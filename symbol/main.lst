# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000
  51  4000              ; BASIC error codes
  52  4000              ;01 NEXT without FOR
  53  4000              ;02 Syntax error
  54  4000              ;03 RETURN without GOSUB
  55  4000              ;04 Out of DATA
  56  4000              ;05 Illegal function call
  57  4000              ;06 Overflow
  58  4000              ;07 Out of memory
  59  4000              ;08 Undefined line number
  60  4000              ;09 Subscript out of range
  61  4000              ;10 Redimensioned array
  62  4000              ;11 Division by zero
  63  4000              ;12 Illegal direct
  64  4000              ;13 Type mismatch
  65  4000              ;14 Out of string space
  66  4000              ;15 String too long
  67  4000              ;16 String formula too complex
  68  4000              ;17 Can't CONTINUE
  69  4000              ;18 Undefined user function
  70  4000              ;19 Device I/O error
  71  4000              ;20 Verify error
  72  4000              ;21 No RESUME
  73  4000              ;22 RESUME without error
  74  4000              ;23 Unprintable error
  75  4000              ;24 Missing operand
  76  4000              ;25 Line buffer overflow
  77  4000              ;50 FIELD overflow
  78  4000              ;51 Internal error
  79  4000              ;52 Bad file number
  80  4000              ;53 File not found
  81  4000              ;54 File already open
  82  4000              ;55 Input past end
  83  4000              ;56 Bad file name
  84  4000              ;57 Direct statement in file
  85  4000              ;58 Sequential I/O only
  86  4000              ;59 File not OPEN
  87  4000
  88  4000
  89  4000               ; simulate cartridge with BASIC extension
  90  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  90  4004 24 54 00 00
  90  4008 00 00 00 00
  90  400C 00 00 00 00
  91  4010
  92  4010              ; this location #4010 stores last location used by basic extension
  93  4010              ; free memory after that point
  94  4010              FREEMEMPTR:
  95  4010 09 5D         DW EXT_END
  96  4012
  97  4012              ; this location #4012 stores extension version in DAA format
  98  4012              ; first byte is major version and second minor
  99  4012              VERSION:
 100  4012 00 70         DB #00, #70
 101  4014
 102  4014              ; binary included AKG player compiled at #4014
 103  4014               IF (SOUND_CMDS == 1)
 104  4014              	INCBIN "bin/AKG.bin"
 105  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 106  4CF0               ENDIF
 107  4CF0
 108  4CF0              ORIG.HTIMI:
 109  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 109  4CF4 00
 110  4CF5               EXPORT ORIG.HTIMI
 111  4CF5
 112  4CF5               IF (SOUND_CMDS == 1)
 113  4CF5              MUSIC_INIT_STATUS:
 114  4CF5 00            DB 0
 115  4CF6              SFX_INIT_STATUS:
 116  4CF6 00            DB 0
 117  4CF7              SOUND_ENABLED:
 118  4CF7 00            DB 0
 119  4CF8               ENDIF
 120  4CF8
 121  4CF8               IF (SPRITE_CMDS == 1)
 122  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 3E 53     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 61 54     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 61 54     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 61 54     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 61 54     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 81 54     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 81 54     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 81 54     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 61 54     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 61 54     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 61 54     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 61 54     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 61 54     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 61 54     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 81 54     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 81 54     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 61 54     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 61 54     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 61 54     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 61 54     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 61 54     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 54 53         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD 9B 53         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD 8B 53         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 123  4F4D               ENDIF
 124  4F4D
 125  4F4D               IF (ANIM_CMDS == 1)
 126  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E 09 5D         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 09 5D         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 09 5D         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; ANIMATION DEFINITION
  31+ 4F56              ; byte number of items 1-15
  32+ 4F56              ; byte[15] anim_item;
  33+ 4F56              ; total size = 16b
  34+ 4F56
  35+ 4F56              ; SPRITE ANIMATION
  36+ 4F56              ; byte sprite number;
  37+ 4F56              ; word time;
  38+ 4F56              ; byte current item;
  39+ 4F56              ; byte animation definition;
  40+ 4F56              ; byte cyclic;
  41+ 4F56              ; byte active;
  42+ 4F56              ; byte reserved
  43+ 4F56              ; total size = 8b
  44+ 4F56
  45+ 4F56              ; *******************************************************************************************************
  46+ 4F56              ; helper function HL=A*5
  47+ 4F56              ; changes HL,DE;
  48+ 4F56              Ax5:
  49+ 4F56 26 00            LD H,0
  50+ 4F58 6F               LD L,A
  51+ 4F59 54               LD D,H
  52+ 4F5A 5D               LD E,L
  53+ 4F5B 29               ADD HL,HL
  54+ 4F5C 29               ADD HL,HL
  55+ 4F5D 19               ADD HL,DE
  56+ 4F5E C9               RET
  57+ 4F5F              ; *******************************************************************************************************
  58+ 4F5F
  59+ 4F5F              ; *******************************************************************************************************
  60+ 4F5F              ; function to handle CALL MAXANIMITEMS basic extension
  61+ 4F5F              ; MAXANIMITEMS (BYTE number)
  62+ 4F5F              ; sets new number and moves memory buffers as needed
  63+ 4F5F              MAXANIMITEMS:
  64+ 4F5F              	; opening (
  65+ 4F5F CD 61 54     	CALL CHKCHAR
  66+ 4F62 28           	DB '('
  67+ 4F63              	; get value
  68+ 4F63 DD 21 1C 52  	LD IX, GETBYT
  69+ 4F67 CD 59 01     	CALL CALBAS
  70+ 4F6A F5               PUSH AF
  71+ 4F6B              	; ending )
  72+ 4F6B CD 61 54     	CALL CHKCHAR
  73+ 4F6E 29           	DB ')'
  74+ 4F6F F1               POP AF
  75+ 4F70
  76+ 4F70              	; save position
  77+ 4F70 E5           	PUSH HL
  78+ 4F71              .ENTRY:
  79+ 4F71 47               LD B,A
  80+ 4F72 3A 4D 4F         LD A,(ANIMITEMNUM)
  81+ 4F75 90               SUB B
  82+ 4F76 28 1F            JR Z, .EXIT; same value as before
  83+ 4F78 FD 21 51 4F      LD IY,ANIMDEFPTR
  84+ 4F7C FA 9A 4F         JP M, .INCREASE
  85+ 4F7F                  ; new value is lower than previous one
  86+ 4F7F CD B2 4F         CALL .SIZEDIFF
  87+ 4F82 CD CD 4F         CALL .DECREASE_COMMON
  88+ 4F85 2A 54 4F         LD HL,(ANIMSPRPTR)
  89+ 4F88 AF               XOR A
  90+ 4F89 ED 42            SBC HL,BC
  91+ 4F8B 22 54 4F         LD (ANIMSPRPTR),HL
  92+ 4F8E              .E1:
  93+ 4F8E 2A 10 40         LD HL,(FREEMEMPTR)
  94+ 4F91 AF               XOR A
  95+ 4F92 ED 42            SBC HL,BC
  96+ 4F94 22 10 40         LD (FREEMEMPTR),HL
  97+ 4F97              .EXIT:
  98+ 4F97 FB               EI
  99+ 4F98 E1           	POP HL
 100+ 4F99 C9           	RET
 101+ 4F9A              .INCREASE:
 102+ 4F9A ED 44            NEG
 103+ 4F9C CD B2 4F         CALL .SIZEDIFF
 104+ 4F9F CD F9 4F         CALL .INCREASE_COMMON
 105+ 4FA2 2A 54 4F         LD HL,(ANIMSPRPTR)
 106+ 4FA5 09               ADD HL,BC
 107+ 4FA6 22 54 4F         LD (ANIMSPRPTR),HL
 108+ 4FA9              .E2:
 109+ 4FA9 2A 10 40         LD HL,(FREEMEMPTR)
 110+ 4FAC 09               ADD HL,BC
 111+ 4FAD 22 10 40         LD (FREEMEMPTR),HL
 112+ 4FB0 18 E5            JR .EXIT
 113+ 4FB2              .SIZEDIFF:
 114+ 4FB2 CD 56 4F         CALL Ax5
 115+ 4FB5 78               LD A,B
 116+ 4FB6 32 4D 4F         LD (ANIMITEMNUM),A
 117+ 4FB9 44               LD B,H
 118+ 4FBA 4D               LD C,L
 119+ 4FBB C9               RET ; BC=size difference in bytes
 120+ 4FBC              .SIZETOMOVE:
 121+ 4FBC D5               PUSH DE
 122+ 4FBD 2A 10 40         LD HL,(FREEMEMPTR)
 123+ 4FC0 FD 5E 00         LD E,(IY)
 124+ 4FC3 FD 56 01         LD D,(IY+1)
 125+ 4FC6 AF               XOR A
 126+ 4FC7 ED 52            SBC HL,DE
 127+ 4FC9 44               LD B,H
 128+ 4FCA 4D               LD C,L
 129+ 4FCB D1               POP DE
 130+ 4FCC C9               RET
 131+ 4FCD              .DECREASE_COMMON:
 132+ 4FCD FD 6E 00         LD L,(IY)
 133+ 4FD0 FD 66 01         LD H,(IY+1)
 134+ 4FD3 AF               XOR A
 135+ 4FD4 ED 42            SBC HL,BC
 136+ 4FD6 EB               EX DE,HL
 137+ 4FD7 C5               PUSH BC
 138+ 4FD8 CD BC 4F         CALL .SIZETOMOVE
 139+ 4FDB F3               DI
 140+ 4FDC 78               LD A,B
 141+ 4FDD B1               OR C
 142+ 4FDE 28 08            JR Z,.L1
 143+ 4FE0 FD 6E 00         LD L,(IY)
 144+ 4FE3 FD 66 01         LD H,(IY+1)
 145+ 4FE6 ED B0            LDIR
 146+ 4FE8              .L1:
 147+ 4FE8 C1               POP BC
 148+ 4FE9 FD 6E 00         LD L,(IY)
 149+ 4FEC FD 66 01         LD H,(IY+1)
 150+ 4FEF AF               XOR A
 151+ 4FF0 ED 42            SBC HL,BC
 152+ 4FF2 FD 75 00         LD (IY),L
 153+ 4FF5 FD 74 01         LD (IY+1),H
 154+ 4FF8 C9               RET
 155+ 4FF9              .INCREASE_COMMON:
 156+ 4FF9 2A 10 40         LD HL,(FREEMEMPTR)
 157+ 4FFC 2B               DEC HL
 158+ 4FFD AF               XOR A
 159+ 4FFE ED 42            SBC HL,BC
 160+ 5000 EB               EX DE,HL
 161+ 5001 C5               PUSH BC
 162+ 5002 CD BC 4F         CALL .SIZETOMOVE
 163+ 5005 F3               DI
 164+ 5006 78               LD A,B
 165+ 5007 B1               OR C
 166+ 5008 28 06            JR Z,.L2
 167+ 500A 2A 10 40         LD HL,(FREEMEMPTR)
 168+ 500D 2B               DEC HL
 169+ 500E ED B8            LDDR
 170+ 5010              .L2:
 171+ 5010 C1               POP BC
 172+ 5011 FD 6E 00         LD L,(IY)
 173+ 5014 FD 66 01         LD H,(IY+1)
 174+ 5017 09               ADD HL,BC
 175+ 5018 FD 75 00         LD (IY),L
 176+ 501B FD 74 01         LD (IY+1),H
 177+ 501E C9               RET
 178+ 501F              ; *******************************************************************************************************
 179+ 501F
 180+ 501F              ; *******************************************************************************************************
 181+ 501F              ; function to handle CALL ANIMITEMPAT basic extension
 182+ 501F              ; ANIMITEMPAT ( BYTE id,
 183+ 501F              ;               INT ticks,
 184+ 501F              ;               BYTE pattern,
 185+ 501F              ;               BYTE color )
 186+ 501F              ; fills animation item data, returns an error if out of bounds
 187+ 501F              ANIMITEMPAT:
 188+ 501F                  ; opening (
 189+ 501F CD 61 54     	CALL CHKCHAR
 190+ 5022 28           	DB '('
 191+ 5023              	; get id
 192+ 5023 DD 21 1C 52  	LD IX, GETBYT
 193+ 5027 CD 59 01     	CALL CALBAS
 194+ 502A F5               PUSH AF
 195+ 502B                  ; check if out of bounds
 196+ 502B 3C               INC A
 197+ 502C 4F               LD C,A
 198+ 502D 3A 4D 4F         LD A,(ANIMITEMNUM)
 199+ 5030 B9               CP C
 200+ 5031 DA 77 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 201+ 5034              	; comma
 202+ 5034 CD 61 54     	CALL CHKCHAR
 203+ 5037 2C           	DB ','
 204+ 5038              	; get ticks
 205+ 5038 DD 21 2F 54  	LD IX, FRMQNT
 206+ 503C CD 59 01     	CALL CALBAS
 207+ 503F D5           	PUSH DE
 208+ 5040              	; comma
 209+ 5040 CD 61 54     	CALL CHKCHAR
 210+ 5043 2C           	DB ','
 211+ 5044              	; get pattern
 212+ 5044 DD 21 1C 52  	LD IX, GETBYT
 213+ 5048 CD 59 01     	CALL CALBAS
 214+ 504B F5               PUSH AF
 215+ 504C              	; comma
 216+ 504C CD 61 54     	CALL CHKCHAR
 217+ 504F 2C           	DB ','
 218+ 5050              	; get color
 219+ 5050 DD 21 1C 52  	LD IX, GETBYT
 220+ 5054 CD 59 01     	CALL CALBAS
 221+ 5057 F5               PUSH AF
 222+ 5058              	; ending )
 223+ 5058 CD 61 54     	CALL CHKCHAR
 224+ 505B 29           	DB ')'
 225+ 505C              .ENTRY:
 226+ 505C E5               PUSH HL
 227+ 505D DD E1            POP IX
 228+ 505F D9               EXX
 229+ 5060 C1               POP BC ; color
 230+ 5061 D1               POP DE ; pattern
 231+ 5062 E1               POP HL ; ticks
 232+ 5063 D9               EXX
 233+ 5064 F1               POP AF
 234+ 5065 CD 56 4F         CALL Ax5
 235+ 5068 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 236+ 506C 19               ADD HL,DE
 237+ 506D E5               PUSH HL
 238+ 506E FD E1            POP IY
 239+ 5070 D9               EXX
 240+ 5071 FD 36 00 00      LD (IY),0 ; type=0
 241+ 5075 FD 75 01         LD (IY+1),L
 242+ 5078 FD 74 02         LD (IY+2),H
 243+ 507B FD 72 03         LD (IY+3),D
 244+ 507E FD 70 04         LD (IY+4),B
 245+ 5081
 246+ 5081 DD E5            PUSH IX
 247+ 5083 E1               POP HL
 248+ 5084 C9               RET
 249+ 5085              ; *******************************************************************************************************
 250+ 5085
 251+ 5085              ; *******************************************************************************************************
 252+ 5085              ; function to handle CALL ANIMITEMPTR basic extension
 253+ 5085              ; ANIMITEMPTR ( BYTE id,
 254+ 5085              ;               INT ticks,
 255+ 5085              ;               INT pointer,
 256+ 5085              ; fills animation item data, returns an error if out of bounds
 257+ 5085              ANIMITEMPTR_CMD:
 258+ 5085                  ; opening (
 259+ 5085 CD 61 54     	CALL CHKCHAR
 260+ 5088 28           	DB '('
 261+ 5089              	; get id
 262+ 5089 DD 21 1C 52  	LD IX, GETBYT
 263+ 508D CD 59 01     	CALL CALBAS
 264+ 5090 F5               PUSH AF
 265+ 5091                  ; check if out of bounds
 266+ 5091 3C               INC A
 267+ 5092 4F               LD C,A
 268+ 5093 3A 4D 4F         LD A,(ANIMITEMNUM)
 269+ 5096 B9               CP C
 270+ 5097 DA 77 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 271+ 509A              	; comma
 272+ 509A CD 61 54     	CALL CHKCHAR
 273+ 509D 2C           	DB ','
 274+ 509E              	; get ticks
 275+ 509E DD 21 2F 54  	LD IX, FRMQNT
 276+ 50A2 CD 59 01     	CALL CALBAS
 277+ 50A5 D5           	PUSH DE
 278+ 50A6              	; comma
 279+ 50A6 CD 61 54     	CALL CHKCHAR
 280+ 50A9 2C           	DB ','
 281+ 50AA              	; get pointer
 282+ 50AA DD 21 2F 54  	LD IX, FRMQNT
 283+ 50AE CD 59 01     	CALL CALBAS
 284+ 50B1 D5           	PUSH DE
 285+ 50B2              	; ending )
 286+ 50B2 CD 61 54     	CALL CHKCHAR
 287+ 50B5 29           	DB ')'
 288+ 50B6              .ENTRY:
 289+ 50B6 E5               PUSH HL
 290+ 50B7 DD E1            POP IX
 291+ 50B9 D9               EXX
 292+ 50BA D1               POP DE ; pointer
 293+ 50BB E1               POP HL ; ticks
 294+ 50BC D9               EXX
 295+ 50BD F1               POP AF
 296+ 50BE CD 56 4F         CALL Ax5
 297+ 50C1 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 298+ 50C5 19               ADD HL,DE
 299+ 50C6 E5               PUSH HL
 300+ 50C7 FD E1            POP IY
 301+ 50C9 D9               EXX
 302+ 50CA FD 36 00 01      LD (IY),1 ; type=1
 303+ 50CE FD 75 01         LD (IY+1),L
 304+ 50D1 FD 74 02         LD (IY+2),H
 305+ 50D4 FD 73 03         LD (IY+3),E
 306+ 50D7 FD 72 04         LD (IY+4),D
 307+ 50DA
 308+ 50DA DD E5            PUSH IX
 309+ 50DC E1               POP HL
 310+ 50DD C9               RET
 311+ 50DE              ; *******************************************************************************************************
 312+ 50DE
 313+ 50DE              ; *******************************************************************************************************
 314+ 50DE              ; function to handle CALL MAXANIMDEFS basic extension
 315+ 50DE              ; MAXANIMDEFS (BYTE number)
 316+ 50DE              ; sets new number and moves memory buffers as needed
 317+ 50DE              MAXANIMDEFS:
 318+ 50DE              	; opening (
 319+ 50DE CD 61 54     	CALL CHKCHAR
 320+ 50E1 28           	DB '('
 321+ 50E2              	; get value
 322+ 50E2 DD 21 1C 52  	LD IX, GETBYT
 323+ 50E6 CD 59 01     	CALL CALBAS
 324+ 50E9 F5               PUSH AF
 325+ 50EA              	; ending )
 326+ 50EA CD 61 54     	CALL CHKCHAR
 327+ 50ED 29           	DB ')'
 328+ 50EE F1               POP AF
 329+ 50EF
 330+ 50EF              	; save position
 331+ 50EF E5           	PUSH HL
 332+ 50F0              .ENTRY:
 333+ 50F0 47               LD B,A
 334+ 50F1 3A 50 4F         LD A,(ANIMDEFNUM)
 335+ 50F4 90               SUB B
 336+ 50F5 CA 97 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 337+ 50F8 FD 21 54 4F      LD IY,ANIMSPRPTR
 338+ 50FC FA 08 51         JP M, .INCREASE
 339+ 50FF                  ; new value is lower than previous one
 340+ 50FF CD 13 51         CALL .SIZEDIFF
 341+ 5102 CD CD 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 342+ 5105 C3 8E 4F         JP MAXANIMITEMS.E1
 343+ 5108              .INCREASE:
 344+ 5108 ED 44            NEG
 345+ 510A CD 13 51         CALL .SIZEDIFF
 346+ 510D CD F9 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 347+ 5110 C3 A9 4F         JP MAXANIMITEMS.E2
 348+ 5113              .SIZEDIFF:
 349+ 5113 26 00            LD H,0
 350+ 5115 6F               LD L,A
 351+ 5116 CD 4F 53         CALL HLx16
 352+ 5119 78               LD A,B
 353+ 511A 32 50 4F         LD (ANIMDEFNUM),A
 354+ 511D 44               LD B,H
 355+ 511E 4D               LD C,L
 356+ 511F C9               RET ; BC=size difference in bytes
 357+ 5120              ; *******************************************************************************************************
 358+ 5120
 359+ 5120              ; *******************************************************************************************************
 360+ 5120              ; function to handle CALL ANIMDEF basic extension
 361+ 5120              ; ANIMITEMPAT ( BYTE id,
 362+ 5120              ;               BYTE size,
 363+ 5120              ;               INT[] list )
 364+ 5120              ; fills animation definition data, returns an error if out of bounds, or invalid type
 365+ 5120              ANIMDEF:
 366+ 5120                  ; opening (
 367+ 5120 CD 61 54     	CALL CHKCHAR
 368+ 5123 28           	DB '('
 369+ 5124              	; get id
 370+ 5124 DD 21 1C 52  	LD IX, GETBYT
 371+ 5128 CD 59 01     	CALL CALBAS
 372+ 512B F5               PUSH AF
 373+ 512C                  ; check if out of bounds
 374+ 512C 3C               INC A
 375+ 512D 4F               LD C,A
 376+ 512E 3A 50 4F         LD A,(ANIMDEFNUM)
 377+ 5131 B9               CP C
 378+ 5132 DA 77 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 379+ 5135              	; comma
 380+ 5135 CD 61 54     	CALL CHKCHAR
 381+ 5138 2C           	DB ','
 382+ 5139              	; get size
 383+ 5139 DD 21 1C 52  	LD IX, GETBYT
 384+ 513D CD 59 01     	CALL CALBAS
 385+ 5140 FE 10            CP 16
 386+ 5142 D2 7B 54         JP NC, OVERFLOW
 387+ 5145 B7               OR A
 388+ 5146 CA 7B 54         JP Z, OVERFLOW
 389+ 5149 F5           	PUSH AF
 390+ 514A              	; comma
 391+ 514A CD 61 54     	CALL CHKCHAR
 392+ 514D 2C           	DB ','
 393+ 514E              	; get pointer to a list of animation items in integer array format
 394+ 514E 3E 01            LD A,1
 395+ 5150 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 396+ 5153 DD 21 A4 5E  	LD IX, PTRGET
 397+ 5157 CD 59 01     	CALL CALBAS
 398+ 515A                  ; contrary to documentation we get a pointer to array dimension in BC
 399+ 515A                  ; and type in VALTYP
 400+ 515A 3A 63 F6         LD A,(VALTYP)
 401+ 515D FE 02            CP 2
 402+ 515F C2 73 54         JP NZ,TYPE_MISMATCH
 403+ 5162 0A               LD A,(BC)
 404+ 5163 FE 01            CP 1
 405+ 5165 C2 73 54         JP NZ,TYPE_MISMATCH
 406+ 5168 03               INC BC
 407+ 5169 0A               LD A,(BC)
 408+ 516A D1               POP DE
 409+ 516B D5               PUSH DE
 410+ 516C 3C               INC A
 411+ 516D BA               CP D
 412+ 516E DA 77 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 413+ 5171 03          > INC BC
 413+ 5172 03          > INC BC
 414+ 5173 C5               PUSH BC
 415+ 5174              	; ending )
 416+ 5174 CD 61 54     	CALL CHKCHAR
 417+ 5177 29           	DB ')'
 418+ 5178              .ENTRY:
 419+ 5178 E5               PUSH HL
 420+ 5179 DD E1            POP IX
 421+ 517B D1               POP DE ; pointer to INT array
 422+ 517C C1               POP BC ; B=item number
 423+ 517D F1               POP AF ; id
 424+ 517E 26 00            LD H,0
 425+ 5180 6F               LD L,A
 426+ 5181 CD 4F 53         CALL HLx16
 427+ 5184 D5               PUSH DE
 428+ 5185 ED 5B 51 4F      LD DE,(ANIMDEFPTR)
 429+ 5189 19               ADD HL,DE
 430+ 518A D1               POP DE
 431+ 518B 70               LD (HL),B
 432+ 518C              .L1:
 433+ 518C 23               INC HL
 434+ 518D 1A               LD A,(DE)
 435+ 518E 13          > INC DE
 435+ 518F 13          > INC DE
 436+ 5190 77               LD (HL),A
 437+ 5191 10 F9            DJNZ .L1
 438+ 5193 DD E5            PUSH IX
 439+ 5195 E1               POP HL
 440+ 5196 C9               RET
 441+ 5197              ; *******************************************************************************************************
 442+ 5197
 443+ 5197              ; *******************************************************************************************************
 444+ 5197              ; function to handle CALL MAXANIMSPRS basic extension
 445+ 5197              ; MAXANIMSPRS (BYTE number)
 446+ 5197              ; sets new number and moves memory buffers as needed
 447+ 5197              MAXANIMSPRS:
 448+ 5197              	; opening (
 449+ 5197 CD 61 54     	CALL CHKCHAR
 450+ 519A 28           	DB '('
 451+ 519B              	; get value
 452+ 519B DD 21 1C 52  	LD IX, GETBYT
 453+ 519F CD 59 01     	CALL CALBAS
 454+ 51A2 F5               PUSH AF
 455+ 51A3              	; ending )
 456+ 51A3 CD 61 54     	CALL CHKCHAR
 457+ 51A6 29           	DB ')'
 458+ 51A7 F1               POP AF
 459+ 51A8
 460+ 51A8              	; save position
 461+ 51A8 E5           	PUSH HL
 462+ 51A9              .ENTRY:
 463+ 51A9 47               LD B,A
 464+ 51AA 3A 53 4F         LD A,(ANIMSPRNUM)
 465+ 51AD 90               SUB B
 466+ 51AE CA 97 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 467+ 51B1 FD 21 10 40      LD IY,FREEMEMPTR
 468+ 51B5 FA C1 51         JP M, .INCREASE
 469+ 51B8                  ; new value is lower than previous one
 470+ 51B8 CD CC 51         CALL .SIZEDIFF
 471+ 51BB CD CD 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 472+ 51BE C3 97 4F         JP MAXANIMITEMS.EXIT
 473+ 51C1              .INCREASE:
 474+ 51C1 ED 44            NEG
 475+ 51C3 CD CC 51         CALL .SIZEDIFF
 476+ 51C6 CD F9 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 477+ 51C9 C3 97 4F         JP MAXANIMITEMS.EXIT
 478+ 51CC              .SIZEDIFF:
 479+ 51CC 26 00            LD H,0
 480+ 51CE 6F               LD L,A
 481+ 51CF CD 50 53         CALL HLx8
 482+ 51D2 78               LD A,B
 483+ 51D3 32 53 4F         LD (ANIMSPRNUM),A
 484+ 51D6 44               LD B,H
 485+ 51D7 4D               LD C,L
 486+ 51D8 C9               RET ; BC=size difference in bytes
 487+ 51D9              ; *******************************************************************************************************
# file closed: asm\ANIMATION.asm
 127  51D9               ENDIF
 128  51D9
 129  51D9              ; temp variables for BLIT, TILE functions
 130  51D9               IF (BLIT_CMDS + TILE_CMDS > 0)
 131  51D9              BLIT_TMP:
 132  51D9              TILETMP1:
 133  51D9              BLIT_TMP1:
 134  51D9 00 00         DW 0
 135  51DB              TILETMP2:
 136  51DB              BLIT_TMP2:
 137  51DB 00 00         DW 0
 138  51DD                IFDEF CMDS_WITH_PARAMETERS
 139  51DD              BLIT_STRUCT:
 140  51DD 00 00 00...   DS 17
 141  51E1                ENDIF
 142  51E1               ENDIF
 143  51EE
 144  51EE              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 145  51EE              ; per starting letter, if no commands with this letter, NULL value
 146  51EE              CMDS:
 147  51EE               IF (ANIM_CMDS == 1)
 148  51EE 17 53        	DW CMDS_A ;
 149  51F0               ELSE
 150  51F0 ~                DW 0 ; A
 151  51F0               ENDIF
 152  51F0               IF (BLIT_CMDS + BOX_CMDS > 0)
 153  51F0 E2 52            DW CMDS_B ; B
 154  51F2               ELSE
 155  51F2 ~            	DW 0
 156  51F2               ENDIF
 157  51F2 00 00            DW 0 ; C
 158  51F4 00 00            DW 0 ; D
 159  51F6 00 00            DW 0 ; E
 160  51F8               IF (VRAM_CMDS + RAM_CMDS > 0)
 161  51F8 60 52            DW CMDS_F; F
 162  51FA               ELSE
 163  51FA ~            	DW 0
 164  51FA               ENDIF
 165  51FA               IF (GENCAL_CMD > 0)
 166  51FA 73 52            DW CMDS_G; G
 167  51FC               ELSE
 168  51FC ~            	DW 0
 169  51FC               ENDIF
 170  51FC 00 00            DW 0 ; H
 171  51FE 00 00            DW 0 ; I
 172  5200 00 00            DW 0 ; J
 173  5202 00 00            DW 0 ; K
 174  5204 00 00            DW 0 ; L
 175  5206               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 176  5206 22 52            DW CMDS_M ; M
 177  5208               ELSE
 178  5208 ~            	DW 0
 179  5208               ENDIF
 180  5208 00 00            DW 0 ; N
 181  520A 00 00            DW 0 ; O
 182  520C 00 00            DW 0 ; P
 183  520E 00 00            DW 0 ; Q
 184  5210 00 00            DW 0 ; R
 185  5212               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 186  5212 87 52            DW CMDS_S ; S
 187  5214               ELSE
 188  5214 ~            	DW 0
 189  5214               ENDIF
 190  5214               IF (TILE_CMDS > 0)
 191  5214 02 53            DW CMDS_T ; T
 192  5216               ELSE
 193  5216 ~            	DW 0
 194  5216               ENDIF
 195  5216 00 00            DW 0 ; U
 196  5218               IF (VRAM_CMDS > 0)
 197  5218 7D 52            DW CMDS_V ; V
 198  521A               ELSE
 199  521A ~            	DW 0
 200  521A               ENDIF
 201  521A 00 00            DW 0 ; W
 202  521C 00 00            DW 0 ; X
 203  521E 00 00            DW 0 ; Y
 204  5220 00 00            DW 0 ; Z
 205  5222
 206  5222              CMDS_M:
 207  5222               IF (VRAM_CMDS == 1)
 208  5222 4D 45 4D 56      DB "MEMVRM", 0
 208  5226 52 4D 00
 209  5229 C9 55            DW MEMVRM
 210  522B               ENDIF
 211  522B               IF (RAM_CMDS == 1)
 212  522B 4D 45 4D 43  	DB "MEMCPY", 0
 212  522F 50 59 00
 213  5232 88 54        	DW MEMCPY
 214  5234               ENDIF
 215  5234               IF (ANIM_CMDS == 1)
 216  5234 4D 41 58 41  	DB "MAXANIMITEMS",0
 216  5238 4E 49 4D 49
 216  523C 54 45 4D 53
 216  5240 00
 217  5241 5F 4F        	DW MAXANIMITEMS
 218  5243 4D 41 58 41  	DB "MAXANIMDEFS",0
 218  5247 4E 49 4D 44
 218  524B 45 46 53 00
 219  524F DE 50        	DW MAXANIMDEFS
 220  5251 4D 41 58 41  	DB "MAXANIMSPRS",0
 220  5255 4E 49 4D 53
 220  5259 50 52 53 00
 221  525D 97 51        	DW MAXANIMSPRS
 222  525F               ENDIF
 223  525F               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 224  525F 00           	DB 0
 225  5260               ENDIF
 226  5260              CMDS_F:
 227  5260               IF (VRAM_CMDS == 1)
 228  5260 46 49 4C 56      DB "FILVRM", 0
 228  5264 52 4D 00
 229  5267 CB 54            DW FILVRM
 230  5269               ENDIF
 231  5269               IF (RAM_CMDS == 1)
 232  5269 46 49 4C 52      DB "FILRAM", 0
 232  526D 41 4D 00
 233  5270 12 55            DW FILRAM
 234  5272               ENDIF
 235  5272               IF (VRAM_CMDS + RAM_CMDS > 0)
 236  5272 00               DB 0
 237  5273               ENDIF
 238  5273              CMDS_G:
 239  5273               IF (GENCAL_CMD == 1)
 240  5273 47 45 4E 43      DB "GENCAL", 0
 240  5277 41 4C 00
 241  527A 70 55            DW GENCAL
 242  527C               ENDIF
 243  527C               IF (GENCAL_CMD > 0)
 244  527C 00           	DB	0
 245  527D               ENDIF
 246  527D              CMDS_V:
 247  527D               IF (VRAM_CMDS == 1)
 248  527D 56 52 4D 4D  	DB "VRMMEM", 0
 248  5281 45 4D 00
 249  5284 41 56        	DW VRMMEM
 250  5286               ENDIF
 251  5286               IF (VRAM_CMDS > 0)
 252  5286 00           	DB 0
 253  5287               ENDIF
 254  5287              CMDS_S:
 255  5287               IF (SPRITE_CMDS == 1)
 256  5287 53 50 52 53  	DB "SPRSET", 0
 256  528B 45 54 00
 257  528E 0E 4E        	DW SPRSET
 258  5290 53 50 52 47  	DB "SPRGRPMOV", 0
 258  5294 52 50 4D 4F
 258  5298 56 00
 259  529A CC 4E        	DW SPRGRPMOV
 260  529C               ENDIF
 261  529C               IF (SOUND_CMDS == 1)
 262  529C 53 4E 44 53  	DB "SNDSFX", 0
 262  52A0 46 58 00
 263  52A3 7F 57        	DW SNDSFX
 264  52A5 53 4E 44 50  	DB "SNDPLYON", 0
 264  52A9 4C 59 4F 4E
 264  52AD 00
 265  52AE 49 57        	DW SNDPLYON
 266  52B0 53 4E 44 50  	DB "SNDPLYOFF", 0
 266  52B4 4C 59 4F 46
 266  52B8 46 00
 267  52BA 5C 57        	DW SNDPLYOFF
 268  52BC 53 4E 44 50  	DB "SNDPLYINI", 0
 268  52C0 4C 59 49 4E
 268  52C4 49 00
 269  52C6 FF 56        	DW SNDPLYINIT
 270  52C8               ENDIF
 271  52C8               IF (SPRITE_CMDS == 1)
 272  52C8 53 50 52 45  	DB "SPRENABLE", 0
 272  52CC 4E 41 42 4C
 272  52D0 45 00
 273  52D2 B9 4D        	DW SPRENABLE
 274  52D4 53 50 52 44  	DB "SPRDISABLE", 0
 274  52D8 49 53 41 42
 274  52DC 4C 45 00
 275  52DF 09 4E        	DW SPRDISABLE
 276  52E1               ENDIF
 277  52E1               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 278  52E1 00           	DB 0
 279  52E2               ENDIF
 280  52E2              CMDS_B:
 281  52E2               IF (BLIT_CMDS == 1)
 282  52E2 42 4C 49 54  	DB "BLIT", 0
 282  52E6 00
 283  52E7 56 59        	DW BLIT
 284  52E9               ENDIF
 285  52E9               IF (BOX_CMDS == 1)
 286  52E9 42 4F 58 4D  	DB "BOXMEMCPY", 0
 286  52ED 45 4D 43 50
 286  52F1 59 00
 287  52F3 8E 5C        	DW BOXMEMCPY
 288  52F5 42 4F 58 4D  	DB "BOXMEMVRM", 0
 288  52F9 45 4D 56 52
 288  52FD 4D 00
 289  52FF C2 5C        	DW BOXMEMVRM
 290  5301               ENDIF
 291  5301               IF (BLIT_CMDS + BOX_CMDS > 0)
 292  5301 00           	DB 0
 293  5302               ENDIF
 294  5302              CMDS_T:
 295  5302               IF (TILE_CMDS == 1)
 296  5302 54 49 4C 45  	DB "TILERAM", 0
 296  5306 52 41 4D 00
 297  530A 9A 5A        	DW TILERAM
 298  530C 54 49 4C 45  	DB "TILEVRM", 0
 298  5310 56 52 4D 00
 299  5314 9D 5B        	DW TILEVRM
 300  5316               ENDIF
 301  5316               IF (TILE_CMDS > 0)
 302  5316 00           	DB 0
 303  5317               ENDIF
 304  5317              CMDS_A:
 305  5317               IF (ANIM_CMDS == 1)
 306  5317 41 4E 49 4D  	DB "ANIMITEMPAT",0
 306  531B 49 54 45 4D
 306  531F 50 41 54 00
 307  5323 1F 50        	DW ANIMITEMPAT
 308  5325 41 4E 49 4D  	DB "ANIMITEMPTR",0
 308  5329 49 54 45 4D
 308  532D 50 54 52 00
 309  5331 85 50        	DW ANIMITEMPTR_CMD
 310  5333 41 4E 49 4D  	DB "ANIMDEF",0
 310  5337 44 45 46 00
 311  533B 20 51        	DW ANIMDEF
 312  533D 00           	DB 0
 313  533E               ENDIF
 314  533E
 315  533E               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 316  533E              ; ****************************************************************************************************
 317  533E              ; function sets VRAM address
 318  533E              ; input HL=address
 319  533E              ; modifies AF
 320  533E              SETWRT_LOCAL:
 321  533E 7D           	LD	A, L
 322  533F D3 99        	OUT	(099H), A
 323  5341 7C           	LD	A, H
 324  5342 E6 3F        	AND	03FH
 325  5344 F6 40        	OR	040H
 326  5346 D3 99        	OUT	(099H), A
 327  5348 C9           	RET
 328  5349              ; ****************************************************************************************************
 329  5349               ENDIF
 330  5349
 331  5349               IF (VRAM_CMDS + TILE_CMDS > 0)
 332  5349              ; ****************************************************************************************************
 333  5349              ; function copies data from RAM to VRAM
 334  5349              ; input HL=address in RAM
 335  5349              ; input B=count
 336  5349              ; modifies AF
 337  5349              BBYTECOPY:
 338  5349 ED A3        	OUTI
 339  534B C2 49 53     	JP	NZ, BBYTECOPY
 340  534E C9           	RET
 341  534F              ; ****************************************************************************************************
 342  534F               ENDIF
 343  534F
 344  534F              ; ****************************************************************************************************
 345  534F              ; function multiplies HL by 16
 346  534F              HLx16:
 347  534F 29           	ADD HL,HL
 348  5350              ; ****************************************************************************************************
 349  5350              ; function multiplies HL by 8
 350  5350              HLx8:
 351  5350 29          > ADD HL, HL
 351  5351 29          > ADD HL, HL
 351  5352 29          > ADD HL, HL
 352  5353 C9           	RET
 353  5354              ; ****************************************************************************************************
 354  5354
 355  5354              ; ****************************************************************************************************
 356  5354              ; function gets slot and subslot data for specific page
 357  5354              ; input A=page (0, 1 or 2)
 358  5354              ; output B = 0A8H register value
 359  5354              ; output D = 0 is no subslots, 1 if yes
 360  5354              ; output C = 0A8H value when page 3 slot equals to requested page slot
 361  5354              ; output E = subslot value if present
 362  5354              ; modifies AF, BC, DE, HL
 363  5354              GET_PAGE_INFO:
 364  5354 6F               LD L, A
 365  5355 C6 C1            ADD A, low (EXPTBL)
 366  5357 32 61 53         LD (GET_PAGE_INFO_L1+1), A
 367  535A DB A8            IN A, (0A8H)
 368  535C 47               LD B, A
 369  535D E6 3F            AND 03FH
 370  535F 4F               LD C, A
 371  5360              GET_PAGE_INFO_L1:
 372  5360 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 373  5363 E6 80            AND 080H
 374  5365 28 1B            JR Z, GET_PAGE_INFO_L2
 375  5367                  ; expanded
 376  5367 2D               DEC L
 377  5368 FA 87 53         JP M, GET_PAGE_INFO_L3
 378  536B 2D               DEC L
 379  536C FA 85 53         JP M, GET_PAGE_INFO_L4
 380  536F                  ; page 2
 381  536F 07               RLCA
 382  5370 07               RLCA
 383  5371              GET_PAGE_INFO_L5:
 384  5371 E6 C0            AND 0C0H
 385  5373 B1               OR C
 386  5374 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 387  5376 4F               LD C, A
 388  5377 3A FF FF         LD A, (0FFFFH)
 389  537A 2F               CPL
 390  537B 5F               LD E, A
 391  537C 16 01            LD D, 1
 392  537E 78               LD A, B ; return stack
 393  537F D3 A8            OUT (0A8H), A
 394  5381 C9               RET
 395  5382              GET_PAGE_INFO_L2:
 396  5382                  ; not expanded
 397  5382 16 00            LD D, 0
 398  5384 C9               RET
 399  5385              GET_PAGE_INFO_L4:
 400  5385                  ; page 1
 401  5385 0F               RRCA
 402  5386 0F               RRCA
 403  5387              GET_PAGE_INFO_L3:
 404  5387                  ; page 0
 405  5387 0F               RRCA
 406  5388 0F               RRCA
 407  5389 18 E6            JR GET_PAGE_INFO_L5
 408  538B              ; ****************************************************************************************************
 409  538B
 410  538B              ; ****************************************************************************************************
 411  538B              ; function returns original slot and subslot info
 412  538B              ; input B = 0A8H register value
 413  538B              ; input D = 0 is no subslots, 1 if yes
 414  538B              ; input C = 0A8H value when page 3 slot equals to requested page slot
 415  538B              ; input E = subslot value if present
 416  538B              ; modifies AF, disables interrupts
 417  538B              RESTORE_PAGE_INFO:
 418  538B 7A               LD A, D
 419  538C B7               OR A
 420  538D 28 08            JR Z, RESTORE_PAGE_INFO_L1
 421  538F 79               LD A, C
 422  5390 F3           	DI
 423  5391 D3 A8            OUT (0A8H), A
 424  5393 7B               LD A, E
 425  5394 32 FF FF         LD (0FFFFH), A
 426  5397              RESTORE_PAGE_INFO_L1:
 427  5397 78               LD A, B
 428  5398 D3 A8            OUT (0A8H), A
 429  539A C9               RET
 430  539B              ; ****************************************************************************************************
 431  539B
 432  539B              ; *******************************************************************************************************
 433  539B              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 434  539B              ; INPUT:  A = SLOT ID: EXXXSSPP
 435  539B              ; E = EXPANDED FLAG
 436  539B              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 437  539B              ; PP = PRIMARY SLOT NUMBER
 438  539B              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 439  539B              ; CHANGES: AF, BC, DE
 440  539B
 441  539B              LOCAL_ENASLT:
 442  539B CD BB 53         CALL L0353
 443  539E FA A8 53         JP M, L0340
 444  53A1 DB A8            IN A, (0A8H)
 445  53A3 A1               AND C
 446  53A4 B0               OR B
 447  53A5 D3 A8            OUT (0A8H), A
 448  53A7 C9               RET
 449  53A8              L0340:
 450  53A8 E5               PUSH HL
 451  53A9 CD E0 53         CALL L0378
 452  53AC 4F               LD C, A
 453  53AD 06 00            LD B, 0
 454  53AF 7D               LD A, L
 455  53B0 A4               AND H
 456  53B1 B2               OR D
 457  53B2 21 C5 FC         LD HL, 0FCC5H
 458  53B5 09               ADD HL, BC
 459  53B6 77               LD (HL), A
 460  53B7 E1               POP HL
 461  53B8 79               LD A, C
 462  53B9 18 E0            JR LOCAL_ENASLT
 463  53BB              L0353:
 464  53BB F3               DI
 465  53BC F5               PUSH AF
 466  53BD 7C               LD A, H
 467  53BE 07               RLCA
 468  53BF 07               RLCA
 469  53C0 E6 03            AND 3
 470  53C2 5F               LD E, A
 471  53C3 3E C0            LD A, 0C0H
 472  53C5              L035D:
 473  53C5 07               RLCA
 474  53C6 07               RLCA
 475  53C7 1D               DEC E
 476  53C8 F2 C5 53         JP P, L035D
 477  53CB 5F               LD E, A
 478  53CC 2F               CPL
 479  53CD 4F               LD C, A
 480  53CE F1               POP AF
 481  53CF F5               PUSH AF
 482  53D0 E6 03            AND 3
 483  53D2 3C               INC A
 484  53D3 47               LD B, A
 485  53D4 3E AB            LD A, 0ABH
 486  53D6              L036E:
 487  53D6 C6 55            ADD A, 055H
 488  53D8 10 FC            DJNZ L036E
 489  53DA 57               LD D, A
 490  53DB A3               AND E
 491  53DC 47               LD B, A
 492  53DD F1               POP AF
 493  53DE A7               AND A
 494  53DF C9               RET
 495  53E0              L0378:
 496  53E0 F5               PUSH AF
 497  53E1 7A               LD A, D
 498  53E2 E6 C0            AND 0C0H
 499  53E4 4F               LD C, A
 500  53E5 F1               POP AF
 501  53E6 F5               PUSH AF
 502  53E7 57               LD D, A
 503  53E8 DB A8            IN A, (0A8H)
 504  53EA 47               LD B, A
 505  53EB E6 3F            AND 03FH
 506  53ED B1               OR C
 507  53EE D3 A8            OUT (0A8H), A
 508  53F0 7A               LD A, D
 509  53F1 0F               RRCA
 510  53F2 0F               RRCA
 511  53F3 E6 03            AND 3
 512  53F5 57               LD D, A
 513  53F6 3E AB            LD A, 0ABH
 514  53F8              L0390:
 515  53F8 C6 55            ADD A, 055H
 516  53FA 15               DEC D
 517  53FB F2 F8 53         JP P, L0390
 518  53FE A3               AND E
 519  53FF 57               LD D, A
 520  5400 7B               LD A, E
 521  5401 2F               CPL
 522  5402 67               LD H, A
 523  5403 3A FF FF         LD A, (0FFFFH)
 524  5406 2F               CPL
 525  5407 6F               LD L, A
 526  5408 A4               AND H
 527  5409 B2               OR D
 528  540A 32 FF FF         LD (0FFFFH), A
 529  540D 78               LD A, B
 530  540E D3 A8            OUT (0A8H), A
 531  5410 F1               POP AF
 532  5411 E6 03            AND 3
 533  5413 C9               RET
 534  5414              ; *******************************************************************************************************
 535  5414
 536  5414              ; *******************************************************************************************************
 537  5414              ; some common code to activate page 0 and place values needed to restore original page on stack
 538  5414              ; input IY=return address
 539  5414              ENABLE_PAGE0:
 540  5414 AF               XOR A
 541  5415 CD 54 53         CALL GET_PAGE_INFO
 542  5418 C5               PUSH BC
 543  5419 D5               PUSH DE
 544  541A 3A 41 F3         LD A, (RAMAD0)
 545  541D 26 00            LD H, 0
 546  541F CD 9B 53         CALL LOCAL_ENASLT
 547  5422 FD E9        	JP (IY)
 548  5424              ; *******************************************************************************************************
 549  5424
 550  5424              ; General BASIC CALL-instruction handler
 551  5424              CALLHAND:
 552  5424 E5           	PUSH HL
 553  5425 21 EE 51     	LD	HL, CMDS ; pointer table based on starting letter
 554  5428 3A 89 FD         LD A, (PROCNM)
 555  542B D6 41            SUB 'A'
 556  542D 87               ADD A, A
 557  542E 16 00            LD D, 0
 558  5430 5F               LD E, A
 559  5431 19               ADD HL, DE
 560  5432 5E               LD E, (HL)
 561  5433 23               INC HL
 562  5434 56               LD D, (HL)
 563  5435 7A               LD A, D
 564  5436 B3               OR E
 565  5437 28 23            JR Z, .CMDNOTRECOGNIZED
 566  5439 EB               EX DE, HL
 567  543A              .CHKCMD:
 568  543A 11 89 FD     	LD	DE, PROCNM
 569  543D 1A           .LOOP:	LD	A,(DE)
 570  543E BE           	CP	(HL)
 571  543F 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 572  5441 13           	INC	DE
 573  5442 23           	INC	HL
 574  5443 A7           	AND	A
 575  5444 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 576  5446 5E           	LD	E,(HL)
 577  5447 23           	INC	HL
 578  5448 56           	LD	D,(HL)
 579  5449 E1           	POP	HL		; routine address
 580  544A CD 6B 54     	CALL	GETPREVCHAR
 581  544D CD 5F 54     	CALL	.CALLDE		; Call routine
 582  5450 A7           	AND	A
 583  5451 C9           	RET
 584  5452
 585  5452              .TONEXTCMD:
 586  5452 0E FF        	LD	C,0FFH
 587  5454 AF           	XOR	A
 588  5455 ED B1        	CPIR			; Skip to end of instruction name
 589  5457 23           	INC	HL
 590  5458 23           	INC	HL		; Skip address
 591  5459 BE           	CP	(HL)
 592  545A 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 593  545C              .CMDNOTRECOGNIZED:
 594  545C E1           	POP	HL
 595  545D 37               SCF
 596  545E C9           	RET
 597  545F
 598  545F              .CALLDE:
 599  545F D5           	PUSH	DE
 600  5460 C9           	RET
 601  5461
 602  5461              ;---------------------------
 603  5461
 604  5461              ;GETSTRPNT:
 605  5461              ; OUT:
 606  5461              ; HL = String Address
 607  5461              ; B  = Lenght
 608  5461              ;        LD      HL,(USR)
 609  5461              ;        LD      B,(HL)
 610  5461              ;        INC     HL
 611  5461              ;        LD      E,(HL)
 612  5461              ;        INC     HL
 613  5461              ;        LD      D,(HL)
 614  5461              ;        EX      DE,HL
 615  5461              ;        RET
 616  5461
 617  5461              ;EVALTXTPARAM:
 618  5461              ;	CALL	CHKCHAR
 619  5461              ;	DEFB	"("             ; Check for (
 620  5461              ;	LD	IX,FRMEVL
 621  5461              ;	CALL	CALBAS		; Evaluate expression
 622  5461              ;       LD      A,(VALTYP)
 623  5461              ;        CP      3               ; Text type?
 624  5461              ;        JP      NZ,TYPE_MISMATCH
 625  5461              ;        PUSH	HL
 626  5461              ;        LD	IX,FRESTR         ; Free the temporary string
 627  5461              ;        CALL	CALBAS
 628  5461              ;        POP	HL
 629  5461              ;	CALL	CHKCHAR
 630  5461              ;	DEFB	")"             ; Check for )
 631  5461              ;        RET
 632  5461
 633  5461
 634  5461              CHKCHAR:
 635  5461 CD 6B 54     	CALL	GETPREVCHAR	; Get previous basic char
 636  5464 E3           	EX	(SP),HL
 637  5465 BE           	CP	(HL) 	        ; Check if good char
 638  5466 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 639  5468 23           	INC	HL
 640  5469 E3           	EX	(SP),HL
 641  546A 23           	INC	HL		; Get next basic char
 642  546B
 643  546B              GETPREVCHAR:
 644  546B 2B           	DEC	HL
 645  546C DD 21 66 46  	LD	IX,CHRGTR
 646  5470 C3 59 01     	JP      CALBAS
 647  5473
 648  5473
 649  5473              TYPE_MISMATCH:
 650  5473 1E 0D            LD E, 13 ; Type mismatch
 651  5475 18 0A            JR THROW_ERROR
 652  5477              SUBSCRIPT_OUT_OF_RANGE:
 653  5477 1E 09            LD E,9 ; subscript out of range
 654  5479 18 06        	JR THROW_ERROR
 655  547B              OVERFLOW:
 656  547B 1E 06        	LD E,6
 657  547D 18 02        	JR THROW_ERROR
 658  547F              SYNTAX_ERROR:
 659  547F 1E 02            LD E, 2 ; Syntax error
 660  5481              THROW_ERROR:
 661  5481 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 662  5485 C3 59 01     	JP	CALBAS
 663  5488
 664  5488              ;---------------------------
 665  5488
 666  5488               IF (RAM_CMDS == 1)
 667  5488              ; *******************************************************************************************************
 668  5488              ; function to handle CALL MEMCPY basic extension
 669  5488              ; _MEMCPY ( INT source,
 670  5488              ;			INT destination,
 671  5488              ;			INT count,
 672  5488              ; will put ram in page 0 also, page 1 is already there
 673  5488              MEMCPY:
 674  5488              	; opening (
 675  5488 CD 61 54     	CALL CHKCHAR
 676  548B 28           	DB '('
 677  548C              	; get source address
 678  548C DD 21 2F 54  	LD IX, FRMQNT
 679  5490 CD 59 01     	CALL CALBAS
 680  5493 D5           	PUSH DE
 681  5494              	; comma
 682  5494 CD 61 54     	CALL CHKCHAR
 683  5497 2C           	DB ','
 684  5498              	; get destination address
 685  5498 DD 21 2F 54  	LD IX, FRMQNT
 686  549C CD 59 01     	CALL CALBAS
 687  549F D5           	PUSH DE
 688  54A0              	; comma
 689  54A0 CD 61 54     	CALL CHKCHAR
 690  54A3 2C           	DB ','
 691  54A4              	; get length
 692  54A4 DD 21 2F 54  	LD IX, FRMQNT
 693  54A8 CD 59 01     	CALL CALBAS
 694  54AB D5           	PUSH DE
 695  54AC              	; ending )
 696  54AC CD 61 54     	CALL CHKCHAR
 697  54AF 29           	DB ')'
 698  54B0
 699  54B0              	; save position
 700  54B0 E5           	PUSH HL
 701  54B1 DD E1        	POP IX
 702  54B3
 703  54B3 C1           	POP BC ; count
 704  54B4 D1           	POP DE ; destination
 705  54B5 E1           	POP HL ; source
 706  54B6 D9           	EXX
 707  54B7              	; enable page 0
 708  54B7 FD 21 BE 54  	LD IY, .RET
 709  54BB C3 14 54     	JP ENABLE_PAGE0
 710  54BE              .RET:
 711  54BE FB           	EI
 712  54BF D9           	EXX
 713  54C0 ED B0        	LDIR
 714  54C2 D1               POP DE
 715  54C3 C1               POP BC
 716  54C4 CD 8B 53         CALL RESTORE_PAGE_INFO
 717  54C7 DD E5        	PUSH IX
 718  54C9 E1           	POP HL
 719  54CA C9           	RET
 720  54CB              ; *******************************************************************************************************
 721  54CB               ENDIF
 722  54CB
 723  54CB               IF (VRAM_CMDS == 1)
 724  54CB              ; *******************************************************************************************************
 725  54CB              ; function to handle CALL FILVRM basic extension
 726  54CB              ; FILVRM ( INT offset,
 727  54CB              ;		   INT count,
 728  54CB              ;		   BYTE value,
 729  54CB              ;		   BYTE wait_vsync) >0 = true
 730  54CB              ; wait_vsync will issue HALT before copying
 731  54CB              FILVRM:
 732  54CB              	; opening (
 733  54CB CD 61 54     	CALL CHKCHAR
 734  54CE 28           	DB '('
 735  54CF              	; get offset address
 736  54CF DD 21 2F 54  	LD IX, FRMQNT
 737  54D3 CD 59 01     	CALL CALBAS
 738  54D6 D5           	PUSH DE
 739  54D7              	; comma
 740  54D7 CD 61 54     	CALL CHKCHAR
 741  54DA 2C           	DB ','
 742  54DB              	; get count
 743  54DB DD 21 2F 54  	LD IX, FRMQNT
 744  54DF CD 59 01     	CALL CALBAS
 745  54E2 D5           	PUSH DE
 746  54E3              	; comma
 747  54E3 CD 61 54     	CALL CHKCHAR
 748  54E6 2C           	DB ','
 749  54E7              	; get value
 750  54E7 DD 21 1C 52  	LD IX, GETBYT
 751  54EB CD 59 01     	CALL CALBAS
 752  54EE F5           	PUSH AF
 753  54EF              	; comma
 754  54EF CD 61 54     	CALL CHKCHAR
 755  54F2 2C           	DB ','
 756  54F3              	; get vsync wait
 757  54F3 DD 21 1C 52  	LD IX, GETBYT
 758  54F7 CD 59 01     	CALL CALBAS
 759  54FA F5           	PUSH AF
 760  54FB              	; ending )
 761  54FB CD 61 54     	CALL CHKCHAR
 762  54FE 29           	DB ')'
 763  54FF
 764  54FF FB               EI
 765  5500              	; save position
 766  5500 E5           	PUSH HL
 767  5501 DD E1        	POP IX
 768  5503
 769  5503              	; syntax ok
 770  5503              	; wait for vsync if needed
 771  5503 F1           	POP AF
 772  5504 B7           	OR A
 773  5505 28 01        	JR Z, .L1
 774  5507 76           	HALT
 775  5508
 776  5508              .L1:
 777  5508 F1               POP AF ; value
 778  5509 C1               POP BC ; count
 779  550A E1               POP HL ; offset
 780  550B CD 56 00         CALL BIOS_FILVRM
 781  550E
 782  550E              .L3:
 783  550E DD E5        	PUSH IX
 784  5510 E1           	POP HL
 785  5511 C9           	RET
 786  5512              ; *******************************************************************************************************
 787  5512               ENDIF
 788  5512
 789  5512               IF (RAM_CMDS == 1)
 790  5512              ; *******************************************************************************************************
 791  5512              ; function to handle CALL FILRAM basic extension
 792  5512              ; FILRAM ( INT start address,
 793  5512              ;		   INT count,
 794  5512              ;		   BYTE value,
 795  5512              ; will put ram in page 0 also, page 1 is already there
 796  5512              FILRAM:
 797  5512              	; opening (
 798  5512 CD 61 54     	CALL CHKCHAR
 799  5515 28           	DB '('
 800  5516              	; get start address
 801  5516 DD 21 2F 54  	LD IX, FRMQNT
 802  551A CD 59 01     	CALL CALBAS
 803  551D D5           	PUSH DE
 804  551E              	; comma
 805  551E CD 61 54     	CALL CHKCHAR
 806  5521 2C           	DB ','
 807  5522              	; get count
 808  5522 DD 21 2F 54  	LD IX, FRMQNT
 809  5526 CD 59 01     	CALL CALBAS
 810  5529 D5           	PUSH DE
 811  552A              	; comma
 812  552A CD 61 54     	CALL CHKCHAR
 813  552D 2C           	DB ','
 814  552E              	; get value
 815  552E DD 21 1C 52  	LD IX, GETBYT
 816  5532 CD 59 01     	CALL CALBAS
 817  5535 F5           	PUSH AF
 818  5536              	; ending )
 819  5536 CD 61 54     	CALL CHKCHAR
 820  5539 29           	DB ')'
 821  553A
 822  553A              	; save position
 823  553A E5           	PUSH HL
 824  553B DD E1        	POP IX
 825  553D
 826  553D D1           	POP DE ; actually AF
 827  553E C1           	POP BC ; count
 828  553F E1           	POP HL ; start address
 829  5540 78           	LD A, B
 830  5541 B7           	OR A
 831  5542 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 832  5544 B1           	OR C
 833  5545 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 834  5547 79           	LD A, C
 835  5548 3D           	DEC A
 836  5549 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 837  554B              	; one byte to fill
 838  554B 72           	LD (HL), D
 839  554C 18 12        	JR .EXIT
 840  554E              .L1:
 841  554E D9           	EXX
 842  554F              	; enable page 0
 843  554F FD 21 56 55  	LD IY, .RET
 844  5553 C3 14 54     	JP ENABLE_PAGE0
 845  5556              .RET:
 846  5556 FB           	EI
 847  5557 D9           	EXX
 848  5558 CD 64 55     	CALL .FILLVALUE
 849  555B D1               POP DE
 850  555C C1               POP BC
 851  555D CD 8B 53         CALL RESTORE_PAGE_INFO
 852  5560              .EXIT:
 853  5560 DD E5        	PUSH IX
 854  5562 E1           	POP HL
 855  5563 C9           	RET
 856  5564
 857  5564              .FILLVALUE:
 858  5564 72               LD (HL), D
 859  5565 54               LD D, H
 860  5566 5D               LD E, L
 861  5567 13               INC DE
 862  5568 0B               DEC BC
 863  5569 ED B0            LDIR
 864  556B C9               RET
 865  556C              ; *******************************************************************************************************
 866  556C               ENDIF
 867  556C
 868  556C               IF (GENCAL_CMD == 1)
 869  556C              ; *******************************************************************************************************
 870  556C              ; function to handle CALL GENCAL basic extension
 871  556C              ; GENCAL ( INT fn_addr, = address of the function to call
 872  556C              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 873  556C              ; output values of reristers will also be stored at reg_list_ptr
 874  556C              GENCAL_VAR_SP:
 875  556C 00 00            DW 0
 876  556E              GENCAL_VAR_SP2:
 877  556E 00 00            DW 0
 878  5570              GENCAL:
 879  5570              	; opening (
 880  5570 CD 61 54     	CALL CHKCHAR
 881  5573 28           	DB '('
 882  5574              	; get function address
 883  5574 DD 21 2F 54  	LD IX, FRMQNT
 884  5578 CD 59 01     	CALL CALBAS
 885  557B D5           	PUSH DE
 886  557C              	; comma
 887  557C CD 61 54     	CALL CHKCHAR
 888  557F 2C           	DB ','
 889  5580              	; get pointer to register list
 890  5580 DD 21 2F 54  	LD IX, FRMQNT
 891  5584 CD 59 01     	CALL CALBAS
 892  5587 D5           	PUSH DE
 893  5588              	; ending )
 894  5588 CD 61 54     	CALL CHKCHAR
 895  558B 29           	DB ')'
 896  558C
 897  558C              	; save BASIC token position
 898  558C E5           	PUSH HL
 899  558D D9               EXX
 900  558E E1           	POP HL ; HL'=next basic token
 901  558F D9               EXX
 902  5590
 903  5590 E1               POP HL ; get pointer to register values
 904  5591 F3           	DI
 905  5592 ED 73 6C 55      LD (GENCAL_VAR_SP), SP
 906  5596 F9               LD SP, HL
 907  5597 F1               POP AF
 908  5598 C1               POP BC
 909  5599 D1               POP DE
 910  559A E1               POP HL
 911  559B DD E1            POP IX
 912  559D FD E1            POP IY
 913  559F D9               EXX
 914  55A0 ED 73 6E 55      LD (GENCAL_VAR_SP2), SP
 915  55A4 ED 7B 6C 55      LD SP, (GENCAL_VAR_SP)
 916  55A8 FB               EI
 917  55A9 D1               POP DE ; get function to call
 918  55AA E5               PUSH HL
 919  55AB CD C6 55         CALL .EXXDECALL
 920  55AE F3               DI
 921  55AF ED 73 6C 55      LD (GENCAL_VAR_SP), SP
 922  55B3 ED 7B 6E 55      LD SP, (GENCAL_VAR_SP2)
 923  55B7 FD E5            PUSH IY
 924  55B9 DD E5            PUSH IX
 925  55BB E5               PUSH HL
 926  55BC D5               PUSH DE
 927  55BD C5               PUSH BC
 928  55BE F5               PUSH AF
 929  55BF ED 7B 6C 55      LD SP, (GENCAL_VAR_SP)
 930  55C3 FB               EI
 931  55C4 E1               POP HL
 932  55C5 C9           	RET
 933  55C6
 934  55C6              .EXXDECALL:
 935  55C6 D5               PUSH DE
 936  55C7 D9               EXX
 937  55C8 C9               RET
 938  55C9              ; *******************************************************************************************************
 939  55C9               ENDIF
 940  55C9
 941  55C9               IF (VRAM_CMDS == 1)
 942  55C9              ; *******************************************************************************************************
 943  55C9              ; function to handle CALL MEMVRM basic extension
 944  55C9              ; copies from RAM to VRAM
 945  55C9              ; _MEMVRM ( INT source,
 946  55C9              ;			INT destination,
 947  55C9              ;			INT count,
 948  55C9              ;			BYTE wait_vsync) >0 = true
 949  55C9              ; will put ram in page 0 also, page 1 is already there
 950  55C9              ; wait_vsync will issue HALT before copying
 951  55C9              MEMVRM:
 952  55C9              	; opening (
 953  55C9 CD 61 54     	CALL CHKCHAR
 954  55CC 28           	DB '('
 955  55CD              	; get source address
 956  55CD DD 21 2F 54  	LD IX, FRMQNT
 957  55D1 CD 59 01     	CALL CALBAS
 958  55D4 D5           	PUSH DE
 959  55D5              	; comma
 960  55D5 CD 61 54     	CALL CHKCHAR
 961  55D8 2C           	DB ','
 962  55D9              	; get destination address
 963  55D9 DD 21 2F 54  	LD IX, FRMQNT
 964  55DD CD 59 01     	CALL CALBAS
 965  55E0 D5           	PUSH DE
 966  55E1              	; comma
 967  55E1 CD 61 54     	CALL CHKCHAR
 968  55E4 2C           	DB ','
 969  55E5              	; get length
 970  55E5 DD 21 2F 54  	LD IX, FRMQNT
 971  55E9 CD 59 01     	CALL CALBAS
 972  55EC D5           	PUSH DE
 973  55ED              	; comma
 974  55ED CD 61 54     	CALL CHKCHAR
 975  55F0 2C           	DB ','
 976  55F1              	; get vsync wait
 977  55F1 DD 21 1C 52  	LD IX, GETBYT
 978  55F5 CD 59 01     	CALL CALBAS
 979  55F8 F5           	PUSH AF
 980  55F9              	; ending )
 981  55F9 CD 61 54     	CALL CHKCHAR
 982  55FC 29           	DB ')'
 983  55FD
 984  55FD                  ; save position in BASIC text
 985  55FD E5           	PUSH HL
 986  55FE DD E1        	POP IX
 987  5600
 988  5600 F1           	POP AF ; wait vsync
 989  5601 B7           	OR A
 990  5602 28 03        	JR Z, .L1
 991  5604 FB               EI
 992  5605 76           	HALT
 993  5606 F3           	DI
 994  5607              .L1:
 995  5607              	; pop LDIR parameters and store away for later
 996  5607 C1           	POP BC ; count
 997  5608 D1           	POP DE ; vram destination
 998  5609 E1           	POP HL ; ram source
 999  560A D9           	EXX
1000  560B FD 21 12 56   	LD IY, .RET
1001  560F C3 14 54     	JP ENABLE_PAGE0
1002  5612              .RET:
1003  5612 FB           	EI
1004  5613 D9           	EXX
1005  5614 CD 20 56     	CALL .LDIRVM
1006  5617 D1               POP DE
1007  5618 C1               POP BC
1008  5619 CD 8B 53         CALL RESTORE_PAGE_INFO
1009  561C DD E5        	PUSH IX
1010  561E E1           	POP HL
1011  561F C9           	RET
1012  5620
1013  5620              .LDIRVM:
1014  5620 EB           	EX DE, HL
1015  5621 F3           	DI
1016  5622 CD 3E 53     	CALL SETWRT_LOCAL
1017  5625 FB           	EI
1018  5626 EB           	EX DE, HL
1019  5627 78           	LD A, B
1020  5628 B7           	OR A
1021  5629 28 0D        	JR Z, .L3
1022  562B C5           	PUSH BC
1023  562C 0E 98        	LD C, #98
1024  562E              .L2:
1025  562E 50           	LD D, B
1026  562F 06 00        	LD B, 0
1027  5631 CD 49 53     	CALL BBYTECOPY
1028  5634 42           	LD B, D
1029  5635 10 F7        	DJNZ .L2
1030  5637 C1           	POP BC
1031  5638              .L3:
1032  5638 79           	LD A, C
1033  5639 B7           	OR A
1034  563A C8           	RET Z
1035  563B 41           	LD B, C
1036  563C 0E 98        	LD C, #98
1037  563E C3 49 53     	JP BBYTECOPY
1038  5641              ; *******************************************************************************************************
1039  5641               ENDIF
1040  5641
1041  5641               IF (VRAM_CMDS == 1)
1042  5641              ; *******************************************************************************************************
1043  5641              ; function to handle CALL VRMMEM basic extension
1044  5641              ; copies from RAM to VRAM
1045  5641              ; _VRMMEM ( INT source,
1046  5641              ;			INT destination,
1047  5641              ;			INT count
1048  5641              ; will put ram in page 0 also, page 1 is already there
1049  5641              VRMMEM:
1050  5641              	; opening (
1051  5641 CD 61 54     	CALL CHKCHAR
1052  5644 28           	DB '('
1053  5645              	; get source address
1054  5645 DD 21 2F 54  	LD IX, FRMQNT
1055  5649 CD 59 01     	CALL CALBAS
1056  564C D5           	PUSH DE
1057  564D              	; comma
1058  564D CD 61 54     	CALL CHKCHAR
1059  5650 2C           	DB ','
1060  5651              	; get destination address
1061  5651 DD 21 2F 54  	LD IX, FRMQNT
1062  5655 CD 59 01     	CALL CALBAS
1063  5658 D5           	PUSH DE
1064  5659              	; comma
1065  5659 CD 61 54     	CALL CHKCHAR
1066  565C 2C           	DB ','
1067  565D              	; get length
1068  565D DD 21 2F 54  	LD IX, FRMQNT
1069  5661 CD 59 01     	CALL CALBAS
1070  5664 D5           	PUSH DE
1071  5665              	; ending )
1072  5665 CD 61 54     	CALL CHKCHAR
1073  5668 29           	DB ')'
1074  5669
1075  5669                  ; save position in BASIC text
1076  5669 E5           	PUSH HL
1077  566A DD E1        	POP IX
1078  566C
1079  566C C1           	POP BC ; count
1080  566D D1           	POP DE ; destination
1081  566E E1           	POP HL ; source
1082  566F D9           	EXX
1083  5670 FD 21 77 56  	LD IY, .RET
1084  5674 C3 14 54     	JP ENABLE_PAGE0
1085  5677              .RET:
1086  5677 FB           	EI
1087  5678 D9           	EXX
1088  5679 CD 85 56     	CALL .LDIRMV
1089  567C D1               POP DE
1090  567D C1               POP BC
1091  567E CD 8B 53         CALL RESTORE_PAGE_INFO
1092  5681 DD E5        	PUSH IX
1093  5683 E1           	POP HL
1094  5684 C9           	RET
1095  5685
1096  5685              .LDIRMV:
1097  5685              	; set VRAM address *exactly* as in ROM, otherwise corruption
1098  5685 7D           	LD	A, L
1099  5686 F3           	DI
1100  5687 D3 99        	OUT	(099H), A
1101  5689 7C           	LD	A, H
1102  568A E6 3F        	AND	03FH
1103  568C D3 99        	OUT	(099H), A
1104  568E FB           	EI
1105  568F              	;EX (SP), HL
1106  568F              	;EX (SP), HL
1107  568F              	;NOP
1108  568F              	;NOP
1109  568F              .L4:
1110  568F DB 98            IN A, (#98)
1111  5691 12           	LD (DE), A
1112  5692 13               INC DE
1113  5693 0B               DEC BC
1114  5694 79               LD A, C
1115  5695 B0               OR B
1116  5696 20 F7            JR NZ, .L4
1117  5698 C9               RET
1118  5699              ; *******************************************************************************************************
1119  5699               ENDIF
1120  5699
1121  5699              ; *******************************************************************************************************
1122  5699              ; H.TIMI function
1123  5699              MBGE_HTIMI:
1124  5699               EXPORT MBGE_HTIMI
1125  5699 F5           	PUSH AF
1126  569A
1127  569A               IF (SPRITE_CMDS == 1)
1128  569A CD 01 4D     	CALL SPRATR_UPDATE
1129  569D               ENDIF
1130  569D
1131  569D               IF (SOUND_CMDS == 1)
1132  569D 3A F7 4C     	LD A, (SOUND_ENABLED)
1133  56A0 B7           	OR A
1134  56A1 28 2A        	JR Z, .EXIT
1135  56A3
1136  56A3              	; enable page 2
1137  56A3 3E 02            LD A, 2
1138  56A5 CD 54 53         CALL GET_PAGE_INFO
1139  56A8 C5               PUSH BC
1140  56A9 D5               PUSH DE
1141  56AA 3A 43 F3         LD A, (RAMAD2)
1142  56AD 26 80            LD H, 080H
1143  56AF CD 9B 53         CALL LOCAL_ENASLT
1144  56B2              	; enable page 0
1145  56B2 AF               XOR A
1146  56B3 CD 54 53         CALL GET_PAGE_INFO
1147  56B6 C5               PUSH BC
1148  56B7 D5               PUSH DE
1149  56B8 3A 41 F3         LD A, (RAMAD0)
1150  56BB 26 00            LD H, 0
1151  56BD CD 9B 53         CALL LOCAL_ENASLT
1152  56C0
1153  56C0 CD 33 42     	CALL PLY_AKG_PLAY
1154  56C3
1155  56C3              	; restore page 0
1156  56C3 D1               POP DE
1157  56C4 C1               POP BC
1158  56C5 CD 8B 53         CALL RESTORE_PAGE_INFO
1159  56C8              	; restore page 2
1160  56C8 D1               POP DE
1161  56C9 C1               POP BC
1162  56CA CD 8B 53         CALL RESTORE_PAGE_INFO
1163  56CD               ENDIF
1164  56CD
1165  56CD              .EXIT:
1166  56CD F1           	POP AF
1167  56CE C3 F0 4C     	JP ORIG.HTIMI
1168  56D1              ; *******************************************************************************************************
1169  56D1
1170  56D1              ; *******************************************************************************************************
1171  56D1              ; interrupt handler when page 0 enabled
1172  56D1              VBLANK:
1173  56D1              	EXPORT VBLANK
1174  56D1
1175  56D1 F5               PUSH AF
1176  56D2              	; is VDP originator ?
1177  56D2 DB 99        	IN	A, (099H)
1178  56D4 A7           	AND	A
1179  56D5 F2 FB 56     	JP P, .EXIT
1180  56D8
1181  56D8               IF (SOUND_CMDS == 1)
1182  56D8 3A F7 4C     	LD A, (SOUND_ENABLED)
1183  56DB B7           	OR A
1184  56DC 28 1D        	JR Z, .EXIT
1185  56DE
1186  56DE C5               PUSH BC
1187  56DF D5               PUSH DE
1188  56E0 E5               PUSH HL
1189  56E1 08               EX AF, AF'
1190  56E2 D9               EXX
1191  56E3 F5               PUSH AF
1192  56E4 C5               PUSH BC
1193  56E5 D5               PUSH DE
1194  56E6 E5               PUSH HL
1195  56E7 DD E5            PUSH IX
1196  56E9 FD E5            PUSH IY
1197  56EB
1198  56EB CD 33 42     	CALL PLY_AKG_PLAY
1199  56EE
1200  56EE FD E1            POP IY
1201  56F0 DD E1            POP IX
1202  56F2 E1               POP HL
1203  56F3 D1               POP DE
1204  56F4 C1               POP BC
1205  56F5 F1               POP AF
1206  56F6 08               EX AF, AF'
1207  56F7 D9               EXX
1208  56F8 E1               POP HL
1209  56F9 D1               POP DE
1210  56FA C1               POP BC
1211  56FB               ENDIF
1212  56FB
1213  56FB              .EXIT:
1214  56FB F1           	POP AF
1215  56FC FB           	EI
1216  56FD ED 4D        	RETI
1217  56FF              ; *******************************************************************************************************
1218  56FF
1219  56FF               IF (SOUND_CMDS == 1)
1220  56FF              ; *******************************************************************************************************
1221  56FF              ; function to handle CALL SNDPLYINIT basic extension
1222  56FF              ; initializes sound player
1223  56FF              ; _SNDPLYINIT ( INT music_offset,
1224  56FF              ;				INT sfx_offset, can be -1 if no SFX
1225  56FF              ; will put ram in page 0 also, page 1 is already there
1226  56FF              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1227  56FF              SNDPLYINIT:
1228  56FF              	; opening (
1229  56FF CD 61 54     	CALL CHKCHAR
1230  5702 28           	DB '('
1231  5703              	; get music address
1232  5703 DD 21 2F 54  	LD IX, FRMQNT
1233  5707 CD 59 01     	CALL CALBAS
1234  570A D5           	PUSH DE
1235  570B              	; comma
1236  570B CD 61 54     	CALL CHKCHAR
1237  570E 2C           	DB ','
1238  570F              	; get sfx address
1239  570F DD 21 2F 54  	LD IX, FRMQNT
1240  5713 CD 59 01     	CALL CALBAS
1241  5716 D5           	PUSH DE
1242  5717              	; ending )
1243  5717 CD 61 54     	CALL CHKCHAR
1244  571A 29           	DB ')'
1245  571B
1246  571B                  ; save position in BASIC text
1247  571B 44           	LD B, H
1248  571C 4D           	LD C, L
1249  571D
1250  571D              	; pop LDIR parameters and store away for later
1251  571D D1           	POP DE ; sfx address
1252  571E E1           	POP HL ; music address
1253  571F C5           	PUSH BC ; basic text location
1254  5720 D9           	EXX
1255  5721 FD 21 28 57  	LD IY, .RET
1256  5725 C3 14 54     	JP ENABLE_PAGE0
1257  5728              .RET:
1258  5728 D9           	EXX
1259  5729
1260  5729 D5           	PUSH DE
1261  572A AF           	XOR A
1262  572B              	; HL = music location
1263  572B CD 62 41     	CALL PLY_AKG_INIT
1264  572E 3E 01        	LD A, 1
1265  5730 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1266  5733
1267  5733 E1           	POP HL ; SFX
1268  5734              	; check if SFX address -1
1269  5734 23           	INC HL
1270  5735 7D           	LD A, L
1271  5736 B4           	OR H
1272  5737 28 09        	JR Z,.L1
1273  5739 2B           	DEC HL
1274  573A CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1275  573D 3E 01        	LD A, 1
1276  573F 32 F6 4C     	LD (SFX_INIT_STATUS), A
1277  5742              .L1:
1278  5742 D1               POP DE
1279  5743 C1               POP BC
1280  5744 CD 8B 53         CALL RESTORE_PAGE_INFO
1281  5747
1282  5747 E1           	POP HL
1283  5748 C9           	RET
1284  5749              ; *******************************************************************************************************
1285  5749
1286  5749              ; *******************************************************************************************************
1287  5749              ; function to handle CALL SNDPLYON basic extension
1288  5749              ; enables sound player
1289  5749              ; _SNDPLYON
1290  5749              ; sets SOUND_ENABLED variable to 1 if init call was done
1291  5749              ; if not throws out of data error
1292  5749              SNDPLYON:
1293  5749 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1294  574C B7           	OR A
1295  574D 20 05        	JR NZ, .L1
1296  574F              	; player not initialized, throw error
1297  574F 1E 04        	LD E, 04 ; Out of DATA
1298  5751 C3 81 54     	JP THROW_ERROR
1299  5754              .L1:
1300  5754 32 F7 4C     	LD (SOUND_ENABLED), A
1301  5757              	; disable key click
1302  5757 AF           	XOR A
1303  5758 32 DB F3     	LD (CLIKSW), A
1304  575B C9           	RET
1305  575C              ; *******************************************************************************************************
1306  575C
1307  575C              ; *******************************************************************************************************
1308  575C              ; function to handle CALL SNDPLYOFF basic extension
1309  575C              ; disables sound player
1310  575C              ; _SNDPLYOFF
1311  575C              ; sets SOUND_ENABLED variable to 0
1312  575C              ; calls AKG to stop music and SFX on all channels if initialized
1313  575C              SNDPLYOFF:
1314  575C 3A F7 4C     	LD A, (SOUND_ENABLED)
1315  575F B7           	OR A
1316  5760 C8           	RET Z ; already stopped
1317  5761 AF           	XOR A
1318  5762 32 F7 4C     	LD (SOUND_ENABLED), A
1319  5765 E5           	PUSH HL
1320  5766 CD 21 42     	CALL PLY_AKG_STOP
1321  5769 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1322  576C B7           	OR A
1323  576D 28 0E        	JR Z, .EXIT ; SFX not in use
1324  576F AF           	XOR A
1325  5770 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1326  5773 3E 01        	LD A, 1
1327  5775 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1328  5778 3E 02        	LD A, 2
1329  577A CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1330  577D              .EXIT:
1331  577D E1           	POP HL
1332  577E C9           	RET
1333  577F              ; *******************************************************************************************************
1334  577F
1335  577F              ; *******************************************************************************************************
1336  577F              ; function to handle CALL SNDSFX basic extension
1337  577F              ; plays a sound effect
1338  577F              ; _SNDSFX ( BYTE sfx_number, >0
1339  577F              ;			BYTE channel, = 0,1 or 2
1340  577F              ;			BYTE inverted_volume = 0-16, 0 being full volume
1341  577F              ; will put ram in page 0 also, page 1 is already there
1342  577F              ; if sound off throws illegal function call
1343  577F              ; if sfx not initialized, throws out of data
1344  577F              SNDSFX:
1345  577F              	; opening (
1346  577F CD 61 54     	CALL CHKCHAR
1347  5782 28           	DB '('
1348  5783              	; get sfx_number
1349  5783 DD 21 1C 52  	LD IX, GETBYT
1350  5787 CD 59 01     	CALL CALBAS
1351  578A D5           	PUSH DE
1352  578B              	; comma
1353  578B CD 61 54     	CALL CHKCHAR
1354  578E 2C           	DB ','
1355  578F              	; get sfx address
1356  578F DD 21 1C 52  	LD IX, GETBYT
1357  5793 CD 59 01     	CALL CALBAS
1358  5796 D5           	PUSH DE
1359  5797              	; comma
1360  5797 CD 61 54     	CALL CHKCHAR
1361  579A 2C           	DB ','
1362  579B              	; get inverted volume
1363  579B DD 21 1C 52  	LD IX, GETBYT
1364  579F CD 59 01     	CALL CALBAS
1365  57A2 D5           	PUSH DE
1366  57A3              	; ending )
1367  57A3 CD 61 54     	CALL CHKCHAR
1368  57A6 29           	DB ')'
1369  57A7
1370  57A7 3A F7 4C     	LD A, (SOUND_ENABLED)
1371  57AA B7           	OR A
1372  57AB 20 05        	JR NZ, .L1
1373  57AD              	; sound disabled, throw illegal function call
1374  57AD 1E 05        	LD E, 5
1375  57AF C3 81 54     	JP THROW_ERROR
1376  57B2              .L1:
1377  57B2 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1378  57B5 B7           	OR A
1379  57B6 20 05        	JR NZ, .L2
1380  57B8              	; sfx data not initialized, throw out of data
1381  57B8 1E 04        	LD E, 4
1382  57BA C3 81 54     	JP THROW_ERROR
1383  57BD              .L2:
1384  57BD              	; pop  parameters and store away for later
1385  57BD D1           	POP DE ; inverted volume
1386  57BE 43           	LD B, E
1387  57BF D1           	POP DE ; channel
1388  57C0 4B           	LD C, E
1389  57C1 D1           	POP DE
1390  57C2 7B           	LD A, E
1391  57C3 08           	EX AF, AF'
1392  57C4 E5           	PUSH HL ; basic text location
1393  57C5 D9           	EXX
1394  57C6 FD 21 CD 57  	LD IY, .RET
1395  57CA C3 14 54     	JP ENABLE_PAGE0
1396  57CD              .RET:
1397  57CD D9           	EXX
1398  57CE 08           	EX AF, AF'
1399  57CF CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1400  57D2
1401  57D2 D1               POP DE
1402  57D3 C1               POP BC
1403  57D4 CD 8B 53         CALL RESTORE_PAGE_INFO
1404  57D7
1405  57D7 E1           	POP HL
1406  57D8 C9           	RET
1407  57D9              ; *******************************************************************************************************
1408  57D9               ENDIF
1409  57D9
1410  57D9               IF (BLIT_CMDS == 1)
1411  57D9              ; *******************************************************************************************************
1412  57D9              ; function rotates mask and data of several characters and applies to background data
1413  57D9              ; this handles x-shift from 0 to 4
1414  57D9              ; contains self-modifying code that is set-up from external function
1415  57D9              ; input HL=pointer to mask data
1416  57D9              ; input HL'=pointer to character data
1417  57D9              ; input DE=output buffer containing background data
1418  57D9              ; input BC=DE+8
1419  57D9              ; input A=number of characters to process
1420  57D9              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1421  57D9              SHIFT04:
1422  57D9 08           	EX AF, AF'
1423  57DA 7E           	LD A, (HL) ; get mask
1424  57DB D9           	EXX
1425  57DC 57           	LD D, A
1426  57DD 1E FF        	LD E, #FF
1427  57DF 37           	SCF
1428  57E0              .M1:
1429  57E0 18 FE        	JR .M1 ; this is self-modifying part
1430  57E2 CB 1A        	RR D
1431  57E4 CB 1B        	RR E
1432  57E6 CB 1A        	RR D
1433  57E8 CB 1B        	RR E
1434  57EA CB 1A        	RR D
1435  57EC CB 1B        	RR E
1436  57EE CB 1A        	RR D
1437  57F0 CB 1B        	RR E
1438  57F2
1439  57F2 46           	LD B, (HL) ; get data
1440  57F3 0E 00        	LD C, 0
1441  57F5              .M2:
1442  57F5 18 FE        	JR .M2 ; also self-modifying part
1443  57F7 CB 38        	SRL B
1444  57F9 CB 19        	RR C
1445  57FB CB 38        	SRL B
1446  57FD CB 19        	RR C
1447  57FF CB 38        	SRL B
1448  5801 CB 19        	RR C
1449  5803 CB 38        	SRL B
1450  5805 CB 19        	RR C
1451  5807
1452  5807 D9           	EXX
1453  5808 1A           	LD A, (DE) ; background
1454  5809 D9           	EXX
1455  580A A2           	AND D
1456  580B B0           	OR B
1457  580C D9           	EXX
1458  580D 12           	LD (DE), A
1459  580E
1460  580E 0A           	LD A, (BC)
1461  580F D9           	EXX
1462  5810 A3           	AND E
1463  5811 B1           	OR C
1464  5812 23           	INC HL
1465  5813 D9           	EXX
1466  5814 02           	LD (BC), A
1467  5815
1468  5815 23           	INC HL
1469  5816 13           	INC DE
1470  5817 03           	INC BC
1471  5818
1472  5818 08           	EX AF, AF'
1473  5819 3D           	DEC A
1474  581A C2 D9 57     	JP NZ, SHIFT04
1475  581D C9           	RET
1476  581E              ; *******************************************************************************************************
1477  581E
1478  581E              ; *******************************************************************************************************
1479  581E              ; function rotates mask and data of several characters and applies to background data
1480  581E              ; this handles x-shift from 5 to 8
1481  581E              ; contains self-modifying code that is set-up from external function
1482  581E              ; input HL=pointer to mask data
1483  581E              ; input HL'=pointer to character data
1484  581E              ; input DE=output buffer containing background data
1485  581E              ; input BC=DE+8
1486  581E              ; input A=number of characters to process
1487  581E              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1488  581E              SHIFT58:
1489  581E 08           	EX AF, AF'
1490  581F 7E           	LD A, (HL) ; get mask
1491  5820 D9           	EXX
1492  5821 57           	LD D, A
1493  5822 1E FF        	LD E, #FF
1494  5824 37           	SCF
1495  5825              .M1:
1496  5825 18 FE        	JR .M1 ; this is self-modifying part
1497  5827 CB 12        	RL D
1498  5829 CB 13        	RL E
1499  582B CB 12        	RL D
1500  582D CB 13        	RL E
1501  582F CB 12        	RL D
1502  5831 CB 13        	RL E
1503  5833
1504  5833 46           	LD B, (HL)
1505  5834 0E 00        	LD C, 0
1506  5836              .M2:
1507  5836 18 FE        	JR .M2 ; also self-modifying part
1508  5838 CB 20        	SLA B
1509  583A CB 11        	RL C
1510  583C CB 20        	SLA B
1511  583E CB 11        	RL C
1512  5840 CB 20        	SLA B
1513  5842 CB 11        	RL C
1514  5844
1515  5844 D9           	EXX
1516  5845 1A           	LD A, (DE) ; background
1517  5846 D9           	EXX
1518  5847 A3           	AND E
1519  5848 B1           	OR C
1520  5849 D9           	EXX
1521  584A 12           	LD (DE), A
1522  584B
1523  584B 0A           	LD A, (BC)
1524  584C D9           	EXX
1525  584D A2           	AND D
1526  584E B0           	OR B
1527  584F 23           	INC HL
1528  5850 D9           	EXX
1529  5851 02           	LD (BC), A
1530  5852
1531  5852 23           	INC HL
1532  5853 13           	INC DE
1533  5854 03           	INC BC
1534  5855
1535  5855 08           	EX AF, AF'
1536  5856 3D           	DEC A
1537  5857 C2 1E 58     	JP NZ, SHIFT58
1538  585A C9           	RET
1539  585B              ; *******************************************************************************************************
1540  585B
1541  585B              ; *******************************************************************************************************
1542  585B              ; routine that shifts one row of characters
1543  585B              ; contains self-modifying code that is set-up from external function
1544  585B              ; input HL=pointer to mask data
1545  585B              ; input HL'=pointer to character data
1546  585B              ; input DE=output buffer containing background data
1547  585B              ; input A=number of characters to process
1548  585B              ; input IX=pointer to structure describing input data
1549  585B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1550  585B              SHIFT_ROW:
1551  585B F5           	PUSH AF
1552  585C ED 53 D9 51  		LD (BLIT_TMP1), DE
1553  5860 E5           		PUSH HL
1554  5861 CD A4 58     			CALL .ADDYSHIFT
1555  5864 E1           		POP HL
1556  5865 ED 53 DB 51  		LD (BLIT_TMP2), DE ; DE+vertical shift
1557  5869              .L1:
1558  5869 3E 08        		LD A, 8
1559  586B DD 96 02     		SUB (IX+2) ; y shift
1560  586E              .CALL1:
1561  586E CD 00 00     		CALL 0
1562  5871 DD 7E 02     		LD A, (IX+2); y shift
1563  5874 B7           		OR A
1564  5875 28 26        		JR Z, .DONE
1565  5877 ED 5B D9 51  		LD DE, (BLIT_TMP1)
1566  587B E5           		PUSH HL
1567  587C CD B2 58     			CALL .DETONEXTROW
1568  587F E1           		POP HL
1569  5880              .CALL2:
1570  5880 CD 00 00     		CALL 0
1571  5883 ED 5B D9 51  		LD DE, (BLIT_TMP1)
1572  5887 E5           		PUSH HL
1573  5888 CD AC 58     			CALL .ADD8
1574  588B E1           		POP HL
1575  588C ED 53 D9 51  		LD (BLIT_TMP1), DE
1576  5890 ED 5B DB 51  		LD DE, (BLIT_TMP2)
1577  5894 E5           		PUSH HL
1578  5895 CD AC 58     			CALL .ADD8
1579  5898 E1           		POP HL
1580  5899 ED 53 DB 51  		LD (BLIT_TMP2), DE ; DE+vertical shift
1581  589D              .DONE:
1582  589D F1           	POP AF
1583  589E 3D           	DEC A
1584  589F C8           	RET Z
1585  58A0 F5           	PUSH AF
1586  58A1 C3 69 58     	JP .L1
1587  58A4              .ADDYSHIFT:
1588  58A4 EB           	EX DE, HL
1589  58A5 16 00        	LD D, 0
1590  58A7 DD 5E 02     	LD E, (IX+2); y shift
1591  58AA 18 0C        	JR .MOVDEBC
1592  58AC              .ADD8:
1593  58AC 21 08 00     	LD HL, 8
1594  58AF C3 B8 58     	JP .MOVDEBC
1595  58B2              .DETONEXTROW:
1596  58B2 DD 6E 06     	LD L, (IX+6)
1597  58B5 DD 66 07     	LD H, (IX+7) ; bkg add to value
1598  58B8              .MOVDEBC:
1599  58B8 19           	ADD HL, DE
1600  58B9 54           	LD D, H
1601  58BA 5D           	LD E, L
1602  58BB 01 08 00     	LD BC, 8
1603  58BE 09           	ADD HL, BC
1604  58BF 44           	LD B, H
1605  58C0 4D           	LD C, L
1606  58C1 C9           	RET
1607  58C2              ; *******************************************************************************************************
1608  58C2
1609  58C2              ; *******************************************************************************************************
1610  58C2              ; function rotates mask and character data and applies it to background
1611  58C2              ; input IX=pointer to structure describing input data
1612  58C2              ; +0  DW horizontal shift count 0-7 (low byte used)
1613  58C2              ; +2  DW vertical shift count 0-7 (low byte used)
1614  58C2              ; +4  DW background data start;
1615  58C2              ; +6  DW background add to value to next row of background data
1616  58C2              ; +8  DW mask data start;
1617  58C2              ; +10  DW character data start;
1618  58C2              ; +12 DW character&mask add to value to next row of data
1619  58C2              ; +14 DW columns (low byte used)
1620  58C2              ; +16 DW rows (low byte used)
1621  58C2              SHIFT_MERGE_CHARACTER:
1622  58C2 DD 7E 00     	LD A, (IX) ; shift
1623  58C5 FE 05        	CP 5
1624  58C7 38 25        	JR C, .RIGHT
1625  58C9              	; shifts 5-7, use rotate towards left 1-3
1626  58C9 21 1E 58     	LD HL, SHIFT58
1627  58CC 22 6F 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1628  58CF 22 81 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1629  58D2 D6 05        	SUB 5
1630  58D4 28 0D        	JR Z, .L1
1631  58D6 87           	ADD A, A
1632  58D7 87           	ADD A, A
1633  58D8 67           	LD H, A
1634  58D9 2E 18        	LD L, #18 ; JR opcode
1635  58DB 22 25 58     	LD (SHIFT58.M1), HL
1636  58DE 22 36 58     	LD (SHIFT58.M2), HL
1637  58E1 18 32        	JR .DO
1638  58E3              .L1:
1639  58E3 21 00 00     	LD HL, 0 ; 2xNOP opcode
1640  58E6 22 25 58     	LD (SHIFT58.M1), HL
1641  58E9 22 36 58     	LD (SHIFT58.M2), HL
1642  58EC 18 27        	JR .DO
1643  58EE              .RIGHT:
1644  58EE              	; shifts 0-4, rotate towards right
1645  58EE 21 D9 57     	LD HL, SHIFT04
1646  58F1 22 6F 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1647  58F4 22 81 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1648  58F7 FE 04        	CP 4
1649  58F9 28 11        	JR Z, .R1
1650  58FB D6 04        	SUB 4
1651  58FD ED 44        	NEG
1652  58FF 87           	ADD A, A
1653  5900 87           	ADD A, A
1654  5901 67           	LD H, A
1655  5902 2E 18        	LD L, #18 ; JR opcode
1656  5904 22 E0 57     	LD (SHIFT04.M1), HL
1657  5907 22 F5 57     	LD (SHIFT04.M2), HL
1658  590A 18 09        	JR .DO
1659  590C              .R1:
1660  590C 21 00 00     	LD HL, 0 ; 2xNOP opcode
1661  590F 22 E0 57     	LD (SHIFT04.M1), HL
1662  5912 22 F5 57     	LD (SHIFT04.M2), HL
1663  5915              .DO:
1664  5915 DD 46 10     	LD B, (IX+16) ; rows
1665  5918 DD 6E 08     	LD L, (IX+8)
1666  591B DD 66 09     	LD H, (IX+9) ; mask data
1667  591E DD 5E 04     	LD E, (IX+4)
1668  5921 DD 56 05     	LD D, (IX+5) ; background data
1669  5924 D9           	EXX
1670  5925 DD 6E 0A     	LD L, (IX+10)
1671  5928 DD 66 0B     	LD H, (IX+11) ; character data
1672  592B D9           	EXX
1673  592C              .LOOP:
1674  592C C5           	PUSH BC
1675  592D E5           		PUSH HL
1676  592E D5           			PUSH DE
1677  592F D9           				EXX
1678  5930 E5           				PUSH HL
1679  5931 D9           					EXX
1680  5932 DD 7E 0E     					LD A, (IX+14) ; columns
1681  5935              .CALL:
1682  5935 CD 5B 58     					CALL SHIFT_ROW
1683  5938 E1           				POP HL
1684  5939 DD 5E 0C     				LD E, (IX+12)
1685  593C DD 56 0D     				LD D, (IX+13) ; char data to next row
1686  593F 19           				ADD HL, DE
1687  5940 D9           				EXX
1688  5941 E1           			POP HL
1689  5942 DD 5E 06     			LD E, (IX+6)
1690  5945 DD 56 07     			LD D, (IX+7) ; background to next row
1691  5948 19           			ADD HL, DE
1692  5949 EB           			EX DE, HL
1693  594A E1           		POP HL
1694  594B DD 4E 0C     		LD C, (IX+12)
1695  594E DD 46 0D     		LD B, (IX+13) ; char data to next row
1696  5951 09           		ADD HL, BC
1697  5952 C1           	POP BC
1698  5953 10 D7        	DJNZ .LOOP
1699  5955 C9           	RET
1700  5956              ; *******************************************************************************************************
1701  5956
1702  5956               IFNDEF CMDS_WITH_PARAMETERS
1703  5956 ~            ; *******************************************************************************************************
1704  5956 ~            ; function to handle CALL BLIT basic extension
1705  5956 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1706  5956 ~            ; fuses with background data and applies vertical shift too
1707  5956 ~            ; BLIT ( INT request_data_ptr )
1708  5956 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1709  5956 ~            ; will put ram in page 0 also, page 1 is already there
1710  5956 ~            BLIT:
1711  5956 ~            	; opening (
1712  5956 ~            	CALL CHKCHAR
1713  5956 ~            	DB '('
1714  5956 ~            	; get pointer to request struct
1715  5956 ~            	LD IX, FRMQNT
1716  5956 ~            	CALL CALBAS
1717  5956 ~            	PUSH DE
1718  5956 ~            	; ending )
1719  5956 ~            	CALL CHKCHAR
1720  5956 ~            	DB ')'
1721  5956 ~
1722  5956 ~            	POP IX ; pointer to request struct
1723  5956 ~
1724  5956 ~            	PUSH HL ; save position in BASIC buffer
1725  5956 ~
1726  5956 ~            	LD IY, .RET
1727  5956 ~            	JP ENABLE_PAGE0
1728  5956 ~            .RET:
1729  5956 ~            	EI
1730  5956 ~            	CALL SHIFT_MERGE_CHARACTER
1731  5956 ~
1732  5956 ~                POP DE
1733  5956 ~                POP BC
1734  5956 ~                CALL RESTORE_PAGE_INFO
1735  5956 ~
1736  5956 ~            	POP HL
1737  5956 ~            	RET
1738  5956 ~            ; *******************************************************************************************************
1739  5956               ENDIF
1740  5956
1741  5956               IFDEF CMDS_WITH_PARAMETERS
1742  5956              ; *******************************************************************************************************
1743  5956              ; function to handle CALL BLIT basic extension
1744  5956              ; rotates 1-bit character drawing horizontally with mask and character data and
1745  5956              ; fuses with background data and applies vertical shift too
1746  5956              ; in form without pointers
1747  5956              ; BLIT ( INT x,
1748  5956              ;		 INT y,
1749  5956              ;		 INT char_data_pointer,
1750  5956              ;		 INT mask_data_pointer,
1751  5956              ;		 INT width (in characters),
1752  5956              ;		 INT height (in characters),
1753  5956              ;		 INT background_pointer (top left),
1754  5956              ;		 INT background_width (in characters),
1755  5956              ;		 INT background_height (in characters))
1756  5956              ; will put ram in page 0 also, page 1 is already there
1757  5956              BLIT:
1758  5956              	; opening (
1759  5956 CD 61 54     	CALL CHKCHAR
1760  5959 28           	DB '('
1761  595A              	; get x coordinate
1762  595A DD 21 2F 54  	LD IX, FRMQNT
1763  595E CD 59 01     	CALL CALBAS
1764  5961 7B           	LD A, E
1765  5962 E6 07        	AND 7
1766  5964 32 DD 51     	LD (BLIT_STRUCT+0), A
1767  5967 CD 44 5A     	CALL .DAdiv8
1768  596A 32 D9 51     	LD (BLIT_TMP+0),A
1769  596D              	; comma
1770  596D CD 61 54     	CALL CHKCHAR
1771  5970 2C           	DB ','
1772  5971              	; get y coordinate
1773  5971 DD 21 2F 54  	LD IX, FRMQNT
1774  5975 CD 59 01     	CALL CALBAS
1775  5978 7B           	LD A, E
1776  5979 E6 07        	AND 7
1777  597B 32 DF 51     	LD (BLIT_STRUCT+2), A
1778  597E CD 44 5A     	CALL .DAdiv8
1779  5981 32 DA 51     	LD (BLIT_TMP+1),A
1780  5984              	; comma
1781  5984 CD 61 54     	CALL CHKCHAR
1782  5987 2C           	DB ','
1783  5988              	; get char data pointer
1784  5988 DD 21 2F 54  	LD IX, FRMQNT
1785  598C CD 59 01     	CALL CALBAS
1786  598F ED 53 E7 51  	LD (BLIT_STRUCT+10), DE
1787  5993              	; comma
1788  5993 CD 61 54     	CALL CHKCHAR
1789  5996 2C           	DB ','
1790  5997              	; get mask data pointer
1791  5997 DD 21 2F 54  	LD IX, FRMQNT
1792  599B CD 59 01     	CALL CALBAS
1793  599E ED 53 E5 51  	LD (BLIT_STRUCT+8), DE
1794  59A2              	; comma
1795  59A2 CD 61 54     	CALL CHKCHAR
1796  59A5 2C           	DB ','
1797  59A6              	; get width
1798  59A6 DD 21 2F 54  	LD IX, FRMQNT
1799  59AA CD 59 01     	CALL CALBAS
1800  59AD 7B           	LD A, E
1801  59AE 32 EB 51     	LD (BLIT_STRUCT+14), A
1802  59B1              	; comma
1803  59B1 CD 61 54     	CALL CHKCHAR
1804  59B4 2C           	DB ','
1805  59B5              	; get height
1806  59B5 DD 21 2F 54  	LD IX, FRMQNT
1807  59B9 CD 59 01     	CALL CALBAS
1808  59BC 7B           	LD A, E
1809  59BD 32 ED 51     	LD (BLIT_STRUCT+16), A
1810  59C0              	; comma
1811  59C0 CD 61 54     	CALL CHKCHAR
1812  59C3 2C           	DB ','
1813  59C4              	; get background pointer
1814  59C4 DD 21 2F 54  	LD IX, FRMQNT
1815  59C8 CD 59 01     	CALL CALBAS
1816  59CB ED 53 E1 51  	LD (BLIT_STRUCT+4), DE
1817  59CF              	; comma
1818  59CF CD 61 54     	CALL CHKCHAR
1819  59D2 2C           	DB ','
1820  59D3              	; get background width
1821  59D3 DD 21 2F 54  	LD IX, FRMQNT
1822  59D7 CD 59 01     	CALL CALBAS
1823  59DA 7B           	LD A, E
1824  59DB 32 DB 51     	LD (BLIT_TMP+2), A
1825  59DE              	; comma
1826  59DE CD 61 54     	CALL CHKCHAR
1827  59E1 2C           	DB ','
1828  59E2              	; get background height
1829  59E2 DD 21 2F 54  	LD IX, FRMQNT
1830  59E6 CD 59 01     	CALL CALBAS
1831  59E9 7B           	LD A, E
1832  59EA 32 DC 51     	LD (BLIT_TMP+3), A
1833  59ED              	; ending )
1834  59ED CD 61 54     	CALL CHKCHAR
1835  59F0 29           	DB ')'
1836  59F1
1837  59F1 E5           	PUSH HL ; save position in BASIC buffer
1838  59F2
1839  59F2              	; calculate char&mask add to value
1840  59F2 26 00        	LD H, 0
1841  59F4 3A EB 51     	LD A, (BLIT_STRUCT+14)
1842  59F7 6F           	LD L, A
1843  59F8 CD 50 53     	CALL HLx8
1844  59FB 22 E9 51     	LD (BLIT_STRUCT+12), HL
1845  59FE              	; calculate background add to value
1846  59FE 26 00        	LD H, 0
1847  5A00 3A DB 51     	LD A, (BLIT_TMP+2)
1848  5A03 6F           	LD L, A
1849  5A04 CD 50 53     	CALL HLx8
1850  5A07 22 E3 51     	LD (BLIT_STRUCT+6), HL
1851  5A0A              	; calculate pointer to background location
1852  5A0A 21 00 00     	LD HL, 0
1853  5A0D 3A DA 51     	LD A,(BLIT_TMP+1)
1854  5A10 B7           	OR A
1855  5A11 28 08        	JR Z, .L1
1856  5A13 47           	LD B,A
1857  5A14 ED 5B E3 51  	LD DE,(BLIT_STRUCT+6)
1858  5A18              .L0:
1859  5A18 19           	ADD HL, DE
1860  5A19 10 FD        	DJNZ .L0
1861  5A1B              .L1:
1862  5A1B EB           	EX DE,HL
1863  5A1C 26 00        	LD H,0
1864  5A1E 3A D9 51     	LD A,(BLIT_TMP+0)
1865  5A21 6F           	LD L,A
1866  5A22 CD 50 53     	CALL HLx8
1867  5A25 19           	ADD HL,DE
1868  5A26 ED 5B E1 51  	LD DE,(BLIT_STRUCT+4)
1869  5A2A 19           	ADD HL,DE
1870  5A2B 22 E1 51     	LD (BLIT_STRUCT+4),HL
1871  5A2E
1872  5A2E FD 21 35 5A  	LD IY, .RET
1873  5A32 C3 14 54     	JP ENABLE_PAGE0
1874  5A35              .RET:
1875  5A35 FB           	EI
1876  5A36 DD 21 DD 51  	LD IX, BLIT_STRUCT
1877  5A3A CD C2 58     	CALL SHIFT_MERGE_CHARACTER
1878  5A3D
1879  5A3D D1               POP DE
1880  5A3E C1               POP BC
1881  5A3F CD 8B 53         CALL RESTORE_PAGE_INFO
1882  5A42
1883  5A42 E1           	POP HL
1884  5A43 C9           	RET
1885  5A44              .DAdiv8:
1886  5A44 7B           	LD A,E
1887  5A45 CB 2A        	SRA D
1888  5A47 CB 1F            RR  A
1889  5A49 CB 2A            SRA D
1890  5A4B CB 1F            RR  A
1891  5A4D CB 2A            SRA D
1892  5A4F CB 1F            RR  A
1893  5A51 C9           	RET
1894  5A52              ; *******************************************************************************************************
1895  5A52               ENDIF
1896  5A52               ENDIF
1897  5A52
1898  5A52               IF (TILE_CMDS == 1)
1899  5A52              ; *******************************************************************************************************
1900  5A52              ; generic function to implement tiling
1901  5A52              ; should be modified to call appropriate function for memory or vram
1902  5A52              ; input IX=pointer to following structure
1903  5A52              ; +00 tile_data_ptr
1904  5A52              ; +02 tile_rows
1905  5A52              ; +04 tile_columns
1906  5A52              ; +06 destination_address
1907  5A52              ; +08 dest_to_next_row_add_to_value
1908  5A52              ; +10 num_horizontal_tiles
1909  5A52              ; +12 num_vertical_tiles
1910  5A52              ; modifies AF, BC, DE, HL
1911  5A52              TILE:
1912  5A52 DD 6E 06     	LD L, (IX+6)
1913  5A55 DD 66 07     	LD H, (IX+7) ; destination address
1914  5A58 22 D9 51     	LD (TILETMP1), HL
1915  5A5B DD 46 0C     	LD B, (IX+12) ; vertical tile number
1916  5A5E              .L1:
1917  5A5E C5           	PUSH BC
1918  5A5F DD 6E 00     		LD L, (IX+0)
1919  5A62 DD 66 01     		LD H, (IX+1) ; tile address
1920  5A65 22 DB 51     		LD (TILETMP2), HL
1921  5A68 DD 46 02     		LD B, (IX+2) ; tile rows
1922  5A6B              .L2:
1923  5A6B C5           		PUSH BC
1924  5A6C              .CALL1:
1925  5A6C CD 00 00     			CALL 0
1926  5A6F DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1927  5A72              .L3:
1928  5A72 C5           			PUSH BC
1929  5A73 2A DB 51     				LD HL, (TILETMP2)
1930  5A76 DD 46 04     				LD B, (IX+4) ; tile columns
1931  5A79              .L4:
1932  5A79 C5           				PUSH BC
1933  5A7A              .CALL2:
1934  5A7A CD 00 00     					CALL 0
1935  5A7D C1           				POP BC
1936  5A7E 10 F9        				DJNZ .L4
1937  5A80 C1           			POP BC
1938  5A81 10 EF        			DJNZ .L3
1939  5A83 22 DB 51     			LD (TILETMP2), HL
1940  5A86 2A D9 51     			LD HL, (TILETMP1)
1941  5A89 DD 5E 08     			LD E, (IX+8)
1942  5A8C DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1943  5A8F 19           			ADD HL, DE
1944  5A90 22 D9 51     			LD (TILETMP1), HL
1945  5A93 C1           		POP BC
1946  5A94 10 D5        		DJNZ .L2
1947  5A96 C1           	POP BC
1948  5A97 10 C5        	DJNZ .L1
1949  5A99 C9           	RET
1950  5A9A              ; *******************************************************************************************************
1951  5A9A
1952  5A9A               IFNDEF CMDS_WITH_PARAMETERS
1953  5A9A ~            ; *******************************************************************************************************
1954  5A9A ~            ; function to handle CALL TILERAM basic extension
1955  5A9A ~            ; fills memory with tiles
1956  5A9A ~            ; TILERAM ( INT request_data_ptr )
1957  5A9A ~            ; request_data_ptr described in TILE
1958  5A9A ~            ; will put ram in page 0 also, page 1 is already there
1959  5A9A ~            TILERAM:
1960  5A9A ~            	; opening (
1961  5A9A ~            	CALL CHKCHAR
1962  5A9A ~            	DB '('
1963  5A9A ~            	; get pointer to request struct
1964  5A9A ~            	LD IX, FRMQNT
1965  5A9A ~            	CALL CALBAS
1966  5A9A ~            	PUSH DE
1967  5A9A ~            	; ending )
1968  5A9A ~            	CALL CHKCHAR
1969  5A9A ~            	DB ')'
1970  5A9A ~
1971  5A9A ~            	POP IX ; pointer to request struct
1972  5A9A ~
1973  5A9A ~            	PUSH HL ; save position in BASIC buffer
1974  5A9A ~
1975  5A9A ~            	LD IY, .RET
1976  5A9A ~            	JP ENABLE_PAGE0
1977  5A9A ~            .RET:
1978  5A9A ~            	EI
1979  5A9A ~            	; set RAM functions to call
1980  5A9A ~            	LD HL, .TILECOPY
1981  5A9A ~            	LD (TILE.CALL2+1), HL
1982  5A9A ~            	LD HL, .SETDESTROW
1983  5A9A ~            	LD (TILE.CALL1+1), HL
1984  5A9A ~            	CALL TILE
1985  5A9A ~
1986  5A9A ~                POP DE
1987  5A9A ~                POP BC
1988  5A9A ~                CALL RESTORE_PAGE_INFO
1989  5A9A ~
1990  5A9A ~            	POP HL
1991  5A9A ~            	RET
1992  5A9A ~            .TILECOPY:
1993  5A9A ~            	.8 LDI
1994  5A9A ~            	RET
1995  5A9A ~            .SETDESTROW:
1996  5A9A ~            	LD DE, (TILETMP1)
1997  5A9A ~            	RET
1998  5A9A ~            ; *******************************************************************************************************
1999  5A9A               ENDIF
2000  5A9A
2001  5A9A               IFDEF CMDS_WITH_PARAMETERS
2002  5A9A              ; *******************************************************************************************************
2003  5A9A              ; function to handle CALL TILERAM basic extension
2004  5A9A              ; fills memory with tiles
2005  5A9A              ; TILERAM ( INT tile_data_pointer,
2006  5A9A              ;			INT tile_columns,
2007  5A9A              ;			INT tile_rows,
2008  5A9A              ;			INT destination_pointer,
2009  5A9A              ;			INT destination_columns,
2010  5A9A              ;			INT destination_rows,
2011  5A9A              ;			INT destination_begin_column,
2012  5A9A              ;			INT destination_begin_row,
2013  5A9A              ;			INT number_of_tiles_horizontally,
2014  5A9A              ;			INT	number_of_tiles_vertically )
2015  5A9A              ; will put ram in page 0 also, page 1 is already there
2016  5A9A              TILERAM:
2017  5A9A              	; opening (
2018  5A9A CD 61 54     	CALL CHKCHAR
2019  5A9D 28           	DB '('
2020  5A9E              	; get tile data pointer coordinate
2021  5A9E DD 21 2F 54  	LD IX, FRMQNT
2022  5AA2 CD 59 01     	CALL CALBAS
2023  5AA5 ED 53 DD 51  	LD (BLIT_STRUCT+0), DE
2024  5AA9              	; comma
2025  5AA9 CD 61 54     	CALL CHKCHAR
2026  5AAC 2C           	DB ','
2027  5AAD              	; get tile columns
2028  5AAD DD 21 2F 54  	LD IX, FRMQNT
2029  5AB1 CD 59 01     	CALL CALBAS
2030  5AB4 ED 53 E1 51  	LD (BLIT_STRUCT+4), DE
2031  5AB8              	; comma
2032  5AB8 CD 61 54     	CALL CHKCHAR
2033  5ABB 2C           	DB ','
2034  5ABC              	; get tile columns
2035  5ABC DD 21 2F 54  	LD IX, FRMQNT
2036  5AC0 CD 59 01     	CALL CALBAS
2037  5AC3 ED 53 DF 51  	LD (BLIT_STRUCT+2), DE
2038  5AC7              	; comma
2039  5AC7 CD 61 54     	CALL CHKCHAR
2040  5ACA 2C           	DB ','
2041  5ACB              	; get destintion pointer
2042  5ACB DD 21 2F 54  	LD IX, FRMQNT
2043  5ACF CD 59 01     	CALL CALBAS
2044  5AD2 ED 53 E3 51  	LD (BLIT_STRUCT+6), DE
2045  5AD6              	; comma
2046  5AD6 CD 61 54     	CALL CHKCHAR
2047  5AD9 2C           	DB ','
2048  5ADA              	; get destination columns
2049  5ADA DD 21 2F 54  	LD IX, FRMQNT
2050  5ADE CD 59 01     	CALL CALBAS
2051  5AE1 7B           	LD A, E
2052  5AE2 32 D9 51     	LD (BLIT_TMP+0), A
2053  5AE5              	; comma
2054  5AE5 CD 61 54     	CALL CHKCHAR
2055  5AE8 2C           	DB ','
2056  5AE9              	; get destination rows
2057  5AE9 DD 21 2F 54  	LD IX, FRMQNT
2058  5AED CD 59 01     	CALL CALBAS
2059  5AF0 7B           	LD A, E
2060  5AF1 32 DA 51     	LD (BLIT_TMP+1), A
2061  5AF4              	; comma
2062  5AF4 CD 61 54     	CALL CHKCHAR
2063  5AF7 2C           	DB ','
2064  5AF8              	; get destination begin column
2065  5AF8 DD 21 2F 54  	LD IX, FRMQNT
2066  5AFC CD 59 01     	CALL CALBAS
2067  5AFF 7B           	LD A, E
2068  5B00 32 DB 51     	LD (BLIT_TMP+2), A
2069  5B03              	; comma
2070  5B03 CD 61 54     	CALL CHKCHAR
2071  5B06 2C           	DB ','
2072  5B07              	; get destination begin row
2073  5B07 DD 21 2F 54  	LD IX, FRMQNT
2074  5B0B CD 59 01     	CALL CALBAS
2075  5B0E 7B           	LD A, E
2076  5B0F 32 DC 51     	LD (BLIT_TMP+3), A
2077  5B12              	; comma
2078  5B12 CD 61 54     	CALL CHKCHAR
2079  5B15 2C           	DB ','
2080  5B16              	; get number of tiles horizontally
2081  5B16 DD 21 2F 54  	LD IX, FRMQNT
2082  5B1A CD 59 01     	CALL CALBAS
2083  5B1D ED 53 E7 51  	LD (BLIT_STRUCT+10), DE
2084  5B21              	; comma
2085  5B21 CD 61 54     	CALL CHKCHAR
2086  5B24 2C           	DB ','
2087  5B25              	; get number of tiles vertically
2088  5B25 DD 21 2F 54  	LD IX, FRMQNT
2089  5B29 CD 59 01     	CALL CALBAS
2090  5B2C ED 53 E9 51  	LD (BLIT_STRUCT+12), DE
2091  5B30              	; ending )
2092  5B30 CD 61 54     	CALL CHKCHAR
2093  5B33 29           	DB ')'
2094  5B34
2095  5B34 E5           	PUSH HL ; save position in BASIC buffer
2096  5B35
2097  5B35              	; calculate destination add to value
2098  5B35 26 00        	LD H, 0
2099  5B37 3A D9 51     	LD A, (BLIT_TMP+0)
2100  5B3A 6F           	LD L, A
2101  5B3B CD 50 53     	CALL HLx8
2102  5B3E 22 E5 51     	LD (BLIT_STRUCT+8), HL
2103  5B41              	; calculate pointer to background location
2104  5B41 21 00 00     	LD HL, 0
2105  5B44 3A DC 51     	LD A,(BLIT_TMP+3)
2106  5B47 B7           	OR A
2107  5B48 28 08        	JR Z, .L1
2108  5B4A 47           	LD B,A
2109  5B4B ED 5B E5 51  	LD DE,(BLIT_STRUCT+8)
2110  5B4F              .L0:
2111  5B4F 19           	ADD HL, DE
2112  5B50 10 FD        	DJNZ .L0
2113  5B52              .L1:
2114  5B52 EB           	EX DE,HL
2115  5B53 26 00        	LD H,0
2116  5B55 3A DB 51     	LD A,(BLIT_TMP+2)
2117  5B58 6F           	LD L,A
2118  5B59 CD 50 53     	CALL HLx8
2119  5B5C 19           	ADD HL,DE
2120  5B5D ED 5B E3 51  	LD DE,(BLIT_STRUCT+6)
2121  5B61 19           	ADD HL,DE
2122  5B62 22 E3 51     	LD (BLIT_STRUCT+6),HL
2123  5B65
2124  5B65 FD 21 6C 5B  	LD IY, .RET
2125  5B69 C3 14 54     	JP ENABLE_PAGE0
2126  5B6C              .RET:
2127  5B6C FB           	EI
2128  5B6D              	; set RAM functions to call
2129  5B6D 21 87 5B     	LD HL, .TILECOPY
2130  5B70 22 7B 5A     	LD (TILE.CALL2+1), HL
2131  5B73 21 98 5B     	LD HL, .SETDESTROW
2132  5B76 22 6D 5A     	LD (TILE.CALL1+1), HL
2133  5B79 DD 21 DD 51  	LD IX,BLIT_STRUCT
2134  5B7D CD 52 5A     	CALL TILE
2135  5B80
2136  5B80 D1               POP DE
2137  5B81 C1               POP BC
2138  5B82 CD 8B 53         CALL RESTORE_PAGE_INFO
2139  5B85
2140  5B85 E1           	POP HL
2141  5B86 C9           	RET
2142  5B87              .TILECOPY:
2143  5B87 ED A0       > LDI
2143  5B89 ED A0       > LDI
2143  5B8B ED A0       > LDI
2143  5B8D ED A0       > LDI
2143  5B8F ED A0       > LDI
2143  5B91 ED A0       > LDI
2143  5B93 ED A0       > LDI
2143  5B95 ED A0       > LDI
2144  5B97 C9           	RET
2145  5B98              .SETDESTROW:
2146  5B98 ED 5B D9 51  	LD DE, (TILETMP1)
2147  5B9C C9           	RET
2148  5B9D              ; *******************************************************************************************************
2149  5B9D               ENDIF
2150  5B9D
2151  5B9D               IFDEF CMDS_WITH_PARAMETERS
2152  5B9D              ; *******************************************************************************************************
2153  5B9D              ; function to handle CALL TILEVRM basic extension
2154  5B9D              ; fills vram with tiles
2155  5B9D              ; TILEVRM ( INT tile_data_pointer,
2156  5B9D              ;			INT tile_columns,
2157  5B9D              ;			INT tile_rows,
2158  5B9D              ;			INT destination_begin_column,
2159  5B9D              ;			INT destination_begin_row,
2160  5B9D              ;			INT number_of_tiles_horizontally,
2161  5B9D              ;			INT	number_of_tiles_vertically )
2162  5B9D              ; will put ram in page 0 also, page 1 is already there
2163  5B9D              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2164  5B9D              TILEVRM:
2165  5B9D              	; opening (
2166  5B9D CD 61 54     	CALL CHKCHAR
2167  5BA0 28           	DB '('
2168  5BA1              	; get tile data pointer coordinate
2169  5BA1 DD 21 2F 54  	LD IX, FRMQNT
2170  5BA5 CD 59 01     	CALL CALBAS
2171  5BA8 ED 53 DD 51  	LD (BLIT_STRUCT+0), DE
2172  5BAC              	; comma
2173  5BAC CD 61 54     	CALL CHKCHAR
2174  5BAF 2C           	DB ','
2175  5BB0              	; get tile columns
2176  5BB0 DD 21 2F 54  	LD IX, FRMQNT
2177  5BB4 CD 59 01     	CALL CALBAS
2178  5BB7 ED 53 E1 51  	LD (BLIT_STRUCT+4), DE
2179  5BBB              	; comma
2180  5BBB CD 61 54     	CALL CHKCHAR
2181  5BBE 2C           	DB ','
2182  5BBF              	; get tile columns
2183  5BBF DD 21 2F 54  	LD IX, FRMQNT
2184  5BC3 CD 59 01     	CALL CALBAS
2185  5BC6 ED 53 DF 51  	LD (BLIT_STRUCT+2), DE
2186  5BCA              	; comma
2187  5BCA CD 61 54     	CALL CHKCHAR
2188  5BCD 2C           	DB ','
2189  5BCE              	; get destination begin column
2190  5BCE DD 21 2F 54  	LD IX, FRMQNT
2191  5BD2 CD 59 01     	CALL CALBAS
2192  5BD5 7B           	LD A, E
2193  5BD6 32 DB 51     	LD (BLIT_TMP+2), A
2194  5BD9              	; comma
2195  5BD9 CD 61 54     	CALL CHKCHAR
2196  5BDC 2C           	DB ','
2197  5BDD              	; get destination begin row
2198  5BDD DD 21 2F 54  	LD IX, FRMQNT
2199  5BE1 CD 59 01     	CALL CALBAS
2200  5BE4 7B           	LD A, E
2201  5BE5 32 DC 51     	LD (BLIT_TMP+3), A
2202  5BE8              	; comma
2203  5BE8 CD 61 54     	CALL CHKCHAR
2204  5BEB 2C           	DB ','
2205  5BEC              	; get number of tiles horizontally
2206  5BEC DD 21 2F 54  	LD IX, FRMQNT
2207  5BF0 CD 59 01     	CALL CALBAS
2208  5BF3 ED 53 E7 51  	LD (BLIT_STRUCT+10), DE
2209  5BF7              	; comma
2210  5BF7 CD 61 54     	CALL CHKCHAR
2211  5BFA 2C           	DB ','
2212  5BFB              	; get number of tiles vertically
2213  5BFB DD 21 2F 54  	LD IX, FRMQNT
2214  5BFF CD 59 01     	CALL CALBAS
2215  5C02 ED 53 E9 51  	LD (BLIT_STRUCT+12), DE
2216  5C06              	; ending )
2217  5C06 CD 61 54     	CALL CHKCHAR
2218  5C09 29           	DB ')'
2219  5C0A
2220  5C0A E5           	PUSH HL ; save position in BASIC buffer
2221  5C0B
2222  5C0B              	; calculate destination add to value
2223  5C0B 21 00 01     	LD HL, 256
2224  5C0E 22 E5 51     	LD (BLIT_STRUCT+8), HL
2225  5C11              	; calculate pointer to background location
2226  5C11 3A DC 51     	LD A,(BLIT_TMP+3)
2227  5C14 67           	LD H,A
2228  5C15 2E 00        	LD L,0
2229  5C17 EB           	EX DE,HL
2230  5C18 26 00        	LD H,0
2231  5C1A 3A DB 51     	LD A,(BLIT_TMP+2)
2232  5C1D 6F           	LD L,A
2233  5C1E CD 50 53     	CALL HLx8
2234  5C21 19           	ADD HL,DE
2235  5C22 ED 5B CB F3  	LD DE,(GRPCGP)
2236  5C26 19           	ADD HL,DE
2237  5C27 22 E3 51     	LD (BLIT_STRUCT+6),HL
2238  5C2A
2239  5C2A FD 21 31 5C  	LD IY, .RET
2240  5C2E C3 14 54     	JP ENABLE_PAGE0
2241  5C31              .RET:
2242  5C31 FB           	EI
2243  5C32              	; set RAM functions to call
2244  5C32 21 4C 5C     	LD HL, .TILECOPY
2245  5C35 22 7B 5A     	LD (TILE.CALL2+1), HL
2246  5C38 21 52 5C     	LD HL, .SETDESTROW
2247  5C3B 22 6D 5A     	LD (TILE.CALL1+1), HL
2248  5C3E DD 21 DD 51  	LD IX,BLIT_STRUCT
2249  5C42 CD 52 5A     	CALL TILE
2250  5C45
2251  5C45 D1               POP DE
2252  5C46 C1               POP BC
2253  5C47 CD 8B 53         CALL RESTORE_PAGE_INFO
2254  5C4A
2255  5C4A E1           	POP HL
2256  5C4B C9           	RET
2257  5C4C              .TILECOPY:
2258  5C4C 01 98 08     	LD BC, #0898
2259  5C4F C3 49 53     	JP BBYTECOPY
2260  5C52              .SETDESTROW:
2261  5C52 2A D9 51     	LD HL, (TILETMP1)
2262  5C55 F3           	DI
2263  5C56 CD 3E 53     	CALL SETWRT_LOCAL
2264  5C59 FB           	EI
2265  5C5A C9           	RET
2266  5C5B              ; *******************************************************************************************************
2267  5C5B               ENDIF
2268  5C5B
2269  5C5B               IFNDEF CMDS_WITH_PARAMETERS
2270  5C5B ~            ; *******************************************************************************************************
2271  5C5B ~            ; function to handle CALL TILEVRM basic extension
2272  5C5B ~            ; fills vram with tiles
2273  5C5B ~            ; TILEVRM ( INT request_data_ptr )
2274  5C5B ~            ; request_data_ptr described in TILE
2275  5C5B ~            ; will put ram in page 0 also, page 1 is already there
2276  5C5B ~            TILEVRM:
2277  5C5B ~            	; opening (
2278  5C5B ~            	CALL CHKCHAR
2279  5C5B ~            	DB '('
2280  5C5B ~            	; get pointer to request struct
2281  5C5B ~            	LD IX, FRMQNT
2282  5C5B ~            	CALL CALBAS
2283  5C5B ~            	PUSH DE
2284  5C5B ~            	; ending )
2285  5C5B ~            	CALL CHKCHAR
2286  5C5B ~            	DB ')'
2287  5C5B ~
2288  5C5B ~            	POP IX ; pointer to request struct
2289  5C5B ~
2290  5C5B ~            	PUSH HL ; save position in BASIC buffer
2291  5C5B ~
2292  5C5B ~            	LD IY, .RET
2293  5C5B ~            	JP ENABLE_PAGE0
2294  5C5B ~            .RET:
2295  5C5B ~            	EI
2296  5C5B ~            	; set RAM functions to call
2297  5C5B ~            	LD HL, .TILECOPY
2298  5C5B ~            	LD (TILE.CALL2+1), HL
2299  5C5B ~            	LD HL, .SETDESTROW
2300  5C5B ~            	LD (TILE.CALL1+1), HL
2301  5C5B ~            	CALL TILE
2302  5C5B ~
2303  5C5B ~                POP DE
2304  5C5B ~                POP BC
2305  5C5B ~                CALL RESTORE_PAGE_INFO
2306  5C5B ~
2307  5C5B ~            	POP HL
2308  5C5B ~            	RET
2309  5C5B ~            .TILECOPY:
2310  5C5B ~            	LD BC, #0898
2311  5C5B ~            	JP BBYTECOPY
2312  5C5B ~            .SETDESTROW:
2313  5C5B ~            	LD HL, (TILETMP1)
2314  5C5B ~            	DI
2315  5C5B ~            	CALL SETWRT_LOCAL
2316  5C5B ~            	EI
2317  5C5B ~            	RET
2318  5C5B ~            ; *******************************************************************************************************
2319  5C5B               ENDIF
2320  5C5B               ENDIF
2321  5C5B
2322  5C5B               IF (BOX_CMDS == 1)
2323  5C5B              ; *******************************************************************************************************
2324  5C5B              ; generic function to implement rectangle data copy
2325  5C5B              ; should be modified to call appropriate function for memory or vram
2326  5C5B              ; input IX=pointer to following structure
2327  5C5B              ; +00 source data pointer
2328  5C5B              ; +02 num bytes in a row
2329  5C5B              ; +04 number of rows
2330  5C5B              ; +06 source add-to value till next row
2331  5C5B              ; +08 destination address
2332  5C5B              ; +10 destination add-to value till next row
2333  5C5B              ; modifies AF, BC, DE, HL
2334  5C5B              RECTANGLE_COPY:
2335  5C5B DD 6E 00     	LD L, (IX+0)
2336  5C5E DD 66 01     	LD H, (IX+1) ; source address
2337  5C61 DD 5E 08     	LD E, (IX+8)
2338  5C64 DD 56 09     	LD D, (IX+9) ; destination
2339  5C67 DD 46 04     	LD B, (IX+4) ; row number
2340  5C6A              .L1:
2341  5C6A C5           	PUSH BC
2342  5C6B E5           		PUSH HL
2343  5C6C D5           			PUSH DE
2344  5C6D DD 4E 02     				LD C, (IX+2)
2345  5C70 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2346  5C73              .CALL1:
2347  5C73 CD 00 00     				CALL 0 ; set destination address from DE
2348  5C76              .CALL2:
2349  5C76 CD 00 00     				CALL 0 ; copy data fn
2350  5C79 E1           			POP HL
2351  5C7A DD 4E 0A     			LD C, (IX+10)
2352  5C7D DD 46 0B     			LD B, (IX+11) ; destination add-to
2353  5C80 09           			ADD HL, BC
2354  5C81 EB           			EX DE, HL
2355  5C82 E1           		POP HL
2356  5C83 DD 4E 06     		LD C, (IX+6)
2357  5C86 DD 46 07     		LD B, (IX+7) ; src add-to
2358  5C89 09           		ADD HL, BC
2359  5C8A C1           	POP BC
2360  5C8B 10 DD        	DJNZ .L1
2361  5C8D C9           	RET
2362  5C8E              ; *******************************************************************************************************
2363  5C8E
2364  5C8E              ; *******************************************************************************************************
2365  5C8E              ; function to handle CALL BOXMEMCPY basic extension
2366  5C8E              ; copies data with window like boundaries to ram
2367  5C8E              ; BOXMEMCPY ( INT request_data_ptr )
2368  5C8E              ; request_data_ptr described in RECTANGLE_COPY
2369  5C8E              ; will put ram in page 0 also, page 1 is already there
2370  5C8E              BOXMEMCPY:
2371  5C8E              	; opening (
2372  5C8E CD 61 54     	CALL CHKCHAR
2373  5C91 28           	DB '('
2374  5C92              	; get pointer to request struct
2375  5C92 DD 21 2F 54  	LD IX, FRMQNT
2376  5C96 CD 59 01     	CALL CALBAS
2377  5C99 D5           	PUSH DE
2378  5C9A              	; ending )
2379  5C9A CD 61 54     	CALL CHKCHAR
2380  5C9D 29           	DB ')'
2381  5C9E
2382  5C9E DD E1        	POP IX ; pointer to request struct
2383  5CA0
2384  5CA0 E5           	PUSH HL ; save position in BASIC buffer
2385  5CA1
2386  5CA1 FD 21 A8 5C  	LD IY, .RET
2387  5CA5 C3 14 54     	JP ENABLE_PAGE0
2388  5CA8              .RET:
2389  5CA8 FB           	EI
2390  5CA9              	; set RAM functions to call
2391  5CA9 21 00 00     	LD HL, 0
2392  5CAC 22 73 5C     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2393  5CAF 22 75 5C     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2394  5CB2 21 ED B0     	LD HL, #B0ED ; LDIR
2395  5CB5 22 77 5C     	LD (RECTANGLE_COPY.CALL1+4), HL
2396  5CB8 CD 5B 5C     	CALL RECTANGLE_COPY
2397  5CBB
2398  5CBB D1               POP DE
2399  5CBC C1               POP BC
2400  5CBD CD 8B 53         CALL RESTORE_PAGE_INFO
2401  5CC0
2402  5CC0 E1           	POP HL
2403  5CC1 C9           	RET
2404  5CC2              ; *******************************************************************************************************
2405  5CC2
2406  5CC2              ; *******************************************************************************************************
2407  5CC2              ; function to handle CALL BOXMEMVRM basic extension
2408  5CC2              ; copies data with window like boundaries to ram
2409  5CC2              ; BOXMEMVRM ( INT request_data_ptr )
2410  5CC2              ; request_data_ptr described in RECTANGLE_COPY
2411  5CC2              ; will put ram in page 0 also, page 1 is already there
2412  5CC2              BOXMEMVRM:
2413  5CC2              	; opening (
2414  5CC2 CD 61 54     	CALL CHKCHAR
2415  5CC5 28           	DB '('
2416  5CC6              	; get pointer to request struct
2417  5CC6 DD 21 2F 54  	LD IX, FRMQNT
2418  5CCA CD 59 01     	CALL CALBAS
2419  5CCD D5           	PUSH DE
2420  5CCE              	; ending )
2421  5CCE CD 61 54     	CALL CHKCHAR
2422  5CD1 29           	DB ')'
2423  5CD2
2424  5CD2 DD E1        	POP IX ; pointer to request struct
2425  5CD4
2426  5CD4 E5           	PUSH HL ; save position in BASIC buffer
2427  5CD5
2428  5CD5 FD 21 DC 5C  	LD IY, .RET
2429  5CD9 C3 14 54     	JP ENABLE_PAGE0
2430  5CDC              .RET:
2431  5CDC FB           	EI
2432  5CDD              	; set RAM functions to call
2433  5CDD 21 FB 5C     	LD HL, .SETDEST
2434  5CE0 22 74 5C     	LD (RECTANGLE_COPY.CALL1+1), HL
2435  5CE3 21 03 5D     	LD HL, .COPYDATA
2436  5CE6 22 77 5C     	LD (RECTANGLE_COPY.CALL2+1), HL
2437  5CE9 3E CD        	LD A, #CD ; CALL
2438  5CEB 32 73 5C     	LD (RECTANGLE_COPY.CALL1), A
2439  5CEE 32 76 5C     	LD (RECTANGLE_COPY.CALL2), A
2440  5CF1 CD 5B 5C     	CALL RECTANGLE_COPY
2441  5CF4
2442  5CF4 D1               POP DE
2443  5CF5 C1               POP BC
2444  5CF6 CD 8B 53         CALL RESTORE_PAGE_INFO
2445  5CF9
2446  5CF9 E1           	POP HL
2447  5CFA C9           	RET
2448  5CFB              .SETDEST:
2449  5CFB EB           	EX DE, HL
2450  5CFC F3           	DI
2451  5CFD CD 3E 53     	CALL SETWRT_LOCAL
2452  5D00 FB           	EI
2453  5D01 EB           	EX DE, HL
2454  5D02 C9           	RET
2455  5D03              .COPYDATA:
2456  5D03 41           	LD B, C
2457  5D04 0E 98        	LD C, #98
2458  5D06 C3 49 53     	JP BBYTECOPY
2459  5D09              ; *******************************************************************************************************
2460  5D09               ENDIF
2461  5D09
2462  5D09              EXT_END:
2463  5D09
# file closed: asm\main.asm
