# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000
  51  4000              ; BASIC error codes
  52  4000              ;01 NEXT without FOR
  53  4000              ;02 Syntax error
  54  4000              ;03 RETURN without GOSUB
  55  4000              ;04 Out of DATA
  56  4000              ;05 Illegal function call
  57  4000              ;06 Overflow
  58  4000              ;07 Out of memory
  59  4000              ;08 Undefined line number
  60  4000              ;09 Subscript out of range
  61  4000              ;10 Redimensioned array
  62  4000              ;11 Division by zero
  63  4000              ;12 Illegal direct
  64  4000              ;13 Type mismatch
  65  4000              ;14 Out of string space
  66  4000              ;15 String too long
  67  4000              ;16 String formula too complex
  68  4000              ;17 Can't CONTINUE
  69  4000              ;18 Undefined user function
  70  4000              ;19 Device I/O error
  71  4000              ;20 Verify error
  72  4000              ;21 No RESUME
  73  4000              ;22 RESUME without error
  74  4000              ;23 Unprintable error
  75  4000              ;24 Missing operand
  76  4000              ;25 Line buffer overflow
  77  4000              ;50 FIELD overflow
  78  4000              ;51 Internal error
  79  4000              ;52 Bad file number
  80  4000              ;53 File not found
  81  4000              ;54 File already open
  82  4000              ;55 Input past end
  83  4000              ;56 Bad file name
  84  4000              ;57 Direct statement in file
  85  4000              ;58 Sequential I/O only
  86  4000              ;59 File not OPEN
  87  4000
  88  4000
  89  4000               ; simulate cartridge with BASIC extension
  90  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  90  4004 59 55 00 00
  90  4008 00 00 00 00
  90  400C 00 00 00 00
  91  4010
  92  4010              ; this location #4010 stores last location used by basic extension
  93  4010              ; free memory after that point
  94  4010              FREEMEMPTR:
  95  4010 3E 5E         DW EXT_END
  96  4012
  97  4012              ; this location #4012 stores extension version in DAA format
  98  4012              ; first byte is major version and second minor
  99  4012              VERSION:
 100  4012 00 70         DB #00, #70
 101  4014
 102  4014              ; binary included AKG player compiled at #4014
 103  4014               IF (SOUND_CMDS == 1)
 104  4014              	INCBIN "bin/AKG.bin"
 105  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 106  4CF0               ENDIF
 107  4CF0
 108  4CF0              ORIG.HTIMI:
 109  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 109  4CF4 00
 110  4CF5               EXPORT ORIG.HTIMI
 111  4CF5
 112  4CF5               IF (SOUND_CMDS == 1)
 113  4CF5              MUSIC_INIT_STATUS:
 114  4CF5 00            DB 0
 115  4CF6              SFX_INIT_STATUS:
 116  4CF6 00            DB 0
 117  4CF7              SOUND_ENABLED:
 118  4CF7 00            DB 0
 119  4CF8               ENDIF
 120  4CF8
 121  4CF8               IF (SPRITE_CMDS == 1)
 122  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D01              ; changes HL,DE;
  22+ 4D01              GETnthSPRATTR:
  23+ 4D01 26 00            LD H,0
  24+ 4D03 6F               LD L,A
  25+ 4D04 CD 85 54         CALL HLx8
  26+ 4D07 ED 5B FB 4C      LD DE,(SPRATR_DATA)
  27+ 4D0B 19               ADD HL,DE
  28+ 4D0C C9               RET
  29+ 4D0D              ; *******************************************************************************************************
  30+ 4D0D
  31+ 4D0D              ; *******************************************************************************************************
  32+ 4D0D              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D0D              ; struct {
  34+ 4D0D              ; DW y
  35+ 4D0D              ; DW x
  36+ 4D0D              ; DW pattern (0-63)
  37+ 4D0D              ; DW color
  38+ 4D0D              ; } [32]
  39+ 4D0D              ; will hide sprites whose location is outside of visible area
  40+ 4D0D              ; works in screen 1 and 2
  41+ 4D0D              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  42+ 4D0D              ; modifies AF, AF', BC, DE, HL
  43+ 4D0D              SPRATR_UPDATE:
  44+ 4D0D              	; check if initialized
  45+ 4D0D 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  46+ 4D10 B7           	OR A
  47+ 4D11 C8           	RET Z
  48+ 4D12              	; check if update requested
  49+ 4D12 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  50+ 4D15 7E           	LD A, (HL)
  51+ 4D16 B7           	OR A
  52+ 4D17 C8           	RET Z
  53+ 4D18              	; check screen mode
  54+ 4D18 3A AF FC     	LD A, (SCRMOD)
  55+ 4D1B 3D           	DEC A
  56+ 4D1C 28 02        	JR Z, .L0 ; screen 1
  57+ 4D1E 3D           	DEC A
  58+ 4D1F C0           	RET NZ ; not screen 2
  59+ 4D20              .L0:
  60+ 4D20 06 20        	LD B, 32 ; sprite number
  61+ 4D22 0E 98        	LD C, #98 ; register for vdp data output
  62+ 4D24              	; set VDP address
  63+ 4D24 2A 28 F9     	LD HL, (ATRBAS)
  64+ 4D27 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  65+ 4D2A B7           	OR A
  66+ 4D2B 28 03        	JR Z, .L3
  67+ 4D2D 3A FE 4C     	LD A, (FLICKER)
  68+ 4D30              .L3:
  69+ 4D30 5F           	LD E, A
  70+ 4D31 08           	EX AF, AF'
  71+ 4D32 7B           	LD A, E
  72+ 4D33 87           	ADD A, A
  73+ 4D34 87           	ADD A, A
  74+ 4D35 16 00        	LD D, 0
  75+ 4D37 5F           	LD E, A
  76+ 4D38 19           	ADD HL, DE
  77+ 4D39 CD 72 54     	CALL SETWRT_LOCAL
  78+ 4D3C ED 73 FF 4C  	LD (TMPSP), SP
  79+ 4D40 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  80+ 4D44
  81+ 4D44              .LOOP:
  82+ 4D44 E1           	POP HL
  83+ 4D45 24           	INC H
  84+ 4D46 28 0D        	JR Z, .L1 ; negative number above -256
  85+ 4D48 25           	DEC H
  86+ 4D49 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  87+ 4D4B 7D           	LD A, L
  88+ 4D4C FE C0        	CP 192
  89+ 4D4E 30 10        	JR NC, .OUT3
  90+ 4D50 3D           	DEC A ; due to VDP rule that top of screen is -1
  91+ 4D51 57           	LD D, A
  92+ 4D52 C3 70 4D     	JP .X
  93+ 4D55              .L1:
  94+ 4D55 7D           	LD A, L
  95+ 4D56 C6 10        	ADD 16
  96+ 4D58 FA 60 4D     	JP M, .OUT3 ; below -16
  97+ 4D5B 2D           	DEC L ; due to VDP rule that top of screen is -1
  98+ 4D5C 55           	LD D, L
  99+ 4D5D C3 70 4D     	JP .X
 100+ 4D60              .OUT3:
 101+ 4D60 E1           	POP HL ; skip x value
 102+ 4D61              .OUT2:
 103+ 4D61 E1           	POP HL ; skip pattern
 104+ 4D62 E1           	POP HL ; skip color
 105+ 4D63 3E D1        	LD A, #D1
 106+ 4D65 D3 98        	OUT (#98), A ; sprite hidden
 107+ 4D67 D3 98        	OUT (#98), A ; value unimportant
 108+ 4D69 D3 98        	OUT (#98), A ; value unimportant
 109+ 4D6B D3 98        	OUT (#98), A ; value unimportant
 110+ 4D6D C3 9B 4D     	JP .NEXT
 111+ 4D70              .X:
 112+ 4D70 E1           	POP HL
 113+ 4D71 24           	INC H
 114+ 4D72 28 08        	JR Z, .L2
 115+ 4D74 25           	DEC H
 116+ 4D75 20 EA        	JR NZ, .OUT2
 117+ 4D77 1E 00        	LD E, 0 ; EC bit
 118+ 4D79 C3 85 4D     	JP .XY
 119+ 4D7C              .L2:
 120+ 4D7C 7D           	LD A, L
 121+ 4D7D C6 20        	ADD 32
 122+ 4D7F FA 61 4D     	JP M, .OUT2
 123+ 4D82 6F           	LD L, A
 124+ 4D83 1E 80        	LD E, #80
 125+ 4D85              .XY:
 126+ 4D85 ED 51        	OUT (C), D
 127+ 4D87 ED 69        	OUT (C), L
 128+ 4D89 E1           	POP HL ; pattern
 129+ 4D8A 3A E0 F3     	LD A, (REG1SAV)
 130+ 4D8D E6 02        	AND 2
 131+ 4D8F 7D           	LD A, L
 132+ 4D90 28 02        	JR Z, .SMALLSPRITES
 133+ 4D92 87           	ADD A, A
 134+ 4D93 87           	ADD A, A ; needs to go at 4x
 135+ 4D94              .SMALLSPRITES:
 136+ 4D94 D3 98        	OUT (#98), A
 137+ 4D96 E1           	POP HL ; color
 138+ 4D97 7D           	LD A, L
 139+ 4D98 B3           	OR E
 140+ 4D99 D3 98        	OUT (#98), A
 141+ 4D9B              .NEXT:
 142+ 4D9B 08           	EX AF, AF'
 143+ 4D9C 3C           	INC A
 144+ 4D9D E6 1F        	AND 31
 145+ 4D9F C2 B3 4D     	JP NZ, .NEXT2
 146+ 4DA2 08           	EX AF, AF'
 147+ 4DA3 2A 28 F9     	LD HL, (ATRBAS)
 148+ 4DA6              	; CALL SETWRT_LOCAL not allowed as SP modified
 149+ 4DA6 7D           	LD	A, L
 150+ 4DA7 D3 99        	OUT	(099H), A
 151+ 4DA9 7C           	LD	A, H
 152+ 4DAA E6 3F        	AND	03FH
 153+ 4DAC F6 40        	OR	040H
 154+ 4DAE D3 99        	OUT	(099H), A
 155+ 4DB0 C3 B4 4D     	JP .NEXT3
 156+ 4DB3              .NEXT2:
 157+ 4DB3 08           	EX AF, AF'
 158+ 4DB4              .NEXT3:
 159+ 4DB4 10 8E        	DJNZ .LOOP
 160+ 4DB6 08           	EX AF, AF'
 161+ 4DB7 3C           	INC A
 162+ 4DB8 32 FE 4C     	LD (FLICKER), A
 163+ 4DBB
 164+ 4DBB ED 7B FF 4C  	LD SP, (TMPSP)
 165+ 4DBF 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 166+ 4DC2 36 00        	LD (HL), 0 ; zero out update flag
 167+ 4DC4 C9           	RET
 168+ 4DC5              ; *******************************************************************************************************
 169+ 4DC5
 170+ 4DC5              ; *******************************************************************************************************
 171+ 4DC5              ; function to handle CALL SPRENABLE basic extension
 172+ 4DC5              ; initializes sprites handler
 173+ 4DC5              ; _SPRENABLE ( INT sprites_attributes_data,
 174+ 4DC5              ;			   INT update_variable_location,
 175+ 4DC5              ;			   INT sprite_flicker_enabled )
 176+ 4DC5              ; expects both locations to be in range #8000+ or throws an error
 177+ 4DC5              ; since these should be BASIC variables
 178+ 4DC5              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 179+ 4DC5              SPRENABLE:
 180+ 4DC5              	; opening (
 181+ 4DC5 CD 96 55     	CALL CHKCHAR
 182+ 4DC8 28           	DB '('
 183+ 4DC9              	; get address of sprite attribute table DIM SA%(3,31)
 184+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 185+ 4DCD CD 59 01     	CALL CALBAS
 186+ 4DD0 D5           	PUSH DE
 187+ 4DD1              	; comma
 188+ 4DD1 CD 96 55     	CALL CHKCHAR
 189+ 4DD4 2C           	DB ','
 190+ 4DD5              	; get address of sprite update flag location
 191+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 192+ 4DD9 CD 59 01     	CALL CALBAS
 193+ 4DDC D5           	PUSH DE
 194+ 4DDD              	; comma
 195+ 4DDD CD 96 55     	CALL CHKCHAR
 196+ 4DE0 2C           	DB ','
 197+ 4DE1              	; get flicker enabled flag
 198+ 4DE1 DD 21 2F 54  	LD IX, FRMQNT
 199+ 4DE5 CD 59 01     	CALL CALBAS
 200+ 4DE8 D5           	PUSH DE
 201+ 4DE9              	; ending )
 202+ 4DE9 CD 96 55     	CALL CHKCHAR
 203+ 4DEC 29           	DB ')'
 204+ 4DED
 205+ 4DED D1           	POP DE ; get flicker flag
 206+ 4DEE 7A           	LD A, D
 207+ 4DEF B3           	OR E
 208+ 4DF0 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 209+ 4DF3
 210+ 4DF3 D1           	POP DE ; update variable location
 211+ 4DF4 CB 7A        	BIT 7, D ; is address >= &h8000
 212+ 4DF6 20 05        	JR NZ, .L1
 213+ 4DF8 1E 05        	LD E, 5 ; illegal function call
 214+ 4DFA C3 B6 55     	JP THROW_ERROR
 215+ 4DFD              .L1:
 216+ 4DFD ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 217+ 4E01 D1           	POP DE ; address of sprite attribute table
 218+ 4E02 CB 7A        	BIT 7, D ; is address >= &h8000
 219+ 4E04 20 05        	JR NZ, .L2
 220+ 4E06 1E 05        	LD E, 5 ; illegal function call
 221+ 4E08 C3 B6 55     	JP THROW_ERROR
 222+ 4E0B              .L2:
 223+ 4E0B ED 53 FB 4C  	LD (SPRATR_DATA), DE
 224+ 4E0F 3E 01        	LD A, 1
 225+ 4E11 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 226+ 4E14 C9           	RET
 227+ 4E15              ; *******************************************************************************************************
 228+ 4E15
 229+ 4E15              ; *******************************************************************************************************
 230+ 4E15              ; function to handle CALL SPRDISABLE basic extension
 231+ 4E15              ; disables sprites handling
 232+ 4E15              ; _SPRDISABLE
 233+ 4E15              ; resets variable SPRATR_INIT_STATUS
 234+ 4E15              SPRDISABLE:
 235+ 4E15 AF           	XOR A
 236+ 4E16 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 237+ 4E19 C9           	RET
 238+ 4E1A              ; *******************************************************************************************************
 239+ 4E1A
 240+ 4E1A              ; *******************************************************************************************************
 241+ 4E1A              ; function to handle CALL SPRSET basic extension
 242+ 4E1A              ; sets position, and optionally pattern and color of sprite
 243+ 4E1A              ; _SPRSET ( BYTE sprite_num , valid 0-31
 244+ 4E1A              ;			INT x,
 245+ 4E1A              ;			INT y,
 246+ 4E1A              ;			INT pattern, valid 0-63, otherwise ignored
 247+ 4E1A              ;			INT color, valid 0-15, otherwise ignored
 248+ 4E1A              SPRSET:
 249+ 4E1A 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 250+ 4E1D B7           	OR A
 251+ 4E1E 20 05        	JR NZ, .L1
 252+ 4E20 1E 05        	LD E, 5 ; illegal function call
 253+ 4E22 C3 B6 55     	JP THROW_ERROR
 254+ 4E25              .L1:
 255+ 4E25              	; opening (
 256+ 4E25 CD 96 55     	CALL CHKCHAR
 257+ 4E28 28           	DB '('
 258+ 4E29              	; get sprite number
 259+ 4E29 DD 21 1C 52  	LD IX, GETBYT
 260+ 4E2D CD 59 01     	CALL CALBAS
 261+ 4E30 F5           	PUSH AF
 262+ 4E31              	; comma
 263+ 4E31 CD 96 55     	CALL CHKCHAR
 264+ 4E34 2C           	DB ','
 265+ 4E35              	; get x
 266+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 267+ 4E39 CD 59 01     	CALL CALBAS
 268+ 4E3C D5           	PUSH DE
 269+ 4E3D              	; comma
 270+ 4E3D CD 96 55     	CALL CHKCHAR
 271+ 4E40 2C           	DB ','
 272+ 4E41              	; get y
 273+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 274+ 4E45 CD 59 01     	CALL CALBAS
 275+ 4E48 D5           	PUSH DE
 276+ 4E49              	; comma
 277+ 4E49 CD 96 55     	CALL CHKCHAR
 278+ 4E4C 2C           	DB ','
 279+ 4E4D              	; get pattern
 280+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 281+ 4E51 CD 59 01     	CALL CALBAS
 282+ 4E54 D5           	PUSH DE
 283+ 4E55              	; comma
 284+ 4E55 CD 96 55     	CALL CHKCHAR
 285+ 4E58 2C           	DB ','
 286+ 4E59              	; get color
 287+ 4E59 DD 21 2F 54  	LD IX, FRMQNT
 288+ 4E5D CD 59 01     	CALL CALBAS
 289+ 4E60 D5           	PUSH DE
 290+ 4E61              	; ending )
 291+ 4E61 CD 96 55     	CALL CHKCHAR
 292+ 4E64 29           	DB ')'
 293+ 4E65
 294+ 4E65                  ; save position in BASIC text
 295+ 4E65 E5           	PUSH HL
 296+ 4E66 DD E1        	POP IX
 297+ 4E68
 298+ 4E68 C1           	POP BC ; color
 299+ 4E69 D1           	POP DE ; pattern
 300+ 4E6A D9           	EXX
 301+ 4E6B C1           	POP BC ; y
 302+ 4E6C D1           	POP DE ; x
 303+ 4E6D F1           	POP AF ; sprite number
 304+ 4E6E FE 20        	CP 32
 305+ 4E70 38 05        	JR C, .L2
 306+ 4E72 1E 05        	LD E, 5 ; illegal function call
 307+ 4E74 C3 B6 55     	JP THROW_ERROR
 308+ 4E77              .L2:
 309+ 4E77              	; find location in sprite attributes table
 310+ 4E77 D5           	PUSH DE
 311+ 4E78 CD 01 4D     	CALL GETnthSPRATTR
 312+ 4E7B D1           	POP DE
 313+ 4E7C              	; set y
 314+ 4E7C 71           	LD (HL), C
 315+ 4E7D 23           	INC HL
 316+ 4E7E 70           	LD (HL), B
 317+ 4E7F 23           	INC HL
 318+ 4E80              	; set x
 319+ 4E80 73           	LD (HL), E
 320+ 4E81 23           	INC HL
 321+ 4E82 72           	LD (HL), D
 322+ 4E83 23           	INC HL
 323+ 4E84 E5           	PUSH HL
 324+ 4E85 D9           	EXX
 325+ 4E86 E1           	POP HL
 326+ 4E87              	; check if 0<=pattern<64
 327+ 4E87 7A           	LD A, D
 328+ 4E88 B7           	OR A
 329+ 4E89 20 0B        	JR NZ, .L3
 330+ 4E8B 7B           	LD A, E
 331+ 4E8C FE 40        	CP 64
 332+ 4E8E 30 06        	JR NC, .L3
 333+ 4E90              	; set pattern
 334+ 4E90              	;ADD A, A
 335+ 4E90              	;ADD A, A
 336+ 4E90              	;ADD A, A
 337+ 4E90 77           	LD (HL), A
 338+ 4E91 23           	INC HL
 339+ 4E92 72           	LD (HL), D
 340+ 4E93 23           	INC HL
 341+ 4E94 18 02        	JR .L4
 342+ 4E96              .L3:
 343+ 4E96              	; skip pattern
 344+ 4E96 23          > INC HL
 344+ 4E97 23          > INC HL
 345+ 4E98              .L4:
 346+ 4E98              	; check if 0<=color<16
 347+ 4E98 78           	LD A, B
 348+ 4E99 B7           	OR A
 349+ 4E9A 20 08        	JR NZ, .L5
 350+ 4E9C 79           	LD A, C
 351+ 4E9D FE 10        	CP 16
 352+ 4E9F 30 03        	JR NC, .L5
 353+ 4EA1              	; set color
 354+ 4EA1 71           	LD (HL), C
 355+ 4EA2 23           	INC HL
 356+ 4EA3 70           	LD (HL), B
 357+ 4EA4
 358+ 4EA4              .L5:
 359+ 4EA4 DD E5        	PUSH IX
 360+ 4EA6 E1           	POP HL
 361+ 4EA7 C9           	RET
 362+ 4EA8              ; *******************************************************************************************************
 363+ 4EA8
 364+ 4EA8              ; *******************************************************************************************************
 365+ 4EA8              ; function sets sprite location based on initial coordinates and offset provided
 366+ 4EA8              ; input A=sprite number in SPRATR_DATA , 0-31
 367+ 4EA8              ; input DE=initial x
 368+ 4EA8              ; input BC=initial y
 369+ 4EA8              ; input IY=location where delta y,x are located
 370+ 4EA8              ; modifies AF, HL, IX
 371+ 4EA8              SPRSET_DELTA_POS:
 372+ 4EA8 D5           	PUSH DE
 373+ 4EA9 CD 01 4D     	CALL GETnthSPRATTR
 374+ 4EAC E5           	PUSH HL
 375+ 4EAD DD E1        	POP IX
 376+ 4EAF D1           	POP DE
 377+ 4EB0              	; IX=sprite's y location
 378+ 4EB0 FD 6E 00     	LD L, (IY)
 379+ 4EB3 FD 66 01     	LD H, (IY+1)
 380+ 4EB6 09           	ADD HL, BC
 381+ 4EB7 DD 75 00     	LD (IX), L
 382+ 4EBA DD 74 01     	LD (IX+1), H
 383+ 4EBD FD 6E 02     	LD L, (IY+2)
 384+ 4EC0 FD 66 03     	LD H, (IY+3)
 385+ 4EC3 19           	ADD HL, DE
 386+ 4EC4 DD 75 02     	LD (IX+2), L
 387+ 4EC7 DD 74 03     	LD (IX+3), H
 388+ 4ECA C9           	RET
 389+ 4ECB              ; *******************************************************************************************************
 390+ 4ECB
 391+ 4ECB              ; *******************************************************************************************************
 392+ 4ECB              ; function to handle CALL SPRGRPMOV basic extension
 393+ 4ECB              ; sets position of a group of sprites described with
 394+ 4ECB              ; { int sprite_num, int delta_y, int delta_x } [count]
 395+ 4ECB              ; _SPRGRPMOV ( INT x,
 396+ 4ECB              ;			   INT y,
 397+ 4ECB              ;			   INT data_ptr,
 398+ 4ECB              ;			   BYTE count,
 399+ 4ECB              ; will put ram in page 0 also, page 1 is already there
 400+ 4ECB              SPRGRPMOV:
 401+ 4ECB 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 402+ 4ECE B7           	OR A
 403+ 4ECF 20 05        	JR NZ, .L1
 404+ 4ED1 1E 05        	LD E, 5 ; illegal function call
 405+ 4ED3 C3 B6 55     	JP THROW_ERROR
 406+ 4ED6              .L1:
 407+ 4ED6              	; opening (
 408+ 4ED6 CD 96 55     	CALL CHKCHAR
 409+ 4ED9 28           	DB '('
 410+ 4EDA              	; get x
 411+ 4EDA DD 21 2F 54  	LD IX, FRMQNT
 412+ 4EDE CD 59 01     	CALL CALBAS
 413+ 4EE1 D5           	PUSH DE
 414+ 4EE2              	; comma
 415+ 4EE2 CD 96 55     	CALL CHKCHAR
 416+ 4EE5 2C           	DB ','
 417+ 4EE6              	; get y
 418+ 4EE6 DD 21 2F 54  	LD IX, FRMQNT
 419+ 4EEA CD 59 01     	CALL CALBAS
 420+ 4EED D5           	PUSH DE
 421+ 4EEE              	; comma
 422+ 4EEE CD 96 55     	CALL CHKCHAR
 423+ 4EF1 2C           	DB ','
 424+ 4EF2              	; get data pointer
 425+ 4EF2 DD 21 2F 54  	LD IX, FRMQNT
 426+ 4EF6 CD 59 01     	CALL CALBAS
 427+ 4EF9 D5           	PUSH DE
 428+ 4EFA              	; comma
 429+ 4EFA CD 96 55     	CALL CHKCHAR
 430+ 4EFD 2C           	DB ','
 431+ 4EFE              	; get count
 432+ 4EFE DD 21 1C 52  	LD IX, GETBYT
 433+ 4F02 CD 59 01     	CALL CALBAS
 434+ 4F05 F5           	PUSH AF
 435+ 4F06              	; ending )
 436+ 4F06 CD 96 55     	CALL CHKCHAR
 437+ 4F09 29           	DB ')'
 438+ 4F0A
 439+ 4F0A E5           	PUSH HL
 440+ 4F0B DD E1        	POP IX
 441+ 4F0D
 442+ 4F0D C1           	POP BC ; count
 443+ 4F0E E1           	POP HL ; data pointer
 444+ 4F0F D9           	EXX
 445+ 4F10 C1           	POP BC ; y
 446+ 4F11 D1           	POP DE ; x
 447+ 4F12 D9           	EXX
 448+ 4F13
 449+ 4F13 DD E5        	PUSH IX ; save position in BASIC buffer
 450+ 4F15
 451+ 4F15 C5           	PUSH BC
 452+ 4F16 E5           	PUSH HL
 453+ 4F17 AF               XOR A
 454+ 4F18 CD 89 54         CALL GET_PAGE_INFO
 455+ 4F1B D9           	EXX
 456+ 4F1C E1           	POP HL
 457+ 4F1D F1           	POP AF
 458+ 4F1E D9           	EXX
 459+ 4F1F C5               PUSH BC
 460+ 4F20 D5               PUSH DE
 461+ 4F21 D9           	EXX
 462+ 4F22 F5           	PUSH AF
 463+ 4F23 E5           	PUSH HL
 464+ 4F24 D9           	EXX
 465+ 4F25 3A 41 F3         LD A, (RAMAD0)
 466+ 4F28 26 00            LD H, 0
 467+ 4F2A CD D0 54         CALL LOCAL_ENASLT
 468+ 4F2D FB           	EI
 469+ 4F2E E1           	POP HL
 470+ 4F2F C1           	POP BC
 471+ 4F30 CD 3A 4F     	CALL .UPDATE_LOC
 472+ 4F33 D1               POP DE
 473+ 4F34 C1               POP BC
 474+ 4F35 CD C0 54         CALL RESTORE_PAGE_INFO
 475+ 4F38 E1           	POP HL
 476+ 4F39 C9           	RET
 477+ 4F3A
 478+ 4F3A              .UPDATE_LOC:
 479+ 4F3A              .L4:
 480+ 4F3A 7E           	LD A, (HL)
 481+ 4F3B 23           	INC HL
 482+ 4F3C 23           	INC HL
 483+ 4F3D E5           	PUSH HL
 484+ 4F3E FD E1        	POP IY
 485+ 4F40 D9           	EXX
 486+ 4F41 CD A8 4E     	CALL SPRSET_DELTA_POS
 487+ 4F44 D9           	EXX
 488+ 4F45 23          > INC HL
 488+ 4F46 23          > INC HL
 488+ 4F47 23          > INC HL
 488+ 4F48 23          > INC HL
 489+ 4F49 10 EF        	DJNZ .L4
 490+ 4F4B C9           	RET
 491+ 4F4C              ; *******************************************************************************************************
 492+ 4F4C
# file closed: asm\SPRITES.asm
 123  4F4C               ENDIF
 124  4F4C
 125  4F4C               IF (ANIM_CMDS == 1)
 126  4F4C               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4C              ; sprite animation routines
   2+ 4F4C
   3+ 4F4C              ; number of animation items and pointer
   4+ 4F4C              ANIMITEMNUM:
   5+ 4F4C 00            DB 0
   6+ 4F4D              ANIMITEMPTR:
   7+ 4F4D 3E 5E         DW EXT_END
   8+ 4F4F              ; number of animation definitions and pointer
   9+ 4F4F              ANIMDEFNUM:
  10+ 4F4F 00            DB 0
  11+ 4F50              ANIMDEFPTR:
  12+ 4F50 3E 5E         DW EXT_END
  13+ 4F52              ; number of links between sprite and animation definitions
  14+ 4F52              ANIMSPRNUM:
  15+ 4F52 00            DB 0
  16+ 4F53              ANIMSPRPTR:
  17+ 4F53 3E 5E         DW EXT_END
  18+ 4F55
  19+ 4F55              ; ANIMATION ITEM
  20+ 4F55              ; byte type = [0 - pattern and color change
  21+ 4F55              ;              1 - pattern definition change ]
  22+ 4F55              ; word ticks - number of ticks to hold this state
  23+ 4F55              ; for type = 0
  24+ 4F55              ;   byte pattern;
  25+ 4F55              ;   byte color;
  26+ 4F55              ; for type = 1
  27+ 4F55              ;   work data_pointer;
  28+ 4F55              ; total size = 5b
  29+ 4F55
  30+ 4F55              ; ANIMATION DEFINITION
  31+ 4F55              ; byte number of items 1-15
  32+ 4F55              ; byte[15] anim_item;
  33+ 4F55              ; total size = 16b
  34+ 4F55
  35+ 4F55              ; SPRITE ANIMATION
  36+ 4F55              ; +00 byte sprite number;
  37+ 4F55              ; +01 word time;
  38+ 4F55              ; +03 byte current item;
  39+ 4F55              ; +04 byte animation definition;
  40+ 4F55              ; +05 byte cyclic;
  41+ 4F55              ; +06 byte active;
  42+ 4F55              ; +07 byte reserved
  43+ 4F55              ; total size = 8b
  44+ 4F55
  45+ 4F55              ; *******************************************************************************************************
  46+ 4F55              ; helper function HL=A*5
  47+ 4F55              ; changes HL,DE;
  48+ 4F55              Ax5:
  49+ 4F55 26 00            LD H,0
  50+ 4F57 6F               LD L,A
  51+ 4F58 54               LD D,H
  52+ 4F59 5D               LD E,L
  53+ 4F5A 29               ADD HL,HL
  54+ 4F5B 29               ADD HL,HL
  55+ 4F5C 19               ADD HL,DE
  56+ 4F5D C9               RET
  57+ 4F5E              ; *******************************************************************************************************
  58+ 4F5E
  59+ 4F5E              ; *******************************************************************************************************
  60+ 4F5E              ; helper function gets pointer to n-th animation item
  61+ 4F5E              ; changes HL,DE;
  62+ 4F5E              GETnthANIMITEM:
  63+ 4F5E CD 55 4F         CALL Ax5
  64+ 4F61 ED 5B 4D 4F      LD DE,(ANIMITEMPTR)
  65+ 4F65 19               ADD HL,DE
  66+ 4F66 C9               RET
  67+ 4F67              ; *******************************************************************************************************
  68+ 4F67
  69+ 4F67              ; *******************************************************************************************************
  70+ 4F67              ; helper function gets pointer to n-th entry in animation definition
  71+ 4F67              ; changes HL,DE;
  72+ 4F67              GETnthANIMDEF:
  73+ 4F67 26 00            LD H,0
  74+ 4F69 6F               LD L,A
  75+ 4F6A CD 85 54         CALL HLx8
  76+ 4F6D ED 5B 50 4F      LD DE,(ANIMDEFPTR)
  77+ 4F71 19               ADD HL,DE
  78+ 4F72 C9               RET
  79+ 4F73              ; *******************************************************************************************************
  80+ 4F73
  81+ 4F73              ; *******************************************************************************************************
  82+ 4F73              ; helper function gets pointer to n-th entry in sprite animation
  83+ 4F73              ; changes HL,DE;
  84+ 4F73              GETnthSPRANIM:
  85+ 4F73 26 00            LD H,0
  86+ 4F75 6F               LD L,A
  87+ 4F76 CD 84 54         CALL HLx16
  88+ 4F79 ED 5B 53 4F      LD DE,(ANIMSPRPTR)
  89+ 4F7D 19               ADD HL,DE
  90+ 4F7E C9               RET
  91+ 4F7F              ; *******************************************************************************************************
  92+ 4F7F
  93+ 4F7F              ; *******************************************************************************************************
  94+ 4F7F              ; function to handle CALL MAXANIMITEMS basic extension
  95+ 4F7F              ; MAXANIMITEMS (BYTE number)
  96+ 4F7F              ; sets new number and moves memory buffers as needed
  97+ 4F7F              MAXANIMITEMS:
  98+ 4F7F              	; opening (
  99+ 4F7F CD 96 55     	CALL CHKCHAR
 100+ 4F82 28           	DB '('
 101+ 4F83              	; get value
 102+ 4F83 DD 21 1C 52  	LD IX, GETBYT
 103+ 4F87 CD 59 01     	CALL CALBAS
 104+ 4F8A F5               PUSH AF
 105+ 4F8B              	; ending )
 106+ 4F8B CD 96 55     	CALL CHKCHAR
 107+ 4F8E 29           	DB ')'
 108+ 4F8F F1               POP AF
 109+ 4F90
 110+ 4F90              	; save position
 111+ 4F90 E5           	PUSH HL
 112+ 4F91              .ENTRY:
 113+ 4F91 47               LD B,A
 114+ 4F92 3A 4C 4F         LD A,(ANIMITEMNUM)
 115+ 4F95 90               SUB B
 116+ 4F96 28 1F            JR Z, .EXIT; same value as before
 117+ 4F98 FD 21 50 4F      LD IY,ANIMDEFPTR
 118+ 4F9C FA BA 4F         JP M, .INCREASE
 119+ 4F9F                  ; new value is lower than previous one
 120+ 4F9F CD D2 4F         CALL .SIZEDIFF
 121+ 4FA2 CD ED 4F         CALL .DECREASE_COMMON
 122+ 4FA5 2A 53 4F         LD HL,(ANIMSPRPTR)
 123+ 4FA8 AF               XOR A
 124+ 4FA9 ED 42            SBC HL,BC
 125+ 4FAB 22 53 4F         LD (ANIMSPRPTR),HL
 126+ 4FAE              .E1:
 127+ 4FAE 2A 10 40         LD HL,(FREEMEMPTR)
 128+ 4FB1 AF               XOR A
 129+ 4FB2 ED 42            SBC HL,BC
 130+ 4FB4 22 10 40         LD (FREEMEMPTR),HL
 131+ 4FB7              .EXIT:
 132+ 4FB7 FB               EI
 133+ 4FB8 E1           	POP HL
 134+ 4FB9 C9           	RET
 135+ 4FBA              .INCREASE:
 136+ 4FBA ED 44            NEG
 137+ 4FBC CD D2 4F         CALL .SIZEDIFF
 138+ 4FBF CD 19 50         CALL .INCREASE_COMMON
 139+ 4FC2 2A 53 4F         LD HL,(ANIMSPRPTR)
 140+ 4FC5 09               ADD HL,BC
 141+ 4FC6 22 53 4F         LD (ANIMSPRPTR),HL
 142+ 4FC9              .E2:
 143+ 4FC9 2A 10 40         LD HL,(FREEMEMPTR)
 144+ 4FCC 09               ADD HL,BC
 145+ 4FCD 22 10 40         LD (FREEMEMPTR),HL
 146+ 4FD0 18 E5            JR .EXIT
 147+ 4FD2              .SIZEDIFF:
 148+ 4FD2 CD 55 4F         CALL Ax5
 149+ 4FD5 78               LD A,B
 150+ 4FD6 32 4C 4F         LD (ANIMITEMNUM),A
 151+ 4FD9 44               LD B,H
 152+ 4FDA 4D               LD C,L
 153+ 4FDB C9               RET ; BC=size difference in bytes
 154+ 4FDC              .SIZETOMOVE:
 155+ 4FDC D5               PUSH DE
 156+ 4FDD 2A 10 40         LD HL,(FREEMEMPTR)
 157+ 4FE0 FD 5E 00         LD E,(IY)
 158+ 4FE3 FD 56 01         LD D,(IY+1)
 159+ 4FE6 AF               XOR A
 160+ 4FE7 ED 52            SBC HL,DE
 161+ 4FE9 44               LD B,H
 162+ 4FEA 4D               LD C,L
 163+ 4FEB D1               POP DE
 164+ 4FEC C9               RET
 165+ 4FED              .DECREASE_COMMON:
 166+ 4FED FD 6E 00         LD L,(IY)
 167+ 4FF0 FD 66 01         LD H,(IY+1)
 168+ 4FF3 AF               XOR A
 169+ 4FF4 ED 42            SBC HL,BC
 170+ 4FF6 EB               EX DE,HL
 171+ 4FF7 C5               PUSH BC
 172+ 4FF8 CD DC 4F         CALL .SIZETOMOVE
 173+ 4FFB F3               DI
 174+ 4FFC 78               LD A,B
 175+ 4FFD B1               OR C
 176+ 4FFE 28 08            JR Z,.L1
 177+ 5000 FD 6E 00         LD L,(IY)
 178+ 5003 FD 66 01         LD H,(IY+1)
 179+ 5006 ED B0            LDIR
 180+ 5008              .L1:
 181+ 5008 C1               POP BC
 182+ 5009 FD 6E 00         LD L,(IY)
 183+ 500C FD 66 01         LD H,(IY+1)
 184+ 500F AF               XOR A
 185+ 5010 ED 42            SBC HL,BC
 186+ 5012 FD 75 00         LD (IY),L
 187+ 5015 FD 74 01         LD (IY+1),H
 188+ 5018 C9               RET
 189+ 5019              .INCREASE_COMMON:
 190+ 5019 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 501C 2B               DEC HL
 192+ 501D AF               XOR A
 193+ 501E ED 42            SBC HL,BC
 194+ 5020 EB               EX DE,HL
 195+ 5021 C5               PUSH BC
 196+ 5022 CD DC 4F         CALL .SIZETOMOVE
 197+ 5025 F3               DI
 198+ 5026 78               LD A,B
 199+ 5027 B1               OR C
 200+ 5028 28 06            JR Z,.L2
 201+ 502A 2A 10 40         LD HL,(FREEMEMPTR)
 202+ 502D 2B               DEC HL
 203+ 502E ED B8            LDDR
 204+ 5030              .L2:
 205+ 5030 C1               POP BC
 206+ 5031 FD 6E 00         LD L,(IY)
 207+ 5034 FD 66 01         LD H,(IY+1)
 208+ 5037 09               ADD HL,BC
 209+ 5038 FD 75 00         LD (IY),L
 210+ 503B FD 74 01         LD (IY+1),H
 211+ 503E C9               RET
 212+ 503F              ; *******************************************************************************************************
 213+ 503F
 214+ 503F              ; *******************************************************************************************************
 215+ 503F              ; function to handle CALL ANIMITEMPAT basic extension
 216+ 503F              ; ANIMITEMPAT ( BYTE id,
 217+ 503F              ;               INT ticks,
 218+ 503F              ;               BYTE pattern,
 219+ 503F              ;               BYTE color )
 220+ 503F              ; fills animation item data, returns an error if out of bounds
 221+ 503F              ANIMITEMPAT:
 222+ 503F                  ; opening (
 223+ 503F CD 96 55     	CALL CHKCHAR
 224+ 5042 28           	DB '('
 225+ 5043              	; get id
 226+ 5043 DD 21 1C 52  	LD IX, GETBYT
 227+ 5047 CD 59 01     	CALL CALBAS
 228+ 504A F5               PUSH AF
 229+ 504B                  ; check if out of bounds
 230+ 504B 3C               INC A
 231+ 504C 4F               LD C,A
 232+ 504D 3A 4C 4F         LD A,(ANIMITEMNUM)
 233+ 5050 B9               CP C
 234+ 5051 DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 235+ 5054              	; comma
 236+ 5054 CD 96 55     	CALL CHKCHAR
 237+ 5057 2C           	DB ','
 238+ 5058              	; get ticks
 239+ 5058 DD 21 2F 54  	LD IX, FRMQNT
 240+ 505C CD 59 01     	CALL CALBAS
 241+ 505F D5           	PUSH DE
 242+ 5060              	; comma
 243+ 5060 CD 96 55     	CALL CHKCHAR
 244+ 5063 2C           	DB ','
 245+ 5064              	; get pattern
 246+ 5064 DD 21 1C 52  	LD IX, GETBYT
 247+ 5068 CD 59 01     	CALL CALBAS
 248+ 506B F5               PUSH AF
 249+ 506C              	; comma
 250+ 506C CD 96 55     	CALL CHKCHAR
 251+ 506F 2C           	DB ','
 252+ 5070              	; get color
 253+ 5070 DD 21 1C 52  	LD IX, GETBYT
 254+ 5074 CD 59 01     	CALL CALBAS
 255+ 5077 F5               PUSH AF
 256+ 5078              	; ending )
 257+ 5078 CD 96 55     	CALL CHKCHAR
 258+ 507B 29           	DB ')'
 259+ 507C              .ENTRY:
 260+ 507C E5               PUSH HL
 261+ 507D DD E1            POP IX
 262+ 507F D9               EXX
 263+ 5080 C1               POP BC ; color
 264+ 5081 D1               POP DE ; pattern
 265+ 5082 E1               POP HL ; ticks
 266+ 5083 D9               EXX
 267+ 5084 F1               POP AF
 268+ 5085 CD 5E 4F         CALL GETnthANIMITEM
 269+ 5088 E5               PUSH HL
 270+ 5089 FD E1            POP IY
 271+ 508B D9               EXX
 272+ 508C FD 36 00 00      LD (IY),0 ; type=0
 273+ 5090 FD 75 01         LD (IY+1),L
 274+ 5093 FD 74 02         LD (IY+2),H
 275+ 5096 FD 72 03         LD (IY+3),D
 276+ 5099 FD 70 04         LD (IY+4),B
 277+ 509C
 278+ 509C DD E5            PUSH IX
 279+ 509E E1               POP HL
 280+ 509F C9               RET
 281+ 50A0              ; *******************************************************************************************************
 282+ 50A0
 283+ 50A0              ; *******************************************************************************************************
 284+ 50A0              ; function to handle CALL ANIMITEMPTR basic extension
 285+ 50A0              ; ANIMITEMPTR ( BYTE id,
 286+ 50A0              ;               INT ticks,
 287+ 50A0              ;               INT pointer,
 288+ 50A0              ; fills animation item data, returns an error if out of bounds
 289+ 50A0              ANIMITEMPTR_CMD:
 290+ 50A0                  ; opening (
 291+ 50A0 CD 96 55     	CALL CHKCHAR
 292+ 50A3 28           	DB '('
 293+ 50A4              	; get id
 294+ 50A4 DD 21 1C 52  	LD IX, GETBYT
 295+ 50A8 CD 59 01     	CALL CALBAS
 296+ 50AB F5               PUSH AF
 297+ 50AC                  ; check if out of bounds
 298+ 50AC 3C               INC A
 299+ 50AD 4F               LD C,A
 300+ 50AE 3A 4C 4F         LD A,(ANIMITEMNUM)
 301+ 50B1 B9               CP C
 302+ 50B2 DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 303+ 50B5              	; comma
 304+ 50B5 CD 96 55     	CALL CHKCHAR
 305+ 50B8 2C           	DB ','
 306+ 50B9              	; get ticks
 307+ 50B9 DD 21 2F 54  	LD IX, FRMQNT
 308+ 50BD CD 59 01     	CALL CALBAS
 309+ 50C0 D5           	PUSH DE
 310+ 50C1              	; comma
 311+ 50C1 CD 96 55     	CALL CHKCHAR
 312+ 50C4 2C           	DB ','
 313+ 50C5              	; get pointer
 314+ 50C5 DD 21 2F 54  	LD IX, FRMQNT
 315+ 50C9 CD 59 01     	CALL CALBAS
 316+ 50CC D5           	PUSH DE
 317+ 50CD              	; ending )
 318+ 50CD CD 96 55     	CALL CHKCHAR
 319+ 50D0 29           	DB ')'
 320+ 50D1              .ENTRY:
 321+ 50D1 E5               PUSH HL
 322+ 50D2 DD E1            POP IX
 323+ 50D4 D9               EXX
 324+ 50D5 D1               POP DE ; pointer
 325+ 50D6 E1               POP HL ; ticks
 326+ 50D7 D9               EXX
 327+ 50D8 F1               POP AF
 328+ 50D9 CD 5E 4F         CALL GETnthANIMITEM
 329+ 50DC E5               PUSH HL
 330+ 50DD FD E1            POP IY
 331+ 50DF D9               EXX
 332+ 50E0 FD 36 00 01      LD (IY),1 ; type=1
 333+ 50E4 FD 75 01         LD (IY+1),L
 334+ 50E7 FD 74 02         LD (IY+2),H
 335+ 50EA FD 73 03         LD (IY+3),E
 336+ 50ED FD 72 04         LD (IY+4),D
 337+ 50F0
 338+ 50F0 DD E5            PUSH IX
 339+ 50F2 E1               POP HL
 340+ 50F3 C9               RET
 341+ 50F4              ; *******************************************************************************************************
 342+ 50F4
 343+ 50F4              ; *******************************************************************************************************
 344+ 50F4              ; function to handle CALL MAXANIMDEFS basic extension
 345+ 50F4              ; MAXANIMDEFS (BYTE number)
 346+ 50F4              ; sets new number and moves memory buffers as needed
 347+ 50F4              MAXANIMDEFS:
 348+ 50F4              	; opening (
 349+ 50F4 CD 96 55     	CALL CHKCHAR
 350+ 50F7 28           	DB '('
 351+ 50F8              	; get value
 352+ 50F8 DD 21 1C 52  	LD IX, GETBYT
 353+ 50FC CD 59 01     	CALL CALBAS
 354+ 50FF F5               PUSH AF
 355+ 5100              	; ending )
 356+ 5100 CD 96 55     	CALL CHKCHAR
 357+ 5103 29           	DB ')'
 358+ 5104 F1               POP AF
 359+ 5105
 360+ 5105              	; save position
 361+ 5105 E5           	PUSH HL
 362+ 5106              .ENTRY:
 363+ 5106 47               LD B,A
 364+ 5107 3A 4F 4F         LD A,(ANIMDEFNUM)
 365+ 510A 90               SUB B
 366+ 510B CA B7 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 367+ 510E FD 21 53 4F      LD IY,ANIMSPRPTR
 368+ 5112 FA 1E 51         JP M, .INCREASE
 369+ 5115                  ; new value is lower than previous one
 370+ 5115 CD 29 51         CALL .SIZEDIFF
 371+ 5118 CD ED 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 372+ 511B C3 AE 4F         JP MAXANIMITEMS.E1
 373+ 511E              .INCREASE:
 374+ 511E ED 44            NEG
 375+ 5120 CD 29 51         CALL .SIZEDIFF
 376+ 5123 CD 19 50         CALL MAXANIMITEMS.INCREASE_COMMON
 377+ 5126 C3 C9 4F         JP MAXANIMITEMS.E2
 378+ 5129              .SIZEDIFF:
 379+ 5129 26 00            LD H,0
 380+ 512B 6F               LD L,A
 381+ 512C CD 84 54         CALL HLx16
 382+ 512F 78               LD A,B
 383+ 5130 32 4F 4F         LD (ANIMDEFNUM),A
 384+ 5133 44               LD B,H
 385+ 5134 4D               LD C,L
 386+ 5135 C9               RET ; BC=size difference in bytes
 387+ 5136              ; *******************************************************************************************************
 388+ 5136
 389+ 5136              ; *******************************************************************************************************
 390+ 5136              ; function to handle CALL ANIMDEF basic extension
 391+ 5136              ; ANIMITEMPAT ( BYTE id,
 392+ 5136              ;               BYTE size,
 393+ 5136              ;               INT[] list )
 394+ 5136              ; fills animation definition data, returns an error if out of bounds, or invalid type
 395+ 5136              ANIMDEF:
 396+ 5136                  ; opening (
 397+ 5136 CD 96 55     	CALL CHKCHAR
 398+ 5139 28           	DB '('
 399+ 513A              	; get id
 400+ 513A DD 21 1C 52  	LD IX, GETBYT
 401+ 513E CD 59 01     	CALL CALBAS
 402+ 5141 F5               PUSH AF
 403+ 5142                  ; check if out of bounds
 404+ 5142 3C               INC A
 405+ 5143 4F               LD C,A
 406+ 5144 3A 4F 4F         LD A,(ANIMDEFNUM)
 407+ 5147 B9               CP C
 408+ 5148 DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 409+ 514B              	; comma
 410+ 514B CD 96 55     	CALL CHKCHAR
 411+ 514E 2C           	DB ','
 412+ 514F              	; get size
 413+ 514F DD 21 1C 52  	LD IX, GETBYT
 414+ 5153 CD 59 01     	CALL CALBAS
 415+ 5156 FE 10            CP 16
 416+ 5158 D2 B0 55         JP NC, OVERFLOW
 417+ 515B B7               OR A
 418+ 515C CA B0 55         JP Z, OVERFLOW
 419+ 515F F5           	PUSH AF
 420+ 5160              	; comma
 421+ 5160 CD 96 55     	CALL CHKCHAR
 422+ 5163 2C           	DB ','
 423+ 5164              	; get pointer to a list of animation items in integer array format
 424+ 5164 3E 01            LD A,1
 425+ 5166 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 426+ 5169 DD 21 A4 5E  	LD IX, PTRGET
 427+ 516D CD 59 01     	CALL CALBAS
 428+ 5170                  ; contrary to documentation we get a pointer to array dimension in BC
 429+ 5170                  ; and type in VALTYP
 430+ 5170 3A 63 F6         LD A,(VALTYP)
 431+ 5173 FE 02            CP 2
 432+ 5175 C2 A8 55         JP NZ,TYPE_MISMATCH
 433+ 5178 0A               LD A,(BC)
 434+ 5179 FE 01            CP 1
 435+ 517B C2 A8 55         JP NZ,TYPE_MISMATCH
 436+ 517E 03               INC BC
 437+ 517F 0A               LD A,(BC)
 438+ 5180 D1               POP DE
 439+ 5181 D5               PUSH DE
 440+ 5182 3C               INC A
 441+ 5183 BA               CP D
 442+ 5184 DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 443+ 5187 03          > INC BC
 443+ 5188 03          > INC BC
 444+ 5189 C5               PUSH BC
 445+ 518A              	; ending )
 446+ 518A CD 96 55     	CALL CHKCHAR
 447+ 518D 29           	DB ')'
 448+ 518E              .ENTRY:
 449+ 518E E5               PUSH HL
 450+ 518F DD E1            POP IX
 451+ 5191 D1               POP DE ; pointer to INT array
 452+ 5192 C1               POP BC ; B=item number
 453+ 5193 F1               POP AF ; id
 454+ 5194 CD 67 4F         CALL GETnthANIMDEF
 455+ 5197 D1               POP DE
 456+ 5198 70               LD (HL),B
 457+ 5199              .L1:
 458+ 5199 23               INC HL
 459+ 519A 1A               LD A,(DE)
 460+ 519B 13          > INC DE
 460+ 519C 13          > INC DE
 461+ 519D 77               LD (HL),A
 462+ 519E 10 F9            DJNZ .L1
 463+ 51A0 DD E5            PUSH IX
 464+ 51A2 E1               POP HL
 465+ 51A3 C9               RET
 466+ 51A4              ; *******************************************************************************************************
 467+ 51A4
 468+ 51A4              ; *******************************************************************************************************
 469+ 51A4              ; function to handle CALL MAXANIMSPRS basic extension
 470+ 51A4              ; MAXANIMSPRS (BYTE number)
 471+ 51A4              ; sets new number and moves memory buffers as needed
 472+ 51A4              MAXANIMSPRS:
 473+ 51A4              	; opening (
 474+ 51A4 CD 96 55     	CALL CHKCHAR
 475+ 51A7 28           	DB '('
 476+ 51A8              	; get value
 477+ 51A8 DD 21 1C 52  	LD IX, GETBYT
 478+ 51AC CD 59 01     	CALL CALBAS
 479+ 51AF F5               PUSH AF
 480+ 51B0              	; ending )
 481+ 51B0 CD 96 55     	CALL CHKCHAR
 482+ 51B3 29           	DB ')'
 483+ 51B4 F1               POP AF
 484+ 51B5
 485+ 51B5              	; save position
 486+ 51B5 E5           	PUSH HL
 487+ 51B6              .ENTRY:
 488+ 51B6 47               LD B,A
 489+ 51B7 3A 52 4F         LD A,(ANIMSPRNUM)
 490+ 51BA 90               SUB B
 491+ 51BB CA B7 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 492+ 51BE FD 21 10 40      LD IY,FREEMEMPTR
 493+ 51C2 FA CE 51         JP M, .INCREASE
 494+ 51C5                  ; new value is lower than previous one
 495+ 51C5 CD ED 51         CALL .SIZEDIFF
 496+ 51C8 CD ED 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 497+ 51CB C3 B7 4F         JP MAXANIMITEMS.EXIT
 498+ 51CE              .INCREASE:
 499+ 51CE ED 44            NEG
 500+ 51D0 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 501+ 51D1 CD ED 51         CALL .SIZEDIFF
 502+ 51D4 CD 19 50         CALL MAXANIMITEMS.INCREASE_COMMON
 503+ 51D7 AF               XOR A
 504+ 51D8 ED 42            SBC HL,BC ; location of new stuff
 505+ 51DA F1               POP AF
 506+ 51DB 47               LD B,A
 507+ 51DC 11 08 00         LD DE,8
 508+ 51DF E5               PUSH HL
 509+ 51E0 DD E1            POP IX
 510+ 51E2              .L1:
 511+ 51E2 DD 36 06 00      LD (IX+6),0
 512+ 51E6 DD 19            ADD IX,DE
 513+ 51E8 10 F8            DJNZ .L1
 514+ 51EA C3 B7 4F         JP MAXANIMITEMS.EXIT
 515+ 51ED              .SIZEDIFF:
 516+ 51ED 26 00            LD H,0
 517+ 51EF 6F               LD L,A
 518+ 51F0 CD 85 54         CALL HLx8
 519+ 51F3 78               LD A,B
 520+ 51F4 32 52 4F         LD (ANIMSPRNUM),A
 521+ 51F7 44               LD B,H
 522+ 51F8 4D               LD C,L
 523+ 51F9 C9               RET ; BC=size difference in bytes
 524+ 51FA              ; *******************************************************************************************************
 525+ 51FA
 526+ 51FA              ; *******************************************************************************************************
 527+ 51FA              ; function to handle CALL ANIMSPRITE basic extension
 528+ 51FA              ; ANIMSPRITE ( BYTE id,
 529+ 51FA              ;              BYTE sprite_number,
 530+ 51FA              ;              BYTE animation_definition_id,
 531+ 51FA              ;              BYTE cyclic_flag )
 532+ 51FA              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 533+ 51FA              ANIMSPRITE:
 534+ 51FA                  ; opening (
 535+ 51FA CD 96 55     	CALL CHKCHAR
 536+ 51FD 28           	DB '('
 537+ 51FE              	; get sprite animation id
 538+ 51FE DD 21 1C 52  	LD IX, GETBYT
 539+ 5202 CD 59 01     	CALL CALBAS
 540+ 5205 F5               PUSH AF
 541+ 5206 3C               INC A
 542+ 5207 4F               LD C,A
 543+ 5208 3A 52 4F         LD A,(ANIMSPRNUM)
 544+ 520B B9               CP C
 545+ 520C DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 546+ 520F              	; comma
 547+ 520F CD 96 55     	CALL CHKCHAR
 548+ 5212 2C           	DB ','
 549+ 5213              	; get sprite number
 550+ 5213 DD 21 1C 52  	LD IX, GETBYT
 551+ 5217 CD 59 01     	CALL CALBAS
 552+ 521A F5               PUSH AF
 553+ 521B                  ; check if out of bounds
 554+ 521B FE 20            CP 32
 555+ 521D D2 AC 55         JP NC, SUBSCRIPT_OUT_OF_RANGE
 556+ 5220              	; comma
 557+ 5220 CD 96 55     	CALL CHKCHAR
 558+ 5223 2C           	DB ','
 559+ 5224              	; get animation definition id
 560+ 5224 DD 21 1C 52  	LD IX, GETBYT
 561+ 5228 CD 59 01     	CALL CALBAS
 562+ 522B F5               PUSH AF
 563+ 522C 3C               INC A
 564+ 522D 4F               LD C,A
 565+ 522E 3A 4F 4F         LD A,(ANIMDEFNUM)
 566+ 5231 B9               CP C
 567+ 5232 DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 568+ 5235              	; comma
 569+ 5235 CD 96 55     	CALL CHKCHAR
 570+ 5238 2C           	DB ','
 571+ 5239              	; get cyclic flag
 572+ 5239 DD 21 1C 52  	LD IX, GETBYT
 573+ 523D CD 59 01         CALL CALBAS
 574+ 5240 F5           	PUSH AF
 575+ 5241              	; ending )
 576+ 5241 CD 96 55     	CALL CHKCHAR
 577+ 5244 29           	DB ')'
 578+ 5245              .ENTRY:
 579+ 5245 E5               PUSH HL
 580+ 5246 DD E1            POP IX
 581+ 5248 D9               EXX
 582+ 5249 D1               POP DE ; cyclic
 583+ 524A C1               POP BC ; animation definition id
 584+ 524B E1               POP HL ; sprite number
 585+ 524C D9               EXX
 586+ 524D F1               POP AF ; sprite animation id
 587+ 524E 26 00            LD H,0
 588+ 5250 6F               LD L,A
 589+ 5251 CD 85 54         CALL HLx8
 590+ 5254 ED 5B 53 4F      LD DE,(ANIMSPRPTR)
 591+ 5258 19               ADD HL,DE
 592+ 5259 E5               PUSH HL
 593+ 525A FD E1            POP IY
 594+ 525C D9               EXX
 595+ 525D FD 74 00         LD (IY),H
 596+ 5260 FD 70 04         LD (IY+4),B
 597+ 5263 FD 72 05         LD (IY+5),D
 598+ 5266                  ;LD (IY+6),0
 599+ 5266 DD E5            PUSH IX
 600+ 5268 E1               POP HL
 601+ 5269 C9               RET
 602+ 526A              ; *******************************************************************************************************
 603+ 526A
 604+ 526A              ; *******************************************************************************************************
 605+ 526A              ; function to handle CALL ANIMSTART basic extension
 606+ 526A              ; two forms
 607+ 526A              ; ANIMSTART ( BYTE id )
 608+ 526A              ; or
 609+ 526A              ; ANIMSTART ( BYTE item_number,
 610+ 526A              ;             INT[] sprite_animations )
 611+ 526A              ; sets active flag to 1
 612+ 526A              ANIMSTART:
 613+ 526A 3E 01            LD A,1
 614+ 526C 18 01            JR ANIMSTARTSTOP_COMMON
 615+ 526E              ; *******************************************************************************************************
 616+ 526E              ; *******************************************************************************************************
 617+ 526E              ; function to handle CALL ANIMSTOP basic extension
 618+ 526E              ; two forms
 619+ 526E              ; ANIMSTOP ( BYTE id )
 620+ 526E              ; or
 621+ 526E              ; ANIMSTOP ( BYTE item_number,
 622+ 526E              ;            INT[] sprite_animations )
 623+ 526E              ; sets active flag to 1
 624+ 526E              ANIMSTOP:
 625+ 526E AF               XOR A
 626+ 526F              ANIMSTARTSTOP_COMMON:
 627+ 526F 32 E7 52         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
 628+ 5272              ; *******************************************************************************************************
 629+ 5272                  ; opening (
 630+ 5272 CD 96 55     	CALL CHKCHAR
 631+ 5275 28           	DB '('
 632+ 5276              	; get sprite animation id or array size
 633+ 5276 DD 21 1C 52  	LD IX,GETBYT
 634+ 527A CD 59 01     	CALL CALBAS
 635+ 527D F5               PUSH AF
 636+ 527E                  ; check if comma present
 637+ 527E CD A0 55         CALL GETPREVCHAR
 638+ 5281 23               INC HL
 639+ 5282 FE 2C            CP ','
 640+ 5284 28 0C            JR Z,.L1
 641+ 5286 FE 29            CP ')'
 642+ 5288 C2 B4 55         JP NZ,SYNTAX_ERROR
 643+ 528B                  ; ok so single argument variant
 644+ 528B F1               POP AF
 645+ 528C E5               PUSH HL
 646+ 528D CD D4 52         CALL .SETVALUE
 647+ 5290 E1               POP HL
 648+ 5291 C9               RET
 649+ 5292              .L1:
 650+ 5292                  ; array of items
 651+ 5292              	; get pointer to a list of animation items in integer array format
 652+ 5292 3E 01            LD A,1
 653+ 5294 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 654+ 5297 DD 21 A4 5E  	LD IX, PTRGET
 655+ 529B CD 59 01     	CALL CALBAS
 656+ 529E                  ; contrary to documentation we get a pointer to array dimension in BC
 657+ 529E                  ; and type in VALTYP
 658+ 529E 3A 63 F6         LD A,(VALTYP)
 659+ 52A1 FE 02            CP 2
 660+ 52A3 C2 A8 55         JP NZ,TYPE_MISMATCH
 661+ 52A6 0A               LD A,(BC)
 662+ 52A7 FE 01            CP 1
 663+ 52A9 C2 A8 55         JP NZ,TYPE_MISMATCH
 664+ 52AC 03               INC BC
 665+ 52AD 0A               LD A,(BC)
 666+ 52AE D1               POP DE
 667+ 52AF D5               PUSH DE
 668+ 52B0 3C               INC A
 669+ 52B1 BA               CP D
 670+ 52B2 DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 671+ 52B5 03          > INC BC
 671+ 52B6 03          > INC BC
 672+ 52B7 C5               PUSH BC
 673+ 52B8              	; ending )
 674+ 52B8 CD 96 55     	CALL CHKCHAR
 675+ 52BB 29           	DB ')'
 676+ 52BC D1               POP DE ; array pointer
 677+ 52BD C1               POP BC ; number of items
 678+ 52BE 78               LD A,B
 679+ 52BF B7               OR A
 680+ 52C0 CA AC 55         JP Z,SUBSCRIPT_OUT_OF_RANGE
 681+ 52C3 E5               PUSH HL
 682+ 52C4 F3               DI
 683+ 52C5              .L2:
 684+ 52C5 C5               PUSH BC
 685+ 52C6 1A               LD A,(DE)
 686+ 52C7 13          > INC DE
 686+ 52C8 13          > INC DE
 687+ 52C9 D5               PUSH DE
 688+ 52CA CD D4 52         CALL .SETVALUE
 689+ 52CD D1               POP DE
 690+ 52CE C1               POP BC
 691+ 52CF 10 F4            DJNZ .L2
 692+ 52D1 FB               EI
 693+ 52D2 E1               POP HL
 694+ 52D3 C9               RET
 695+ 52D4
 696+ 52D4              .SETVALUE:
 697+ 52D4 47               LD B,A
 698+ 52D5 3C               INC A
 699+ 52D6 4F               LD C,A
 700+ 52D7 3A 52 4F         LD A,(ANIMSPRNUM)
 701+ 52DA B9               CP C
 702+ 52DB DA AC 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 703+ 52DE CD 73 4F         CALL GETnthSPRANIM
 704+ 52E1 E5               PUSH HL
 705+ 52E2 DD E1            POP IX
 706+ 52E4              .VALUE:
 707+ 52E4 DD 36 06 01      LD (IX+6),1
 708+ 52E8 C9               RET
 709+ 52E9              ; *******************************************************************************************************
 710+ 52E9
# file closed: asm\ANIMATION.asm
 127  52E9               ENDIF
 128  52E9
 129  52E9              ; temp variables for BLIT, TILE functions
 130  52E9               IF (BLIT_CMDS + TILE_CMDS > 0)
 131  52E9              BLIT_TMP:
 132  52E9              TILETMP1:
 133  52E9              BLIT_TMP1:
 134  52E9 00 00         DW 0
 135  52EB              TILETMP2:
 136  52EB              BLIT_TMP2:
 137  52EB 00 00         DW 0
 138  52ED                IFDEF CMDS_WITH_PARAMETERS
 139  52ED              BLIT_STRUCT:
 140  52ED 00 00 00...   DS 17
 141  52F1                ENDIF
 142  52F1               ENDIF
 143  52FE
 144  52FE              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 145  52FE              ; per starting letter, if no commands with this letter, NULL value
 146  52FE              CMDS:
 147  52FE               IF (ANIM_CMDS == 1)
 148  52FE 27 54        	DW CMDS_A ;
 149  5300               ELSE
 150  5300 ~                DW 0 ; A
 151  5300               ENDIF
 152  5300               IF (BLIT_CMDS + BOX_CMDS > 0)
 153  5300 F2 53            DW CMDS_B ; B
 154  5302               ELSE
 155  5302 ~            	DW 0
 156  5302               ENDIF
 157  5302 00 00            DW 0 ; C
 158  5304 00 00            DW 0 ; D
 159  5306 00 00            DW 0 ; E
 160  5308               IF (VRAM_CMDS + RAM_CMDS > 0)
 161  5308 70 53            DW CMDS_F; F
 162  530A               ELSE
 163  530A ~            	DW 0
 164  530A               ENDIF
 165  530A               IF (GENCAL_CMD > 0)
 166  530A 83 53            DW CMDS_G; G
 167  530C               ELSE
 168  530C ~            	DW 0
 169  530C               ENDIF
 170  530C 00 00            DW 0 ; H
 171  530E 00 00            DW 0 ; I
 172  5310 00 00            DW 0 ; J
 173  5312 00 00            DW 0 ; K
 174  5314 00 00            DW 0 ; L
 175  5316               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 176  5316 32 53            DW CMDS_M ; M
 177  5318               ELSE
 178  5318 ~            	DW 0
 179  5318               ENDIF
 180  5318 00 00            DW 0 ; N
 181  531A 00 00            DW 0 ; O
 182  531C 00 00            DW 0 ; P
 183  531E 00 00            DW 0 ; Q
 184  5320 00 00            DW 0 ; R
 185  5322               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 186  5322 97 53            DW CMDS_S ; S
 187  5324               ELSE
 188  5324 ~            	DW 0
 189  5324               ENDIF
 190  5324               IF (TILE_CMDS > 0)
 191  5324 12 54            DW CMDS_T ; T
 192  5326               ELSE
 193  5326 ~            	DW 0
 194  5326               ENDIF
 195  5326 00 00            DW 0 ; U
 196  5328               IF (VRAM_CMDS > 0)
 197  5328 8D 53            DW CMDS_V ; V
 198  532A               ELSE
 199  532A ~            	DW 0
 200  532A               ENDIF
 201  532A 00 00            DW 0 ; W
 202  532C 00 00            DW 0 ; X
 203  532E 00 00            DW 0 ; Y
 204  5330 00 00            DW 0 ; Z
 205  5332
 206  5332              CMDS_M:
 207  5332               IF (VRAM_CMDS == 1)
 208  5332 4D 45 4D 56      DB "MEMVRM", 0
 208  5336 52 4D 00
 209  5339 FE 56            DW MEMVRM
 210  533B               ENDIF
 211  533B               IF (RAM_CMDS == 1)
 212  533B 4D 45 4D 43  	DB "MEMCPY", 0
 212  533F 50 59 00
 213  5342 BD 55        	DW MEMCPY
 214  5344               ENDIF
 215  5344               IF (ANIM_CMDS == 1)
 216  5344 4D 41 58 41  	DB "MAXANIMITEMS",0
 216  5348 4E 49 4D 49
 216  534C 54 45 4D 53
 216  5350 00
 217  5351 7F 4F        	DW MAXANIMITEMS
 218  5353 4D 41 58 41  	DB "MAXANIMDEFS",0
 218  5357 4E 49 4D 44
 218  535B 45 46 53 00
 219  535F F4 50        	DW MAXANIMDEFS
 220  5361 4D 41 58 41  	DB "MAXANIMSPRS",0
 220  5365 4E 49 4D 53
 220  5369 50 52 53 00
 221  536D A4 51        	DW MAXANIMSPRS
 222  536F               ENDIF
 223  536F               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 224  536F 00           	DB 0
 225  5370               ENDIF
 226  5370              CMDS_F:
 227  5370               IF (VRAM_CMDS == 1)
 228  5370 46 49 4C 56      DB "FILVRM", 0
 228  5374 52 4D 00
 229  5377 00 56            DW FILVRM
 230  5379               ENDIF
 231  5379               IF (RAM_CMDS == 1)
 232  5379 46 49 4C 52      DB "FILRAM", 0
 232  537D 41 4D 00
 233  5380 47 56            DW FILRAM
 234  5382               ENDIF
 235  5382               IF (VRAM_CMDS + RAM_CMDS > 0)
 236  5382 00               DB 0
 237  5383               ENDIF
 238  5383              CMDS_G:
 239  5383               IF (GENCAL_CMD == 1)
 240  5383 47 45 4E 43      DB "GENCAL", 0
 240  5387 41 4C 00
 241  538A A5 56            DW GENCAL
 242  538C               ENDIF
 243  538C               IF (GENCAL_CMD > 0)
 244  538C 00           	DB	0
 245  538D               ENDIF
 246  538D              CMDS_V:
 247  538D               IF (VRAM_CMDS == 1)
 248  538D 56 52 4D 4D  	DB "VRMMEM", 0
 248  5391 45 4D 00
 249  5394 76 57        	DW VRMMEM
 250  5396               ENDIF
 251  5396               IF (VRAM_CMDS > 0)
 252  5396 00           	DB 0
 253  5397               ENDIF
 254  5397              CMDS_S:
 255  5397               IF (SPRITE_CMDS == 1)
 256  5397 53 50 52 53  	DB "SPRSET", 0
 256  539B 45 54 00
 257  539E 1A 4E        	DW SPRSET
 258  53A0 53 50 52 47  	DB "SPRGRPMOV", 0
 258  53A4 52 50 4D 4F
 258  53A8 56 00
 259  53AA CB 4E        	DW SPRGRPMOV
 260  53AC               ENDIF
 261  53AC               IF (SOUND_CMDS == 1)
 262  53AC 53 4E 44 53  	DB "SNDSFX", 0
 262  53B0 46 58 00
 263  53B3 B4 58        	DW SNDSFX
 264  53B5 53 4E 44 50  	DB "SNDPLYON", 0
 264  53B9 4C 59 4F 4E
 264  53BD 00
 265  53BE 7E 58        	DW SNDPLYON
 266  53C0 53 4E 44 50  	DB "SNDPLYOFF", 0
 266  53C4 4C 59 4F 46
 266  53C8 46 00
 267  53CA 91 58        	DW SNDPLYOFF
 268  53CC 53 4E 44 50  	DB "SNDPLYINI", 0
 268  53D0 4C 59 49 4E
 268  53D4 49 00
 269  53D6 34 58        	DW SNDPLYINIT
 270  53D8               ENDIF
 271  53D8               IF (SPRITE_CMDS == 1)
 272  53D8 53 50 52 45  	DB "SPRENABLE", 0
 272  53DC 4E 41 42 4C
 272  53E0 45 00
 273  53E2 C5 4D        	DW SPRENABLE
 274  53E4 53 50 52 44  	DB "SPRDISABLE", 0
 274  53E8 49 53 41 42
 274  53EC 4C 45 00
 275  53EF 15 4E        	DW SPRDISABLE
 276  53F1               ENDIF
 277  53F1               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 278  53F1 00           	DB 0
 279  53F2               ENDIF
 280  53F2              CMDS_B:
 281  53F2               IF (BLIT_CMDS == 1)
 282  53F2 42 4C 49 54  	DB "BLIT", 0
 282  53F6 00
 283  53F7 8B 5A        	DW BLIT
 284  53F9               ENDIF
 285  53F9               IF (BOX_CMDS == 1)
 286  53F9 42 4F 58 4D  	DB "BOXMEMCPY", 0
 286  53FD 45 4D 43 50
 286  5401 59 00
 287  5403 C3 5D        	DW BOXMEMCPY
 288  5405 42 4F 58 4D  	DB "BOXMEMVRM", 0
 288  5409 45 4D 56 52
 288  540D 4D 00
 289  540F F7 5D        	DW BOXMEMVRM
 290  5411               ENDIF
 291  5411               IF (BLIT_CMDS + BOX_CMDS > 0)
 292  5411 00           	DB 0
 293  5412               ENDIF
 294  5412              CMDS_T:
 295  5412               IF (TILE_CMDS == 1)
 296  5412 54 49 4C 45  	DB "TILERAM", 0
 296  5416 52 41 4D 00
 297  541A CF 5B        	DW TILERAM
 298  541C 54 49 4C 45  	DB "TILEVRM", 0
 298  5420 56 52 4D 00
 299  5424 D2 5C        	DW TILEVRM
 300  5426               ENDIF
 301  5426               IF (TILE_CMDS > 0)
 302  5426 00           	DB 0
 303  5427               ENDIF
 304  5427              CMDS_A:
 305  5427               IF (ANIM_CMDS == 1)
 306  5427 41 4E 49 4D  	DB "ANIMSTART",0
 306  542B 53 54 41 52
 306  542F 54 00
 307  5431 6A 52        	DW ANIMSTART
 308  5433 41 4E 49 4D  	DB "ANIMSTOP",0
 308  5437 53 54 4F 50
 308  543B 00
 309  543C 6E 52        	DW ANIMSTOP
 310  543E 41 4E 49 4D  	DB "ANIMITEMPAT",0
 310  5442 49 54 45 4D
 310  5446 50 41 54 00
 311  544A 3F 50        	DW ANIMITEMPAT
 312  544C 41 4E 49 4D  	DB "ANIMITEMPTR",0
 312  5450 49 54 45 4D
 312  5454 50 54 52 00
 313  5458 A0 50        	DW ANIMITEMPTR_CMD
 314  545A 41 4E 49 4D  	DB "ANIMDEF",0
 314  545E 44 45 46 00
 315  5462 36 51        	DW ANIMDEF
 316  5464 41 4E 49 4D  	DB "ANIMSPRITE",0
 316  5468 53 50 52 49
 316  546C 54 45 00
 317  546F FA 51        	DW ANIMSPRITE
 318  5471 00           	DB 0
 319  5472               ENDIF
 320  5472
 321  5472               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 322  5472              ; ****************************************************************************************************
 323  5472              ; function sets VRAM address
 324  5472              ; input HL=address
 325  5472              ; modifies AF
 326  5472              SETWRT_LOCAL:
 327  5472 7D           	LD	A, L
 328  5473 D3 99        	OUT	(099H), A
 329  5475 7C           	LD	A, H
 330  5476 E6 3F        	AND	03FH
 331  5478 F6 40        	OR	040H
 332  547A D3 99        	OUT	(099H), A
 333  547C C9           	RET
 334  547D              ; ****************************************************************************************************
 335  547D               ENDIF
 336  547D
 337  547D               IF (VRAM_CMDS + TILE_CMDS > 0)
 338  547D              ; ****************************************************************************************************
 339  547D              ; function copies data from RAM to VRAM
 340  547D              ; input HL=address in RAM
 341  547D              ; input B=count
 342  547D              ; modifies AF
 343  547D              BBYTECOPY:
 344  547D ED A3        	OUTI
 345  547F C2 7D 54     	JP	NZ, BBYTECOPY
 346  5482 C9           	RET
 347  5483              ; ****************************************************************************************************
 348  5483               ENDIF
 349  5483
 350  5483              ; ****************************************************************************************************
 351  5483              ; function multiplies HL by 32
 352  5483              HPx32:
 353  5483 29           	ADD HL,HL
 354  5484              ; ****************************************************************************************************
 355  5484              ; function multiplies HL by 16
 356  5484              HLx16:
 357  5484 29           	ADD HL,HL
 358  5485              ; ****************************************************************************************************
 359  5485              ; function multiplies HL by 8
 360  5485              HLx8:
 361  5485 29          > ADD HL, HL
 361  5486 29          > ADD HL, HL
 361  5487 29          > ADD HL, HL
 362  5488 C9           	RET
 363  5489              ; ****************************************************************************************************
 364  5489
 365  5489              ; ****************************************************************************************************
 366  5489              ; function gets slot and subslot data for specific page
 367  5489              ; input A=page (0, 1 or 2)
 368  5489              ; output B = 0A8H register value
 369  5489              ; output D = 0 is no subslots, 1 if yes
 370  5489              ; output C = 0A8H value when page 3 slot equals to requested page slot
 371  5489              ; output E = subslot value if present
 372  5489              ; modifies AF, BC, DE, HL
 373  5489              GET_PAGE_INFO:
 374  5489 6F               LD L, A
 375  548A C6 C1            ADD A, low (EXPTBL)
 376  548C 32 96 54         LD (GET_PAGE_INFO_L1+1), A
 377  548F DB A8            IN A, (0A8H)
 378  5491 47               LD B, A
 379  5492 E6 3F            AND 03FH
 380  5494 4F               LD C, A
 381  5495              GET_PAGE_INFO_L1:
 382  5495 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 383  5498 E6 80            AND 080H
 384  549A 28 1B            JR Z, GET_PAGE_INFO_L2
 385  549C                  ; expanded
 386  549C 2D               DEC L
 387  549D FA BC 54         JP M, GET_PAGE_INFO_L3
 388  54A0 2D               DEC L
 389  54A1 FA BA 54         JP M, GET_PAGE_INFO_L4
 390  54A4                  ; page 2
 391  54A4 07               RLCA
 392  54A5 07               RLCA
 393  54A6              GET_PAGE_INFO_L5:
 394  54A6 E6 C0            AND 0C0H
 395  54A8 B1               OR C
 396  54A9 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 397  54AB 4F               LD C, A
 398  54AC 3A FF FF         LD A, (0FFFFH)
 399  54AF 2F               CPL
 400  54B0 5F               LD E, A
 401  54B1 16 01            LD D, 1
 402  54B3 78               LD A, B ; return stack
 403  54B4 D3 A8            OUT (0A8H), A
 404  54B6 C9               RET
 405  54B7              GET_PAGE_INFO_L2:
 406  54B7                  ; not expanded
 407  54B7 16 00            LD D, 0
 408  54B9 C9               RET
 409  54BA              GET_PAGE_INFO_L4:
 410  54BA                  ; page 1
 411  54BA 0F               RRCA
 412  54BB 0F               RRCA
 413  54BC              GET_PAGE_INFO_L3:
 414  54BC                  ; page 0
 415  54BC 0F               RRCA
 416  54BD 0F               RRCA
 417  54BE 18 E6            JR GET_PAGE_INFO_L5
 418  54C0              ; ****************************************************************************************************
 419  54C0
 420  54C0              ; ****************************************************************************************************
 421  54C0              ; function returns original slot and subslot info
 422  54C0              ; input B = 0A8H register value
 423  54C0              ; input D = 0 is no subslots, 1 if yes
 424  54C0              ; input C = 0A8H value when page 3 slot equals to requested page slot
 425  54C0              ; input E = subslot value if present
 426  54C0              ; modifies AF, disables interrupts
 427  54C0              RESTORE_PAGE_INFO:
 428  54C0 7A               LD A, D
 429  54C1 B7               OR A
 430  54C2 28 08            JR Z, RESTORE_PAGE_INFO_L1
 431  54C4 79               LD A, C
 432  54C5 F3           	DI
 433  54C6 D3 A8            OUT (0A8H), A
 434  54C8 7B               LD A, E
 435  54C9 32 FF FF         LD (0FFFFH), A
 436  54CC              RESTORE_PAGE_INFO_L1:
 437  54CC 78               LD A, B
 438  54CD D3 A8            OUT (0A8H), A
 439  54CF C9               RET
 440  54D0              ; ****************************************************************************************************
 441  54D0
 442  54D0              ; *******************************************************************************************************
 443  54D0              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 444  54D0              ; INPUT:  A = SLOT ID: EXXXSSPP
 445  54D0              ; E = EXPANDED FLAG
 446  54D0              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 447  54D0              ; PP = PRIMARY SLOT NUMBER
 448  54D0              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 449  54D0              ; CHANGES: AF, BC, DE
 450  54D0
 451  54D0              LOCAL_ENASLT:
 452  54D0 CD F0 54         CALL L0353
 453  54D3 FA DD 54         JP M, L0340
 454  54D6 DB A8            IN A, (0A8H)
 455  54D8 A1               AND C
 456  54D9 B0               OR B
 457  54DA D3 A8            OUT (0A8H), A
 458  54DC C9               RET
 459  54DD              L0340:
 460  54DD E5               PUSH HL
 461  54DE CD 15 55         CALL L0378
 462  54E1 4F               LD C, A
 463  54E2 06 00            LD B, 0
 464  54E4 7D               LD A, L
 465  54E5 A4               AND H
 466  54E6 B2               OR D
 467  54E7 21 C5 FC         LD HL, 0FCC5H
 468  54EA 09               ADD HL, BC
 469  54EB 77               LD (HL), A
 470  54EC E1               POP HL
 471  54ED 79               LD A, C
 472  54EE 18 E0            JR LOCAL_ENASLT
 473  54F0              L0353:
 474  54F0 F3               DI
 475  54F1 F5               PUSH AF
 476  54F2 7C               LD A, H
 477  54F3 07               RLCA
 478  54F4 07               RLCA
 479  54F5 E6 03            AND 3
 480  54F7 5F               LD E, A
 481  54F8 3E C0            LD A, 0C0H
 482  54FA              L035D:
 483  54FA 07               RLCA
 484  54FB 07               RLCA
 485  54FC 1D               DEC E
 486  54FD F2 FA 54         JP P, L035D
 487  5500 5F               LD E, A
 488  5501 2F               CPL
 489  5502 4F               LD C, A
 490  5503 F1               POP AF
 491  5504 F5               PUSH AF
 492  5505 E6 03            AND 3
 493  5507 3C               INC A
 494  5508 47               LD B, A
 495  5509 3E AB            LD A, 0ABH
 496  550B              L036E:
 497  550B C6 55            ADD A, 055H
 498  550D 10 FC            DJNZ L036E
 499  550F 57               LD D, A
 500  5510 A3               AND E
 501  5511 47               LD B, A
 502  5512 F1               POP AF
 503  5513 A7               AND A
 504  5514 C9               RET
 505  5515              L0378:
 506  5515 F5               PUSH AF
 507  5516 7A               LD A, D
 508  5517 E6 C0            AND 0C0H
 509  5519 4F               LD C, A
 510  551A F1               POP AF
 511  551B F5               PUSH AF
 512  551C 57               LD D, A
 513  551D DB A8            IN A, (0A8H)
 514  551F 47               LD B, A
 515  5520 E6 3F            AND 03FH
 516  5522 B1               OR C
 517  5523 D3 A8            OUT (0A8H), A
 518  5525 7A               LD A, D
 519  5526 0F               RRCA
 520  5527 0F               RRCA
 521  5528 E6 03            AND 3
 522  552A 57               LD D, A
 523  552B 3E AB            LD A, 0ABH
 524  552D              L0390:
 525  552D C6 55            ADD A, 055H
 526  552F 15               DEC D
 527  5530 F2 2D 55         JP P, L0390
 528  5533 A3               AND E
 529  5534 57               LD D, A
 530  5535 7B               LD A, E
 531  5536 2F               CPL
 532  5537 67               LD H, A
 533  5538 3A FF FF         LD A, (0FFFFH)
 534  553B 2F               CPL
 535  553C 6F               LD L, A
 536  553D A4               AND H
 537  553E B2               OR D
 538  553F 32 FF FF         LD (0FFFFH), A
 539  5542 78               LD A, B
 540  5543 D3 A8            OUT (0A8H), A
 541  5545 F1               POP AF
 542  5546 E6 03            AND 3
 543  5548 C9               RET
 544  5549              ; *******************************************************************************************************
 545  5549
 546  5549              ; *******************************************************************************************************
 547  5549              ; some common code to activate page 0 and place values needed to restore original page on stack
 548  5549              ; input IY=return address
 549  5549              ENABLE_PAGE0:
 550  5549 AF               XOR A
 551  554A CD 89 54         CALL GET_PAGE_INFO
 552  554D C5               PUSH BC
 553  554E D5               PUSH DE
 554  554F 3A 41 F3         LD A, (RAMAD0)
 555  5552 26 00            LD H, 0
 556  5554 CD D0 54         CALL LOCAL_ENASLT
 557  5557 FD E9        	JP (IY)
 558  5559              ; *******************************************************************************************************
 559  5559
 560  5559              ; General BASIC CALL-instruction handler
 561  5559              CALLHAND:
 562  5559 E5           	PUSH HL
 563  555A 21 FE 52     	LD	HL, CMDS ; pointer table based on starting letter
 564  555D 3A 89 FD         LD A, (PROCNM)
 565  5560 D6 41            SUB 'A'
 566  5562 87               ADD A, A
 567  5563 16 00            LD D, 0
 568  5565 5F               LD E, A
 569  5566 19               ADD HL, DE
 570  5567 5E               LD E, (HL)
 571  5568 23               INC HL
 572  5569 56               LD D, (HL)
 573  556A 7A               LD A, D
 574  556B B3               OR E
 575  556C 28 23            JR Z, .CMDNOTRECOGNIZED
 576  556E EB               EX DE, HL
 577  556F              .CHKCMD:
 578  556F 11 89 FD     	LD	DE, PROCNM
 579  5572 1A           .LOOP:	LD	A,(DE)
 580  5573 BE           	CP	(HL)
 581  5574 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 582  5576 13           	INC	DE
 583  5577 23           	INC	HL
 584  5578 A7           	AND	A
 585  5579 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 586  557B 5E           	LD	E,(HL)
 587  557C 23           	INC	HL
 588  557D 56           	LD	D,(HL)
 589  557E E1           	POP	HL		; routine address
 590  557F CD A0 55     	CALL	GETPREVCHAR
 591  5582 CD 94 55     	CALL	.CALLDE		; Call routine
 592  5585 A7           	AND	A
 593  5586 C9           	RET
 594  5587
 595  5587              .TONEXTCMD:
 596  5587 0E FF        	LD	C,0FFH
 597  5589 AF           	XOR	A
 598  558A ED B1        	CPIR			; Skip to end of instruction name
 599  558C 23           	INC	HL
 600  558D 23           	INC	HL		; Skip address
 601  558E BE           	CP	(HL)
 602  558F 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 603  5591              .CMDNOTRECOGNIZED:
 604  5591 E1           	POP	HL
 605  5592 37               SCF
 606  5593 C9           	RET
 607  5594
 608  5594              .CALLDE:
 609  5594 D5           	PUSH	DE
 610  5595 C9           	RET
 611  5596
 612  5596              ;---------------------------
 613  5596
 614  5596              ;GETSTRPNT:
 615  5596              ; OUT:
 616  5596              ; HL = String Address
 617  5596              ; B  = Lenght
 618  5596              ;        LD      HL,(USR)
 619  5596              ;        LD      B,(HL)
 620  5596              ;        INC     HL
 621  5596              ;        LD      E,(HL)
 622  5596              ;        INC     HL
 623  5596              ;        LD      D,(HL)
 624  5596              ;        EX      DE,HL
 625  5596              ;        RET
 626  5596
 627  5596              ;EVALTXTPARAM:
 628  5596              ;	CALL	CHKCHAR
 629  5596              ;	DEFB	"("             ; Check for (
 630  5596              ;	LD	IX,FRMEVL
 631  5596              ;	CALL	CALBAS		; Evaluate expression
 632  5596              ;       LD      A,(VALTYP)
 633  5596              ;        CP      3               ; Text type?
 634  5596              ;        JP      NZ,TYPE_MISMATCH
 635  5596              ;        PUSH	HL
 636  5596              ;        LD	IX,FRESTR         ; Free the temporary string
 637  5596              ;        CALL	CALBAS
 638  5596              ;        POP	HL
 639  5596              ;	CALL	CHKCHAR
 640  5596              ;	DEFB	")"             ; Check for )
 641  5596              ;        RET
 642  5596
 643  5596
 644  5596              CHKCHAR:
 645  5596 CD A0 55     	CALL	GETPREVCHAR	; Get previous basic char
 646  5599 E3           	EX	(SP),HL
 647  559A BE           	CP	(HL) 	        ; Check if good char
 648  559B 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 649  559D 23           	INC	HL
 650  559E E3           	EX	(SP),HL
 651  559F 23           	INC	HL		; Get next basic char
 652  55A0
 653  55A0              GETPREVCHAR:
 654  55A0 2B           	DEC	HL
 655  55A1 DD 21 66 46  	LD	IX,CHRGTR
 656  55A5 C3 59 01     	JP      CALBAS
 657  55A8
 658  55A8
 659  55A8              TYPE_MISMATCH:
 660  55A8 1E 0D            LD E, 13 ; Type mismatch
 661  55AA 18 0A            JR THROW_ERROR
 662  55AC              SUBSCRIPT_OUT_OF_RANGE:
 663  55AC 1E 09            LD E,9 ; subscript out of range
 664  55AE 18 06        	JR THROW_ERROR
 665  55B0              OVERFLOW:
 666  55B0 1E 06        	LD E,6
 667  55B2 18 02        	JR THROW_ERROR
 668  55B4              SYNTAX_ERROR:
 669  55B4 1E 02            LD E, 2 ; Syntax error
 670  55B6              THROW_ERROR:
 671  55B6 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 672  55BA C3 59 01     	JP	CALBAS
 673  55BD
 674  55BD              ;---------------------------
 675  55BD
 676  55BD               IF (RAM_CMDS == 1)
 677  55BD              ; *******************************************************************************************************
 678  55BD              ; function to handle CALL MEMCPY basic extension
 679  55BD              ; _MEMCPY ( INT source,
 680  55BD              ;			INT destination,
 681  55BD              ;			INT count,
 682  55BD              ; will put ram in page 0 also, page 1 is already there
 683  55BD              MEMCPY:
 684  55BD              	; opening (
 685  55BD CD 96 55     	CALL CHKCHAR
 686  55C0 28           	DB '('
 687  55C1              	; get source address
 688  55C1 DD 21 2F 54  	LD IX, FRMQNT
 689  55C5 CD 59 01     	CALL CALBAS
 690  55C8 D5           	PUSH DE
 691  55C9              	; comma
 692  55C9 CD 96 55     	CALL CHKCHAR
 693  55CC 2C           	DB ','
 694  55CD              	; get destination address
 695  55CD DD 21 2F 54  	LD IX, FRMQNT
 696  55D1 CD 59 01     	CALL CALBAS
 697  55D4 D5           	PUSH DE
 698  55D5              	; comma
 699  55D5 CD 96 55     	CALL CHKCHAR
 700  55D8 2C           	DB ','
 701  55D9              	; get length
 702  55D9 DD 21 2F 54  	LD IX, FRMQNT
 703  55DD CD 59 01     	CALL CALBAS
 704  55E0 D5           	PUSH DE
 705  55E1              	; ending )
 706  55E1 CD 96 55     	CALL CHKCHAR
 707  55E4 29           	DB ')'
 708  55E5
 709  55E5              	; save position
 710  55E5 E5           	PUSH HL
 711  55E6 DD E1        	POP IX
 712  55E8
 713  55E8 C1           	POP BC ; count
 714  55E9 D1           	POP DE ; destination
 715  55EA E1           	POP HL ; source
 716  55EB D9           	EXX
 717  55EC              	; enable page 0
 718  55EC FD 21 F3 55  	LD IY, .RET
 719  55F0 C3 49 55     	JP ENABLE_PAGE0
 720  55F3              .RET:
 721  55F3 FB           	EI
 722  55F4 D9           	EXX
 723  55F5 ED B0        	LDIR
 724  55F7 D1               POP DE
 725  55F8 C1               POP BC
 726  55F9 CD C0 54         CALL RESTORE_PAGE_INFO
 727  55FC DD E5        	PUSH IX
 728  55FE E1           	POP HL
 729  55FF C9           	RET
 730  5600              ; *******************************************************************************************************
 731  5600               ENDIF
 732  5600
 733  5600               IF (VRAM_CMDS == 1)
 734  5600              ; *******************************************************************************************************
 735  5600              ; function to handle CALL FILVRM basic extension
 736  5600              ; FILVRM ( INT offset,
 737  5600              ;		   INT count,
 738  5600              ;		   BYTE value,
 739  5600              ;		   BYTE wait_vsync) >0 = true
 740  5600              ; wait_vsync will issue HALT before copying
 741  5600              FILVRM:
 742  5600              	; opening (
 743  5600 CD 96 55     	CALL CHKCHAR
 744  5603 28           	DB '('
 745  5604              	; get offset address
 746  5604 DD 21 2F 54  	LD IX, FRMQNT
 747  5608 CD 59 01     	CALL CALBAS
 748  560B D5           	PUSH DE
 749  560C              	; comma
 750  560C CD 96 55     	CALL CHKCHAR
 751  560F 2C           	DB ','
 752  5610              	; get count
 753  5610 DD 21 2F 54  	LD IX, FRMQNT
 754  5614 CD 59 01     	CALL CALBAS
 755  5617 D5           	PUSH DE
 756  5618              	; comma
 757  5618 CD 96 55     	CALL CHKCHAR
 758  561B 2C           	DB ','
 759  561C              	; get value
 760  561C DD 21 1C 52  	LD IX, GETBYT
 761  5620 CD 59 01     	CALL CALBAS
 762  5623 F5           	PUSH AF
 763  5624              	; comma
 764  5624 CD 96 55     	CALL CHKCHAR
 765  5627 2C           	DB ','
 766  5628              	; get vsync wait
 767  5628 DD 21 1C 52  	LD IX, GETBYT
 768  562C CD 59 01     	CALL CALBAS
 769  562F F5           	PUSH AF
 770  5630              	; ending )
 771  5630 CD 96 55     	CALL CHKCHAR
 772  5633 29           	DB ')'
 773  5634
 774  5634 FB               EI
 775  5635              	; save position
 776  5635 E5           	PUSH HL
 777  5636 DD E1        	POP IX
 778  5638
 779  5638              	; syntax ok
 780  5638              	; wait for vsync if needed
 781  5638 F1           	POP AF
 782  5639 B7           	OR A
 783  563A 28 01        	JR Z, .L1
 784  563C 76           	HALT
 785  563D
 786  563D              .L1:
 787  563D F1               POP AF ; value
 788  563E C1               POP BC ; count
 789  563F E1               POP HL ; offset
 790  5640 CD 56 00         CALL BIOS_FILVRM
 791  5643
 792  5643              .L3:
 793  5643 DD E5        	PUSH IX
 794  5645 E1           	POP HL
 795  5646 C9           	RET
 796  5647              ; *******************************************************************************************************
 797  5647               ENDIF
 798  5647
 799  5647               IF (RAM_CMDS == 1)
 800  5647              ; *******************************************************************************************************
 801  5647              ; function to handle CALL FILRAM basic extension
 802  5647              ; FILRAM ( INT start address,
 803  5647              ;		   INT count,
 804  5647              ;		   BYTE value,
 805  5647              ; will put ram in page 0 also, page 1 is already there
 806  5647              FILRAM:
 807  5647              	; opening (
 808  5647 CD 96 55     	CALL CHKCHAR
 809  564A 28           	DB '('
 810  564B              	; get start address
 811  564B DD 21 2F 54  	LD IX, FRMQNT
 812  564F CD 59 01     	CALL CALBAS
 813  5652 D5           	PUSH DE
 814  5653              	; comma
 815  5653 CD 96 55     	CALL CHKCHAR
 816  5656 2C           	DB ','
 817  5657              	; get count
 818  5657 DD 21 2F 54  	LD IX, FRMQNT
 819  565B CD 59 01     	CALL CALBAS
 820  565E D5           	PUSH DE
 821  565F              	; comma
 822  565F CD 96 55     	CALL CHKCHAR
 823  5662 2C           	DB ','
 824  5663              	; get value
 825  5663 DD 21 1C 52  	LD IX, GETBYT
 826  5667 CD 59 01     	CALL CALBAS
 827  566A F5           	PUSH AF
 828  566B              	; ending )
 829  566B CD 96 55     	CALL CHKCHAR
 830  566E 29           	DB ')'
 831  566F
 832  566F              	; save position
 833  566F E5           	PUSH HL
 834  5670 DD E1        	POP IX
 835  5672
 836  5672 D1           	POP DE ; actually AF
 837  5673 C1           	POP BC ; count
 838  5674 E1           	POP HL ; start address
 839  5675 78           	LD A, B
 840  5676 B7           	OR A
 841  5677 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 842  5679 B1           	OR C
 843  567A 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 844  567C 79           	LD A, C
 845  567D 3D           	DEC A
 846  567E 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 847  5680              	; one byte to fill
 848  5680 72           	LD (HL), D
 849  5681 18 12        	JR .EXIT
 850  5683              .L1:
 851  5683 D9           	EXX
 852  5684              	; enable page 0
 853  5684 FD 21 8B 56  	LD IY, .RET
 854  5688 C3 49 55     	JP ENABLE_PAGE0
 855  568B              .RET:
 856  568B FB           	EI
 857  568C D9           	EXX
 858  568D CD 99 56     	CALL .FILLVALUE
 859  5690 D1               POP DE
 860  5691 C1               POP BC
 861  5692 CD C0 54         CALL RESTORE_PAGE_INFO
 862  5695              .EXIT:
 863  5695 DD E5        	PUSH IX
 864  5697 E1           	POP HL
 865  5698 C9           	RET
 866  5699
 867  5699              .FILLVALUE:
 868  5699 72               LD (HL), D
 869  569A 54               LD D, H
 870  569B 5D               LD E, L
 871  569C 13               INC DE
 872  569D 0B               DEC BC
 873  569E ED B0            LDIR
 874  56A0 C9               RET
 875  56A1              ; *******************************************************************************************************
 876  56A1               ENDIF
 877  56A1
 878  56A1               IF (GENCAL_CMD == 1)
 879  56A1              ; *******************************************************************************************************
 880  56A1              ; function to handle CALL GENCAL basic extension
 881  56A1              ; GENCAL ( INT fn_addr, = address of the function to call
 882  56A1              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 883  56A1              ; output values of reristers will also be stored at reg_list_ptr
 884  56A1              GENCAL_VAR_SP:
 885  56A1 00 00            DW 0
 886  56A3              GENCAL_VAR_SP2:
 887  56A3 00 00            DW 0
 888  56A5              GENCAL:
 889  56A5              	; opening (
 890  56A5 CD 96 55     	CALL CHKCHAR
 891  56A8 28           	DB '('
 892  56A9              	; get function address
 893  56A9 DD 21 2F 54  	LD IX, FRMQNT
 894  56AD CD 59 01     	CALL CALBAS
 895  56B0 D5           	PUSH DE
 896  56B1              	; comma
 897  56B1 CD 96 55     	CALL CHKCHAR
 898  56B4 2C           	DB ','
 899  56B5              	; get pointer to register list
 900  56B5 DD 21 2F 54  	LD IX, FRMQNT
 901  56B9 CD 59 01     	CALL CALBAS
 902  56BC D5           	PUSH DE
 903  56BD              	; ending )
 904  56BD CD 96 55     	CALL CHKCHAR
 905  56C0 29           	DB ')'
 906  56C1
 907  56C1              	; save BASIC token position
 908  56C1 E5           	PUSH HL
 909  56C2 D9               EXX
 910  56C3 E1           	POP HL ; HL'=next basic token
 911  56C4 D9               EXX
 912  56C5
 913  56C5 E1               POP HL ; get pointer to register values
 914  56C6 F3           	DI
 915  56C7 ED 73 A1 56      LD (GENCAL_VAR_SP), SP
 916  56CB F9               LD SP, HL
 917  56CC F1               POP AF
 918  56CD C1               POP BC
 919  56CE D1               POP DE
 920  56CF E1               POP HL
 921  56D0 DD E1            POP IX
 922  56D2 FD E1            POP IY
 923  56D4 D9               EXX
 924  56D5 ED 73 A3 56      LD (GENCAL_VAR_SP2), SP
 925  56D9 ED 7B A1 56      LD SP, (GENCAL_VAR_SP)
 926  56DD FB               EI
 927  56DE D1               POP DE ; get function to call
 928  56DF E5               PUSH HL
 929  56E0 CD FB 56         CALL .EXXDECALL
 930  56E3 F3               DI
 931  56E4 ED 73 A1 56      LD (GENCAL_VAR_SP), SP
 932  56E8 ED 7B A3 56      LD SP, (GENCAL_VAR_SP2)
 933  56EC FD E5            PUSH IY
 934  56EE DD E5            PUSH IX
 935  56F0 E5               PUSH HL
 936  56F1 D5               PUSH DE
 937  56F2 C5               PUSH BC
 938  56F3 F5               PUSH AF
 939  56F4 ED 7B A1 56      LD SP, (GENCAL_VAR_SP)
 940  56F8 FB               EI
 941  56F9 E1               POP HL
 942  56FA C9           	RET
 943  56FB
 944  56FB              .EXXDECALL:
 945  56FB D5               PUSH DE
 946  56FC D9               EXX
 947  56FD C9               RET
 948  56FE              ; *******************************************************************************************************
 949  56FE               ENDIF
 950  56FE
 951  56FE               IF (VRAM_CMDS == 1)
 952  56FE              ; *******************************************************************************************************
 953  56FE              ; function to handle CALL MEMVRM basic extension
 954  56FE              ; copies from RAM to VRAM
 955  56FE              ; _MEMVRM ( INT source,
 956  56FE              ;			INT destination,
 957  56FE              ;			INT count,
 958  56FE              ;			BYTE wait_vsync) >0 = true
 959  56FE              ; will put ram in page 0 also, page 1 is already there
 960  56FE              ; wait_vsync will issue HALT before copying
 961  56FE              MEMVRM:
 962  56FE              	; opening (
 963  56FE CD 96 55     	CALL CHKCHAR
 964  5701 28           	DB '('
 965  5702              	; get source address
 966  5702 DD 21 2F 54  	LD IX, FRMQNT
 967  5706 CD 59 01     	CALL CALBAS
 968  5709 D5           	PUSH DE
 969  570A              	; comma
 970  570A CD 96 55     	CALL CHKCHAR
 971  570D 2C           	DB ','
 972  570E              	; get destination address
 973  570E DD 21 2F 54  	LD IX, FRMQNT
 974  5712 CD 59 01     	CALL CALBAS
 975  5715 D5           	PUSH DE
 976  5716              	; comma
 977  5716 CD 96 55     	CALL CHKCHAR
 978  5719 2C           	DB ','
 979  571A              	; get length
 980  571A DD 21 2F 54  	LD IX, FRMQNT
 981  571E CD 59 01     	CALL CALBAS
 982  5721 D5           	PUSH DE
 983  5722              	; comma
 984  5722 CD 96 55     	CALL CHKCHAR
 985  5725 2C           	DB ','
 986  5726              	; get vsync wait
 987  5726 DD 21 1C 52  	LD IX, GETBYT
 988  572A CD 59 01     	CALL CALBAS
 989  572D F5           	PUSH AF
 990  572E              	; ending )
 991  572E CD 96 55     	CALL CHKCHAR
 992  5731 29           	DB ')'
 993  5732
 994  5732                  ; save position in BASIC text
 995  5732 E5           	PUSH HL
 996  5733 DD E1        	POP IX
 997  5735
 998  5735 F1           	POP AF ; wait vsync
 999  5736 B7           	OR A
1000  5737 28 03        	JR Z, .L1
1001  5739 FB               EI
1002  573A 76           	HALT
1003  573B F3           	DI
1004  573C              .L1:
1005  573C              	; pop LDIR parameters and store away for later
1006  573C C1           	POP BC ; count
1007  573D D1           	POP DE ; vram destination
1008  573E E1           	POP HL ; ram source
1009  573F D9           	EXX
1010  5740 FD 21 47 57   	LD IY, .RET
1011  5744 C3 49 55     	JP ENABLE_PAGE0
1012  5747              .RET:
1013  5747 FB           	EI
1014  5748 D9           	EXX
1015  5749 CD 55 57     	CALL .LDIRVM
1016  574C D1               POP DE
1017  574D C1               POP BC
1018  574E CD C0 54         CALL RESTORE_PAGE_INFO
1019  5751 DD E5        	PUSH IX
1020  5753 E1           	POP HL
1021  5754 C9           	RET
1022  5755
1023  5755              .LDIRVM:
1024  5755 EB           	EX DE, HL
1025  5756 F3           	DI
1026  5757 CD 72 54     	CALL SETWRT_LOCAL
1027  575A FB           	EI
1028  575B EB           	EX DE, HL
1029  575C 78           	LD A, B
1030  575D B7           	OR A
1031  575E 28 0D        	JR Z, .L3
1032  5760 C5           	PUSH BC
1033  5761 0E 98        	LD C, #98
1034  5763              .L2:
1035  5763 50           	LD D, B
1036  5764 06 00        	LD B, 0
1037  5766 CD 7D 54     	CALL BBYTECOPY
1038  5769 42           	LD B, D
1039  576A 10 F7        	DJNZ .L2
1040  576C C1           	POP BC
1041  576D              .L3:
1042  576D 79           	LD A, C
1043  576E B7           	OR A
1044  576F C8           	RET Z
1045  5770 41           	LD B, C
1046  5771 0E 98        	LD C, #98
1047  5773 C3 7D 54     	JP BBYTECOPY
1048  5776              ; *******************************************************************************************************
1049  5776               ENDIF
1050  5776
1051  5776               IF (VRAM_CMDS == 1)
1052  5776              ; *******************************************************************************************************
1053  5776              ; function to handle CALL VRMMEM basic extension
1054  5776              ; copies from RAM to VRAM
1055  5776              ; _VRMMEM ( INT source,
1056  5776              ;			INT destination,
1057  5776              ;			INT count
1058  5776              ; will put ram in page 0 also, page 1 is already there
1059  5776              VRMMEM:
1060  5776              	; opening (
1061  5776 CD 96 55     	CALL CHKCHAR
1062  5779 28           	DB '('
1063  577A              	; get source address
1064  577A DD 21 2F 54  	LD IX, FRMQNT
1065  577E CD 59 01     	CALL CALBAS
1066  5781 D5           	PUSH DE
1067  5782              	; comma
1068  5782 CD 96 55     	CALL CHKCHAR
1069  5785 2C           	DB ','
1070  5786              	; get destination address
1071  5786 DD 21 2F 54  	LD IX, FRMQNT
1072  578A CD 59 01     	CALL CALBAS
1073  578D D5           	PUSH DE
1074  578E              	; comma
1075  578E CD 96 55     	CALL CHKCHAR
1076  5791 2C           	DB ','
1077  5792              	; get length
1078  5792 DD 21 2F 54  	LD IX, FRMQNT
1079  5796 CD 59 01     	CALL CALBAS
1080  5799 D5           	PUSH DE
1081  579A              	; ending )
1082  579A CD 96 55     	CALL CHKCHAR
1083  579D 29           	DB ')'
1084  579E
1085  579E                  ; save position in BASIC text
1086  579E E5           	PUSH HL
1087  579F DD E1        	POP IX
1088  57A1
1089  57A1 C1           	POP BC ; count
1090  57A2 D1           	POP DE ; destination
1091  57A3 E1           	POP HL ; source
1092  57A4 D9           	EXX
1093  57A5 FD 21 AC 57  	LD IY, .RET
1094  57A9 C3 49 55     	JP ENABLE_PAGE0
1095  57AC              .RET:
1096  57AC FB           	EI
1097  57AD D9           	EXX
1098  57AE CD BA 57     	CALL .LDIRMV
1099  57B1 D1               POP DE
1100  57B2 C1               POP BC
1101  57B3 CD C0 54         CALL RESTORE_PAGE_INFO
1102  57B6 DD E5        	PUSH IX
1103  57B8 E1           	POP HL
1104  57B9 C9           	RET
1105  57BA
1106  57BA              .LDIRMV:
1107  57BA              	; set VRAM address *exactly* as in ROM, otherwise corruption
1108  57BA 7D           	LD	A, L
1109  57BB F3           	DI
1110  57BC D3 99        	OUT	(099H), A
1111  57BE 7C           	LD	A, H
1112  57BF E6 3F        	AND	03FH
1113  57C1 D3 99        	OUT	(099H), A
1114  57C3 FB           	EI
1115  57C4              	;EX (SP), HL
1116  57C4              	;EX (SP), HL
1117  57C4              	;NOP
1118  57C4              	;NOP
1119  57C4              .L4:
1120  57C4 DB 98            IN A, (#98)
1121  57C6 12           	LD (DE), A
1122  57C7 13               INC DE
1123  57C8 0B               DEC BC
1124  57C9 79               LD A, C
1125  57CA B0               OR B
1126  57CB 20 F7            JR NZ, .L4
1127  57CD C9               RET
1128  57CE              ; *******************************************************************************************************
1129  57CE               ENDIF
1130  57CE
1131  57CE              ; *******************************************************************************************************
1132  57CE              ; H.TIMI function
1133  57CE              MBGE_HTIMI:
1134  57CE               EXPORT MBGE_HTIMI
1135  57CE F5           	PUSH AF
1136  57CF
1137  57CF               IF (SPRITE_CMDS == 1)
1138  57CF CD 0D 4D     	CALL SPRATR_UPDATE
1139  57D2               ENDIF
1140  57D2
1141  57D2               IF (SOUND_CMDS == 1)
1142  57D2 3A F7 4C     	LD A, (SOUND_ENABLED)
1143  57D5 B7           	OR A
1144  57D6 28 2A        	JR Z, .EXIT
1145  57D8
1146  57D8              	; enable page 2
1147  57D8 3E 02            LD A, 2
1148  57DA CD 89 54         CALL GET_PAGE_INFO
1149  57DD C5               PUSH BC
1150  57DE D5               PUSH DE
1151  57DF 3A 43 F3         LD A, (RAMAD2)
1152  57E2 26 80            LD H, 080H
1153  57E4 CD D0 54         CALL LOCAL_ENASLT
1154  57E7              	; enable page 0
1155  57E7 AF               XOR A
1156  57E8 CD 89 54         CALL GET_PAGE_INFO
1157  57EB C5               PUSH BC
1158  57EC D5               PUSH DE
1159  57ED 3A 41 F3         LD A, (RAMAD0)
1160  57F0 26 00            LD H, 0
1161  57F2 CD D0 54         CALL LOCAL_ENASLT
1162  57F5
1163  57F5 CD 33 42     	CALL PLY_AKG_PLAY
1164  57F8
1165  57F8              	; restore page 0
1166  57F8 D1               POP DE
1167  57F9 C1               POP BC
1168  57FA CD C0 54         CALL RESTORE_PAGE_INFO
1169  57FD              	; restore page 2
1170  57FD D1               POP DE
1171  57FE C1               POP BC
1172  57FF CD C0 54         CALL RESTORE_PAGE_INFO
1173  5802               ENDIF
1174  5802
1175  5802              .EXIT:
1176  5802 F1           	POP AF
1177  5803 C3 F0 4C     	JP ORIG.HTIMI
1178  5806              ; *******************************************************************************************************
1179  5806
1180  5806              ; *******************************************************************************************************
1181  5806              ; interrupt handler when page 0 enabled
1182  5806              VBLANK:
1183  5806              	EXPORT VBLANK
1184  5806
1185  5806 F5               PUSH AF
1186  5807              	; is VDP originator ?
1187  5807 DB 99        	IN	A, (099H)
1188  5809 A7           	AND	A
1189  580A F2 30 58     	JP P, .EXIT
1190  580D
1191  580D               IF (SOUND_CMDS == 1)
1192  580D 3A F7 4C     	LD A, (SOUND_ENABLED)
1193  5810 B7           	OR A
1194  5811 28 1D        	JR Z, .EXIT
1195  5813
1196  5813 C5               PUSH BC
1197  5814 D5               PUSH DE
1198  5815 E5               PUSH HL
1199  5816 08               EX AF, AF'
1200  5817 D9               EXX
1201  5818 F5               PUSH AF
1202  5819 C5               PUSH BC
1203  581A D5               PUSH DE
1204  581B E5               PUSH HL
1205  581C DD E5            PUSH IX
1206  581E FD E5            PUSH IY
1207  5820
1208  5820 CD 33 42     	CALL PLY_AKG_PLAY
1209  5823
1210  5823 FD E1            POP IY
1211  5825 DD E1            POP IX
1212  5827 E1               POP HL
1213  5828 D1               POP DE
1214  5829 C1               POP BC
1215  582A F1               POP AF
1216  582B 08               EX AF, AF'
1217  582C D9               EXX
1218  582D E1               POP HL
1219  582E D1               POP DE
1220  582F C1               POP BC
1221  5830               ENDIF
1222  5830
1223  5830              .EXIT:
1224  5830 F1           	POP AF
1225  5831 FB           	EI
1226  5832 ED 4D        	RETI
1227  5834              ; *******************************************************************************************************
1228  5834
1229  5834               IF (SOUND_CMDS == 1)
1230  5834              ; *******************************************************************************************************
1231  5834              ; function to handle CALL SNDPLYINIT basic extension
1232  5834              ; initializes sound player
1233  5834              ; _SNDPLYINIT ( INT music_offset,
1234  5834              ;				INT sfx_offset, can be -1 if no SFX
1235  5834              ; will put ram in page 0 also, page 1 is already there
1236  5834              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1237  5834              SNDPLYINIT:
1238  5834              	; opening (
1239  5834 CD 96 55     	CALL CHKCHAR
1240  5837 28           	DB '('
1241  5838              	; get music address
1242  5838 DD 21 2F 54  	LD IX, FRMQNT
1243  583C CD 59 01     	CALL CALBAS
1244  583F D5           	PUSH DE
1245  5840              	; comma
1246  5840 CD 96 55     	CALL CHKCHAR
1247  5843 2C           	DB ','
1248  5844              	; get sfx address
1249  5844 DD 21 2F 54  	LD IX, FRMQNT
1250  5848 CD 59 01     	CALL CALBAS
1251  584B D5           	PUSH DE
1252  584C              	; ending )
1253  584C CD 96 55     	CALL CHKCHAR
1254  584F 29           	DB ')'
1255  5850
1256  5850                  ; save position in BASIC text
1257  5850 44           	LD B, H
1258  5851 4D           	LD C, L
1259  5852
1260  5852              	; pop LDIR parameters and store away for later
1261  5852 D1           	POP DE ; sfx address
1262  5853 E1           	POP HL ; music address
1263  5854 C5           	PUSH BC ; basic text location
1264  5855 D9           	EXX
1265  5856 FD 21 5D 58  	LD IY, .RET
1266  585A C3 49 55     	JP ENABLE_PAGE0
1267  585D              .RET:
1268  585D D9           	EXX
1269  585E
1270  585E D5           	PUSH DE
1271  585F AF           	XOR A
1272  5860              	; HL = music location
1273  5860 CD 62 41     	CALL PLY_AKG_INIT
1274  5863 3E 01        	LD A, 1
1275  5865 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1276  5868
1277  5868 E1           	POP HL ; SFX
1278  5869              	; check if SFX address -1
1279  5869 23           	INC HL
1280  586A 7D           	LD A, L
1281  586B B4           	OR H
1282  586C 28 09        	JR Z,.L1
1283  586E 2B           	DEC HL
1284  586F CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1285  5872 3E 01        	LD A, 1
1286  5874 32 F6 4C     	LD (SFX_INIT_STATUS), A
1287  5877              .L1:
1288  5877 D1               POP DE
1289  5878 C1               POP BC
1290  5879 CD C0 54         CALL RESTORE_PAGE_INFO
1291  587C
1292  587C E1           	POP HL
1293  587D C9           	RET
1294  587E              ; *******************************************************************************************************
1295  587E
1296  587E              ; *******************************************************************************************************
1297  587E              ; function to handle CALL SNDPLYON basic extension
1298  587E              ; enables sound player
1299  587E              ; _SNDPLYON
1300  587E              ; sets SOUND_ENABLED variable to 1 if init call was done
1301  587E              ; if not throws out of data error
1302  587E              SNDPLYON:
1303  587E 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1304  5881 B7           	OR A
1305  5882 20 05        	JR NZ, .L1
1306  5884              	; player not initialized, throw error
1307  5884 1E 04        	LD E, 04 ; Out of DATA
1308  5886 C3 B6 55     	JP THROW_ERROR
1309  5889              .L1:
1310  5889 32 F7 4C     	LD (SOUND_ENABLED), A
1311  588C              	; disable key click
1312  588C AF           	XOR A
1313  588D 32 DB F3     	LD (CLIKSW), A
1314  5890 C9           	RET
1315  5891              ; *******************************************************************************************************
1316  5891
1317  5891              ; *******************************************************************************************************
1318  5891              ; function to handle CALL SNDPLYOFF basic extension
1319  5891              ; disables sound player
1320  5891              ; _SNDPLYOFF
1321  5891              ; sets SOUND_ENABLED variable to 0
1322  5891              ; calls AKG to stop music and SFX on all channels if initialized
1323  5891              SNDPLYOFF:
1324  5891 3A F7 4C     	LD A, (SOUND_ENABLED)
1325  5894 B7           	OR A
1326  5895 C8           	RET Z ; already stopped
1327  5896 AF           	XOR A
1328  5897 32 F7 4C     	LD (SOUND_ENABLED), A
1329  589A E5           	PUSH HL
1330  589B CD 21 42     	CALL PLY_AKG_STOP
1331  589E 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1332  58A1 B7           	OR A
1333  58A2 28 0E        	JR Z, .EXIT ; SFX not in use
1334  58A4 AF           	XOR A
1335  58A5 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1336  58A8 3E 01        	LD A, 1
1337  58AA CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1338  58AD 3E 02        	LD A, 2
1339  58AF CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1340  58B2              .EXIT:
1341  58B2 E1           	POP HL
1342  58B3 C9           	RET
1343  58B4              ; *******************************************************************************************************
1344  58B4
1345  58B4              ; *******************************************************************************************************
1346  58B4              ; function to handle CALL SNDSFX basic extension
1347  58B4              ; plays a sound effect
1348  58B4              ; _SNDSFX ( BYTE sfx_number, >0
1349  58B4              ;			BYTE channel, = 0,1 or 2
1350  58B4              ;			BYTE inverted_volume = 0-16, 0 being full volume
1351  58B4              ; will put ram in page 0 also, page 1 is already there
1352  58B4              ; if sound off throws illegal function call
1353  58B4              ; if sfx not initialized, throws out of data
1354  58B4              SNDSFX:
1355  58B4              	; opening (
1356  58B4 CD 96 55     	CALL CHKCHAR
1357  58B7 28           	DB '('
1358  58B8              	; get sfx_number
1359  58B8 DD 21 1C 52  	LD IX, GETBYT
1360  58BC CD 59 01     	CALL CALBAS
1361  58BF D5           	PUSH DE
1362  58C0              	; comma
1363  58C0 CD 96 55     	CALL CHKCHAR
1364  58C3 2C           	DB ','
1365  58C4              	; get sfx address
1366  58C4 DD 21 1C 52  	LD IX, GETBYT
1367  58C8 CD 59 01     	CALL CALBAS
1368  58CB D5           	PUSH DE
1369  58CC              	; comma
1370  58CC CD 96 55     	CALL CHKCHAR
1371  58CF 2C           	DB ','
1372  58D0              	; get inverted volume
1373  58D0 DD 21 1C 52  	LD IX, GETBYT
1374  58D4 CD 59 01     	CALL CALBAS
1375  58D7 D5           	PUSH DE
1376  58D8              	; ending )
1377  58D8 CD 96 55     	CALL CHKCHAR
1378  58DB 29           	DB ')'
1379  58DC
1380  58DC 3A F7 4C     	LD A, (SOUND_ENABLED)
1381  58DF B7           	OR A
1382  58E0 20 05        	JR NZ, .L1
1383  58E2              	; sound disabled, throw illegal function call
1384  58E2 1E 05        	LD E, 5
1385  58E4 C3 B6 55     	JP THROW_ERROR
1386  58E7              .L1:
1387  58E7 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1388  58EA B7           	OR A
1389  58EB 20 05        	JR NZ, .L2
1390  58ED              	; sfx data not initialized, throw out of data
1391  58ED 1E 04        	LD E, 4
1392  58EF C3 B6 55     	JP THROW_ERROR
1393  58F2              .L2:
1394  58F2              	; pop  parameters and store away for later
1395  58F2 D1           	POP DE ; inverted volume
1396  58F3 43           	LD B, E
1397  58F4 D1           	POP DE ; channel
1398  58F5 4B           	LD C, E
1399  58F6 D1           	POP DE
1400  58F7 7B           	LD A, E
1401  58F8 08           	EX AF, AF'
1402  58F9 E5           	PUSH HL ; basic text location
1403  58FA D9           	EXX
1404  58FB FD 21 02 59  	LD IY, .RET
1405  58FF C3 49 55     	JP ENABLE_PAGE0
1406  5902              .RET:
1407  5902 D9           	EXX
1408  5903 08           	EX AF, AF'
1409  5904 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1410  5907
1411  5907 D1               POP DE
1412  5908 C1               POP BC
1413  5909 CD C0 54         CALL RESTORE_PAGE_INFO
1414  590C
1415  590C E1           	POP HL
1416  590D C9           	RET
1417  590E              ; *******************************************************************************************************
1418  590E               ENDIF
1419  590E
1420  590E               IF (BLIT_CMDS == 1)
1421  590E              ; *******************************************************************************************************
1422  590E              ; function rotates mask and data of several characters and applies to background data
1423  590E              ; this handles x-shift from 0 to 4
1424  590E              ; contains self-modifying code that is set-up from external function
1425  590E              ; input HL=pointer to mask data
1426  590E              ; input HL'=pointer to character data
1427  590E              ; input DE=output buffer containing background data
1428  590E              ; input BC=DE+8
1429  590E              ; input A=number of characters to process
1430  590E              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1431  590E              SHIFT04:
1432  590E 08           	EX AF, AF'
1433  590F 7E           	LD A, (HL) ; get mask
1434  5910 D9           	EXX
1435  5911 57           	LD D, A
1436  5912 1E FF        	LD E, #FF
1437  5914 37           	SCF
1438  5915              .M1:
1439  5915 18 FE        	JR .M1 ; this is self-modifying part
1440  5917 CB 1A        	RR D
1441  5919 CB 1B        	RR E
1442  591B CB 1A        	RR D
1443  591D CB 1B        	RR E
1444  591F CB 1A        	RR D
1445  5921 CB 1B        	RR E
1446  5923 CB 1A        	RR D
1447  5925 CB 1B        	RR E
1448  5927
1449  5927 46           	LD B, (HL) ; get data
1450  5928 0E 00        	LD C, 0
1451  592A              .M2:
1452  592A 18 FE        	JR .M2 ; also self-modifying part
1453  592C CB 38        	SRL B
1454  592E CB 19        	RR C
1455  5930 CB 38        	SRL B
1456  5932 CB 19        	RR C
1457  5934 CB 38        	SRL B
1458  5936 CB 19        	RR C
1459  5938 CB 38        	SRL B
1460  593A CB 19        	RR C
1461  593C
1462  593C D9           	EXX
1463  593D 1A           	LD A, (DE) ; background
1464  593E D9           	EXX
1465  593F A2           	AND D
1466  5940 B0           	OR B
1467  5941 D9           	EXX
1468  5942 12           	LD (DE), A
1469  5943
1470  5943 0A           	LD A, (BC)
1471  5944 D9           	EXX
1472  5945 A3           	AND E
1473  5946 B1           	OR C
1474  5947 23           	INC HL
1475  5948 D9           	EXX
1476  5949 02           	LD (BC), A
1477  594A
1478  594A 23           	INC HL
1479  594B 13           	INC DE
1480  594C 03           	INC BC
1481  594D
1482  594D 08           	EX AF, AF'
1483  594E 3D           	DEC A
1484  594F C2 0E 59     	JP NZ, SHIFT04
1485  5952 C9           	RET
1486  5953              ; *******************************************************************************************************
1487  5953
1488  5953              ; *******************************************************************************************************
1489  5953              ; function rotates mask and data of several characters and applies to background data
1490  5953              ; this handles x-shift from 5 to 8
1491  5953              ; contains self-modifying code that is set-up from external function
1492  5953              ; input HL=pointer to mask data
1493  5953              ; input HL'=pointer to character data
1494  5953              ; input DE=output buffer containing background data
1495  5953              ; input BC=DE+8
1496  5953              ; input A=number of characters to process
1497  5953              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1498  5953              SHIFT58:
1499  5953 08           	EX AF, AF'
1500  5954 7E           	LD A, (HL) ; get mask
1501  5955 D9           	EXX
1502  5956 57           	LD D, A
1503  5957 1E FF        	LD E, #FF
1504  5959 37           	SCF
1505  595A              .M1:
1506  595A 18 FE        	JR .M1 ; this is self-modifying part
1507  595C CB 12        	RL D
1508  595E CB 13        	RL E
1509  5960 CB 12        	RL D
1510  5962 CB 13        	RL E
1511  5964 CB 12        	RL D
1512  5966 CB 13        	RL E
1513  5968
1514  5968 46           	LD B, (HL)
1515  5969 0E 00        	LD C, 0
1516  596B              .M2:
1517  596B 18 FE        	JR .M2 ; also self-modifying part
1518  596D CB 20        	SLA B
1519  596F CB 11        	RL C
1520  5971 CB 20        	SLA B
1521  5973 CB 11        	RL C
1522  5975 CB 20        	SLA B
1523  5977 CB 11        	RL C
1524  5979
1525  5979 D9           	EXX
1526  597A 1A           	LD A, (DE) ; background
1527  597B D9           	EXX
1528  597C A3           	AND E
1529  597D B1           	OR C
1530  597E D9           	EXX
1531  597F 12           	LD (DE), A
1532  5980
1533  5980 0A           	LD A, (BC)
1534  5981 D9           	EXX
1535  5982 A2           	AND D
1536  5983 B0           	OR B
1537  5984 23           	INC HL
1538  5985 D9           	EXX
1539  5986 02           	LD (BC), A
1540  5987
1541  5987 23           	INC HL
1542  5988 13           	INC DE
1543  5989 03           	INC BC
1544  598A
1545  598A 08           	EX AF, AF'
1546  598B 3D           	DEC A
1547  598C C2 53 59     	JP NZ, SHIFT58
1548  598F C9           	RET
1549  5990              ; *******************************************************************************************************
1550  5990
1551  5990              ; *******************************************************************************************************
1552  5990              ; routine that shifts one row of characters
1553  5990              ; contains self-modifying code that is set-up from external function
1554  5990              ; input HL=pointer to mask data
1555  5990              ; input HL'=pointer to character data
1556  5990              ; input DE=output buffer containing background data
1557  5990              ; input A=number of characters to process
1558  5990              ; input IX=pointer to structure describing input data
1559  5990              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1560  5990              SHIFT_ROW:
1561  5990 F5           	PUSH AF
1562  5991 ED 53 E9 52  		LD (BLIT_TMP1), DE
1563  5995 E5           		PUSH HL
1564  5996 CD D9 59     			CALL .ADDYSHIFT
1565  5999 E1           		POP HL
1566  599A ED 53 EB 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1567  599E              .L1:
1568  599E 3E 08        		LD A, 8
1569  59A0 DD 96 02     		SUB (IX+2) ; y shift
1570  59A3              .CALL1:
1571  59A3 CD 00 00     		CALL 0
1572  59A6 DD 7E 02     		LD A, (IX+2); y shift
1573  59A9 B7           		OR A
1574  59AA 28 26        		JR Z, .DONE
1575  59AC ED 5B E9 52  		LD DE, (BLIT_TMP1)
1576  59B0 E5           		PUSH HL
1577  59B1 CD E7 59     			CALL .DETONEXTROW
1578  59B4 E1           		POP HL
1579  59B5              .CALL2:
1580  59B5 CD 00 00     		CALL 0
1581  59B8 ED 5B E9 52  		LD DE, (BLIT_TMP1)
1582  59BC E5           		PUSH HL
1583  59BD CD E1 59     			CALL .ADD8
1584  59C0 E1           		POP HL
1585  59C1 ED 53 E9 52  		LD (BLIT_TMP1), DE
1586  59C5 ED 5B EB 52  		LD DE, (BLIT_TMP2)
1587  59C9 E5           		PUSH HL
1588  59CA CD E1 59     			CALL .ADD8
1589  59CD E1           		POP HL
1590  59CE ED 53 EB 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1591  59D2              .DONE:
1592  59D2 F1           	POP AF
1593  59D3 3D           	DEC A
1594  59D4 C8           	RET Z
1595  59D5 F5           	PUSH AF
1596  59D6 C3 9E 59     	JP .L1
1597  59D9              .ADDYSHIFT:
1598  59D9 EB           	EX DE, HL
1599  59DA 16 00        	LD D, 0
1600  59DC DD 5E 02     	LD E, (IX+2); y shift
1601  59DF 18 0C        	JR .MOVDEBC
1602  59E1              .ADD8:
1603  59E1 21 08 00     	LD HL, 8
1604  59E4 C3 ED 59     	JP .MOVDEBC
1605  59E7              .DETONEXTROW:
1606  59E7 DD 6E 06     	LD L, (IX+6)
1607  59EA DD 66 07     	LD H, (IX+7) ; bkg add to value
1608  59ED              .MOVDEBC:
1609  59ED 19           	ADD HL, DE
1610  59EE 54           	LD D, H
1611  59EF 5D           	LD E, L
1612  59F0 01 08 00     	LD BC, 8
1613  59F3 09           	ADD HL, BC
1614  59F4 44           	LD B, H
1615  59F5 4D           	LD C, L
1616  59F6 C9           	RET
1617  59F7              ; *******************************************************************************************************
1618  59F7
1619  59F7              ; *******************************************************************************************************
1620  59F7              ; function rotates mask and character data and applies it to background
1621  59F7              ; input IX=pointer to structure describing input data
1622  59F7              ; +0  DW horizontal shift count 0-7 (low byte used)
1623  59F7              ; +2  DW vertical shift count 0-7 (low byte used)
1624  59F7              ; +4  DW background data start;
1625  59F7              ; +6  DW background add to value to next row of background data
1626  59F7              ; +8  DW mask data start;
1627  59F7              ; +10  DW character data start;
1628  59F7              ; +12 DW character&mask add to value to next row of data
1629  59F7              ; +14 DW columns (low byte used)
1630  59F7              ; +16 DW rows (low byte used)
1631  59F7              SHIFT_MERGE_CHARACTER:
1632  59F7 DD 7E 00     	LD A, (IX) ; shift
1633  59FA FE 05        	CP 5
1634  59FC 38 25        	JR C, .RIGHT
1635  59FE              	; shifts 5-7, use rotate towards left 1-3
1636  59FE 21 53 59     	LD HL, SHIFT58
1637  5A01 22 A4 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1638  5A04 22 B6 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1639  5A07 D6 05        	SUB 5
1640  5A09 28 0D        	JR Z, .L1
1641  5A0B 87           	ADD A, A
1642  5A0C 87           	ADD A, A
1643  5A0D 67           	LD H, A
1644  5A0E 2E 18        	LD L, #18 ; JR opcode
1645  5A10 22 5A 59     	LD (SHIFT58.M1), HL
1646  5A13 22 6B 59     	LD (SHIFT58.M2), HL
1647  5A16 18 32        	JR .DO
1648  5A18              .L1:
1649  5A18 21 00 00     	LD HL, 0 ; 2xNOP opcode
1650  5A1B 22 5A 59     	LD (SHIFT58.M1), HL
1651  5A1E 22 6B 59     	LD (SHIFT58.M2), HL
1652  5A21 18 27        	JR .DO
1653  5A23              .RIGHT:
1654  5A23              	; shifts 0-4, rotate towards right
1655  5A23 21 0E 59     	LD HL, SHIFT04
1656  5A26 22 A4 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1657  5A29 22 B6 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1658  5A2C FE 04        	CP 4
1659  5A2E 28 11        	JR Z, .R1
1660  5A30 D6 04        	SUB 4
1661  5A32 ED 44        	NEG
1662  5A34 87           	ADD A, A
1663  5A35 87           	ADD A, A
1664  5A36 67           	LD H, A
1665  5A37 2E 18        	LD L, #18 ; JR opcode
1666  5A39 22 15 59     	LD (SHIFT04.M1), HL
1667  5A3C 22 2A 59     	LD (SHIFT04.M2), HL
1668  5A3F 18 09        	JR .DO
1669  5A41              .R1:
1670  5A41 21 00 00     	LD HL, 0 ; 2xNOP opcode
1671  5A44 22 15 59     	LD (SHIFT04.M1), HL
1672  5A47 22 2A 59     	LD (SHIFT04.M2), HL
1673  5A4A              .DO:
1674  5A4A DD 46 10     	LD B, (IX+16) ; rows
1675  5A4D DD 6E 08     	LD L, (IX+8)
1676  5A50 DD 66 09     	LD H, (IX+9) ; mask data
1677  5A53 DD 5E 04     	LD E, (IX+4)
1678  5A56 DD 56 05     	LD D, (IX+5) ; background data
1679  5A59 D9           	EXX
1680  5A5A DD 6E 0A     	LD L, (IX+10)
1681  5A5D DD 66 0B     	LD H, (IX+11) ; character data
1682  5A60 D9           	EXX
1683  5A61              .LOOP:
1684  5A61 C5           	PUSH BC
1685  5A62 E5           		PUSH HL
1686  5A63 D5           			PUSH DE
1687  5A64 D9           				EXX
1688  5A65 E5           				PUSH HL
1689  5A66 D9           					EXX
1690  5A67 DD 7E 0E     					LD A, (IX+14) ; columns
1691  5A6A              .CALL:
1692  5A6A CD 90 59     					CALL SHIFT_ROW
1693  5A6D E1           				POP HL
1694  5A6E DD 5E 0C     				LD E, (IX+12)
1695  5A71 DD 56 0D     				LD D, (IX+13) ; char data to next row
1696  5A74 19           				ADD HL, DE
1697  5A75 D9           				EXX
1698  5A76 E1           			POP HL
1699  5A77 DD 5E 06     			LD E, (IX+6)
1700  5A7A DD 56 07     			LD D, (IX+7) ; background to next row
1701  5A7D 19           			ADD HL, DE
1702  5A7E EB           			EX DE, HL
1703  5A7F E1           		POP HL
1704  5A80 DD 4E 0C     		LD C, (IX+12)
1705  5A83 DD 46 0D     		LD B, (IX+13) ; char data to next row
1706  5A86 09           		ADD HL, BC
1707  5A87 C1           	POP BC
1708  5A88 10 D7        	DJNZ .LOOP
1709  5A8A C9           	RET
1710  5A8B              ; *******************************************************************************************************
1711  5A8B
1712  5A8B               IFNDEF CMDS_WITH_PARAMETERS
1713  5A8B ~            ; *******************************************************************************************************
1714  5A8B ~            ; function to handle CALL BLIT basic extension
1715  5A8B ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1716  5A8B ~            ; fuses with background data and applies vertical shift too
1717  5A8B ~            ; BLIT ( INT request_data_ptr )
1718  5A8B ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1719  5A8B ~            ; will put ram in page 0 also, page 1 is already there
1720  5A8B ~            BLIT:
1721  5A8B ~            	; opening (
1722  5A8B ~            	CALL CHKCHAR
1723  5A8B ~            	DB '('
1724  5A8B ~            	; get pointer to request struct
1725  5A8B ~            	LD IX, FRMQNT
1726  5A8B ~            	CALL CALBAS
1727  5A8B ~            	PUSH DE
1728  5A8B ~            	; ending )
1729  5A8B ~            	CALL CHKCHAR
1730  5A8B ~            	DB ')'
1731  5A8B ~
1732  5A8B ~            	POP IX ; pointer to request struct
1733  5A8B ~
1734  5A8B ~            	PUSH HL ; save position in BASIC buffer
1735  5A8B ~
1736  5A8B ~            	LD IY, .RET
1737  5A8B ~            	JP ENABLE_PAGE0
1738  5A8B ~            .RET:
1739  5A8B ~            	EI
1740  5A8B ~            	CALL SHIFT_MERGE_CHARACTER
1741  5A8B ~
1742  5A8B ~                POP DE
1743  5A8B ~                POP BC
1744  5A8B ~                CALL RESTORE_PAGE_INFO
1745  5A8B ~
1746  5A8B ~            	POP HL
1747  5A8B ~            	RET
1748  5A8B ~            ; *******************************************************************************************************
1749  5A8B               ENDIF
1750  5A8B
1751  5A8B               IFDEF CMDS_WITH_PARAMETERS
1752  5A8B              ; *******************************************************************************************************
1753  5A8B              ; function to handle CALL BLIT basic extension
1754  5A8B              ; rotates 1-bit character drawing horizontally with mask and character data and
1755  5A8B              ; fuses with background data and applies vertical shift too
1756  5A8B              ; in form without pointers
1757  5A8B              ; BLIT ( INT x,
1758  5A8B              ;		 INT y,
1759  5A8B              ;		 INT char_data_pointer,
1760  5A8B              ;		 INT mask_data_pointer,
1761  5A8B              ;		 INT width (in characters),
1762  5A8B              ;		 INT height (in characters),
1763  5A8B              ;		 INT background_pointer (top left),
1764  5A8B              ;		 INT background_width (in characters),
1765  5A8B              ;		 INT background_height (in characters))
1766  5A8B              ; will put ram in page 0 also, page 1 is already there
1767  5A8B              BLIT:
1768  5A8B              	; opening (
1769  5A8B CD 96 55     	CALL CHKCHAR
1770  5A8E 28           	DB '('
1771  5A8F              	; get x coordinate
1772  5A8F DD 21 2F 54  	LD IX, FRMQNT
1773  5A93 CD 59 01     	CALL CALBAS
1774  5A96 7B           	LD A, E
1775  5A97 E6 07        	AND 7
1776  5A99 32 ED 52     	LD (BLIT_STRUCT+0), A
1777  5A9C CD 79 5B     	CALL .DAdiv8
1778  5A9F 32 E9 52     	LD (BLIT_TMP+0),A
1779  5AA2              	; comma
1780  5AA2 CD 96 55     	CALL CHKCHAR
1781  5AA5 2C           	DB ','
1782  5AA6              	; get y coordinate
1783  5AA6 DD 21 2F 54  	LD IX, FRMQNT
1784  5AAA CD 59 01     	CALL CALBAS
1785  5AAD 7B           	LD A, E
1786  5AAE E6 07        	AND 7
1787  5AB0 32 EF 52     	LD (BLIT_STRUCT+2), A
1788  5AB3 CD 79 5B     	CALL .DAdiv8
1789  5AB6 32 EA 52     	LD (BLIT_TMP+1),A
1790  5AB9              	; comma
1791  5AB9 CD 96 55     	CALL CHKCHAR
1792  5ABC 2C           	DB ','
1793  5ABD              	; get char data pointer
1794  5ABD DD 21 2F 54  	LD IX, FRMQNT
1795  5AC1 CD 59 01     	CALL CALBAS
1796  5AC4 ED 53 F7 52  	LD (BLIT_STRUCT+10), DE
1797  5AC8              	; comma
1798  5AC8 CD 96 55     	CALL CHKCHAR
1799  5ACB 2C           	DB ','
1800  5ACC              	; get mask data pointer
1801  5ACC DD 21 2F 54  	LD IX, FRMQNT
1802  5AD0 CD 59 01     	CALL CALBAS
1803  5AD3 ED 53 F5 52  	LD (BLIT_STRUCT+8), DE
1804  5AD7              	; comma
1805  5AD7 CD 96 55     	CALL CHKCHAR
1806  5ADA 2C           	DB ','
1807  5ADB              	; get width
1808  5ADB DD 21 2F 54  	LD IX, FRMQNT
1809  5ADF CD 59 01     	CALL CALBAS
1810  5AE2 7B           	LD A, E
1811  5AE3 32 FB 52     	LD (BLIT_STRUCT+14), A
1812  5AE6              	; comma
1813  5AE6 CD 96 55     	CALL CHKCHAR
1814  5AE9 2C           	DB ','
1815  5AEA              	; get height
1816  5AEA DD 21 2F 54  	LD IX, FRMQNT
1817  5AEE CD 59 01     	CALL CALBAS
1818  5AF1 7B           	LD A, E
1819  5AF2 32 FD 52     	LD (BLIT_STRUCT+16), A
1820  5AF5              	; comma
1821  5AF5 CD 96 55     	CALL CHKCHAR
1822  5AF8 2C           	DB ','
1823  5AF9              	; get background pointer
1824  5AF9 DD 21 2F 54  	LD IX, FRMQNT
1825  5AFD CD 59 01     	CALL CALBAS
1826  5B00 ED 53 F1 52  	LD (BLIT_STRUCT+4), DE
1827  5B04              	; comma
1828  5B04 CD 96 55     	CALL CHKCHAR
1829  5B07 2C           	DB ','
1830  5B08              	; get background width
1831  5B08 DD 21 2F 54  	LD IX, FRMQNT
1832  5B0C CD 59 01     	CALL CALBAS
1833  5B0F 7B           	LD A, E
1834  5B10 32 EB 52     	LD (BLIT_TMP+2), A
1835  5B13              	; comma
1836  5B13 CD 96 55     	CALL CHKCHAR
1837  5B16 2C           	DB ','
1838  5B17              	; get background height
1839  5B17 DD 21 2F 54  	LD IX, FRMQNT
1840  5B1B CD 59 01     	CALL CALBAS
1841  5B1E 7B           	LD A, E
1842  5B1F 32 EC 52     	LD (BLIT_TMP+3), A
1843  5B22              	; ending )
1844  5B22 CD 96 55     	CALL CHKCHAR
1845  5B25 29           	DB ')'
1846  5B26
1847  5B26 E5           	PUSH HL ; save position in BASIC buffer
1848  5B27
1849  5B27              	; calculate char&mask add to value
1850  5B27 26 00        	LD H, 0
1851  5B29 3A FB 52     	LD A, (BLIT_STRUCT+14)
1852  5B2C 6F           	LD L, A
1853  5B2D CD 85 54     	CALL HLx8
1854  5B30 22 F9 52     	LD (BLIT_STRUCT+12), HL
1855  5B33              	; calculate background add to value
1856  5B33 26 00        	LD H, 0
1857  5B35 3A EB 52     	LD A, (BLIT_TMP+2)
1858  5B38 6F           	LD L, A
1859  5B39 CD 85 54     	CALL HLx8
1860  5B3C 22 F3 52     	LD (BLIT_STRUCT+6), HL
1861  5B3F              	; calculate pointer to background location
1862  5B3F 21 00 00     	LD HL, 0
1863  5B42 3A EA 52     	LD A,(BLIT_TMP+1)
1864  5B45 B7           	OR A
1865  5B46 28 08        	JR Z, .L1
1866  5B48 47           	LD B,A
1867  5B49 ED 5B F3 52  	LD DE,(BLIT_STRUCT+6)
1868  5B4D              .L0:
1869  5B4D 19           	ADD HL, DE
1870  5B4E 10 FD        	DJNZ .L0
1871  5B50              .L1:
1872  5B50 EB           	EX DE,HL
1873  5B51 26 00        	LD H,0
1874  5B53 3A E9 52     	LD A,(BLIT_TMP+0)
1875  5B56 6F           	LD L,A
1876  5B57 CD 85 54     	CALL HLx8
1877  5B5A 19           	ADD HL,DE
1878  5B5B ED 5B F1 52  	LD DE,(BLIT_STRUCT+4)
1879  5B5F 19           	ADD HL,DE
1880  5B60 22 F1 52     	LD (BLIT_STRUCT+4),HL
1881  5B63
1882  5B63 FD 21 6A 5B  	LD IY, .RET
1883  5B67 C3 49 55     	JP ENABLE_PAGE0
1884  5B6A              .RET:
1885  5B6A FB           	EI
1886  5B6B DD 21 ED 52  	LD IX, BLIT_STRUCT
1887  5B6F CD F7 59     	CALL SHIFT_MERGE_CHARACTER
1888  5B72
1889  5B72 D1               POP DE
1890  5B73 C1               POP BC
1891  5B74 CD C0 54         CALL RESTORE_PAGE_INFO
1892  5B77
1893  5B77 E1           	POP HL
1894  5B78 C9           	RET
1895  5B79              .DAdiv8:
1896  5B79 7B           	LD A,E
1897  5B7A CB 2A        	SRA D
1898  5B7C CB 1F            RR  A
1899  5B7E CB 2A            SRA D
1900  5B80 CB 1F            RR  A
1901  5B82 CB 2A            SRA D
1902  5B84 CB 1F            RR  A
1903  5B86 C9           	RET
1904  5B87              ; *******************************************************************************************************
1905  5B87               ENDIF
1906  5B87               ENDIF
1907  5B87
1908  5B87               IF (TILE_CMDS == 1)
1909  5B87              ; *******************************************************************************************************
1910  5B87              ; generic function to implement tiling
1911  5B87              ; should be modified to call appropriate function for memory or vram
1912  5B87              ; input IX=pointer to following structure
1913  5B87              ; +00 tile_data_ptr
1914  5B87              ; +02 tile_rows
1915  5B87              ; +04 tile_columns
1916  5B87              ; +06 destination_address
1917  5B87              ; +08 dest_to_next_row_add_to_value
1918  5B87              ; +10 num_horizontal_tiles
1919  5B87              ; +12 num_vertical_tiles
1920  5B87              ; modifies AF, BC, DE, HL
1921  5B87              TILE:
1922  5B87 DD 6E 06     	LD L, (IX+6)
1923  5B8A DD 66 07     	LD H, (IX+7) ; destination address
1924  5B8D 22 E9 52     	LD (TILETMP1), HL
1925  5B90 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1926  5B93              .L1:
1927  5B93 C5           	PUSH BC
1928  5B94 DD 6E 00     		LD L, (IX+0)
1929  5B97 DD 66 01     		LD H, (IX+1) ; tile address
1930  5B9A 22 EB 52     		LD (TILETMP2), HL
1931  5B9D DD 46 02     		LD B, (IX+2) ; tile rows
1932  5BA0              .L2:
1933  5BA0 C5           		PUSH BC
1934  5BA1              .CALL1:
1935  5BA1 CD 00 00     			CALL 0
1936  5BA4 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1937  5BA7              .L3:
1938  5BA7 C5           			PUSH BC
1939  5BA8 2A EB 52     				LD HL, (TILETMP2)
1940  5BAB DD 46 04     				LD B, (IX+4) ; tile columns
1941  5BAE              .L4:
1942  5BAE C5           				PUSH BC
1943  5BAF              .CALL2:
1944  5BAF CD 00 00     					CALL 0
1945  5BB2 C1           				POP BC
1946  5BB3 10 F9        				DJNZ .L4
1947  5BB5 C1           			POP BC
1948  5BB6 10 EF        			DJNZ .L3
1949  5BB8 22 EB 52     			LD (TILETMP2), HL
1950  5BBB 2A E9 52     			LD HL, (TILETMP1)
1951  5BBE DD 5E 08     			LD E, (IX+8)
1952  5BC1 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1953  5BC4 19           			ADD HL, DE
1954  5BC5 22 E9 52     			LD (TILETMP1), HL
1955  5BC8 C1           		POP BC
1956  5BC9 10 D5        		DJNZ .L2
1957  5BCB C1           	POP BC
1958  5BCC 10 C5        	DJNZ .L1
1959  5BCE C9           	RET
1960  5BCF              ; *******************************************************************************************************
1961  5BCF
1962  5BCF               IFNDEF CMDS_WITH_PARAMETERS
1963  5BCF ~            ; *******************************************************************************************************
1964  5BCF ~            ; function to handle CALL TILERAM basic extension
1965  5BCF ~            ; fills memory with tiles
1966  5BCF ~            ; TILERAM ( INT request_data_ptr )
1967  5BCF ~            ; request_data_ptr described in TILE
1968  5BCF ~            ; will put ram in page 0 also, page 1 is already there
1969  5BCF ~            TILERAM:
1970  5BCF ~            	; opening (
1971  5BCF ~            	CALL CHKCHAR
1972  5BCF ~            	DB '('
1973  5BCF ~            	; get pointer to request struct
1974  5BCF ~            	LD IX, FRMQNT
1975  5BCF ~            	CALL CALBAS
1976  5BCF ~            	PUSH DE
1977  5BCF ~            	; ending )
1978  5BCF ~            	CALL CHKCHAR
1979  5BCF ~            	DB ')'
1980  5BCF ~
1981  5BCF ~            	POP IX ; pointer to request struct
1982  5BCF ~
1983  5BCF ~            	PUSH HL ; save position in BASIC buffer
1984  5BCF ~
1985  5BCF ~            	LD IY, .RET
1986  5BCF ~            	JP ENABLE_PAGE0
1987  5BCF ~            .RET:
1988  5BCF ~            	EI
1989  5BCF ~            	; set RAM functions to call
1990  5BCF ~            	LD HL, .TILECOPY
1991  5BCF ~            	LD (TILE.CALL2+1), HL
1992  5BCF ~            	LD HL, .SETDESTROW
1993  5BCF ~            	LD (TILE.CALL1+1), HL
1994  5BCF ~            	CALL TILE
1995  5BCF ~
1996  5BCF ~                POP DE
1997  5BCF ~                POP BC
1998  5BCF ~                CALL RESTORE_PAGE_INFO
1999  5BCF ~
2000  5BCF ~            	POP HL
2001  5BCF ~            	RET
2002  5BCF ~            .TILECOPY:
2003  5BCF ~            	.8 LDI
2004  5BCF ~            	RET
2005  5BCF ~            .SETDESTROW:
2006  5BCF ~            	LD DE, (TILETMP1)
2007  5BCF ~            	RET
2008  5BCF ~            ; *******************************************************************************************************
2009  5BCF               ENDIF
2010  5BCF
2011  5BCF               IFDEF CMDS_WITH_PARAMETERS
2012  5BCF              ; *******************************************************************************************************
2013  5BCF              ; function to handle CALL TILERAM basic extension
2014  5BCF              ; fills memory with tiles
2015  5BCF              ; TILERAM ( INT tile_data_pointer,
2016  5BCF              ;			INT tile_columns,
2017  5BCF              ;			INT tile_rows,
2018  5BCF              ;			INT destination_pointer,
2019  5BCF              ;			INT destination_columns,
2020  5BCF              ;			INT destination_rows,
2021  5BCF              ;			INT destination_begin_column,
2022  5BCF              ;			INT destination_begin_row,
2023  5BCF              ;			INT number_of_tiles_horizontally,
2024  5BCF              ;			INT	number_of_tiles_vertically )
2025  5BCF              ; will put ram in page 0 also, page 1 is already there
2026  5BCF              TILERAM:
2027  5BCF              	; opening (
2028  5BCF CD 96 55     	CALL CHKCHAR
2029  5BD2 28           	DB '('
2030  5BD3              	; get tile data pointer coordinate
2031  5BD3 DD 21 2F 54  	LD IX, FRMQNT
2032  5BD7 CD 59 01     	CALL CALBAS
2033  5BDA ED 53 ED 52  	LD (BLIT_STRUCT+0), DE
2034  5BDE              	; comma
2035  5BDE CD 96 55     	CALL CHKCHAR
2036  5BE1 2C           	DB ','
2037  5BE2              	; get tile columns
2038  5BE2 DD 21 2F 54  	LD IX, FRMQNT
2039  5BE6 CD 59 01     	CALL CALBAS
2040  5BE9 ED 53 F1 52  	LD (BLIT_STRUCT+4), DE
2041  5BED              	; comma
2042  5BED CD 96 55     	CALL CHKCHAR
2043  5BF0 2C           	DB ','
2044  5BF1              	; get tile columns
2045  5BF1 DD 21 2F 54  	LD IX, FRMQNT
2046  5BF5 CD 59 01     	CALL CALBAS
2047  5BF8 ED 53 EF 52  	LD (BLIT_STRUCT+2), DE
2048  5BFC              	; comma
2049  5BFC CD 96 55     	CALL CHKCHAR
2050  5BFF 2C           	DB ','
2051  5C00              	; get destintion pointer
2052  5C00 DD 21 2F 54  	LD IX, FRMQNT
2053  5C04 CD 59 01     	CALL CALBAS
2054  5C07 ED 53 F3 52  	LD (BLIT_STRUCT+6), DE
2055  5C0B              	; comma
2056  5C0B CD 96 55     	CALL CHKCHAR
2057  5C0E 2C           	DB ','
2058  5C0F              	; get destination columns
2059  5C0F DD 21 2F 54  	LD IX, FRMQNT
2060  5C13 CD 59 01     	CALL CALBAS
2061  5C16 7B           	LD A, E
2062  5C17 32 E9 52     	LD (BLIT_TMP+0), A
2063  5C1A              	; comma
2064  5C1A CD 96 55     	CALL CHKCHAR
2065  5C1D 2C           	DB ','
2066  5C1E              	; get destination rows
2067  5C1E DD 21 2F 54  	LD IX, FRMQNT
2068  5C22 CD 59 01     	CALL CALBAS
2069  5C25 7B           	LD A, E
2070  5C26 32 EA 52     	LD (BLIT_TMP+1), A
2071  5C29              	; comma
2072  5C29 CD 96 55     	CALL CHKCHAR
2073  5C2C 2C           	DB ','
2074  5C2D              	; get destination begin column
2075  5C2D DD 21 2F 54  	LD IX, FRMQNT
2076  5C31 CD 59 01     	CALL CALBAS
2077  5C34 7B           	LD A, E
2078  5C35 32 EB 52     	LD (BLIT_TMP+2), A
2079  5C38              	; comma
2080  5C38 CD 96 55     	CALL CHKCHAR
2081  5C3B 2C           	DB ','
2082  5C3C              	; get destination begin row
2083  5C3C DD 21 2F 54  	LD IX, FRMQNT
2084  5C40 CD 59 01     	CALL CALBAS
2085  5C43 7B           	LD A, E
2086  5C44 32 EC 52     	LD (BLIT_TMP+3), A
2087  5C47              	; comma
2088  5C47 CD 96 55     	CALL CHKCHAR
2089  5C4A 2C           	DB ','
2090  5C4B              	; get number of tiles horizontally
2091  5C4B DD 21 2F 54  	LD IX, FRMQNT
2092  5C4F CD 59 01     	CALL CALBAS
2093  5C52 ED 53 F7 52  	LD (BLIT_STRUCT+10), DE
2094  5C56              	; comma
2095  5C56 CD 96 55     	CALL CHKCHAR
2096  5C59 2C           	DB ','
2097  5C5A              	; get number of tiles vertically
2098  5C5A DD 21 2F 54  	LD IX, FRMQNT
2099  5C5E CD 59 01     	CALL CALBAS
2100  5C61 ED 53 F9 52  	LD (BLIT_STRUCT+12), DE
2101  5C65              	; ending )
2102  5C65 CD 96 55     	CALL CHKCHAR
2103  5C68 29           	DB ')'
2104  5C69
2105  5C69 E5           	PUSH HL ; save position in BASIC buffer
2106  5C6A
2107  5C6A              	; calculate destination add to value
2108  5C6A 26 00        	LD H, 0
2109  5C6C 3A E9 52     	LD A, (BLIT_TMP+0)
2110  5C6F 6F           	LD L, A
2111  5C70 CD 85 54     	CALL HLx8
2112  5C73 22 F5 52     	LD (BLIT_STRUCT+8), HL
2113  5C76              	; calculate pointer to background location
2114  5C76 21 00 00     	LD HL, 0
2115  5C79 3A EC 52     	LD A,(BLIT_TMP+3)
2116  5C7C B7           	OR A
2117  5C7D 28 08        	JR Z, .L1
2118  5C7F 47           	LD B,A
2119  5C80 ED 5B F5 52  	LD DE,(BLIT_STRUCT+8)
2120  5C84              .L0:
2121  5C84 19           	ADD HL, DE
2122  5C85 10 FD        	DJNZ .L0
2123  5C87              .L1:
2124  5C87 EB           	EX DE,HL
2125  5C88 26 00        	LD H,0
2126  5C8A 3A EB 52     	LD A,(BLIT_TMP+2)
2127  5C8D 6F           	LD L,A
2128  5C8E CD 85 54     	CALL HLx8
2129  5C91 19           	ADD HL,DE
2130  5C92 ED 5B F3 52  	LD DE,(BLIT_STRUCT+6)
2131  5C96 19           	ADD HL,DE
2132  5C97 22 F3 52     	LD (BLIT_STRUCT+6),HL
2133  5C9A
2134  5C9A FD 21 A1 5C  	LD IY, .RET
2135  5C9E C3 49 55     	JP ENABLE_PAGE0
2136  5CA1              .RET:
2137  5CA1 FB           	EI
2138  5CA2              	; set RAM functions to call
2139  5CA2 21 BC 5C     	LD HL, .TILECOPY
2140  5CA5 22 B0 5B     	LD (TILE.CALL2+1), HL
2141  5CA8 21 CD 5C     	LD HL, .SETDESTROW
2142  5CAB 22 A2 5B     	LD (TILE.CALL1+1), HL
2143  5CAE DD 21 ED 52  	LD IX,BLIT_STRUCT
2144  5CB2 CD 87 5B     	CALL TILE
2145  5CB5
2146  5CB5 D1               POP DE
2147  5CB6 C1               POP BC
2148  5CB7 CD C0 54         CALL RESTORE_PAGE_INFO
2149  5CBA
2150  5CBA E1           	POP HL
2151  5CBB C9           	RET
2152  5CBC              .TILECOPY:
2153  5CBC ED A0       > LDI
2153  5CBE ED A0       > LDI
2153  5CC0 ED A0       > LDI
2153  5CC2 ED A0       > LDI
2153  5CC4 ED A0       > LDI
2153  5CC6 ED A0       > LDI
2153  5CC8 ED A0       > LDI
2153  5CCA ED A0       > LDI
2154  5CCC C9           	RET
2155  5CCD              .SETDESTROW:
2156  5CCD ED 5B E9 52  	LD DE, (TILETMP1)
2157  5CD1 C9           	RET
2158  5CD2              ; *******************************************************************************************************
2159  5CD2               ENDIF
2160  5CD2
2161  5CD2               IFDEF CMDS_WITH_PARAMETERS
2162  5CD2              ; *******************************************************************************************************
2163  5CD2              ; function to handle CALL TILEVRM basic extension
2164  5CD2              ; fills vram with tiles
2165  5CD2              ; TILEVRM ( INT tile_data_pointer,
2166  5CD2              ;			INT tile_columns,
2167  5CD2              ;			INT tile_rows,
2168  5CD2              ;			INT destination_begin_column,
2169  5CD2              ;			INT destination_begin_row,
2170  5CD2              ;			INT number_of_tiles_horizontally,
2171  5CD2              ;			INT	number_of_tiles_vertically )
2172  5CD2              ; will put ram in page 0 also, page 1 is already there
2173  5CD2              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2174  5CD2              TILEVRM:
2175  5CD2              	; opening (
2176  5CD2 CD 96 55     	CALL CHKCHAR
2177  5CD5 28           	DB '('
2178  5CD6              	; get tile data pointer coordinate
2179  5CD6 DD 21 2F 54  	LD IX, FRMQNT
2180  5CDA CD 59 01     	CALL CALBAS
2181  5CDD ED 53 ED 52  	LD (BLIT_STRUCT+0), DE
2182  5CE1              	; comma
2183  5CE1 CD 96 55     	CALL CHKCHAR
2184  5CE4 2C           	DB ','
2185  5CE5              	; get tile columns
2186  5CE5 DD 21 2F 54  	LD IX, FRMQNT
2187  5CE9 CD 59 01     	CALL CALBAS
2188  5CEC ED 53 F1 52  	LD (BLIT_STRUCT+4), DE
2189  5CF0              	; comma
2190  5CF0 CD 96 55     	CALL CHKCHAR
2191  5CF3 2C           	DB ','
2192  5CF4              	; get tile columns
2193  5CF4 DD 21 2F 54  	LD IX, FRMQNT
2194  5CF8 CD 59 01     	CALL CALBAS
2195  5CFB ED 53 EF 52  	LD (BLIT_STRUCT+2), DE
2196  5CFF              	; comma
2197  5CFF CD 96 55     	CALL CHKCHAR
2198  5D02 2C           	DB ','
2199  5D03              	; get destination begin column
2200  5D03 DD 21 2F 54  	LD IX, FRMQNT
2201  5D07 CD 59 01     	CALL CALBAS
2202  5D0A 7B           	LD A, E
2203  5D0B 32 EB 52     	LD (BLIT_TMP+2), A
2204  5D0E              	; comma
2205  5D0E CD 96 55     	CALL CHKCHAR
2206  5D11 2C           	DB ','
2207  5D12              	; get destination begin row
2208  5D12 DD 21 2F 54  	LD IX, FRMQNT
2209  5D16 CD 59 01     	CALL CALBAS
2210  5D19 7B           	LD A, E
2211  5D1A 32 EC 52     	LD (BLIT_TMP+3), A
2212  5D1D              	; comma
2213  5D1D CD 96 55     	CALL CHKCHAR
2214  5D20 2C           	DB ','
2215  5D21              	; get number of tiles horizontally
2216  5D21 DD 21 2F 54  	LD IX, FRMQNT
2217  5D25 CD 59 01     	CALL CALBAS
2218  5D28 ED 53 F7 52  	LD (BLIT_STRUCT+10), DE
2219  5D2C              	; comma
2220  5D2C CD 96 55     	CALL CHKCHAR
2221  5D2F 2C           	DB ','
2222  5D30              	; get number of tiles vertically
2223  5D30 DD 21 2F 54  	LD IX, FRMQNT
2224  5D34 CD 59 01     	CALL CALBAS
2225  5D37 ED 53 F9 52  	LD (BLIT_STRUCT+12), DE
2226  5D3B              	; ending )
2227  5D3B CD 96 55     	CALL CHKCHAR
2228  5D3E 29           	DB ')'
2229  5D3F
2230  5D3F E5           	PUSH HL ; save position in BASIC buffer
2231  5D40
2232  5D40              	; calculate destination add to value
2233  5D40 21 00 01     	LD HL, 256
2234  5D43 22 F5 52     	LD (BLIT_STRUCT+8), HL
2235  5D46              	; calculate pointer to background location
2236  5D46 3A EC 52     	LD A,(BLIT_TMP+3)
2237  5D49 67           	LD H,A
2238  5D4A 2E 00        	LD L,0
2239  5D4C EB           	EX DE,HL
2240  5D4D 26 00        	LD H,0
2241  5D4F 3A EB 52     	LD A,(BLIT_TMP+2)
2242  5D52 6F           	LD L,A
2243  5D53 CD 85 54     	CALL HLx8
2244  5D56 19           	ADD HL,DE
2245  5D57 ED 5B CB F3  	LD DE,(GRPCGP)
2246  5D5B 19           	ADD HL,DE
2247  5D5C 22 F3 52     	LD (BLIT_STRUCT+6),HL
2248  5D5F
2249  5D5F FD 21 66 5D  	LD IY, .RET
2250  5D63 C3 49 55     	JP ENABLE_PAGE0
2251  5D66              .RET:
2252  5D66 FB           	EI
2253  5D67              	; set RAM functions to call
2254  5D67 21 81 5D     	LD HL, .TILECOPY
2255  5D6A 22 B0 5B     	LD (TILE.CALL2+1), HL
2256  5D6D 21 87 5D     	LD HL, .SETDESTROW
2257  5D70 22 A2 5B     	LD (TILE.CALL1+1), HL
2258  5D73 DD 21 ED 52  	LD IX,BLIT_STRUCT
2259  5D77 CD 87 5B     	CALL TILE
2260  5D7A
2261  5D7A D1               POP DE
2262  5D7B C1               POP BC
2263  5D7C CD C0 54         CALL RESTORE_PAGE_INFO
2264  5D7F
2265  5D7F E1           	POP HL
2266  5D80 C9           	RET
2267  5D81              .TILECOPY:
2268  5D81 01 98 08     	LD BC, #0898
2269  5D84 C3 7D 54     	JP BBYTECOPY
2270  5D87              .SETDESTROW:
2271  5D87 2A E9 52     	LD HL, (TILETMP1)
2272  5D8A F3           	DI
2273  5D8B CD 72 54     	CALL SETWRT_LOCAL
2274  5D8E FB           	EI
2275  5D8F C9           	RET
2276  5D90              ; *******************************************************************************************************
2277  5D90               ENDIF
2278  5D90
2279  5D90               IFNDEF CMDS_WITH_PARAMETERS
2280  5D90 ~            ; *******************************************************************************************************
2281  5D90 ~            ; function to handle CALL TILEVRM basic extension
2282  5D90 ~            ; fills vram with tiles
2283  5D90 ~            ; TILEVRM ( INT request_data_ptr )
2284  5D90 ~            ; request_data_ptr described in TILE
2285  5D90 ~            ; will put ram in page 0 also, page 1 is already there
2286  5D90 ~            TILEVRM:
2287  5D90 ~            	; opening (
2288  5D90 ~            	CALL CHKCHAR
2289  5D90 ~            	DB '('
2290  5D90 ~            	; get pointer to request struct
2291  5D90 ~            	LD IX, FRMQNT
2292  5D90 ~            	CALL CALBAS
2293  5D90 ~            	PUSH DE
2294  5D90 ~            	; ending )
2295  5D90 ~            	CALL CHKCHAR
2296  5D90 ~            	DB ')'
2297  5D90 ~
2298  5D90 ~            	POP IX ; pointer to request struct
2299  5D90 ~
2300  5D90 ~            	PUSH HL ; save position in BASIC buffer
2301  5D90 ~
2302  5D90 ~            	LD IY, .RET
2303  5D90 ~            	JP ENABLE_PAGE0
2304  5D90 ~            .RET:
2305  5D90 ~            	EI
2306  5D90 ~            	; set RAM functions to call
2307  5D90 ~            	LD HL, .TILECOPY
2308  5D90 ~            	LD (TILE.CALL2+1), HL
2309  5D90 ~            	LD HL, .SETDESTROW
2310  5D90 ~            	LD (TILE.CALL1+1), HL
2311  5D90 ~            	CALL TILE
2312  5D90 ~
2313  5D90 ~                POP DE
2314  5D90 ~                POP BC
2315  5D90 ~                CALL RESTORE_PAGE_INFO
2316  5D90 ~
2317  5D90 ~            	POP HL
2318  5D90 ~            	RET
2319  5D90 ~            .TILECOPY:
2320  5D90 ~            	LD BC, #0898
2321  5D90 ~            	JP BBYTECOPY
2322  5D90 ~            .SETDESTROW:
2323  5D90 ~            	LD HL, (TILETMP1)
2324  5D90 ~            	DI
2325  5D90 ~            	CALL SETWRT_LOCAL
2326  5D90 ~            	EI
2327  5D90 ~            	RET
2328  5D90 ~            ; *******************************************************************************************************
2329  5D90               ENDIF
2330  5D90               ENDIF
2331  5D90
2332  5D90               IF (BOX_CMDS == 1)
2333  5D90              ; *******************************************************************************************************
2334  5D90              ; generic function to implement rectangle data copy
2335  5D90              ; should be modified to call appropriate function for memory or vram
2336  5D90              ; input IX=pointer to following structure
2337  5D90              ; +00 source data pointer
2338  5D90              ; +02 num bytes in a row
2339  5D90              ; +04 number of rows
2340  5D90              ; +06 source add-to value till next row
2341  5D90              ; +08 destination address
2342  5D90              ; +10 destination add-to value till next row
2343  5D90              ; modifies AF, BC, DE, HL
2344  5D90              RECTANGLE_COPY:
2345  5D90 DD 6E 00     	LD L, (IX+0)
2346  5D93 DD 66 01     	LD H, (IX+1) ; source address
2347  5D96 DD 5E 08     	LD E, (IX+8)
2348  5D99 DD 56 09     	LD D, (IX+9) ; destination
2349  5D9C DD 46 04     	LD B, (IX+4) ; row number
2350  5D9F              .L1:
2351  5D9F C5           	PUSH BC
2352  5DA0 E5           		PUSH HL
2353  5DA1 D5           			PUSH DE
2354  5DA2 DD 4E 02     				LD C, (IX+2)
2355  5DA5 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2356  5DA8              .CALL1:
2357  5DA8 CD 00 00     				CALL 0 ; set destination address from DE
2358  5DAB              .CALL2:
2359  5DAB CD 00 00     				CALL 0 ; copy data fn
2360  5DAE E1           			POP HL
2361  5DAF DD 4E 0A     			LD C, (IX+10)
2362  5DB2 DD 46 0B     			LD B, (IX+11) ; destination add-to
2363  5DB5 09           			ADD HL, BC
2364  5DB6 EB           			EX DE, HL
2365  5DB7 E1           		POP HL
2366  5DB8 DD 4E 06     		LD C, (IX+6)
2367  5DBB DD 46 07     		LD B, (IX+7) ; src add-to
2368  5DBE 09           		ADD HL, BC
2369  5DBF C1           	POP BC
2370  5DC0 10 DD        	DJNZ .L1
2371  5DC2 C9           	RET
2372  5DC3              ; *******************************************************************************************************
2373  5DC3
2374  5DC3              ; *******************************************************************************************************
2375  5DC3              ; function to handle CALL BOXMEMCPY basic extension
2376  5DC3              ; copies data with window like boundaries to ram
2377  5DC3              ; BOXMEMCPY ( INT request_data_ptr )
2378  5DC3              ; request_data_ptr described in RECTANGLE_COPY
2379  5DC3              ; will put ram in page 0 also, page 1 is already there
2380  5DC3              BOXMEMCPY:
2381  5DC3              	; opening (
2382  5DC3 CD 96 55     	CALL CHKCHAR
2383  5DC6 28           	DB '('
2384  5DC7              	; get pointer to request struct
2385  5DC7 DD 21 2F 54  	LD IX, FRMQNT
2386  5DCB CD 59 01     	CALL CALBAS
2387  5DCE D5           	PUSH DE
2388  5DCF              	; ending )
2389  5DCF CD 96 55     	CALL CHKCHAR
2390  5DD2 29           	DB ')'
2391  5DD3
2392  5DD3 DD E1        	POP IX ; pointer to request struct
2393  5DD5
2394  5DD5 E5           	PUSH HL ; save position in BASIC buffer
2395  5DD6
2396  5DD6 FD 21 DD 5D  	LD IY, .RET
2397  5DDA C3 49 55     	JP ENABLE_PAGE0
2398  5DDD              .RET:
2399  5DDD FB           	EI
2400  5DDE              	; set RAM functions to call
2401  5DDE 21 00 00     	LD HL, 0
2402  5DE1 22 A8 5D     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2403  5DE4 22 AA 5D     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2404  5DE7 21 ED B0     	LD HL, #B0ED ; LDIR
2405  5DEA 22 AC 5D     	LD (RECTANGLE_COPY.CALL1+4), HL
2406  5DED CD 90 5D     	CALL RECTANGLE_COPY
2407  5DF0
2408  5DF0 D1               POP DE
2409  5DF1 C1               POP BC
2410  5DF2 CD C0 54         CALL RESTORE_PAGE_INFO
2411  5DF5
2412  5DF5 E1           	POP HL
2413  5DF6 C9           	RET
2414  5DF7              ; *******************************************************************************************************
2415  5DF7
2416  5DF7              ; *******************************************************************************************************
2417  5DF7              ; function to handle CALL BOXMEMVRM basic extension
2418  5DF7              ; copies data with window like boundaries to ram
2419  5DF7              ; BOXMEMVRM ( INT request_data_ptr )
2420  5DF7              ; request_data_ptr described in RECTANGLE_COPY
2421  5DF7              ; will put ram in page 0 also, page 1 is already there
2422  5DF7              BOXMEMVRM:
2423  5DF7              	; opening (
2424  5DF7 CD 96 55     	CALL CHKCHAR
2425  5DFA 28           	DB '('
2426  5DFB              	; get pointer to request struct
2427  5DFB DD 21 2F 54  	LD IX, FRMQNT
2428  5DFF CD 59 01     	CALL CALBAS
2429  5E02 D5           	PUSH DE
2430  5E03              	; ending )
2431  5E03 CD 96 55     	CALL CHKCHAR
2432  5E06 29           	DB ')'
2433  5E07
2434  5E07 DD E1        	POP IX ; pointer to request struct
2435  5E09
2436  5E09 E5           	PUSH HL ; save position in BASIC buffer
2437  5E0A
2438  5E0A FD 21 11 5E  	LD IY, .RET
2439  5E0E C3 49 55     	JP ENABLE_PAGE0
2440  5E11              .RET:
2441  5E11 FB           	EI
2442  5E12              	; set RAM functions to call
2443  5E12 21 30 5E     	LD HL, .SETDEST
2444  5E15 22 A9 5D     	LD (RECTANGLE_COPY.CALL1+1), HL
2445  5E18 21 38 5E     	LD HL, .COPYDATA
2446  5E1B 22 AC 5D     	LD (RECTANGLE_COPY.CALL2+1), HL
2447  5E1E 3E CD        	LD A, #CD ; CALL
2448  5E20 32 A8 5D     	LD (RECTANGLE_COPY.CALL1), A
2449  5E23 32 AB 5D     	LD (RECTANGLE_COPY.CALL2), A
2450  5E26 CD 90 5D     	CALL RECTANGLE_COPY
2451  5E29
2452  5E29 D1               POP DE
2453  5E2A C1               POP BC
2454  5E2B CD C0 54         CALL RESTORE_PAGE_INFO
2455  5E2E
2456  5E2E E1           	POP HL
2457  5E2F C9           	RET
2458  5E30              .SETDEST:
2459  5E30 EB           	EX DE, HL
2460  5E31 F3           	DI
2461  5E32 CD 72 54     	CALL SETWRT_LOCAL
2462  5E35 FB           	EI
2463  5E36 EB           	EX DE, HL
2464  5E37 C9           	RET
2465  5E38              .COPYDATA:
2466  5E38 41           	LD B, C
2467  5E39 0E 98        	LD C, #98
2468  5E3B C3 7D 54     	JP BBYTECOPY
2469  5E3E              ; *******************************************************************************************************
2470  5E3E               ENDIF
2471  5E3E
2472  5E3E              EXT_END:
2473  5E3E
# file closed: asm\main.asm
