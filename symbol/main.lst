# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000               DEFINE CMDS_WITH_PARAMETERS
  16  4000
  17  4000              CHPUT   EQU    #A2
  18  4000              CALBAS  EQU		#159
  19  4000              ERRHAND EQU    #406F
  20  4000              FRMEVL  EQU    #4C64
  21  4000              FRESTR  EQU		#67D0
  22  4000              ; FRMQNT = formula quantificator
  23  4000              ; input HL=pointer to current program expression
  24  4000              ; output HL=next address
  25  4000              ; output DE=integer datum
  26  4000              FRMQNT	EQU		#542F
  27  4000              ; GETBYT = get byte parameter
  28  4000              ; input HL=pointer to current program expression
  29  4000              ; output HL=next address
  30  4000              ; output A=E=byte read
  31  4000              GETBYT		EQU	#521C
  32  4000              CHRGTR  	   EQU   #4666
  33  4000              PTRGET		EQU 	#5EA4
  34  4000              SUBFLG		EQU	#F6A5
  35  4000              SYNCHR		EQU	#558C
  36  4000              VALTYP  	   EQU   #F663
  37  4000              DAC         EQU   #F7F6
  38  4000              USR     	   EQU   #F7F8
  39  4000              PROCNM		EQU	#FD89
  40  4000              BIOS_FILVRM EQU   #0056
  41  4000              CLIKSW		EQU	#F3DB
  42  4000
  43  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	   EQU   #FCC1
  48  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  49  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  50  4000              JIFFY	      EQU   #FC9E
  51  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  52  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  53  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  54  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  55  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  56  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  57  4000
  58  4000              ; BASIC error codes
  59  4000              ;01 NEXT without FOR
  60  4000              ;02 Syntax error
  61  4000              ;03 RETURN without GOSUB
  62  4000              ;04 Out of DATA
  63  4000              ;05 Illegal function call
  64  4000              ;06 Overflow
  65  4000              ;07 Out of memory
  66  4000              ;08 Undefined line number
  67  4000              ;09 Subscript out of range
  68  4000              ;10 Redimensioned array
  69  4000              ;11 Division by zero
  70  4000              ;12 Illegal direct
  71  4000              ;13 Type mismatch
  72  4000              ;14 Out of string space
  73  4000              ;15 String too long
  74  4000              ;16 String formula too complex
  75  4000              ;17 Can't CONTINUE
  76  4000              ;18 Undefined user function
  77  4000              ;19 Device I/O error
  78  4000              ;20 Verify error
  79  4000              ;21 No RESUME
  80  4000              ;22 RESUME without error
  81  4000              ;23 Unprintable error
  82  4000              ;24 Missing operand
  83  4000              ;25 Line buffer overflow
  84  4000              ;50 FIELD overflow
  85  4000              ;51 Internal error
  86  4000              ;52 Bad file number
  87  4000              ;53 File not found
  88  4000              ;54 File already open
  89  4000              ;55 Input past end
  90  4000              ;56 Bad file name
  91  4000              ;57 Direct statement in file
  92  4000              ;58 Sequential I/O only
  93  4000              ;59 File not OPEN
  94  4000
  95  4000
  96  4000               ; simulate cartridge with BASIC extension
  97  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  97  4004 88 65 00 00
  97  4008 00 00 00 00
  97  400C 00 00 00 00
  98  4010
  99  4010              ; this location #4010 stores last location used by basic extension
 100  4010              ; free memory after that point
 101  4010              FREEMEMPTR:
 102  4010 28 66         DW EXT_END
 103  4012
 104  4012              ; this location #4012 stores extension version in DAA format
 105  4012              ; first byte is major version and second minor
 106  4012              VERSION:
 107  4012 00 80         DB #00, #80
 108  4014
 109  4014              ; binary included AKG player compiled at #4014
 110  4014               IF (SOUND_CMDS == 1)
 111  4014              	INCBIN "bin/AKG.bin"
 112  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 113  4CF0               ENDIF
 114  4CF0
 115  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 20 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A 3A 59     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13                  ;LD HL,(JIFFY)
  43+ 4D13                  ;INC HL
  44+ 4D13                  ;LD (JIFFY),HL
  45+ 4D13
  46+ 4D13 FD E1            POP IY
  47+ 4D15 DD E1            POP IX
  48+ 4D17 E1               POP HL
  49+ 4D18 D1               POP DE
  50+ 4D19 C1               POP BC
  51+ 4D1A F1               POP AF
  52+ 4D1B 08               EX AF, AF'
  53+ 4D1C D9               EXX
  54+ 4D1D E1               POP HL
  55+ 4D1E D1               POP DE
  56+ 4D1F C1               POP BC
  57+ 4D20               ENDIF
  58+ 4D20
  59+ 4D20              .EXIT:
  60+ 4D20 F1           	POP AF
  61+ 4D21 FB           	EI
  62+ 4D22 ED 4D        	RETI
  63+ 4D24              ; *******************************************************************************************************
  64+ 4D24
  65+ 4D24              ; *******************************************************************************************************
  66+ 4D24              ; H.TIMI function
  67+ 4D24              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D24              MBGE_HTIMI:
  69+ 4D24               EXPORT MBGE_HTIMI
  70+ 4D24
  71+ 4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D24
  73+ 4D24 F5           	PUSH AF
  74+ 4D25
  75+ 4D25              	; enable page 2
  76+ 4D25 3E 02            LD A, 2
  77+ 4D27 CD B8 64         CALL GET_PAGE_INFO
  78+ 4D2A C5               PUSH BC
  79+ 4D2B D5               PUSH DE
  80+ 4D2C 3A 43 F3         LD A, (RAMAD2)
  81+ 4D2F 26 80            LD H, 080H
  82+ 4D31 CD FF 64         CALL LOCAL_ENASLT
  83+ 4D34              	; enable page 0
  84+ 4D34 AF               XOR A
  85+ 4D35 CD B8 64         CALL GET_PAGE_INFO
  86+ 4D38 C5               PUSH BC
  87+ 4D39 D5               PUSH DE
  88+ 4D3A 3A 41 F3         LD A, (RAMAD0)
  89+ 4D3D 26 00            LD H, 0
  90+ 4D3F CD FF 64         CALL LOCAL_ENASLT
  91+ 4D42
  92+ 4D42               IF (SPRITE_CMDS == 1)
  93+ 4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D45               ENDIF
  95+ 4D45
  96+ 4D45               IF (SOUND_CMDS == 1)
  97+ 4D45 3A 3A 59     	LD A, (SOUND_ENABLED)
  98+ 4D48 B7           	OR A
  99+ 4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4C               ENDIF
 101+ 4D4C
 102+ 4D4C              	; restore page 0
 103+ 4D4C D1               POP DE
 104+ 4D4D C1               POP BC
 105+ 4D4E CD EF 64         CALL RESTORE_PAGE_INFO
 106+ 4D51              	; restore page 2
 107+ 4D51 D1               POP DE
 108+ 4D52 C1               POP BC
 109+ 4D53 CD EF 64         CALL RESTORE_PAGE_INFO
 110+ 4D56
 111+ 4D56 F1           	POP AF
 112+ 4D57               ENDIF
 113+ 4D57 C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D5A              ; *******************************************************************************************************
 115+ 4D5A
 116+ 4D5A              ; *******************************************************************************************************
 117+ 4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5A              ; also checks if some VRAM modifying command is running
 119+ 4D5A              ; when that checks out calls sprite updates and animation processing
 120+ 4D5A              ; if in an unsupported mode disables sprite handling
 121+ 4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5A              	; check if initialized
 123+ 4D5A 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D5D B7           	OR A
 125+ 4D5E C8           	RET Z
 126+ 4D5F              	; check screen mode
 127+ 4D5F 3A AF FC     	LD A, (SCRMOD)
 128+ 4D62 3D           	DEC A
 129+ 4D63 28 08        	JR Z, .L0 ; screen 1
 130+ 4D65 3D           	DEC A
 131+ 4D66 28 05            JR Z, .L0 ; screen 2
 132+ 4D68              	; unsupported screen mode, disable
 133+ 4D68 AF               XOR A
 134+ 4D69 32 7C 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6C C9               RET
 136+ 4D6D              .L0:
 137+ 4D6D                  ; check if anyone else is working with VRAM
 138+ 4D6D 3A C9 62         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D70 B7               OR A
 140+ 4D71 C0               RET NZ
 141+ 4D72
 142+ 4D72 CD 91 4D         CALL SPRATR_UPDATE
 143+ 4D75
 144+ 4D75               IF (ANIM_CMDS == 1)
 145+ 4D75 CD DC 55         CALL PROCESS_ANIMATIONS
 146+ 4D78 CD A8 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7B               ENDIF
 148+ 4D7B C9               RET
 149+ 4D7C              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 116  4D7C
 117  4D7C               IF (SPRITE_CMDS == 1)
 118  4D7C               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7C              ; commands and variables related to sprites
   2+ 4D7C
   3+ 4D7C              SPRATR_INIT_STATUS:
   4+ 4D7C 00            DB 0
   5+ 4D7D              SPRATR_UPDATE_FLAG:
   6+ 4D7D 00 00         DW 0
   7+ 4D7F              SPRATR_DATA:
   8+ 4D7F 00 00         DW 0
   9+ 4D81              SPRFLICKER_ENABLED:
  10+ 4D81 00            DB 0
  11+ 4D82              ; to support sprite flicker
  12+ 4D82              FLICKER:
  13+ 4D82 00            DB 0
  14+ 4D83
  15+ 4D83              ; to temporarily store stack pointer
  16+ 4D83              TMPSP:
  17+ 4D83 00 00         DW 0
  18+ 4D85
  19+ 4D85              ; *******************************************************************************************************
  20+ 4D85              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D85              ; changes HL,DE
  22+ 4D85              GETnthSPRATTR:
  23+ 4D85 26 00            LD H,0
  24+ 4D87 6F               LD L,A
  25+ 4D88 CD B4 64         CALL HLx8
  26+ 4D8B ED 5B 7F 4D      LD DE,(SPRATR_DATA)
  27+ 4D8F 19               ADD HL,DE
  28+ 4D90 C9               RET
  29+ 4D91              ; *******************************************************************************************************
  30+ 4D91
  31+ 4D91              ; *******************************************************************************************************
  32+ 4D91              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D91              ; struct {
  34+ 4D91              ; DW y
  35+ 4D91              ; DW x
  36+ 4D91              ; DW pattern (0-63)
  37+ 4D91              ; DW color
  38+ 4D91              ; } [32]
  39+ 4D91              ; will hide sprites whose location is outside of visible area
  40+ 4D91              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D91              ; modifies AF, AF', BC, DE, HL
  42+ 4D91              SPRATR_UPDATE:
  43+ 4D91              	; check if update requested
  44+ 4D91 2A 7D 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D94 7E           	LD A, (HL)
  46+ 4D95 B7           	OR A
  47+ 4D96 C8           	RET Z
  48+ 4D97              .L0:
  49+ 4D97 06 20        	LD B, 32 ; sprite number
  50+ 4D99 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D9B              	; set VDP address
  52+ 4D9B 3A AF FC         LD A,(SCRMOD)
  53+ 4D9E 3D               DEC A
  54+ 4D9F 20 05            JR NZ,.L4
  55+ 4DA1 2A C3 F3         LD HL, (T32ATR)
  56+ 4DA4 18 03            JR .L5
  57+ 4DA6              .L4:
  58+ 4DA6 2A CD F3         LD HL, (GRPATR)
  59+ 4DA9              .L5:
  60+ 4DA9 3A 81 4D     	LD A, (SPRFLICKER_ENABLED)
  61+ 4DAC B7           	OR A
  62+ 4DAD 28 03        	JR Z, .L3
  63+ 4DAF 3A 82 4D     	LD A, (FLICKER)
  64+ 4DB2              .L3:
  65+ 4DB2 5F           	LD E, A
  66+ 4DB3 08           	EX AF, AF'
  67+ 4DB4 7B           	LD A, E
  68+ 4DB5 87           	ADD A, A
  69+ 4DB6 87           	ADD A, A
  70+ 4DB7 16 00        	LD D, 0
  71+ 4DB9 5F           	LD E, A
  72+ 4DBA 19           	ADD HL, DE
  73+ 4DBB CD 9F 64     	CALL SETWRT_LOCAL
  74+ 4DBE ED 73 83 4D  	LD (TMPSP), SP
  75+ 4DC2 ED 7B 7F 4D  	LD SP, (SPRATR_DATA)
  76+ 4DC6
  77+ 4DC6              .LOOP:
  78+ 4DC6 E1           	POP HL
  79+ 4DC7 24           	INC H
  80+ 4DC8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  81+ 4DCA 25           	DEC H
  82+ 4DCB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  83+ 4DCD 7D           	LD A, L
  84+ 4DCE FE C0        	CP 192
  85+ 4DD0 30 10        	JR NC, .OUT3
  86+ 4DD2 3D           	DEC A ; due to VDP rule that top of screen is -1
  87+ 4DD3 57           	LD D, A
  88+ 4DD4 C3 FB 4D     	JP .X
  89+ 4DD7              .L1:
  90+ 4DD7 7D           	LD A, L
  91+ 4DD8 C6 10        	ADD 16
  92+ 4DDA FA E2 4D     	JP M, .OUT3 ; below -16
  93+ 4DDD 2D           	DEC L ; due to VDP rule that top of screen is -1
  94+ 4DDE 55           	LD D, L
  95+ 4DDF C3 FB 4D     	JP .X
  96+ 4DE2              .OUT3:
  97+ 4DE2 E1           	POP HL ; skip x value
  98+ 4DE3              .OUT2:
  99+ 4DE3 E1           	POP HL ; skip pattern
 100+ 4DE4 E1           	POP HL ; skip color
 101+ 4DE5 3E D1        	LD A, #D1
 102+ 4DE7 ED 79        	OUT (C), A ; sprite hidden
 103+ 4DE9 00          > NOP
 103+ 4DEA 00          > NOP
 103+ 4DEB 00          > NOP
 104+ 4DEC ED 79        	OUT (C), A ; value unimportant
 105+ 4DEE 00          > NOP
 105+ 4DEF 00          > NOP
 105+ 4DF0 00          > NOP
 106+ 4DF1 ED 79        	OUT (C), A ; value unimportant
 107+ 4DF3 00          > NOP
 107+ 4DF4 00          > NOP
 107+ 4DF5 00          > NOP
 108+ 4DF6 ED 79        	OUT (C), A ; value unimportant
 109+ 4DF8 C3 26 4E     	JP .NEXT
 110+ 4DFB              .X:
 111+ 4DFB E1           	POP HL
 112+ 4DFC 24           	INC H
 113+ 4DFD 28 08        	JR Z, .L2
 114+ 4DFF 25           	DEC H
 115+ 4E00 20 E1        	JR NZ, .OUT2
 116+ 4E02 1E 00        	LD E, 0 ; EC bit
 117+ 4E04 C3 10 4E     	JP .XY
 118+ 4E07              .L2:
 119+ 4E07 7D           	LD A, L
 120+ 4E08 C6 20        	ADD 32
 121+ 4E0A FA E3 4D     	JP M, .OUT2
 122+ 4E0D 6F           	LD L, A
 123+ 4E0E 1E 80        	LD E, #80
 124+ 4E10              .XY:
 125+ 4E10 ED 51        	OUT (C), D
 126+ 4E12 3A E0 F3     	LD A, (REG1SAV)
 127+ 4E15 E6 02        	AND 2
 128+ 4E17 ED 69        	OUT (C), L
 129+ 4E19 E1           	POP HL ; pattern
 130+ 4E1A 7D           	LD A, L
 131+ 4E1B 28 02        	JR Z, .SMALLSPRITES
 132+ 4E1D 87           	ADD A, A
 133+ 4E1E 87           	ADD A, A ; needs to go at 4x
 134+ 4E1F              .SMALLSPRITES:
 135+ 4E1F D3 98        	OUT (#98), A
 136+ 4E21 E1           	POP HL ; color
 137+ 4E22 7D           	LD A, L
 138+ 4E23 B3           	OR E
 139+ 4E24 D3 98        	OUT (#98), A
 140+ 4E26              .NEXT:
 141+ 4E26 08           	EX AF, AF'
 142+ 4E27 3C           	INC A
 143+ 4E28 E6 1F        	AND 31
 144+ 4E2A C2 49 4E     	JP NZ, .NEXT2
 145+ 4E2D 08           	EX AF, AF'
 146+ 4E2E 3A AF FC         LD A,(SCRMOD)
 147+ 4E31 3D               DEC A
 148+ 4E32 20 05            JR NZ,.L6
 149+ 4E34 2A C3 F3         LD HL, (T32ATR)
 150+ 4E37 18 03            JR .L7
 151+ 4E39              .L6:
 152+ 4E39 2A CD F3         LD HL, (GRPATR)
 153+ 4E3C              .L7:
 154+ 4E3C              	; CALL SETWRT_LOCAL not allowed as SP modified
 155+ 4E3C 7D           	LD	A, L
 156+ 4E3D D3 99        	OUT	(099H), A
 157+ 4E3F 7C           	LD	A, H
 158+ 4E40 E6 3F        	AND	03FH
 159+ 4E42 F6 40        	OR	040H
 160+ 4E44 D3 99        	OUT	(099H), A
 161+ 4E46 C3 4A 4E     	JP .NEXT3
 162+ 4E49              .NEXT2:
 163+ 4E49 08           	EX AF, AF'
 164+ 4E4A              .NEXT3:
 165+ 4E4A 05           	DEC B
 166+ 4E4B C2 C6 4D     	JP NZ, .LOOP
 167+ 4E4E 08           	EX AF, AF'
 168+ 4E4F 3C           	INC A
 169+ 4E50 32 82 4D     	LD (FLICKER), A
 170+ 4E53
 171+ 4E53 ED 7B 83 4D  	LD SP, (TMPSP)
 172+ 4E57 2A 7D 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 173+ 4E5A 36 00        	LD (HL), 0 ; zero out update flag
 174+ 4E5C C9           	RET
 175+ 4E5D              ; *******************************************************************************************************
 176+ 4E5D
 177+ 4E5D              ; *******************************************************************************************************
 178+ 4E5D              ; function to handle CALL SPRENABLE basic extension
 179+ 4E5D              ; initializes sprites handler
 180+ 4E5D              ; _SPRENABLE ( INT[][] sprites_attributes,
 181+ 4E5D              ;			   INT update_variable,
 182+ 4E5D              ;			   BYTE sprite_flicker_enabled )
 183+ 4E5D              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 184+ 4E5D              SPRENABLE:
 185+ 4E5D              	; opening (
 186+ 4E5D CD C6 65     	CALL CHKCHAR
 187+ 4E60 28           	DB '('
 188+ 4E61              	; get address of sprite attribute table DIM SA%(3,31)
 189+ 4E61 3E 02        	LD A,2
 190+ 4E63 06 02        	LD B,2
 191+ 4E65 11 20 04     	LD DE,#0420
 192+ 4E68 CD F3 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 193+ 4E6B C5           	PUSH BC
 194+ 4E6C              	; comma
 195+ 4E6C CD C6 65     	CALL CHKCHAR
 196+ 4E6F 2C           	DB ','
 197+ 4E70              	; get address of sprite update flag
 198+ 4E70 DD 21 A4 5E  	LD IX, PTRGET
 199+ 4E74 CD 59 01     	CALL CALBAS
 200+ 4E77 D5           	PUSH DE
 201+ 4E78              	; comma
 202+ 4E78 CD C6 65     	CALL CHKCHAR
 203+ 4E7B 2C           	DB ','
 204+ 4E7C              	; get flicker enabled flag
 205+ 4E7C DD 21 1C 52  	LD IX, GETBYT
 206+ 4E80 CD 59 01     	CALL CALBAS
 207+ 4E83 F5           	PUSH AF
 208+ 4E84              	; ending )
 209+ 4E84 CD C6 65     	CALL CHKCHAR
 210+ 4E87 29           	DB ')'
 211+ 4E88
 212+ 4E88 F1           	POP AF ; get flicker flag
 213+ 4E89 B7           	OR A
 214+ 4E8A 32 81 4D     	LD (SPRFLICKER_ENABLED), A
 215+ 4E8D
 216+ 4E8D D1           	POP DE ; update variable location
 217+ 4E8E ED 53 7D 4D  	LD (SPRATR_UPDATE_FLAG), DE
 218+ 4E92 D1           	POP DE ; address of sprite attribute table
 219+ 4E93 ED 53 7F 4D  	LD (SPRATR_DATA), DE
 220+ 4E97 3E 01        	LD A, 1
 221+ 4E99 32 7C 4D     	LD (SPRATR_INIT_STATUS), A
 222+ 4E9C C9           	RET
 223+ 4E9D              ; *******************************************************************************************************
 224+ 4E9D
 225+ 4E9D              ; *******************************************************************************************************
 226+ 4E9D              ; function to handle CALL SPRDISABLE basic extension
 227+ 4E9D              ; disables sprites handling
 228+ 4E9D              ; _SPRDISABLE
 229+ 4E9D              ; resets variable SPRATR_INIT_STATUS
 230+ 4E9D              SPRDISABLE:
 231+ 4E9D AF           	XOR A
 232+ 4E9E 32 7C 4D     	LD (SPRATR_INIT_STATUS), A
 233+ 4EA1 C9           	RET
 234+ 4EA2              ; *******************************************************************************************************
 235+ 4EA2
 236+ 4EA2              ; *******************************************************************************************************
 237+ 4EA2              ; function to handle CALL SPRSET basic extension
 238+ 4EA2              ; sets position, and optionally pattern and color of sprite
 239+ 4EA2              ; _SPRSET ( BYTE sprite_num , valid 0-31
 240+ 4EA2              ;			INT x,
 241+ 4EA2              ;			INT y,
 242+ 4EA2              ;			INT pattern, valid 0-63, otherwise ignored
 243+ 4EA2              ;			INT color, valid 0-15, otherwise ignored
 244+ 4EA2              SPRSET:
 245+ 4EA2 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 246+ 4EA5 B7           	OR A
 247+ 4EA6 20 05        	JR NZ, .L1
 248+ 4EA8 1E 05        	LD E, 5 ; illegal function call
 249+ 4EAA C3 EC 65     	JP THROW_ERROR
 250+ 4EAD              .L1:
 251+ 4EAD              	; opening (
 252+ 4EAD CD C6 65     	CALL CHKCHAR
 253+ 4EB0 28           	DB '('
 254+ 4EB1              	; get sprite number
 255+ 4EB1 DD 21 1C 52  	LD IX, GETBYT
 256+ 4EB5 CD 59 01     	CALL CALBAS
 257+ 4EB8 F5           	PUSH AF
 258+ 4EB9              	; comma
 259+ 4EB9 CD C6 65     	CALL CHKCHAR
 260+ 4EBC 2C           	DB ','
 261+ 4EBD              	; get x
 262+ 4EBD DD 21 2F 54  	LD IX, FRMQNT
 263+ 4EC1 CD 59 01     	CALL CALBAS
 264+ 4EC4 D5           	PUSH DE
 265+ 4EC5              	; comma
 266+ 4EC5 CD C6 65     	CALL CHKCHAR
 267+ 4EC8 2C           	DB ','
 268+ 4EC9              	; get y
 269+ 4EC9 DD 21 2F 54  	LD IX, FRMQNT
 270+ 4ECD CD 59 01     	CALL CALBAS
 271+ 4ED0 D5           	PUSH DE
 272+ 4ED1              	; comma
 273+ 4ED1 CD C6 65     	CALL CHKCHAR
 274+ 4ED4 2C           	DB ','
 275+ 4ED5              	; get pattern
 276+ 4ED5 DD 21 2F 54  	LD IX, FRMQNT
 277+ 4ED9 CD 59 01     	CALL CALBAS
 278+ 4EDC D5           	PUSH DE
 279+ 4EDD              	; comma
 280+ 4EDD CD C6 65     	CALL CHKCHAR
 281+ 4EE0 2C           	DB ','
 282+ 4EE1              	; get color
 283+ 4EE1 DD 21 2F 54  	LD IX, FRMQNT
 284+ 4EE5 CD 59 01     	CALL CALBAS
 285+ 4EE8 D5           	PUSH DE
 286+ 4EE9              	; ending )
 287+ 4EE9 CD C6 65     	CALL CHKCHAR
 288+ 4EEC 29           	DB ')'
 289+ 4EED
 290+ 4EED                  ; save position in BASIC text
 291+ 4EED E5           	PUSH HL
 292+ 4EEE DD E1        	POP IX
 293+ 4EF0
 294+ 4EF0 C1           	POP BC ; color
 295+ 4EF1 D1           	POP DE ; pattern
 296+ 4EF2 D9           	EXX
 297+ 4EF3 C1           	POP BC ; y
 298+ 4EF4 D1           	POP DE ; x
 299+ 4EF5 F1           	POP AF ; sprite number
 300+ 4EF6 FE 20        	CP 32
 301+ 4EF8 38 05        	JR C, .L2
 302+ 4EFA 1E 05        	LD E, 5 ; illegal function call
 303+ 4EFC C3 EC 65     	JP THROW_ERROR
 304+ 4EFF              .L2:
 305+ 4EFF              	; find location in sprite attributes table
 306+ 4EFF D5           	PUSH DE
 307+ 4F00 CD 85 4D     	CALL GETnthSPRATTR
 308+ 4F03 D1           	POP DE
 309+ 4F04 F3           	DI
 310+ 4F05              	; set y
 311+ 4F05 71           	LD (HL), C
 312+ 4F06 23           	INC HL
 313+ 4F07 70           	LD (HL), B
 314+ 4F08 23           	INC HL
 315+ 4F09              	; set x
 316+ 4F09 73           	LD (HL), E
 317+ 4F0A 23           	INC HL
 318+ 4F0B 72           	LD (HL), D
 319+ 4F0C 23           	INC HL
 320+ 4F0D E5           	PUSH HL
 321+ 4F0E D9           	EXX
 322+ 4F0F E1           	POP HL
 323+ 4F10              	; check if 0<=pattern<64
 324+ 4F10 7A           	LD A, D
 325+ 4F11 B7           	OR A
 326+ 4F12 20 0B        	JR NZ, .L3
 327+ 4F14 7B           	LD A, E
 328+ 4F15 FE 40        	CP 64
 329+ 4F17 30 06        	JR NC, .L3
 330+ 4F19              	; set pattern
 331+ 4F19              	;ADD A, A
 332+ 4F19              	;ADD A, A
 333+ 4F19              	;ADD A, A
 334+ 4F19 77           	LD (HL), A
 335+ 4F1A 23           	INC HL
 336+ 4F1B 72           	LD (HL), D
 337+ 4F1C 23           	INC HL
 338+ 4F1D 18 02        	JR .L4
 339+ 4F1F              .L3:
 340+ 4F1F              	; skip pattern
 341+ 4F1F 23          > INC HL
 341+ 4F20 23          > INC HL
 342+ 4F21              .L4:
 343+ 4F21              	; check if 0<=color<16
 344+ 4F21 78           	LD A, B
 345+ 4F22 B7           	OR A
 346+ 4F23 20 08        	JR NZ, .L5
 347+ 4F25 79           	LD A, C
 348+ 4F26 FE 10        	CP 16
 349+ 4F28 30 03        	JR NC, .L5
 350+ 4F2A              	; set color
 351+ 4F2A 71           	LD (HL), C
 352+ 4F2B 23           	INC HL
 353+ 4F2C 70           	LD (HL), B
 354+ 4F2D
 355+ 4F2D              .L5:
 356+ 4F2D FB           	EI
 357+ 4F2E DD E5        	PUSH IX
 358+ 4F30 E1           	POP HL
 359+ 4F31 C9           	RET
 360+ 4F32              ; *******************************************************************************************************
 361+ 4F32
 362+ 4F32              ; *******************************************************************************************************
 363+ 4F32              ; function sets sprite location based on initial coordinates and offset provided
 364+ 4F32              ; input A=sprite number in SPRATR_DATA , 0-31
 365+ 4F32              ; input DE=initial x
 366+ 4F32              ; input BC=initial y
 367+ 4F32              ; input IY=location where delta y,x are located
 368+ 4F32              ; modifies AF, HL, IX
 369+ 4F32              SPRSET_DELTA_POS:
 370+ 4F32 D5           	PUSH DE
 371+ 4F33 CD 85 4D     	CALL GETnthSPRATTR
 372+ 4F36 E5           	PUSH HL
 373+ 4F37 DD E1        	POP IX
 374+ 4F39 D1           	POP DE
 375+ 4F3A              	; IX=sprite's y location
 376+ 4F3A FD 6E 00     	LD L, (IY)
 377+ 4F3D FD 66 01     	LD H, (IY+1)
 378+ 4F40 09           	ADD HL, BC
 379+ 4F41 DD 75 00     	LD (IX), L
 380+ 4F44 DD 74 01     	LD (IX+1), H
 381+ 4F47 FD 6E 02     	LD L, (IY+2)
 382+ 4F4A FD 66 03     	LD H, (IY+3)
 383+ 4F4D 19           	ADD HL, DE
 384+ 4F4E DD 75 02     	LD (IX+2), L
 385+ 4F51 DD 74 03     	LD (IX+3), H
 386+ 4F54 C9           	RET
 387+ 4F55              ; *******************************************************************************************************
 388+ 4F55
 389+ 4F55              ; *******************************************************************************************************
 390+ 4F55              ; function to handle CALL SPRGRPMOV basic extension
 391+ 4F55              ; sets position of a group of sprites described with
 392+ 4F55              ; { int sprite_num, int delta_y, int delta_x } [count]
 393+ 4F55              ; _SPRGRPMOV ( INT x,
 394+ 4F55              ;			   INT y,
 395+ 4F55              ;			   BYTE count,
 396+ 4F55              ;			   INT[2][count] data_ptr
 397+ 4F55              SPRGRPMOV:
 398+ 4F55 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 399+ 4F58 B7           	OR A
 400+ 4F59 CA E6 65     	JP Z,ILLEGAL_FUNCTION
 401+ 4F5C              	; opening (
 402+ 4F5C CD C6 65     	CALL CHKCHAR
 403+ 4F5F 28           	DB '('
 404+ 4F60              	; get x
 405+ 4F60 DD 21 2F 54  	LD IX, FRMQNT
 406+ 4F64 CD 59 01     	CALL CALBAS
 407+ 4F67 ED 53 B8 62  	LD (BLIT_STRUCT),DE
 408+ 4F6B              	; comma
 409+ 4F6B CD C6 65     	CALL CHKCHAR
 410+ 4F6E 2C           	DB ','
 411+ 4F6F              	; get y
 412+ 4F6F DD 21 2F 54  	LD IX, FRMQNT
 413+ 4F73 CD 59 01     	CALL CALBAS
 414+ 4F76 ED 53 BA 62  	LD (BLIT_STRUCT+2),DE
 415+ 4F7A              	; comma
 416+ 4F7A CD C6 65     	CALL CHKCHAR
 417+ 4F7D 2C           	DB ','
 418+ 4F7E              	; get count
 419+ 4F7E DD 21 1C 52  	LD IX, GETBYT
 420+ 4F82 CD 59 01     	CALL CALBAS
 421+ 4F85 32 BC 62     	LD (BLIT_STRUCT+4),A
 422+ 4F88              	; comma
 423+ 4F88 CD C6 65     	CALL CHKCHAR
 424+ 4F8B 2C           	DB ','
 425+ 4F8C              	; get sprite group definition array data pointer
 426+ 4F8C 3A BC 62     	LD A,(BLIT_STRUCT+4)
 427+ 4F8F 5F           	LD E,A
 428+ 4F90 16 03        	LD D,3
 429+ 4F92 3E 02        	LD A,2
 430+ 4F94 47           	LD B,A
 431+ 4F95 CD F3 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 432+ 4F98 ED 43 BD 62  	LD (BLIT_STRUCT+5),BC
 433+ 4F9C              	; ending )
 434+ 4F9C CD C6 65     	CALL CHKCHAR
 435+ 4F9F 29           	DB ')'
 436+ 4FA0
 437+ 4FA0 E5           	PUSH HL
 438+ 4FA1
 439+ 4FA1 D9               EXX
 440+ 4FA2 ED 5B B8 62      LD DE,(BLIT_STRUCT) ; initial x
 441+ 4FA6 ED 4B BA 62      LD BC,(BLIT_STRUCT+2) ; initial y
 442+ 4FAA D9               EXX
 443+ 4FAB 2A BD 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 444+ 4FAE 3A BC 62         LD A,(BLIT_STRUCT+4) ; number of entries
 445+ 4FB1 47               LD B,A
 446+ 4FB2 3E 01        	LD A,1
 447+ 4FB4 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4FB7 F3           	DI
 449+ 4FB8 CD C2 4F     	CALL .UPDATE_LOC
 450+ 4FBB FB           	EI
 451+ 4FBC AF           	XOR A
 452+ 4FBD 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 453+ 4FC0
 454+ 4FC0 E1           	POP HL
 455+ 4FC1 C9           	RET
 456+ 4FC2
 457+ 4FC2              .UPDATE_LOC:
 458+ 4FC2 7E           	LD A, (HL)
 459+ 4FC3 23           	INC HL
 460+ 4FC4 23           	INC HL
 461+ 4FC5 E5           	PUSH HL
 462+ 4FC6 FD E1        	POP IY
 463+ 4FC8 D9           	EXX
 464+ 4FC9 CD 32 4F     	CALL SPRSET_DELTA_POS
 465+ 4FCC D9           	EXX
 466+ 4FCD 23          > INC HL
 466+ 4FCE 23          > INC HL
 466+ 4FCF 23          > INC HL
 466+ 4FD0 23          > INC HL
 467+ 4FD1 10 EF        	DJNZ .UPDATE_LOC
 468+ 4FD3 C9           	RET
 469+ 4FD4              ; *******************************************************************************************************
 470+ 4FD4
# file closed: asm\SPRITES.asm
 119  4FD4               ENDIF
 120  4FD4
 121  4FD4               IF (ANIM_CMDS == 1)
 122  4FD4               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4FD4              ; sprite animation routines
   2+ 4FD4
   3+ 4FD4              ; number of animation items and pointer
   4+ 4FD4              ANIMITEMNUM:
   5+ 4FD4 00            DB 0
   6+ 4FD5              ANIMITEMPTR:
   7+ 4FD5 28 66         DW EXT_END
   8+ 4FD7              ; number of animation definitions and pointer
   9+ 4FD7              ANIMDEFNUM:
  10+ 4FD7 00            DB 0
  11+ 4FD8              ANIMDEFPTR:
  12+ 4FD8 28 66         DW EXT_END
  13+ 4FDA              ; number of links between sprite and animation definitions
  14+ 4FDA              ANIMSPRNUM:
  15+ 4FDA 00            DB 0
  16+ 4FDB              ANIMSPRPTR:
  17+ 4FDB 28 66         DW EXT_END
  18+ 4FDD              ; number of automatic sprite group move and animate structures
  19+ 4FDD              AUTOSGAMNUM:
  20+ 4FDD 00            DB 0
  21+ 4FDE              AUTOSGAMPTR:
  22+ 4FDE 28 66         DW EXT_END
  23+ 4FE0
  24+ 4FE0              ; ANIMATION ITEM
  25+ 4FE0              ; byte type = [0 - pattern and color change
  26+ 4FE0              ;              1 - pattern definition change ]
  27+ 4FE0              ; word ticks - number of ticks to hold this state
  28+ 4FE0              ; for type = 0
  29+ 4FE0              ;   byte pattern;
  30+ 4FE0              ;   byte color;
  31+ 4FE0              ; for type = 1
  32+ 4FE0              ;   work data_pointer;
  33+ 4FE0              ; total size = 5b
  34+ 4FE0
  35+ 4FE0              ; ANIMATION DEFINITION
  36+ 4FE0              ; byte number of items 1-15
  37+ 4FE0              ; byte[15] anim_item;
  38+ 4FE0              ; total size = 16b
  39+ 4FE0
  40+ 4FE0              ; SPRITE/CHAR ANIMATION
  41+ 4FE0              ; +00 byte sprite/char number;
  42+ 4FE0              ; +01 word time;
  43+ 4FE0              ; +03 byte current item;
  44+ 4FE0              ; +04 byte animation definition;
  45+ 4FE0              ; +05 byte cyclic;
  46+ 4FE0              ; +06 byte active;
  47+ 4FE0              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4FE0              ; total size = 8b
  49+ 4FE0
  50+ 4FE0              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4FE0              ; +00 pointer to X variable
  52+ 4FE0              ; +02 pointer to Y variable
  53+ 4FE0              ; +04 minimum value
  54+ 4FE0              ; +06 maximal value
  55+ 4FE0              ; +08 delta value
  56+ 4FE0              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4FE0              ; +11 sprite group size
  58+ 4FE0              ; +12 sprite group pointer
  59+ 4FE0              ; +14 animation list size
  60+ 4FE0              ; +15 animation list pointer for negative delta values
  61+ 4FE0              ; +17 animation list pointer for positive delta values
  62+ 4FE0              ; +19 active flag
  63+ 4FE0              ; +20 ticks for movement
  64+ 4FE0              ; +22 timer
  65+ 4FE0              ; total = 24b
  66+ 4FE0
  67+ 4FE0              ; *******************************************************************************************************
  68+ 4FE0              ; helper function HL=A*5
  69+ 4FE0              ; changes HL,DE
  70+ 4FE0              Ax5:
  71+ 4FE0 26 00            LD H,0
  72+ 4FE2 6F               LD L,A
  73+ 4FE3 54               LD D,H
  74+ 4FE4 5D               LD E,L
  75+ 4FE5 29               ADD HL,HL
  76+ 4FE6 29               ADD HL,HL
  77+ 4FE7 19               ADD HL,DE
  78+ 4FE8 C9               RET
  79+ 4FE9              ; *******************************************************************************************************
  80+ 4FE9
  81+ 4FE9              ; *******************************************************************************************************
  82+ 4FE9              ; helper function gets pointer to n-th animation item
  83+ 4FE9              ; changes HL,DE
  84+ 4FE9              GETnthANIMITEM:
  85+ 4FE9 CD E0 4F         CALL Ax5
  86+ 4FEC ED 5B D5 4F      LD DE,(ANIMITEMPTR)
  87+ 4FF0 19               ADD HL,DE
  88+ 4FF1 C9               RET
  89+ 4FF2              ; *******************************************************************************************************
  90+ 4FF2
  91+ 4FF2              ; *******************************************************************************************************
  92+ 4FF2              ; helper function gets pointer to n-th entry in animation definition
  93+ 4FF2              ; changes HL,DE
  94+ 4FF2              GETnthANIMDEF:
  95+ 4FF2 26 00            LD H,0
  96+ 4FF4 6F               LD L,A
  97+ 4FF5 CD B3 64         CALL HLx16
  98+ 4FF8 ED 5B D8 4F      LD DE,(ANIMDEFPTR)
  99+ 4FFC 19               ADD HL,DE
 100+ 4FFD C9               RET
 101+ 4FFE              ; *******************************************************************************************************
 102+ 4FFE
 103+ 4FFE              ; *******************************************************************************************************
 104+ 4FFE              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4FFE              ; changes HL,DE
 106+ 4FFE              GETnthSPRANIM:
 107+ 4FFE 26 00            LD H,0
 108+ 5000 6F               LD L,A
 109+ 5001 CD B4 64         CALL HLx8
 110+ 5004 ED 5B DB 4F      LD DE,(ANIMSPRPTR)
 111+ 5008 19               ADD HL,DE
 112+ 5009 C9               RET
 113+ 500A              ; *******************************************************************************************************
 114+ 500A
 115+ 500A              ; *******************************************************************************************************
 116+ 500A              ; helper function gets pointer to n-th entry in autosgam table
 117+ 500A              ; changes HL,DE
 118+ 500A              GETnthAUTOSGAM:
 119+ 500A 26 00            LD H,0
 120+ 500C 6F               LD L,A
 121+ 500D CD B4 64         CALL HLx8
 122+ 5010 54               LD D,H
 123+ 5011 5D               LD E,L
 124+ 5012 29               ADD HL,HL
 125+ 5013 19               ADD HL,DE
 126+ 5014 ED 5B DE 4F      LD DE,(AUTOSGAMPTR)
 127+ 5018 19               ADD HL,DE
 128+ 5019 C9               RET
 129+ 501A              ; *******************************************************************************************************
 130+ 501A
 131+ 501A              ; *******************************************************************************************************
 132+ 501A              ; function to handle CALL MAXANIMITEMS basic extension
 133+ 501A              ; MAXANIMITEMS (BYTE number)
 134+ 501A              ; sets new number and moves memory buffers as needed
 135+ 501A              MAXANIMITEMS:
 136+ 501A              	; opening (
 137+ 501A CD C6 65     	CALL CHKCHAR
 138+ 501D 28           	DB '('
 139+ 501E              	; get value
 140+ 501E DD 21 1C 52  	LD IX, GETBYT
 141+ 5022 CD 59 01     	CALL CALBAS
 142+ 5025 F5               PUSH AF
 143+ 5026              	; ending )
 144+ 5026 CD C6 65     	CALL CHKCHAR
 145+ 5029 29           	DB ')'
 146+ 502A F1               POP AF
 147+ 502B F3               DI
 148+ 502C              	; save position
 149+ 502C E5           	PUSH HL
 150+ 502D              .ENTRY:
 151+ 502D 47               LD B,A
 152+ 502E 3A D4 4F         LD A,(ANIMITEMNUM)
 153+ 5031 90               SUB B
 154+ 5032 28 28            JR Z, .EXIT; same value as before
 155+ 5034 FD 21 D8 4F      LD IY,ANIMDEFPTR
 156+ 5038 FA 5F 50         JP M, .INCREASE
 157+ 503B                  ; new value is lower than previous one
 158+ 503B CD 7E 50         CALL .SIZEDIFF
 159+ 503E CD 99 50         CALL .DECREASE_COMMON
 160+ 5041 2A DB 4F         LD HL,(ANIMSPRPTR)
 161+ 5044 AF               XOR A
 162+ 5045 ED 42            SBC HL,BC
 163+ 5047 22 DB 4F         LD (ANIMSPRPTR),HL
 164+ 504A              .E1:
 165+ 504A 2A DE 4F         LD HL,(AUTOSGAMPTR)
 166+ 504D AF               XOR A
 167+ 504E ED 42            SBC HL,BC
 168+ 5050 22 DE 4F         LD (AUTOSGAMPTR),HL
 169+ 5053              .E3:
 170+ 5053 2A 10 40         LD HL,(FREEMEMPTR)
 171+ 5056 AF               XOR A
 172+ 5057 ED 42            SBC HL,BC
 173+ 5059 22 10 40         LD (FREEMEMPTR),HL
 174+ 505C              .EXIT:
 175+ 505C FB               EI
 176+ 505D E1           	POP HL
 177+ 505E C9           	RET
 178+ 505F              .INCREASE:
 179+ 505F ED 44            NEG
 180+ 5061 CD 7E 50         CALL .SIZEDIFF
 181+ 5064 CD C5 50         CALL .INCREASE_COMMON
 182+ 5067 2A DB 4F         LD HL,(ANIMSPRPTR)
 183+ 506A 09               ADD HL,BC
 184+ 506B 22 DB 4F         LD (ANIMSPRPTR),HL
 185+ 506E              .E2:
 186+ 506E 2A DE 4F         LD HL,(AUTOSGAMPTR)
 187+ 5071 09               ADD HL,BC
 188+ 5072 22 DE 4F         LD (AUTOSGAMPTR),HL
 189+ 5075              .E4:
 190+ 5075 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 5078 09               ADD HL,BC
 192+ 5079 22 10 40         LD (FREEMEMPTR),HL
 193+ 507C 18 DE            JR .EXIT
 194+ 507E              .SIZEDIFF:
 195+ 507E CD E0 4F         CALL Ax5
 196+ 5081 78               LD A,B
 197+ 5082 32 D4 4F         LD (ANIMITEMNUM),A
 198+ 5085 44               LD B,H
 199+ 5086 4D               LD C,L
 200+ 5087 C9               RET ; BC=size difference in bytes
 201+ 5088              .SIZETOMOVE:
 202+ 5088 D5               PUSH DE
 203+ 5089 2A 10 40         LD HL,(FREEMEMPTR)
 204+ 508C FD 5E 00         LD E,(IY)
 205+ 508F FD 56 01         LD D,(IY+1)
 206+ 5092 AF               XOR A
 207+ 5093 ED 52            SBC HL,DE
 208+ 5095 44               LD B,H
 209+ 5096 4D               LD C,L
 210+ 5097 D1               POP DE
 211+ 5098 C9               RET
 212+ 5099              .DECREASE_COMMON:
 213+ 5099 FD 6E 00         LD L,(IY)
 214+ 509C FD 66 01         LD H,(IY+1)
 215+ 509F AF               XOR A
 216+ 50A0 ED 42            SBC HL,BC
 217+ 50A2 EB               EX DE,HL
 218+ 50A3 C5               PUSH BC
 219+ 50A4 CD 88 50         CALL .SIZETOMOVE
 220+ 50A7 F3               DI
 221+ 50A8 78               LD A,B
 222+ 50A9 B1               OR C
 223+ 50AA 28 08            JR Z,.L1
 224+ 50AC FD 6E 00         LD L,(IY)
 225+ 50AF FD 66 01         LD H,(IY+1)
 226+ 50B2 ED B0            LDIR
 227+ 50B4              .L1:
 228+ 50B4 C1               POP BC
 229+ 50B5 FD 6E 00         LD L,(IY)
 230+ 50B8 FD 66 01         LD H,(IY+1)
 231+ 50BB AF               XOR A
 232+ 50BC ED 42            SBC HL,BC
 233+ 50BE FD 75 00         LD (IY),L
 234+ 50C1 FD 74 01         LD (IY+1),H
 235+ 50C4 C9               RET
 236+ 50C5              .INCREASE_COMMON:
 237+ 50C5 2A 10 40         LD HL,(FREEMEMPTR)
 238+ 50C8 2B               DEC HL
 239+ 50C9 AF               XOR A
 240+ 50CA ED 42            SBC HL,BC
 241+ 50CC EB               EX DE,HL
 242+ 50CD C5               PUSH BC
 243+ 50CE CD 88 50         CALL .SIZETOMOVE
 244+ 50D1 F3               DI
 245+ 50D2 78               LD A,B
 246+ 50D3 B1               OR C
 247+ 50D4 28 06            JR Z,.L2
 248+ 50D6 2A 10 40         LD HL,(FREEMEMPTR)
 249+ 50D9 2B               DEC HL
 250+ 50DA ED B8            LDDR
 251+ 50DC              .L2:
 252+ 50DC C1               POP BC
 253+ 50DD FD 6E 00         LD L,(IY)
 254+ 50E0 FD 66 01         LD H,(IY+1)
 255+ 50E3 09               ADD HL,BC
 256+ 50E4 FD 75 00         LD (IY),L
 257+ 50E7 FD 74 01         LD (IY+1),H
 258+ 50EA C9               RET
 259+ 50EB              ; *******************************************************************************************************
 260+ 50EB
 261+ 50EB              ; *******************************************************************************************************
 262+ 50EB              ; function to handle CALL ANIMITEMPAT basic extension
 263+ 50EB              ; ANIMITEMPAT ( BYTE id,
 264+ 50EB              ;               INT ticks >0,
 265+ 50EB              ;               BYTE pattern,
 266+ 50EB              ;               BYTE color )
 267+ 50EB              ; fills animation item data, returns an error if ID out of bounds
 268+ 50EB              ANIMITEMPAT:
 269+ 50EB                  ; opening (
 270+ 50EB CD C6 65     	CALL CHKCHAR
 271+ 50EE 28           	DB '('
 272+ 50EF              	; get id
 273+ 50EF DD 21 1C 52  	LD IX, GETBYT
 274+ 50F3 CD 59 01     	CALL CALBAS
 275+ 50F6 F5               PUSH AF
 276+ 50F7                  ; check if out of bounds
 277+ 50F7 3C               INC A
 278+ 50F8 4F               LD C,A
 279+ 50F9 3A D4 4F         LD A,(ANIMITEMNUM)
 280+ 50FC B9               CP C
 281+ 50FD DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 282+ 5100              	; comma
 283+ 5100 CD C6 65     	CALL CHKCHAR
 284+ 5103 2C           	DB ','
 285+ 5104              	; get ticks
 286+ 5104 DD 21 2F 54  	LD IX, FRMQNT
 287+ 5108 CD 59 01     	CALL CALBAS
 288+ 510B 7A               LD A,D
 289+ 510C B3               OR E
 290+ 510D CA E2 65         JP Z, OVERFLOW
 291+ 5110 D5           	PUSH DE
 292+ 5111              	; comma
 293+ 5111 CD C6 65     	CALL CHKCHAR
 294+ 5114 2C           	DB ','
 295+ 5115              	; get pattern
 296+ 5115 DD 21 1C 52  	LD IX, GETBYT
 297+ 5119 CD 59 01     	CALL CALBAS
 298+ 511C F5               PUSH AF
 299+ 511D              	; comma
 300+ 511D CD C6 65     	CALL CHKCHAR
 301+ 5120 2C           	DB ','
 302+ 5121              	; get color
 303+ 5121 DD 21 1C 52  	LD IX, GETBYT
 304+ 5125 CD 59 01     	CALL CALBAS
 305+ 5128 F5               PUSH AF
 306+ 5129              	; ending )
 307+ 5129 CD C6 65     	CALL CHKCHAR
 308+ 512C 29           	DB ')'
 309+ 512D              .ENTRY:
 310+ 512D E5               PUSH HL
 311+ 512E DD E1            POP IX
 312+ 5130 D9               EXX
 313+ 5131 C1               POP BC ; color
 314+ 5132 D1               POP DE ; pattern
 315+ 5133 E1               POP HL ; ticks
 316+ 5134 D9               EXX
 317+ 5135 F1               POP AF
 318+ 5136 CD E9 4F         CALL GETnthANIMITEM
 319+ 5139 E5               PUSH HL
 320+ 513A FD E1            POP IY
 321+ 513C D9               EXX
 322+ 513D FD 36 00 00      LD (IY),0 ; type=0
 323+ 5141 FD 75 01         LD (IY+1),L
 324+ 5144 FD 74 02         LD (IY+2),H
 325+ 5147 FD 72 03         LD (IY+3),D
 326+ 514A FD 70 04         LD (IY+4),B
 327+ 514D
 328+ 514D DD E5            PUSH IX
 329+ 514F E1               POP HL
 330+ 5150 C9               RET
 331+ 5151              ; *******************************************************************************************************
 332+ 5151
 333+ 5151              ; *******************************************************************************************************
 334+ 5151              ; function to handle CALL ANIMITEMPTR basic extension
 335+ 5151              ; ANIMITEMPTR ( BYTE id,
 336+ 5151              ;               INT ticks,
 337+ 5151              ;               INT pointer,
 338+ 5151              ; fills animation item data, returns an error if ID out of bounds
 339+ 5151              ANIMITEMPTR_CMD:
 340+ 5151                  ; opening (
 341+ 5151 CD C6 65     	CALL CHKCHAR
 342+ 5154 28           	DB '('
 343+ 5155              	; get id
 344+ 5155 DD 21 1C 52  	LD IX, GETBYT
 345+ 5159 CD 59 01     	CALL CALBAS
 346+ 515C F5               PUSH AF
 347+ 515D                  ; check if out of bounds
 348+ 515D 3C               INC A
 349+ 515E 4F               LD C,A
 350+ 515F 3A D4 4F         LD A,(ANIMITEMNUM)
 351+ 5162 B9               CP C
 352+ 5163 DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 353+ 5166              	; comma
 354+ 5166 CD C6 65     	CALL CHKCHAR
 355+ 5169 2C           	DB ','
 356+ 516A              	; get ticks
 357+ 516A DD 21 2F 54  	LD IX, FRMQNT
 358+ 516E CD 59 01     	CALL CALBAS
 359+ 5171 D5           	PUSH DE
 360+ 5172              	; comma
 361+ 5172 CD C6 65     	CALL CHKCHAR
 362+ 5175 2C           	DB ','
 363+ 5176              	; get pointer
 364+ 5176 DD 21 2F 54  	LD IX, FRMQNT
 365+ 517A CD 59 01     	CALL CALBAS
 366+ 517D D5           	PUSH DE
 367+ 517E              	; ending )
 368+ 517E CD C6 65     	CALL CHKCHAR
 369+ 5181 29           	DB ')'
 370+ 5182              .ENTRY:
 371+ 5182 E5               PUSH HL
 372+ 5183 DD E1            POP IX
 373+ 5185 D9               EXX
 374+ 5186 D1               POP DE ; pointer
 375+ 5187 E1               POP HL ; ticks
 376+ 5188 D9               EXX
 377+ 5189 F1               POP AF
 378+ 518A CD E9 4F         CALL GETnthANIMITEM
 379+ 518D E5               PUSH HL
 380+ 518E FD E1            POP IY
 381+ 5190 D9               EXX
 382+ 5191 FD 36 00 01      LD (IY),1 ; type=1
 383+ 5195 FD 75 01         LD (IY+1),L
 384+ 5198 FD 74 02         LD (IY+2),H
 385+ 519B FD 73 03         LD (IY+3),E
 386+ 519E FD 72 04         LD (IY+4),D
 387+ 51A1
 388+ 51A1 DD E5            PUSH IX
 389+ 51A3 E1               POP HL
 390+ 51A4 C9               RET
 391+ 51A5              ; *******************************************************************************************************
 392+ 51A5
 393+ 51A5              ; *******************************************************************************************************
 394+ 51A5              ; function to handle CALL MAXANIMDEFS basic extension
 395+ 51A5              ; MAXANIMDEFS (BYTE number)
 396+ 51A5              ; sets new number and moves memory buffers as needed
 397+ 51A5              MAXANIMDEFS:
 398+ 51A5              	; opening (
 399+ 51A5 CD C6 65     	CALL CHKCHAR
 400+ 51A8 28           	DB '('
 401+ 51A9              	; get value
 402+ 51A9 DD 21 1C 52  	LD IX, GETBYT
 403+ 51AD CD 59 01     	CALL CALBAS
 404+ 51B0 F5               PUSH AF
 405+ 51B1              	; ending )
 406+ 51B1 CD C6 65     	CALL CHKCHAR
 407+ 51B4 29           	DB ')'
 408+ 51B5 F1               POP AF
 409+ 51B6 F3               DI
 410+ 51B7              	; save position
 411+ 51B7 E5           	PUSH HL
 412+ 51B8              .ENTRY:
 413+ 51B8 47               LD B,A
 414+ 51B9 3A D7 4F         LD A,(ANIMDEFNUM)
 415+ 51BC 90               SUB B
 416+ 51BD CA 5C 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 417+ 51C0 FD 21 DB 4F      LD IY,ANIMSPRPTR
 418+ 51C4 FA D0 51         JP M, .INCREASE
 419+ 51C7                  ; new value is lower than previous one
 420+ 51C7 CD DB 51         CALL .SIZEDIFF
 421+ 51CA CD 99 50         CALL MAXANIMITEMS.DECREASE_COMMON
 422+ 51CD C3 4A 50         JP MAXANIMITEMS.E1
 423+ 51D0              .INCREASE:
 424+ 51D0 ED 44            NEG
 425+ 51D2 CD DB 51         CALL .SIZEDIFF
 426+ 51D5 CD C5 50         CALL MAXANIMITEMS.INCREASE_COMMON
 427+ 51D8 C3 6E 50         JP MAXANIMITEMS.E2
 428+ 51DB              .SIZEDIFF:
 429+ 51DB 26 00            LD H,0
 430+ 51DD 6F               LD L,A
 431+ 51DE CD B3 64         CALL HLx16
 432+ 51E1 78               LD A,B
 433+ 51E2 32 D7 4F         LD (ANIMDEFNUM),A
 434+ 51E5 44               LD B,H
 435+ 51E6 4D               LD C,L
 436+ 51E7 C9               RET ; BC=size difference in bytes
 437+ 51E8              ; *******************************************************************************************************
 438+ 51E8
 439+ 51E8              ; *******************************************************************************************************
 440+ 51E8              ; function to handle CALL ANIMDEF basic extension
 441+ 51E8              ; ANIMITEMPAT ( BYTE id,
 442+ 51E8              ;               BYTE size,
 443+ 51E8              ;               INT[] list )
 444+ 51E8              ; fills animation definition data, returns an error if out of bounds, or invalid type
 445+ 51E8              ANIMDEF:
 446+ 51E8                  ; opening (
 447+ 51E8 CD C6 65     	CALL CHKCHAR
 448+ 51EB 28           	DB '('
 449+ 51EC              	; get id
 450+ 51EC DD 21 1C 52  	LD IX, GETBYT
 451+ 51F0 CD 59 01     	CALL CALBAS
 452+ 51F3 F5               PUSH AF
 453+ 51F4                  ; check if out of bounds
 454+ 51F4 3C               INC A
 455+ 51F5 4F               LD C,A
 456+ 51F6 3A D7 4F         LD A,(ANIMDEFNUM)
 457+ 51F9 B9               CP C
 458+ 51FA DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 459+ 51FD              	; comma
 460+ 51FD CD C6 65     	CALL CHKCHAR
 461+ 5200 2C           	DB ','
 462+ 5201              	; get size
 463+ 5201 DD 21 1C 52  	LD IX, GETBYT
 464+ 5205 CD 59 01     	CALL CALBAS
 465+ 5208 FE 10            CP 16
 466+ 520A D2 E2 65         JP NC, OVERFLOW
 467+ 520D B7               OR A
 468+ 520E CA E2 65         JP Z, OVERFLOW
 469+ 5211 F5           	PUSH AF
 470+ 5212              	; comma
 471+ 5212 CD C6 65     	CALL CHKCHAR
 472+ 5215 2C           	DB ','
 473+ 5216              	; get pointer to a list of animation items in integer array format
 474+ 5216                  ; get array pointer
 475+ 5216 D1               POP DE
 476+ 5217 D5               PUSH DE
 477+ 5218 3E 02            LD A,2
 478+ 521A 06 01            LD B,1
 479+ 521C CD F3 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 480+ 521F C5               PUSH BC
 481+ 5220              	; ending )
 482+ 5220 CD C6 65     	CALL CHKCHAR
 483+ 5223 29           	DB ')'
 484+ 5224              .ENTRY:
 485+ 5224 E5               PUSH HL
 486+ 5225 DD E1            POP IX
 487+ 5227 D1               POP DE ; pointer to INT array
 488+ 5228 C1               POP BC ; B=item number
 489+ 5229 F1               POP AF ; id
 490+ 522A D5               PUSH DE
 491+ 522B CD F2 4F         CALL GETnthANIMDEF
 492+ 522E D1               POP DE
 493+ 522F 70               LD (HL),B
 494+ 5230              .L1:
 495+ 5230 23               INC HL
 496+ 5231 1A               LD A,(DE)
 497+ 5232 13          > INC DE
 497+ 5233 13          > INC DE
 498+ 5234 77               LD (HL),A
 499+ 5235 10 F9            DJNZ .L1
 500+ 5237 DD E5            PUSH IX
 501+ 5239 E1               POP HL
 502+ 523A C9               RET
 503+ 523B              ; *******************************************************************************************************
 504+ 523B
 505+ 523B              ; *******************************************************************************************************
 506+ 523B              ; function to handle CALL MAXANIMSPRS basic extension
 507+ 523B              ; MAXANIMSPRS (BYTE number)
 508+ 523B              ; sets new number and moves memory buffers as needed
 509+ 523B              MAXANIMSPRS:
 510+ 523B              	; opening (
 511+ 523B CD C6 65     	CALL CHKCHAR
 512+ 523E 28           	DB '('
 513+ 523F              	; get value
 514+ 523F DD 21 1C 52  	LD IX, GETBYT
 515+ 5243 CD 59 01     	CALL CALBAS
 516+ 5246 F5               PUSH AF
 517+ 5247              	; ending )
 518+ 5247 CD C6 65     	CALL CHKCHAR
 519+ 524A 29           	DB ')'
 520+ 524B F1               POP AF
 521+ 524C F3               DI
 522+ 524D              	; save position
 523+ 524D E5           	PUSH HL
 524+ 524E              .ENTRY:
 525+ 524E 47               LD B,A
 526+ 524F 3A DA 4F         LD A,(ANIMSPRNUM)
 527+ 5252 90               SUB B
 528+ 5253 CA 5C 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 529+ 5256 FD 21 DE 4F      LD IY,AUTOSGAMPTR
 530+ 525A FA 66 52         JP M, .INCREASE
 531+ 525D                  ; new value is lower than previous one
 532+ 525D CD 87 52         CALL .SIZEDIFF
 533+ 5260 CD 99 50         CALL MAXANIMITEMS.DECREASE_COMMON
 534+ 5263 C3 53 50         JP MAXANIMITEMS.E3
 535+ 5266              .INCREASE:
 536+ 5266 ED 44            NEG
 537+ 5268 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 538+ 5269 CD 87 52         CALL .SIZEDIFF
 539+ 526C CD C5 50         CALL MAXANIMITEMS.INCREASE_COMMON
 540+ 526F AF               XOR A
 541+ 5270 ED 42            SBC HL,BC ; location of new stuff
 542+ 5272 F1               POP AF
 543+ 5273 C5               PUSH BC
 544+ 5274 47               LD B,A
 545+ 5275 11 08 00         LD DE,8
 546+ 5278 E5               PUSH HL
 547+ 5279 DD E1            POP IX
 548+ 527B              .L1:
 549+ 527B DD 36 06 00      LD (IX+6),0 ; active flag
 550+ 527F DD 19            ADD IX,DE
 551+ 5281 10 F8            DJNZ .L1
 552+ 5283 C1               POP BC
 553+ 5284 C3 75 50         JP MAXANIMITEMS.E4
 554+ 5287              .SIZEDIFF:
 555+ 5287 26 00            LD H,0
 556+ 5289 6F               LD L,A
 557+ 528A CD B4 64         CALL HLx8
 558+ 528D 78               LD A,B
 559+ 528E 32 DA 4F         LD (ANIMSPRNUM),A
 560+ 5291 44               LD B,H
 561+ 5292 4D               LD C,L
 562+ 5293 C9               RET ; BC=size difference in bytes
 563+ 5294              ; *******************************************************************************************************
 564+ 5294
 565+ 5294              ; *******************************************************************************************************
 566+ 5294              ; function to handle CALL ANIMSPRITE basic extension
 567+ 5294              ; ANIMSPRITE ( BYTE id,
 568+ 5294              ;              BYTE sprite_number,
 569+ 5294              ;              BYTE animation_definition_id,
 570+ 5294              ;              BYTE cyclic_flag )
 571+ 5294              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 572+ 5294              ANIMSPRITE:
 573+ 5294                  ; opening (
 574+ 5294 CD C6 65     	CALL CHKCHAR
 575+ 5297 28           	DB '('
 576+ 5298              	; get sprite animation id
 577+ 5298 DD 21 1C 52  	LD IX, GETBYT
 578+ 529C CD 59 01     	CALL CALBAS
 579+ 529F F5               PUSH AF
 580+ 52A0 3C               INC A
 581+ 52A1 4F               LD C,A
 582+ 52A2 3A DA 4F         LD A,(ANIMSPRNUM)
 583+ 52A5 B9               CP C
 584+ 52A6 DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 585+ 52A9              	; comma
 586+ 52A9 CD C6 65     	CALL CHKCHAR
 587+ 52AC 2C           	DB ','
 588+ 52AD              	; get sprite number
 589+ 52AD DD 21 1C 52  	LD IX, GETBYT
 590+ 52B1 CD 59 01     	CALL CALBAS
 591+ 52B4 F5               PUSH AF
 592+ 52B5                  ; check if out of bounds
 593+ 52B5 FE 20            CP 32
 594+ 52B7 D2 DE 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 595+ 52BA              	; comma
 596+ 52BA CD C6 65     	CALL CHKCHAR
 597+ 52BD 2C           	DB ','
 598+ 52BE              	; get animation definition id
 599+ 52BE DD 21 1C 52  	LD IX, GETBYT
 600+ 52C2 CD 59 01     	CALL CALBAS
 601+ 52C5 F5               PUSH AF
 602+ 52C6 3C               INC A
 603+ 52C7 4F               LD C,A
 604+ 52C8 3A D7 4F         LD A,(ANIMDEFNUM)
 605+ 52CB B9               CP C
 606+ 52CC DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 607+ 52CF              	; comma
 608+ 52CF CD C6 65     	CALL CHKCHAR
 609+ 52D2 2C           	DB ','
 610+ 52D3              	; get cyclic flag
 611+ 52D3 DD 21 1C 52  	LD IX, GETBYT
 612+ 52D7 CD 59 01         CALL CALBAS
 613+ 52DA F5           	PUSH AF
 614+ 52DB              	; ending )
 615+ 52DB CD C6 65     	CALL CHKCHAR
 616+ 52DE 29           	DB ')'
 617+ 52DF              .ENTRY:
 618+ 52DF E5               PUSH HL
 619+ 52E0 DD E1            POP IX
 620+ 52E2 D9               EXX
 621+ 52E3 D1               POP DE ; cyclic
 622+ 52E4 C1               POP BC ; animation definition id
 623+ 52E5 E1               POP HL ; sprite number
 624+ 52E6 D9               EXX
 625+ 52E7 F1               POP AF ; sprite animation id
 626+ 52E8 CD FE 4F         CALL GETnthSPRANIM
 627+ 52EB E5               PUSH HL
 628+ 52EC FD E1            POP IY
 629+ 52EE D9               EXX
 630+ 52EF FD 74 00         LD (IY),H
 631+ 52F2 FD 70 04         LD (IY+4),B
 632+ 52F5 FD 72 05         LD (IY+5),D
 633+ 52F8                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 634+ 52F8                  ; following will do preparation for ANIMSTEP situation
 635+ 52F8                  ; current item set to above limit and timer to 1
 636+ 52F8                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 637+ 52F8 FD 36 03 FF      LD (IY+3),255
 638+ 52FC FD 36 01 01      LD (IY+1),1
 639+ 5300 FD 36 02 00      LD (IY+2),0
 640+ 5304                  ; mark as sprite animation
 641+ 5304 FD 36 07 00      LD (IY+7),0
 642+ 5308 DD E5            PUSH IX
 643+ 530A E1               POP HL
 644+ 530B C9               RET
 645+ 530C              ; *******************************************************************************************************
 646+ 530C
 647+ 530C              ; *******************************************************************************************************
 648+ 530C              ; function to handle CALL ANIMCHAR basic extension
 649+ 530C              ; ANIMCHAR ( BYTE id,
 650+ 530C              ;            INT character number 0-767,
 651+ 530C              ;            BYTE animation_definition_id,
 652+ 530C              ;            BYTE cyclic_flag )
 653+ 530C              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 654+ 530C              ANIMCHAR:
 655+ 530C                  ; opening (
 656+ 530C CD C6 65     	CALL CHKCHAR
 657+ 530F 28           	DB '('
 658+ 5310              	; get sprite animation id
 659+ 5310 DD 21 1C 52  	LD IX, GETBYT
 660+ 5314 CD 59 01     	CALL CALBAS
 661+ 5317 F5               PUSH AF
 662+ 5318 3C               INC A
 663+ 5319 4F               LD C,A
 664+ 531A 3A DA 4F         LD A,(ANIMSPRNUM)
 665+ 531D B9               CP C
 666+ 531E DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 667+ 5321              	; comma
 668+ 5321 CD C6 65     	CALL CHKCHAR
 669+ 5324 2C           	DB ','
 670+ 5325              	; get character number
 671+ 5325 DD 21 2F 54  	LD IX, FRMQNT
 672+ 5329 CD 59 01     	CALL CALBAS
 673+ 532C D5               PUSH DE
 674+ 532D                  ; check if out of bounds
 675+ 532D 7A               LD A,D
 676+ 532E FE 03            CP 3
 677+ 5330 D2 DE 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 678+ 5333              	; comma
 679+ 5333 CD C6 65     	CALL CHKCHAR
 680+ 5336 2C           	DB ','
 681+ 5337              	; get animation definition id
 682+ 5337 DD 21 1C 52  	LD IX, GETBYT
 683+ 533B CD 59 01     	CALL CALBAS
 684+ 533E F5               PUSH AF
 685+ 533F 3C               INC A
 686+ 5340 4F               LD C,A
 687+ 5341 3A D7 4F         LD A,(ANIMDEFNUM)
 688+ 5344 B9               CP C
 689+ 5345 DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 690+ 5348              	; comma
 691+ 5348 CD C6 65     	CALL CHKCHAR
 692+ 534B 2C           	DB ','
 693+ 534C              	; get cyclic flag
 694+ 534C DD 21 1C 52  	LD IX, GETBYT
 695+ 5350 CD 59 01         CALL CALBAS
 696+ 5353 F5           	PUSH AF
 697+ 5354              	; ending )
 698+ 5354 CD C6 65     	CALL CHKCHAR
 699+ 5357 29           	DB ')'
 700+ 5358              .ENTRY:
 701+ 5358 E5               PUSH HL
 702+ 5359 DD E1            POP IX
 703+ 535B D9               EXX
 704+ 535C D1               POP DE ; cyclic
 705+ 535D C1               POP BC ; animation definition id
 706+ 535E E1               POP HL ; character number
 707+ 535F D9               EXX
 708+ 5360 F1               POP AF ; sprite animation id
 709+ 5361 CD FE 4F         CALL GETnthSPRANIM
 710+ 5364 E5               PUSH HL
 711+ 5365 FD E1            POP IY
 712+ 5367 D9               EXX
 713+ 5368 FD 75 00         LD (IY),L
 714+ 536B 24               INC H ; save character bank+1
 715+ 536C FD 74 07         LD (IY+7),H
 716+ 536F FD 70 04         LD (IY+4),B
 717+ 5372 FD 72 05         LD (IY+5),D
 718+ 5375                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 719+ 5375                  ; following will do preparation for ANIMSTEP situation
 720+ 5375                  ; current item set to above limit and timer to 1
 721+ 5375                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 722+ 5375 FD 36 03 FF      LD (IY+3),255
 723+ 5379 FD 36 01 01      LD (IY+1),1
 724+ 537D FD 36 02 00      LD (IY+2),0
 725+ 5381 DD E5            PUSH IX
 726+ 5383 E1               POP HL
 727+ 5384 C9               RET
 728+ 5385              ; *******************************************************************************************************
 729+ 5385
 730+ 5385              ; *******************************************************************************************************
 731+ 5385              ; function to handle CALL MAXAUTOSGAMS basic extension
 732+ 5385              ; MAXAUTOSGAMS (BYTE number)
 733+ 5385              ; sets new number and moves memory buffers as needed
 734+ 5385              MAXAUTOSGAMS:
 735+ 5385              	; opening (
 736+ 5385 CD C6 65     	CALL CHKCHAR
 737+ 5388 28           	DB '('
 738+ 5389              	; get value
 739+ 5389 DD 21 1C 52  	LD IX, GETBYT
 740+ 538D CD 59 01     	CALL CALBAS
 741+ 5390 F5               PUSH AF
 742+ 5391              	; ending )
 743+ 5391 CD C6 65     	CALL CHKCHAR
 744+ 5394 29           	DB ')'
 745+ 5395 F1               POP AF
 746+ 5396 F3               DI
 747+ 5397              	; save position
 748+ 5397 E5           	PUSH HL
 749+ 5398              .ENTRY:
 750+ 5398 47               LD B,A
 751+ 5399 3A DD 4F         LD A,(AUTOSGAMNUM)
 752+ 539C 90               SUB B
 753+ 539D CA 5C 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 754+ 53A0 FD 21 10 40      LD IY,FREEMEMPTR
 755+ 53A4 FA B0 53         JP M, .INCREASE
 756+ 53A7                  ; new value is lower than previous one
 757+ 53A7 CD D1 53         CALL .SIZEDIFF
 758+ 53AA CD 99 50         CALL MAXANIMITEMS.DECREASE_COMMON
 759+ 53AD C3 5C 50         JP MAXANIMITEMS.EXIT
 760+ 53B0              .INCREASE:
 761+ 53B0 ED 44            NEG
 762+ 53B2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 763+ 53B3 CD D1 53         CALL .SIZEDIFF
 764+ 53B6 CD C5 50         CALL MAXANIMITEMS.INCREASE_COMMON
 765+ 53B9 AF               XOR A
 766+ 53BA ED 42            SBC HL,BC ; location of new stuff
 767+ 53BC F1               POP AF
 768+ 53BD C5               PUSH BC
 769+ 53BE 47               LD B,A
 770+ 53BF 11 18 00         LD DE,24
 771+ 53C2 E5               PUSH HL
 772+ 53C3 DD E1            POP IX
 773+ 53C5              .L1:
 774+ 53C5 DD 36 13 00      LD (IX+19),0 ; active flag
 775+ 53C9 DD 19            ADD IX,DE
 776+ 53CB 10 F8            DJNZ .L1
 777+ 53CD C1               POP BC
 778+ 53CE C3 5C 50         JP MAXANIMITEMS.EXIT
 779+ 53D1              .SIZEDIFF:
 780+ 53D1 26 00            LD H,0
 781+ 53D3 6F               LD L,A
 782+ 53D4 CD B4 64         CALL HLx8
 783+ 53D7 54               LD D,H
 784+ 53D8 5D               LD E,L
 785+ 53D9 29               ADD HL,HL
 786+ 53DA 19               ADD HL,DE
 787+ 53DB 78               LD A,B
 788+ 53DC 32 DD 4F         LD (AUTOSGAMNUM),A
 789+ 53DF 44               LD B,H
 790+ 53E0 4D               LD C,L
 791+ 53E1 C9               RET ; BC=size difference in bytes
 792+ 53E2              ; *******************************************************************************************************
 793+ 53E2
 794+ 53E2              ; *******************************************************************************************************
 795+ 53E2              ; function to handle CALL AUTOSGAMDEF basic extension
 796+ 53E2              ; AUTOSGAMDEF ( BYTE id,
 797+ 53E2              ;               INT VARIABLE x, INT VARIABLE y,
 798+ 53E2              ;               INT minimum, INT maximum, INT delta,
 799+ 53E2              ;               INT direction,
 800+ 53E2              ;               INT ticks,
 801+ 53E2              ;               BYTE sprite_group_count,
 802+ 53E2              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
 803+ 53E2              ;               BYTE item_number,
 804+ 53E2              ;               INT[] VARIABLE sprite_animations_negative_direction,
 805+ 53E2              ;               INT[] VARIABLE sprite_animations_positive_direction
 806+ 53E2              AUTOSGAMDEF:
 807+ 53E2                  ; opening (
 808+ 53E2 CD C6 65     	CALL CHKCHAR
 809+ 53E5 28           	DB '('
 810+ 53E6              	; get sprite animation id
 811+ 53E6 DD 21 1C 52  	LD IX, GETBYT
 812+ 53EA CD 59 01     	CALL CALBAS
 813+ 53ED F5               PUSH AF
 814+ 53EE 3C               INC A
 815+ 53EF 4F               LD C,A
 816+ 53F0 3A DD 4F         LD A,(AUTOSGAMNUM)
 817+ 53F3 B9               CP C
 818+ 53F4 DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 819+ 53F7 F1               POP AF
 820+ 53F8 E5               PUSH HL
 821+ 53F9 CD 0A 50         CALL GETnthAUTOSGAM
 822+ 53FC 22 B4 62         LD (BLIT_TMP),HL ; for later
 823+ 53FF E1               POP HL
 824+ 5400              	; comma
 825+ 5400 CD C6 65     	CALL CHKCHAR
 826+ 5403 2C           	DB ','
 827+ 5404              	; get address of the X coordinate variable
 828+ 5404 DD 21 A4 5E  	LD IX, PTRGET
 829+ 5408 CD 59 01     	CALL CALBAS
 830+ 540B DD 2A B4 62  	LD IX,(BLIT_TMP)
 831+ 540F DD 73 00         LD (IX+0),E
 832+ 5412 DD 72 01         LD (IX+1),D
 833+ 5415              	; comma
 834+ 5415 CD C6 65     	CALL CHKCHAR
 835+ 5418 2C           	DB ','
 836+ 5419              	; get address of the Y coordinate variable
 837+ 5419 DD 21 A4 5E  	LD IX, PTRGET
 838+ 541D CD 59 01     	CALL CALBAS
 839+ 5420 DD 2A B4 62  	LD IX,(BLIT_TMP)
 840+ 5424 DD 73 02         LD (IX+2),E
 841+ 5427 DD 72 03         LD (IX+3),D
 842+ 542A              	; comma
 843+ 542A CD C6 65     	CALL CHKCHAR
 844+ 542D 2C           	DB ','
 845+ 542E              	; get minimum value
 846+ 542E DD 21 2F 54  	LD IX, FRMQNT
 847+ 5432 CD 59 01     	CALL CALBAS
 848+ 5435 DD 2A B4 62  	LD IX,(BLIT_TMP)
 849+ 5439 DD 73 04         LD (IX+4),E
 850+ 543C DD 72 05         LD (IX+5),D
 851+ 543F              	; comma
 852+ 543F CD C6 65     	CALL CHKCHAR
 853+ 5442 2C           	DB ','
 854+ 5443              	; get maximum value
 855+ 5443 DD 21 2F 54  	LD IX, FRMQNT
 856+ 5447 CD 59 01     	CALL CALBAS
 857+ 544A DD 2A B4 62  	LD IX,(BLIT_TMP)
 858+ 544E DD 73 06         LD (IX+6),E
 859+ 5451 DD 72 07         LD (IX+7),D
 860+ 5454              	; comma
 861+ 5454 CD C6 65     	CALL CHKCHAR
 862+ 5457 2C           	DB ','
 863+ 5458              	; get delta value
 864+ 5458 DD 21 2F 54  	LD IX, FRMQNT
 865+ 545C CD 59 01     	CALL CALBAS
 866+ 545F DD 2A B4 62  	LD IX,(BLIT_TMP)
 867+ 5463 DD 73 08         LD (IX+8),E
 868+ 5466 DD 72 09         LD (IX+9),D
 869+ 5469              	; comma
 870+ 5469 CD C6 65     	CALL CHKCHAR
 871+ 546C 2C           	DB ','
 872+ 546D              	; get direction value
 873+ 546D DD 21 2F 54  	LD IX, FRMQNT
 874+ 5471 CD 59 01     	CALL CALBAS
 875+ 5474 DD 2A B4 62  	LD IX,(BLIT_TMP)
 876+ 5478 DD 73 0A         LD (IX+10),E
 877+ 547B DD 72 0B         LD (IX+11),D
 878+ 547E              	; comma
 879+ 547E CD C6 65     	CALL CHKCHAR
 880+ 5481 2C           	DB ','
 881+ 5482              	; get ticks value
 882+ 5482 DD 21 2F 54  	LD IX, FRMQNT
 883+ 5486 CD 59 01     	CALL CALBAS
 884+ 5489 DD 2A B4 62  	LD IX,(BLIT_TMP)
 885+ 548D DD 73 14         LD (IX+20),E
 886+ 5490 DD 72 15         LD (IX+21),D
 887+ 5493              	; comma
 888+ 5493 CD C6 65     	CALL CHKCHAR
 889+ 5496 2C           	DB ','
 890+ 5497              	; get sprite group count
 891+ 5497 DD 21 1C 52  	LD IX, GETBYT
 892+ 549B CD 59 01     	CALL CALBAS
 893+ 549E B7               OR A
 894+ 549F CA DE 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 895+ 54A2 DD 2A B4 62  	LD IX,(BLIT_TMP)
 896+ 54A6 DD 77 0B         LD (IX+11),A
 897+ 54A9              	; comma
 898+ 54A9 CD C6 65     	CALL CHKCHAR
 899+ 54AC 2C           	DB ','
 900+ 54AD              	; get sprite group definition array data pointer
 901+ 54AD DD 2A B4 62  	LD IX,(BLIT_TMP)
 902+ 54B1 DD 5E 0B         LD E,(IX+11)
 903+ 54B4 16 03        	LD D,3
 904+ 54B6 3E 02        	LD A,2
 905+ 54B8 47           	LD B,A
 906+ 54B9 CD F3 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 907+ 54BC DD 2A B4 62  	LD IX,(BLIT_TMP)
 908+ 54C0 DD 71 0C     	LD (IX+12),C
 909+ 54C3 DD 70 0D         LD (IX+13),B
 910+ 54C6              	; comma
 911+ 54C6 CD C6 65     	CALL CHKCHAR
 912+ 54C9 2C           	DB ','
 913+ 54CA              	; get sprite animation array size
 914+ 54CA DD 21 1C 52  	LD IX,GETBYT
 915+ 54CE CD 59 01     	CALL CALBAS
 916+ 54D1 DD 2A B4 62  	LD IX,(BLIT_TMP)
 917+ 54D5 DD 77 0E         LD (IX+14),A
 918+ 54D8 B7               OR A
 919+ 54D9 CA DE 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 920+ 54DC              	; comma
 921+ 54DC CD C6 65     	CALL CHKCHAR
 922+ 54DF 2C           	DB ','
 923+ 54E0                  ; get array pointer for negative direction
 924+ 54E0 DD 2A B4 62  	LD IX,(BLIT_TMP)
 925+ 54E4 DD 56 0E         LD D,(IX+14)
 926+ 54E7 3E 02            LD A,2
 927+ 54E9 06 01            LD B,1
 928+ 54EB CD F3 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 929+ 54EE DD 2A B4 62  	LD IX,(BLIT_TMP)
 930+ 54F2 DD 71 0F         LD (IX+15),C
 931+ 54F5 DD 70 10         LD (IX+16),B
 932+ 54F8              	; comma
 933+ 54F8 CD C6 65     	CALL CHKCHAR
 934+ 54FB 2C           	DB ','
 935+ 54FC                  ; get array pointer for positive direction
 936+ 54FC DD 2A B4 62  	LD IX,(BLIT_TMP)
 937+ 5500 DD 56 0E         LD D,(IX+14)
 938+ 5503 3E 02            LD A,2
 939+ 5505 06 01            LD B,1
 940+ 5507 CD F3 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 941+ 550A DD 2A B4 62  	LD IX,(BLIT_TMP)
 942+ 550E DD 71 11         LD (IX+17),C
 943+ 5511 DD 70 12         LD (IX+18),B
 944+ 5514              	; ending )
 945+ 5514 CD C6 65     	CALL CHKCHAR
 946+ 5517 29           	DB ')'
 947+ 5518 C9               RET
 948+ 5519              ; *******************************************************************************************************
 949+ 5519
 950+ 5519              ; *******************************************************************************************************
 951+ 5519              ; function to handle CALL AUTOSGAMSTART basic extension
 952+ 5519              ; AUTOSGAMSTART ( BYTE id )
 953+ 5519              AUTOSGAMSTART:
 954+ 5519 3E 01            LD A,1
 955+ 551B              .COMMON:
 956+ 551B 32 47 55         LD (.SETVALUE+3),A
 957+ 551E                  ; opening (
 958+ 551E CD C6 65     	CALL CHKCHAR
 959+ 5521 28           	DB '('
 960+ 5522              	; get sprite animation id
 961+ 5522 DD 21 1C 52  	LD IX, GETBYT
 962+ 5526 CD 59 01     	CALL CALBAS
 963+ 5529 F5               PUSH AF
 964+ 552A 3C               INC A
 965+ 552B 4F               LD C,A
 966+ 552C 3A DD 4F         LD A,(AUTOSGAMNUM)
 967+ 552F B9               CP C
 968+ 5530 DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 969+ 5533 F1               POP AF
 970+ 5534 E5               PUSH HL
 971+ 5535 CD 0A 50         CALL GETnthAUTOSGAM
 972+ 5538 E5               PUSH HL
 973+ 5539 DD E1            POP IX
 974+ 553B E1               POP HL
 975+ 553C DD E5            PUSH IX
 976+ 553E              	; ending )
 977+ 553E CD C6 65     	CALL CHKCHAR
 978+ 5541 29           	DB ')'
 979+ 5542
 980+ 5542                  ; so syntax is fine
 981+ 5542 DD E1            POP IX
 982+ 5544              .SETVALUE:
 983+ 5544 DD 36 13 01      LD (IX+19),1 ; active flag
 984+ 5548                  ; set initial timer
 985+ 5548 DD 7E 14         LD A,(IX+20)
 986+ 554B DD 77 16         LD (IX+22),A
 987+ 554E DD 7E 15         LD A,(IX+21)
 988+ 5551 DD 77 17         LD (IX+23),A
 989+ 5554 C9               RET
 990+ 5555              ; *******************************************************************************************************
 991+ 5555
 992+ 5555              ; *******************************************************************************************************
 993+ 5555              ; function to handle CALL AUTOSGAMSTOP basic extension
 994+ 5555              ; AUTOSGAMSTOP ( BYTE id )
 995+ 5555              AUTOSGAMSTOP:
 996+ 5555 AF               XOR A
 997+ 5556 18 C3            JR AUTOSGAMSTART.COMMON
 998+ 5558              ; *******************************************************************************************************
 999+ 5558
1000+ 5558              ; *******************************************************************************************************
1001+ 5558              ; function to handle CALL ANIMSTEP basic extension
1002+ 5558              ; two forms
1003+ 5558              ; ANIMSTEP ( BYTE id )
1004+ 5558              ; or
1005+ 5558              ; ANIMSTEP ( BYTE item_number,
1006+ 5558              ;            INT[] sprite_animations )
1007+ 5558              ; sets active flag to 1
1008+ 5558              ANIMSTEP:
1009+ 5558 11 D7 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1010+ 555B 18 08            JR ANIMSTARTSTOP_COMMON
1011+ 555D              ; *******************************************************************************************************
1012+ 555D              ; *******************************************************************************************************
1013+ 555D              ; function to handle CALL ANIMSTART basic extension
1014+ 555D              ; two forms
1015+ 555D              ; ANIMSTART ( BYTE id )
1016+ 555D              ; or
1017+ 555D              ; ANIMSTART ( BYTE item_number,
1018+ 555D              ;             INT[] sprite_animations )
1019+ 555D              ; sets active flag to 1
1020+ 555D              ANIMSTART:
1021+ 555D 11 C5 55         LD DE,ANIMSTARTSTOP_COMMON.START
1022+ 5560 18 03            JR ANIMSTARTSTOP_COMMON
1023+ 5562              ; *******************************************************************************************************
1024+ 5562              ; *******************************************************************************************************
1025+ 5562              ; function to handle CALL ANIMSTOP basic extension
1026+ 5562              ; two forms
1027+ 5562              ; ANIMSTOP ( BYTE id )
1028+ 5562              ; or
1029+ 5562              ; ANIMSTOP ( BYTE item_number,
1030+ 5562              ;            INT[] sprite_animations )
1031+ 5562              ; sets active flag to 1
1032+ 5562              ANIMSTOP:
1033+ 5562 11 D2 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1034+ 5565              ; *******************************************************************************************************
1035+ 5565              ANIMSTARTSTOP_COMMON:
1036+ 5565 ED 53 C3 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1037+ 5569                  ; opening (
1038+ 5569 CD C6 65     	CALL CHKCHAR
1039+ 556C 28           	DB '('
1040+ 556D              	; get sprite animation id or array size
1041+ 556D DD 21 1C 52  	LD IX,GETBYT
1042+ 5571 CD 59 01     	CALL CALBAS
1043+ 5574 F5               PUSH AF
1044+ 5575                  ; check if comma present
1045+ 5575 CD D0 65         CALL GETPREVCHAR
1046+ 5578 23               INC HL
1047+ 5579 FE 2C            CP ','
1048+ 557B 28 0E            JR Z,.L1
1049+ 557D FE 29            CP ')'
1050+ 557F C2 EA 65         JP NZ,SYNTAX_ERROR
1051+ 5582                  ; ok so single argument variant
1052+ 5582 F1               POP AF
1053+ 5583 E5               PUSH HL
1054+ 5584 F3               DI
1055+ 5585 CD B1 55         CALL .SETVALUE
1056+ 5588 FB               EI
1057+ 5589 E1               POP HL
1058+ 558A C9               RET
1059+ 558B              .L1:
1060+ 558B                  ; get array pointer
1061+ 558B D1               POP DE
1062+ 558C D5               PUSH DE
1063+ 558D 3E 02            LD A,2
1064+ 558F 06 01            LD B,1
1065+ 5591 CD F3 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1066+ 5594 C5               PUSH BC
1067+ 5595              	; ending )
1068+ 5595 CD C6 65     	CALL CHKCHAR
1069+ 5598 29           	DB ')'
1070+ 5599 D1               POP DE ; array pointer
1071+ 559A C1               POP BC ; number of items
1072+ 559B 78               LD A,B
1073+ 559C B7               OR A
1074+ 559D CA DE 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1075+ 55A0 E5               PUSH HL
1076+ 55A1 F3               DI
1077+ 55A2              .L2:
1078+ 55A2 C5               PUSH BC
1079+ 55A3 1A               LD A,(DE)
1080+ 55A4 13          > INC DE
1080+ 55A5 13          > INC DE
1081+ 55A6 D5               PUSH DE
1082+ 55A7 CD B1 55         CALL .SETVALUE
1083+ 55AA D1               POP DE
1084+ 55AB C1               POP BC
1085+ 55AC 10 F4            DJNZ .L2
1086+ 55AE FB               EI
1087+ 55AF E1               POP HL
1088+ 55B0 C9               RET
1089+ 55B1
1090+ 55B1              .SETVALUE:
1091+ 55B1 47               LD B,A
1092+ 55B2 3C               INC A
1093+ 55B3 4F               LD C,A
1094+ 55B4 3A DA 4F         LD A,(ANIMSPRNUM)
1095+ 55B7 B9               CP C
1096+ 55B8 DA DE 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1097+ 55BB 78               LD A,B
1098+ 55BC CD FE 4F         CALL GETnthSPRANIM
1099+ 55BF E5               PUSH HL
1100+ 55C0 DD E1            POP IX
1101+ 55C2              .FN:
1102+ 55C2 C3 00 00         JP 0
1103+ 55C5              .START:
1104+ 55C5 DD 36 06 01      LD (IX+6),1 ; active flag
1105+ 55C9 DD 36 03 00      LD (IX+3),0 ; current item
1106+ 55CD 06 00            LD B,0 ; setup timer
1107+ 55CF C3 56 56         JP SETUP_ANIM_STEP
1108+ 55D2              .STOP:
1109+ 55D2 DD 36 06 00      LD (IX+6),0 ; active flag
1110+ 55D6 C9               RET
1111+ 55D7              .STEP:
1112+ 55D7 06 00            LD B,0
1113+ 55D9 C3 FA 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1114+ 55DC              ; *******************************************************************************************************
1115+ 55DC
1116+ 55DC              ; *******************************************************************************************************
1117+ 55DC              ; function processes animations during vblank period
1118+ 55DC              PROCESS_ANIMATIONS:
1119+ 55DC 3A DA 4F         LD A,(ANIMSPRNUM)
1120+ 55DF B7               OR A
1121+ 55E0 C8               RET Z; no animations defined
1122+ 55E1 47               LD B,A
1123+ 55E2 DD 2A DB 4F      LD IX,(ANIMSPRPTR)
1124+ 55E6              .L1:
1125+ 55E6 C5               PUSH BC
1126+ 55E7 06 00            LD B,0 ; normal mode, change on timer expiry only
1127+ 55E9 CD F5 55         CALL PROCESS_SINGLE_ANIMATION
1128+ 55EC 11 08 00         LD DE,8
1129+ 55EF DD 19            ADD IX,DE
1130+ 55F1 C1               POP BC
1131+ 55F2 10 F2            DJNZ .L1
1132+ 55F4 C9               RET
1133+ 55F5              ; *******************************************************************************************************
1134+ 55F5
1135+ 55F5              ; *******************************************************************************************************
1136+ 55F5              ; processes single sprite animation
1137+ 55F5              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1138+ 55F5              ; on timer expiry goes to next animation item
1139+ 55F5              ; input IX=sprite animation pointer
1140+ 55F5              ; input B=1 force mode, activate animation action regardless of expired timer
1141+ 55F5              PROCESS_SINGLE_ANIMATION:
1142+ 55F5 DD 7E 06         LD A,(IX+6); active
1143+ 55F8 B7               OR A
1144+ 55F9 C8               RET Z ; inactive animation
1145+ 55FA              .INACTIVE_TOO:
1146+ 55FA DD 6E 01         LD L,(IX+1)
1147+ 55FD DD 66 02         LD H,(IX+2) ; HL=end time
1148+ 5600 2B               DEC HL
1149+ 5601 DD 75 01         LD (IX+1),L
1150+ 5604 DD 74 02         LD (IX+2),H
1151+ 5607 7D               LD A,L
1152+ 5608 B4               OR H
1153+ 5609 28 06            JR Z,.STEP
1154+ 560B 05               DEC B
1155+ 560C 04               INC B
1156+ 560D C8               RET Z ; not forced mode, return
1157+ 560E C3 56 56         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1158+ 5611              .STEP:
1159+ 5611 06 00            LD B,0; setup timer
1160+ 5613 DD 34 03         INC (IX+3) ; current animation item
1161+ 5616 C3 56 56         JP SETUP_ANIM_STEP
1162+ 5619              ; *******************************************************************************************************
1163+ 5619
1164+ 5619              ; *******************************************************************************************************
1165+ 5619              ; function will setup sprite animation after current item change
1166+ 5619              ; input A=current animation definition
1167+ 5619              ; input IX=pointer to sprite animation
1168+ 5619              ; input B=1 skip timer setup
1169+ 5619              ; output IY=pointer to animation item
1170+ 5619              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1171+ 5619              ; basically sets new end time for current animation
1172+ 5619              INIT_CURRENT_ANIMATION:
1173+ 5619 CD F2 4F         CALL GETnthANIMDEF
1174+ 561C DD 7E 03         LD A,(IX+3) ; current animation item
1175+ 561F BE               CP (HL) ; number of animation items in the animation definition
1176+ 5620 38 0A            JR C,.L3 ; last item not reached
1177+ 5622                  ; last item reached
1178+ 5622 DD 7E 05         LD A,(IX+5) ; cyclic flag
1179+ 5625 B7               OR A
1180+ 5626 28 2C            JR Z,.ERROR ; non-cyclic animation
1181+ 5628                  ; cyclic animation, restart
1182+ 5628 DD 36 03 00      LD (IX+3),0; current item
1183+ 562C              .L3:
1184+ 562C                  ; HL = animation definition
1185+ 562C 23               INC HL ; skip animation definition size field
1186+ 562D 16 00            LD D,0
1187+ 562F DD 5E 03         LD E,(IX+3); current item
1188+ 5632 19               ADD HL,DE
1189+ 5633 4E               LD C,(HL) ; current animation item
1190+ 5634 0C               INC C
1191+ 5635 3A D4 4F         LD A,(ANIMITEMNUM)
1192+ 5638 B9               CP C
1193+ 5639 38 19            JR C,.ERROR ; invalid animation item, stop animation
1194+ 563B 0D               DEC C
1195+ 563C 79               LD A,C
1196+ 563D CD E9 4F         CALL GETnthANIMITEM
1197+ 5640 E5               PUSH HL
1198+ 5641 FD E1            POP IY ; IY=animation item
1199+ 5643 05               DEC B
1200+ 5644 28 0C            JR Z,.EXIT
1201+ 5646 FD 5E 01         LD E,(IY+1)
1202+ 5649 FD 56 02         LD D,(IY+2) ; duration
1203+ 564C DD 73 01         LD (IX+1),E
1204+ 564F DD 72 02         LD (IX+2),D
1205+ 5652              .EXIT:
1206+ 5652 AF               XOR A
1207+ 5653 C9               RET
1208+ 5654              .ERROR:
1209+ 5654 37               SCF
1210+ 5655 C9               RET
1211+ 5656              ; *******************************************************************************************************
1212+ 5656
1213+ 5656              ; *******************************************************************************************************
1214+ 5656              ; function will display currect item and set up expiry time
1215+ 5656              ; it will also stop the animation if expired
1216+ 5656              ; sets sprite update flag if any changes in sprite data made
1217+ 5656              ; input IX=current sprite animation
1218+ 5656              ; input B=1 skip timer setup
1219+ 5656              SETUP_ANIM_STEP:
1220+ 5656 DD 4E 04         LD C,(IX+4) ; animation definition ID
1221+ 5659 0C               INC C
1222+ 565A 3A D7 4F         LD A,(ANIMDEFNUM)
1223+ 565D B9               CP C
1224+ 565E 30 05            JR NC,.L2
1225+ 5660                  ; given animation item is outside of bounds, deactivate animation
1226+ 5660              .STOPANIM:
1227+ 5660 DD 36 06 00      LD (IX+6),0
1228+ 5664 C9               RET
1229+ 5665              .L2:
1230+ 5665 0D               DEC C
1231+ 5666 79               LD A,C
1232+ 5667 CD 19 56         CALL INIT_CURRENT_ANIMATION
1233+ 566A 38 F4            JR C, .STOPANIM
1234+ 566C FD 7E 00         LD A,(IY) ; type of animation item
1235+ 566F B7               OR A
1236+ 5670 28 44            JR Z,.L4 ; change pattern and/or color
1237+ 5672              .PAT:
1238+ 5672                  ; change pattern definition
1239+ 5672                  ; check if sprite or character
1240+ 5672 DD 7E 07         LD A,(IX+7)
1241+ 5675 B7               OR A
1242+ 5676 20 58            JR NZ,.CHAR
1243+ 5678 DD 7E 00         LD A,(IX) ; sprite number
1244+ 567B CD 85 4D         CALL GETnthSPRATTR
1245+ 567E 23          > INC HL ; skip y and x
1245+ 567F 23          > INC HL
1245+ 5680 23          > INC HL
1245+ 5681 23          > INC HL
1246+ 5682 7E               LD A,(HL); current pattern
1247+ 5683 26 00            LD H,0
1248+ 5685 6F               LD L,A
1249+ 5686 3A E0 F3         LD A,(REG1SAV)
1250+ 5689 E6 02            AND 2
1251+ 568B 20 07            JR NZ,.L6
1252+ 568D                  ; 8x8 sprite
1253+ 568D CD B4 64         CALL HLx8
1254+ 5690 06 08            LD B,8
1255+ 5692 18 05            JR .L5
1256+ 5694              .L6:
1257+ 5694 CD B2 64         CALL HLx32
1258+ 5697 06 20            LD B,32
1259+ 5699              .L5:
1260+ 5699 3A AF FC         LD A,(SCRMOD)
1261+ 569C 3D               DEC A
1262+ 569D 20 06            JR NZ,.L10
1263+ 569F ED 5B C5 F3      LD DE,(T32PAT)
1264+ 56A3 18 04            JR .L7
1265+ 56A5              .L10:
1266+ 56A5 ED 5B CF F3      LD DE,(GRPPAT)
1267+ 56A9              .L7:
1268+ 56A9 19               ADD HL,DE
1269+ 56AA CD 9F 64         CALL SETWRT_LOCAL
1270+ 56AD FD 6E 03         LD L,(IY+3)
1271+ 56B0 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1272+ 56B3 C3 AA 64         JP BBYTECOPY
1273+ 56B6              .L4:
1274+ 56B6                  ; change pattern and color in sprite attributes table
1275+ 56B6 DD 7E 00         LD A,(IX) ; sprite number
1276+ 56B9 CD 85 4D         CALL GETnthSPRATTR
1277+ 56BC 23          > INC HL ; skip y and x
1277+ 56BD 23          > INC HL
1277+ 56BE 23          > INC HL
1277+ 56BF 23          > INC HL
1278+ 56C0 FD 7E 03         LD A,(IY+3) ; new pattern
1279+ 56C3 77               LD (HL),A
1280+ 56C4 23          > INC HL
1280+ 56C5 23          > INC HL
1281+ 56C6 FD 7E 04         LD A,(IY+4) ; new color
1282+ 56C9 77               LD (HL),A
1283+ 56CA 2A 7D 4D         LD HL,(SPRATR_UPDATE_FLAG)
1284+ 56CD 36 01            LD (HL),1
1285+ 56CF C9               RET
1286+ 56D0              .CHAR:
1287+ 56D0 DD 6E 00         LD L,(IX)
1288+ 56D3 3D               DEC A
1289+ 56D4 67               LD H,A
1290+ 56D5 CD B4 64         CALL HLx8
1291+ 56D8 3A AF FC         LD A,(SCRMOD)
1292+ 56DB 3D               DEC A
1293+ 56DC 20 06            JR NZ,.L8
1294+ 56DE ED 5B C1 F3      LD DE,(T32CGP)
1295+ 56E2 18 04            JR .L9
1296+ 56E4              .L8:
1297+ 56E4 ED 5B CB F3      LD DE,(GRPCGP)
1298+ 56E8              .L9:
1299+ 56E8 06 08            LD B,8
1300+ 56EA 18 BD            JR .L7
1301+ 56EC              ; *******************************************************************************************************
1302+ 56EC
# file closed: asm\ANIMATION.asm
 123  56EC               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 56EC              ; Sprite Group Animate and Move
   2+ 56EC
   3+ 56EC              ; *******************************************************************************************************
   4+ 56EC              ; shared function to process a list of animations
   5+ 56EC              ; input B=list size
   6+ 56EC              ; input DE=list pointer
   7+ 56EC              SGAM_PROCESS_ANIM_LIST:
   8+ 56EC 21 FF 56         LD HL,.STEP
   9+ 56EF 22 C3 55         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 56F2              .L1:
  11+ 56F2 C5               PUSH BC
  12+ 56F3 1A               LD A,(DE)
  13+ 56F4 13          > INC DE
  13+ 56F5 13          > INC DE
  14+ 56F6 D5               PUSH DE
  15+ 56F7 CD B1 55         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 56FA D1               POP DE
  17+ 56FB C1               POP BC
  18+ 56FC 10 F4            DJNZ .L1
  19+ 56FE C9           	RET
  20+ 56FF              .STEP:
  21+ 56FF 06 01            LD B,1
  22+ 5701 C3 FA 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 5704              ; *******************************************************************************************************
  24+ 5704
  25+ 5704              ; *******************************************************************************************************
  26+ 5704              ; function to handle CALL SGAM basic extension
  27+ 5704              ; sets position of a group of sprites as described in SPRGRPMOV
  28+ 5704              ; and manually animate a list of animations
  29+ 5704              ; _SGAM ( INT x,
  30+ 5704              ;	      INT y,
  31+ 5704              ;		  BYTE count,
  32+ 5704              ;		  INT[2][count] data_ptr,
  33+ 5704              ;         BYTE item_number,
  34+ 5704              ;         INT[] sprite_animations )
  35+ 5704              ; will put ram in page 0 also, page 1 is already there
  36+ 5704              SGAM:
  37+ 5704 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
  38+ 5707 B7           	OR A
  39+ 5708 CA E6 65     	JP Z,ILLEGAL_FUNCTION
  40+ 570B              	; opening (
  41+ 570B CD C6 65     	CALL CHKCHAR
  42+ 570E 28           	DB '('
  43+ 570F              	; get x
  44+ 570F DD 21 2F 54  	LD IX, FRMQNT
  45+ 5713 CD 59 01     	CALL CALBAS
  46+ 5716 ED 53 B8 62  	LD (BLIT_STRUCT),DE
  47+ 571A              	; comma
  48+ 571A CD C6 65     	CALL CHKCHAR
  49+ 571D 2C           	DB ','
  50+ 571E              	; get y
  51+ 571E DD 21 2F 54  	LD IX, FRMQNT
  52+ 5722 CD 59 01     	CALL CALBAS
  53+ 5725 ED 53 BA 62  	LD (BLIT_STRUCT+2),DE
  54+ 5729              	; comma
  55+ 5729 CD C6 65     	CALL CHKCHAR
  56+ 572C 2C           	DB ','
  57+ 572D              	; get count
  58+ 572D DD 21 1C 52  	LD IX, GETBYT
  59+ 5731 CD 59 01     	CALL CALBAS
  60+ 5734 B7               OR A
  61+ 5735 CA DE 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  62+ 5738 32 BC 62     	LD (BLIT_STRUCT+4),A
  63+ 573B              	; comma
  64+ 573B CD C6 65     	CALL CHKCHAR
  65+ 573E 2C           	DB ','
  66+ 573F              	; get sprite group definition array data pointer
  67+ 573F 3A BC 62         LD A,(BLIT_STRUCT+4)
  68+ 5742 5F           	LD E,A
  69+ 5743 16 03        	LD D,3
  70+ 5745 3E 02        	LD A,2
  71+ 5747 47           	LD B,A
  72+ 5748 CD F3 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
  73+ 574B ED 43 BD 62  	LD (BLIT_STRUCT+5),BC
  74+ 574F              	; comma
  75+ 574F CD C6 65     	CALL CHKCHAR
  76+ 5752 2C           	DB ','
  77+ 5753              	; get sprite animation array size
  78+ 5753 DD 21 1C 52  	LD IX,GETBYT
  79+ 5757 CD 59 01     	CALL CALBAS
  80+ 575A 32 BF 62         LD (BLIT_STRUCT+7),A
  81+ 575D B7               OR A
  82+ 575E CA DE 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  83+ 5761              	; comma
  84+ 5761 CD C6 65     	CALL CHKCHAR
  85+ 5764 2C           	DB ','
  86+ 5765                  ; get array pointer
  87+ 5765 3A BF 62         LD A,(BLIT_STRUCT+7)
  88+ 5768 57               LD D,A
  89+ 5769 3E 02            LD A,2
  90+ 576B 06 01            LD B,1
  91+ 576D CD F3 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  92+ 5770 ED 43 C0 62      LD (BLIT_STRUCT+8),BC
  93+ 5774              	; ending )
  94+ 5774 CD C6 65     	CALL CHKCHAR
  95+ 5777 29           	DB ')'
  96+ 5778              .ENTRY:
  97+ 5778 E5               PUSH HL
  98+ 5779 F3               DI
  99+ 577A
 100+ 577A              	; enable page 0
 101+ 577A FD 21 81 57  	LD IY, .RET
 102+ 577E C3 78 65     	JP ENABLE_PAGE0
 103+ 5781              .RET:
 104+ 5781 D9               EXX
 105+ 5782 ED 5B B8 62      LD DE,(BLIT_STRUCT) ; initial x
 106+ 5786 ED 4B BA 62      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 578A D9               EXX
 108+ 578B 2A BD 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 578E 3A BC 62         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 5791 47               LD B,A
 111+ 5792 CD C2 4F         CALL SPRGRPMOV.UPDATE_LOC
 112+ 5795
 113+ 5795 3A BF 62         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5798 47               LD B,A
 115+ 5799 ED 5B C0 62      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 579D CD EC 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 57A0
 118+ 57A0 D1               POP DE
 119+ 57A1 C1               POP BC
 120+ 57A2 CD EF 64         CALL RESTORE_PAGE_INFO
 121+ 57A5 FB               EI
 122+ 57A6 E1               POP HL
 123+ 57A7 C9               RET
 124+ 57A8              ; *******************************************************************************************************
 125+ 57A8
 126+ 57A8              ; *******************************************************************************************************
 127+ 57A8              ; handles automatic move and animate sprite groups during interrupt
 128+ 57A8              PROCESS_AUTOSGAMS:
 129+ 57A8 3A DD 4F     	LD A,(AUTOSGAMNUM)
 130+ 57AB B7           	OR A
 131+ 57AC C8           	RET Z
 132+ 57AD 47           	LD B,A
 133+ 57AE DD 2A DE 4F  	LD IX,(AUTOSGAMPTR)
 134+ 57B2              .L1:
 135+ 57B2 C5           	PUSH BC
 136+ 57B3 DD 7E 13     	LD A,(IX+19) ; active flag
 137+ 57B6 B7           	OR A
 138+ 57B7 28 28        	JR Z,.LOOPEND
 139+ 57B9              	; active, check timer
 140+ 57B9 DD 6E 16     	LD L,(IX+22)
 141+ 57BC DD 66 17     	LD H,(IX+23) ; timer
 142+ 57BF 2B           	DEC HL
 143+ 57C0 7C           	LD A,H
 144+ 57C1 B5           	OR L
 145+ 57C2 28 08        	JR Z,.L2
 146+ 57C4              	; not expired
 147+ 57C4 DD 75 16     	LD (IX+22),L
 148+ 57C7 DD 74 17     	LD (IX+23),H
 149+ 57CA 18 15        	JR .LOOPEND
 150+ 57CC              .L2:
 151+ 57CC              	; expired, process
 152+ 57CC
 153+ 57CC                  ; set initial timer
 154+ 57CC DD 7E 14         LD A,(IX+20)
 155+ 57CF DD 77 16         LD (IX+22),A
 156+ 57D2 DD 7E 15         LD A,(IX+21)
 157+ 57D5 DD 77 17         LD (IX+23),A
 158+ 57D8
 159+ 57D8 CD EA 57     	CALL .MOVE
 160+ 57DB CD 55 58     	CALL .UPDATELOC
 161+ 57DE CD 7A 58     	CALL .PROCESS_ANIM_LIST
 162+ 57E1
 163+ 57E1              .LOOPEND:
 164+ 57E1 11 18 00     	LD DE,24
 165+ 57E4 DD 19        	ADD IX,DE
 166+ 57E6 C1           	POP BC
 167+ 57E7 10 C9        	DJNZ .L1
 168+ 57E9 C9           	RET
 169+ 57EA
 170+ 57EA              .MOVE:
 171+ 57EA              	; process movement
 172+ 57EA DD 7E 0A     	LD A,(IX+10) ; direction
 173+ 57ED B7           	OR A
 174+ 57EE 28 08        	JR Z, .MOVE_L1
 175+ 57F0              	; vertical
 176+ 57F0 DD 6E 02     	LD L,(IX+2)
 177+ 57F3 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 178+ 57F6 18 06        	JR .MOVE_L2
 179+ 57F8              .MOVE_L1:
 180+ 57F8              	; horizontal
 181+ 57F8 DD 6E 00     	LD L,(IX+0)
 182+ 57FB DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 183+ 57FE              .MOVE_L2:
 184+ 57FE E5           	PUSH HL
 185+ 57FF FD E1        	POP IY
 186+ 5801 FD 6E 00     	LD L,(IY+0)
 187+ 5804 FD 66 01     	LD H,(IY+1)
 188+ 5807 DD 5E 08     	LD E,(IX+8)
 189+ 580A DD 56 09     	LD D,(IX+9) ; delta value
 190+ 580D 19           	ADD HL,DE
 191+ 580E E5           	PUSH HL
 192+ 580F DD 5E 04     	LD E,(IX+4)
 193+ 5812 DD 56 05     	LD D,(IX+5) ; minimum value
 194+ 5815 A7           	AND A
 195+ 5816 ED 52        	SBC HL,DE
 196+ 5818 FA 32 58     	JP M,.MOVE_L3 ; below minimum
 197+ 581B E1           	POP HL
 198+ 581C E5           	PUSH HL
 199+ 581D DD 5E 06     	LD E,(IX+6)
 200+ 5820 DD 56 07     	LD D,(IX+7) ; maximum value
 201+ 5823 EB           	EX DE,HL
 202+ 5824 A7           	AND A
 203+ 5825 ED 52        	SBC HL,DE
 204+ 5827 FA 3A 58     	JP M,.MOVE_L4 ; above maximum
 205+ 582A E1           	POP HL
 206+ 582B              	; within bounds
 207+ 582B              .MOVE_L5:
 208+ 582B FD 75 00     	LD (IY+0),L
 209+ 582E FD 74 01     	LD (IY+1),H
 210+ 5831 C9           	RET
 211+ 5832              .MOVE_L3:
 212+ 5832 E1           	POP HL
 213+ 5833 CD 46 58     	CALL .INVERSE_DELTA
 214+ 5836 6B           	LD L,E
 215+ 5837 62           	LD H,D
 216+ 5838 18 F1        	JR .MOVE_L5
 217+ 583A              .MOVE_L4:
 218+ 583A E1           	POP HL
 219+ 583B CD 46 58     	CALL .INVERSE_DELTA
 220+ 583E DD 6E 06     	LD L,(IX+6)
 221+ 5841 DD 66 07     	LD H,(IX+7) ; maximum
 222+ 5844 18 E5        	JR .MOVE_L5
 223+ 5846              .INVERSE_DELTA:
 224+ 5846 AF           	XOR A
 225+ 5847 DD 96 08     	SUB (IX+8)
 226+ 584A DD 77 08     	LD (IX+8),A
 227+ 584D 9F           	SBC A,A
 228+ 584E DD 96 09     	SUB (IX+9)
 229+ 5851 DD 77 09     	LD (IX+9),A
 230+ 5854 C9           	RET
 231+ 5855
 232+ 5855              .UPDATELOC:
 233+ 5855 DD E5        	PUSH IX
 234+ 5857 D9           	EXX
 235+ 5858 DD 6E 00     	LD L,(IX+0)
 236+ 585B DD 66 01     	LD H,(IX+1)
 237+ 585E 5E           	LD E,(HL)
 238+ 585F 23           	INC HL
 239+ 5860 56           	LD D,(HL)
 240+ 5861 DD 6E 02     	LD L,(IX+2)
 241+ 5864 DD 66 03     	LD H,(IX+3)
 242+ 5867 4E           	LD C,(HL)
 243+ 5868 23           	INC HL
 244+ 5869 46           	LD B,(HL)
 245+ 586A D9           	EXX
 246+ 586B DD 6E 0C     	LD L,(IX+12)
 247+ 586E DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 248+ 5871 DD 46 0B     	LD B,(IX+11) ; sprite group size
 249+ 5874 CD C2 4F     	CALL SPRGRPMOV.UPDATE_LOC
 250+ 5877 DD E1        	POP IX
 251+ 5879 C9           	RET
 252+ 587A
 253+ 587A              .PROCESS_ANIM_LIST:
 254+ 587A DD E5        	PUSH IX
 255+ 587C DD 46 0E         LD B,(IX+14) ; anim list size
 256+ 587F DD CB 09 7E  	BIT 7,(IX+9)
 257+ 5883 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 258+ 5885              	; negative direction
 259+ 5885 DD 5E 0F     	LD E,(IX+15)
 260+ 5888 DD 56 10     	LD D,(IX+16)
 261+ 588B 18 06        	JR .PROCESS_ANIM_LIST_L2
 262+ 588D              .PROCESS_ANIM_LIST_L1:
 263+ 588D              	; positive direction
 264+ 588D DD 5E 11     	LD E,(IX+17)
 265+ 5890 DD 56 12     	LD D,(IX+18)
 266+ 5893              .PROCESS_ANIM_LIST_L2:
 267+ 5893 CD EC 56     	CALL SGAM_PROCESS_ANIM_LIST
 268+ 5896 DD E1        	POP IX
 269+ 5898 C9           	RET
 270+ 5899              ; *******************************************************************************************************
 271+ 5899
# file closed: asm\SGAM.asm
 124  5899               ENDIF
 125  5899
 126  5899               IF (RAM_CMDS == 1)
 127  5899               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5899              ; *******************************************************************************************************
   2+ 5899              ; function to handle CALL MEMCPY basic extension
   3+ 5899              ; _MEMCPY ( INT source,
   4+ 5899              ;			INT destination,
   5+ 5899              ;			INT count,
   6+ 5899              ; will put ram in page 0 also, page 1 is already there
   7+ 5899              MEMCPY:
   8+ 5899              	; opening (
   9+ 5899 CD C6 65     	CALL CHKCHAR
  10+ 589C 28           	DB '('
  11+ 589D              	; get source address
  12+ 589D DD 21 2F 54  	LD IX, FRMQNT
  13+ 58A1 CD 59 01     	CALL CALBAS
  14+ 58A4 D5           	PUSH DE
  15+ 58A5              	; comma
  16+ 58A5 CD C6 65     	CALL CHKCHAR
  17+ 58A8 2C           	DB ','
  18+ 58A9              	; get destination address
  19+ 58A9 DD 21 2F 54  	LD IX, FRMQNT
  20+ 58AD CD 59 01     	CALL CALBAS
  21+ 58B0 D5           	PUSH DE
  22+ 58B1              	; comma
  23+ 58B1 CD C6 65     	CALL CHKCHAR
  24+ 58B4 2C           	DB ','
  25+ 58B5              	; get length
  26+ 58B5 DD 21 2F 54  	LD IX, FRMQNT
  27+ 58B9 CD 59 01     	CALL CALBAS
  28+ 58BC D5           	PUSH DE
  29+ 58BD              	; ending )
  30+ 58BD CD C6 65     	CALL CHKCHAR
  31+ 58C0 29           	DB ')'
  32+ 58C1
  33+ 58C1              	; save position
  34+ 58C1 E5           	PUSH HL
  35+ 58C2 DD E1        	POP IX
  36+ 58C4
  37+ 58C4 C1           	POP BC ; count
  38+ 58C5 D1           	POP DE ; destination
  39+ 58C6 E1           	POP HL ; source
  40+ 58C7 D9           	EXX
  41+ 58C8              	; enable page 0
  42+ 58C8 F3           	DI
  43+ 58C9 FD 21 D0 58  	LD IY, .RET
  44+ 58CD C3 78 65     	JP ENABLE_PAGE0
  45+ 58D0              .RET:
  46+ 58D0 FB           	EI
  47+ 58D1 D9           	EXX
  48+ 58D2 ED B0        	LDIR
  49+ 58D4 D1               POP DE
  50+ 58D5 C1               POP BC
  51+ 58D6 CD EF 64         CALL RESTORE_PAGE_INFO
  52+ 58D9 DD E5        	PUSH IX
  53+ 58DB E1           	POP HL
  54+ 58DC C9           	RET
  55+ 58DD              ; *******************************************************************************************************
  56+ 58DD
  57+ 58DD              ; *******************************************************************************************************
  58+ 58DD              ; function to handle CALL FILRAM basic extension
  59+ 58DD              ; FILRAM ( INT start address,
  60+ 58DD              ;		   INT count,
  61+ 58DD              ;		   BYTE value )
  62+ 58DD              ; will put ram in page 0 also, page 1 is already there
  63+ 58DD              FILRAM:
  64+ 58DD              	; opening (
  65+ 58DD CD C6 65     	CALL CHKCHAR
  66+ 58E0 28           	DB '('
  67+ 58E1              	; get start address
  68+ 58E1 DD 21 2F 54  	LD IX, FRMQNT
  69+ 58E5 CD 59 01     	CALL CALBAS
  70+ 58E8 D5           	PUSH DE
  71+ 58E9              	; comma
  72+ 58E9 CD C6 65     	CALL CHKCHAR
  73+ 58EC 2C           	DB ','
  74+ 58ED              	; get count
  75+ 58ED DD 21 2F 54  	LD IX, FRMQNT
  76+ 58F1 CD 59 01     	CALL CALBAS
  77+ 58F4 D5           	PUSH DE
  78+ 58F5              	; comma
  79+ 58F5 CD C6 65     	CALL CHKCHAR
  80+ 58F8 2C           	DB ','
  81+ 58F9              	; get value
  82+ 58F9 DD 21 1C 52  	LD IX, GETBYT
  83+ 58FD CD 59 01     	CALL CALBAS
  84+ 5900 F5           	PUSH AF
  85+ 5901              	; ending )
  86+ 5901 CD C6 65     	CALL CHKCHAR
  87+ 5904 29           	DB ')'
  88+ 5905
  89+ 5905              	; save position
  90+ 5905 E5           	PUSH HL
  91+ 5906 DD E1        	POP IX
  92+ 5908
  93+ 5908 D1           	POP DE ; actually AF
  94+ 5909 C1           	POP BC ; count
  95+ 590A E1           	POP HL ; start address
  96+ 590B 78           	LD A, B
  97+ 590C B7           	OR A
  98+ 590D 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
  99+ 590F B1           	OR C
 100+ 5910 28 1A        	JR Z, .EXIT ; 0 bytes to fill, skip
 101+ 5912 79           	LD A, C
 102+ 5913 3D           	DEC A
 103+ 5914 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 104+ 5916              	; one byte to fill
 105+ 5916 72           	LD (HL), D
 106+ 5917 18 13        	JR .EXIT
 107+ 5919              .L1:
 108+ 5919 D9           	EXX
 109+ 591A              	; enable page 0
 110+ 591A F3           	DI
 111+ 591B FD 21 22 59  	LD IY, .RET
 112+ 591F C3 78 65     	JP ENABLE_PAGE0
 113+ 5922              .RET:
 114+ 5922 FB           	EI
 115+ 5923 D9           	EXX
 116+ 5924 CD 30 59     	CALL .FILLVALUE
 117+ 5927 D1               POP DE
 118+ 5928 C1               POP BC
 119+ 5929 CD EF 64         CALL RESTORE_PAGE_INFO
 120+ 592C              .EXIT:
 121+ 592C DD E5        	PUSH IX
 122+ 592E E1           	POP HL
 123+ 592F C9           	RET
 124+ 5930
 125+ 5930              .FILLVALUE:
 126+ 5930 72               LD (HL), D
 127+ 5931 54               LD D, H
 128+ 5932 5D               LD E, L
 129+ 5933 13               INC DE
 130+ 5934 0B               DEC BC
 131+ 5935 ED B0            LDIR
 132+ 5937 C9               RET
 133+ 5938              ; *******************************************************************************************************
 134+ 5938
# file closed: asm\MEMORY.asm
 128  5938               ENDIF
 129  5938
 130  5938               IF (SOUND_CMDS == 1)
 131  5938               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5938              MUSIC_INIT_STATUS:
   2+ 5938 00            DB 0
   3+ 5939              SFX_INIT_STATUS:
   4+ 5939 00            DB 0
   5+ 593A              SOUND_ENABLED:
   6+ 593A 00            DB 0
   7+ 593B
   8+ 593B              ; *******************************************************************************************************
   9+ 593B              ; function to handle CALL SNDPLYINIT basic extension
  10+ 593B              ; initializes sound player
  11+ 593B              ; _SNDPLYINIT ( INT music_offset,
  12+ 593B              ;				INT sfx_offset, can be -1 if no SFX
  13+ 593B              ; will put ram in page 0 also, page 1 is already there
  14+ 593B              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 593B              SNDPLYINIT:
  16+ 593B              	; opening (
  17+ 593B CD C6 65     	CALL CHKCHAR
  18+ 593E 28           	DB '('
  19+ 593F              	; get music address
  20+ 593F DD 21 2F 54  	LD IX, FRMQNT
  21+ 5943 CD 59 01     	CALL CALBAS
  22+ 5946 D5           	PUSH DE
  23+ 5947              	; comma
  24+ 5947 CD C6 65     	CALL CHKCHAR
  25+ 594A 2C           	DB ','
  26+ 594B              	; get sfx address
  27+ 594B DD 21 2F 54  	LD IX, FRMQNT
  28+ 594F CD 59 01     	CALL CALBAS
  29+ 5952 D5           	PUSH DE
  30+ 5953              	; ending )
  31+ 5953 CD C6 65     	CALL CHKCHAR
  32+ 5956 29           	DB ')'
  33+ 5957
  34+ 5957                  ; save position in BASIC text
  35+ 5957 44           	LD B, H
  36+ 5958 4D           	LD C, L
  37+ 5959
  38+ 5959              	; pop LDIR parameters and store away for later
  39+ 5959 D1           	POP DE ; sfx address
  40+ 595A E1           	POP HL ; music address
  41+ 595B C5           	PUSH BC ; basic text location
  42+ 595C D9           	EXX
  43+ 595D FD 21 64 59  	LD IY, .RET
  44+ 5961 C3 78 65     	JP ENABLE_PAGE0
  45+ 5964              .RET:
  46+ 5964 D9           	EXX
  47+ 5965
  48+ 5965 D5           	PUSH DE
  49+ 5966 AF           	XOR A
  50+ 5967              	; HL = music location
  51+ 5967 CD 62 41     	CALL PLY_AKG_INIT
  52+ 596A 3E 01        	LD A, 1
  53+ 596C 32 38 59     	LD (MUSIC_INIT_STATUS), A
  54+ 596F
  55+ 596F E1           	POP HL ; SFX
  56+ 5970              	; check if SFX address -1
  57+ 5970 23           	INC HL
  58+ 5971 7D           	LD A, L
  59+ 5972 B4           	OR H
  60+ 5973 28 09        	JR Z,.L1
  61+ 5975 2B           	DEC HL
  62+ 5976 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 5979 3E 01        	LD A, 1
  64+ 597B 32 39 59     	LD (SFX_INIT_STATUS), A
  65+ 597E              .L1:
  66+ 597E D1               POP DE
  67+ 597F C1               POP BC
  68+ 5980 CD EF 64         CALL RESTORE_PAGE_INFO
  69+ 5983
  70+ 5983 E1           	POP HL
  71+ 5984 C9           	RET
  72+ 5985              ; *******************************************************************************************************
  73+ 5985
  74+ 5985              ; *******************************************************************************************************
  75+ 5985              ; function to handle CALL SNDPLYON basic extension
  76+ 5985              ; enables sound player
  77+ 5985              ; _SNDPLYON
  78+ 5985              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 5985              ; if not throws out of data error
  80+ 5985              SNDPLYON:
  81+ 5985 3A 38 59     	LD A, (MUSIC_INIT_STATUS)
  82+ 5988 B7           	OR A
  83+ 5989 20 05        	JR NZ, .L1
  84+ 598B              	; player not initialized, throw error
  85+ 598B 1E 04        	LD E, 04 ; Out of DATA
  86+ 598D C3 EC 65     	JP THROW_ERROR
  87+ 5990              .L1:
  88+ 5990 32 3A 59     	LD (SOUND_ENABLED), A
  89+ 5993              	; disable key click
  90+ 5993 AF           	XOR A
  91+ 5994 32 DB F3     	LD (CLIKSW), A
  92+ 5997 C9           	RET
  93+ 5998              ; *******************************************************************************************************
  94+ 5998
  95+ 5998              ; *******************************************************************************************************
  96+ 5998              ; function to handle CALL SNDPLYOFF basic extension
  97+ 5998              ; disables sound player
  98+ 5998              ; _SNDPLYOFF
  99+ 5998              ; sets SOUND_ENABLED variable to 0
 100+ 5998              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 5998              SNDPLYOFF:
 102+ 5998 3A 3A 59     	LD A, (SOUND_ENABLED)
 103+ 599B B7           	OR A
 104+ 599C C8           	RET Z ; already stopped
 105+ 599D AF           	XOR A
 106+ 599E 32 3A 59     	LD (SOUND_ENABLED), A
 107+ 59A1 E5           	PUSH HL
 108+ 59A2 CD 21 42     	CALL PLY_AKG_STOP
 109+ 59A5 3A 39 59     	LD A, (SFX_INIT_STATUS)
 110+ 59A8 B7           	OR A
 111+ 59A9 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 59AB AF           	XOR A
 113+ 59AC CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 59AF 3E 01        	LD A, 1
 115+ 59B1 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 59B4 3E 02        	LD A, 2
 117+ 59B6 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 59B9              .EXIT:
 119+ 59B9 E1           	POP HL
 120+ 59BA C9           	RET
 121+ 59BB              ; *******************************************************************************************************
 122+ 59BB
 123+ 59BB              ; *******************************************************************************************************
 124+ 59BB              ; function to handle CALL SNDSFX basic extension
 125+ 59BB              ; plays a sound effect
 126+ 59BB              ; _SNDSFX ( BYTE sfx_number, >0
 127+ 59BB              ;			BYTE channel, = 0,1 or 2
 128+ 59BB              ;			BYTE inverted_volume = 0-16, 0 being full volume
 129+ 59BB              ; will put ram in page 0 also, page 1 is already there
 130+ 59BB              ; if sound off throws illegal function call
 131+ 59BB              ; if sfx not initialized, throws out of data
 132+ 59BB              SNDSFX:
 133+ 59BB              	; opening (
 134+ 59BB CD C6 65     	CALL CHKCHAR
 135+ 59BE 28           	DB '('
 136+ 59BF              	; get sfx_number
 137+ 59BF DD 21 1C 52  	LD IX, GETBYT
 138+ 59C3 CD 59 01     	CALL CALBAS
 139+ 59C6 D5           	PUSH DE
 140+ 59C7              	; comma
 141+ 59C7 CD C6 65     	CALL CHKCHAR
 142+ 59CA 2C           	DB ','
 143+ 59CB              	; get sfx address
 144+ 59CB DD 21 1C 52  	LD IX, GETBYT
 145+ 59CF CD 59 01     	CALL CALBAS
 146+ 59D2 D5           	PUSH DE
 147+ 59D3              	; comma
 148+ 59D3 CD C6 65     	CALL CHKCHAR
 149+ 59D6 2C           	DB ','
 150+ 59D7              	; get inverted volume
 151+ 59D7 DD 21 1C 52  	LD IX, GETBYT
 152+ 59DB CD 59 01     	CALL CALBAS
 153+ 59DE D5           	PUSH DE
 154+ 59DF              	; ending )
 155+ 59DF CD C6 65     	CALL CHKCHAR
 156+ 59E2 29           	DB ')'
 157+ 59E3
 158+ 59E3 3A 3A 59     	LD A, (SOUND_ENABLED)
 159+ 59E6 B7           	OR A
 160+ 59E7 20 05        	JR NZ, .L1
 161+ 59E9              	; sound disabled, throw illegal function call
 162+ 59E9 1E 05        	LD E, 5
 163+ 59EB C3 EC 65     	JP THROW_ERROR
 164+ 59EE              .L1:
 165+ 59EE 3A 39 59     	LD A, (SFX_INIT_STATUS)
 166+ 59F1 B7           	OR A
 167+ 59F2 20 05        	JR NZ, .L2
 168+ 59F4              	; sfx data not initialized, throw out of data
 169+ 59F4 1E 04        	LD E, 4
 170+ 59F6 C3 EC 65     	JP THROW_ERROR
 171+ 59F9              .L2:
 172+ 59F9              	; pop  parameters and store away for later
 173+ 59F9 D1           	POP DE ; inverted volume
 174+ 59FA 43           	LD B, E
 175+ 59FB D1           	POP DE ; channel
 176+ 59FC 4B           	LD C, E
 177+ 59FD D1           	POP DE
 178+ 59FE 7B           	LD A, E
 179+ 59FF 08           	EX AF, AF'
 180+ 5A00 E5           	PUSH HL ; basic text location
 181+ 5A01 D9           	EXX
 182+ 5A02 FD 21 09 5A  	LD IY, .RET
 183+ 5A06 C3 78 65     	JP ENABLE_PAGE0
 184+ 5A09              .RET:
 185+ 5A09 D9           	EXX
 186+ 5A0A 08           	EX AF, AF'
 187+ 5A0B CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 188+ 5A0E
 189+ 5A0E D1               POP DE
 190+ 5A0F C1               POP BC
 191+ 5A10 CD EF 64         CALL RESTORE_PAGE_INFO
 192+ 5A13
 193+ 5A13 E1           	POP HL
 194+ 5A14 C9           	RET
 195+ 5A15              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
 132  5A15               ENDIF
 133  5A15
 134  5A15               IF (VRAM_CMDS == 1)
 135  5A15               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5A15              ; *******************************************************************************************************
   2+ 5A15              ; function to handle CALL FILVRM basic extension
   3+ 5A15              ; FILVRM ( INT offset,
   4+ 5A15              ;		   INT count,
   5+ 5A15              ;		   BYTE value,
   6+ 5A15              ;		   BYTE wait_vsync) >0 = true
   7+ 5A15              ; wait_vsync will issue HALT before copying
   8+ 5A15              FILVRM:
   9+ 5A15              	; opening (
  10+ 5A15 CD C6 65     	CALL CHKCHAR
  11+ 5A18 28           	DB '('
  12+ 5A19              	; get offset address
  13+ 5A19 DD 21 2F 54  	LD IX, FRMQNT
  14+ 5A1D CD 59 01     	CALL CALBAS
  15+ 5A20 D5           	PUSH DE
  16+ 5A21              	; comma
  17+ 5A21 CD C6 65     	CALL CHKCHAR
  18+ 5A24 2C           	DB ','
  19+ 5A25              	; get count
  20+ 5A25 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5A29 CD 59 01     	CALL CALBAS
  22+ 5A2C D5           	PUSH DE
  23+ 5A2D              	; comma
  24+ 5A2D CD C6 65     	CALL CHKCHAR
  25+ 5A30 2C           	DB ','
  26+ 5A31              	; get value
  27+ 5A31 DD 21 1C 52  	LD IX, GETBYT
  28+ 5A35 CD 59 01     	CALL CALBAS
  29+ 5A38 F5           	PUSH AF
  30+ 5A39              	; comma
  31+ 5A39 CD C6 65     	CALL CHKCHAR
  32+ 5A3C 2C           	DB ','
  33+ 5A3D              	; get vsync wait
  34+ 5A3D DD 21 1C 52  	LD IX, GETBYT
  35+ 5A41 CD 59 01     	CALL CALBAS
  36+ 5A44 F5           	PUSH AF
  37+ 5A45              	; ending )
  38+ 5A45 CD C6 65     	CALL CHKCHAR
  39+ 5A48 29           	DB ')'
  40+ 5A49
  41+ 5A49              	; save position
  42+ 5A49 E5           	PUSH HL
  43+ 5A4A DD E1        	POP IX
  44+ 5A4C
  45+ 5A4C              	; syntax ok
  46+ 5A4C              	; wait for vsync if needed
  47+ 5A4C F1           	POP AF
  48+ 5A4D B7           	OR A
  49+ 5A4E 28 01        	JR Z, .L1
  50+ 5A50 76           	HALT
  51+ 5A51
  52+ 5A51              .L1:
  53+ 5A51 3E 01        	LD A,1
  54+ 5A53 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  55+ 5A56 F1               POP AF ; value
  56+ 5A57 C1               POP BC ; count
  57+ 5A58 E1               POP HL ; offset
  58+ 5A59 CD 56 00         CALL BIOS_FILVRM
  59+ 5A5C AF           	XOR A
  60+ 5A5D 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  61+ 5A60
  62+ 5A60              .L3:
  63+ 5A60 DD E5        	PUSH IX
  64+ 5A62 E1           	POP HL
  65+ 5A63 C9           	RET
  66+ 5A64              ; *******************************************************************************************************
  67+ 5A64
  68+ 5A64              ; *******************************************************************************************************
  69+ 5A64              ; function to handle CALL MEMVRM basic extension
  70+ 5A64              ; copies from RAM to VRAM
  71+ 5A64              ; _MEMVRM ( INT source,
  72+ 5A64              ;			INT destination,
  73+ 5A64              ;			INT count,
  74+ 5A64              ;			BYTE wait_vsync) >0 = true
  75+ 5A64              ; will put ram in page 0 also, page 1 is already there
  76+ 5A64              ; wait_vsync will issue HALT before copying
  77+ 5A64              MEMVRM:
  78+ 5A64              	; opening (
  79+ 5A64 CD C6 65     	CALL CHKCHAR
  80+ 5A67 28           	DB '('
  81+ 5A68              	; get source address
  82+ 5A68 DD 21 2F 54  	LD IX, FRMQNT
  83+ 5A6C CD 59 01     	CALL CALBAS
  84+ 5A6F D5           	PUSH DE
  85+ 5A70              	; comma
  86+ 5A70 CD C6 65     	CALL CHKCHAR
  87+ 5A73 2C           	DB ','
  88+ 5A74              	; get destination address
  89+ 5A74 DD 21 2F 54  	LD IX, FRMQNT
  90+ 5A78 CD 59 01     	CALL CALBAS
  91+ 5A7B D5           	PUSH DE
  92+ 5A7C              	; comma
  93+ 5A7C CD C6 65     	CALL CHKCHAR
  94+ 5A7F 2C           	DB ','
  95+ 5A80              	; get length
  96+ 5A80 DD 21 2F 54  	LD IX, FRMQNT
  97+ 5A84 CD 59 01     	CALL CALBAS
  98+ 5A87 D5           	PUSH DE
  99+ 5A88              	; comma
 100+ 5A88 CD C6 65     	CALL CHKCHAR
 101+ 5A8B 2C           	DB ','
 102+ 5A8C              	; get vsync wait
 103+ 5A8C DD 21 1C 52  	LD IX, GETBYT
 104+ 5A90 CD 59 01     	CALL CALBAS
 105+ 5A93 F5           	PUSH AF
 106+ 5A94              	; ending )
 107+ 5A94 CD C6 65     	CALL CHKCHAR
 108+ 5A97 29           	DB ')'
 109+ 5A98
 110+ 5A98                  ; save position in BASIC text
 111+ 5A98 E5           	PUSH HL
 112+ 5A99 DD E1        	POP IX
 113+ 5A9B
 114+ 5A9B F1           	POP AF ; wait vsync
 115+ 5A9C B7           	OR A
 116+ 5A9D 28 02        	JR Z, .L1
 117+ 5A9F 76           	HALT
 118+ 5AA0 F3           	DI
 119+ 5AA1              .L1:
 120+ 5AA1              	; pop LDIR parameters and store away for later
 121+ 5AA1 C1           	POP BC ; count
 122+ 5AA2 D1           	POP DE ; vram destination
 123+ 5AA3 E1           	POP HL ; ram source
 124+ 5AA4 D9           	EXX
 125+ 5AA5 FD 21 AC 5A   	LD IY, .RET
 126+ 5AA9 C3 78 65     	JP ENABLE_PAGE0
 127+ 5AAC              .RET:
 128+ 5AAC FB           	EI
 129+ 5AAD D9           	EXX
 130+ 5AAE 3E 01        	LD A,1
 131+ 5AB0 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 132+ 5AB3 CD C3 5A     	CALL .LDIRVM
 133+ 5AB6 AF           	XOR A
 134+ 5AB7 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 135+ 5ABA D1               POP DE
 136+ 5ABB C1               POP BC
 137+ 5ABC CD EF 64         CALL RESTORE_PAGE_INFO
 138+ 5ABF DD E5        	PUSH IX
 139+ 5AC1 E1           	POP HL
 140+ 5AC2 C9           	RET
 141+ 5AC3
 142+ 5AC3              .LDIRVM:
 143+ 5AC3 EB           	EX DE, HL
 144+ 5AC4 F3           	DI
 145+ 5AC5 CD 9F 64     	CALL SETWRT_LOCAL
 146+ 5AC8 FB           	EI
 147+ 5AC9 EB           	EX DE, HL
 148+ 5ACA 78           	LD A, B
 149+ 5ACB B7           	OR A
 150+ 5ACC 28 0D        	JR Z, .L3
 151+ 5ACE C5           	PUSH BC
 152+ 5ACF 0E 98        	LD C, #98
 153+ 5AD1              .L2:
 154+ 5AD1 50           	LD D, B
 155+ 5AD2 06 00        	LD B, 0
 156+ 5AD4 CD AC 64     	CALL BBYTECOPY_NO_C
 157+ 5AD7 42           	LD B, D
 158+ 5AD8 10 F7        	DJNZ .L2
 159+ 5ADA C1           	POP BC
 160+ 5ADB              .L3:
 161+ 5ADB 79           	LD A, C
 162+ 5ADC B7           	OR A
 163+ 5ADD C8           	RET Z
 164+ 5ADE 41           	LD B, C
 165+ 5ADF C3 AA 64     	JP BBYTECOPY
 166+ 5AE2              ; *******************************************************************************************************
 167+ 5AE2
 168+ 5AE2              ; *******************************************************************************************************
 169+ 5AE2              ; function to handle CALL VRMMEM basic extension
 170+ 5AE2              ; copies from RAM to VRAM
 171+ 5AE2              ; _VRMMEM ( INT source,
 172+ 5AE2              ;			INT destination,
 173+ 5AE2              ;			INT count
 174+ 5AE2              ; will put ram in page 0 also, page 1 is already there
 175+ 5AE2              VRMMEM:
 176+ 5AE2              	; opening (
 177+ 5AE2 CD C6 65     	CALL CHKCHAR
 178+ 5AE5 28           	DB '('
 179+ 5AE6              	; get source address
 180+ 5AE6 DD 21 2F 54  	LD IX, FRMQNT
 181+ 5AEA CD 59 01     	CALL CALBAS
 182+ 5AED D5           	PUSH DE
 183+ 5AEE              	; comma
 184+ 5AEE CD C6 65     	CALL CHKCHAR
 185+ 5AF1 2C           	DB ','
 186+ 5AF2              	; get destination address
 187+ 5AF2 DD 21 2F 54  	LD IX, FRMQNT
 188+ 5AF6 CD 59 01     	CALL CALBAS
 189+ 5AF9 D5           	PUSH DE
 190+ 5AFA              	; comma
 191+ 5AFA CD C6 65     	CALL CHKCHAR
 192+ 5AFD 2C           	DB ','
 193+ 5AFE              	; get length
 194+ 5AFE DD 21 2F 54  	LD IX, FRMQNT
 195+ 5B02 CD 59 01     	CALL CALBAS
 196+ 5B05 D5           	PUSH DE
 197+ 5B06              	; ending )
 198+ 5B06 CD C6 65     	CALL CHKCHAR
 199+ 5B09 29           	DB ')'
 200+ 5B0A
 201+ 5B0A                  ; save position in BASIC text
 202+ 5B0A E5           	PUSH HL
 203+ 5B0B DD E1        	POP IX
 204+ 5B0D
 205+ 5B0D C1           	POP BC ; count
 206+ 5B0E D1           	POP DE ; destination
 207+ 5B0F E1           	POP HL ; source
 208+ 5B10 D9           	EXX
 209+ 5B11 FD 21 19 5B  	LD IY, .RET
 210+ 5B15 F3           	DI
 211+ 5B16 C3 78 65     	JP ENABLE_PAGE0
 212+ 5B19              .RET:
 213+ 5B19 FB           	EI
 214+ 5B1A D9           	EXX
 215+ 5B1B 3E 01        	LD A,1
 216+ 5B1D 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 217+ 5B20 CD 30 5B     	CALL .LDIRMV
 218+ 5B23 AF           	XOR A
 219+ 5B24 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 220+ 5B27 D1               POP DE
 221+ 5B28 C1               POP BC
 222+ 5B29 CD EF 64         CALL RESTORE_PAGE_INFO
 223+ 5B2C DD E5        	PUSH IX
 224+ 5B2E E1           	POP HL
 225+ 5B2F C9           	RET
 226+ 5B30
 227+ 5B30              .LDIRMV:
 228+ 5B30              	; set VRAM address *exactly* as in ROM, otherwise corruption
 229+ 5B30 7D           	LD	A, L
 230+ 5B31 F3           	DI
 231+ 5B32 D3 99        	OUT	(099H), A
 232+ 5B34 7C           	LD	A, H
 233+ 5B35 E6 3F        	AND	03FH
 234+ 5B37 D3 99        	OUT	(099H), A
 235+ 5B39 FB           	EI
 236+ 5B3A              	;EX (SP), HL
 237+ 5B3A              	;EX (SP), HL
 238+ 5B3A              	;NOP
 239+ 5B3A              	;NOP
 240+ 5B3A              .L4:
 241+ 5B3A DB 98            IN A, (#98)
 242+ 5B3C 12           	LD (DE), A
 243+ 5B3D 13               INC DE
 244+ 5B3E 0B               DEC BC
 245+ 5B3F 79               LD A, C
 246+ 5B40 B0               OR B
 247+ 5B41 20 F7            JR NZ, .L4
 248+ 5B43 C9               RET
 249+ 5B44              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 136  5B44               ENDIF
 137  5B44
 138  5B44               IF (GENCAL_CMD == 1)
 139  5B44               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5B44              ; *******************************************************************************************************
   2+ 5B44              ; function to handle CALL GENCAL basic extension
   3+ 5B44              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5B44              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5B44              ; output values of registers will also be stored at reg_list_ptr
   6+ 5B44              GENCAL:
   7+ 5B44              	; opening (
   8+ 5B44 CD C6 65     	CALL CHKCHAR
   9+ 5B47 28           	DB '('
  10+ 5B48              	; get function address
  11+ 5B48 DD 21 2F 54  	LD IX, FRMQNT
  12+ 5B4C CD 59 01     	CALL CALBAS
  13+ 5B4F D5           	PUSH DE
  14+ 5B50              	; comma
  15+ 5B50 CD C6 65     	CALL CHKCHAR
  16+ 5B53 2C           	DB ','
  17+ 5B54              	; get pointer to register list
  18+ 5B54 3E 02            LD A,2
  19+ 5B56 06 01            LD B,1
  20+ 5B58 11 00 05         LD DE,#0500
  21+ 5B5B CD F3 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  22+ 5B5E C5           	PUSH BC
  23+ 5B5F              	; ending )
  24+ 5B5F CD C6 65     	CALL CHKCHAR
  25+ 5B62 29           	DB ')'
  26+ 5B63
  27+ 5B63              	; save BASIC token position
  28+ 5B63 E5           	PUSH HL
  29+ 5B64 D9               EXX
  30+ 5B65 E1           	POP HL ; HL'=next basic token
  31+ 5B66 D9               EXX
  32+ 5B67
  33+ 5B67 E1               POP HL ; get pointer to register values
  34+ 5B68 F3           	DI
  35+ 5B69 ED 73 B8 62      LD (BLIT_STRUCT), SP
  36+ 5B6D F9               LD SP, HL
  37+ 5B6E F1               POP AF
  38+ 5B6F C1               POP BC
  39+ 5B70 D1               POP DE
  40+ 5B71 E1               POP HL
  41+ 5B72 DD E1            POP IX
  42+ 5B74 FD E1            POP IY
  43+ 5B76 D9               EXX
  44+ 5B77 ED 73 BA 62      LD (BLIT_STRUCT+2), SP
  45+ 5B7B ED 7B B8 62      LD SP, (BLIT_STRUCT)
  46+ 5B7F FB               EI
  47+ 5B80 D1               POP DE ; get function to call
  48+ 5B81 E5               PUSH HL
  49+ 5B82 CD 9D 5B         CALL .EXXDECALL
  50+ 5B85 F3               DI
  51+ 5B86 ED 73 B8 62      LD (BLIT_STRUCT), SP
  52+ 5B8A ED 7B BA 62      LD SP, (BLIT_STRUCT+2)
  53+ 5B8E FD E5            PUSH IY
  54+ 5B90 DD E5            PUSH IX
  55+ 5B92 E5               PUSH HL
  56+ 5B93 D5               PUSH DE
  57+ 5B94 C5               PUSH BC
  58+ 5B95 F5               PUSH AF
  59+ 5B96 ED 7B B8 62      LD SP, (BLIT_STRUCT)
  60+ 5B9A FB               EI
  61+ 5B9B E1               POP HL
  62+ 5B9C C9           	RET
  63+ 5B9D
  64+ 5B9D              .EXXDECALL:
  65+ 5B9D D5               PUSH DE
  66+ 5B9E D9               EXX
  67+ 5B9F C9               RET
  68+ 5BA0              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 140  5BA0               ENDIF
 141  5BA0
 142  5BA0               IF (BOX_CMDS == 1)
 143  5BA0               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5BA0              ; *******************************************************************************************************
   2+ 5BA0              ; generic function to implement rectangle data copy
   3+ 5BA0              ; should be modified to call appropriate function for memory or vram
   4+ 5BA0              ; input IX=pointer to following structure
   5+ 5BA0              ; +00 source data pointer
   6+ 5BA0              ; +02 num bytes in a row
   7+ 5BA0              ; +04 number of rows
   8+ 5BA0              ; +06 source add-to value till next row
   9+ 5BA0              ; +08 destination address
  10+ 5BA0              ; +10 destination add-to value till next row
  11+ 5BA0              ; modifies AF, BC, DE, HL
  12+ 5BA0              RECTANGLE_COPY:
  13+ 5BA0 DD 6E 00     	LD L, (IX+0)
  14+ 5BA3 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5BA6 DD 5E 08     	LD E, (IX+8)
  16+ 5BA9 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5BAC DD 46 04     	LD B, (IX+4) ; row number
  18+ 5BAF              .L1:
  19+ 5BAF C5           	PUSH BC
  20+ 5BB0 E5           		PUSH HL
  21+ 5BB1 D5           			PUSH DE
  22+ 5BB2 DD 4E 02     				LD C, (IX+2)
  23+ 5BB5 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5BB8              .CALL1:
  25+ 5BB8 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5BBB              .CALL2:
  27+ 5BBB CD 00 00     				CALL 0 ; copy data fn
  28+ 5BBE E1           			POP HL
  29+ 5BBF DD 4E 0A     			LD C, (IX+10)
  30+ 5BC2 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5BC5 09           			ADD HL, BC
  32+ 5BC6 EB           			EX DE, HL
  33+ 5BC7 E1           		POP HL
  34+ 5BC8 DD 4E 06     		LD C, (IX+6)
  35+ 5BCB DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5BCE 09           		ADD HL, BC
  37+ 5BCF C1           	POP BC
  38+ 5BD0 10 DD        	DJNZ .L1
  39+ 5BD2 C9           	RET
  40+ 5BD3              ; *******************************************************************************************************
  41+ 5BD3
  42+ 5BD3              ; *******************************************************************************************************
  43+ 5BD3              ; function to handle CALL BOXMEMCPY basic extension
  44+ 5BD3              ; copies data with window like boundaries within ram
  45+ 5BD3              ; BOXMEMCPY ( INT source data pointer,
  46+ 5BD3              ;			  INT source number of bytes in a row,
  47+ 5BD3              ;			  INT number of rows,
  48+ 5BD3              ;			  INT source add-to value till next row,
  49+ 5BD3              ; 			  INT destination pointer,
  50+ 5BD3              ;			  INT destination add-to value till next row )
  51+ 5BD3              ; request_data_ptr described in RECTANGLE_COPY
  52+ 5BD3              ; will put ram in page 0 also, page 1 is already there
  53+ 5BD3              BOXMEMCPY:
  54+ 5BD3 11 DD 5B     	LD DE,BOXMEMCPY.RET
  55+ 5BD6 ED 53 52 5C  	LD (BOXCOMMON.ADDR+2), DE
  56+ 5BDA C3 F0 5B     	JP BOXCOMMON
  57+ 5BDD              .RET:
  58+ 5BDD FB           	EI
  59+ 5BDE              	; set RAM functions to call
  60+ 5BDE 21 00 00     	LD HL, 0
  61+ 5BE1 22 B8 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  62+ 5BE4 22 BA 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  63+ 5BE7 21 ED B0     	LD HL, #B0ED ; LDIR
  64+ 5BEA 22 BC 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  65+ 5BED C3 57 5C     	JP BOXCOMMON.CALL
  66+ 5BF0              ; *******************************************************************************************************
  67+ 5BF0
  68+ 5BF0              ; *******************************************************************************************************
  69+ 5BF0              ; common parts of BOX commands
  70+ 5BF0              BOXCOMMON:
  71+ 5BF0              	; opening (
  72+ 5BF0 CD C6 65     	CALL CHKCHAR
  73+ 5BF3 28           	DB '('
  74+ 5BF4              	; get source data pointer
  75+ 5BF4 DD 21 2F 54  	LD IX, FRMQNT
  76+ 5BF8 CD 59 01     	CALL CALBAS
  77+ 5BFB ED 53 B8 62  	LD (BLIT_STRUCT+0), DE
  78+ 5BFF              	; comma
  79+ 5BFF CD C6 65     	CALL CHKCHAR
  80+ 5C02 2C           	DB ','
  81+ 5C03              	; source number of bytes in a row
  82+ 5C03 DD 21 2F 54  	LD IX, FRMQNT
  83+ 5C07 CD 59 01     	CALL CALBAS
  84+ 5C0A ED 53 BA 62  	LD (BLIT_STRUCT+2), DE
  85+ 5C0E              	; comma
  86+ 5C0E CD C6 65     	CALL CHKCHAR
  87+ 5C11 2C           	DB ','
  88+ 5C12              	; number of rows
  89+ 5C12 DD 21 2F 54  	LD IX, FRMQNT
  90+ 5C16 CD 59 01     	CALL CALBAS
  91+ 5C19 ED 53 BC 62  	LD (BLIT_STRUCT+4), DE
  92+ 5C1D              	; comma
  93+ 5C1D CD C6 65     	CALL CHKCHAR
  94+ 5C20 2C           	DB ','
  95+ 5C21              	; source add-to value till next row
  96+ 5C21 DD 21 2F 54  	LD IX, FRMQNT
  97+ 5C25 CD 59 01     	CALL CALBAS
  98+ 5C28 ED 53 BE 62  	LD (BLIT_STRUCT+6), DE
  99+ 5C2C              	; comma
 100+ 5C2C CD C6 65     	CALL CHKCHAR
 101+ 5C2F 2C           	DB ','
 102+ 5C30              	; destination pointer
 103+ 5C30 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5C34 CD 59 01     	CALL CALBAS
 105+ 5C37 ED 53 C0 62  	LD (BLIT_STRUCT+8), DE
 106+ 5C3B              	; comma
 107+ 5C3B CD C6 65     	CALL CHKCHAR
 108+ 5C3E 2C           	DB ','
 109+ 5C3F              	; destination add-to value till next row
 110+ 5C3F DD 21 2F 54  	LD IX, FRMQNT
 111+ 5C43 CD 59 01     	CALL CALBAS
 112+ 5C46 ED 53 C2 62  	LD (BLIT_STRUCT+10), DE
 113+ 5C4A              	; ending )
 114+ 5C4A CD C6 65     	CALL CHKCHAR
 115+ 5C4D 29           	DB ')'
 116+ 5C4E
 117+ 5C4E E5           	PUSH HL ; save position in BASIC buffer
 118+ 5C4F F3           	DI
 119+ 5C50              .ADDR:
 120+ 5C50 FD 21 00 00  	LD IY, 0
 121+ 5C54 C3 78 65     	JP ENABLE_PAGE0
 122+ 5C57              .CALL:
 123+ 5C57 DD 21 B8 62  	LD IX,BLIT_STRUCT
 124+ 5C5B CD A0 5B     	CALL RECTANGLE_COPY
 125+ 5C5E AF           	XOR A
 126+ 5C5F 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 127+ 5C62
 128+ 5C62 D1               POP DE
 129+ 5C63 C1               POP BC
 130+ 5C64 CD EF 64         CALL RESTORE_PAGE_INFO
 131+ 5C67
 132+ 5C67 E1           	POP HL
 133+ 5C68 C9           	RET
 134+ 5C69              ; *******************************************************************************************************
 135+ 5C69
 136+ 5C69              ; *******************************************************************************************************
 137+ 5C69              ; function to handle CALL BOXMEMVRM basic extension
 138+ 5C69              ; copies data with window like boundaries from ram to Vram
 139+ 5C69              ; BOXMEMVRM ( INT source data pointer,
 140+ 5C69              ;			  INT source number of bytes in a row,
 141+ 5C69              ;			  INT number of rows,
 142+ 5C69              ;			  INT source add-to value till next row,
 143+ 5C69              ; 			  INT destination pointer,
 144+ 5C69              ;			  INT destination add-to value till next row )
 145+ 5C69              ; request_data_ptr described in RECTANGLE_COPY
 146+ 5C69              ; will put ram in page 0 also, page 1 is already there
 147+ 5C69              BOXMEMVRM:
 148+ 5C69 11 73 5C     	LD DE,BOXMEMVRM.RET
 149+ 5C6C ED 53 52 5C  	LD (BOXCOMMON.ADDR+2), DE
 150+ 5C70 C3 F0 5B     	JP BOXCOMMON
 151+ 5C73              .RET:
 152+ 5C73 FB           	EI
 153+ 5C74              	; set RAM functions to call
 154+ 5C74 21 8E 5C     	LD HL, .SETDEST
 155+ 5C77 22 B9 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 156+ 5C7A 21 96 5C     	LD HL, .COPYDATA
 157+ 5C7D 22 BC 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 158+ 5C80 3E CD        	LD A, #CD ; CALL
 159+ 5C82 32 B8 5B     	LD (RECTANGLE_COPY.CALL1), A
 160+ 5C85 32 BB 5B     	LD (RECTANGLE_COPY.CALL2), A
 161+ 5C88              	;LD A,1
 162+ 5C88 32 C9 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 163+ 5C8B C3 57 5C     	JP BOXCOMMON.CALL
 164+ 5C8E              .SETDEST:
 165+ 5C8E EB           	EX DE, HL
 166+ 5C8F F3           	DI
 167+ 5C90 CD 9F 64     	CALL SETWRT_LOCAL
 168+ 5C93 FB           	EI
 169+ 5C94 EB           	EX DE, HL
 170+ 5C95 C9           	RET
 171+ 5C96              .COPYDATA:
 172+ 5C96 41           	LD B, C
 173+ 5C97 C3 AA 64     	JP BBYTECOPY
 174+ 5C9A              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 144  5C9A               ENDIF
 145  5C9A
 146  5C9A               IF (BLIT_CMDS == 1)
 147  5C9A               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C9A              ; *******************************************************************************************************
   2+ 5C9A              ; function rotates mask and data of several characters and applies to background data
   3+ 5C9A              ; this handles x-shift from 0 to 4
   4+ 5C9A              ; contains self-modifying code that is set-up from external function
   5+ 5C9A              ; input HL=pointer to mask data
   6+ 5C9A              ; input HL'=pointer to character data
   7+ 5C9A              ; input DE=output buffer containing background data
   8+ 5C9A              ; input BC=DE+8
   9+ 5C9A              ; input A=number of characters to process
  10+ 5C9A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C9A              SHIFT04:
  12+ 5C9A 08           	EX AF, AF'
  13+ 5C9B 7E           	LD A, (HL) ; get mask
  14+ 5C9C D9           	EXX
  15+ 5C9D 57           	LD D, A
  16+ 5C9E 1E FF        	LD E, #FF
  17+ 5CA0 37           	SCF
  18+ 5CA1              .M1:
  19+ 5CA1 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5CA3 CB 1A        	RR D
  21+ 5CA5 CB 1B        	RR E
  22+ 5CA7 CB 1A        	RR D
  23+ 5CA9 CB 1B        	RR E
  24+ 5CAB CB 1A        	RR D
  25+ 5CAD CB 1B        	RR E
  26+ 5CAF CB 1A        	RR D
  27+ 5CB1 CB 1B        	RR E
  28+ 5CB3
  29+ 5CB3 46           	LD B, (HL) ; get data
  30+ 5CB4 0E 00        	LD C, 0
  31+ 5CB6              .M2:
  32+ 5CB6 18 FE        	JR .M2 ; also self-modifying part
  33+ 5CB8 CB 38        	SRL B
  34+ 5CBA CB 19        	RR C
  35+ 5CBC CB 38        	SRL B
  36+ 5CBE CB 19        	RR C
  37+ 5CC0 CB 38        	SRL B
  38+ 5CC2 CB 19        	RR C
  39+ 5CC4 CB 38        	SRL B
  40+ 5CC6 CB 19        	RR C
  41+ 5CC8
  42+ 5CC8 D9           	EXX
  43+ 5CC9 1A           	LD A, (DE) ; background
  44+ 5CCA D9           	EXX
  45+ 5CCB A2           	AND D
  46+ 5CCC B0           	OR B
  47+ 5CCD D9           	EXX
  48+ 5CCE 12           	LD (DE), A
  49+ 5CCF
  50+ 5CCF 0A           	LD A, (BC)
  51+ 5CD0 D9           	EXX
  52+ 5CD1 A3           	AND E
  53+ 5CD2 B1           	OR C
  54+ 5CD3 23           	INC HL
  55+ 5CD4 D9           	EXX
  56+ 5CD5 02           	LD (BC), A
  57+ 5CD6
  58+ 5CD6 23           	INC HL
  59+ 5CD7 13           	INC DE
  60+ 5CD8 03           	INC BC
  61+ 5CD9
  62+ 5CD9 08           	EX AF, AF'
  63+ 5CDA 3D           	DEC A
  64+ 5CDB C2 9A 5C     	JP NZ, SHIFT04
  65+ 5CDE C9           	RET
  66+ 5CDF              ; *******************************************************************************************************
  67+ 5CDF
  68+ 5CDF              ; *******************************************************************************************************
  69+ 5CDF              ; function rotates mask and data of several characters and applies to background data
  70+ 5CDF              ; this handles x-shift from 5 to 8
  71+ 5CDF              ; contains self-modifying code that is set-up from external function
  72+ 5CDF              ; input HL=pointer to mask data
  73+ 5CDF              ; input HL'=pointer to character data
  74+ 5CDF              ; input DE=output buffer containing background data
  75+ 5CDF              ; input BC=DE+8
  76+ 5CDF              ; input A=number of characters to process
  77+ 5CDF              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5CDF              SHIFT58:
  79+ 5CDF 08           	EX AF, AF'
  80+ 5CE0 7E           	LD A, (HL) ; get mask
  81+ 5CE1 D9           	EXX
  82+ 5CE2 57           	LD D, A
  83+ 5CE3 1E FF        	LD E, #FF
  84+ 5CE5 37           	SCF
  85+ 5CE6              .M1:
  86+ 5CE6 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5CE8 CB 12        	RL D
  88+ 5CEA CB 13        	RL E
  89+ 5CEC CB 12        	RL D
  90+ 5CEE CB 13        	RL E
  91+ 5CF0 CB 12        	RL D
  92+ 5CF2 CB 13        	RL E
  93+ 5CF4
  94+ 5CF4 46           	LD B, (HL)
  95+ 5CF5 0E 00        	LD C, 0
  96+ 5CF7              .M2:
  97+ 5CF7 18 FE        	JR .M2 ; also self-modifying part
  98+ 5CF9 CB 20        	SLA B
  99+ 5CFB CB 11        	RL C
 100+ 5CFD CB 20        	SLA B
 101+ 5CFF CB 11        	RL C
 102+ 5D01 CB 20        	SLA B
 103+ 5D03 CB 11        	RL C
 104+ 5D05
 105+ 5D05 D9           	EXX
 106+ 5D06 1A           	LD A, (DE) ; background
 107+ 5D07 D9           	EXX
 108+ 5D08 A3           	AND E
 109+ 5D09 B1           	OR C
 110+ 5D0A D9           	EXX
 111+ 5D0B 12           	LD (DE), A
 112+ 5D0C
 113+ 5D0C 0A           	LD A, (BC)
 114+ 5D0D D9           	EXX
 115+ 5D0E A2           	AND D
 116+ 5D0F B0           	OR B
 117+ 5D10 23           	INC HL
 118+ 5D11 D9           	EXX
 119+ 5D12 02           	LD (BC), A
 120+ 5D13
 121+ 5D13 23           	INC HL
 122+ 5D14 13           	INC DE
 123+ 5D15 03           	INC BC
 124+ 5D16
 125+ 5D16 08           	EX AF, AF'
 126+ 5D17 3D           	DEC A
 127+ 5D18 C2 DF 5C     	JP NZ, SHIFT58
 128+ 5D1B C9           	RET
 129+ 5D1C              ; *******************************************************************************************************
 130+ 5D1C
 131+ 5D1C              ; *******************************************************************************************************
 132+ 5D1C              ; routine that shifts one row of characters
 133+ 5D1C              ; contains self-modifying code that is set-up from external function
 134+ 5D1C              ; input HL=pointer to mask data
 135+ 5D1C              ; input HL'=pointer to character data
 136+ 5D1C              ; input DE=output buffer containing background data
 137+ 5D1C              ; input A=number of characters to process
 138+ 5D1C              ; input IX=pointer to structure describing input data
 139+ 5D1C              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5D1C              SHIFT_ROW:
 141+ 5D1C F5           	PUSH AF
 142+ 5D1D ED 53 B4 62  		LD (BLIT_TMP1), DE
 143+ 5D21 E5           		PUSH HL
 144+ 5D22 CD 65 5D     			CALL .ADDYSHIFT
 145+ 5D25 E1           		POP HL
 146+ 5D26 ED 53 B6 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5D2A              .L1:
 148+ 5D2A 3E 08        		LD A, 8
 149+ 5D2C DD 96 02     		SUB (IX+2) ; y shift
 150+ 5D2F              .CALL1:
 151+ 5D2F CD 00 00     		CALL 0
 152+ 5D32 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5D35 B7           		OR A
 154+ 5D36 28 26        		JR Z, .DONE
 155+ 5D38 ED 5B B4 62  		LD DE, (BLIT_TMP1)
 156+ 5D3C E5           		PUSH HL
 157+ 5D3D CD 73 5D     			CALL .DETONEXTROW
 158+ 5D40 E1           		POP HL
 159+ 5D41              .CALL2:
 160+ 5D41 CD 00 00     		CALL 0
 161+ 5D44 ED 5B B4 62  		LD DE, (BLIT_TMP1)
 162+ 5D48 E5           		PUSH HL
 163+ 5D49 CD 6D 5D     			CALL .ADD8
 164+ 5D4C E1           		POP HL
 165+ 5D4D ED 53 B4 62  		LD (BLIT_TMP1), DE
 166+ 5D51 ED 5B B6 62  		LD DE, (BLIT_TMP2)
 167+ 5D55 E5           		PUSH HL
 168+ 5D56 CD 6D 5D     			CALL .ADD8
 169+ 5D59 E1           		POP HL
 170+ 5D5A ED 53 B6 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5D5E              .DONE:
 172+ 5D5E F1           	POP AF
 173+ 5D5F 3D           	DEC A
 174+ 5D60 C8           	RET Z
 175+ 5D61 F5           	PUSH AF
 176+ 5D62 C3 2A 5D     	JP .L1
 177+ 5D65              .ADDYSHIFT:
 178+ 5D65 EB           	EX DE, HL
 179+ 5D66 16 00        	LD D, 0
 180+ 5D68 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5D6B 18 0C        	JR .MOVDEBC
 182+ 5D6D              .ADD8:
 183+ 5D6D 21 08 00     	LD HL, 8
 184+ 5D70 C3 79 5D     	JP .MOVDEBC
 185+ 5D73              .DETONEXTROW:
 186+ 5D73 DD 6E 06     	LD L, (IX+6)
 187+ 5D76 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D79              .MOVDEBC:
 189+ 5D79 19           	ADD HL, DE
 190+ 5D7A 54           	LD D, H
 191+ 5D7B 5D           	LD E, L
 192+ 5D7C 01 08 00     	LD BC, 8
 193+ 5D7F 09           	ADD HL, BC
 194+ 5D80 44           	LD B, H
 195+ 5D81 4D           	LD C, L
 196+ 5D82 C9           	RET
 197+ 5D83              ; *******************************************************************************************************
 198+ 5D83
 199+ 5D83              ; *******************************************************************************************************
 200+ 5D83              ; function rotates mask and character data and applies it to background
 201+ 5D83              ; input IX=pointer to structure describing input data
 202+ 5D83              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D83              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D83              ; +4  DW background data start;
 205+ 5D83              ; +6  DW background add to value to next row of background data
 206+ 5D83              ; +8  DW mask data start;
 207+ 5D83              ; +10  DW character data start;
 208+ 5D83              ; +12 DW character&mask add to value to next row of data
 209+ 5D83              ; +14 DW columns (low byte used)
 210+ 5D83              ; +16 DW rows (low byte used)
 211+ 5D83              SHIFT_MERGE_CHARACTER:
 212+ 5D83 DD 7E 00     	LD A, (IX) ; shift
 213+ 5D86 FE 05        	CP 5
 214+ 5D88 38 25        	JR C, .RIGHT
 215+ 5D8A              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D8A 21 DF 5C     	LD HL, SHIFT58
 217+ 5D8D 22 30 5D     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D90 22 42 5D     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D93 D6 05        	SUB 5
 220+ 5D95 28 0D        	JR Z, .L1
 221+ 5D97 87           	ADD A, A
 222+ 5D98 87           	ADD A, A
 223+ 5D99 67           	LD H, A
 224+ 5D9A 2E 18        	LD L, #18 ; JR opcode
 225+ 5D9C 22 E6 5C     	LD (SHIFT58.M1), HL
 226+ 5D9F 22 F7 5C     	LD (SHIFT58.M2), HL
 227+ 5DA2 18 32        	JR .DO
 228+ 5DA4              .L1:
 229+ 5DA4 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5DA7 22 E6 5C     	LD (SHIFT58.M1), HL
 231+ 5DAA 22 F7 5C     	LD (SHIFT58.M2), HL
 232+ 5DAD 18 27        	JR .DO
 233+ 5DAF              .RIGHT:
 234+ 5DAF              	; shifts 0-4, rotate towards right
 235+ 5DAF 21 9A 5C     	LD HL, SHIFT04
 236+ 5DB2 22 30 5D     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5DB5 22 42 5D     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5DB8 FE 04        	CP 4
 239+ 5DBA 28 11        	JR Z, .R1
 240+ 5DBC D6 04        	SUB 4
 241+ 5DBE ED 44        	NEG
 242+ 5DC0 87           	ADD A, A
 243+ 5DC1 87           	ADD A, A
 244+ 5DC2 67           	LD H, A
 245+ 5DC3 2E 18        	LD L, #18 ; JR opcode
 246+ 5DC5 22 A1 5C     	LD (SHIFT04.M1), HL
 247+ 5DC8 22 B6 5C     	LD (SHIFT04.M2), HL
 248+ 5DCB 18 09        	JR .DO
 249+ 5DCD              .R1:
 250+ 5DCD 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5DD0 22 A1 5C     	LD (SHIFT04.M1), HL
 252+ 5DD3 22 B6 5C     	LD (SHIFT04.M2), HL
 253+ 5DD6              .DO:
 254+ 5DD6 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5DD9 DD 6E 08     	LD L, (IX+8)
 256+ 5DDC DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5DDF DD 5E 04     	LD E, (IX+4)
 258+ 5DE2 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5DE5 D9           	EXX
 260+ 5DE6 DD 6E 0A     	LD L, (IX+10)
 261+ 5DE9 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5DEC D9           	EXX
 263+ 5DED              .LOOP:
 264+ 5DED C5           	PUSH BC
 265+ 5DEE E5           		PUSH HL
 266+ 5DEF D5           			PUSH DE
 267+ 5DF0 D9           				EXX
 268+ 5DF1 E5           				PUSH HL
 269+ 5DF2 D9           					EXX
 270+ 5DF3 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5DF6              .CALL:
 272+ 5DF6 CD 1C 5D     					CALL SHIFT_ROW
 273+ 5DF9 E1           				POP HL
 274+ 5DFA DD 5E 0C     				LD E, (IX+12)
 275+ 5DFD DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5E00 19           				ADD HL, DE
 277+ 5E01 D9           				EXX
 278+ 5E02 E1           			POP HL
 279+ 5E03 DD 5E 06     			LD E, (IX+6)
 280+ 5E06 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5E09 19           			ADD HL, DE
 282+ 5E0A EB           			EX DE, HL
 283+ 5E0B E1           		POP HL
 284+ 5E0C DD 4E 0C     		LD C, (IX+12)
 285+ 5E0F DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5E12 09           		ADD HL, BC
 287+ 5E13 C1           	POP BC
 288+ 5E14 10 D7        	DJNZ .LOOP
 289+ 5E16 C9           	RET
 290+ 5E17              ; *******************************************************************************************************
 291+ 5E17
 292+ 5E17               IFNDEF CMDS_WITH_PARAMETERS
 293+ 5E17 ~            ; *******************************************************************************************************
 294+ 5E17 ~            ; function to handle CALL BLIT basic extension
 295+ 5E17 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 296+ 5E17 ~            ; fuses with background data and applies vertical shift too
 297+ 5E17 ~            ; BLIT ( INT request_data_ptr )
 298+ 5E17 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
 299+ 5E17 ~            ; will put ram in page 0 also, page 1 is already there
 300+ 5E17 ~            BLIT:
 301+ 5E17 ~            	; opening (
 302+ 5E17 ~            	CALL CHKCHAR
 303+ 5E17 ~            	DB '('
 304+ 5E17 ~            	; get pointer to request struct
 305+ 5E17 ~            	LD IX, FRMQNT
 306+ 5E17 ~            	CALL CALBAS
 307+ 5E17 ~            	PUSH DE
 308+ 5E17 ~            	; ending )
 309+ 5E17 ~            	CALL CHKCHAR
 310+ 5E17 ~            	DB ')'
 311+ 5E17 ~
 312+ 5E17 ~            	POP IX ; pointer to request struct
 313+ 5E17 ~
 314+ 5E17 ~            	PUSH HL ; save position in BASIC buffer
 315+ 5E17 ~
 316+ 5E17 ~            	LD IY, .RET
 317+ 5E17 ~            	JP ENABLE_PAGE0
 318+ 5E17 ~            .RET:
 319+ 5E17 ~            	EI
 320+ 5E17 ~            	CALL SHIFT_MERGE_CHARACTER
 321+ 5E17 ~
 322+ 5E17 ~                POP DE
 323+ 5E17 ~                POP BC
 324+ 5E17 ~                CALL RESTORE_PAGE_INFO
 325+ 5E17 ~
 326+ 5E17 ~            	POP HL
 327+ 5E17 ~            	RET
 328+ 5E17 ~            ; *******************************************************************************************************
 329+ 5E17               ENDIF
 330+ 5E17
 331+ 5E17               IFDEF CMDS_WITH_PARAMETERS
 332+ 5E17              ; *******************************************************************************************************
 333+ 5E17              ; function to handle CALL BLIT basic extension
 334+ 5E17              ; rotates 1-bit character drawing horizontally with mask and character data and
 335+ 5E17              ; fuses with background data and applies vertical shift too
 336+ 5E17              ; in form without pointers
 337+ 5E17              ; BLIT ( INT x,
 338+ 5E17              ;		 INT y,
 339+ 5E17              ;		 INT char_data_pointer,
 340+ 5E17              ;		 INT mask_data_pointer,
 341+ 5E17              ;		 INT width (in characters),
 342+ 5E17              ;		 INT height (in characters),
 343+ 5E17              ;		 INT background_pointer (top left),
 344+ 5E17              ;		 INT background_width (in characters),
 345+ 5E17              ;		 INT background_height (in characters))
 346+ 5E17              ; will put ram in page 0 also, page 1 is already there
 347+ 5E17              BLIT:
 348+ 5E17              	; opening (
 349+ 5E17 CD C6 65     	CALL CHKCHAR
 350+ 5E1A 28           	DB '('
 351+ 5E1B              	; get x coordinate
 352+ 5E1B DD 21 2F 54  	LD IX, FRMQNT
 353+ 5E1F CD 59 01     	CALL CALBAS
 354+ 5E22 7B           	LD A, E
 355+ 5E23 E6 07        	AND 7
 356+ 5E25 32 B8 62     	LD (BLIT_STRUCT+0), A
 357+ 5E28 CD 06 5F     	CALL .DAdiv8
 358+ 5E2B 32 B4 62     	LD (BLIT_TMP+0),A
 359+ 5E2E              	; comma
 360+ 5E2E CD C6 65     	CALL CHKCHAR
 361+ 5E31 2C           	DB ','
 362+ 5E32              	; get y coordinate
 363+ 5E32 DD 21 2F 54  	LD IX, FRMQNT
 364+ 5E36 CD 59 01     	CALL CALBAS
 365+ 5E39 7B           	LD A, E
 366+ 5E3A E6 07        	AND 7
 367+ 5E3C 32 BA 62     	LD (BLIT_STRUCT+2), A
 368+ 5E3F CD 06 5F     	CALL .DAdiv8
 369+ 5E42 32 B5 62     	LD (BLIT_TMP+1),A
 370+ 5E45              	; comma
 371+ 5E45 CD C6 65     	CALL CHKCHAR
 372+ 5E48 2C           	DB ','
 373+ 5E49              	; get char data pointer
 374+ 5E49 DD 21 2F 54  	LD IX, FRMQNT
 375+ 5E4D CD 59 01     	CALL CALBAS
 376+ 5E50 ED 53 C2 62  	LD (BLIT_STRUCT+10), DE
 377+ 5E54              	; comma
 378+ 5E54 CD C6 65     	CALL CHKCHAR
 379+ 5E57 2C           	DB ','
 380+ 5E58              	; get mask data pointer
 381+ 5E58 DD 21 2F 54  	LD IX, FRMQNT
 382+ 5E5C CD 59 01     	CALL CALBAS
 383+ 5E5F ED 53 C0 62  	LD (BLIT_STRUCT+8), DE
 384+ 5E63              	; comma
 385+ 5E63 CD C6 65     	CALL CHKCHAR
 386+ 5E66 2C           	DB ','
 387+ 5E67              	; get width
 388+ 5E67 DD 21 2F 54  	LD IX, FRMQNT
 389+ 5E6B CD 59 01     	CALL CALBAS
 390+ 5E6E 7B           	LD A, E
 391+ 5E6F 32 C6 62     	LD (BLIT_STRUCT+14), A
 392+ 5E72              	; comma
 393+ 5E72 CD C6 65     	CALL CHKCHAR
 394+ 5E75 2C           	DB ','
 395+ 5E76              	; get height
 396+ 5E76 DD 21 2F 54  	LD IX, FRMQNT
 397+ 5E7A CD 59 01     	CALL CALBAS
 398+ 5E7D 7B           	LD A, E
 399+ 5E7E 32 C8 62     	LD (BLIT_STRUCT+16), A
 400+ 5E81              	; comma
 401+ 5E81 CD C6 65     	CALL CHKCHAR
 402+ 5E84 2C           	DB ','
 403+ 5E85              	; get background pointer
 404+ 5E85 DD 21 2F 54  	LD IX, FRMQNT
 405+ 5E89 CD 59 01     	CALL CALBAS
 406+ 5E8C ED 53 BC 62  	LD (BLIT_STRUCT+4), DE
 407+ 5E90              	; comma
 408+ 5E90 CD C6 65     	CALL CHKCHAR
 409+ 5E93 2C           	DB ','
 410+ 5E94              	; get background width
 411+ 5E94 DD 21 2F 54  	LD IX, FRMQNT
 412+ 5E98 CD 59 01     	CALL CALBAS
 413+ 5E9B 7B           	LD A, E
 414+ 5E9C 32 B6 62     	LD (BLIT_TMP+2), A
 415+ 5E9F              	; comma
 416+ 5E9F CD C6 65     	CALL CHKCHAR
 417+ 5EA2 2C           	DB ','
 418+ 5EA3              	; get background height
 419+ 5EA3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5EA7 CD 59 01     	CALL CALBAS
 421+ 5EAA 7B           	LD A, E
 422+ 5EAB 32 B7 62     	LD (BLIT_TMP+3), A
 423+ 5EAE              	; ending )
 424+ 5EAE CD C6 65     	CALL CHKCHAR
 425+ 5EB1 29           	DB ')'
 426+ 5EB2
 427+ 5EB2 E5           	PUSH HL ; save position in BASIC buffer
 428+ 5EB3
 429+ 5EB3              	; calculate char&mask add to value
 430+ 5EB3 26 00        	LD H, 0
 431+ 5EB5 3A C6 62     	LD A, (BLIT_STRUCT+14)
 432+ 5EB8 6F           	LD L, A
 433+ 5EB9 CD B4 64     	CALL HLx8
 434+ 5EBC 22 C4 62     	LD (BLIT_STRUCT+12), HL
 435+ 5EBF              	; calculate background add to value
 436+ 5EBF 26 00        	LD H, 0
 437+ 5EC1 3A B6 62     	LD A, (BLIT_TMP+2)
 438+ 5EC4 6F           	LD L, A
 439+ 5EC5 CD B4 64     	CALL HLx8
 440+ 5EC8 22 BE 62     	LD (BLIT_STRUCT+6), HL
 441+ 5ECB              	; calculate pointer to background location
 442+ 5ECB 21 00 00     	LD HL, 0
 443+ 5ECE 3A B5 62     	LD A,(BLIT_TMP+1)
 444+ 5ED1 B7           	OR A
 445+ 5ED2 28 08        	JR Z, .L1
 446+ 5ED4 47           	LD B,A
 447+ 5ED5 ED 5B BE 62  	LD DE,(BLIT_STRUCT+6)
 448+ 5ED9              .L0:
 449+ 5ED9 19           	ADD HL, DE
 450+ 5EDA 10 FD        	DJNZ .L0
 451+ 5EDC              .L1:
 452+ 5EDC EB           	EX DE,HL
 453+ 5EDD 26 00        	LD H,0
 454+ 5EDF 3A B4 62     	LD A,(BLIT_TMP+0)
 455+ 5EE2 6F           	LD L,A
 456+ 5EE3 CD B4 64     	CALL HLx8
 457+ 5EE6 19           	ADD HL,DE
 458+ 5EE7 ED 5B BC 62  	LD DE,(BLIT_STRUCT+4)
 459+ 5EEB 19           	ADD HL,DE
 460+ 5EEC 22 BC 62     	LD (BLIT_STRUCT+4),HL
 461+ 5EEF
 462+ 5EEF F3           	DI
 463+ 5EF0 FD 21 F7 5E  	LD IY, .RET
 464+ 5EF4 C3 78 65     	JP ENABLE_PAGE0
 465+ 5EF7              .RET:
 466+ 5EF7 FB           	EI
 467+ 5EF8 DD 21 B8 62  	LD IX, BLIT_STRUCT
 468+ 5EFC CD 83 5D     	CALL SHIFT_MERGE_CHARACTER
 469+ 5EFF
 470+ 5EFF D1               POP DE
 471+ 5F00 C1               POP BC
 472+ 5F01 CD EF 64         CALL RESTORE_PAGE_INFO
 473+ 5F04
 474+ 5F04 E1           	POP HL
 475+ 5F05 C9           	RET
 476+ 5F06              .DAdiv8:
 477+ 5F06 7B           	LD A,E
 478+ 5F07 CB 2A        	SRA D
 479+ 5F09 CB 1F            RR  A
 480+ 5F0B CB 2A            SRA D
 481+ 5F0D CB 1F            RR  A
 482+ 5F0F CB 2A            SRA D
 483+ 5F11 CB 1F            RR  A
 484+ 5F13 C9           	RET
 485+ 5F14              ; *******************************************************************************************************
 486+ 5F14               ENDIF
# file closed: asm\BLIT.asm
 148  5F14               ENDIF
 149  5F14
 150  5F14               IF (TILE_CMDS == 1)
 151  5F14               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5F14              ; *******************************************************************************************************
   2+ 5F14              ; generic function to implement tiling
   3+ 5F14              ; should be modified to call appropriate function for memory or vram
   4+ 5F14              ; input IX=pointer to following structure
   5+ 5F14              ; +00 tile_data_ptr
   6+ 5F14              ; +02 tile_rows
   7+ 5F14              ; +04 tile_columns
   8+ 5F14              ; +06 destination_address
   9+ 5F14              ; +08 dest_to_next_row_add_to_value
  10+ 5F14              ; +10 num_horizontal_tiles
  11+ 5F14              ; +12 num_vertical_tiles
  12+ 5F14              ; modifies AF, BC, DE, HL
  13+ 5F14              TILE:
  14+ 5F14 DD 6E 06     	LD L, (IX+6)
  15+ 5F17 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5F1A 22 B4 62     	LD (TILETMP1), HL
  17+ 5F1D DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5F20              .L1:
  19+ 5F20 C5           	PUSH BC
  20+ 5F21 DD 6E 00     		LD L, (IX+0)
  21+ 5F24 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5F27 22 B6 62     		LD (TILETMP2), HL
  23+ 5F2A DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5F2D              .L2:
  25+ 5F2D C5           		PUSH BC
  26+ 5F2E CD 00 00     .CALL1:		CALL 0
  27+ 5F31 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5F34              .L3:
  29+ 5F34 C5           			PUSH BC
  30+ 5F35 2A B6 62     				LD HL, (TILETMP2)
  31+ 5F38 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5F3B              .L4:
  33+ 5F3B C5           				PUSH BC
  34+ 5F3C              .CALL2:
  35+ 5F3C CD 00 00     					CALL 0
  36+ 5F3F C1           				POP BC
  37+ 5F40 10 F9        				DJNZ .L4
  38+ 5F42 C1           			POP BC
  39+ 5F43 10 EF        			DJNZ .L3
  40+ 5F45 22 B6 62     			LD (TILETMP2), HL
  41+ 5F48 2A B4 62     			LD HL, (TILETMP1)
  42+ 5F4B DD 5E 08     			LD E, (IX+8)
  43+ 5F4E DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5F51 19           			ADD HL, DE
  45+ 5F52 22 B4 62     			LD (TILETMP1), HL
  46+ 5F55 C1           		POP BC
  47+ 5F56 10 D5        		DJNZ .L2
  48+ 5F58 C1           	POP BC
  49+ 5F59 10 C5        	DJNZ .L1
  50+ 5F5B C9           	RET
  51+ 5F5C              ; *******************************************************************************************************
  52+ 5F5C
  53+ 5F5C               IFNDEF CMDS_WITH_PARAMETERS
  54+ 5F5C ~            ; *******************************************************************************************************
  55+ 5F5C ~            ; function to handle CALL TILERAM basic extension
  56+ 5F5C ~            ; fills memory with tiles
  57+ 5F5C ~            ; TILERAM ( INT request_data_ptr )
  58+ 5F5C ~            ; request_data_ptr described in TILE
  59+ 5F5C ~            ; will put ram in page 0 also, page 1 is already there
  60+ 5F5C ~            TILERAM:
  61+ 5F5C ~            	; opening (
  62+ 5F5C ~            	CALL CHKCHAR
  63+ 5F5C ~            	DB '('
  64+ 5F5C ~            	; get pointer to request struct
  65+ 5F5C ~            	LD IX, FRMQNT
  66+ 5F5C ~            	CALL CALBAS
  67+ 5F5C ~            	PUSH DE
  68+ 5F5C ~            	; ending )
  69+ 5F5C ~            	CALL CHKCHAR
  70+ 5F5C ~            	DB ')'
  71+ 5F5C ~
  72+ 5F5C ~            	POP IX ; pointer to request struct
  73+ 5F5C ~
  74+ 5F5C ~            	PUSH HL ; save position in BASIC buffer
  75+ 5F5C ~            	DI
  76+ 5F5C ~            	LD IY, .RET
  77+ 5F5C ~            	JP ENABLE_PAGE0
  78+ 5F5C ~            .RET:
  79+ 5F5C ~            	EI
  80+ 5F5C ~            	; set RAM functions to call
  81+ 5F5C ~            	LD HL, .TILECOPY
  82+ 5F5C ~            	LD (TILE.CALL2+1), HL
  83+ 5F5C ~            	LD HL, .SETDESTROW
  84+ 5F5C ~            	LD (TILE.CALL1+1), HL
  85+ 5F5C ~            	LD A,1
  86+ 5F5C ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 5F5C ~            	CALL TILE
  88+ 5F5C ~            	XOR A
  89+ 5F5C ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 5F5C ~
  91+ 5F5C ~                POP DE
  92+ 5F5C ~                POP BC
  93+ 5F5C ~                CALL RESTORE_PAGE_INFO
  94+ 5F5C ~
  95+ 5F5C ~            	POP HL
  96+ 5F5C ~            	RET
  97+ 5F5C ~            .TILECOPY:
  98+ 5F5C ~            	.8 LDI
  99+ 5F5C ~            	RET
 100+ 5F5C ~            .SETDESTROW:
 101+ 5F5C ~            	LD DE, (TILETMP1)
 102+ 5F5C ~            	RET
 103+ 5F5C ~            ; *******************************************************************************************************
 104+ 5F5C               ENDIF
 105+ 5F5C
 106+ 5F5C               IFDEF CMDS_WITH_PARAMETERS
 107+ 5F5C              ; *******************************************************************************************************
 108+ 5F5C              ; function to handle CALL TILERAM basic extension
 109+ 5F5C              ; fills memory with tiles
 110+ 5F5C              ; TILERAM ( INT tile_data_pointer,
 111+ 5F5C              ;			INT tile_columns,
 112+ 5F5C              ;			INT tile_rows,
 113+ 5F5C              ;			INT destination_pointer,
 114+ 5F5C              ;			INT destination_columns,
 115+ 5F5C              ;			INT destination_rows,
 116+ 5F5C              ;			INT destination_begin_column,
 117+ 5F5C              ;			INT destination_begin_row,
 118+ 5F5C              ;			INT number_of_tiles_horizontally,
 119+ 5F5C              ;			INT	number_of_tiles_vertically )
 120+ 5F5C              ; will put ram in page 0 also, page 1 is already there
 121+ 5F5C              TILERAM:
 122+ 5F5C              	; opening (
 123+ 5F5C CD C6 65     	CALL CHKCHAR
 124+ 5F5F 28           	DB '('
 125+ 5F60              	; get tile data pointer coordinate
 126+ 5F60 DD 21 2F 54  	LD IX, FRMQNT
 127+ 5F64 CD 59 01     	CALL CALBAS
 128+ 5F67 ED 53 B8 62  	LD (BLIT_STRUCT+0), DE
 129+ 5F6B              	; comma
 130+ 5F6B CD C6 65     	CALL CHKCHAR
 131+ 5F6E 2C           	DB ','
 132+ 5F6F              	; get tile columns
 133+ 5F6F DD 21 2F 54  	LD IX, FRMQNT
 134+ 5F73 CD 59 01     	CALL CALBAS
 135+ 5F76 ED 53 BC 62  	LD (BLIT_STRUCT+4), DE
 136+ 5F7A              	; comma
 137+ 5F7A CD C6 65     	CALL CHKCHAR
 138+ 5F7D 2C           	DB ','
 139+ 5F7E              	; get tile columns
 140+ 5F7E DD 21 2F 54  	LD IX, FRMQNT
 141+ 5F82 CD 59 01     	CALL CALBAS
 142+ 5F85 ED 53 BA 62  	LD (BLIT_STRUCT+2), DE
 143+ 5F89              	; comma
 144+ 5F89 CD C6 65     	CALL CHKCHAR
 145+ 5F8C 2C           	DB ','
 146+ 5F8D              	; get destintion pointer
 147+ 5F8D DD 21 2F 54  	LD IX, FRMQNT
 148+ 5F91 CD 59 01     	CALL CALBAS
 149+ 5F94 ED 53 BE 62  	LD (BLIT_STRUCT+6), DE
 150+ 5F98              	; comma
 151+ 5F98 CD C6 65     	CALL CHKCHAR
 152+ 5F9B 2C           	DB ','
 153+ 5F9C              	; get destination columns
 154+ 5F9C DD 21 2F 54  	LD IX, FRMQNT
 155+ 5FA0 CD 59 01     	CALL CALBAS
 156+ 5FA3 7B           	LD A, E
 157+ 5FA4 32 B4 62     	LD (BLIT_TMP+0), A
 158+ 5FA7              	; comma
 159+ 5FA7 CD C6 65     	CALL CHKCHAR
 160+ 5FAA 2C           	DB ','
 161+ 5FAB              	; get destination rows
 162+ 5FAB DD 21 2F 54  	LD IX, FRMQNT
 163+ 5FAF CD 59 01     	CALL CALBAS
 164+ 5FB2 7B           	LD A, E
 165+ 5FB3 32 B5 62     	LD (BLIT_TMP+1), A
 166+ 5FB6              	; comma
 167+ 5FB6 CD C6 65     	CALL CHKCHAR
 168+ 5FB9 2C           	DB ','
 169+ 5FBA              	; get destination begin column
 170+ 5FBA DD 21 2F 54  	LD IX, FRMQNT
 171+ 5FBE CD 59 01     	CALL CALBAS
 172+ 5FC1 7B           	LD A, E
 173+ 5FC2 32 B6 62     	LD (BLIT_TMP+2), A
 174+ 5FC5              	; comma
 175+ 5FC5 CD C6 65     	CALL CHKCHAR
 176+ 5FC8 2C           	DB ','
 177+ 5FC9              	; get destination begin row
 178+ 5FC9 DD 21 2F 54  	LD IX, FRMQNT
 179+ 5FCD CD 59 01     	CALL CALBAS
 180+ 5FD0 7B           	LD A, E
 181+ 5FD1 32 B7 62     	LD (BLIT_TMP+3), A
 182+ 5FD4              	; comma
 183+ 5FD4 CD C6 65     	CALL CHKCHAR
 184+ 5FD7 2C           	DB ','
 185+ 5FD8              	; get number of tiles horizontally
 186+ 5FD8 DD 21 2F 54  	LD IX, FRMQNT
 187+ 5FDC CD 59 01     	CALL CALBAS
 188+ 5FDF ED 53 C2 62  	LD (BLIT_STRUCT+10), DE
 189+ 5FE3              	; comma
 190+ 5FE3 CD C6 65     	CALL CHKCHAR
 191+ 5FE6 2C           	DB ','
 192+ 5FE7              	; get number of tiles vertically
 193+ 5FE7 DD 21 2F 54  	LD IX, FRMQNT
 194+ 5FEB CD 59 01     	CALL CALBAS
 195+ 5FEE ED 53 C4 62  	LD (BLIT_STRUCT+12), DE
 196+ 5FF2              	; ending )
 197+ 5FF2 CD C6 65     	CALL CHKCHAR
 198+ 5FF5 29           	DB ')'
 199+ 5FF6
 200+ 5FF6 E5           	PUSH HL ; save position in BASIC buffer
 201+ 5FF7
 202+ 5FF7              	; calculate destination add to value
 203+ 5FF7 26 00        	LD H, 0
 204+ 5FF9 3A B4 62     	LD A, (BLIT_TMP+0)
 205+ 5FFC 6F           	LD L, A
 206+ 5FFD CD B4 64     	CALL HLx8
 207+ 6000 22 C0 62     	LD (BLIT_STRUCT+8), HL
 208+ 6003              	; calculate pointer to background location
 209+ 6003 21 00 00     	LD HL, 0
 210+ 6006 3A B7 62     	LD A,(BLIT_TMP+3)
 211+ 6009 B7           	OR A
 212+ 600A 28 08        	JR Z, .L1
 213+ 600C 47           	LD B,A
 214+ 600D ED 5B C0 62  	LD DE,(BLIT_STRUCT+8)
 215+ 6011              .L0:
 216+ 6011 19           	ADD HL, DE
 217+ 6012 10 FD        	DJNZ .L0
 218+ 6014              .L1:
 219+ 6014 EB           	EX DE,HL
 220+ 6015 26 00        	LD H,0
 221+ 6017 3A B6 62     	LD A,(BLIT_TMP+2)
 222+ 601A 6F           	LD L,A
 223+ 601B CD B4 64     	CALL HLx8
 224+ 601E 19           	ADD HL,DE
 225+ 601F ED 5B BE 62  	LD DE,(BLIT_STRUCT+6)
 226+ 6023 19           	ADD HL,DE
 227+ 6024 22 BE 62     	LD (BLIT_STRUCT+6),HL
 228+ 6027 F3           	DI
 229+ 6028 FD 21 2F 60  	LD IY, .RET
 230+ 602C C3 78 65     	JP ENABLE_PAGE0
 231+ 602F              .RET:
 232+ 602F FB           	EI
 233+ 6030              	; set RAM functions to call
 234+ 6030 21 4A 60     	LD HL, .TILECOPY
 235+ 6033 22 3D 5F     	LD (TILE.CALL2+1), HL
 236+ 6036 21 5B 60     	LD HL, .SETDESTROW
 237+ 6039 22 2F 5F     	LD (TILE.CALL1+1), HL
 238+ 603C DD 21 B8 62  	LD IX,BLIT_STRUCT
 239+ 6040 CD 14 5F     	CALL TILE
 240+ 6043
 241+ 6043 D1               POP DE
 242+ 6044 C1               POP BC
 243+ 6045 CD EF 64         CALL RESTORE_PAGE_INFO
 244+ 6048
 245+ 6048 E1           	POP HL
 246+ 6049 C9           	RET
 247+ 604A              .TILECOPY:
 248+ 604A ED A0       > LDI
 248+ 604C ED A0       > LDI
 248+ 604E ED A0       > LDI
 248+ 6050 ED A0       > LDI
 248+ 6052 ED A0       > LDI
 248+ 6054 ED A0       > LDI
 248+ 6056 ED A0       > LDI
 248+ 6058 ED A0       > LDI
 249+ 605A C9           	RET
 250+ 605B              .SETDESTROW:
 251+ 605B ED 5B B4 62  	LD DE, (TILETMP1)
 252+ 605F C9           	RET
 253+ 6060              ; *******************************************************************************************************
 254+ 6060               ENDIF
 255+ 6060
 256+ 6060               IFDEF CMDS_WITH_PARAMETERS
 257+ 6060              ; *******************************************************************************************************
 258+ 6060              ; function to handle CALL TILEVRM basic extension
 259+ 6060              ; fills vram with tiles
 260+ 6060              ; TILEVRM ( INT tile_data_pointer,
 261+ 6060              ;			INT tile_columns,
 262+ 6060              ;			INT tile_rows,
 263+ 6060              ;			INT destination_begin_column,
 264+ 6060              ;			INT destination_begin_row,
 265+ 6060              ;			INT number_of_tiles_horizontally,
 266+ 6060              ;			INT	number_of_tiles_vertically )
 267+ 6060              ; will put ram in page 0 also, page 1 is already there
 268+ 6060              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 6060              TILEVRM:
 270+ 6060              	; opening (
 271+ 6060 CD C6 65     	CALL CHKCHAR
 272+ 6063 28           	DB '('
 273+ 6064              	; get tile data pointer coordinate
 274+ 6064 DD 21 2F 54  	LD IX, FRMQNT
 275+ 6068 CD 59 01     	CALL CALBAS
 276+ 606B ED 53 B8 62  	LD (BLIT_STRUCT+0), DE
 277+ 606F              	; comma
 278+ 606F CD C6 65     	CALL CHKCHAR
 279+ 6072 2C           	DB ','
 280+ 6073              	; get tile columns
 281+ 6073 DD 21 2F 54  	LD IX, FRMQNT
 282+ 6077 CD 59 01     	CALL CALBAS
 283+ 607A ED 53 BC 62  	LD (BLIT_STRUCT+4), DE
 284+ 607E              	; comma
 285+ 607E CD C6 65     	CALL CHKCHAR
 286+ 6081 2C           	DB ','
 287+ 6082              	; get tile columns
 288+ 6082 DD 21 2F 54  	LD IX, FRMQNT
 289+ 6086 CD 59 01     	CALL CALBAS
 290+ 6089 ED 53 BA 62  	LD (BLIT_STRUCT+2), DE
 291+ 608D              	; comma
 292+ 608D CD C6 65     	CALL CHKCHAR
 293+ 6090 2C           	DB ','
 294+ 6091              	; get destination begin column
 295+ 6091 DD 21 2F 54  	LD IX, FRMQNT
 296+ 6095 CD 59 01     	CALL CALBAS
 297+ 6098 7B           	LD A, E
 298+ 6099 32 B6 62     	LD (BLIT_TMP+2), A
 299+ 609C              	; comma
 300+ 609C CD C6 65     	CALL CHKCHAR
 301+ 609F 2C           	DB ','
 302+ 60A0              	; get destination begin row
 303+ 60A0 DD 21 2F 54  	LD IX, FRMQNT
 304+ 60A4 CD 59 01     	CALL CALBAS
 305+ 60A7 7B           	LD A, E
 306+ 60A8 32 B7 62     	LD (BLIT_TMP+3), A
 307+ 60AB              	; comma
 308+ 60AB CD C6 65     	CALL CHKCHAR
 309+ 60AE 2C           	DB ','
 310+ 60AF              	; get number of tiles horizontally
 311+ 60AF DD 21 2F 54  	LD IX, FRMQNT
 312+ 60B3 CD 59 01     	CALL CALBAS
 313+ 60B6 ED 53 C2 62  	LD (BLIT_STRUCT+10), DE
 314+ 60BA              	; comma
 315+ 60BA CD C6 65     	CALL CHKCHAR
 316+ 60BD 2C           	DB ','
 317+ 60BE              	; get number of tiles vertically
 318+ 60BE DD 21 2F 54  	LD IX, FRMQNT
 319+ 60C2 CD 59 01     	CALL CALBAS
 320+ 60C5 ED 53 C4 62  	LD (BLIT_STRUCT+12), DE
 321+ 60C9              	; ending )
 322+ 60C9 CD C6 65     	CALL CHKCHAR
 323+ 60CC 29           	DB ')'
 324+ 60CD
 325+ 60CD E5           	PUSH HL ; save position in BASIC buffer
 326+ 60CE
 327+ 60CE              	; calculate destination add to value
 328+ 60CE 21 00 01     	LD HL, 256
 329+ 60D1 22 C0 62     	LD (BLIT_STRUCT+8), HL
 330+ 60D4              	; calculate pointer to background location
 331+ 60D4 3A B7 62     	LD A,(BLIT_TMP+3)
 332+ 60D7 67           	LD H,A
 333+ 60D8 2E 00        	LD L,0
 334+ 60DA EB           	EX DE,HL
 335+ 60DB 26 00        	LD H,0
 336+ 60DD 3A B6 62     	LD A,(BLIT_TMP+2)
 337+ 60E0 6F           	LD L,A
 338+ 60E1 CD B4 64     	CALL HLx8
 339+ 60E4 19           	ADD HL,DE
 340+ 60E5 ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 60E9 19           	ADD HL,DE
 342+ 60EA 22 BE 62     	LD (BLIT_STRUCT+6),HL
 343+ 60ED F3           	DI
 344+ 60EE FD 21 F5 60  	LD IY, .RET
 345+ 60F2 C3 78 65     	JP ENABLE_PAGE0
 346+ 60F5              .RET:
 347+ 60F5 FB           	EI
 348+ 60F6              	; set RAM functions to call
 349+ 60F6 21 10 61     	LD HL, .TILECOPY
 350+ 60F9 22 3D 5F     	LD (TILE.CALL2+1), HL
 351+ 60FC 21 16 61     	LD HL, .SETDESTROW
 352+ 60FF 22 2F 5F     	LD (TILE.CALL1+1), HL
 353+ 6102 DD 21 B8 62  	LD IX,BLIT_STRUCT
 354+ 6106 CD 14 5F     	CALL TILE
 355+ 6109
 356+ 6109 D1               POP DE
 357+ 610A C1               POP BC
 358+ 610B CD EF 64         CALL RESTORE_PAGE_INFO
 359+ 610E
 360+ 610E E1           	POP HL
 361+ 610F C9           	RET
 362+ 6110              .TILECOPY:
 363+ 6110 01 98 08     	LD BC, #0898
 364+ 6113 C3 AC 64     	JP BBYTECOPY_NO_C
 365+ 6116              .SETDESTROW:
 366+ 6116 2A B4 62     	LD HL, (TILETMP1)
 367+ 6119 F3           	DI
 368+ 611A CD 9F 64     	CALL SETWRT_LOCAL
 369+ 611D FB           	EI
 370+ 611E C9           	RET
 371+ 611F              ; *******************************************************************************************************
 372+ 611F               ENDIF
 373+ 611F
 374+ 611F               IFNDEF CMDS_WITH_PARAMETERS
 375+ 611F ~            ; *******************************************************************************************************
 376+ 611F ~            ; function to handle CALL TILEVRM basic extension
 377+ 611F ~            ; fills vram with tiles
 378+ 611F ~            ; TILEVRM ( INT request_data_ptr )
 379+ 611F ~            ; request_data_ptr described in TILE
 380+ 611F ~            ; will put ram in page 0 also, page 1 is already there
 381+ 611F ~            TILEVRM:
 382+ 611F ~            	; opening (
 383+ 611F ~            	CALL CHKCHAR
 384+ 611F ~            	DB '('
 385+ 611F ~            	; get pointer to request struct
 386+ 611F ~            	LD IX, FRMQNT
 387+ 611F ~            	CALL CALBAS
 388+ 611F ~            	PUSH DE
 389+ 611F ~            	; ending )
 390+ 611F ~            	CALL CHKCHAR
 391+ 611F ~            	DB ')'
 392+ 611F ~
 393+ 611F ~            	POP IX ; pointer to request struct
 394+ 611F ~
 395+ 611F ~            	PUSH HL ; save position in BASIC buffer
 396+ 611F ~            	DI
 397+ 611F ~            	LD IY, .RET
 398+ 611F ~            	JP ENABLE_PAGE0
 399+ 611F ~            .RET:
 400+ 611F ~            	EI
 401+ 611F ~            	; set RAM functions to call
 402+ 611F ~            	LD HL, .TILECOPY
 403+ 611F ~            	LD (TILE.CALL2+1), HL
 404+ 611F ~            	LD HL, .SETDESTROW
 405+ 611F ~            	LD (TILE.CALL1+1), HL
 406+ 611F ~            	CALL TILE
 407+ 611F ~
 408+ 611F ~                POP DE
 409+ 611F ~                POP BC
 410+ 611F ~                CALL RESTORE_PAGE_INFO
 411+ 611F ~
 412+ 611F ~            	POP HL
 413+ 611F ~            	RET
 414+ 611F ~            .TILECOPY:
 415+ 611F ~            	LD BC, #0898
 416+ 611F ~            	JP BBYTECOPY_NO_C
 417+ 611F ~            .SETDESTROW:
 418+ 611F ~            	LD HL, (TILETMP1)
 419+ 611F ~            	DI
 420+ 611F ~            	CALL SETWRT_LOCAL
 421+ 611F ~            	EI
 422+ 611F ~            	RET
 423+ 611F ~            ; *******************************************************************************************************
 424+ 611F               ENDIF
# file closed: asm\TILE.asm
 152  611F               ENDIF
 153  611F
 154  611F               IF (COLL_CMD == 1)
 155  611F               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 611F              ; generic collision checking routines
   2+ 611F              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 611F              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 611F              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 611F              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 611F              ; R%(3,n) x offset where rectangle begins
   7+ 611F              ; R%(4,n) y offset where rectangle begins
   8+ 611F              ; R%(5,n) is width
   9+ 611F              ; R%(6,n) is height
  10+ 611F              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 611F              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 611F              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 611F
  14+ 611F              ; ************************************************************************************************
  15+ 611F              ; quick test if HL<=DE<=HL+BC
  16+ 611F              ; input BC=width, DE=x, HL=min
  17+ 611F              ; if not true flag C set
  18+ 611F              ; modifies AF
  19+ 611F              GENERIC_INNER_CHECK:
  20+ 611F E5               PUSH HL
  21+ 6120 D5               PUSH DE
  22+ 6121 EB               EX DE,HL
  23+ 6122 A7               AND A
  24+ 6123 ED 52            SBC HL, DE
  25+ 6125 FA 33 61         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 6128 A7               AND A
  27+ 6129 ED 42            SBC HL, BC
  28+ 612B 28 03            JR Z, .L2
  29+ 612D F2 33 61         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 6130              .L2:
  31+ 6130 A7               AND A
  32+ 6131 18 01            JR .EXIT
  33+ 6133              .GENERIC_INNER_CHECK_NOT:
  34+ 6133 37               SCF
  35+ 6134              .EXIT:
  36+ 6134 D1               POP DE
  37+ 6135 E1               POP HL
  38+ 6136 C9               RET
  39+ 6137              ; ************************************************************************************************
  40+ 6137
  41+ 6137              ; ************************************************************************************************
  42+ 6137              ; function to check if rectangles are overlapping
  43+ 6137              ; input IX=IY=pointer to struct
  44+ 6137              ;  +00 active flag
  45+ 6137              ;  +02 x coordinate
  46+ 6137              ;  +04 y coordinate
  47+ 6137              ;  +06 x offset where rectangle begins
  48+ 6137              ;  +08 y offset where rectangle begins
  49+ 6137              ;  +10 width
  50+ 6137              ;  +12 height
  51+ 6137              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 6137              ; this is a hack to allow location being taken from sprite attributes table
  53+ 6137              ; input BLIT_STRUCT data
  54+ 6137              ;  +00 x coordinate
  55+ 6137              ;  +02 y coordinate
  56+ 6137              ;  +04 width
  57+ 6137              ;  +06 height
  58+ 6137              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 6137              RECTANGLE_OVERLAP_CHECK:
  60+ 6137                  ; first check which rectangle is higher
  61+ 6137 DD 6E 0C         LD L,(IX+12)
  62+ 613A DD 66 0D         LD H,(IX+13)
  63+ 613D ED 5B BE 62      LD DE,(BLIT_STRUCT+6)
  64+ 6141 A7               AND A
  65+ 6142 ED 52            SBC HL,DE
  66+ 6144 FD 6E 04         LD L,(IY+4)
  67+ 6147 FD 66 05         LD H,(IY+5)
  68+ 614A DD 5E 08         LD E,(IX+8)
  69+ 614D DD 56 09         LD D,(IX+9)
  70+ 6150 FA 70 61         JP M,.L1
  71+ 6153                  ; equally high or IX defined one higher
  72+ 6153                  ; check upper boundary
  73+ 6153 19               ADD HL,DE
  74+ 6154 ED 5B BA 62      LD DE,(BLIT_STRUCT+2)
  75+ 6158 DD 4E 0C         LD C,(IX+12)
  76+ 615B DD 46 0D         LD B,(IX+13)
  77+ 615E CD 1F 61         CALL GENERIC_INNER_CHECK
  78+ 6161 30 29            JR NC,.INSIDE
  79+ 6163                  ; check lower boundary
  80+ 6163 E5               PUSH HL
  81+ 6164 2A BE 62         LD HL,(BLIT_STRUCT+6)
  82+ 6167 19               ADD HL,DE
  83+ 6168 EB               EX DE,HL
  84+ 6169 E1               POP HL
  85+ 616A CD 1F 61         CALL GENERIC_INNER_CHECK
  86+ 616D 30 1D            JR NC,.INSIDE
  87+ 616F C9               RET ; not overlapping
  88+ 6170              .L1:
  89+ 6170                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 6170 19               ADD HL,DE
  91+ 6171 EB               EX DE,HL
  92+ 6172 2A BA 62         LD HL,(BLIT_STRUCT+2)
  93+ 6175 ED 4B BE 62      LD BC,(BLIT_STRUCT+6)
  94+ 6179 CD 1F 61         CALL GENERIC_INNER_CHECK
  95+ 617C 30 0E            JR NC,.INSIDE
  96+ 617E E5               PUSH HL
  97+ 617F DD 6E 0C         LD L,(IX+12)
  98+ 6182 DD 66 0D         LD H,(IX+13)
  99+ 6185 19               ADD HL,DE
 100+ 6186 EB               EX DE,HL
 101+ 6187 E1               POP HL
 102+ 6188 CD 1F 61         CALL GENERIC_INNER_CHECK
 103+ 618B D8               RET C
 104+ 618C              .INSIDE:
 105+ 618C                  ; check x coordinate
 106+ 618C                  ; first check which rectangle is wider
 107+ 618C DD 6E 0A         LD L,(IX+10)
 108+ 618F DD 66 0B         LD H,(IX+11)
 109+ 6192 ED 5B BC 62      LD DE,(BLIT_STRUCT+4)
 110+ 6196 A7               AND A
 111+ 6197 ED 52            SBC HL,DE
 112+ 6199 FD 6E 02         LD L,(IY+2)
 113+ 619C FD 66 03         LD H,(IY+3)
 114+ 619F DD 5E 06         LD E,(IX+6)
 115+ 61A2 DD 56 07         LD D,(IX+7)
 116+ 61A5 FA C1 61         JP M,.L2
 117+ 61A8                  ; equally wide or IX defined one wider
 118+ 61A8                  ; check left boundary
 119+ 61A8 19               ADD HL,DE
 120+ 61A9 ED 5B B8 62      LD DE,(BLIT_STRUCT+0)
 121+ 61AD DD 4E 0A         LD C,(IX+10)
 122+ 61B0 DD 46 0B         LD B,(IX+11)
 123+ 61B3 CD 1F 61         CALL GENERIC_INNER_CHECK
 124+ 61B6 D0               RET NC ; overlap
 125+ 61B7                  ; check right boundary
 126+ 61B7 E5               PUSH HL
 127+ 61B8 2A BC 62         LD HL,(BLIT_STRUCT+4)
 128+ 61BB 19               ADD HL,DE
 129+ 61BC EB               EX DE,HL
 130+ 61BD E1               POP HL
 131+ 61BE C3 1F 61         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 61C1              .L2:
 133+ 61C1                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 61C1 19               ADD HL,DE
 135+ 61C2 EB               EX DE,HL
 136+ 61C3 2A B8 62         LD HL,(BLIT_STRUCT+0)
 137+ 61C6 ED 4B BC 62      LD BC,(BLIT_STRUCT+4)
 138+ 61CA CD 1F 61         CALL GENERIC_INNER_CHECK
 139+ 61CD D0               RET NC ; overlap
 140+ 61CE E5               PUSH HL
 141+ 61CF DD 6E 0A         LD L,(IX+10)
 142+ 61D2 DD 66 0B         LD H,(IX+11)
 143+ 61D5 19               ADD HL,DE
 144+ 61D6 EB               EX DE,HL
 145+ 61D7 E1               POP HL
 146+ 61D8 C3 1F 61         JP GENERIC_INNER_CHECK
 147+ 61DB              ; ************************************************************************************************
 148+ 61DB
 149+ 61DB              ; ************************************************************************************************
 150+ 61DB              ; function tries to find rectangle overlap and returns an index if found
 151+ 61DB              ; input BLIT_STRUCT data
 152+ 61DB              ;  +00 x coordinate
 153+ 61DB              ;  +02 y coordinate
 154+ 61DB              ;  +04 width
 155+ 61DB              ;  +06 height
 156+ 61DB              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 61DB              ;  +09 pointer to first element of R%(7,n)
 158+ 61DB              ;  +11 pointer to INT result variable
 159+ 61DB              ; returns CF=1 if not overlapping
 160+ 61DB              ; returns A=list index and CF=0 if overlapping
 161+ 61DB              FIND_OVERLAP:
 162+ 61DB 3A C0 62         LD A,(BLIT_STRUCT+8)
 163+ 61DE 47               LD B,A
 164+ 61DF DD 2A C1 62      LD IX,(BLIT_STRUCT+9)
 165+ 61E3              .L1:
 166+ 61E3 C5               PUSH BC
 167+ 61E4                  ; check active flag
 168+ 61E4 DD 7E 00         LD A,(IX)
 169+ 61E7 DD B6 01         OR (IX+1)
 170+ 61EA 28 18            JR Z,.NEXT
 171+ 61EC                  ; check type
 172+ 61EC DD 7E 0E         LD A,(IX+14)
 173+ 61EF DD B6 0F         OR (IX+15)
 174+ 61F2 20 1A            JR NZ,.L2
 175+ 61F4 DD E5            PUSH IX
 176+ 61F6 FD E1            POP IY
 177+ 61F8              .L3:
 178+ 61F8 CD 37 61         CALL RECTANGLE_OVERLAP_CHECK
 179+ 61FB 38 07            JR C,.NEXT
 180+ 61FD                  ; found
 181+ 61FD C1               POP BC
 182+ 61FE 3A C0 62         LD A,(BLIT_STRUCT+8)
 183+ 6201 90               SUB B
 184+ 6202 A7               AND A
 185+ 6203 C9               RET
 186+ 6204              .NEXT:
 187+ 6204 11 10 00         LD DE,16
 188+ 6207 DD 19            ADD IX,DE
 189+ 6209 C1               POP BC
 190+ 620A 10 D7            DJNZ .L1
 191+ 620C 37               SCF
 192+ 620D C9               RET
 193+ 620E              .L2:
 194+ 620E                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 620E                  ; at BLIT_STRUCT+13
 196+ 620E DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 6211 CD 85 4D         CALL GETnthSPRATTR
 198+ 6214 FD 21 C3 62      LD IY,BLIT_STRUCT+11
 199+ 6218 7E               LD A,(HL)
 200+ 6219 FD 77 04         LD (IY+4),A
 201+ 621C 23               INC HL
 202+ 621D 7E               LD A,(HL)
 203+ 621E FD 77 05         LD (IY+5),A
 204+ 6221 23               INC HL
 205+ 6222 7E               LD A,(HL)
 206+ 6223 FD 77 02         LD (IY+2),A
 207+ 6226 23               INC HL
 208+ 6227 7E               LD A,(HL)
 209+ 6228 FD 77 03         LD (IY+3),A
 210+ 622B 18 CB            JR .L3
 211+ 622D              ; ************************************************************************************************
 212+ 622D
 213+ 622D              ; ************************************************************************************************
 214+ 622D              ; function to handle CALL COLL basic extension
 215+ 622D              ; checks for collision between player and other rectangles
 216+ 622D              ; COLL ( INT result variable,
 217+ 622D              ;	     INT player x value,
 218+ 622D              ;	     INT player y value,
 219+ 622D              ;	     INT player width,
 220+ 622D              ;	     INT player height,
 221+ 622D              ;	     INT number of items in a list,
 222+ 622D              ;		 INT[6][n] rectangle struct )
 223+ 622D              ; will fill result variable with index or -1 if no collision
 224+ 622D              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 225+ 622D              COLL:
 226+ 622D              	; opening (
 227+ 622D CD C6 65     	CALL CHKCHAR
 228+ 6230 28           	DB '('
 229+ 6231              	; get address of result variable
 230+ 6231 DD 21 A4 5E  	LD IX, PTRGET
 231+ 6235 CD 59 01     	CALL CALBAS
 232+ 6238 ED 53 C3 62  	LD (BLIT_STRUCT+11),DE
 233+ 623C              	; comma
 234+ 623C CD C6 65     	CALL CHKCHAR
 235+ 623F 2C           	DB ','
 236+ 6240              	; get x
 237+ 6240 DD 21 2F 54  	LD IX, FRMQNT
 238+ 6244 CD 59 01     	CALL CALBAS
 239+ 6247 ED 53 B8 62  	LD (BLIT_STRUCT+0),DE
 240+ 624B              	; comma
 241+ 624B CD C6 65     	CALL CHKCHAR
 242+ 624E 2C           	DB ','
 243+ 624F              	; get y
 244+ 624F DD 21 2F 54  	LD IX, FRMQNT
 245+ 6253 CD 59 01     	CALL CALBAS
 246+ 6256 ED 53 BA 62  	LD (BLIT_STRUCT+2),DE
 247+ 625A              	; comma
 248+ 625A CD C6 65     	CALL CHKCHAR
 249+ 625D 2C           	DB ','
 250+ 625E              	; get width
 251+ 625E DD 21 2F 54  	LD IX, FRMQNT
 252+ 6262 CD 59 01     	CALL CALBAS
 253+ 6265 ED 53 BC 62  	LD (BLIT_STRUCT+4),DE
 254+ 6269              	; comma
 255+ 6269 CD C6 65     	CALL CHKCHAR
 256+ 626C 2C           	DB ','
 257+ 626D              	; get height
 258+ 626D DD 21 2F 54  	LD IX, FRMQNT
 259+ 6271 CD 59 01     	CALL CALBAS
 260+ 6274 ED 53 BE 62  	LD (BLIT_STRUCT+6),DE
 261+ 6278              	; comma
 262+ 6278 CD C6 65     	CALL CHKCHAR
 263+ 627B 2C           	DB ','
 264+ 627C              	; get number of items in a list
 265+ 627C DD 21 1C 52  	LD IX, GETBYT
 266+ 6280 CD 59 01     	CALL CALBAS
 267+ 6283 32 C0 62     	LD (BLIT_STRUCT+8),A
 268+ 6286              	; comma
 269+ 6286 CD C6 65     	CALL CHKCHAR
 270+ 6289 2C           	DB ','
 271+ 628A              	; get address of rectangle structure array DIM R%(7,n)
 272+ 628A 3A C0 62     	LD A,(BLIT_STRUCT+8)
 273+ 628D 5F               LD E,A
 274+ 628E 3E 02            LD A,2
 275+ 6290 47           	LD B,A
 276+ 6291 16 07        	LD D,7
 277+ 6293 CD F3 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 278+ 6296 ED 43 C1 62  	LD (BLIT_STRUCT+9),BC
 279+ 629A              	; ending )
 280+ 629A CD C6 65     	CALL CHKCHAR
 281+ 629D 29           	DB ')'
 282+ 629E
 283+ 629E E5               PUSH HL
 284+ 629F CD DB 61         CALL FIND_OVERLAP
 285+ 62A2 2A C3 62         LD HL,(BLIT_STRUCT+11)
 286+ 62A5 38 06            JR C,.NOTFOUND
 287+ 62A7 77               LD (HL),A
 288+ 62A8 23               INC HL
 289+ 62A9 36 00            LD (HL),0
 290+ 62AB E1               POP HL
 291+ 62AC C9               RET
 292+ 62AD              .NOTFOUND:
 293+ 62AD 36 FF            LD (HL),#FF
 294+ 62AF 23               INC HL
 295+ 62B0 36 FF            LD (HL),#FF
 296+ 62B2 E1               POP HL
 297+ 62B3 C9               RET
 298+ 62B4              ; ************************************************************************************************
 299+ 62B4
# file closed: asm\COLLISION.asm
 156  62B4               ENDIF
 157  62B4
 158  62B4              ; temp variables for BLIT, TILE functions
 159  62B4               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 160  62B4              BLIT_TMP:
 161  62B4              TILETMP1:
 162  62B4              BLIT_TMP1:
 163  62B4 00 00         DW 0
 164  62B6              TILETMP2:
 165  62B6              BLIT_TMP2:
 166  62B6 00 00         DW 0
 167  62B8                IFDEF CMDS_WITH_PARAMETERS
 168  62B8              BLIT_STRUCT:
 169  62B8 00 00 00...   DS 17
 170  62BC                ENDIF
 171  62BC               ENDIF
 172  62C9
 173  62C9               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 174  62C9              VRAM_UPDATE_IN_PROGRESS:
 175  62C9 00            DB 0
 176  62CA               ENDIF
 177  62CA
 178  62CA              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 179  62CA              ; per starting letter, if no commands with this letter, NULL value
 180  62CA              CMDS:
 181  62CA               IF (ANIM_CMDS == 1)
 182  62CA 09 64        	DW CMDS_A ;
 183  62CC               ELSE
 184  62CC ~                DW 0 ; A
 185  62CC               ENDIF
 186  62CC               IF (BLIT_CMDS + BOX_CMDS > 0)
 187  62CC D4 63            DW CMDS_B ; B
 188  62CE               ELSE
 189  62CE ~            	DW 0
 190  62CE               ENDIF
 191  62CE               IF (COLL_CMD == 1)
 192  62CE 97 64        	DW CMDS_C ;
 193  62D0               ELSE
 194  62D0 ~                DW 0 ; C
 195  62D0               ENDIF
 196  62D0 00 00            DW 0 ; D
 197  62D2 00 00            DW 0 ; E
 198  62D4               IF (VRAM_CMDS + RAM_CMDS > 0)
 199  62D4 4B 63            DW CMDS_F; F
 200  62D6               ELSE
 201  62D6 ~            	DW 0
 202  62D6               ENDIF
 203  62D6               IF (GENCAL_CMD > 0)
 204  62D6 5E 63            DW CMDS_G; G
 205  62D8               ELSE
 206  62D8 ~            	DW 0
 207  62D8               ENDIF
 208  62D8 00 00            DW 0 ; H
 209  62DA 00 00            DW 0 ; I
 210  62DC 00 00            DW 0 ; J
 211  62DE 00 00            DW 0 ; K
 212  62E0 00 00            DW 0 ; L
 213  62E2               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 214  62E2 FE 62            DW CMDS_M ; M
 215  62E4               ELSE
 216  62E4 ~            	DW 0
 217  62E4               ENDIF
 218  62E4 00 00            DW 0 ; N
 219  62E6 00 00            DW 0 ; O
 220  62E8 00 00            DW 0 ; P
 221  62EA 00 00            DW 0 ; Q
 222  62EC 00 00            DW 0 ; R
 223  62EE               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 224  62EE 72 63            DW CMDS_S ; S
 225  62F0               ELSE
 226  62F0 ~            	DW 0
 227  62F0               ENDIF
 228  62F0               IF (TILE_CMDS > 0)
 229  62F0 F4 63            DW CMDS_T ; T
 230  62F2               ELSE
 231  62F2 ~            	DW 0
 232  62F2               ENDIF
 233  62F2 00 00            DW 0 ; U
 234  62F4               IF (VRAM_CMDS > 0)
 235  62F4 68 63            DW CMDS_V ; V
 236  62F6               ELSE
 237  62F6 ~            	DW 0
 238  62F6               ENDIF
 239  62F6 00 00            DW 0 ; W
 240  62F8 00 00            DW 0 ; X
 241  62FA 00 00            DW 0 ; Y
 242  62FC 00 00            DW 0 ; Z
 243  62FE
 244  62FE              CMDS_M:
 245  62FE               IF (VRAM_CMDS == 1)
 246  62FE 4D 45 4D 56      DB "MEMVRM", 0
 246  6302 52 4D 00
 247  6305 64 5A            DW MEMVRM
 248  6307               ENDIF
 249  6307               IF (RAM_CMDS == 1)
 250  6307 4D 45 4D 43  	DB "MEMCPY", 0
 250  630B 50 59 00
 251  630E 99 58        	DW MEMCPY
 252  6310               ENDIF
 253  6310               IF (ANIM_CMDS == 1)
 254  6310 4D 41 58 41  	DB "MAXANIMITEMS",0
 254  6314 4E 49 4D 49
 254  6318 54 45 4D 53
 254  631C 00
 255  631D 1A 50        	DW MAXANIMITEMS
 256  631F 4D 41 58 41  	DB "MAXANIMDEFS",0
 256  6323 4E 49 4D 44
 256  6327 45 46 53 00
 257  632B A5 51        	DW MAXANIMDEFS
 258  632D 4D 41 58 41  	DB "MAXANIMSPRS",0
 258  6331 4E 49 4D 53
 258  6335 50 52 53 00
 259  6339 3B 52        	DW MAXANIMSPRS
 260  633B 4D 41 58 41     DB "MAXAUTOSGAMS",0
 260  633F 55 54 4F 53
 260  6343 47 41 4D 53
 260  6347 00
 261  6348 85 53           DW MAXAUTOSGAMS
 262  634A               ENDIF
 263  634A               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 264  634A 00           	DB 0
 265  634B               ENDIF
 266  634B              CMDS_F:
 267  634B               IF (VRAM_CMDS == 1)
 268  634B 46 49 4C 56      DB "FILVRM", 0
 268  634F 52 4D 00
 269  6352 15 5A            DW FILVRM
 270  6354               ENDIF
 271  6354               IF (RAM_CMDS == 1)
 272  6354 46 49 4C 52      DB "FILRAM", 0
 272  6358 41 4D 00
 273  635B DD 58            DW FILRAM
 274  635D               ENDIF
 275  635D               IF (VRAM_CMDS + RAM_CMDS > 0)
 276  635D 00               DB 0
 277  635E               ENDIF
 278  635E              CMDS_G:
 279  635E               IF (GENCAL_CMD == 1)
 280  635E 47 45 4E 43      DB "GENCAL", 0
 280  6362 41 4C 00
 281  6365 44 5B            DW GENCAL
 282  6367               ENDIF
 283  6367               IF (GENCAL_CMD > 0)
 284  6367 00           	DB	0
 285  6368               ENDIF
 286  6368              CMDS_V:
 287  6368               IF (VRAM_CMDS == 1)
 288  6368 56 52 4D 4D  	DB "VRMMEM", 0
 288  636C 45 4D 00
 289  636F E2 5A        	DW VRMMEM
 290  6371               ENDIF
 291  6371               IF (VRAM_CMDS > 0)
 292  6371 00           	DB 0
 293  6372               ENDIF
 294  6372              CMDS_S:
 295  6372               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 296  6372 53 47 41 4D      DB "SGAM",0
 296  6376 00
 297  6377 04 57            DW SGAM
 298  6379               ENDIF
 299  6379               IF (SPRITE_CMDS == 1)
 300  6379 53 50 52 53   	DB "SPRSET", 0
 300  637D 45 54 00
 301  6380 A2 4E        	DW SPRSET
 302  6382 53 50 52 47  	DB "SPRGRPMOV", 0
 302  6386 52 50 4D 4F
 302  638A 56 00
 303  638C 55 4F        	DW SPRGRPMOV
 304  638E               ENDIF
 305  638E               IF (SOUND_CMDS == 1)
 306  638E 53 4E 44 53  	DB "SNDSFX", 0
 306  6392 46 58 00
 307  6395 BB 59        	DW SNDSFX
 308  6397 53 4E 44 50  	DB "SNDPLYON", 0
 308  639B 4C 59 4F 4E
 308  639F 00
 309  63A0 85 59        	DW SNDPLYON
 310  63A2 53 4E 44 50  	DB "SNDPLYOFF", 0
 310  63A6 4C 59 4F 46
 310  63AA 46 00
 311  63AC 98 59        	DW SNDPLYOFF
 312  63AE 53 4E 44 50  	DB "SNDPLYINI", 0
 312  63B2 4C 59 49 4E
 312  63B6 49 00
 313  63B8 3B 59        	DW SNDPLYINIT
 314  63BA               ENDIF
 315  63BA               IF (SPRITE_CMDS == 1)
 316  63BA 53 50 52 45  	DB "SPRENABLE", 0
 316  63BE 4E 41 42 4C
 316  63C2 45 00
 317  63C4 5D 4E        	DW SPRENABLE
 318  63C6 53 50 52 44  	DB "SPRDISABLE", 0
 318  63CA 49 53 41 42
 318  63CE 4C 45 00
 319  63D1 9D 4E        	DW SPRDISABLE
 320  63D3               ENDIF
 321  63D3               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 322  63D3 00           	DB 0
 323  63D4               ENDIF
 324  63D4              CMDS_B:
 325  63D4               IF (BLIT_CMDS == 1)
 326  63D4 42 4C 49 54  	DB "BLIT", 0
 326  63D8 00
 327  63D9 17 5E        	DW BLIT
 328  63DB               ENDIF
 329  63DB               IF (BOX_CMDS == 1)
 330  63DB 42 4F 58 4D  	DB "BOXMEMCPY", 0
 330  63DF 45 4D 43 50
 330  63E3 59 00
 331  63E5 D3 5B        	DW BOXMEMCPY
 332  63E7 42 4F 58 4D  	DB "BOXMEMVRM", 0
 332  63EB 45 4D 56 52
 332  63EF 4D 00
 333  63F1 69 5C        	DW BOXMEMVRM
 334  63F3               ENDIF
 335  63F3               IF (BLIT_CMDS + BOX_CMDS > 0)
 336  63F3 00           	DB 0
 337  63F4               ENDIF
 338  63F4              CMDS_T:
 339  63F4               IF (TILE_CMDS == 1)
 340  63F4 54 49 4C 45  	DB "TILERAM", 0
 340  63F8 52 41 4D 00
 341  63FC 5C 5F        	DW TILERAM
 342  63FE 54 49 4C 45  	DB "TILEVRM", 0
 342  6402 56 52 4D 00
 343  6406 60 60        	DW TILEVRM
 344  6408               ENDIF
 345  6408               IF (TILE_CMDS > 0)
 346  6408 00           	DB 0
 347  6409               ENDIF
 348  6409              CMDS_A:
 349  6409               IF (ANIM_CMDS == 1)
 350  6409 41 4E 49 4D     DB "ANIMSTEP",0
 350  640D 53 54 45 50
 350  6411 00
 351  6412 58 55           DW ANIMSTEP
 352  6414 41 4E 49 4D  	DB "ANIMSTART",0
 352  6418 53 54 41 52
 352  641C 54 00
 353  641E 5D 55        	DW ANIMSTART
 354  6420 41 4E 49 4D  	DB "ANIMSTOP",0
 354  6424 53 54 4F 50
 354  6428 00
 355  6429 62 55        	DW ANIMSTOP
 356  642B 41 4E 49 4D  	DB "ANIMITEMPAT",0
 356  642F 49 54 45 4D
 356  6433 50 41 54 00
 357  6437 EB 50        	DW ANIMITEMPAT
 358  6439 41 4E 49 4D  	DB "ANIMITEMPTR",0
 358  643D 49 54 45 4D
 358  6441 50 54 52 00
 359  6445 51 51        	DW ANIMITEMPTR_CMD
 360  6447 41 4E 49 4D  	DB "ANIMDEF",0
 360  644B 44 45 46 00
 361  644F E8 51        	DW ANIMDEF
 362  6451 41 4E 49 4D  	DB "ANIMSPRITE",0
 362  6455 53 50 52 49
 362  6459 54 45 00
 363  645C 94 52        	DW ANIMSPRITE
 364  645E 41 4E 49 4D     DB "ANIMCHAR",0
 364  6462 43 48 41 52
 364  6466 00
 365  6467 0C 53           DW ANIMCHAR
 366  6469 41 55 54 4F     DB "AUTOSGAMDEF",0
 366  646D 53 47 41 4D
 366  6471 44 45 46 00
 367  6475 E2 53           DW AUTOSGAMDEF
 368  6477 41 55 54 4F     DB "AUTOSGAMSTART",0
 368  647B 53 47 41 4D
 368  647F 53 54 41 52
 368  6483 54 00
 369  6485 19 55           DW AUTOSGAMSTART
 370  6487 41 55 54 4F     DB "AUTOSGAMSTOP",0
 370  648B 53 47 41 4D
 370  648F 53 54 4F 50
 370  6493 00
 371  6494 55 55           DW AUTOSGAMSTOP
 372  6496 00           	DB 0
 373  6497               ENDIF
 374  6497              CMDS_C:
 375  6497               IF (COLL_CMD == 1)
 376  6497 43 4F 4C 4C      DB "COLL", 0
 376  649B 00
 377  649C 2D 62            DW COLL
 378  649E               ENDIF
 379  649E               IF (COLL_CMD > 0)
 380  649E 00           	DB	0
 381  649F               ENDIF
 382  649F
 383  649F               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 384  649F              ; ****************************************************************************************************
 385  649F              ; function sets VRAM address
 386  649F              ; input HL=address
 387  649F              ; modifies AF
 388  649F              SETWRT_LOCAL:
 389  649F 7D           	LD	A, L
 390  64A0 D3 99        	OUT	(099H), A
 391  64A2 7C           	LD	A, H
 392  64A3 E6 3F        	AND	03FH
 393  64A5 F6 40        	OR	040H
 394  64A7 D3 99        	OUT	(099H), A
 395  64A9 C9           	RET
 396  64AA              ; ****************************************************************************************************
 397  64AA               ENDIF
 398  64AA
 399  64AA               IF (VRAM_CMDS + TILE_CMDS > 0)
 400  64AA              ; ****************************************************************************************************
 401  64AA              ; function copies data from RAM to VRAM
 402  64AA              ; input HL=address in RAM
 403  64AA              ; input B=count
 404  64AA              ; modifies AF, BC, HL
 405  64AA              BBYTECOPY:
 406  64AA 0E 98        	LD C,#98
 407  64AC              BBYTECOPY_NO_C:
 408  64AC ED A3        	OUTI
 409  64AE C2 AC 64     	JP	NZ, BBYTECOPY_NO_C
 410  64B1 C9           	RET
 411  64B2              ; ****************************************************************************************************
 412  64B2               ENDIF
 413  64B2
 414  64B2              ; ****************************************************************************************************
 415  64B2              ; function multiplies HL by 32
 416  64B2              HLx32:
 417  64B2 29           	ADD HL,HL
 418  64B3              ; ****************************************************************************************************
 419  64B3              ; function multiplies HL by 16
 420  64B3              HLx16:
 421  64B3 29           	ADD HL,HL
 422  64B4              ; ****************************************************************************************************
 423  64B4              ; function multiplies HL by 8
 424  64B4              HLx8:
 425  64B4 29          > ADD HL, HL
 425  64B5 29          > ADD HL, HL
 425  64B6 29          > ADD HL, HL
 426  64B7 C9           	RET
 427  64B8              ; ****************************************************************************************************
 428  64B8
 429  64B8              ; ****************************************************************************************************
 430  64B8              ; function gets slot and subslot data for specific page
 431  64B8              ; input A=page (0, 1 or 2)
 432  64B8              ; output B = 0A8H register value
 433  64B8              ; output D = 0 is no subslots, 1 if yes
 434  64B8              ; output C = 0A8H value when page 3 slot equals to requested page slot
 435  64B8              ; output E = subslot value if present
 436  64B8              ; modifies AF, BC, DE, HL
 437  64B8              GET_PAGE_INFO:
 438  64B8 6F               LD L, A
 439  64B9 C6 C1            ADD A, low (EXPTBL)
 440  64BB 32 C5 64         LD (GET_PAGE_INFO_L1+1), A
 441  64BE DB A8            IN A, (0A8H)
 442  64C0 47               LD B, A
 443  64C1 E6 3F            AND 03FH
 444  64C3 4F               LD C, A
 445  64C4              GET_PAGE_INFO_L1:
 446  64C4 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 447  64C7 E6 80            AND 080H
 448  64C9 28 1B            JR Z, GET_PAGE_INFO_L2
 449  64CB                  ; expanded
 450  64CB 2D               DEC L
 451  64CC FA EB 64         JP M, GET_PAGE_INFO_L3
 452  64CF 2D               DEC L
 453  64D0 FA E9 64         JP M, GET_PAGE_INFO_L4
 454  64D3                  ; page 2
 455  64D3 07               RLCA
 456  64D4 07               RLCA
 457  64D5              GET_PAGE_INFO_L5:
 458  64D5 E6 C0            AND 0C0H
 459  64D7 B1               OR C
 460  64D8 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 461  64DA 4F               LD C, A
 462  64DB 3A FF FF         LD A, (0FFFFH)
 463  64DE 2F               CPL
 464  64DF 5F               LD E, A
 465  64E0 16 01            LD D, 1
 466  64E2 78               LD A, B ; return stack
 467  64E3 D3 A8            OUT (0A8H), A
 468  64E5 C9               RET
 469  64E6              GET_PAGE_INFO_L2:
 470  64E6                  ; not expanded
 471  64E6 16 00            LD D, 0
 472  64E8 C9               RET
 473  64E9              GET_PAGE_INFO_L4:
 474  64E9                  ; page 1
 475  64E9 0F               RRCA
 476  64EA 0F               RRCA
 477  64EB              GET_PAGE_INFO_L3:
 478  64EB                  ; page 0
 479  64EB 0F               RRCA
 480  64EC 0F               RRCA
 481  64ED 18 E6            JR GET_PAGE_INFO_L5
 482  64EF              ; ****************************************************************************************************
 483  64EF
 484  64EF              ; ****************************************************************************************************
 485  64EF              ; function returns original slot and subslot info
 486  64EF              ; input B = 0A8H register value
 487  64EF              ; input D = 0 is no subslots, 1 if yes
 488  64EF              ; input C = 0A8H value when page 3 slot equals to requested page slot
 489  64EF              ; input E = subslot value if present
 490  64EF              ; modifies AF, disables interrupts
 491  64EF              RESTORE_PAGE_INFO:
 492  64EF 7A              LD A, D
 493  64F0 B7              OR A
 494  64F1 28 08           JR Z, RESTORE_PAGE_INFO_L1
 495  64F3 79              LD A, C
 496  64F4 F3           	DI
 497  64F5 D3 A8           OUT (0A8H), A
 498  64F7 7B              LD A, E
 499  64F8 32 FF FF        LD (0FFFFH), A
 500  64FB              RESTORE_PAGE_INFO_L1:
 501  64FB 78              LD A, B
 502  64FC D3 A8           OUT (0A8H), A
 503  64FE C9              RET
 504  64FF              ; ****************************************************************************************************
 505  64FF
 506  64FF              ; *******************************************************************************************************
 507  64FF              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 508  64FF              ; INPUT:  A = SLOT ID: EXXXSSPP
 509  64FF              ; E = EXPANDED FLAG
 510  64FF              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 511  64FF              ; PP = PRIMARY SLOT NUMBER
 512  64FF              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 513  64FF              ; CHANGES: AF, BC, DE
 514  64FF
 515  64FF              LOCAL_ENASLT:
 516  64FF CD 1F 65         CALL L0353
 517  6502 FA 0C 65         JP M, L0340
 518  6505 DB A8            IN A, (0A8H)
 519  6507 A1               AND C
 520  6508 B0               OR B
 521  6509 D3 A8            OUT (0A8H), A
 522  650B C9               RET
 523  650C              L0340:
 524  650C E5               PUSH HL
 525  650D CD 44 65         CALL L0378
 526  6510 4F               LD C, A
 527  6511 06 00            LD B, 0
 528  6513 7D               LD A, L
 529  6514 A4               AND H
 530  6515 B2               OR D
 531  6516 21 C5 FC         LD HL, 0FCC5H
 532  6519 09               ADD HL, BC
 533  651A 77               LD (HL), A
 534  651B E1               POP HL
 535  651C 79               LD A, C
 536  651D 18 E0            JR LOCAL_ENASLT
 537  651F              L0353:
 538  651F F3               DI
 539  6520 F5               PUSH AF
 540  6521 7C               LD A, H
 541  6522 07               RLCA
 542  6523 07               RLCA
 543  6524 E6 03            AND 3
 544  6526 5F               LD E, A
 545  6527 3E C0            LD A, 0C0H
 546  6529              L035D:
 547  6529 07               RLCA
 548  652A 07               RLCA
 549  652B 1D               DEC E
 550  652C F2 29 65         JP P, L035D
 551  652F 5F               LD E, A
 552  6530 2F               CPL
 553  6531 4F               LD C, A
 554  6532 F1               POP AF
 555  6533 F5               PUSH AF
 556  6534 E6 03            AND 3
 557  6536 3C               INC A
 558  6537 47               LD B, A
 559  6538 3E AB            LD A, 0ABH
 560  653A              L036E:
 561  653A C6 55            ADD A, 055H
 562  653C 10 FC            DJNZ L036E
 563  653E 57               LD D, A
 564  653F A3               AND E
 565  6540 47               LD B, A
 566  6541 F1               POP AF
 567  6542 A7               AND A
 568  6543 C9               RET
 569  6544              L0378:
 570  6544 F5               PUSH AF
 571  6545 7A               LD A, D
 572  6546 E6 C0            AND 0C0H
 573  6548 4F               LD C, A
 574  6549 F1               POP AF
 575  654A F5               PUSH AF
 576  654B 57               LD D, A
 577  654C DB A8            IN A, (0A8H)
 578  654E 47               LD B, A
 579  654F E6 3F            AND 03FH
 580  6551 B1               OR C
 581  6552 D3 A8            OUT (0A8H), A
 582  6554 7A               LD A, D
 583  6555 0F               RRCA
 584  6556 0F               RRCA
 585  6557 E6 03            AND 3
 586  6559 57               LD D, A
 587  655A 3E AB            LD A, 0ABH
 588  655C              L0390:
 589  655C C6 55            ADD A, 055H
 590  655E 15               DEC D
 591  655F F2 5C 65         JP P, L0390
 592  6562 A3               AND E
 593  6563 57               LD D, A
 594  6564 7B               LD A, E
 595  6565 2F               CPL
 596  6566 67               LD H, A
 597  6567 3A FF FF         LD A, (0FFFFH)
 598  656A 2F               CPL
 599  656B 6F               LD L, A
 600  656C A4               AND H
 601  656D B2               OR D
 602  656E 32 FF FF         LD (0FFFFH), A
 603  6571 78               LD A, B
 604  6572 D3 A8            OUT (0A8H), A
 605  6574 F1               POP AF
 606  6575 E6 03            AND 3
 607  6577 C9               RET
 608  6578              ; *******************************************************************************************************
 609  6578
 610  6578              ; *******************************************************************************************************
 611  6578              ; some common code to activate page 0 and place values needed to restore original page on stack
 612  6578              ; input IY=return address
 613  6578              ENABLE_PAGE0:
 614  6578 AF              XOR A
 615  6579 CD B8 64        CALL GET_PAGE_INFO
 616  657C C5              PUSH BC
 617  657D D5              PUSH DE
 618  657E 3A 41 F3        LD A, (RAMAD0)
 619  6581 26 00           LD H, 0
 620  6583 CD FF 64        CALL LOCAL_ENASLT
 621  6586 FD E9        	JP (IY)
 622  6588              ; *******************************************************************************************************
 623  6588
 624  6588              ; General BASIC CALL-instruction handler
 625  6588              CALLHAND:
 626  6588 FB              EI
 627  6589 E5           	PUSH HL
 628  658A 21 CA 62     	LD	HL, CMDS ; pointer table based on starting letter
 629  658D 3A 89 FD        LD A, (PROCNM)
 630  6590 D6 41           SUB 'A'
 631  6592 87              ADD A, A
 632  6593 16 00           LD D, 0
 633  6595 5F              LD E, A
 634  6596 19              ADD HL, DE
 635  6597 5E              LD E, (HL)
 636  6598 23              INC HL
 637  6599 56              LD D, (HL)
 638  659A 7A              LD A, D
 639  659B B3              OR E
 640  659C 28 23           JR Z, .CMDNOTRECOGNIZED
 641  659E EB              EX DE, HL
 642  659F              .CHKCMD:
 643  659F 11 89 FD     	LD	DE, PROCNM
 644  65A2              .LOOP:
 645  65A2 1A              LD	A,(DE)
 646  65A3 BE           	CP	(HL)
 647  65A4 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 648  65A6 13           	INC	DE
 649  65A7 23           	INC	HL
 650  65A8 A7           	AND	A
 651  65A9 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 652  65AB 5E           	LD	E,(HL)
 653  65AC 23           	INC	HL
 654  65AD 56           	LD	D,(HL)
 655  65AE E1           	POP	HL		; routine address
 656  65AF CD D0 65     	CALL	GETPREVCHAR
 657  65B2 CD C4 65     	CALL	.CALLDE		; Call routine
 658  65B5 A7           	AND	A
 659  65B6 C9           	RET
 660  65B7
 661  65B7              .TONEXTCMD:
 662  65B7 0E FF        	LD	C,0FFH
 663  65B9 AF           	XOR	A
 664  65BA ED B1        	CPIR			; Skip to end of instruction name
 665  65BC 23           	INC	HL
 666  65BD 23           	INC	HL		; Skip address
 667  65BE BE           	CP	(HL)
 668  65BF 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 669  65C1              .CMDNOTRECOGNIZED:
 670  65C1 E1           	POP	HL
 671  65C2 37              SCF
 672  65C3 C9           	RET
 673  65C4
 674  65C4              .CALLDE:
 675  65C4 D5           	PUSH	DE
 676  65C5 C9           	RET
 677  65C6
 678  65C6              ;---------------------------
 679  65C6
 680  65C6              ;GETSTRPNT:
 681  65C6              ; OUT:
 682  65C6              ; HL = String Address
 683  65C6              ; B  = Lenght
 684  65C6              ;        LD      HL,(USR)
 685  65C6              ;        LD      B,(HL)
 686  65C6              ;        INC     HL
 687  65C6              ;        LD      E,(HL)
 688  65C6              ;        INC     HL
 689  65C6              ;        LD      D,(HL)
 690  65C6              ;        EX      DE,HL
 691  65C6              ;        RET
 692  65C6
 693  65C6              ;EVALTXTPARAM:
 694  65C6              ;	CALL	CHKCHAR
 695  65C6              ;	DEFB	"("             ; Check for (
 696  65C6              ;	LD	IX,FRMEVL
 697  65C6              ;	CALL	CALBAS		; Evaluate expression
 698  65C6              ;       LD      A,(VALTYP)
 699  65C6              ;        CP      3               ; Text type?
 700  65C6              ;        JP      NZ,TYPE_MISMATCH
 701  65C6              ;        PUSH	HL
 702  65C6              ;        LD	IX,FRESTR         ; Free the temporary string
 703  65C6              ;        CALL	CALBAS
 704  65C6              ;        POP	HL
 705  65C6              ;	CALL	CHKCHAR
 706  65C6              ;	DEFB	")"             ; Check for )
 707  65C6              ;        RET
 708  65C6
 709  65C6
 710  65C6              CHKCHAR:
 711  65C6 CD D0 65     	CALL	GETPREVCHAR	; Get previous basic char
 712  65C9 E3           	EX	(SP),HL
 713  65CA BE           	CP	(HL) 	        ; Check if good char
 714  65CB 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 715  65CD 23           	INC	HL
 716  65CE E3           	EX	(SP),HL
 717  65CF 23           	INC	HL		; Get next basic char
 718  65D0
 719  65D0              GETPREVCHAR:
 720  65D0 2B           	DEC HL
 721  65D1 DD 21 66 46  	LD	IX,CHRGTR
 722  65D5 CD 59 01     	CALL CALBAS
 723  65D8 FB              EI
 724  65D9 C9              RET
 725  65DA
 726  65DA
 727  65DA              TYPE_MISMATCH:
 728  65DA 1E 0D            LD E, 13 ; Type mismatch
 729  65DC 18 0E            JR THROW_ERROR
 730  65DE              SUBSCRIPT_OUT_OF_RANGE:
 731  65DE 1E 09            LD E,9 ; subscript out of range
 732  65E0 18 0A        	JR THROW_ERROR
 733  65E2              OVERFLOW:
 734  65E2 1E 06        	LD E,6
 735  65E4 18 06        	JR THROW_ERROR
 736  65E6              ILLEGAL_FUNCTION:
 737  65E6 1E 05            LD E, 5 ; illegal function call
 738  65E8 18 02            JR THROW_ERROR
 739  65EA              SYNTAX_ERROR:
 740  65EA 1E 02            LD E, 2 ; Syntax error
 741  65EC              THROW_ERROR:
 742  65EC DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 743  65F0 C3 59 01     	JP	CALBAS
 744  65F3
 745  65F3              ;---------------------------
 746  65F3
 747  65F3              ; *******************************************************************************************************
 748  65F3              ; helper function to get pointer to BASIC array data
 749  65F3              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 750  65F3              ; input B=dimensions (1 or 2)
 751  65F3              ; input D=minimal first dimension
 752  65F3              ; input E=minimal second dimension, if applicable
 753  65F3              ; returns BC=pointer to first data element
 754  65F3              ; throws BASIC error if invalid type
 755  65F3              GET_BASIC_ARRAY_DATA_POINTER:
 756  65F3 D5           	PUSH DE
 757  65F4 C5           	PUSH BC
 758  65F5 F5           	PUSH AF
 759  65F6 3E 01           LD A,1
 760  65F8 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 761  65FB DD 21 A4 5E  	LD IX, PTRGET
 762  65FF CD 59 01     	CALL CALBAS
 763  6602 AF              XOR A
 764  6603 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 765  6606 3A 63 F6     	LD A,(VALTYP)
 766  6609 D1           	POP DE ; required type
 767  660A BA           	CP D
 768  660B C2 DA 65     	JP NZ,TYPE_MISMATCH
 769  660E 0A           	LD A,(BC)
 770  660F 03           	INC BC
 771  6610 D1           	POP DE ; required number of dimensions
 772  6611 BA           	CP D
 773  6612 C2 DA 65     	JP NZ,TYPE_MISMATCH
 774  6615 D1           	POP DE ; required minimal array dimensions
 775  6616 3D           	DEC A
 776  6617 28 07        	JR Z,.ONE_DIMENSION
 777  6619              	; 2-dimension array
 778  6619 0A           	LD A,(BC)
 779  661A 03          > INC BC
 779  661B 03          > INC BC
 780  661C BB           	CP E
 781  661D DA DE 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 782  6620              .ONE_DIMENSION:
 783  6620 0A           	LD A,(BC)
 784  6621 03          > INC BC
 784  6622 03          > INC BC
 785  6623 BA           	CP D
 786  6624 DA DE 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 787  6627 C9           	RET
 788  6628              ; *******************************************************************************************************
 789  6628
 790  6628              EXT_END:
 791  6628
# file closed: asm\main.asm
