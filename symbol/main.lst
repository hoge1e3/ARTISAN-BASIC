# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000               DEFINE CMDS_WITH_PARAMETERS
  16  4000
  17  4000              CHPUT   EQU    #A2
  18  4000              CALBAS  EQU		#159
  19  4000              ERRHAND EQU    #406F
  20  4000              FRMEVL  EQU    #4C64
  21  4000              FRESTR  EQU		#67D0
  22  4000              ; FRMQNT = formula quantificator
  23  4000              ; input HL=pointer to current program expression
  24  4000              ; output HL=next address
  25  4000              ; output DE=integer datum
  26  4000              FRMQNT	EQU		#542F
  27  4000              ; GETBYT = get byte parameter
  28  4000              ; input HL=pointer to current program expression
  29  4000              ; output HL=next address
  30  4000              ; output A=E=byte read
  31  4000              GETBYT		EQU	#521C
  32  4000              CHRGTR  	   EQU   #4666
  33  4000              PTRGET		EQU 	#5EA4
  34  4000              SUBFLG		EQU	#F6A5
  35  4000              SYNCHR		EQU	#558C
  36  4000              VALTYP  	   EQU   #F663
  37  4000              DAC         EQU   #F7F6
  38  4000              USR     	   EQU   #F7F8
  39  4000              PROCNM		EQU	#FD89
  40  4000              BIOS_FILVRM EQU   #0056
  41  4000              CLIKSW		EQU	#F3DB
  42  4000
  43  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	   EQU   #FCC1
  48  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  49  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  50  4000              JIFFY	      EQU   #FC9E
  51  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  52  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  53  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  54  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  55  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  56  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  57  4000
  58  4000              ; BASIC error codes
  59  4000              ;01 NEXT without FOR
  60  4000              ;02 Syntax error
  61  4000              ;03 RETURN without GOSUB
  62  4000              ;04 Out of DATA
  63  4000              ;05 Illegal function call
  64  4000              ;06 Overflow
  65  4000              ;07 Out of memory
  66  4000              ;08 Undefined line number
  67  4000              ;09 Subscript out of range
  68  4000              ;10 Redimensioned array
  69  4000              ;11 Division by zero
  70  4000              ;12 Illegal direct
  71  4000              ;13 Type mismatch
  72  4000              ;14 Out of string space
  73  4000              ;15 String too long
  74  4000              ;16 String formula too complex
  75  4000              ;17 Can't CONTINUE
  76  4000              ;18 Undefined user function
  77  4000              ;19 Device I/O error
  78  4000              ;20 Verify error
  79  4000              ;21 No RESUME
  80  4000              ;22 RESUME without error
  81  4000              ;23 Unprintable error
  82  4000              ;24 Missing operand
  83  4000              ;25 Line buffer overflow
  84  4000              ;50 FIELD overflow
  85  4000              ;51 Internal error
  86  4000              ;52 Bad file number
  87  4000              ;53 File not found
  88  4000              ;54 File already open
  89  4000              ;55 Input past end
  90  4000              ;56 Bad file name
  91  4000              ;57 Direct statement in file
  92  4000              ;58 Sequential I/O only
  93  4000              ;59 File not OPEN
  94  4000
  95  4000
  96  4000               ; simulate cartridge with BASIC extension
  97  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  97  4004 E5 64 00 00
  97  4008 00 00 00 00
  97  400C 00 00 00 00
  98  4010
  99  4010              ; this location #4010 stores last location used by basic extension
 100  4010              ; free memory after that point
 101  4010              FREEMEMPTR:
 102  4010 85 65         DW EXT_END
 103  4012
 104  4012              ; this location #4012 stores extension version in DAA format
 105  4012              ; first byte is major version and second minor
 106  4012              VERSION:
 107  4012 00 80         DB #00, #80
 108  4014
 109  4014              ; binary included AKG player compiled at #4014
 110  4014               IF (SOUND_CMDS == 1)
 111  4014              	INCBIN "bin/AKG.bin"
 112  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 113  4CF0               ENDIF
 114  4CF0
 115  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 20 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A AF 58     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13                  ;LD HL,(JIFFY)
  43+ 4D13                  ;INC HL
  44+ 4D13                  ;LD (JIFFY),HL
  45+ 4D13
  46+ 4D13 FD E1            POP IY
  47+ 4D15 DD E1            POP IX
  48+ 4D17 E1               POP HL
  49+ 4D18 D1               POP DE
  50+ 4D19 C1               POP BC
  51+ 4D1A F1               POP AF
  52+ 4D1B 08               EX AF, AF'
  53+ 4D1C D9               EXX
  54+ 4D1D E1               POP HL
  55+ 4D1E D1               POP DE
  56+ 4D1F C1               POP BC
  57+ 4D20               ENDIF
  58+ 4D20
  59+ 4D20              .EXIT:
  60+ 4D20 F1           	POP AF
  61+ 4D21 FB           	EI
  62+ 4D22 ED 4D        	RETI
  63+ 4D24              ; *******************************************************************************************************
  64+ 4D24
  65+ 4D24              ; *******************************************************************************************************
  66+ 4D24              ; H.TIMI function
  67+ 4D24              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D24              MBGE_HTIMI:
  69+ 4D24               EXPORT MBGE_HTIMI
  70+ 4D24
  71+ 4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D24
  73+ 4D24 F5           	PUSH AF
  74+ 4D25
  75+ 4D25              	; enable page 2
  76+ 4D25 3E 02            LD A, 2
  77+ 4D27 CD 15 64         CALL GET_PAGE_INFO
  78+ 4D2A C5               PUSH BC
  79+ 4D2B D5               PUSH DE
  80+ 4D2C 3A 43 F3         LD A, (RAMAD2)
  81+ 4D2F 26 80            LD H, 080H
  82+ 4D31 CD 5C 64         CALL LOCAL_ENASLT
  83+ 4D34              	; enable page 0
  84+ 4D34 AF               XOR A
  85+ 4D35 CD 15 64         CALL GET_PAGE_INFO
  86+ 4D38 C5               PUSH BC
  87+ 4D39 D5               PUSH DE
  88+ 4D3A 3A 41 F3         LD A, (RAMAD0)
  89+ 4D3D 26 00            LD H, 0
  90+ 4D3F CD 5C 64         CALL LOCAL_ENASLT
  91+ 4D42
  92+ 4D42               IF (SPRITE_CMDS == 1)
  93+ 4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D45               ENDIF
  95+ 4D45
  96+ 4D45               IF (SOUND_CMDS == 1)
  97+ 4D45 3A AF 58     	LD A, (SOUND_ENABLED)
  98+ 4D48 B7           	OR A
  99+ 4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4C               ENDIF
 101+ 4D4C
 102+ 4D4C              	; restore page 0
 103+ 4D4C D1               POP DE
 104+ 4D4D C1               POP BC
 105+ 4D4E CD 4C 64         CALL RESTORE_PAGE_INFO
 106+ 4D51              	; restore page 2
 107+ 4D51 D1               POP DE
 108+ 4D52 C1               POP BC
 109+ 4D53 CD 4C 64         CALL RESTORE_PAGE_INFO
 110+ 4D56
 111+ 4D56 F1           	POP AF
 112+ 4D57               ENDIF
 113+ 4D57 C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D5A              ; *******************************************************************************************************
 115+ 4D5A
 116+ 4D5A              ; *******************************************************************************************************
 117+ 4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5A              ; also checks if some VRAM modifying command is running
 119+ 4D5A              ; when that checks out calls sprite updates and animation processing
 120+ 4D5A              ; if in an unsupported mode disables sprite handling
 121+ 4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5A              	; check if initialized
 123+ 4D5A 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D5D B7           	OR A
 125+ 4D5E C8           	RET Z
 126+ 4D5F              	; check screen mode
 127+ 4D5F 3A AF FC     	LD A, (SCRMOD)
 128+ 4D62 3D           	DEC A
 129+ 4D63 28 08        	JR Z, .L0 ; screen 1
 130+ 4D65 3D           	DEC A
 131+ 4D66 28 05            JR Z, .L0 ; screen 2
 132+ 4D68              	; unsupported screen mode, disable
 133+ 4D68 AF               XOR A
 134+ 4D69 32 7C 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6C C9               RET
 136+ 4D6D              .L0:
 137+ 4D6D                  ; check if anyone else is working with VRAM
 138+ 4D6D 3A 2F 62         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D70 B7               OR A
 140+ 4D71 C0               RET NZ
 141+ 4D72
 142+ 4D72 CD 91 4D         CALL SPRATR_UPDATE
 143+ 4D75
 144+ 4D75               IF (ANIM_CMDS == 1)
 145+ 4D75 CD 51 55         CALL PROCESS_ANIMATIONS
 146+ 4D78 CD 1D 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7B               ENDIF
 148+ 4D7B C9               RET
 149+ 4D7C              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 116  4D7C
 117  4D7C               IF (SPRITE_CMDS == 1)
 118  4D7C               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7C              ; commands and variables related to sprites
   2+ 4D7C
   3+ 4D7C              SPRATR_INIT_STATUS:
   4+ 4D7C 00            DB 0
   5+ 4D7D              SPRATR_UPDATE_FLAG:
   6+ 4D7D 00 00         DW 0
   7+ 4D7F              SPRATR_DATA:
   8+ 4D7F 00 00         DW 0
   9+ 4D81              SPRFLICKER_ENABLED:
  10+ 4D81 00            DB 0
  11+ 4D82              ; to support sprite flicker
  12+ 4D82              FLICKER:
  13+ 4D82 00            DB 0
  14+ 4D83
  15+ 4D83              ; to temporarily store stack pointer
  16+ 4D83              TMPSP:
  17+ 4D83 00 00         DW 0
  18+ 4D85
  19+ 4D85              ; *******************************************************************************************************
  20+ 4D85              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D85              ; changes HL,DE
  22+ 4D85              GETnthSPRATTR:
  23+ 4D85 26 00            LD H,0
  24+ 4D87 6F               LD L,A
  25+ 4D88 CD 11 64         CALL HLx8
  26+ 4D8B ED 5B 7F 4D      LD DE,(SPRATR_DATA)
  27+ 4D8F 19               ADD HL,DE
  28+ 4D90 C9               RET
  29+ 4D91              ; *******************************************************************************************************
  30+ 4D91
  31+ 4D91              ; *******************************************************************************************************
  32+ 4D91              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D91              ; struct {
  34+ 4D91              ; DW y
  35+ 4D91              ; DW x
  36+ 4D91              ; DW pattern (0-63)
  37+ 4D91              ; DW color
  38+ 4D91              ; } [32]
  39+ 4D91              ; will hide sprites whose location is outside of visible area
  40+ 4D91              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D91              ; modifies AF, AF', BC, DE, HL
  42+ 4D91              SPRATR_UPDATE:
  43+ 4D91              	; check if update requested
  44+ 4D91 2A 7D 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D94 7E           	LD A, (HL)
  46+ 4D95 B7           	OR A
  47+ 4D96 C8           	RET Z
  48+ 4D97              .L0:
  49+ 4D97 06 20        	LD B, 32 ; sprite number
  50+ 4D99 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D9B              	; set VDP address
  52+ 4D9B 3A AF FC         LD A,(SCRMOD)
  53+ 4D9E 3D               DEC A
  54+ 4D9F 20 05            JR NZ,.L4
  55+ 4DA1 2A C3 F3         LD HL, (T32ATR)
  56+ 4DA4 18 03            JR .L5
  57+ 4DA6              .L4:
  58+ 4DA6 2A CD F3         LD HL, (GRPATR)
  59+ 4DA9              .L5:
  60+ 4DA9 3A 81 4D     	LD A, (SPRFLICKER_ENABLED)
  61+ 4DAC B7           	OR A
  62+ 4DAD 28 03        	JR Z, .L3
  63+ 4DAF 3A 82 4D     	LD A, (FLICKER)
  64+ 4DB2              .L3:
  65+ 4DB2 5F           	LD E, A
  66+ 4DB3 08           	EX AF, AF'
  67+ 4DB4 7B           	LD A, E
  68+ 4DB5 87           	ADD A, A
  69+ 4DB6 87           	ADD A, A
  70+ 4DB7 16 00        	LD D, 0
  71+ 4DB9 5F           	LD E, A
  72+ 4DBA 19           	ADD HL, DE
  73+ 4DBB CD FC 63     	CALL SETWRT_LOCAL
  74+ 4DBE ED 73 83 4D  	LD (TMPSP), SP
  75+ 4DC2 ED 7B 7F 4D  	LD SP, (SPRATR_DATA)
  76+ 4DC6
  77+ 4DC6              .LOOP:
  78+ 4DC6 E1           	POP HL
  79+ 4DC7 24           	INC H
  80+ 4DC8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  81+ 4DCA 25           	DEC H
  82+ 4DCB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  83+ 4DCD 7D           	LD A, L
  84+ 4DCE FE C0        	CP 192
  85+ 4DD0 30 10        	JR NC, .OUT3
  86+ 4DD2 3D           	DEC A ; due to VDP rule that top of screen is -1
  87+ 4DD3 57           	LD D, A
  88+ 4DD4 C3 FB 4D     	JP .X
  89+ 4DD7              .L1:
  90+ 4DD7 7D           	LD A, L
  91+ 4DD8 C6 10        	ADD 16
  92+ 4DDA FA E2 4D     	JP M, .OUT3 ; below -16
  93+ 4DDD 2D           	DEC L ; due to VDP rule that top of screen is -1
  94+ 4DDE 55           	LD D, L
  95+ 4DDF C3 FB 4D     	JP .X
  96+ 4DE2              .OUT3:
  97+ 4DE2 E1           	POP HL ; skip x value
  98+ 4DE3              .OUT2:
  99+ 4DE3 E1           	POP HL ; skip pattern
 100+ 4DE4 E1           	POP HL ; skip color
 101+ 4DE5 3E D1        	LD A, #D1
 102+ 4DE7 ED 79        	OUT (C), A ; sprite hidden
 103+ 4DE9 00          > NOP
 103+ 4DEA 00          > NOP
 103+ 4DEB 00          > NOP
 104+ 4DEC ED 79        	OUT (C), A ; value unimportant
 105+ 4DEE 00          > NOP
 105+ 4DEF 00          > NOP
 105+ 4DF0 00          > NOP
 106+ 4DF1 ED 79        	OUT (C), A ; value unimportant
 107+ 4DF3 00          > NOP
 107+ 4DF4 00          > NOP
 107+ 4DF5 00          > NOP
 108+ 4DF6 ED 79        	OUT (C), A ; value unimportant
 109+ 4DF8 C3 26 4E     	JP .NEXT
 110+ 4DFB              .X:
 111+ 4DFB E1           	POP HL
 112+ 4DFC 24           	INC H
 113+ 4DFD 28 08        	JR Z, .L2
 114+ 4DFF 25           	DEC H
 115+ 4E00 20 E1        	JR NZ, .OUT2
 116+ 4E02 1E 00        	LD E, 0 ; EC bit
 117+ 4E04 C3 10 4E     	JP .XY
 118+ 4E07              .L2:
 119+ 4E07 7D           	LD A, L
 120+ 4E08 C6 20        	ADD 32
 121+ 4E0A FA E3 4D     	JP M, .OUT2
 122+ 4E0D 6F           	LD L, A
 123+ 4E0E 1E 80        	LD E, #80
 124+ 4E10              .XY:
 125+ 4E10 ED 51        	OUT (C), D
 126+ 4E12 3A E0 F3     	LD A, (REG1SAV)
 127+ 4E15 E6 02        	AND 2
 128+ 4E17 ED 69        	OUT (C), L
 129+ 4E19 E1           	POP HL ; pattern
 130+ 4E1A 7D           	LD A, L
 131+ 4E1B 28 02        	JR Z, .SMALLSPRITES
 132+ 4E1D 87           	ADD A, A
 133+ 4E1E 87           	ADD A, A ; needs to go at 4x
 134+ 4E1F              .SMALLSPRITES:
 135+ 4E1F D3 98        	OUT (#98), A
 136+ 4E21 E1           	POP HL ; color
 137+ 4E22 7D           	LD A, L
 138+ 4E23 B3           	OR E
 139+ 4E24 D3 98        	OUT (#98), A
 140+ 4E26              .NEXT:
 141+ 4E26 08           	EX AF, AF'
 142+ 4E27 3C           	INC A
 143+ 4E28 E6 1F        	AND 31
 144+ 4E2A C2 49 4E     	JP NZ, .NEXT2
 145+ 4E2D 08           	EX AF, AF'
 146+ 4E2E 3A AF FC         LD A,(SCRMOD)
 147+ 4E31 3D               DEC A
 148+ 4E32 20 05            JR NZ,.L6
 149+ 4E34 2A C3 F3         LD HL, (T32ATR)
 150+ 4E37 18 03            JR .L7
 151+ 4E39              .L6:
 152+ 4E39 2A CD F3         LD HL, (GRPATR)
 153+ 4E3C              .L7:
 154+ 4E3C              	; CALL SETWRT_LOCAL not allowed as SP modified
 155+ 4E3C 7D           	LD	A, L
 156+ 4E3D D3 99        	OUT	(099H), A
 157+ 4E3F 7C           	LD	A, H
 158+ 4E40 E6 3F        	AND	03FH
 159+ 4E42 F6 40        	OR	040H
 160+ 4E44 D3 99        	OUT	(099H), A
 161+ 4E46 C3 4A 4E     	JP .NEXT3
 162+ 4E49              .NEXT2:
 163+ 4E49 08           	EX AF, AF'
 164+ 4E4A              .NEXT3:
 165+ 4E4A 05           	DEC B
 166+ 4E4B C2 C6 4D     	JP NZ, .LOOP
 167+ 4E4E 08           	EX AF, AF'
 168+ 4E4F 3C           	INC A
 169+ 4E50 32 82 4D     	LD (FLICKER), A
 170+ 4E53
 171+ 4E53 ED 7B 83 4D  	LD SP, (TMPSP)
 172+ 4E57 2A 7D 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 173+ 4E5A 36 00        	LD (HL), 0 ; zero out update flag
 174+ 4E5C C9           	RET
 175+ 4E5D              ; *******************************************************************************************************
 176+ 4E5D
 177+ 4E5D              ; *******************************************************************************************************
 178+ 4E5D              ; function to handle CALL SPRENABLE basic extension
 179+ 4E5D              ; initializes sprites handler
 180+ 4E5D              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 181+ 4E5D              ;			   INT variable update_variable,
 182+ 4E5D              ;			   BYTE sprite_flicker_enabled )
 183+ 4E5D              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 184+ 4E5D              SPRENABLE:
 185+ 4E5D              	; opening (
 186+ 4E5D CD 23 65     	CALL CHKCHAR
 187+ 4E60 28           	DB '('
 188+ 4E61              	; get address of sprite attribute table DIM SA%(3,31)
 189+ 4E61 3E 02        	LD A,2
 190+ 4E63 06 02        	LD B,2
 191+ 4E65 11 20 04     	LD DE,#0420
 192+ 4E68 CD 50 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 193+ 4E6B C5           	PUSH BC
 194+ 4E6C              	; comma
 195+ 4E6C CD 23 65     	CALL CHKCHAR
 196+ 4E6F 2C           	DB ','
 197+ 4E70              	; get address of sprite update flag
 198+ 4E70 DD 21 A4 5E  	LD IX, PTRGET
 199+ 4E74 CD 59 01     	CALL CALBAS
 200+ 4E77 D5           	PUSH DE
 201+ 4E78              	; comma
 202+ 4E78 CD 23 65     	CALL CHKCHAR
 203+ 4E7B 2C           	DB ','
 204+ 4E7C              	; get flicker enabled flag
 205+ 4E7C DD 21 1C 52  	LD IX, GETBYT
 206+ 4E80 CD 59 01     	CALL CALBAS
 207+ 4E83 F5           	PUSH AF
 208+ 4E84              	; ending )
 209+ 4E84 CD 23 65     	CALL CHKCHAR
 210+ 4E87 29           	DB ')'
 211+ 4E88
 212+ 4E88 F1           	POP AF ; get flicker flag
 213+ 4E89 B7           	OR A
 214+ 4E8A 32 81 4D     	LD (SPRFLICKER_ENABLED), A
 215+ 4E8D
 216+ 4E8D D1           	POP DE ; update variable location
 217+ 4E8E ED 53 7D 4D  	LD (SPRATR_UPDATE_FLAG), DE
 218+ 4E92 D1           	POP DE ; address of sprite attribute table
 219+ 4E93 ED 53 7F 4D  	LD (SPRATR_DATA), DE
 220+ 4E97 3E 01        	LD A, 1
 221+ 4E99 32 7C 4D     	LD (SPRATR_INIT_STATUS), A
 222+ 4E9C C9           	RET
 223+ 4E9D              ; *******************************************************************************************************
 224+ 4E9D
 225+ 4E9D              ; *******************************************************************************************************
 226+ 4E9D              ; function to handle CALL SPRDISABLE basic extension
 227+ 4E9D              ; disables sprites handling
 228+ 4E9D              ; _SPRDISABLE
 229+ 4E9D              ; resets variable SPRATR_INIT_STATUS
 230+ 4E9D              SPRDISABLE:
 231+ 4E9D AF           	XOR A
 232+ 4E9E 32 7C 4D     	LD (SPRATR_INIT_STATUS), A
 233+ 4EA1 C9           	RET
 234+ 4EA2              ; *******************************************************************************************************
 235+ 4EA2
 236+ 4EA2              ; *******************************************************************************************************
 237+ 4EA2              ; function to handle CALL SPRSET basic extension
 238+ 4EA2              ; sets position, and optionally pattern and color of sprite
 239+ 4EA2              ; _SPRSET ( BYTE sprite_num , valid 0-31
 240+ 4EA2              ;			INT x,
 241+ 4EA2              ;			INT y,
 242+ 4EA2              ;			INT pattern, valid 0-63, otherwise ignored
 243+ 4EA2              ;			INT color, valid 0-15, otherwise ignored
 244+ 4EA2              ;SPRSET:
 245+ 4EA2              ;	LD A, (SPRATR_INIT_STATUS)
 246+ 4EA2              ;	OR A
 247+ 4EA2              ;	JR NZ, .L1
 248+ 4EA2              ;	LD E, 5 ; illegal function call
 249+ 4EA2              ;	JP THROW_ERROR
 250+ 4EA2              ;.L1:
 251+ 4EA2              ;	; opening (
 252+ 4EA2              ;	CALL CHKCHAR
 253+ 4EA2              ;	DB '('
 254+ 4EA2              ;	; get sprite number
 255+ 4EA2              ;	LD IX, GETBYT
 256+ 4EA2              ;	CALL CALBAS
 257+ 4EA2              ;	PUSH AF
 258+ 4EA2              ;	; comma
 259+ 4EA2              ;	CALL CHKCHAR
 260+ 4EA2              ;	DB ','
 261+ 4EA2              ;	; get x
 262+ 4EA2              ;	LD IX, FRMQNT
 263+ 4EA2              ;	CALL CALBAS
 264+ 4EA2              ;	PUSH DE
 265+ 4EA2              ;	; comma
 266+ 4EA2              ;	CALL CHKCHAR
 267+ 4EA2              ;	DB ','
 268+ 4EA2              ;	; get y
 269+ 4EA2              ;	LD IX, FRMQNT
 270+ 4EA2              ;	CALL CALBAS
 271+ 4EA2              ;	PUSH DE
 272+ 4EA2              ;	; comma
 273+ 4EA2              ;	CALL CHKCHAR
 274+ 4EA2              ;	DB ','
 275+ 4EA2              ;	; get pattern
 276+ 4EA2              ;	LD IX, FRMQNT
 277+ 4EA2              ;	CALL CALBAS
 278+ 4EA2              ;	PUSH DE
 279+ 4EA2              ;	; comma
 280+ 4EA2              ;	CALL CHKCHAR
 281+ 4EA2              ;	DB ','
 282+ 4EA2              ;	; get color
 283+ 4EA2              ;	LD IX, FRMQNT
 284+ 4EA2              ;	CALL CALBAS
 285+ 4EA2              ;	PUSH DE
 286+ 4EA2              ;	; ending )
 287+ 4EA2              ;	CALL CHKCHAR
 288+ 4EA2              ;	DB ')'
 289+ 4EA2              ;
 290+ 4EA2              ;   ; save position in BASIC text
 291+ 4EA2              ;	PUSH HL
 292+ 4EA2              ;	POP IX
 293+ 4EA2              ;
 294+ 4EA2              ;	POP BC ; color
 295+ 4EA2              ;	POP DE ; pattern
 296+ 4EA2              ;	EXX
 297+ 4EA2              ;	POP BC ; y
 298+ 4EA2              ;	POP DE ; x
 299+ 4EA2              ;	POP AF ; sprite number
 300+ 4EA2              ;	CP 32
 301+ 4EA2              ;	JR C, .L2
 302+ 4EA2              ;	LD E, 5 ; illegal function call
 303+ 4EA2              ;	JP THROW_ERROR
 304+ 4EA2              ;.L2:
 305+ 4EA2              ;	; find location in sprite attributes table
 306+ 4EA2              ;	PUSH DE
 307+ 4EA2              ;	CALL GETnthSPRATTR
 308+ 4EA2              ;	POP DE
 309+ 4EA2              ;	DI
 310+ 4EA2              ;	; set y
 311+ 4EA2              ;	LD (HL), C
 312+ 4EA2              ;	INC HL
 313+ 4EA2              ;	LD (HL), B
 314+ 4EA2              ;	INC HL
 315+ 4EA2              ;	; set x
 316+ 4EA2              ;	LD (HL), E
 317+ 4EA2              ;	INC HL
 318+ 4EA2              ;	LD (HL), D
 319+ 4EA2              ;	INC HL
 320+ 4EA2              ;	PUSH HL
 321+ 4EA2              ;	EXX
 322+ 4EA2              ;	POP HL
 323+ 4EA2              ;	; check if 0<=pattern<64
 324+ 4EA2              ;	LD A, D
 325+ 4EA2              ;	OR A
 326+ 4EA2              ;	JR NZ, .L3
 327+ 4EA2              ;	LD A, E
 328+ 4EA2              ;	CP 64
 329+ 4EA2              ;	JR NC, .L3
 330+ 4EA2              ;	; set pattern
 331+ 4EA2              ;	;ADD A, A
 332+ 4EA2              ;	;ADD A, A
 333+ 4EA2              ;	;ADD A, A
 334+ 4EA2              ;	LD (HL), A
 335+ 4EA2              ;	INC HL
 336+ 4EA2              ;	LD (HL), D
 337+ 4EA2              ;	INC HL
 338+ 4EA2              ;	JR .L4
 339+ 4EA2              ;.L3:
 340+ 4EA2              ;	; skip pattern
 341+ 4EA2              ;	.2 INC HL
 342+ 4EA2              ;.L4:
 343+ 4EA2              ;	; check if 0<=color<16
 344+ 4EA2              ;	LD A, B
 345+ 4EA2              ;	OR A
 346+ 4EA2              ;	JR NZ, .L5
 347+ 4EA2              ;	LD A, C
 348+ 4EA2              ;	CP 16
 349+ 4EA2              ;	JR NC, .L5
 350+ 4EA2              ;	; set color
 351+ 4EA2              ;	LD (HL), C
 352+ 4EA2              ;	INC HL
 353+ 4EA2              ;	LD (HL), B
 354+ 4EA2              ;
 355+ 4EA2              ;.L5:
 356+ 4EA2              ;	EI
 357+ 4EA2              ;	PUSH IX
 358+ 4EA2              ;	POP HL
 359+ 4EA2              ;	RET
 360+ 4EA2              ; *******************************************************************************************************
 361+ 4EA2
 362+ 4EA2              ; *******************************************************************************************************
 363+ 4EA2              ; function sets sprite location based on initial coordinates and offset provided
 364+ 4EA2              ; input A=sprite number in SPRATR_DATA , 0-31
 365+ 4EA2              ; input DE=initial x
 366+ 4EA2              ; input BC=initial y
 367+ 4EA2              ; input IY=location where delta y,x are located
 368+ 4EA2              ; modifies AF, HL, IX
 369+ 4EA2              SPRSET_DELTA_POS:
 370+ 4EA2 D5           	PUSH DE
 371+ 4EA3 CD 85 4D     	CALL GETnthSPRATTR
 372+ 4EA6 E5           	PUSH HL
 373+ 4EA7 DD E1        	POP IX
 374+ 4EA9 D1           	POP DE
 375+ 4EAA              	; IX=sprite's y location
 376+ 4EAA FD 6E 00     	LD L, (IY)
 377+ 4EAD FD 66 01     	LD H, (IY+1)
 378+ 4EB0 09           	ADD HL, BC
 379+ 4EB1 DD 75 00     	LD (IX), L
 380+ 4EB4 DD 74 01     	LD (IX+1), H
 381+ 4EB7 FD 6E 02     	LD L, (IY+2)
 382+ 4EBA FD 66 03     	LD H, (IY+3)
 383+ 4EBD 19           	ADD HL, DE
 384+ 4EBE DD 75 02     	LD (IX+2), L
 385+ 4EC1 DD 74 03     	LD (IX+3), H
 386+ 4EC4 C9           	RET
 387+ 4EC5              ; *******************************************************************************************************
 388+ 4EC5
 389+ 4EC5              ; *******************************************************************************************************
 390+ 4EC5              ; function to handle CALL SPRGRPMOV basic extension
 391+ 4EC5              ; sets position of a group of sprites described with
 392+ 4EC5              ; { int sprite_num, int delta_y, int delta_x } [count]
 393+ 4EC5              ; _SPRGRPMOV ( INT x,
 394+ 4EC5              ;			   INT y,
 395+ 4EC5              ;			   BYTE count,
 396+ 4EC5              ;			   INT[2][count] data_ptr
 397+ 4EC5              SPRGRPMOV:
 398+ 4EC5 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 399+ 4EC8 B7           	OR A
 400+ 4EC9 CA 43 65     	JP Z,ILLEGAL_FUNCTION
 401+ 4ECC              	; opening (
 402+ 4ECC CD 23 65     	CALL CHKCHAR
 403+ 4ECF 28           	DB '('
 404+ 4ED0              	; get x
 405+ 4ED0 DD 21 2F 54  	LD IX, FRMQNT
 406+ 4ED4 CD 59 01     	CALL CALBAS
 407+ 4ED7 ED 53 1E 62  	LD (BLIT_STRUCT),DE
 408+ 4EDB              	; comma
 409+ 4EDB CD 23 65     	CALL CHKCHAR
 410+ 4EDE 2C           	DB ','
 411+ 4EDF              	; get y
 412+ 4EDF DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EE3 CD 59 01     	CALL CALBAS
 414+ 4EE6 ED 53 20 62  	LD (BLIT_STRUCT+2),DE
 415+ 4EEA              	; comma
 416+ 4EEA CD 23 65     	CALL CHKCHAR
 417+ 4EED 2C           	DB ','
 418+ 4EEE              	; get count
 419+ 4EEE DD 21 1C 52  	LD IX, GETBYT
 420+ 4EF2 CD 59 01     	CALL CALBAS
 421+ 4EF5 32 22 62     	LD (BLIT_STRUCT+4),A
 422+ 4EF8              	; comma
 423+ 4EF8 CD 23 65     	CALL CHKCHAR
 424+ 4EFB 2C           	DB ','
 425+ 4EFC              	; get sprite group definition array data pointer
 426+ 4EFC 3A 22 62     	LD A,(BLIT_STRUCT+4)
 427+ 4EFF 5F           	LD E,A
 428+ 4F00 16 03        	LD D,3
 429+ 4F02 3E 02        	LD A,2
 430+ 4F04 47           	LD B,A
 431+ 4F05 CD 50 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 432+ 4F08 ED 43 23 62  	LD (BLIT_STRUCT+5),BC
 433+ 4F0C              	; ending )
 434+ 4F0C CD 23 65     	CALL CHKCHAR
 435+ 4F0F 29           	DB ')'
 436+ 4F10
 437+ 4F10 E5           	PUSH HL
 438+ 4F11
 439+ 4F11 D9               EXX
 440+ 4F12 ED 5B 1E 62      LD DE,(BLIT_STRUCT) ; initial x
 441+ 4F16 ED 4B 20 62      LD BC,(BLIT_STRUCT+2) ; initial y
 442+ 4F1A D9               EXX
 443+ 4F1B 2A 23 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 444+ 4F1E 3A 22 62         LD A,(BLIT_STRUCT+4) ; number of entries
 445+ 4F21 47               LD B,A
 446+ 4F22 3E 01        	LD A,1
 447+ 4F24 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4F27 F3           	DI
 449+ 4F28 CD 32 4F     	CALL .UPDATE_LOC
 450+ 4F2B FB           	EI
 451+ 4F2C AF           	XOR A
 452+ 4F2D 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 453+ 4F30
 454+ 4F30 E1           	POP HL
 455+ 4F31 C9           	RET
 456+ 4F32
 457+ 4F32              .UPDATE_LOC:
 458+ 4F32 7E           	LD A, (HL)
 459+ 4F33 23           	INC HL
 460+ 4F34 23           	INC HL
 461+ 4F35 E5           	PUSH HL
 462+ 4F36 FD E1        	POP IY
 463+ 4F38 D9           	EXX
 464+ 4F39 CD A2 4E     	CALL SPRSET_DELTA_POS
 465+ 4F3C D9           	EXX
 466+ 4F3D 23          > INC HL
 466+ 4F3E 23          > INC HL
 466+ 4F3F 23          > INC HL
 466+ 4F40 23          > INC HL
 467+ 4F41 10 EF        	DJNZ .UPDATE_LOC
 468+ 4F43 C9           	RET
 469+ 4F44              ; *******************************************************************************************************
 470+ 4F44
# file closed: asm\SPRITES.asm
 119  4F44               ENDIF
 120  4F44
 121  4F44               IF (ANIM_CMDS == 1)
 122  4F44               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F44              ; sprite animation routines
   2+ 4F44
   3+ 4F44              ; number of animation items and pointer
   4+ 4F44              ANIMITEMNUM:
   5+ 4F44 00            DB 0
   6+ 4F45              ANIMITEMPTR:
   7+ 4F45 85 65         DW EXT_END
   8+ 4F47              ; number of animation definitions and pointer
   9+ 4F47              ANIMDEFNUM:
  10+ 4F47 00            DB 0
  11+ 4F48              ANIMDEFPTR:
  12+ 4F48 85 65         DW EXT_END
  13+ 4F4A              ; number of links between sprite and animation definitions
  14+ 4F4A              ANIMSPRNUM:
  15+ 4F4A 00            DB 0
  16+ 4F4B              ANIMSPRPTR:
  17+ 4F4B 85 65         DW EXT_END
  18+ 4F4D              ; number of automatic sprite group move and animate structures
  19+ 4F4D              AUTOSGAMNUM:
  20+ 4F4D 00            DB 0
  21+ 4F4E              AUTOSGAMPTR:
  22+ 4F4E 85 65         DW EXT_END
  23+ 4F50
  24+ 4F50              ; ANIMATION ITEM
  25+ 4F50              ; byte type = [0 - pattern and color change
  26+ 4F50              ;              1 - pattern definition change ]
  27+ 4F50              ; word ticks - number of ticks to hold this state
  28+ 4F50              ; for type = 0
  29+ 4F50              ;   byte pattern;
  30+ 4F50              ;   byte color;
  31+ 4F50              ; for type = 1
  32+ 4F50              ;   work data_pointer;
  33+ 4F50              ; total size = 5b
  34+ 4F50
  35+ 4F50              ; ANIMATION DEFINITION
  36+ 4F50              ; byte number of items 1-15
  37+ 4F50              ; byte[15] anim_item;
  38+ 4F50              ; total size = 16b
  39+ 4F50
  40+ 4F50              ; SPRITE/CHAR ANIMATION
  41+ 4F50              ; +00 byte sprite/char number;
  42+ 4F50              ; +01 word time;
  43+ 4F50              ; +03 byte current item;
  44+ 4F50              ; +04 byte animation definition;
  45+ 4F50              ; +05 byte cyclic;
  46+ 4F50              ; +06 byte active;
  47+ 4F50              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F50              ; total size = 8b
  49+ 4F50
  50+ 4F50              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F50              ; +00 pointer to X variable
  52+ 4F50              ; +02 pointer to Y variable
  53+ 4F50              ; +04 minimum value
  54+ 4F50              ; +06 maximal value
  55+ 4F50              ; +08 delta value
  56+ 4F50              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F50              ; +11 sprite group size
  58+ 4F50              ; +12 sprite group pointer
  59+ 4F50              ; +14 animation list size
  60+ 4F50              ; +15 animation list pointer for negative delta values
  61+ 4F50              ; +17 animation list pointer for positive delta values
  62+ 4F50              ; +19 active flag
  63+ 4F50              ; +20 ticks for movement
  64+ 4F50              ; +22 timer
  65+ 4F50              ; total = 24b
  66+ 4F50
  67+ 4F50              ; *******************************************************************************************************
  68+ 4F50              ; helper function HL=A*5
  69+ 4F50              ; changes HL,DE
  70+ 4F50              Ax5:
  71+ 4F50 26 00            LD H,0
  72+ 4F52 6F               LD L,A
  73+ 4F53 54               LD D,H
  74+ 4F54 5D               LD E,L
  75+ 4F55 29               ADD HL,HL
  76+ 4F56 29               ADD HL,HL
  77+ 4F57 19               ADD HL,DE
  78+ 4F58 C9               RET
  79+ 4F59              ; *******************************************************************************************************
  80+ 4F59
  81+ 4F59              ; *******************************************************************************************************
  82+ 4F59              ; helper function gets pointer to n-th animation item
  83+ 4F59              ; changes HL,DE
  84+ 4F59              GETnthANIMITEM:
  85+ 4F59 CD 50 4F         CALL Ax5
  86+ 4F5C ED 5B 45 4F      LD DE,(ANIMITEMPTR)
  87+ 4F60 19               ADD HL,DE
  88+ 4F61 C9               RET
  89+ 4F62              ; *******************************************************************************************************
  90+ 4F62
  91+ 4F62              ; *******************************************************************************************************
  92+ 4F62              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F62              ; changes HL,DE
  94+ 4F62              GETnthANIMDEF:
  95+ 4F62 26 00            LD H,0
  96+ 4F64 6F               LD L,A
  97+ 4F65 CD 10 64         CALL HLx16
  98+ 4F68 ED 5B 48 4F      LD DE,(ANIMDEFPTR)
  99+ 4F6C 19               ADD HL,DE
 100+ 4F6D C9               RET
 101+ 4F6E              ; *******************************************************************************************************
 102+ 4F6E
 103+ 4F6E              ; *******************************************************************************************************
 104+ 4F6E              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F6E              ; changes HL,DE
 106+ 4F6E              GETnthSPRANIM:
 107+ 4F6E 26 00            LD H,0
 108+ 4F70 6F               LD L,A
 109+ 4F71 CD 11 64         CALL HLx8
 110+ 4F74 ED 5B 4B 4F      LD DE,(ANIMSPRPTR)
 111+ 4F78 19               ADD HL,DE
 112+ 4F79 C9               RET
 113+ 4F7A              ; *******************************************************************************************************
 114+ 4F7A
 115+ 4F7A              ; *******************************************************************************************************
 116+ 4F7A              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F7A              ; changes HL,DE
 118+ 4F7A              GETnthAUTOSGAM:
 119+ 4F7A 26 00            LD H,0
 120+ 4F7C 6F               LD L,A
 121+ 4F7D CD 11 64         CALL HLx8
 122+ 4F80 54               LD D,H
 123+ 4F81 5D               LD E,L
 124+ 4F82 29               ADD HL,HL
 125+ 4F83 19               ADD HL,DE
 126+ 4F84 ED 5B 4E 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F88 19               ADD HL,DE
 128+ 4F89 C9               RET
 129+ 4F8A              ; *******************************************************************************************************
 130+ 4F8A
 131+ 4F8A              ; *******************************************************************************************************
 132+ 4F8A              ; function to handle CALL MAXANIMITEMS basic extension
 133+ 4F8A              ; MAXANIMITEMS (BYTE number)
 134+ 4F8A              ; sets new number and moves memory buffers as needed
 135+ 4F8A              MAXANIMITEMS:
 136+ 4F8A              	; opening (
 137+ 4F8A CD 23 65     	CALL CHKCHAR
 138+ 4F8D 28           	DB '('
 139+ 4F8E              	; get value
 140+ 4F8E DD 21 1C 52  	LD IX, GETBYT
 141+ 4F92 CD 59 01     	CALL CALBAS
 142+ 4F95 F5               PUSH AF
 143+ 4F96              	; ending )
 144+ 4F96 CD 23 65     	CALL CHKCHAR
 145+ 4F99 29           	DB ')'
 146+ 4F9A F1               POP AF
 147+ 4F9B F3               DI
 148+ 4F9C              	; save position
 149+ 4F9C E5           	PUSH HL
 150+ 4F9D              .ENTRY:
 151+ 4F9D 47               LD B,A
 152+ 4F9E 3A 44 4F         LD A,(ANIMITEMNUM)
 153+ 4FA1 90               SUB B
 154+ 4FA2 28 28            JR Z, .EXIT; same value as before
 155+ 4FA4 FD 21 48 4F      LD IY,ANIMDEFPTR
 156+ 4FA8 FA CF 4F         JP M, .INCREASE
 157+ 4FAB                  ; new value is lower than previous one
 158+ 4FAB CD EE 4F         CALL .SIZEDIFF
 159+ 4FAE CD 09 50         CALL .DECREASE_COMMON
 160+ 4FB1 2A 4B 4F         LD HL,(ANIMSPRPTR)
 161+ 4FB4 AF               XOR A
 162+ 4FB5 ED 42            SBC HL,BC
 163+ 4FB7 22 4B 4F         LD (ANIMSPRPTR),HL
 164+ 4FBA              .E1:
 165+ 4FBA 2A 4E 4F         LD HL,(AUTOSGAMPTR)
 166+ 4FBD AF               XOR A
 167+ 4FBE ED 42            SBC HL,BC
 168+ 4FC0 22 4E 4F         LD (AUTOSGAMPTR),HL
 169+ 4FC3              .E3:
 170+ 4FC3 2A 10 40         LD HL,(FREEMEMPTR)
 171+ 4FC6 AF               XOR A
 172+ 4FC7 ED 42            SBC HL,BC
 173+ 4FC9 22 10 40         LD (FREEMEMPTR),HL
 174+ 4FCC              .EXIT:
 175+ 4FCC FB               EI
 176+ 4FCD E1           	POP HL
 177+ 4FCE C9           	RET
 178+ 4FCF              .INCREASE:
 179+ 4FCF ED 44            NEG
 180+ 4FD1 CD EE 4F         CALL .SIZEDIFF
 181+ 4FD4 CD 35 50         CALL .INCREASE_COMMON
 182+ 4FD7 2A 4B 4F         LD HL,(ANIMSPRPTR)
 183+ 4FDA 09               ADD HL,BC
 184+ 4FDB 22 4B 4F         LD (ANIMSPRPTR),HL
 185+ 4FDE              .E2:
 186+ 4FDE 2A 4E 4F         LD HL,(AUTOSGAMPTR)
 187+ 4FE1 09               ADD HL,BC
 188+ 4FE2 22 4E 4F         LD (AUTOSGAMPTR),HL
 189+ 4FE5              .E4:
 190+ 4FE5 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 4FE8 09               ADD HL,BC
 192+ 4FE9 22 10 40         LD (FREEMEMPTR),HL
 193+ 4FEC 18 DE            JR .EXIT
 194+ 4FEE              .SIZEDIFF:
 195+ 4FEE CD 50 4F         CALL Ax5
 196+ 4FF1 78               LD A,B
 197+ 4FF2 32 44 4F         LD (ANIMITEMNUM),A
 198+ 4FF5 44               LD B,H
 199+ 4FF6 4D               LD C,L
 200+ 4FF7 C9               RET ; BC=size difference in bytes
 201+ 4FF8              .SIZETOMOVE:
 202+ 4FF8 D5               PUSH DE
 203+ 4FF9 2A 10 40         LD HL,(FREEMEMPTR)
 204+ 4FFC FD 5E 00         LD E,(IY)
 205+ 4FFF FD 56 01         LD D,(IY+1)
 206+ 5002 AF               XOR A
 207+ 5003 ED 52            SBC HL,DE
 208+ 5005 44               LD B,H
 209+ 5006 4D               LD C,L
 210+ 5007 D1               POP DE
 211+ 5008 C9               RET
 212+ 5009              .DECREASE_COMMON:
 213+ 5009 FD 6E 00         LD L,(IY)
 214+ 500C FD 66 01         LD H,(IY+1)
 215+ 500F AF               XOR A
 216+ 5010 ED 42            SBC HL,BC
 217+ 5012 EB               EX DE,HL
 218+ 5013 C5               PUSH BC
 219+ 5014 CD F8 4F         CALL .SIZETOMOVE
 220+ 5017 F3               DI
 221+ 5018 78               LD A,B
 222+ 5019 B1               OR C
 223+ 501A 28 08            JR Z,.L1
 224+ 501C FD 6E 00         LD L,(IY)
 225+ 501F FD 66 01         LD H,(IY+1)
 226+ 5022 ED B0            LDIR
 227+ 5024              .L1:
 228+ 5024 C1               POP BC
 229+ 5025 FD 6E 00         LD L,(IY)
 230+ 5028 FD 66 01         LD H,(IY+1)
 231+ 502B AF               XOR A
 232+ 502C ED 42            SBC HL,BC
 233+ 502E FD 75 00         LD (IY),L
 234+ 5031 FD 74 01         LD (IY+1),H
 235+ 5034 C9               RET
 236+ 5035              .INCREASE_COMMON:
 237+ 5035 2A 10 40         LD HL,(FREEMEMPTR)
 238+ 5038 2B               DEC HL
 239+ 5039 AF               XOR A
 240+ 503A ED 42            SBC HL,BC
 241+ 503C EB               EX DE,HL
 242+ 503D C5               PUSH BC
 243+ 503E CD F8 4F         CALL .SIZETOMOVE
 244+ 5041 F3               DI
 245+ 5042 78               LD A,B
 246+ 5043 B1               OR C
 247+ 5044 28 06            JR Z,.L2
 248+ 5046 2A 10 40         LD HL,(FREEMEMPTR)
 249+ 5049 2B               DEC HL
 250+ 504A ED B8            LDDR
 251+ 504C              .L2:
 252+ 504C C1               POP BC
 253+ 504D FD 6E 00         LD L,(IY)
 254+ 5050 FD 66 01         LD H,(IY+1)
 255+ 5053 09               ADD HL,BC
 256+ 5054 FD 75 00         LD (IY),L
 257+ 5057 FD 74 01         LD (IY+1),H
 258+ 505A C9               RET
 259+ 505B              ; *******************************************************************************************************
 260+ 505B
 261+ 505B              ; *******************************************************************************************************
 262+ 505B              ; function to handle CALL ANIMITEMPAT basic extension
 263+ 505B              ; ANIMITEMPAT ( BYTE id,
 264+ 505B              ;               INT ticks >0,
 265+ 505B              ;               BYTE pattern,
 266+ 505B              ;               BYTE color )
 267+ 505B              ; fills animation item data, returns an error if ID out of bounds
 268+ 505B              ANIMITEMPAT:
 269+ 505B                  ; opening (
 270+ 505B CD 23 65     	CALL CHKCHAR
 271+ 505E 28           	DB '('
 272+ 505F              	; get id
 273+ 505F DD 21 1C 52  	LD IX, GETBYT
 274+ 5063 CD 59 01     	CALL CALBAS
 275+ 5066 F5               PUSH AF
 276+ 5067                  ; check if out of bounds
 277+ 5067 3C               INC A
 278+ 5068 4F               LD C,A
 279+ 5069 3A 44 4F         LD A,(ANIMITEMNUM)
 280+ 506C B9               CP C
 281+ 506D DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 282+ 5070              	; comma
 283+ 5070 CD 23 65     	CALL CHKCHAR
 284+ 5073 2C           	DB ','
 285+ 5074              	; get ticks
 286+ 5074 DD 21 2F 54  	LD IX, FRMQNT
 287+ 5078 CD 59 01     	CALL CALBAS
 288+ 507B 7A               LD A,D
 289+ 507C B3               OR E
 290+ 507D CA 3F 65         JP Z, OVERFLOW
 291+ 5080 D5           	PUSH DE
 292+ 5081              	; comma
 293+ 5081 CD 23 65     	CALL CHKCHAR
 294+ 5084 2C           	DB ','
 295+ 5085              	; get pattern
 296+ 5085 DD 21 1C 52  	LD IX, GETBYT
 297+ 5089 CD 59 01     	CALL CALBAS
 298+ 508C F5               PUSH AF
 299+ 508D              	; comma
 300+ 508D CD 23 65     	CALL CHKCHAR
 301+ 5090 2C           	DB ','
 302+ 5091              	; get color
 303+ 5091 DD 21 1C 52  	LD IX, GETBYT
 304+ 5095 CD 59 01     	CALL CALBAS
 305+ 5098 F5               PUSH AF
 306+ 5099              	; ending )
 307+ 5099 CD 23 65     	CALL CHKCHAR
 308+ 509C 29           	DB ')'
 309+ 509D              .ENTRY:
 310+ 509D E5               PUSH HL
 311+ 509E DD E1            POP IX
 312+ 50A0 D9               EXX
 313+ 50A1 C1               POP BC ; color
 314+ 50A2 D1               POP DE ; pattern
 315+ 50A3 E1               POP HL ; ticks
 316+ 50A4 D9               EXX
 317+ 50A5 F1               POP AF
 318+ 50A6 CD 59 4F         CALL GETnthANIMITEM
 319+ 50A9 E5               PUSH HL
 320+ 50AA FD E1            POP IY
 321+ 50AC D9               EXX
 322+ 50AD FD 36 00 00      LD (IY),0 ; type=0
 323+ 50B1 FD 75 01         LD (IY+1),L
 324+ 50B4 FD 74 02         LD (IY+2),H
 325+ 50B7 FD 72 03         LD (IY+3),D
 326+ 50BA FD 70 04         LD (IY+4),B
 327+ 50BD
 328+ 50BD DD E5            PUSH IX
 329+ 50BF E1               POP HL
 330+ 50C0 C9               RET
 331+ 50C1              ; *******************************************************************************************************
 332+ 50C1
 333+ 50C1              ; *******************************************************************************************************
 334+ 50C1              ; function to handle CALL ANIMITEMPTR basic extension
 335+ 50C1              ; ANIMITEMPTR ( BYTE id,
 336+ 50C1              ;               INT ticks,
 337+ 50C1              ;               INT pointer,
 338+ 50C1              ; fills animation item data, returns an error if ID out of bounds
 339+ 50C1              ANIMITEMPTR_CMD:
 340+ 50C1                  ; opening (
 341+ 50C1 CD 23 65     	CALL CHKCHAR
 342+ 50C4 28           	DB '('
 343+ 50C5              	; get id
 344+ 50C5 DD 21 1C 52  	LD IX, GETBYT
 345+ 50C9 CD 59 01     	CALL CALBAS
 346+ 50CC F5               PUSH AF
 347+ 50CD                  ; check if out of bounds
 348+ 50CD 3C               INC A
 349+ 50CE 4F               LD C,A
 350+ 50CF 3A 44 4F         LD A,(ANIMITEMNUM)
 351+ 50D2 B9               CP C
 352+ 50D3 DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 353+ 50D6              	; comma
 354+ 50D6 CD 23 65     	CALL CHKCHAR
 355+ 50D9 2C           	DB ','
 356+ 50DA              	; get ticks
 357+ 50DA DD 21 2F 54  	LD IX, FRMQNT
 358+ 50DE CD 59 01     	CALL CALBAS
 359+ 50E1 7A               LD A,D
 360+ 50E2 B3               OR E
 361+ 50E3 CA 3F 65         JP Z,OVERFLOW
 362+ 50E6 D5           	PUSH DE
 363+ 50E7              	; comma
 364+ 50E7 CD 23 65     	CALL CHKCHAR
 365+ 50EA 2C           	DB ','
 366+ 50EB              	; get pointer
 367+ 50EB DD 21 2F 54  	LD IX, FRMQNT
 368+ 50EF CD 59 01     	CALL CALBAS
 369+ 50F2 D5           	PUSH DE
 370+ 50F3              	; ending )
 371+ 50F3 CD 23 65     	CALL CHKCHAR
 372+ 50F6 29           	DB ')'
 373+ 50F7              .ENTRY:
 374+ 50F7 E5               PUSH HL
 375+ 50F8 DD E1            POP IX
 376+ 50FA D9               EXX
 377+ 50FB D1               POP DE ; pointer
 378+ 50FC E1               POP HL ; ticks
 379+ 50FD D9               EXX
 380+ 50FE F1               POP AF
 381+ 50FF CD 59 4F         CALL GETnthANIMITEM
 382+ 5102 E5               PUSH HL
 383+ 5103 FD E1            POP IY
 384+ 5105 D9               EXX
 385+ 5106 FD 36 00 01      LD (IY),1 ; type=1
 386+ 510A FD 75 01         LD (IY+1),L
 387+ 510D FD 74 02         LD (IY+2),H
 388+ 5110 FD 73 03         LD (IY+3),E
 389+ 5113 FD 72 04         LD (IY+4),D
 390+ 5116
 391+ 5116 DD E5            PUSH IX
 392+ 5118 E1               POP HL
 393+ 5119 C9               RET
 394+ 511A              ; *******************************************************************************************************
 395+ 511A
 396+ 511A              ; *******************************************************************************************************
 397+ 511A              ; function to handle CALL MAXANIMDEFS basic extension
 398+ 511A              ; MAXANIMDEFS (BYTE number)
 399+ 511A              ; sets new number and moves memory buffers as needed
 400+ 511A              MAXANIMDEFS:
 401+ 511A              	; opening (
 402+ 511A CD 23 65     	CALL CHKCHAR
 403+ 511D 28           	DB '('
 404+ 511E              	; get value
 405+ 511E DD 21 1C 52  	LD IX, GETBYT
 406+ 5122 CD 59 01     	CALL CALBAS
 407+ 5125 F5               PUSH AF
 408+ 5126              	; ending )
 409+ 5126 CD 23 65     	CALL CHKCHAR
 410+ 5129 29           	DB ')'
 411+ 512A F1               POP AF
 412+ 512B F3               DI
 413+ 512C              	; save position
 414+ 512C E5           	PUSH HL
 415+ 512D              .ENTRY:
 416+ 512D 47               LD B,A
 417+ 512E 3A 47 4F         LD A,(ANIMDEFNUM)
 418+ 5131 90               SUB B
 419+ 5132 CA CC 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 420+ 5135 FD 21 4B 4F      LD IY,ANIMSPRPTR
 421+ 5139 FA 45 51         JP M, .INCREASE
 422+ 513C                  ; new value is lower than previous one
 423+ 513C CD 50 51         CALL .SIZEDIFF
 424+ 513F CD 09 50         CALL MAXANIMITEMS.DECREASE_COMMON
 425+ 5142 C3 BA 4F         JP MAXANIMITEMS.E1
 426+ 5145              .INCREASE:
 427+ 5145 ED 44            NEG
 428+ 5147 CD 50 51         CALL .SIZEDIFF
 429+ 514A CD 35 50         CALL MAXANIMITEMS.INCREASE_COMMON
 430+ 514D C3 DE 4F         JP MAXANIMITEMS.E2
 431+ 5150              .SIZEDIFF:
 432+ 5150 26 00            LD H,0
 433+ 5152 6F               LD L,A
 434+ 5153 CD 10 64         CALL HLx16
 435+ 5156 78               LD A,B
 436+ 5157 32 47 4F         LD (ANIMDEFNUM),A
 437+ 515A 44               LD B,H
 438+ 515B 4D               LD C,L
 439+ 515C C9               RET ; BC=size difference in bytes
 440+ 515D              ; *******************************************************************************************************
 441+ 515D
 442+ 515D              ; *******************************************************************************************************
 443+ 515D              ; function to handle CALL ANIMDEF basic extension
 444+ 515D              ; ANIMITEMPAT ( BYTE id,
 445+ 515D              ;               BYTE size,
 446+ 515D              ;               INT[] list )
 447+ 515D              ; fills animation definition data, returns an error if out of bounds, or invalid type
 448+ 515D              ANIMDEF:
 449+ 515D                  ; opening (
 450+ 515D CD 23 65     	CALL CHKCHAR
 451+ 5160 28           	DB '('
 452+ 5161              	; get id
 453+ 5161 DD 21 1C 52  	LD IX, GETBYT
 454+ 5165 CD 59 01     	CALL CALBAS
 455+ 5168 F5               PUSH AF
 456+ 5169                  ; check if out of bounds
 457+ 5169 3C               INC A
 458+ 516A 4F               LD C,A
 459+ 516B 3A 47 4F         LD A,(ANIMDEFNUM)
 460+ 516E B9               CP C
 461+ 516F DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 462+ 5172              	; comma
 463+ 5172 CD 23 65     	CALL CHKCHAR
 464+ 5175 2C           	DB ','
 465+ 5176              	; get size
 466+ 5176 DD 21 1C 52  	LD IX, GETBYT
 467+ 517A CD 59 01     	CALL CALBAS
 468+ 517D FE 10            CP 16
 469+ 517F D2 3F 65         JP NC, OVERFLOW
 470+ 5182 B7               OR A
 471+ 5183 CA 3F 65         JP Z, OVERFLOW
 472+ 5186 F5           	PUSH AF
 473+ 5187              	; comma
 474+ 5187 CD 23 65     	CALL CHKCHAR
 475+ 518A 2C           	DB ','
 476+ 518B              	; get pointer to a list of animation items in integer array format
 477+ 518B                  ; get array pointer
 478+ 518B D1               POP DE
 479+ 518C D5               PUSH DE
 480+ 518D 3E 02            LD A,2
 481+ 518F 06 01            LD B,1
 482+ 5191 CD 50 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 483+ 5194 C5               PUSH BC
 484+ 5195              	; ending )
 485+ 5195 CD 23 65     	CALL CHKCHAR
 486+ 5198 29           	DB ')'
 487+ 5199              .ENTRY:
 488+ 5199 E5               PUSH HL
 489+ 519A DD E1            POP IX
 490+ 519C D1               POP DE ; pointer to INT array
 491+ 519D C1               POP BC ; B=item number
 492+ 519E F1               POP AF ; id
 493+ 519F D5               PUSH DE
 494+ 51A0 CD 62 4F         CALL GETnthANIMDEF
 495+ 51A3 D1               POP DE
 496+ 51A4 70               LD (HL),B
 497+ 51A5              .L1:
 498+ 51A5 23               INC HL
 499+ 51A6 1A               LD A,(DE)
 500+ 51A7 13          > INC DE
 500+ 51A8 13          > INC DE
 501+ 51A9 77               LD (HL),A
 502+ 51AA 10 F9            DJNZ .L1
 503+ 51AC DD E5            PUSH IX
 504+ 51AE E1               POP HL
 505+ 51AF C9               RET
 506+ 51B0              ; *******************************************************************************************************
 507+ 51B0
 508+ 51B0              ; *******************************************************************************************************
 509+ 51B0              ; function to handle CALL MAXANIMSPRS basic extension
 510+ 51B0              ; MAXANIMSPRS (BYTE number)
 511+ 51B0              ; sets new number and moves memory buffers as needed
 512+ 51B0              MAXANIMSPRS:
 513+ 51B0              	; opening (
 514+ 51B0 CD 23 65     	CALL CHKCHAR
 515+ 51B3 28           	DB '('
 516+ 51B4              	; get value
 517+ 51B4 DD 21 1C 52  	LD IX, GETBYT
 518+ 51B8 CD 59 01     	CALL CALBAS
 519+ 51BB F5               PUSH AF
 520+ 51BC              	; ending )
 521+ 51BC CD 23 65     	CALL CHKCHAR
 522+ 51BF 29           	DB ')'
 523+ 51C0 F1               POP AF
 524+ 51C1 F3               DI
 525+ 51C2              	; save position
 526+ 51C2 E5           	PUSH HL
 527+ 51C3              .ENTRY:
 528+ 51C3 47               LD B,A
 529+ 51C4 3A 4A 4F         LD A,(ANIMSPRNUM)
 530+ 51C7 90               SUB B
 531+ 51C8 CA CC 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 532+ 51CB FD 21 4E 4F      LD IY,AUTOSGAMPTR
 533+ 51CF FA DB 51         JP M, .INCREASE
 534+ 51D2                  ; new value is lower than previous one
 535+ 51D2 CD FC 51         CALL .SIZEDIFF
 536+ 51D5 CD 09 50         CALL MAXANIMITEMS.DECREASE_COMMON
 537+ 51D8 C3 C3 4F         JP MAXANIMITEMS.E3
 538+ 51DB              .INCREASE:
 539+ 51DB ED 44            NEG
 540+ 51DD F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 541+ 51DE CD FC 51         CALL .SIZEDIFF
 542+ 51E1 CD 35 50         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 51E4 AF               XOR A
 544+ 51E5 ED 42            SBC HL,BC ; location of new stuff
 545+ 51E7 F1               POP AF
 546+ 51E8 C5               PUSH BC
 547+ 51E9 47               LD B,A
 548+ 51EA 11 08 00         LD DE,8
 549+ 51ED E5               PUSH HL
 550+ 51EE DD E1            POP IX
 551+ 51F0              .L1:
 552+ 51F0 DD 36 06 00      LD (IX+6),0 ; active flag
 553+ 51F4 DD 19            ADD IX,DE
 554+ 51F6 10 F8            DJNZ .L1
 555+ 51F8 C1               POP BC
 556+ 51F9 C3 E5 4F         JP MAXANIMITEMS.E4
 557+ 51FC              .SIZEDIFF:
 558+ 51FC 26 00            LD H,0
 559+ 51FE 6F               LD L,A
 560+ 51FF CD 11 64         CALL HLx8
 561+ 5202 78               LD A,B
 562+ 5203 32 4A 4F         LD (ANIMSPRNUM),A
 563+ 5206 44               LD B,H
 564+ 5207 4D               LD C,L
 565+ 5208 C9               RET ; BC=size difference in bytes
 566+ 5209              ; *******************************************************************************************************
 567+ 5209
 568+ 5209              ; *******************************************************************************************************
 569+ 5209              ; function to handle CALL ANIMSPRITE basic extension
 570+ 5209              ; ANIMSPRITE ( BYTE id,
 571+ 5209              ;              BYTE sprite_number,
 572+ 5209              ;              BYTE animation_definition_id,
 573+ 5209              ;              BYTE cyclic_flag )
 574+ 5209              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 575+ 5209              ANIMSPRITE:
 576+ 5209                  ; opening (
 577+ 5209 CD 23 65     	CALL CHKCHAR
 578+ 520C 28           	DB '('
 579+ 520D              	; get sprite animation id
 580+ 520D DD 21 1C 52  	LD IX, GETBYT
 581+ 5211 CD 59 01     	CALL CALBAS
 582+ 5214 F5               PUSH AF
 583+ 5215 3C               INC A
 584+ 5216 4F               LD C,A
 585+ 5217 3A 4A 4F         LD A,(ANIMSPRNUM)
 586+ 521A B9               CP C
 587+ 521B DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 588+ 521E              	; comma
 589+ 521E CD 23 65     	CALL CHKCHAR
 590+ 5221 2C           	DB ','
 591+ 5222              	; get sprite number
 592+ 5222 DD 21 1C 52  	LD IX, GETBYT
 593+ 5226 CD 59 01     	CALL CALBAS
 594+ 5229 F5               PUSH AF
 595+ 522A                  ; check if out of bounds
 596+ 522A FE 20            CP 32
 597+ 522C D2 3B 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 598+ 522F              	; comma
 599+ 522F CD 23 65     	CALL CHKCHAR
 600+ 5232 2C           	DB ','
 601+ 5233              	; get animation definition id
 602+ 5233 DD 21 1C 52  	LD IX, GETBYT
 603+ 5237 CD 59 01     	CALL CALBAS
 604+ 523A F5               PUSH AF
 605+ 523B 3C               INC A
 606+ 523C 4F               LD C,A
 607+ 523D 3A 47 4F         LD A,(ANIMDEFNUM)
 608+ 5240 B9               CP C
 609+ 5241 DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 610+ 5244              	; comma
 611+ 5244 CD 23 65     	CALL CHKCHAR
 612+ 5247 2C           	DB ','
 613+ 5248              	; get cyclic flag
 614+ 5248 DD 21 1C 52  	LD IX, GETBYT
 615+ 524C CD 59 01         CALL CALBAS
 616+ 524F F5           	PUSH AF
 617+ 5250              	; ending )
 618+ 5250 CD 23 65     	CALL CHKCHAR
 619+ 5253 29           	DB ')'
 620+ 5254              .ENTRY:
 621+ 5254 E5               PUSH HL
 622+ 5255 DD E1            POP IX
 623+ 5257 D9               EXX
 624+ 5258 D1               POP DE ; cyclic
 625+ 5259 C1               POP BC ; animation definition id
 626+ 525A E1               POP HL ; sprite number
 627+ 525B D9               EXX
 628+ 525C F1               POP AF ; sprite animation id
 629+ 525D CD 6E 4F         CALL GETnthSPRANIM
 630+ 5260 E5               PUSH HL
 631+ 5261 FD E1            POP IY
 632+ 5263 D9               EXX
 633+ 5264 FD 74 00         LD (IY),H
 634+ 5267 FD 70 04         LD (IY+4),B
 635+ 526A FD 72 05         LD (IY+5),D
 636+ 526D                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 637+ 526D                  ; following will do preparation for ANIMSTEP situation
 638+ 526D                  ; current item set to above limit and timer to 1
 639+ 526D                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 640+ 526D FD 36 03 FF      LD (IY+3),255
 641+ 5271 FD 36 01 01      LD (IY+1),1
 642+ 5275 FD 36 02 00      LD (IY+2),0
 643+ 5279                  ; mark as sprite animation
 644+ 5279 FD 36 07 00      LD (IY+7),0
 645+ 527D DD E5            PUSH IX
 646+ 527F E1               POP HL
 647+ 5280 C9               RET
 648+ 5281              ; *******************************************************************************************************
 649+ 5281
 650+ 5281              ; *******************************************************************************************************
 651+ 5281              ; function to handle CALL ANIMCHAR basic extension
 652+ 5281              ; ANIMCHAR ( BYTE id,
 653+ 5281              ;            INT character number 0-767,
 654+ 5281              ;            BYTE animation_definition_id,
 655+ 5281              ;            BYTE cyclic_flag )
 656+ 5281              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 657+ 5281              ANIMCHAR:
 658+ 5281                  ; opening (
 659+ 5281 CD 23 65     	CALL CHKCHAR
 660+ 5284 28           	DB '('
 661+ 5285              	; get sprite animation id
 662+ 5285 DD 21 1C 52  	LD IX, GETBYT
 663+ 5289 CD 59 01     	CALL CALBAS
 664+ 528C F5               PUSH AF
 665+ 528D 3C               INC A
 666+ 528E 4F               LD C,A
 667+ 528F 3A 4A 4F         LD A,(ANIMSPRNUM)
 668+ 5292 B9               CP C
 669+ 5293 DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 670+ 5296              	; comma
 671+ 5296 CD 23 65     	CALL CHKCHAR
 672+ 5299 2C           	DB ','
 673+ 529A              	; get character number
 674+ 529A DD 21 2F 54  	LD IX, FRMQNT
 675+ 529E CD 59 01     	CALL CALBAS
 676+ 52A1 D5               PUSH DE
 677+ 52A2                  ; check if out of bounds
 678+ 52A2 7A               LD A,D
 679+ 52A3 FE 03            CP 3
 680+ 52A5 D2 3B 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 681+ 52A8              	; comma
 682+ 52A8 CD 23 65     	CALL CHKCHAR
 683+ 52AB 2C           	DB ','
 684+ 52AC              	; get animation definition id
 685+ 52AC DD 21 1C 52  	LD IX, GETBYT
 686+ 52B0 CD 59 01     	CALL CALBAS
 687+ 52B3 F5               PUSH AF
 688+ 52B4 3C               INC A
 689+ 52B5 4F               LD C,A
 690+ 52B6 3A 47 4F         LD A,(ANIMDEFNUM)
 691+ 52B9 B9               CP C
 692+ 52BA DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 693+ 52BD              	; comma
 694+ 52BD CD 23 65     	CALL CHKCHAR
 695+ 52C0 2C           	DB ','
 696+ 52C1              	; get cyclic flag
 697+ 52C1 DD 21 1C 52  	LD IX, GETBYT
 698+ 52C5 CD 59 01         CALL CALBAS
 699+ 52C8 F5           	PUSH AF
 700+ 52C9              	; ending )
 701+ 52C9 CD 23 65     	CALL CHKCHAR
 702+ 52CC 29           	DB ')'
 703+ 52CD              .ENTRY:
 704+ 52CD E5               PUSH HL
 705+ 52CE DD E1            POP IX
 706+ 52D0 D9               EXX
 707+ 52D1 D1               POP DE ; cyclic
 708+ 52D2 C1               POP BC ; animation definition id
 709+ 52D3 E1               POP HL ; character number
 710+ 52D4 D9               EXX
 711+ 52D5 F1               POP AF ; sprite animation id
 712+ 52D6 CD 6E 4F         CALL GETnthSPRANIM
 713+ 52D9 E5               PUSH HL
 714+ 52DA FD E1            POP IY
 715+ 52DC D9               EXX
 716+ 52DD FD 75 00         LD (IY),L
 717+ 52E0 24               INC H ; save character bank+1
 718+ 52E1 FD 74 07         LD (IY+7),H
 719+ 52E4 FD 70 04         LD (IY+4),B
 720+ 52E7 FD 72 05         LD (IY+5),D
 721+ 52EA                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 722+ 52EA                  ; following will do preparation for ANIMSTEP situation
 723+ 52EA                  ; current item set to above limit and timer to 1
 724+ 52EA                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 725+ 52EA FD 36 03 FF      LD (IY+3),255
 726+ 52EE FD 36 01 01      LD (IY+1),1
 727+ 52F2 FD 36 02 00      LD (IY+2),0
 728+ 52F6 DD E5            PUSH IX
 729+ 52F8 E1               POP HL
 730+ 52F9 C9               RET
 731+ 52FA              ; *******************************************************************************************************
 732+ 52FA
 733+ 52FA              ; *******************************************************************************************************
 734+ 52FA              ; function to handle CALL MAXAUTOSGAMS basic extension
 735+ 52FA              ; MAXAUTOSGAMS (BYTE number)
 736+ 52FA              ; sets new number and moves memory buffers as needed
 737+ 52FA              MAXAUTOSGAMS:
 738+ 52FA              	; opening (
 739+ 52FA CD 23 65     	CALL CHKCHAR
 740+ 52FD 28           	DB '('
 741+ 52FE              	; get value
 742+ 52FE DD 21 1C 52  	LD IX, GETBYT
 743+ 5302 CD 59 01     	CALL CALBAS
 744+ 5305 F5               PUSH AF
 745+ 5306              	; ending )
 746+ 5306 CD 23 65     	CALL CHKCHAR
 747+ 5309 29           	DB ')'
 748+ 530A F1               POP AF
 749+ 530B F3               DI
 750+ 530C              	; save position
 751+ 530C E5           	PUSH HL
 752+ 530D              .ENTRY:
 753+ 530D 47               LD B,A
 754+ 530E 3A 4D 4F         LD A,(AUTOSGAMNUM)
 755+ 5311 90               SUB B
 756+ 5312 CA CC 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 757+ 5315 FD 21 10 40      LD IY,FREEMEMPTR
 758+ 5319 FA 25 53         JP M, .INCREASE
 759+ 531C                  ; new value is lower than previous one
 760+ 531C CD 46 53         CALL .SIZEDIFF
 761+ 531F CD 09 50         CALL MAXANIMITEMS.DECREASE_COMMON
 762+ 5322 C3 CC 4F         JP MAXANIMITEMS.EXIT
 763+ 5325              .INCREASE:
 764+ 5325 ED 44            NEG
 765+ 5327 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 766+ 5328 CD 46 53         CALL .SIZEDIFF
 767+ 532B CD 35 50         CALL MAXANIMITEMS.INCREASE_COMMON
 768+ 532E AF               XOR A
 769+ 532F ED 42            SBC HL,BC ; location of new stuff
 770+ 5331 F1               POP AF
 771+ 5332 C5               PUSH BC
 772+ 5333 47               LD B,A
 773+ 5334 11 18 00         LD DE,24
 774+ 5337 E5               PUSH HL
 775+ 5338 DD E1            POP IX
 776+ 533A              .L1:
 777+ 533A DD 36 13 00      LD (IX+19),0 ; active flag
 778+ 533E DD 19            ADD IX,DE
 779+ 5340 10 F8            DJNZ .L1
 780+ 5342 C1               POP BC
 781+ 5343 C3 CC 4F         JP MAXANIMITEMS.EXIT
 782+ 5346              .SIZEDIFF:
 783+ 5346 26 00            LD H,0
 784+ 5348 6F               LD L,A
 785+ 5349 CD 11 64         CALL HLx8
 786+ 534C 54               LD D,H
 787+ 534D 5D               LD E,L
 788+ 534E 29               ADD HL,HL
 789+ 534F 19               ADD HL,DE
 790+ 5350 78               LD A,B
 791+ 5351 32 4D 4F         LD (AUTOSGAMNUM),A
 792+ 5354 44               LD B,H
 793+ 5355 4D               LD C,L
 794+ 5356 C9               RET ; BC=size difference in bytes
 795+ 5357              ; *******************************************************************************************************
 796+ 5357
 797+ 5357              ; *******************************************************************************************************
 798+ 5357              ; function to handle CALL AUTOSGAMDEF basic extension
 799+ 5357              ; AUTOSGAMDEF ( BYTE id,
 800+ 5357              ;               INT VARIABLE x, INT VARIABLE y,
 801+ 5357              ;               INT minimum, INT maximum, INT delta,
 802+ 5357              ;               INT direction =0 horizontal,
 803+ 5357              ;               INT ticks,
 804+ 5357              ;               BYTE sprite_group_count,
 805+ 5357              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
 806+ 5357              ;               BYTE item_number,
 807+ 5357              ;               INT[] VARIABLE sprite_animations_negative_direction,
 808+ 5357              ;               INT[] VARIABLE sprite_animations_positive_direction
 809+ 5357              AUTOSGAMDEF:
 810+ 5357                  ; opening (
 811+ 5357 CD 23 65     	CALL CHKCHAR
 812+ 535A 28           	DB '('
 813+ 535B              	; get sprite animation id
 814+ 535B DD 21 1C 52  	LD IX, GETBYT
 815+ 535F CD 59 01     	CALL CALBAS
 816+ 5362 F5               PUSH AF
 817+ 5363 3C               INC A
 818+ 5364 4F               LD C,A
 819+ 5365 3A 4D 4F         LD A,(AUTOSGAMNUM)
 820+ 5368 B9               CP C
 821+ 5369 DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 822+ 536C F1               POP AF
 823+ 536D E5               PUSH HL
 824+ 536E CD 7A 4F         CALL GETnthAUTOSGAM
 825+ 5371 22 1A 62         LD (BLIT_TMP),HL ; for later
 826+ 5374 E1               POP HL
 827+ 5375              	; comma
 828+ 5375 CD 23 65     	CALL CHKCHAR
 829+ 5378 2C           	DB ','
 830+ 5379              	; get address of the X coordinate variable
 831+ 5379 DD 21 A4 5E  	LD IX, PTRGET
 832+ 537D CD 59 01     	CALL CALBAS
 833+ 5380 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 834+ 5384 DD 73 00         LD (IX+0),E
 835+ 5387 DD 72 01         LD (IX+1),D
 836+ 538A              	; comma
 837+ 538A CD 23 65     	CALL CHKCHAR
 838+ 538D 2C           	DB ','
 839+ 538E              	; get address of the Y coordinate variable
 840+ 538E DD 21 A4 5E  	LD IX, PTRGET
 841+ 5392 CD 59 01     	CALL CALBAS
 842+ 5395 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 843+ 5399 DD 73 02         LD (IX+2),E
 844+ 539C DD 72 03         LD (IX+3),D
 845+ 539F              	; comma
 846+ 539F CD 23 65     	CALL CHKCHAR
 847+ 53A2 2C           	DB ','
 848+ 53A3              	; get minimum value
 849+ 53A3 DD 21 2F 54  	LD IX, FRMQNT
 850+ 53A7 CD 59 01     	CALL CALBAS
 851+ 53AA DD 2A 1A 62  	LD IX,(BLIT_TMP)
 852+ 53AE DD 73 04         LD (IX+4),E
 853+ 53B1 DD 72 05         LD (IX+5),D
 854+ 53B4              	; comma
 855+ 53B4 CD 23 65     	CALL CHKCHAR
 856+ 53B7 2C           	DB ','
 857+ 53B8              	; get maximum value
 858+ 53B8 DD 21 2F 54  	LD IX, FRMQNT
 859+ 53BC CD 59 01     	CALL CALBAS
 860+ 53BF DD 2A 1A 62  	LD IX,(BLIT_TMP)
 861+ 53C3 DD 73 06         LD (IX+6),E
 862+ 53C6 DD 72 07         LD (IX+7),D
 863+ 53C9              	; comma
 864+ 53C9 CD 23 65     	CALL CHKCHAR
 865+ 53CC 2C           	DB ','
 866+ 53CD              	; get delta value
 867+ 53CD DD 21 2F 54  	LD IX, FRMQNT
 868+ 53D1 CD 59 01     	CALL CALBAS
 869+ 53D4 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 870+ 53D8 DD 73 08         LD (IX+8),E
 871+ 53DB DD 72 09         LD (IX+9),D
 872+ 53DE              	; comma
 873+ 53DE CD 23 65     	CALL CHKCHAR
 874+ 53E1 2C           	DB ','
 875+ 53E2              	; get direction value
 876+ 53E2 DD 21 2F 54  	LD IX, FRMQNT
 877+ 53E6 CD 59 01     	CALL CALBAS
 878+ 53E9 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 879+ 53ED DD 73 0A         LD (IX+10),E
 880+ 53F0 DD 72 0B         LD (IX+11),D
 881+ 53F3              	; comma
 882+ 53F3 CD 23 65     	CALL CHKCHAR
 883+ 53F6 2C           	DB ','
 884+ 53F7              	; get ticks value
 885+ 53F7 DD 21 2F 54  	LD IX, FRMQNT
 886+ 53FB CD 59 01     	CALL CALBAS
 887+ 53FE DD 2A 1A 62  	LD IX,(BLIT_TMP)
 888+ 5402 DD 73 14         LD (IX+20),E
 889+ 5405 DD 72 15         LD (IX+21),D
 890+ 5408              	; comma
 891+ 5408 CD 23 65     	CALL CHKCHAR
 892+ 540B 2C           	DB ','
 893+ 540C              	; get sprite group count
 894+ 540C DD 21 1C 52  	LD IX, GETBYT
 895+ 5410 CD 59 01     	CALL CALBAS
 896+ 5413 B7               OR A
 897+ 5414 CA 3B 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 898+ 5417 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 899+ 541B DD 77 0B         LD (IX+11),A
 900+ 541E              	; comma
 901+ 541E CD 23 65     	CALL CHKCHAR
 902+ 5421 2C           	DB ','
 903+ 5422              	; get sprite group definition array data pointer
 904+ 5422 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 905+ 5426 DD 5E 0B         LD E,(IX+11)
 906+ 5429 16 03        	LD D,3
 907+ 542B 3E 02        	LD A,2
 908+ 542D 47           	LD B,A
 909+ 542E CD 50 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 910+ 5431 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 911+ 5435 DD 71 0C     	LD (IX+12),C
 912+ 5438 DD 70 0D         LD (IX+13),B
 913+ 543B              	; comma
 914+ 543B CD 23 65     	CALL CHKCHAR
 915+ 543E 2C           	DB ','
 916+ 543F              	; get sprite animation array size
 917+ 543F DD 21 1C 52  	LD IX,GETBYT
 918+ 5443 CD 59 01     	CALL CALBAS
 919+ 5446 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 920+ 544A DD 77 0E         LD (IX+14),A
 921+ 544D B7               OR A
 922+ 544E CA 3B 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 923+ 5451              	; comma
 924+ 5451 CD 23 65     	CALL CHKCHAR
 925+ 5454 2C           	DB ','
 926+ 5455                  ; get array pointer for negative direction
 927+ 5455 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 928+ 5459 DD 56 0E         LD D,(IX+14)
 929+ 545C 3E 02            LD A,2
 930+ 545E 06 01            LD B,1
 931+ 5460 CD 50 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 932+ 5463 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 933+ 5467 DD 71 0F         LD (IX+15),C
 934+ 546A DD 70 10         LD (IX+16),B
 935+ 546D              	; comma
 936+ 546D CD 23 65     	CALL CHKCHAR
 937+ 5470 2C           	DB ','
 938+ 5471                  ; get array pointer for positive direction
 939+ 5471 DD 2A 1A 62  	LD IX,(BLIT_TMP)
 940+ 5475 DD 56 0E         LD D,(IX+14)
 941+ 5478 3E 02            LD A,2
 942+ 547A 06 01            LD B,1
 943+ 547C CD 50 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 944+ 547F DD 2A 1A 62  	LD IX,(BLIT_TMP)
 945+ 5483 DD 71 11         LD (IX+17),C
 946+ 5486 DD 70 12         LD (IX+18),B
 947+ 5489              	; ending )
 948+ 5489 CD 23 65     	CALL CHKCHAR
 949+ 548C 29           	DB ')'
 950+ 548D C9               RET
 951+ 548E              ; *******************************************************************************************************
 952+ 548E
 953+ 548E              ; *******************************************************************************************************
 954+ 548E              ; function to handle CALL AUTOSGAMSTART basic extension
 955+ 548E              ; AUTOSGAMSTART ( BYTE id )
 956+ 548E              AUTOSGAMSTART:
 957+ 548E 3E 01            LD A,1
 958+ 5490              .COMMON:
 959+ 5490 32 BC 54         LD (.SETVALUE+3),A
 960+ 5493                  ; opening (
 961+ 5493 CD 23 65     	CALL CHKCHAR
 962+ 5496 28           	DB '('
 963+ 5497              	; get sprite animation id
 964+ 5497 DD 21 1C 52  	LD IX, GETBYT
 965+ 549B CD 59 01     	CALL CALBAS
 966+ 549E F5               PUSH AF
 967+ 549F 3C               INC A
 968+ 54A0 4F               LD C,A
 969+ 54A1 3A 4D 4F         LD A,(AUTOSGAMNUM)
 970+ 54A4 B9               CP C
 971+ 54A5 DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 972+ 54A8 F1               POP AF
 973+ 54A9 E5               PUSH HL
 974+ 54AA CD 7A 4F         CALL GETnthAUTOSGAM
 975+ 54AD E5               PUSH HL
 976+ 54AE DD E1            POP IX
 977+ 54B0 E1               POP HL
 978+ 54B1 DD E5            PUSH IX
 979+ 54B3              	; ending )
 980+ 54B3 CD 23 65     	CALL CHKCHAR
 981+ 54B6 29           	DB ')'
 982+ 54B7
 983+ 54B7                  ; so syntax is fine
 984+ 54B7 DD E1            POP IX
 985+ 54B9              .SETVALUE:
 986+ 54B9 DD 36 13 01      LD (IX+19),1 ; active flag
 987+ 54BD                  ; set initial timer
 988+ 54BD DD 7E 14         LD A,(IX+20)
 989+ 54C0 DD 77 16         LD (IX+22),A
 990+ 54C3 DD 7E 15         LD A,(IX+21)
 991+ 54C6 DD 77 17         LD (IX+23),A
 992+ 54C9 C9               RET
 993+ 54CA              ; *******************************************************************************************************
 994+ 54CA
 995+ 54CA              ; *******************************************************************************************************
 996+ 54CA              ; function to handle CALL AUTOSGAMSTOP basic extension
 997+ 54CA              ; AUTOSGAMSTOP ( BYTE id )
 998+ 54CA              AUTOSGAMSTOP:
 999+ 54CA AF               XOR A
1000+ 54CB 18 C3            JR AUTOSGAMSTART.COMMON
1001+ 54CD              ; *******************************************************************************************************
1002+ 54CD
1003+ 54CD              ; *******************************************************************************************************
1004+ 54CD              ; function to handle CALL ANIMSTEP basic extension
1005+ 54CD              ; two forms
1006+ 54CD              ; ANIMSTEP ( BYTE id )
1007+ 54CD              ; or
1008+ 54CD              ; ANIMSTEP ( BYTE item_number,
1009+ 54CD              ;            INT[] sprite_animations )
1010+ 54CD              ANIMSTEP:
1011+ 54CD 11 4C 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1012+ 54D0 18 08            JR ANIMSTARTSTOP_COMMON
1013+ 54D2              ; *******************************************************************************************************
1014+ 54D2              ; *******************************************************************************************************
1015+ 54D2              ; function to handle CALL ANIMSTART basic extension
1016+ 54D2              ; two forms
1017+ 54D2              ; ANIMSTART ( BYTE id )
1018+ 54D2              ; or
1019+ 54D2              ; ANIMSTART ( BYTE item_number,
1020+ 54D2              ;             INT[] sprite_animations )
1021+ 54D2              ; sets active flag to 1
1022+ 54D2              ANIMSTART:
1023+ 54D2 11 3A 55         LD DE,ANIMSTARTSTOP_COMMON.START
1024+ 54D5 18 03            JR ANIMSTARTSTOP_COMMON
1025+ 54D7              ; *******************************************************************************************************
1026+ 54D7              ; *******************************************************************************************************
1027+ 54D7              ; function to handle CALL ANIMSTOP basic extension
1028+ 54D7              ; two forms
1029+ 54D7              ; ANIMSTOP ( BYTE id )
1030+ 54D7              ; or
1031+ 54D7              ; ANIMSTOP ( BYTE item_number,
1032+ 54D7              ;            INT[] sprite_animations )
1033+ 54D7              ; sets active flag to 0
1034+ 54D7              ANIMSTOP:
1035+ 54D7 11 47 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1036+ 54DA              ; *******************************************************************************************************
1037+ 54DA              ANIMSTARTSTOP_COMMON:
1038+ 54DA ED 53 38 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1039+ 54DE                  ; opening (
1040+ 54DE CD 23 65     	CALL CHKCHAR
1041+ 54E1 28           	DB '('
1042+ 54E2              	; get sprite animation id or array size
1043+ 54E2 DD 21 1C 52  	LD IX,GETBYT
1044+ 54E6 CD 59 01     	CALL CALBAS
1045+ 54E9 F5               PUSH AF
1046+ 54EA                  ; check if comma present
1047+ 54EA CD 2D 65         CALL GETPREVCHAR
1048+ 54ED 23               INC HL
1049+ 54EE FE 2C            CP ','
1050+ 54F0 28 0E            JR Z,.L1
1051+ 54F2 FE 29            CP ')'
1052+ 54F4 C2 47 65         JP NZ,SYNTAX_ERROR
1053+ 54F7                  ; ok so single argument variant
1054+ 54F7 F1               POP AF
1055+ 54F8 E5               PUSH HL
1056+ 54F9 F3               DI
1057+ 54FA CD 26 55         CALL .SETVALUE
1058+ 54FD FB               EI
1059+ 54FE E1               POP HL
1060+ 54FF C9               RET
1061+ 5500              .L1:
1062+ 5500                  ; get array pointer
1063+ 5500 D1               POP DE
1064+ 5501 D5               PUSH DE
1065+ 5502 3E 02            LD A,2
1066+ 5504 06 01            LD B,1
1067+ 5506 CD 50 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1068+ 5509 C5               PUSH BC
1069+ 550A              	; ending )
1070+ 550A CD 23 65     	CALL CHKCHAR
1071+ 550D 29           	DB ')'
1072+ 550E D1               POP DE ; array pointer
1073+ 550F C1               POP BC ; number of items
1074+ 5510 78               LD A,B
1075+ 5511 B7               OR A
1076+ 5512 CA 3B 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1077+ 5515 E5               PUSH HL
1078+ 5516 F3               DI
1079+ 5517              .L2:
1080+ 5517 C5               PUSH BC
1081+ 5518 1A               LD A,(DE)
1082+ 5519 13          > INC DE
1082+ 551A 13          > INC DE
1083+ 551B D5               PUSH DE
1084+ 551C CD 26 55         CALL .SETVALUE
1085+ 551F D1               POP DE
1086+ 5520 C1               POP BC
1087+ 5521 10 F4            DJNZ .L2
1088+ 5523 FB               EI
1089+ 5524 E1               POP HL
1090+ 5525 C9               RET
1091+ 5526
1092+ 5526              .SETVALUE:
1093+ 5526 47               LD B,A
1094+ 5527 3C               INC A
1095+ 5528 4F               LD C,A
1096+ 5529 3A 4A 4F         LD A,(ANIMSPRNUM)
1097+ 552C B9               CP C
1098+ 552D DA 3B 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1099+ 5530 78               LD A,B
1100+ 5531 CD 6E 4F         CALL GETnthSPRANIM
1101+ 5534 E5               PUSH HL
1102+ 5535 DD E1            POP IX
1103+ 5537              .FN:
1104+ 5537 C3 00 00         JP 0
1105+ 553A              .START:
1106+ 553A DD 36 06 01      LD (IX+6),1 ; active flag
1107+ 553E DD 36 03 00      LD (IX+3),0 ; current item
1108+ 5542 06 00            LD B,0 ; setup timer
1109+ 5544 C3 CB 55         JP SETUP_ANIM_STEP
1110+ 5547              .STOP:
1111+ 5547 DD 36 06 00      LD (IX+6),0 ; active flag
1112+ 554B C9               RET
1113+ 554C              .STEP:
1114+ 554C 06 00            LD B,0
1115+ 554E C3 6F 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1116+ 5551              ; *******************************************************************************************************
1117+ 5551
1118+ 5551              ; *******************************************************************************************************
1119+ 5551              ; function processes animations during vblank period
1120+ 5551              PROCESS_ANIMATIONS:
1121+ 5551 3A 4A 4F         LD A,(ANIMSPRNUM)
1122+ 5554 B7               OR A
1123+ 5555 C8               RET Z; no animations defined
1124+ 5556 47               LD B,A
1125+ 5557 DD 2A 4B 4F      LD IX,(ANIMSPRPTR)
1126+ 555B              .L1:
1127+ 555B C5               PUSH BC
1128+ 555C 06 00            LD B,0 ; normal mode, change on timer expiry only
1129+ 555E CD 6A 55         CALL PROCESS_SINGLE_ANIMATION
1130+ 5561 11 08 00         LD DE,8
1131+ 5564 DD 19            ADD IX,DE
1132+ 5566 C1               POP BC
1133+ 5567 10 F2            DJNZ .L1
1134+ 5569 C9               RET
1135+ 556A              ; *******************************************************************************************************
1136+ 556A
1137+ 556A              ; *******************************************************************************************************
1138+ 556A              ; processes single sprite animation
1139+ 556A              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1140+ 556A              ; on timer expiry goes to next animation item
1141+ 556A              ; input IX=sprite animation pointer
1142+ 556A              ; input B=1 force mode, activate animation action regardless of expired timer
1143+ 556A              PROCESS_SINGLE_ANIMATION:
1144+ 556A DD 7E 06         LD A,(IX+6); active
1145+ 556D B7               OR A
1146+ 556E C8               RET Z ; inactive animation
1147+ 556F              .INACTIVE_TOO:
1148+ 556F DD 6E 01         LD L,(IX+1)
1149+ 5572 DD 66 02         LD H,(IX+2) ; HL=end time
1150+ 5575 2B               DEC HL
1151+ 5576 DD 75 01         LD (IX+1),L
1152+ 5579 DD 74 02         LD (IX+2),H
1153+ 557C 7D               LD A,L
1154+ 557D B4               OR H
1155+ 557E 28 06            JR Z,.STEP
1156+ 5580 05               DEC B
1157+ 5581 04               INC B
1158+ 5582 C8               RET Z ; not forced mode, return
1159+ 5583 C3 CB 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1160+ 5586              .STEP:
1161+ 5586 06 00            LD B,0; setup timer
1162+ 5588 DD 34 03         INC (IX+3) ; current animation item
1163+ 558B C3 CB 55         JP SETUP_ANIM_STEP
1164+ 558E              ; *******************************************************************************************************
1165+ 558E
1166+ 558E              ; *******************************************************************************************************
1167+ 558E              ; function will setup sprite animation after current item change
1168+ 558E              ; input A=current animation definition
1169+ 558E              ; input IX=pointer to sprite animation
1170+ 558E              ; input B=1 skip timer setup
1171+ 558E              ; output IY=pointer to animation item
1172+ 558E              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1173+ 558E              ; basically sets new end time for current animation
1174+ 558E              INIT_CURRENT_ANIMATION:
1175+ 558E CD 62 4F         CALL GETnthANIMDEF
1176+ 5591 DD 7E 03         LD A,(IX+3) ; current animation item
1177+ 5594 BE               CP (HL) ; number of animation items in the animation definition
1178+ 5595 38 0A            JR C,.L3 ; last item not reached
1179+ 5597                  ; last item reached
1180+ 5597 DD 7E 05         LD A,(IX+5) ; cyclic flag
1181+ 559A B7               OR A
1182+ 559B 28 2C            JR Z,.ERROR ; non-cyclic animation
1183+ 559D                  ; cyclic animation, restart
1184+ 559D DD 36 03 00      LD (IX+3),0; current item
1185+ 55A1              .L3:
1186+ 55A1                  ; HL = animation definition
1187+ 55A1 23               INC HL ; skip animation definition size field
1188+ 55A2 16 00            LD D,0
1189+ 55A4 DD 5E 03         LD E,(IX+3); current item
1190+ 55A7 19               ADD HL,DE
1191+ 55A8 4E               LD C,(HL) ; current animation item
1192+ 55A9 0C               INC C
1193+ 55AA 3A 44 4F         LD A,(ANIMITEMNUM)
1194+ 55AD B9               CP C
1195+ 55AE 38 19            JR C,.ERROR ; invalid animation item, stop animation
1196+ 55B0 0D               DEC C
1197+ 55B1 79               LD A,C
1198+ 55B2 CD 59 4F         CALL GETnthANIMITEM
1199+ 55B5 E5               PUSH HL
1200+ 55B6 FD E1            POP IY ; IY=animation item
1201+ 55B8 05               DEC B
1202+ 55B9 28 0C            JR Z,.EXIT
1203+ 55BB FD 5E 01         LD E,(IY+1)
1204+ 55BE FD 56 02         LD D,(IY+2) ; duration
1205+ 55C1 DD 73 01         LD (IX+1),E
1206+ 55C4 DD 72 02         LD (IX+2),D
1207+ 55C7              .EXIT:
1208+ 55C7 AF               XOR A
1209+ 55C8 C9               RET
1210+ 55C9              .ERROR:
1211+ 55C9 37               SCF
1212+ 55CA C9               RET
1213+ 55CB              ; *******************************************************************************************************
1214+ 55CB
1215+ 55CB              ; *******************************************************************************************************
1216+ 55CB              ; function will display currect item and set up expiry time
1217+ 55CB              ; it will also stop the animation if expired
1218+ 55CB              ; sets sprite update flag if any changes in sprite data made
1219+ 55CB              ; input IX=current sprite animation
1220+ 55CB              ; input B=1 skip timer setup
1221+ 55CB              SETUP_ANIM_STEP:
1222+ 55CB DD 4E 04         LD C,(IX+4) ; animation definition ID
1223+ 55CE 0C               INC C
1224+ 55CF 3A 47 4F         LD A,(ANIMDEFNUM)
1225+ 55D2 B9               CP C
1226+ 55D3 30 05            JR NC,.L2
1227+ 55D5                  ; given animation item is outside of bounds, deactivate animation
1228+ 55D5              .STOPANIM:
1229+ 55D5 DD 36 06 00      LD (IX+6),0
1230+ 55D9 C9               RET
1231+ 55DA              .L2:
1232+ 55DA 0D               DEC C
1233+ 55DB 79               LD A,C
1234+ 55DC CD 8E 55         CALL INIT_CURRENT_ANIMATION
1235+ 55DF 38 F4            JR C, .STOPANIM
1236+ 55E1 FD 7E 00         LD A,(IY) ; type of animation item
1237+ 55E4 B7               OR A
1238+ 55E5 28 44            JR Z,.L4 ; change pattern and/or color
1239+ 55E7              .PAT:
1240+ 55E7                  ; change pattern definition
1241+ 55E7                  ; check if sprite or character
1242+ 55E7 DD 7E 07         LD A,(IX+7)
1243+ 55EA B7               OR A
1244+ 55EB 20 58            JR NZ,.CHAR
1245+ 55ED DD 7E 00         LD A,(IX) ; sprite number
1246+ 55F0 CD 85 4D         CALL GETnthSPRATTR
1247+ 55F3 23          > INC HL ; skip y and x
1247+ 55F4 23          > INC HL
1247+ 55F5 23          > INC HL
1247+ 55F6 23          > INC HL
1248+ 55F7 7E               LD A,(HL); current pattern
1249+ 55F8 26 00            LD H,0
1250+ 55FA 6F               LD L,A
1251+ 55FB 3A E0 F3         LD A,(REG1SAV)
1252+ 55FE E6 02            AND 2
1253+ 5600 20 07            JR NZ,.L6
1254+ 5602                  ; 8x8 sprite
1255+ 5602 CD 11 64         CALL HLx8
1256+ 5605 06 08            LD B,8
1257+ 5607 18 05            JR .L5
1258+ 5609              .L6:
1259+ 5609 CD 0F 64         CALL HLx32
1260+ 560C 06 20            LD B,32
1261+ 560E              .L5:
1262+ 560E 3A AF FC         LD A,(SCRMOD)
1263+ 5611 3D               DEC A
1264+ 5612 20 06            JR NZ,.L10
1265+ 5614 ED 5B C5 F3      LD DE,(T32PAT)
1266+ 5618 18 04            JR .L7
1267+ 561A              .L10:
1268+ 561A ED 5B CF F3      LD DE,(GRPPAT)
1269+ 561E              .L7:
1270+ 561E 19               ADD HL,DE
1271+ 561F CD FC 63         CALL SETWRT_LOCAL
1272+ 5622 FD 6E 03         LD L,(IY+3)
1273+ 5625 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1274+ 5628 C3 07 64         JP BBYTECOPY
1275+ 562B              .L4:
1276+ 562B                  ; change pattern and color in sprite attributes table
1277+ 562B DD 7E 00         LD A,(IX) ; sprite number
1278+ 562E CD 85 4D         CALL GETnthSPRATTR
1279+ 5631 23          > INC HL ; skip y and x
1279+ 5632 23          > INC HL
1279+ 5633 23          > INC HL
1279+ 5634 23          > INC HL
1280+ 5635 FD 7E 03         LD A,(IY+3) ; new pattern
1281+ 5638 77               LD (HL),A
1282+ 5639 23          > INC HL
1282+ 563A 23          > INC HL
1283+ 563B FD 7E 04         LD A,(IY+4) ; new color
1284+ 563E 77               LD (HL),A
1285+ 563F 2A 7D 4D         LD HL,(SPRATR_UPDATE_FLAG)
1286+ 5642 36 01            LD (HL),1
1287+ 5644 C9               RET
1288+ 5645              .CHAR:
1289+ 5645 DD 6E 00         LD L,(IX)
1290+ 5648 3D               DEC A
1291+ 5649 67               LD H,A
1292+ 564A CD 11 64         CALL HLx8
1293+ 564D 3A AF FC         LD A,(SCRMOD)
1294+ 5650 3D               DEC A
1295+ 5651 20 06            JR NZ,.L8
1296+ 5653 ED 5B C1 F3      LD DE,(T32CGP)
1297+ 5657 18 04            JR .L9
1298+ 5659              .L8:
1299+ 5659 ED 5B CB F3      LD DE,(GRPCGP)
1300+ 565D              .L9:
1301+ 565D 06 08            LD B,8
1302+ 565F 18 BD            JR .L7
1303+ 5661              ; *******************************************************************************************************
1304+ 5661
# file closed: asm\ANIMATION.asm
 123  5661               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 5661              ; Sprite Group Animate and Move
   2+ 5661
   3+ 5661              ; *******************************************************************************************************
   4+ 5661              ; shared function to process a list of animations
   5+ 5661              ; input B=list size
   6+ 5661              ; input DE=list pointer
   7+ 5661              SGAM_PROCESS_ANIM_LIST:
   8+ 5661 21 74 56         LD HL,.STEP
   9+ 5664 22 38 55         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 5667              .L1:
  11+ 5667 C5               PUSH BC
  12+ 5668 1A               LD A,(DE)
  13+ 5669 13          > INC DE
  13+ 566A 13          > INC DE
  14+ 566B D5               PUSH DE
  15+ 566C CD 26 55         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 566F D1               POP DE
  17+ 5670 C1               POP BC
  18+ 5671 10 F4            DJNZ .L1
  19+ 5673 C9           	RET
  20+ 5674              .STEP:
  21+ 5674 06 01            LD B,1
  22+ 5676 C3 6F 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 5679              ; *******************************************************************************************************
  24+ 5679
  25+ 5679              ; *******************************************************************************************************
  26+ 5679              ; function to handle CALL SGAM basic extension
  27+ 5679              ; sets position of a group of sprites as described in SPRGRPMOV
  28+ 5679              ; and manually animate a list of animations
  29+ 5679              ; _SGAM ( INT x,
  30+ 5679              ;	      INT y,
  31+ 5679              ;		  BYTE count,
  32+ 5679              ;		  INT[2][count] data_ptr,
  33+ 5679              ;         BYTE item_number,
  34+ 5679              ;         INT[] sprite_animations )
  35+ 5679              ; will put ram in page 0 also, page 1 is already there
  36+ 5679              SGAM:
  37+ 5679 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
  38+ 567C B7           	OR A
  39+ 567D CA 43 65     	JP Z,ILLEGAL_FUNCTION
  40+ 5680              	; opening (
  41+ 5680 CD 23 65     	CALL CHKCHAR
  42+ 5683 28           	DB '('
  43+ 5684              	; get x
  44+ 5684 DD 21 2F 54  	LD IX, FRMQNT
  45+ 5688 CD 59 01     	CALL CALBAS
  46+ 568B ED 53 1E 62  	LD (BLIT_STRUCT),DE
  47+ 568F              	; comma
  48+ 568F CD 23 65     	CALL CHKCHAR
  49+ 5692 2C           	DB ','
  50+ 5693              	; get y
  51+ 5693 DD 21 2F 54  	LD IX, FRMQNT
  52+ 5697 CD 59 01     	CALL CALBAS
  53+ 569A ED 53 20 62  	LD (BLIT_STRUCT+2),DE
  54+ 569E              	; comma
  55+ 569E CD 23 65     	CALL CHKCHAR
  56+ 56A1 2C           	DB ','
  57+ 56A2              	; get count
  58+ 56A2 DD 21 1C 52  	LD IX, GETBYT
  59+ 56A6 CD 59 01     	CALL CALBAS
  60+ 56A9 B7               OR A
  61+ 56AA CA 3B 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  62+ 56AD 32 22 62     	LD (BLIT_STRUCT+4),A
  63+ 56B0              	; comma
  64+ 56B0 CD 23 65     	CALL CHKCHAR
  65+ 56B3 2C           	DB ','
  66+ 56B4              	; get sprite group definition array data pointer
  67+ 56B4 3A 22 62         LD A,(BLIT_STRUCT+4)
  68+ 56B7 5F           	LD E,A
  69+ 56B8 16 03        	LD D,3
  70+ 56BA 3E 02        	LD A,2
  71+ 56BC 47           	LD B,A
  72+ 56BD CD 50 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
  73+ 56C0 ED 43 23 62  	LD (BLIT_STRUCT+5),BC
  74+ 56C4              	; comma
  75+ 56C4 CD 23 65     	CALL CHKCHAR
  76+ 56C7 2C           	DB ','
  77+ 56C8              	; get sprite animation array size
  78+ 56C8 DD 21 1C 52  	LD IX,GETBYT
  79+ 56CC CD 59 01     	CALL CALBAS
  80+ 56CF 32 25 62         LD (BLIT_STRUCT+7),A
  81+ 56D2 B7               OR A
  82+ 56D3 CA 3B 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  83+ 56D6              	; comma
  84+ 56D6 CD 23 65     	CALL CHKCHAR
  85+ 56D9 2C           	DB ','
  86+ 56DA                  ; get array pointer
  87+ 56DA 3A 25 62         LD A,(BLIT_STRUCT+7)
  88+ 56DD 57               LD D,A
  89+ 56DE 3E 02            LD A,2
  90+ 56E0 06 01            LD B,1
  91+ 56E2 CD 50 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  92+ 56E5 ED 43 26 62      LD (BLIT_STRUCT+8),BC
  93+ 56E9              	; ending )
  94+ 56E9 CD 23 65     	CALL CHKCHAR
  95+ 56EC 29           	DB ')'
  96+ 56ED              .ENTRY:
  97+ 56ED E5               PUSH HL
  98+ 56EE F3               DI
  99+ 56EF
 100+ 56EF              	; enable page 0
 101+ 56EF FD 21 F6 56  	LD IY, .RET
 102+ 56F3 C3 D5 64     	JP ENABLE_PAGE0
 103+ 56F6              .RET:
 104+ 56F6 D9               EXX
 105+ 56F7 ED 5B 1E 62      LD DE,(BLIT_STRUCT) ; initial x
 106+ 56FB ED 4B 20 62      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 56FF D9               EXX
 108+ 5700 2A 23 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5703 3A 22 62         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 5706 47               LD B,A
 111+ 5707 CD 32 4F         CALL SPRGRPMOV.UPDATE_LOC
 112+ 570A
 113+ 570A 3A 25 62         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 570D 47               LD B,A
 115+ 570E ED 5B 26 62      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 5712 CD 61 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5715
 118+ 5715 D1               POP DE
 119+ 5716 C1               POP BC
 120+ 5717 CD 4C 64         CALL RESTORE_PAGE_INFO
 121+ 571A FB               EI
 122+ 571B E1               POP HL
 123+ 571C C9               RET
 124+ 571D              ; *******************************************************************************************************
 125+ 571D
 126+ 571D              ; *******************************************************************************************************
 127+ 571D              ; handles automatic move and animate sprite groups during interrupt
 128+ 571D              PROCESS_AUTOSGAMS:
 129+ 571D 3A 4D 4F     	LD A,(AUTOSGAMNUM)
 130+ 5720 B7           	OR A
 131+ 5721 C8           	RET Z
 132+ 5722 47           	LD B,A
 133+ 5723 DD 2A 4E 4F  	LD IX,(AUTOSGAMPTR)
 134+ 5727              .L1:
 135+ 5727 C5           	PUSH BC
 136+ 5728 DD 7E 13     	LD A,(IX+19) ; active flag
 137+ 572B B7           	OR A
 138+ 572C 28 28        	JR Z,.LOOPEND
 139+ 572E              	; active, check timer
 140+ 572E DD 6E 16     	LD L,(IX+22)
 141+ 5731 DD 66 17     	LD H,(IX+23) ; timer
 142+ 5734 2B           	DEC HL
 143+ 5735 7C           	LD A,H
 144+ 5736 B5           	OR L
 145+ 5737 28 08        	JR Z,.L2
 146+ 5739              	; not expired
 147+ 5739 DD 75 16     	LD (IX+22),L
 148+ 573C DD 74 17     	LD (IX+23),H
 149+ 573F 18 15        	JR .LOOPEND
 150+ 5741              .L2:
 151+ 5741              	; expired, process
 152+ 5741
 153+ 5741                  ; set initial timer
 154+ 5741 DD 7E 14         LD A,(IX+20)
 155+ 5744 DD 77 16         LD (IX+22),A
 156+ 5747 DD 7E 15         LD A,(IX+21)
 157+ 574A DD 77 17         LD (IX+23),A
 158+ 574D
 159+ 574D CD 5F 57     	CALL .MOVE
 160+ 5750 CD CA 57     	CALL .UPDATELOC
 161+ 5753 CD EF 57     	CALL .PROCESS_ANIM_LIST
 162+ 5756
 163+ 5756              .LOOPEND:
 164+ 5756 11 18 00     	LD DE,24
 165+ 5759 DD 19        	ADD IX,DE
 166+ 575B C1           	POP BC
 167+ 575C 10 C9        	DJNZ .L1
 168+ 575E C9           	RET
 169+ 575F
 170+ 575F              .MOVE:
 171+ 575F              	; process movement
 172+ 575F DD 7E 0A     	LD A,(IX+10) ; direction
 173+ 5762 B7           	OR A
 174+ 5763 28 08        	JR Z, .MOVE_L1
 175+ 5765              	; vertical
 176+ 5765 DD 6E 02     	LD L,(IX+2)
 177+ 5768 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 178+ 576B 18 06        	JR .MOVE_L2
 179+ 576D              .MOVE_L1:
 180+ 576D              	; horizontal
 181+ 576D DD 6E 00     	LD L,(IX+0)
 182+ 5770 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 183+ 5773              .MOVE_L2:
 184+ 5773 E5           	PUSH HL
 185+ 5774 FD E1        	POP IY
 186+ 5776 FD 6E 00     	LD L,(IY+0)
 187+ 5779 FD 66 01     	LD H,(IY+1)
 188+ 577C DD 5E 08     	LD E,(IX+8)
 189+ 577F DD 56 09     	LD D,(IX+9) ; delta value
 190+ 5782 19           	ADD HL,DE
 191+ 5783 E5           	PUSH HL
 192+ 5784 DD 5E 04     	LD E,(IX+4)
 193+ 5787 DD 56 05     	LD D,(IX+5) ; minimum value
 194+ 578A A7           	AND A
 195+ 578B ED 52        	SBC HL,DE
 196+ 578D FA A7 57     	JP M,.MOVE_L3 ; below minimum
 197+ 5790 E1           	POP HL
 198+ 5791 E5           	PUSH HL
 199+ 5792 DD 5E 06     	LD E,(IX+6)
 200+ 5795 DD 56 07     	LD D,(IX+7) ; maximum value
 201+ 5798 EB           	EX DE,HL
 202+ 5799 A7           	AND A
 203+ 579A ED 52        	SBC HL,DE
 204+ 579C FA AF 57     	JP M,.MOVE_L4 ; above maximum
 205+ 579F E1           	POP HL
 206+ 57A0              	; within bounds
 207+ 57A0              .MOVE_L5:
 208+ 57A0 FD 75 00     	LD (IY+0),L
 209+ 57A3 FD 74 01     	LD (IY+1),H
 210+ 57A6 C9           	RET
 211+ 57A7              .MOVE_L3:
 212+ 57A7 E1           	POP HL
 213+ 57A8 CD BB 57     	CALL .INVERSE_DELTA
 214+ 57AB 6B           	LD L,E
 215+ 57AC 62           	LD H,D
 216+ 57AD 18 F1        	JR .MOVE_L5
 217+ 57AF              .MOVE_L4:
 218+ 57AF E1           	POP HL
 219+ 57B0 CD BB 57     	CALL .INVERSE_DELTA
 220+ 57B3 DD 6E 06     	LD L,(IX+6)
 221+ 57B6 DD 66 07     	LD H,(IX+7) ; maximum
 222+ 57B9 18 E5        	JR .MOVE_L5
 223+ 57BB              .INVERSE_DELTA:
 224+ 57BB AF           	XOR A
 225+ 57BC DD 96 08     	SUB (IX+8)
 226+ 57BF DD 77 08     	LD (IX+8),A
 227+ 57C2 9F           	SBC A,A
 228+ 57C3 DD 96 09     	SUB (IX+9)
 229+ 57C6 DD 77 09     	LD (IX+9),A
 230+ 57C9 C9           	RET
 231+ 57CA
 232+ 57CA              .UPDATELOC:
 233+ 57CA DD E5        	PUSH IX
 234+ 57CC D9           	EXX
 235+ 57CD DD 6E 00     	LD L,(IX+0)
 236+ 57D0 DD 66 01     	LD H,(IX+1)
 237+ 57D3 5E           	LD E,(HL)
 238+ 57D4 23           	INC HL
 239+ 57D5 56           	LD D,(HL)
 240+ 57D6 DD 6E 02     	LD L,(IX+2)
 241+ 57D9 DD 66 03     	LD H,(IX+3)
 242+ 57DC 4E           	LD C,(HL)
 243+ 57DD 23           	INC HL
 244+ 57DE 46           	LD B,(HL)
 245+ 57DF D9           	EXX
 246+ 57E0 DD 6E 0C     	LD L,(IX+12)
 247+ 57E3 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 248+ 57E6 DD 46 0B     	LD B,(IX+11) ; sprite group size
 249+ 57E9 CD 32 4F     	CALL SPRGRPMOV.UPDATE_LOC
 250+ 57EC DD E1        	POP IX
 251+ 57EE C9           	RET
 252+ 57EF
 253+ 57EF              .PROCESS_ANIM_LIST:
 254+ 57EF DD E5        	PUSH IX
 255+ 57F1 DD 46 0E         LD B,(IX+14) ; anim list size
 256+ 57F4 DD CB 09 7E  	BIT 7,(IX+9)
 257+ 57F8 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 258+ 57FA              	; negative direction
 259+ 57FA DD 5E 0F     	LD E,(IX+15)
 260+ 57FD DD 56 10     	LD D,(IX+16)
 261+ 5800 18 06        	JR .PROCESS_ANIM_LIST_L2
 262+ 5802              .PROCESS_ANIM_LIST_L1:
 263+ 5802              	; positive direction
 264+ 5802 DD 5E 11     	LD E,(IX+17)
 265+ 5805 DD 56 12     	LD D,(IX+18)
 266+ 5808              .PROCESS_ANIM_LIST_L2:
 267+ 5808 CD 61 56     	CALL SGAM_PROCESS_ANIM_LIST
 268+ 580B DD E1        	POP IX
 269+ 580D C9           	RET
 270+ 580E              ; *******************************************************************************************************
 271+ 580E
# file closed: asm\SGAM.asm
 124  580E               ENDIF
 125  580E
 126  580E               IF (RAM_CMDS == 1)
 127  580E               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 580E              ; *******************************************************************************************************
   2+ 580E              ; function to handle CALL MEMCPY basic extension
   3+ 580E              ; _MEMCPY ( INT source,
   4+ 580E              ;			INT destination,
   5+ 580E              ;			INT count,
   6+ 580E              ; will put ram in page 0 also, page 1 is already there
   7+ 580E              MEMCPY:
   8+ 580E              	; opening (
   9+ 580E CD 23 65     	CALL CHKCHAR
  10+ 5811 28           	DB '('
  11+ 5812              	; get source address
  12+ 5812 DD 21 2F 54  	LD IX, FRMQNT
  13+ 5816 CD 59 01     	CALL CALBAS
  14+ 5819 D5           	PUSH DE
  15+ 581A              	; comma
  16+ 581A CD 23 65     	CALL CHKCHAR
  17+ 581D 2C           	DB ','
  18+ 581E              	; get destination address
  19+ 581E DD 21 2F 54  	LD IX, FRMQNT
  20+ 5822 CD 59 01     	CALL CALBAS
  21+ 5825 D5           	PUSH DE
  22+ 5826              	; comma
  23+ 5826 CD 23 65     	CALL CHKCHAR
  24+ 5829 2C           	DB ','
  25+ 582A              	; get length
  26+ 582A DD 21 2F 54  	LD IX, FRMQNT
  27+ 582E CD 59 01     	CALL CALBAS
  28+ 5831 D5           	PUSH DE
  29+ 5832              	; ending )
  30+ 5832 CD 23 65     	CALL CHKCHAR
  31+ 5835 29           	DB ')'
  32+ 5836
  33+ 5836              	; save position
  34+ 5836 E5           	PUSH HL
  35+ 5837 DD E1        	POP IX
  36+ 5839
  37+ 5839 C1           	POP BC ; count
  38+ 583A D1           	POP DE ; destination
  39+ 583B E1           	POP HL ; source
  40+ 583C D9           	EXX
  41+ 583D              	; enable page 0
  42+ 583D F3           	DI
  43+ 583E FD 21 45 58  	LD IY, .RET
  44+ 5842 C3 D5 64     	JP ENABLE_PAGE0
  45+ 5845              .RET:
  46+ 5845 FB           	EI
  47+ 5846 D9           	EXX
  48+ 5847 ED B0        	LDIR
  49+ 5849 D1               POP DE
  50+ 584A C1               POP BC
  51+ 584B CD 4C 64         CALL RESTORE_PAGE_INFO
  52+ 584E DD E5        	PUSH IX
  53+ 5850 E1           	POP HL
  54+ 5851 C9           	RET
  55+ 5852              ; *******************************************************************************************************
  56+ 5852
  57+ 5852              ; *******************************************************************************************************
  58+ 5852              ; function to handle CALL FILRAM basic extension
  59+ 5852              ; FILRAM ( INT start address,
  60+ 5852              ;		   INT count,
  61+ 5852              ;		   BYTE value )
  62+ 5852              ; will put ram in page 0 also, page 1 is already there
  63+ 5852              FILRAM:
  64+ 5852              	; opening (
  65+ 5852 CD 23 65     	CALL CHKCHAR
  66+ 5855 28           	DB '('
  67+ 5856              	; get start address
  68+ 5856 DD 21 2F 54  	LD IX, FRMQNT
  69+ 585A CD 59 01     	CALL CALBAS
  70+ 585D D5           	PUSH DE
  71+ 585E              	; comma
  72+ 585E CD 23 65     	CALL CHKCHAR
  73+ 5861 2C           	DB ','
  74+ 5862              	; get count
  75+ 5862 DD 21 2F 54  	LD IX, FRMQNT
  76+ 5866 CD 59 01     	CALL CALBAS
  77+ 5869 D5           	PUSH DE
  78+ 586A              	; comma
  79+ 586A CD 23 65     	CALL CHKCHAR
  80+ 586D 2C           	DB ','
  81+ 586E              	; get value
  82+ 586E DD 21 1C 52  	LD IX, GETBYT
  83+ 5872 CD 59 01     	CALL CALBAS
  84+ 5875 F5           	PUSH AF
  85+ 5876              	; ending )
  86+ 5876 CD 23 65     	CALL CHKCHAR
  87+ 5879 29           	DB ')'
  88+ 587A
  89+ 587A              	; save position
  90+ 587A E5           	PUSH HL
  91+ 587B DD E1        	POP IX
  92+ 587D
  93+ 587D D1           	POP DE ; actually AF
  94+ 587E C1           	POP BC ; count
  95+ 587F E1           	POP HL ; start address
  96+ 5880 78           	LD A, B
  97+ 5881 B7           	OR A
  98+ 5882 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
  99+ 5884 B1           	OR C
 100+ 5885 28 1A        	JR Z, .EXIT ; 0 bytes to fill, skip
 101+ 5887 79           	LD A, C
 102+ 5888 3D           	DEC A
 103+ 5889 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 104+ 588B              	; one byte to fill
 105+ 588B 72           	LD (HL), D
 106+ 588C 18 13        	JR .EXIT
 107+ 588E              .L1:
 108+ 588E D9           	EXX
 109+ 588F              	; enable page 0
 110+ 588F F3           	DI
 111+ 5890 FD 21 97 58  	LD IY, .RET
 112+ 5894 C3 D5 64     	JP ENABLE_PAGE0
 113+ 5897              .RET:
 114+ 5897 FB           	EI
 115+ 5898 D9           	EXX
 116+ 5899 CD A5 58     	CALL .FILLVALUE
 117+ 589C D1               POP DE
 118+ 589D C1               POP BC
 119+ 589E CD 4C 64         CALL RESTORE_PAGE_INFO
 120+ 58A1              .EXIT:
 121+ 58A1 DD E5        	PUSH IX
 122+ 58A3 E1           	POP HL
 123+ 58A4 C9           	RET
 124+ 58A5
 125+ 58A5              .FILLVALUE:
 126+ 58A5 72               LD (HL), D
 127+ 58A6 54               LD D, H
 128+ 58A7 5D               LD E, L
 129+ 58A8 13               INC DE
 130+ 58A9 0B               DEC BC
 131+ 58AA ED B0            LDIR
 132+ 58AC C9               RET
 133+ 58AD              ; *******************************************************************************************************
 134+ 58AD
# file closed: asm\MEMORY.asm
 128  58AD               ENDIF
 129  58AD
 130  58AD               IF (SOUND_CMDS == 1)
 131  58AD               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58AD              MUSIC_INIT_STATUS:
   2+ 58AD 00            DB 0
   3+ 58AE              SFX_INIT_STATUS:
   4+ 58AE 00            DB 0
   5+ 58AF              SOUND_ENABLED:
   6+ 58AF 00            DB 0
   7+ 58B0
   8+ 58B0              ; *******************************************************************************************************
   9+ 58B0              ; function to handle CALL SNDPLYINIT basic extension
  10+ 58B0              ; initializes sound player
  11+ 58B0              ; _SNDPLYINIT ( INT music_offset,
  12+ 58B0              ;				INT sfx_offset, can be -1 if no SFX
  13+ 58B0              ; will put ram in page 0 also, page 1 is already there
  14+ 58B0              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 58B0              SNDPLYINIT:
  16+ 58B0              	; opening (
  17+ 58B0 CD 23 65     	CALL CHKCHAR
  18+ 58B3 28           	DB '('
  19+ 58B4              	; get music address
  20+ 58B4 DD 21 2F 54  	LD IX, FRMQNT
  21+ 58B8 CD 59 01     	CALL CALBAS
  22+ 58BB D5           	PUSH DE
  23+ 58BC              	; comma
  24+ 58BC CD 23 65     	CALL CHKCHAR
  25+ 58BF 2C           	DB ','
  26+ 58C0              	; get sfx address
  27+ 58C0 DD 21 2F 54  	LD IX, FRMQNT
  28+ 58C4 CD 59 01     	CALL CALBAS
  29+ 58C7 D5           	PUSH DE
  30+ 58C8              	; ending )
  31+ 58C8 CD 23 65     	CALL CHKCHAR
  32+ 58CB 29           	DB ')'
  33+ 58CC
  34+ 58CC                  ; save position in BASIC text
  35+ 58CC 44           	LD B, H
  36+ 58CD 4D           	LD C, L
  37+ 58CE
  38+ 58CE              	; pop LDIR parameters and store away for later
  39+ 58CE D1           	POP DE ; sfx address
  40+ 58CF E1           	POP HL ; music address
  41+ 58D0 C5           	PUSH BC ; basic text location
  42+ 58D1 D9           	EXX
  43+ 58D2 FD 21 D9 58  	LD IY, .RET
  44+ 58D6 C3 D5 64     	JP ENABLE_PAGE0
  45+ 58D9              .RET:
  46+ 58D9 D9           	EXX
  47+ 58DA
  48+ 58DA D5           	PUSH DE
  49+ 58DB AF           	XOR A
  50+ 58DC              	; HL = music location
  51+ 58DC CD 62 41     	CALL PLY_AKG_INIT
  52+ 58DF 3E 01        	LD A, 1
  53+ 58E1 32 AD 58     	LD (MUSIC_INIT_STATUS), A
  54+ 58E4
  55+ 58E4 E1           	POP HL ; SFX
  56+ 58E5              	; check if SFX address -1
  57+ 58E5 23           	INC HL
  58+ 58E6 7D           	LD A, L
  59+ 58E7 B4           	OR H
  60+ 58E8 28 09        	JR Z,.L1
  61+ 58EA 2B           	DEC HL
  62+ 58EB CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 58EE 3E 01        	LD A, 1
  64+ 58F0 32 AE 58     	LD (SFX_INIT_STATUS), A
  65+ 58F3              .L1:
  66+ 58F3 D1               POP DE
  67+ 58F4 C1               POP BC
  68+ 58F5 CD 4C 64         CALL RESTORE_PAGE_INFO
  69+ 58F8
  70+ 58F8 E1           	POP HL
  71+ 58F9 C9           	RET
  72+ 58FA              ; *******************************************************************************************************
  73+ 58FA
  74+ 58FA              ; *******************************************************************************************************
  75+ 58FA              ; function to handle CALL SNDPLYON basic extension
  76+ 58FA              ; enables sound player
  77+ 58FA              ; _SNDPLYON
  78+ 58FA              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 58FA              ; if not throws out of data error
  80+ 58FA              SNDPLYON:
  81+ 58FA 3A AD 58     	LD A, (MUSIC_INIT_STATUS)
  82+ 58FD B7           	OR A
  83+ 58FE 20 05        	JR NZ, .L1
  84+ 5900              	; player not initialized, throw error
  85+ 5900 1E 04        	LD E, 04 ; Out of DATA
  86+ 5902 C3 49 65     	JP THROW_ERROR
  87+ 5905              .L1:
  88+ 5905 32 AF 58     	LD (SOUND_ENABLED), A
  89+ 5908              	; disable key click
  90+ 5908 AF           	XOR A
  91+ 5909 32 DB F3     	LD (CLIKSW), A
  92+ 590C C9           	RET
  93+ 590D              ; *******************************************************************************************************
  94+ 590D
  95+ 590D              ; *******************************************************************************************************
  96+ 590D              ; function to handle CALL SNDPLYOFF basic extension
  97+ 590D              ; disables sound player
  98+ 590D              ; _SNDPLYOFF
  99+ 590D              ; sets SOUND_ENABLED variable to 0
 100+ 590D              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 590D              SNDPLYOFF:
 102+ 590D 3A AF 58     	LD A, (SOUND_ENABLED)
 103+ 5910 B7           	OR A
 104+ 5911 C8           	RET Z ; already stopped
 105+ 5912 AF           	XOR A
 106+ 5913 32 AF 58     	LD (SOUND_ENABLED), A
 107+ 5916 E5           	PUSH HL
 108+ 5917 CD 21 42     	CALL PLY_AKG_STOP
 109+ 591A 3A AE 58     	LD A, (SFX_INIT_STATUS)
 110+ 591D B7           	OR A
 111+ 591E 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 5920 AF           	XOR A
 113+ 5921 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 5924 3E 01        	LD A, 1
 115+ 5926 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 5929 3E 02        	LD A, 2
 117+ 592B CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 592E              .EXIT:
 119+ 592E E1           	POP HL
 120+ 592F C9           	RET
 121+ 5930              ; *******************************************************************************************************
 122+ 5930
 123+ 5930              ; *******************************************************************************************************
 124+ 5930              ; function to handle CALL SNDSFX basic extension
 125+ 5930              ; plays a sound effect
 126+ 5930              ; _SNDSFX ( BYTE sfx_number, >0
 127+ 5930              ;			BYTE channel, = 0,1 or 2
 128+ 5930              ;			BYTE inverted_volume = 0-16, 0 being full volume
 129+ 5930              ; will put ram in page 0 also, page 1 is already there
 130+ 5930              ; if sound off throws illegal function call
 131+ 5930              ; if sfx not initialized, throws out of data
 132+ 5930              SNDSFX:
 133+ 5930              	; opening (
 134+ 5930 CD 23 65     	CALL CHKCHAR
 135+ 5933 28           	DB '('
 136+ 5934              	; get sfx_number
 137+ 5934 DD 21 1C 52  	LD IX, GETBYT
 138+ 5938 CD 59 01     	CALL CALBAS
 139+ 593B D5           	PUSH DE
 140+ 593C              	; comma
 141+ 593C CD 23 65     	CALL CHKCHAR
 142+ 593F 2C           	DB ','
 143+ 5940              	; get sfx address
 144+ 5940 DD 21 1C 52  	LD IX, GETBYT
 145+ 5944 CD 59 01     	CALL CALBAS
 146+ 5947 D5           	PUSH DE
 147+ 5948              	; comma
 148+ 5948 CD 23 65     	CALL CHKCHAR
 149+ 594B 2C           	DB ','
 150+ 594C              	; get inverted volume
 151+ 594C DD 21 1C 52  	LD IX, GETBYT
 152+ 5950 CD 59 01     	CALL CALBAS
 153+ 5953 D5           	PUSH DE
 154+ 5954              	; ending )
 155+ 5954 CD 23 65     	CALL CHKCHAR
 156+ 5957 29           	DB ')'
 157+ 5958
 158+ 5958 3A AF 58     	LD A, (SOUND_ENABLED)
 159+ 595B B7           	OR A
 160+ 595C 20 05        	JR NZ, .L1
 161+ 595E              	; sound disabled, throw illegal function call
 162+ 595E 1E 05        	LD E, 5
 163+ 5960 C3 49 65     	JP THROW_ERROR
 164+ 5963              .L1:
 165+ 5963 3A AE 58     	LD A, (SFX_INIT_STATUS)
 166+ 5966 B7           	OR A
 167+ 5967 20 05        	JR NZ, .L2
 168+ 5969              	; sfx data not initialized, throw out of data
 169+ 5969 1E 04        	LD E, 4
 170+ 596B C3 49 65     	JP THROW_ERROR
 171+ 596E              .L2:
 172+ 596E              	; pop  parameters and store away for later
 173+ 596E D1           	POP DE ; inverted volume
 174+ 596F 43           	LD B, E
 175+ 5970 D1           	POP DE ; channel
 176+ 5971 4B           	LD C, E
 177+ 5972 D1           	POP DE
 178+ 5973 7B           	LD A, E
 179+ 5974 08           	EX AF, AF'
 180+ 5975 E5           	PUSH HL ; basic text location
 181+ 5976 D9           	EXX
 182+ 5977 FD 21 7E 59  	LD IY, .RET
 183+ 597B C3 D5 64     	JP ENABLE_PAGE0
 184+ 597E              .RET:
 185+ 597E D9           	EXX
 186+ 597F 08           	EX AF, AF'
 187+ 5980 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 188+ 5983
 189+ 5983 D1               POP DE
 190+ 5984 C1               POP BC
 191+ 5985 CD 4C 64         CALL RESTORE_PAGE_INFO
 192+ 5988
 193+ 5988 E1           	POP HL
 194+ 5989 C9           	RET
 195+ 598A              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
 132  598A               ENDIF
 133  598A
 134  598A               IF (VRAM_CMDS == 1)
 135  598A               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 598A              ; *******************************************************************************************************
   2+ 598A              ; function to handle CALL FILVRM basic extension
   3+ 598A              ; FILVRM ( INT offset,
   4+ 598A              ;		   INT count,
   5+ 598A              ;		   BYTE value,
   6+ 598A              ;		   BYTE wait_vsync) >0 = true
   7+ 598A              ; wait_vsync will issue HALT before copying
   8+ 598A              FILVRM:
   9+ 598A              	; opening (
  10+ 598A CD 23 65     	CALL CHKCHAR
  11+ 598D 28           	DB '('
  12+ 598E              	; get offset address
  13+ 598E DD 21 2F 54  	LD IX, FRMQNT
  14+ 5992 CD 59 01     	CALL CALBAS
  15+ 5995 D5           	PUSH DE
  16+ 5996              	; comma
  17+ 5996 CD 23 65     	CALL CHKCHAR
  18+ 5999 2C           	DB ','
  19+ 599A              	; get count
  20+ 599A DD 21 2F 54  	LD IX, FRMQNT
  21+ 599E CD 59 01     	CALL CALBAS
  22+ 59A1 D5           	PUSH DE
  23+ 59A2              	; comma
  24+ 59A2 CD 23 65     	CALL CHKCHAR
  25+ 59A5 2C           	DB ','
  26+ 59A6              	; get value
  27+ 59A6 DD 21 1C 52  	LD IX, GETBYT
  28+ 59AA CD 59 01     	CALL CALBAS
  29+ 59AD F5           	PUSH AF
  30+ 59AE              	; comma
  31+ 59AE CD 23 65     	CALL CHKCHAR
  32+ 59B1 2C           	DB ','
  33+ 59B2              	; get vsync wait
  34+ 59B2 DD 21 1C 52  	LD IX, GETBYT
  35+ 59B6 CD 59 01     	CALL CALBAS
  36+ 59B9 F5           	PUSH AF
  37+ 59BA              	; ending )
  38+ 59BA CD 23 65     	CALL CHKCHAR
  39+ 59BD 29           	DB ')'
  40+ 59BE
  41+ 59BE              	; save position
  42+ 59BE E5           	PUSH HL
  43+ 59BF DD E1        	POP IX
  44+ 59C1
  45+ 59C1              	; syntax ok
  46+ 59C1              	; wait for vsync if needed
  47+ 59C1 F1           	POP AF
  48+ 59C2 B7           	OR A
  49+ 59C3 28 01        	JR Z, .L1
  50+ 59C5 76           	HALT
  51+ 59C6
  52+ 59C6              .L1:
  53+ 59C6 3E 01        	LD A,1
  54+ 59C8 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  55+ 59CB F1               POP AF ; value
  56+ 59CC C1               POP BC ; count
  57+ 59CD E1               POP HL ; offset
  58+ 59CE CD 56 00         CALL BIOS_FILVRM
  59+ 59D1 AF           	XOR A
  60+ 59D2 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  61+ 59D5
  62+ 59D5              .L3:
  63+ 59D5 DD E5        	PUSH IX
  64+ 59D7 E1           	POP HL
  65+ 59D8 C9           	RET
  66+ 59D9              ; *******************************************************************************************************
  67+ 59D9
  68+ 59D9              ; *******************************************************************************************************
  69+ 59D9              ; function to handle CALL MEMVRM basic extension
  70+ 59D9              ; copies from RAM to VRAM
  71+ 59D9              ; _MEMVRM ( INT source,
  72+ 59D9              ;			INT destination,
  73+ 59D9              ;			INT count,
  74+ 59D9              ;			BYTE wait_vsync) >0 = true
  75+ 59D9              ; will put ram in page 0 also, page 1 is already there
  76+ 59D9              ; wait_vsync will issue HALT before copying
  77+ 59D9              MEMVRM:
  78+ 59D9              	; opening (
  79+ 59D9 CD 23 65     	CALL CHKCHAR
  80+ 59DC 28           	DB '('
  81+ 59DD              	; get source address
  82+ 59DD DD 21 2F 54  	LD IX, FRMQNT
  83+ 59E1 CD 59 01     	CALL CALBAS
  84+ 59E4 D5           	PUSH DE
  85+ 59E5              	; comma
  86+ 59E5 CD 23 65     	CALL CHKCHAR
  87+ 59E8 2C           	DB ','
  88+ 59E9              	; get destination address
  89+ 59E9 DD 21 2F 54  	LD IX, FRMQNT
  90+ 59ED CD 59 01     	CALL CALBAS
  91+ 59F0 D5           	PUSH DE
  92+ 59F1              	; comma
  93+ 59F1 CD 23 65     	CALL CHKCHAR
  94+ 59F4 2C           	DB ','
  95+ 59F5              	; get length
  96+ 59F5 DD 21 2F 54  	LD IX, FRMQNT
  97+ 59F9 CD 59 01     	CALL CALBAS
  98+ 59FC D5           	PUSH DE
  99+ 59FD              	; comma
 100+ 59FD CD 23 65     	CALL CHKCHAR
 101+ 5A00 2C           	DB ','
 102+ 5A01              	; get vsync wait
 103+ 5A01 DD 21 1C 52  	LD IX, GETBYT
 104+ 5A05 CD 59 01     	CALL CALBAS
 105+ 5A08 F5           	PUSH AF
 106+ 5A09              	; ending )
 107+ 5A09 CD 23 65     	CALL CHKCHAR
 108+ 5A0C 29           	DB ')'
 109+ 5A0D
 110+ 5A0D                  ; save position in BASIC text
 111+ 5A0D E5           	PUSH HL
 112+ 5A0E DD E1        	POP IX
 113+ 5A10
 114+ 5A10 F1           	POP AF ; wait vsync
 115+ 5A11 B7           	OR A
 116+ 5A12 28 02        	JR Z, .L1
 117+ 5A14 76           	HALT
 118+ 5A15 F3           	DI
 119+ 5A16              .L1:
 120+ 5A16              	; pop LDIR parameters and store away for later
 121+ 5A16 C1           	POP BC ; count
 122+ 5A17 D1           	POP DE ; vram destination
 123+ 5A18 E1           	POP HL ; ram source
 124+ 5A19 D9           	EXX
 125+ 5A1A FD 21 21 5A   	LD IY, .RET
 126+ 5A1E C3 D5 64     	JP ENABLE_PAGE0
 127+ 5A21              .RET:
 128+ 5A21 FB           	EI
 129+ 5A22 D9           	EXX
 130+ 5A23 3E 01        	LD A,1
 131+ 5A25 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 132+ 5A28 CD 38 5A     	CALL .LDIRVM
 133+ 5A2B AF           	XOR A
 134+ 5A2C 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 135+ 5A2F D1               POP DE
 136+ 5A30 C1               POP BC
 137+ 5A31 CD 4C 64         CALL RESTORE_PAGE_INFO
 138+ 5A34 DD E5        	PUSH IX
 139+ 5A36 E1           	POP HL
 140+ 5A37 C9           	RET
 141+ 5A38
 142+ 5A38              .LDIRVM:
 143+ 5A38 EB           	EX DE, HL
 144+ 5A39 F3           	DI
 145+ 5A3A CD FC 63     	CALL SETWRT_LOCAL
 146+ 5A3D FB           	EI
 147+ 5A3E EB           	EX DE, HL
 148+ 5A3F 78           	LD A, B
 149+ 5A40 B7           	OR A
 150+ 5A41 28 0D        	JR Z, .L3
 151+ 5A43 C5           	PUSH BC
 152+ 5A44 0E 98        	LD C, #98
 153+ 5A46              .L2:
 154+ 5A46 50           	LD D, B
 155+ 5A47 06 00        	LD B, 0
 156+ 5A49 CD 09 64     	CALL BBYTECOPY_NO_C
 157+ 5A4C 42           	LD B, D
 158+ 5A4D 10 F7        	DJNZ .L2
 159+ 5A4F C1           	POP BC
 160+ 5A50              .L3:
 161+ 5A50 79           	LD A, C
 162+ 5A51 B7           	OR A
 163+ 5A52 C8           	RET Z
 164+ 5A53 41           	LD B, C
 165+ 5A54 C3 07 64     	JP BBYTECOPY
 166+ 5A57              ; *******************************************************************************************************
 167+ 5A57
 168+ 5A57              ; *******************************************************************************************************
 169+ 5A57              ; function to handle CALL VRMMEM basic extension
 170+ 5A57              ; copies from RAM to VRAM
 171+ 5A57              ; _VRMMEM ( INT source,
 172+ 5A57              ;			INT destination,
 173+ 5A57              ;			INT count
 174+ 5A57              ; will put ram in page 0 also, page 1 is already there
 175+ 5A57              VRMMEM:
 176+ 5A57              	; opening (
 177+ 5A57 CD 23 65     	CALL CHKCHAR
 178+ 5A5A 28           	DB '('
 179+ 5A5B              	; get source address
 180+ 5A5B DD 21 2F 54  	LD IX, FRMQNT
 181+ 5A5F CD 59 01     	CALL CALBAS
 182+ 5A62 D5           	PUSH DE
 183+ 5A63              	; comma
 184+ 5A63 CD 23 65     	CALL CHKCHAR
 185+ 5A66 2C           	DB ','
 186+ 5A67              	; get destination address
 187+ 5A67 DD 21 2F 54  	LD IX, FRMQNT
 188+ 5A6B CD 59 01     	CALL CALBAS
 189+ 5A6E D5           	PUSH DE
 190+ 5A6F              	; comma
 191+ 5A6F CD 23 65     	CALL CHKCHAR
 192+ 5A72 2C           	DB ','
 193+ 5A73              	; get length
 194+ 5A73 DD 21 2F 54  	LD IX, FRMQNT
 195+ 5A77 CD 59 01     	CALL CALBAS
 196+ 5A7A D5           	PUSH DE
 197+ 5A7B              	; ending )
 198+ 5A7B CD 23 65     	CALL CHKCHAR
 199+ 5A7E 29           	DB ')'
 200+ 5A7F
 201+ 5A7F                  ; save position in BASIC text
 202+ 5A7F E5           	PUSH HL
 203+ 5A80 DD E1        	POP IX
 204+ 5A82
 205+ 5A82 C1           	POP BC ; count
 206+ 5A83 D1           	POP DE ; destination
 207+ 5A84 E1           	POP HL ; source
 208+ 5A85 D9           	EXX
 209+ 5A86 FD 21 8E 5A  	LD IY, .RET
 210+ 5A8A F3           	DI
 211+ 5A8B C3 D5 64     	JP ENABLE_PAGE0
 212+ 5A8E              .RET:
 213+ 5A8E FB           	EI
 214+ 5A8F D9           	EXX
 215+ 5A90 3E 01        	LD A,1
 216+ 5A92 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 217+ 5A95 CD A5 5A     	CALL .LDIRMV
 218+ 5A98 AF           	XOR A
 219+ 5A99 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 220+ 5A9C D1               POP DE
 221+ 5A9D C1               POP BC
 222+ 5A9E CD 4C 64         CALL RESTORE_PAGE_INFO
 223+ 5AA1 DD E5        	PUSH IX
 224+ 5AA3 E1           	POP HL
 225+ 5AA4 C9           	RET
 226+ 5AA5
 227+ 5AA5              .LDIRMV:
 228+ 5AA5              	; set VRAM address *exactly* as in ROM, otherwise corruption
 229+ 5AA5 7D           	LD	A, L
 230+ 5AA6 F3           	DI
 231+ 5AA7 D3 99        	OUT	(099H), A
 232+ 5AA9 7C           	LD	A, H
 233+ 5AAA E6 3F        	AND	03FH
 234+ 5AAC D3 99        	OUT	(099H), A
 235+ 5AAE FB           	EI
 236+ 5AAF              	;EX (SP), HL
 237+ 5AAF              	;EX (SP), HL
 238+ 5AAF              	;NOP
 239+ 5AAF              	;NOP
 240+ 5AAF              .L4:
 241+ 5AAF DB 98            IN A, (#98)
 242+ 5AB1 12           	LD (DE), A
 243+ 5AB2 13               INC DE
 244+ 5AB3 0B               DEC BC
 245+ 5AB4 79               LD A, C
 246+ 5AB5 B0               OR B
 247+ 5AB6 20 F7            JR NZ, .L4
 248+ 5AB8 C9               RET
 249+ 5AB9              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 136  5AB9               ENDIF
 137  5AB9
 138  5AB9               IF (GENCAL_CMD == 1)
 139  5AB9               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5AB9              ; *******************************************************************************************************
   2+ 5AB9              ; function to handle CALL GENCAL basic extension
   3+ 5AB9              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5AB9              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5AB9              ; output values of registers will also be stored at reg_list_ptr
   6+ 5AB9              GENCAL:
   7+ 5AB9              	; opening (
   8+ 5AB9 CD 23 65     	CALL CHKCHAR
   9+ 5ABC 28           	DB '('
  10+ 5ABD              	; get function address
  11+ 5ABD DD 21 2F 54  	LD IX, FRMQNT
  12+ 5AC1 CD 59 01     	CALL CALBAS
  13+ 5AC4 D5           	PUSH DE
  14+ 5AC5              	; comma
  15+ 5AC5 CD 23 65     	CALL CHKCHAR
  16+ 5AC8 2C           	DB ','
  17+ 5AC9              	; get pointer to register list
  18+ 5AC9 3E 02            LD A,2
  19+ 5ACB 06 01            LD B,1
  20+ 5ACD 11 00 05         LD DE,#0500
  21+ 5AD0 CD 50 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  22+ 5AD3 C5           	PUSH BC
  23+ 5AD4              	; ending )
  24+ 5AD4 CD 23 65     	CALL CHKCHAR
  25+ 5AD7 29           	DB ')'
  26+ 5AD8
  27+ 5AD8              	; save BASIC token position
  28+ 5AD8 E5           	PUSH HL
  29+ 5AD9 D9               EXX
  30+ 5ADA E1           	POP HL ; HL'=next basic token
  31+ 5ADB D9               EXX
  32+ 5ADC
  33+ 5ADC E1               POP HL ; get pointer to register values
  34+ 5ADD F3           	DI
  35+ 5ADE ED 73 1E 62      LD (BLIT_STRUCT), SP
  36+ 5AE2 F9               LD SP, HL
  37+ 5AE3 F1               POP AF
  38+ 5AE4 C1               POP BC
  39+ 5AE5 D1               POP DE
  40+ 5AE6 E1               POP HL
  41+ 5AE7 DD E1            POP IX
  42+ 5AE9 FD E1            POP IY
  43+ 5AEB D9               EXX
  44+ 5AEC ED 73 20 62      LD (BLIT_STRUCT+2), SP
  45+ 5AF0 ED 7B 1E 62      LD SP, (BLIT_STRUCT)
  46+ 5AF4 FB               EI
  47+ 5AF5 D1               POP DE ; get function to call
  48+ 5AF6 E5               PUSH HL
  49+ 5AF7 CD 12 5B         CALL .EXXDECALL
  50+ 5AFA F3               DI
  51+ 5AFB ED 73 1E 62      LD (BLIT_STRUCT), SP
  52+ 5AFF ED 7B 20 62      LD SP, (BLIT_STRUCT+2)
  53+ 5B03 FD E5            PUSH IY
  54+ 5B05 DD E5            PUSH IX
  55+ 5B07 E5               PUSH HL
  56+ 5B08 D5               PUSH DE
  57+ 5B09 C5               PUSH BC
  58+ 5B0A F5               PUSH AF
  59+ 5B0B ED 7B 1E 62      LD SP, (BLIT_STRUCT)
  60+ 5B0F FB               EI
  61+ 5B10 E1               POP HL
  62+ 5B11 C9           	RET
  63+ 5B12
  64+ 5B12              .EXXDECALL:
  65+ 5B12 D5               PUSH DE
  66+ 5B13 D9               EXX
  67+ 5B14 C9               RET
  68+ 5B15              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 140  5B15               ENDIF
 141  5B15
 142  5B15               IF (BOX_CMDS == 1)
 143  5B15               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B15              ; *******************************************************************************************************
   2+ 5B15              ; generic function to implement rectangle data copy
   3+ 5B15              ; should be modified to call appropriate function for memory or vram
   4+ 5B15              ; input IX=pointer to following structure
   5+ 5B15              ; +00 source data pointer
   6+ 5B15              ; +02 num bytes in a row
   7+ 5B15              ; +04 number of rows
   8+ 5B15              ; +06 source add-to value till next row
   9+ 5B15              ; +08 destination address
  10+ 5B15              ; +10 destination add-to value till next row
  11+ 5B15              ; modifies AF, BC, DE, HL
  12+ 5B15              RECTANGLE_COPY:
  13+ 5B15 DD 6E 00     	LD L, (IX+0)
  14+ 5B18 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B1B DD 5E 08     	LD E, (IX+8)
  16+ 5B1E DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B21 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B24              .L1:
  19+ 5B24 C5           	PUSH BC
  20+ 5B25 E5           		PUSH HL
  21+ 5B26 D5           			PUSH DE
  22+ 5B27 DD 4E 02     				LD C, (IX+2)
  23+ 5B2A DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B2D              .CALL1:
  25+ 5B2D CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B30              .CALL2:
  27+ 5B30 CD 00 00     				CALL 0 ; copy data fn
  28+ 5B33 E1           			POP HL
  29+ 5B34 DD 4E 0A     			LD C, (IX+10)
  30+ 5B37 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B3A 09           			ADD HL, BC
  32+ 5B3B EB           			EX DE, HL
  33+ 5B3C E1           		POP HL
  34+ 5B3D DD 4E 06     		LD C, (IX+6)
  35+ 5B40 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B43 09           		ADD HL, BC
  37+ 5B44 C1           	POP BC
  38+ 5B45 10 DD        	DJNZ .L1
  39+ 5B47 C9           	RET
  40+ 5B48              ; *******************************************************************************************************
  41+ 5B48
  42+ 5B48              ; *******************************************************************************************************
  43+ 5B48              ; function to handle CALL BOXMEMCPY basic extension
  44+ 5B48              ; copies data with window like boundaries within ram
  45+ 5B48              ; BOXMEMCPY ( INT source data pointer,
  46+ 5B48              ;			  INT source number of bytes in a row,
  47+ 5B48              ;			  INT number of rows,
  48+ 5B48              ;			  INT source add-to value till next row,
  49+ 5B48              ; 			  INT destination pointer,
  50+ 5B48              ;			  INT destination add-to value till next row )
  51+ 5B48              ; request_data_ptr described in RECTANGLE_COPY
  52+ 5B48              ; will put ram in page 0 also, page 1 is already there
  53+ 5B48              BOXMEMCPY:
  54+ 5B48 11 52 5B     	LD DE,BOXMEMCPY.RET
  55+ 5B4B ED 53 C7 5B  	LD (BOXCOMMON.ADDR+2), DE
  56+ 5B4F C3 65 5B     	JP BOXCOMMON
  57+ 5B52              .RET:
  58+ 5B52 FB           	EI
  59+ 5B53              	; set RAM functions to call
  60+ 5B53 21 00 00     	LD HL, 0
  61+ 5B56 22 2D 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  62+ 5B59 22 2F 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  63+ 5B5C 21 ED B0     	LD HL, #B0ED ; LDIR
  64+ 5B5F 22 31 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  65+ 5B62 C3 CC 5B     	JP BOXCOMMON.CALL
  66+ 5B65              ; *******************************************************************************************************
  67+ 5B65
  68+ 5B65              ; *******************************************************************************************************
  69+ 5B65              ; common parts of BOX commands
  70+ 5B65              BOXCOMMON:
  71+ 5B65              	; opening (
  72+ 5B65 CD 23 65     	CALL CHKCHAR
  73+ 5B68 28           	DB '('
  74+ 5B69              	; get source data pointer
  75+ 5B69 DD 21 2F 54  	LD IX, FRMQNT
  76+ 5B6D CD 59 01     	CALL CALBAS
  77+ 5B70 ED 53 1E 62  	LD (BLIT_STRUCT+0), DE
  78+ 5B74              	; comma
  79+ 5B74 CD 23 65     	CALL CHKCHAR
  80+ 5B77 2C           	DB ','
  81+ 5B78              	; source number of bytes in a row
  82+ 5B78 DD 21 2F 54  	LD IX, FRMQNT
  83+ 5B7C CD 59 01     	CALL CALBAS
  84+ 5B7F ED 53 20 62  	LD (BLIT_STRUCT+2), DE
  85+ 5B83              	; comma
  86+ 5B83 CD 23 65     	CALL CHKCHAR
  87+ 5B86 2C           	DB ','
  88+ 5B87              	; number of rows
  89+ 5B87 DD 21 2F 54  	LD IX, FRMQNT
  90+ 5B8B CD 59 01     	CALL CALBAS
  91+ 5B8E ED 53 22 62  	LD (BLIT_STRUCT+4), DE
  92+ 5B92              	; comma
  93+ 5B92 CD 23 65     	CALL CHKCHAR
  94+ 5B95 2C           	DB ','
  95+ 5B96              	; source add-to value till next row
  96+ 5B96 DD 21 2F 54  	LD IX, FRMQNT
  97+ 5B9A CD 59 01     	CALL CALBAS
  98+ 5B9D ED 53 24 62  	LD (BLIT_STRUCT+6), DE
  99+ 5BA1              	; comma
 100+ 5BA1 CD 23 65     	CALL CHKCHAR
 101+ 5BA4 2C           	DB ','
 102+ 5BA5              	; destination pointer
 103+ 5BA5 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5BA9 CD 59 01     	CALL CALBAS
 105+ 5BAC ED 53 26 62  	LD (BLIT_STRUCT+8), DE
 106+ 5BB0              	; comma
 107+ 5BB0 CD 23 65     	CALL CHKCHAR
 108+ 5BB3 2C           	DB ','
 109+ 5BB4              	; destination add-to value till next row
 110+ 5BB4 DD 21 2F 54  	LD IX, FRMQNT
 111+ 5BB8 CD 59 01     	CALL CALBAS
 112+ 5BBB ED 53 28 62  	LD (BLIT_STRUCT+10), DE
 113+ 5BBF              	; ending )
 114+ 5BBF CD 23 65     	CALL CHKCHAR
 115+ 5BC2 29           	DB ')'
 116+ 5BC3
 117+ 5BC3 E5           	PUSH HL ; save position in BASIC buffer
 118+ 5BC4 F3           	DI
 119+ 5BC5              .ADDR:
 120+ 5BC5 FD 21 00 00  	LD IY, 0
 121+ 5BC9 C3 D5 64     	JP ENABLE_PAGE0
 122+ 5BCC              .CALL:
 123+ 5BCC DD 21 1E 62  	LD IX,BLIT_STRUCT
 124+ 5BD0 CD 15 5B     	CALL RECTANGLE_COPY
 125+ 5BD3 AF           	XOR A
 126+ 5BD4 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 127+ 5BD7
 128+ 5BD7 D1               POP DE
 129+ 5BD8 C1               POP BC
 130+ 5BD9 CD 4C 64         CALL RESTORE_PAGE_INFO
 131+ 5BDC
 132+ 5BDC E1           	POP HL
 133+ 5BDD C9           	RET
 134+ 5BDE              ; *******************************************************************************************************
 135+ 5BDE
 136+ 5BDE              ; *******************************************************************************************************
 137+ 5BDE              ; function to handle CALL BOXMEMVRM basic extension
 138+ 5BDE              ; copies data with window like boundaries from ram to Vram
 139+ 5BDE              ; BOXMEMVRM ( INT source data pointer,
 140+ 5BDE              ;			  INT source number of bytes in a row,
 141+ 5BDE              ;			  INT number of rows,
 142+ 5BDE              ;			  INT source add-to value till next row,
 143+ 5BDE              ; 			  INT destination pointer,
 144+ 5BDE              ;			  INT destination add-to value till next row )
 145+ 5BDE              ; request_data_ptr described in RECTANGLE_COPY
 146+ 5BDE              ; will put ram in page 0 also, page 1 is already there
 147+ 5BDE              BOXMEMVRM:
 148+ 5BDE 11 E8 5B     	LD DE,BOXMEMVRM.RET
 149+ 5BE1 ED 53 C7 5B  	LD (BOXCOMMON.ADDR+2), DE
 150+ 5BE5 C3 65 5B     	JP BOXCOMMON
 151+ 5BE8              .RET:
 152+ 5BE8 FB           	EI
 153+ 5BE9              	; set RAM functions to call
 154+ 5BE9 21 03 5C     	LD HL, .SETDEST
 155+ 5BEC 22 2E 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 156+ 5BEF 21 0B 5C     	LD HL, .COPYDATA
 157+ 5BF2 22 31 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 158+ 5BF5 3E CD        	LD A, #CD ; CALL
 159+ 5BF7 32 2D 5B     	LD (RECTANGLE_COPY.CALL1), A
 160+ 5BFA 32 30 5B     	LD (RECTANGLE_COPY.CALL2), A
 161+ 5BFD              	;LD A,1
 162+ 5BFD 32 2F 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 163+ 5C00 C3 CC 5B     	JP BOXCOMMON.CALL
 164+ 5C03              .SETDEST:
 165+ 5C03 EB           	EX DE, HL
 166+ 5C04 F3           	DI
 167+ 5C05 CD FC 63     	CALL SETWRT_LOCAL
 168+ 5C08 FB           	EI
 169+ 5C09 EB           	EX DE, HL
 170+ 5C0A C9           	RET
 171+ 5C0B              .COPYDATA:
 172+ 5C0B 41           	LD B, C
 173+ 5C0C C3 07 64     	JP BBYTECOPY
 174+ 5C0F              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 144  5C0F               ENDIF
 145  5C0F
 146  5C0F               IF (BLIT_CMDS == 1)
 147  5C0F               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C0F              ; *******************************************************************************************************
   2+ 5C0F              ; function rotates mask and data of several characters and applies to background data
   3+ 5C0F              ; this handles x-shift from 0 to 4
   4+ 5C0F              ; contains self-modifying code that is set-up from external function
   5+ 5C0F              ; input HL=pointer to mask data
   6+ 5C0F              ; input HL'=pointer to character data
   7+ 5C0F              ; input DE=output buffer containing background data
   8+ 5C0F              ; input BC=DE+8
   9+ 5C0F              ; input A=number of characters to process
  10+ 5C0F              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C0F              SHIFT04:
  12+ 5C0F 08           	EX AF, AF'
  13+ 5C10 7E           	LD A, (HL) ; get mask
  14+ 5C11 D9           	EXX
  15+ 5C12 57           	LD D, A
  16+ 5C13 1E FF        	LD E, #FF
  17+ 5C15 37           	SCF
  18+ 5C16              .M1:
  19+ 5C16 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C18 CB 1A        	RR D
  21+ 5C1A CB 1B        	RR E
  22+ 5C1C CB 1A        	RR D
  23+ 5C1E CB 1B        	RR E
  24+ 5C20 CB 1A        	RR D
  25+ 5C22 CB 1B        	RR E
  26+ 5C24 CB 1A        	RR D
  27+ 5C26 CB 1B        	RR E
  28+ 5C28
  29+ 5C28 46           	LD B, (HL) ; get data
  30+ 5C29 0E 00        	LD C, 0
  31+ 5C2B              .M2:
  32+ 5C2B 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C2D CB 38        	SRL B
  34+ 5C2F CB 19        	RR C
  35+ 5C31 CB 38        	SRL B
  36+ 5C33 CB 19        	RR C
  37+ 5C35 CB 38        	SRL B
  38+ 5C37 CB 19        	RR C
  39+ 5C39 CB 38        	SRL B
  40+ 5C3B CB 19        	RR C
  41+ 5C3D
  42+ 5C3D D9           	EXX
  43+ 5C3E 1A           	LD A, (DE) ; background
  44+ 5C3F D9           	EXX
  45+ 5C40 A2           	AND D
  46+ 5C41 B0           	OR B
  47+ 5C42 D9           	EXX
  48+ 5C43 12           	LD (DE), A
  49+ 5C44
  50+ 5C44 0A           	LD A, (BC)
  51+ 5C45 D9           	EXX
  52+ 5C46 A3           	AND E
  53+ 5C47 B1           	OR C
  54+ 5C48 23           	INC HL
  55+ 5C49 D9           	EXX
  56+ 5C4A 02           	LD (BC), A
  57+ 5C4B
  58+ 5C4B 23           	INC HL
  59+ 5C4C 13           	INC DE
  60+ 5C4D 03           	INC BC
  61+ 5C4E
  62+ 5C4E 08           	EX AF, AF'
  63+ 5C4F 3D           	DEC A
  64+ 5C50 C2 0F 5C     	JP NZ, SHIFT04
  65+ 5C53 C9           	RET
  66+ 5C54              ; *******************************************************************************************************
  67+ 5C54
  68+ 5C54              ; *******************************************************************************************************
  69+ 5C54              ; function rotates mask and data of several characters and applies to background data
  70+ 5C54              ; this handles x-shift from 5 to 8
  71+ 5C54              ; contains self-modifying code that is set-up from external function
  72+ 5C54              ; input HL=pointer to mask data
  73+ 5C54              ; input HL'=pointer to character data
  74+ 5C54              ; input DE=output buffer containing background data
  75+ 5C54              ; input BC=DE+8
  76+ 5C54              ; input A=number of characters to process
  77+ 5C54              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C54              SHIFT58:
  79+ 5C54 08           	EX AF, AF'
  80+ 5C55 7E           	LD A, (HL) ; get mask
  81+ 5C56 D9           	EXX
  82+ 5C57 57           	LD D, A
  83+ 5C58 1E FF        	LD E, #FF
  84+ 5C5A 37           	SCF
  85+ 5C5B              .M1:
  86+ 5C5B 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C5D CB 12        	RL D
  88+ 5C5F CB 13        	RL E
  89+ 5C61 CB 12        	RL D
  90+ 5C63 CB 13        	RL E
  91+ 5C65 CB 12        	RL D
  92+ 5C67 CB 13        	RL E
  93+ 5C69
  94+ 5C69 46           	LD B, (HL)
  95+ 5C6A 0E 00        	LD C, 0
  96+ 5C6C              .M2:
  97+ 5C6C 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C6E CB 20        	SLA B
  99+ 5C70 CB 11        	RL C
 100+ 5C72 CB 20        	SLA B
 101+ 5C74 CB 11        	RL C
 102+ 5C76 CB 20        	SLA B
 103+ 5C78 CB 11        	RL C
 104+ 5C7A
 105+ 5C7A D9           	EXX
 106+ 5C7B 1A           	LD A, (DE) ; background
 107+ 5C7C D9           	EXX
 108+ 5C7D A3           	AND E
 109+ 5C7E B1           	OR C
 110+ 5C7F D9           	EXX
 111+ 5C80 12           	LD (DE), A
 112+ 5C81
 113+ 5C81 0A           	LD A, (BC)
 114+ 5C82 D9           	EXX
 115+ 5C83 A2           	AND D
 116+ 5C84 B0           	OR B
 117+ 5C85 23           	INC HL
 118+ 5C86 D9           	EXX
 119+ 5C87 02           	LD (BC), A
 120+ 5C88
 121+ 5C88 23           	INC HL
 122+ 5C89 13           	INC DE
 123+ 5C8A 03           	INC BC
 124+ 5C8B
 125+ 5C8B 08           	EX AF, AF'
 126+ 5C8C 3D           	DEC A
 127+ 5C8D C2 54 5C     	JP NZ, SHIFT58
 128+ 5C90 C9           	RET
 129+ 5C91              ; *******************************************************************************************************
 130+ 5C91
 131+ 5C91              ; *******************************************************************************************************
 132+ 5C91              ; routine that shifts one row of characters
 133+ 5C91              ; contains self-modifying code that is set-up from external function
 134+ 5C91              ; input HL=pointer to mask data
 135+ 5C91              ; input HL'=pointer to character data
 136+ 5C91              ; input DE=output buffer containing background data
 137+ 5C91              ; input A=number of characters to process
 138+ 5C91              ; input IX=pointer to structure describing input data
 139+ 5C91              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5C91              SHIFT_ROW:
 141+ 5C91 F5           	PUSH AF
 142+ 5C92 ED 53 1A 62  		LD (BLIT_TMP1), DE
 143+ 5C96 E5           		PUSH HL
 144+ 5C97 CD DA 5C     			CALL .ADDYSHIFT
 145+ 5C9A E1           		POP HL
 146+ 5C9B ED 53 1C 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5C9F              .L1:
 148+ 5C9F 3E 08        		LD A, 8
 149+ 5CA1 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CA4              .CALL1:
 151+ 5CA4 CD 00 00     		CALL 0
 152+ 5CA7 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CAA B7           		OR A
 154+ 5CAB 28 26        		JR Z, .DONE
 155+ 5CAD ED 5B 1A 62  		LD DE, (BLIT_TMP1)
 156+ 5CB1 E5           		PUSH HL
 157+ 5CB2 CD E8 5C     			CALL .DETONEXTROW
 158+ 5CB5 E1           		POP HL
 159+ 5CB6              .CALL2:
 160+ 5CB6 CD 00 00     		CALL 0
 161+ 5CB9 ED 5B 1A 62  		LD DE, (BLIT_TMP1)
 162+ 5CBD E5           		PUSH HL
 163+ 5CBE CD E2 5C     			CALL .ADD8
 164+ 5CC1 E1           		POP HL
 165+ 5CC2 ED 53 1A 62  		LD (BLIT_TMP1), DE
 166+ 5CC6 ED 5B 1C 62  		LD DE, (BLIT_TMP2)
 167+ 5CCA E5           		PUSH HL
 168+ 5CCB CD E2 5C     			CALL .ADD8
 169+ 5CCE E1           		POP HL
 170+ 5CCF ED 53 1C 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5CD3              .DONE:
 172+ 5CD3 F1           	POP AF
 173+ 5CD4 3D           	DEC A
 174+ 5CD5 C8           	RET Z
 175+ 5CD6 F5           	PUSH AF
 176+ 5CD7 C3 9F 5C     	JP .L1
 177+ 5CDA              .ADDYSHIFT:
 178+ 5CDA EB           	EX DE, HL
 179+ 5CDB 16 00        	LD D, 0
 180+ 5CDD DD 5E 02     	LD E, (IX+2); y shift
 181+ 5CE0 18 0C        	JR .MOVDEBC
 182+ 5CE2              .ADD8:
 183+ 5CE2 21 08 00     	LD HL, 8
 184+ 5CE5 C3 EE 5C     	JP .MOVDEBC
 185+ 5CE8              .DETONEXTROW:
 186+ 5CE8 DD 6E 06     	LD L, (IX+6)
 187+ 5CEB DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5CEE              .MOVDEBC:
 189+ 5CEE 19           	ADD HL, DE
 190+ 5CEF 54           	LD D, H
 191+ 5CF0 5D           	LD E, L
 192+ 5CF1 01 08 00     	LD BC, 8
 193+ 5CF4 09           	ADD HL, BC
 194+ 5CF5 44           	LD B, H
 195+ 5CF6 4D           	LD C, L
 196+ 5CF7 C9           	RET
 197+ 5CF8              ; *******************************************************************************************************
 198+ 5CF8
 199+ 5CF8              ; *******************************************************************************************************
 200+ 5CF8              ; function rotates mask and character data and applies it to background
 201+ 5CF8              ; input IX=pointer to structure describing input data
 202+ 5CF8              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5CF8              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5CF8              ; +4  DW background data start;
 205+ 5CF8              ; +6  DW background add to value to next row of background data
 206+ 5CF8              ; +8  DW mask data start;
 207+ 5CF8              ; +10  DW character data start;
 208+ 5CF8              ; +12 DW character&mask add to value to next row of data
 209+ 5CF8              ; +14 DW columns (low byte used)
 210+ 5CF8              ; +16 DW rows (low byte used)
 211+ 5CF8              SHIFT_MERGE_CHARACTER:
 212+ 5CF8 DD 7E 00     	LD A, (IX) ; shift
 213+ 5CFB FE 05        	CP 5
 214+ 5CFD 38 25        	JR C, .RIGHT
 215+ 5CFF              	; shifts 5-7, use rotate towards left 1-3
 216+ 5CFF 21 54 5C     	LD HL, SHIFT58
 217+ 5D02 22 A5 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D05 22 B7 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D08 D6 05        	SUB 5
 220+ 5D0A 28 0D        	JR Z, .L1
 221+ 5D0C 87           	ADD A, A
 222+ 5D0D 87           	ADD A, A
 223+ 5D0E 67           	LD H, A
 224+ 5D0F 2E 18        	LD L, #18 ; JR opcode
 225+ 5D11 22 5B 5C     	LD (SHIFT58.M1), HL
 226+ 5D14 22 6C 5C     	LD (SHIFT58.M2), HL
 227+ 5D17 18 32        	JR .DO
 228+ 5D19              .L1:
 229+ 5D19 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D1C 22 5B 5C     	LD (SHIFT58.M1), HL
 231+ 5D1F 22 6C 5C     	LD (SHIFT58.M2), HL
 232+ 5D22 18 27        	JR .DO
 233+ 5D24              .RIGHT:
 234+ 5D24              	; shifts 0-4, rotate towards right
 235+ 5D24 21 0F 5C     	LD HL, SHIFT04
 236+ 5D27 22 A5 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D2A 22 B7 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D2D FE 04        	CP 4
 239+ 5D2F 28 11        	JR Z, .R1
 240+ 5D31 D6 04        	SUB 4
 241+ 5D33 ED 44        	NEG
 242+ 5D35 87           	ADD A, A
 243+ 5D36 87           	ADD A, A
 244+ 5D37 67           	LD H, A
 245+ 5D38 2E 18        	LD L, #18 ; JR opcode
 246+ 5D3A 22 16 5C     	LD (SHIFT04.M1), HL
 247+ 5D3D 22 2B 5C     	LD (SHIFT04.M2), HL
 248+ 5D40 18 09        	JR .DO
 249+ 5D42              .R1:
 250+ 5D42 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D45 22 16 5C     	LD (SHIFT04.M1), HL
 252+ 5D48 22 2B 5C     	LD (SHIFT04.M2), HL
 253+ 5D4B              .DO:
 254+ 5D4B DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D4E DD 6E 08     	LD L, (IX+8)
 256+ 5D51 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D54 DD 5E 04     	LD E, (IX+4)
 258+ 5D57 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D5A D9           	EXX
 260+ 5D5B DD 6E 0A     	LD L, (IX+10)
 261+ 5D5E DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D61 D9           	EXX
 263+ 5D62              .LOOP:
 264+ 5D62 C5           	PUSH BC
 265+ 5D63 E5           		PUSH HL
 266+ 5D64 D5           			PUSH DE
 267+ 5D65 D9           				EXX
 268+ 5D66 E5           				PUSH HL
 269+ 5D67 D9           					EXX
 270+ 5D68 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D6B              .CALL:
 272+ 5D6B CD 91 5C     					CALL SHIFT_ROW
 273+ 5D6E E1           				POP HL
 274+ 5D6F DD 5E 0C     				LD E, (IX+12)
 275+ 5D72 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5D75 19           				ADD HL, DE
 277+ 5D76 D9           				EXX
 278+ 5D77 E1           			POP HL
 279+ 5D78 DD 5E 06     			LD E, (IX+6)
 280+ 5D7B DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5D7E 19           			ADD HL, DE
 282+ 5D7F EB           			EX DE, HL
 283+ 5D80 E1           		POP HL
 284+ 5D81 DD 4E 0C     		LD C, (IX+12)
 285+ 5D84 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5D87 09           		ADD HL, BC
 287+ 5D88 C1           	POP BC
 288+ 5D89 10 D7        	DJNZ .LOOP
 289+ 5D8B C9           	RET
 290+ 5D8C              ; *******************************************************************************************************
 291+ 5D8C
 292+ 5D8C               IFNDEF CMDS_WITH_PARAMETERS
 293+ 5D8C ~            ; *******************************************************************************************************
 294+ 5D8C ~            ; function to handle CALL BLIT basic extension
 295+ 5D8C ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 296+ 5D8C ~            ; fuses with background data and applies vertical shift too
 297+ 5D8C ~            ; BLIT ( INT request_data_ptr )
 298+ 5D8C ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
 299+ 5D8C ~            ; will put ram in page 0 also, page 1 is already there
 300+ 5D8C ~            BLIT:
 301+ 5D8C ~            	; opening (
 302+ 5D8C ~            	CALL CHKCHAR
 303+ 5D8C ~            	DB '('
 304+ 5D8C ~            	; get pointer to request struct
 305+ 5D8C ~            	LD IX, FRMQNT
 306+ 5D8C ~            	CALL CALBAS
 307+ 5D8C ~            	PUSH DE
 308+ 5D8C ~            	; ending )
 309+ 5D8C ~            	CALL CHKCHAR
 310+ 5D8C ~            	DB ')'
 311+ 5D8C ~
 312+ 5D8C ~            	POP IX ; pointer to request struct
 313+ 5D8C ~
 314+ 5D8C ~            	PUSH HL ; save position in BASIC buffer
 315+ 5D8C ~
 316+ 5D8C ~            	LD IY, .RET
 317+ 5D8C ~            	JP ENABLE_PAGE0
 318+ 5D8C ~            .RET:
 319+ 5D8C ~            	EI
 320+ 5D8C ~            	CALL SHIFT_MERGE_CHARACTER
 321+ 5D8C ~
 322+ 5D8C ~                POP DE
 323+ 5D8C ~                POP BC
 324+ 5D8C ~                CALL RESTORE_PAGE_INFO
 325+ 5D8C ~
 326+ 5D8C ~            	POP HL
 327+ 5D8C ~            	RET
 328+ 5D8C ~            ; *******************************************************************************************************
 329+ 5D8C               ENDIF
 330+ 5D8C
 331+ 5D8C               IFDEF CMDS_WITH_PARAMETERS
 332+ 5D8C              ; *******************************************************************************************************
 333+ 5D8C              ; function to handle CALL BLIT basic extension
 334+ 5D8C              ; rotates 1-bit character drawing horizontally with mask and character data and
 335+ 5D8C              ; fuses with background data and applies vertical shift too
 336+ 5D8C              ; in form without pointers
 337+ 5D8C              ; BLIT ( INT x,
 338+ 5D8C              ;		 INT y,
 339+ 5D8C              ;		 INT char_data_pointer,
 340+ 5D8C              ;		 INT mask_data_pointer,
 341+ 5D8C              ;		 INT width (in characters),
 342+ 5D8C              ;		 INT height (in characters),
 343+ 5D8C              ;		 INT background_pointer (top left),
 344+ 5D8C              ;		 INT background_width (in characters),
 345+ 5D8C              ; will put ram in page 0 also, page 1 is already there
 346+ 5D8C              BLIT:
 347+ 5D8C              	; opening (
 348+ 5D8C CD 23 65     	CALL CHKCHAR
 349+ 5D8F 28           	DB '('
 350+ 5D90              	; get x coordinate
 351+ 5D90 DD 21 2F 54  	LD IX, FRMQNT
 352+ 5D94 CD 59 01     	CALL CALBAS
 353+ 5D97 7B           	LD A, E
 354+ 5D98 E6 07        	AND 7
 355+ 5D9A 32 1E 62     	LD (BLIT_STRUCT+0), A
 356+ 5D9D CD 6C 5E     	CALL .DAdiv8
 357+ 5DA0 32 1A 62     	LD (BLIT_TMP+0),A
 358+ 5DA3              	; comma
 359+ 5DA3 CD 23 65     	CALL CHKCHAR
 360+ 5DA6 2C           	DB ','
 361+ 5DA7              	; get y coordinate
 362+ 5DA7 DD 21 2F 54  	LD IX, FRMQNT
 363+ 5DAB CD 59 01     	CALL CALBAS
 364+ 5DAE 7B           	LD A, E
 365+ 5DAF E6 07        	AND 7
 366+ 5DB1 32 20 62     	LD (BLIT_STRUCT+2), A
 367+ 5DB4 CD 6C 5E     	CALL .DAdiv8
 368+ 5DB7 32 1B 62     	LD (BLIT_TMP+1),A
 369+ 5DBA              	; comma
 370+ 5DBA CD 23 65     	CALL CHKCHAR
 371+ 5DBD 2C           	DB ','
 372+ 5DBE              	; get char data pointer
 373+ 5DBE DD 21 2F 54  	LD IX, FRMQNT
 374+ 5DC2 CD 59 01     	CALL CALBAS
 375+ 5DC5 ED 53 28 62  	LD (BLIT_STRUCT+10), DE
 376+ 5DC9              	; comma
 377+ 5DC9 CD 23 65     	CALL CHKCHAR
 378+ 5DCC 2C           	DB ','
 379+ 5DCD              	; get mask data pointer
 380+ 5DCD DD 21 2F 54  	LD IX, FRMQNT
 381+ 5DD1 CD 59 01     	CALL CALBAS
 382+ 5DD4 ED 53 26 62  	LD (BLIT_STRUCT+8), DE
 383+ 5DD8              	; comma
 384+ 5DD8 CD 23 65     	CALL CHKCHAR
 385+ 5DDB 2C           	DB ','
 386+ 5DDC              	; get width
 387+ 5DDC DD 21 2F 54  	LD IX, FRMQNT
 388+ 5DE0 CD 59 01     	CALL CALBAS
 389+ 5DE3 7B           	LD A, E
 390+ 5DE4 32 2C 62     	LD (BLIT_STRUCT+14), A
 391+ 5DE7              	; comma
 392+ 5DE7 CD 23 65     	CALL CHKCHAR
 393+ 5DEA 2C           	DB ','
 394+ 5DEB              	; get height
 395+ 5DEB DD 21 2F 54  	LD IX, FRMQNT
 396+ 5DEF CD 59 01     	CALL CALBAS
 397+ 5DF2 7B           	LD A, E
 398+ 5DF3 32 2E 62     	LD (BLIT_STRUCT+16), A
 399+ 5DF6              	; comma
 400+ 5DF6 CD 23 65     	CALL CHKCHAR
 401+ 5DF9 2C           	DB ','
 402+ 5DFA              	; get background pointer
 403+ 5DFA DD 21 2F 54  	LD IX, FRMQNT
 404+ 5DFE CD 59 01     	CALL CALBAS
 405+ 5E01 ED 53 22 62  	LD (BLIT_STRUCT+4), DE
 406+ 5E05              	; comma
 407+ 5E05 CD 23 65     	CALL CHKCHAR
 408+ 5E08 2C           	DB ','
 409+ 5E09              	; get background width
 410+ 5E09 DD 21 2F 54  	LD IX, FRMQNT
 411+ 5E0D CD 59 01     	CALL CALBAS
 412+ 5E10 7B           	LD A, E
 413+ 5E11 32 1C 62     	LD (BLIT_TMP+2), A
 414+ 5E14              	; ending )
 415+ 5E14 CD 23 65     	CALL CHKCHAR
 416+ 5E17 29           	DB ')'
 417+ 5E18
 418+ 5E18 E5           	PUSH HL ; save position in BASIC buffer
 419+ 5E19
 420+ 5E19              	; calculate char&mask add to value
 421+ 5E19 26 00        	LD H, 0
 422+ 5E1B 3A 2C 62     	LD A, (BLIT_STRUCT+14)
 423+ 5E1E 6F           	LD L, A
 424+ 5E1F CD 11 64     	CALL HLx8
 425+ 5E22 22 2A 62     	LD (BLIT_STRUCT+12), HL
 426+ 5E25              	; calculate background add to value
 427+ 5E25 26 00        	LD H, 0
 428+ 5E27 3A 1C 62     	LD A, (BLIT_TMP+2)
 429+ 5E2A 6F           	LD L, A
 430+ 5E2B CD 11 64     	CALL HLx8
 431+ 5E2E 22 24 62     	LD (BLIT_STRUCT+6), HL
 432+ 5E31              	; calculate pointer to background location
 433+ 5E31 21 00 00     	LD HL, 0
 434+ 5E34 3A 1B 62     	LD A,(BLIT_TMP+1)
 435+ 5E37 B7           	OR A
 436+ 5E38 28 08        	JR Z, .L1
 437+ 5E3A 47           	LD B,A
 438+ 5E3B ED 5B 24 62  	LD DE,(BLIT_STRUCT+6)
 439+ 5E3F              .L0:
 440+ 5E3F 19           	ADD HL, DE
 441+ 5E40 10 FD        	DJNZ .L0
 442+ 5E42              .L1:
 443+ 5E42 EB           	EX DE,HL
 444+ 5E43 26 00        	LD H,0
 445+ 5E45 3A 1A 62     	LD A,(BLIT_TMP+0)
 446+ 5E48 6F           	LD L,A
 447+ 5E49 CD 11 64     	CALL HLx8
 448+ 5E4C 19           	ADD HL,DE
 449+ 5E4D ED 5B 22 62  	LD DE,(BLIT_STRUCT+4)
 450+ 5E51 19           	ADD HL,DE
 451+ 5E52 22 22 62     	LD (BLIT_STRUCT+4),HL
 452+ 5E55
 453+ 5E55 F3           	DI
 454+ 5E56 FD 21 5D 5E  	LD IY, .RET
 455+ 5E5A C3 D5 64     	JP ENABLE_PAGE0
 456+ 5E5D              .RET:
 457+ 5E5D FB           	EI
 458+ 5E5E DD 21 1E 62  	LD IX, BLIT_STRUCT
 459+ 5E62 CD F8 5C     	CALL SHIFT_MERGE_CHARACTER
 460+ 5E65
 461+ 5E65 D1               POP DE
 462+ 5E66 C1               POP BC
 463+ 5E67 CD 4C 64         CALL RESTORE_PAGE_INFO
 464+ 5E6A
 465+ 5E6A E1           	POP HL
 466+ 5E6B C9           	RET
 467+ 5E6C              .DAdiv8:
 468+ 5E6C 7B           	LD A,E
 469+ 5E6D CB 2A        	SRA D
 470+ 5E6F CB 1F            RR  A
 471+ 5E71 CB 2A            SRA D
 472+ 5E73 CB 1F            RR  A
 473+ 5E75 CB 2A            SRA D
 474+ 5E77 CB 1F            RR  A
 475+ 5E79 C9           	RET
 476+ 5E7A              ; *******************************************************************************************************
 477+ 5E7A               ENDIF
# file closed: asm\BLIT.asm
 148  5E7A               ENDIF
 149  5E7A
 150  5E7A               IF (TILE_CMDS == 1)
 151  5E7A               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5E7A              ; *******************************************************************************************************
   2+ 5E7A              ; generic function to implement tiling
   3+ 5E7A              ; should be modified to call appropriate function for memory or vram
   4+ 5E7A              ; input IX=pointer to following structure
   5+ 5E7A              ; +00 tile_data_ptr
   6+ 5E7A              ; +02 tile_rows
   7+ 5E7A              ; +04 tile_columns
   8+ 5E7A              ; +06 destination_address
   9+ 5E7A              ; +08 dest_to_next_row_add_to_value
  10+ 5E7A              ; +10 num_horizontal_tiles
  11+ 5E7A              ; +12 num_vertical_tiles
  12+ 5E7A              ; modifies AF, BC, DE, HL
  13+ 5E7A              TILE:
  14+ 5E7A DD 6E 06     	LD L, (IX+6)
  15+ 5E7D DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5E80 22 1A 62     	LD (TILETMP1), HL
  17+ 5E83 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5E86              .L1:
  19+ 5E86 C5           	PUSH BC
  20+ 5E87 DD 6E 00     		LD L, (IX+0)
  21+ 5E8A DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5E8D 22 1C 62     		LD (TILETMP2), HL
  23+ 5E90 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5E93              .L2:
  25+ 5E93 C5           		PUSH BC
  26+ 5E94 CD 00 00     .CALL1:		CALL 0
  27+ 5E97 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5E9A              .L3:
  29+ 5E9A C5           			PUSH BC
  30+ 5E9B 2A 1C 62     				LD HL, (TILETMP2)
  31+ 5E9E DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5EA1              .L4:
  33+ 5EA1 C5           				PUSH BC
  34+ 5EA2              .CALL2:
  35+ 5EA2 CD 00 00     					CALL 0
  36+ 5EA5 C1           				POP BC
  37+ 5EA6 10 F9        				DJNZ .L4
  38+ 5EA8 C1           			POP BC
  39+ 5EA9 10 EF        			DJNZ .L3
  40+ 5EAB 22 1C 62     			LD (TILETMP2), HL
  41+ 5EAE 2A 1A 62     			LD HL, (TILETMP1)
  42+ 5EB1 DD 5E 08     			LD E, (IX+8)
  43+ 5EB4 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5EB7 19           			ADD HL, DE
  45+ 5EB8 22 1A 62     			LD (TILETMP1), HL
  46+ 5EBB C1           		POP BC
  47+ 5EBC 10 D5        		DJNZ .L2
  48+ 5EBE C1           	POP BC
  49+ 5EBF 10 C5        	DJNZ .L1
  50+ 5EC1 C9           	RET
  51+ 5EC2              ; *******************************************************************************************************
  52+ 5EC2
  53+ 5EC2               IFNDEF CMDS_WITH_PARAMETERS
  54+ 5EC2 ~            ; *******************************************************************************************************
  55+ 5EC2 ~            ; function to handle CALL TILERAM basic extension
  56+ 5EC2 ~            ; fills memory with tiles
  57+ 5EC2 ~            ; TILERAM ( INT request_data_ptr )
  58+ 5EC2 ~            ; request_data_ptr described in TILE
  59+ 5EC2 ~            ; will put ram in page 0 also, page 1 is already there
  60+ 5EC2 ~            TILERAM:
  61+ 5EC2 ~            	; opening (
  62+ 5EC2 ~            	CALL CHKCHAR
  63+ 5EC2 ~            	DB '('
  64+ 5EC2 ~            	; get pointer to request struct
  65+ 5EC2 ~            	LD IX, FRMQNT
  66+ 5EC2 ~            	CALL CALBAS
  67+ 5EC2 ~            	PUSH DE
  68+ 5EC2 ~            	; ending )
  69+ 5EC2 ~            	CALL CHKCHAR
  70+ 5EC2 ~            	DB ')'
  71+ 5EC2 ~
  72+ 5EC2 ~            	POP IX ; pointer to request struct
  73+ 5EC2 ~
  74+ 5EC2 ~            	PUSH HL ; save position in BASIC buffer
  75+ 5EC2 ~            	DI
  76+ 5EC2 ~            	LD IY, .RET
  77+ 5EC2 ~            	JP ENABLE_PAGE0
  78+ 5EC2 ~            .RET:
  79+ 5EC2 ~            	EI
  80+ 5EC2 ~            	; set RAM functions to call
  81+ 5EC2 ~            	LD HL, .TILECOPY
  82+ 5EC2 ~            	LD (TILE.CALL2+1), HL
  83+ 5EC2 ~            	LD HL, .SETDESTROW
  84+ 5EC2 ~            	LD (TILE.CALL1+1), HL
  85+ 5EC2 ~            	LD A,1
  86+ 5EC2 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 5EC2 ~            	CALL TILE
  88+ 5EC2 ~            	XOR A
  89+ 5EC2 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 5EC2 ~
  91+ 5EC2 ~                POP DE
  92+ 5EC2 ~                POP BC
  93+ 5EC2 ~                CALL RESTORE_PAGE_INFO
  94+ 5EC2 ~
  95+ 5EC2 ~            	POP HL
  96+ 5EC2 ~            	RET
  97+ 5EC2 ~            .TILECOPY:
  98+ 5EC2 ~            	.8 LDI
  99+ 5EC2 ~            	RET
 100+ 5EC2 ~            .SETDESTROW:
 101+ 5EC2 ~            	LD DE, (TILETMP1)
 102+ 5EC2 ~            	RET
 103+ 5EC2 ~            ; *******************************************************************************************************
 104+ 5EC2               ENDIF
 105+ 5EC2
 106+ 5EC2               IFDEF CMDS_WITH_PARAMETERS
 107+ 5EC2              ; *******************************************************************************************************
 108+ 5EC2              ; function to handle CALL TILERAM basic extension
 109+ 5EC2              ; fills memory with tiles
 110+ 5EC2              ; TILERAM ( INT tile_data_pointer,
 111+ 5EC2              ;			INT tile_columns,
 112+ 5EC2              ;			INT tile_rows,
 113+ 5EC2              ;			INT destination_pointer,
 114+ 5EC2              ;			INT destination_columns,
 115+ 5EC2              ;			INT destination_rows,
 116+ 5EC2              ;			INT destination_begin_column,
 117+ 5EC2              ;			INT destination_begin_row,
 118+ 5EC2              ;			INT number_of_tiles_horizontally,
 119+ 5EC2              ;			INT	number_of_tiles_vertically )
 120+ 5EC2              ; will put ram in page 0 also, page 1 is already there
 121+ 5EC2              TILERAM:
 122+ 5EC2              	; opening (
 123+ 5EC2 CD 23 65     	CALL CHKCHAR
 124+ 5EC5 28           	DB '('
 125+ 5EC6              	; get tile data pointer coordinate
 126+ 5EC6 DD 21 2F 54  	LD IX, FRMQNT
 127+ 5ECA CD 59 01     	CALL CALBAS
 128+ 5ECD ED 53 1E 62  	LD (BLIT_STRUCT+0), DE
 129+ 5ED1              	; comma
 130+ 5ED1 CD 23 65     	CALL CHKCHAR
 131+ 5ED4 2C           	DB ','
 132+ 5ED5              	; get tile columns
 133+ 5ED5 DD 21 2F 54  	LD IX, FRMQNT
 134+ 5ED9 CD 59 01     	CALL CALBAS
 135+ 5EDC ED 53 22 62  	LD (BLIT_STRUCT+4), DE
 136+ 5EE0              	; comma
 137+ 5EE0 CD 23 65     	CALL CHKCHAR
 138+ 5EE3 2C           	DB ','
 139+ 5EE4              	; get tile columns
 140+ 5EE4 DD 21 2F 54  	LD IX, FRMQNT
 141+ 5EE8 CD 59 01     	CALL CALBAS
 142+ 5EEB ED 53 20 62  	LD (BLIT_STRUCT+2), DE
 143+ 5EEF              	; comma
 144+ 5EEF CD 23 65     	CALL CHKCHAR
 145+ 5EF2 2C           	DB ','
 146+ 5EF3              	; get destintion pointer
 147+ 5EF3 DD 21 2F 54  	LD IX, FRMQNT
 148+ 5EF7 CD 59 01     	CALL CALBAS
 149+ 5EFA ED 53 24 62  	LD (BLIT_STRUCT+6), DE
 150+ 5EFE              	; comma
 151+ 5EFE CD 23 65     	CALL CHKCHAR
 152+ 5F01 2C           	DB ','
 153+ 5F02              	; get destination columns
 154+ 5F02 DD 21 2F 54  	LD IX, FRMQNT
 155+ 5F06 CD 59 01     	CALL CALBAS
 156+ 5F09 7B           	LD A, E
 157+ 5F0A 32 1A 62     	LD (BLIT_TMP+0), A
 158+ 5F0D              	; comma
 159+ 5F0D CD 23 65     	CALL CHKCHAR
 160+ 5F10 2C           	DB ','
 161+ 5F11              	; get destination rows
 162+ 5F11 DD 21 2F 54  	LD IX, FRMQNT
 163+ 5F15 CD 59 01     	CALL CALBAS
 164+ 5F18 7B           	LD A, E
 165+ 5F19 32 1B 62     	LD (BLIT_TMP+1), A
 166+ 5F1C              	; comma
 167+ 5F1C CD 23 65     	CALL CHKCHAR
 168+ 5F1F 2C           	DB ','
 169+ 5F20              	; get destination begin column
 170+ 5F20 DD 21 2F 54  	LD IX, FRMQNT
 171+ 5F24 CD 59 01     	CALL CALBAS
 172+ 5F27 7B           	LD A, E
 173+ 5F28 32 1C 62     	LD (BLIT_TMP+2), A
 174+ 5F2B              	; comma
 175+ 5F2B CD 23 65     	CALL CHKCHAR
 176+ 5F2E 2C           	DB ','
 177+ 5F2F              	; get destination begin row
 178+ 5F2F DD 21 2F 54  	LD IX, FRMQNT
 179+ 5F33 CD 59 01     	CALL CALBAS
 180+ 5F36 7B           	LD A, E
 181+ 5F37 32 1D 62     	LD (BLIT_TMP+3), A
 182+ 5F3A              	; comma
 183+ 5F3A CD 23 65     	CALL CHKCHAR
 184+ 5F3D 2C           	DB ','
 185+ 5F3E              	; get number of tiles horizontally
 186+ 5F3E DD 21 2F 54  	LD IX, FRMQNT
 187+ 5F42 CD 59 01     	CALL CALBAS
 188+ 5F45 ED 53 28 62  	LD (BLIT_STRUCT+10), DE
 189+ 5F49              	; comma
 190+ 5F49 CD 23 65     	CALL CHKCHAR
 191+ 5F4C 2C           	DB ','
 192+ 5F4D              	; get number of tiles vertically
 193+ 5F4D DD 21 2F 54  	LD IX, FRMQNT
 194+ 5F51 CD 59 01     	CALL CALBAS
 195+ 5F54 ED 53 2A 62  	LD (BLIT_STRUCT+12), DE
 196+ 5F58              	; ending )
 197+ 5F58 CD 23 65     	CALL CHKCHAR
 198+ 5F5B 29           	DB ')'
 199+ 5F5C
 200+ 5F5C E5           	PUSH HL ; save position in BASIC buffer
 201+ 5F5D
 202+ 5F5D              	; calculate destination add to value
 203+ 5F5D 26 00        	LD H, 0
 204+ 5F5F 3A 1A 62     	LD A, (BLIT_TMP+0)
 205+ 5F62 6F           	LD L, A
 206+ 5F63 CD 11 64     	CALL HLx8
 207+ 5F66 22 26 62     	LD (BLIT_STRUCT+8), HL
 208+ 5F69              	; calculate pointer to background location
 209+ 5F69 21 00 00     	LD HL, 0
 210+ 5F6C 3A 1D 62     	LD A,(BLIT_TMP+3)
 211+ 5F6F B7           	OR A
 212+ 5F70 28 08        	JR Z, .L1
 213+ 5F72 47           	LD B,A
 214+ 5F73 ED 5B 26 62  	LD DE,(BLIT_STRUCT+8)
 215+ 5F77              .L0:
 216+ 5F77 19           	ADD HL, DE
 217+ 5F78 10 FD        	DJNZ .L0
 218+ 5F7A              .L1:
 219+ 5F7A EB           	EX DE,HL
 220+ 5F7B 26 00        	LD H,0
 221+ 5F7D 3A 1C 62     	LD A,(BLIT_TMP+2)
 222+ 5F80 6F           	LD L,A
 223+ 5F81 CD 11 64     	CALL HLx8
 224+ 5F84 19           	ADD HL,DE
 225+ 5F85 ED 5B 24 62  	LD DE,(BLIT_STRUCT+6)
 226+ 5F89 19           	ADD HL,DE
 227+ 5F8A 22 24 62     	LD (BLIT_STRUCT+6),HL
 228+ 5F8D F3           	DI
 229+ 5F8E FD 21 95 5F  	LD IY, .RET
 230+ 5F92 C3 D5 64     	JP ENABLE_PAGE0
 231+ 5F95              .RET:
 232+ 5F95 FB           	EI
 233+ 5F96              	; set RAM functions to call
 234+ 5F96 21 B0 5F     	LD HL, .TILECOPY
 235+ 5F99 22 A3 5E     	LD (TILE.CALL2+1), HL
 236+ 5F9C 21 C1 5F     	LD HL, .SETDESTROW
 237+ 5F9F 22 95 5E     	LD (TILE.CALL1+1), HL
 238+ 5FA2 DD 21 1E 62  	LD IX,BLIT_STRUCT
 239+ 5FA6 CD 7A 5E     	CALL TILE
 240+ 5FA9
 241+ 5FA9 D1               POP DE
 242+ 5FAA C1               POP BC
 243+ 5FAB CD 4C 64         CALL RESTORE_PAGE_INFO
 244+ 5FAE
 245+ 5FAE E1           	POP HL
 246+ 5FAF C9           	RET
 247+ 5FB0              .TILECOPY:
 248+ 5FB0 ED A0       > LDI
 248+ 5FB2 ED A0       > LDI
 248+ 5FB4 ED A0       > LDI
 248+ 5FB6 ED A0       > LDI
 248+ 5FB8 ED A0       > LDI
 248+ 5FBA ED A0       > LDI
 248+ 5FBC ED A0       > LDI
 248+ 5FBE ED A0       > LDI
 249+ 5FC0 C9           	RET
 250+ 5FC1              .SETDESTROW:
 251+ 5FC1 ED 5B 1A 62  	LD DE, (TILETMP1)
 252+ 5FC5 C9           	RET
 253+ 5FC6              ; *******************************************************************************************************
 254+ 5FC6               ENDIF
 255+ 5FC6
 256+ 5FC6               IFDEF CMDS_WITH_PARAMETERS
 257+ 5FC6              ; *******************************************************************************************************
 258+ 5FC6              ; function to handle CALL TILEVRM basic extension
 259+ 5FC6              ; fills vram with tiles
 260+ 5FC6              ; TILEVRM ( INT tile_data_pointer,
 261+ 5FC6              ;			INT tile_columns,
 262+ 5FC6              ;			INT tile_rows,
 263+ 5FC6              ;			INT destination_begin_column,
 264+ 5FC6              ;			INT destination_begin_row,
 265+ 5FC6              ;			INT number_of_tiles_horizontally,
 266+ 5FC6              ;			INT	number_of_tiles_vertically )
 267+ 5FC6              ; will put ram in page 0 also, page 1 is already there
 268+ 5FC6              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 5FC6              TILEVRM:
 270+ 5FC6              	; opening (
 271+ 5FC6 CD 23 65     	CALL CHKCHAR
 272+ 5FC9 28           	DB '('
 273+ 5FCA              	; get tile data pointer coordinate
 274+ 5FCA DD 21 2F 54  	LD IX, FRMQNT
 275+ 5FCE CD 59 01     	CALL CALBAS
 276+ 5FD1 ED 53 1E 62  	LD (BLIT_STRUCT+0), DE
 277+ 5FD5              	; comma
 278+ 5FD5 CD 23 65     	CALL CHKCHAR
 279+ 5FD8 2C           	DB ','
 280+ 5FD9              	; get tile columns
 281+ 5FD9 DD 21 2F 54  	LD IX, FRMQNT
 282+ 5FDD CD 59 01     	CALL CALBAS
 283+ 5FE0 ED 53 22 62  	LD (BLIT_STRUCT+4), DE
 284+ 5FE4              	; comma
 285+ 5FE4 CD 23 65     	CALL CHKCHAR
 286+ 5FE7 2C           	DB ','
 287+ 5FE8              	; get tile columns
 288+ 5FE8 DD 21 2F 54  	LD IX, FRMQNT
 289+ 5FEC CD 59 01     	CALL CALBAS
 290+ 5FEF ED 53 20 62  	LD (BLIT_STRUCT+2), DE
 291+ 5FF3              	; comma
 292+ 5FF3 CD 23 65     	CALL CHKCHAR
 293+ 5FF6 2C           	DB ','
 294+ 5FF7              	; get destination begin column
 295+ 5FF7 DD 21 2F 54  	LD IX, FRMQNT
 296+ 5FFB CD 59 01     	CALL CALBAS
 297+ 5FFE 7B           	LD A, E
 298+ 5FFF 32 1C 62     	LD (BLIT_TMP+2), A
 299+ 6002              	; comma
 300+ 6002 CD 23 65     	CALL CHKCHAR
 301+ 6005 2C           	DB ','
 302+ 6006              	; get destination begin row
 303+ 6006 DD 21 2F 54  	LD IX, FRMQNT
 304+ 600A CD 59 01     	CALL CALBAS
 305+ 600D 7B           	LD A, E
 306+ 600E 32 1D 62     	LD (BLIT_TMP+3), A
 307+ 6011              	; comma
 308+ 6011 CD 23 65     	CALL CHKCHAR
 309+ 6014 2C           	DB ','
 310+ 6015              	; get number of tiles horizontally
 311+ 6015 DD 21 2F 54  	LD IX, FRMQNT
 312+ 6019 CD 59 01     	CALL CALBAS
 313+ 601C ED 53 28 62  	LD (BLIT_STRUCT+10), DE
 314+ 6020              	; comma
 315+ 6020 CD 23 65     	CALL CHKCHAR
 316+ 6023 2C           	DB ','
 317+ 6024              	; get number of tiles vertically
 318+ 6024 DD 21 2F 54  	LD IX, FRMQNT
 319+ 6028 CD 59 01     	CALL CALBAS
 320+ 602B ED 53 2A 62  	LD (BLIT_STRUCT+12), DE
 321+ 602F              	; ending )
 322+ 602F CD 23 65     	CALL CHKCHAR
 323+ 6032 29           	DB ')'
 324+ 6033
 325+ 6033 E5           	PUSH HL ; save position in BASIC buffer
 326+ 6034
 327+ 6034              	; calculate destination add to value
 328+ 6034 21 00 01     	LD HL, 256
 329+ 6037 22 26 62     	LD (BLIT_STRUCT+8), HL
 330+ 603A              	; calculate pointer to background location
 331+ 603A 3A 1D 62     	LD A,(BLIT_TMP+3)
 332+ 603D 67           	LD H,A
 333+ 603E 2E 00        	LD L,0
 334+ 6040 EB           	EX DE,HL
 335+ 6041 26 00        	LD H,0
 336+ 6043 3A 1C 62     	LD A,(BLIT_TMP+2)
 337+ 6046 6F           	LD L,A
 338+ 6047 CD 11 64     	CALL HLx8
 339+ 604A 19           	ADD HL,DE
 340+ 604B ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 604F 19           	ADD HL,DE
 342+ 6050 22 24 62     	LD (BLIT_STRUCT+6),HL
 343+ 6053 F3           	DI
 344+ 6054 FD 21 5B 60  	LD IY, .RET
 345+ 6058 C3 D5 64     	JP ENABLE_PAGE0
 346+ 605B              .RET:
 347+ 605B FB           	EI
 348+ 605C              	; set RAM functions to call
 349+ 605C 21 76 60     	LD HL, .TILECOPY
 350+ 605F 22 A3 5E     	LD (TILE.CALL2+1), HL
 351+ 6062 21 7C 60     	LD HL, .SETDESTROW
 352+ 6065 22 95 5E     	LD (TILE.CALL1+1), HL
 353+ 6068 DD 21 1E 62  	LD IX,BLIT_STRUCT
 354+ 606C CD 7A 5E     	CALL TILE
 355+ 606F
 356+ 606F D1               POP DE
 357+ 6070 C1               POP BC
 358+ 6071 CD 4C 64         CALL RESTORE_PAGE_INFO
 359+ 6074
 360+ 6074 E1           	POP HL
 361+ 6075 C9           	RET
 362+ 6076              .TILECOPY:
 363+ 6076 01 98 08     	LD BC, #0898
 364+ 6079 C3 09 64     	JP BBYTECOPY_NO_C
 365+ 607C              .SETDESTROW:
 366+ 607C 2A 1A 62     	LD HL, (TILETMP1)
 367+ 607F F3           	DI
 368+ 6080 CD FC 63     	CALL SETWRT_LOCAL
 369+ 6083 FB           	EI
 370+ 6084 C9           	RET
 371+ 6085              ; *******************************************************************************************************
 372+ 6085               ENDIF
 373+ 6085
 374+ 6085               IFNDEF CMDS_WITH_PARAMETERS
 375+ 6085 ~            ; *******************************************************************************************************
 376+ 6085 ~            ; function to handle CALL TILEVRM basic extension
 377+ 6085 ~            ; fills vram with tiles
 378+ 6085 ~            ; TILEVRM ( INT request_data_ptr )
 379+ 6085 ~            ; request_data_ptr described in TILE
 380+ 6085 ~            ; will put ram in page 0 also, page 1 is already there
 381+ 6085 ~            TILEVRM:
 382+ 6085 ~            	; opening (
 383+ 6085 ~            	CALL CHKCHAR
 384+ 6085 ~            	DB '('
 385+ 6085 ~            	; get pointer to request struct
 386+ 6085 ~            	LD IX, FRMQNT
 387+ 6085 ~            	CALL CALBAS
 388+ 6085 ~            	PUSH DE
 389+ 6085 ~            	; ending )
 390+ 6085 ~            	CALL CHKCHAR
 391+ 6085 ~            	DB ')'
 392+ 6085 ~
 393+ 6085 ~            	POP IX ; pointer to request struct
 394+ 6085 ~
 395+ 6085 ~            	PUSH HL ; save position in BASIC buffer
 396+ 6085 ~            	DI
 397+ 6085 ~            	LD IY, .RET
 398+ 6085 ~            	JP ENABLE_PAGE0
 399+ 6085 ~            .RET:
 400+ 6085 ~            	EI
 401+ 6085 ~            	; set RAM functions to call
 402+ 6085 ~            	LD HL, .TILECOPY
 403+ 6085 ~            	LD (TILE.CALL2+1), HL
 404+ 6085 ~            	LD HL, .SETDESTROW
 405+ 6085 ~            	LD (TILE.CALL1+1), HL
 406+ 6085 ~            	CALL TILE
 407+ 6085 ~
 408+ 6085 ~                POP DE
 409+ 6085 ~                POP BC
 410+ 6085 ~                CALL RESTORE_PAGE_INFO
 411+ 6085 ~
 412+ 6085 ~            	POP HL
 413+ 6085 ~            	RET
 414+ 6085 ~            .TILECOPY:
 415+ 6085 ~            	LD BC, #0898
 416+ 6085 ~            	JP BBYTECOPY_NO_C
 417+ 6085 ~            .SETDESTROW:
 418+ 6085 ~            	LD HL, (TILETMP1)
 419+ 6085 ~            	DI
 420+ 6085 ~            	CALL SETWRT_LOCAL
 421+ 6085 ~            	EI
 422+ 6085 ~            	RET
 423+ 6085 ~            ; *******************************************************************************************************
 424+ 6085               ENDIF
# file closed: asm\TILE.asm
 152  6085               ENDIF
 153  6085
 154  6085               IF (COLL_CMD == 1)
 155  6085               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 6085              ; generic collision checking routines
   2+ 6085              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 6085              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 6085              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 6085              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 6085              ; R%(3,n) x offset where rectangle begins
   7+ 6085              ; R%(4,n) y offset where rectangle begins
   8+ 6085              ; R%(5,n) is width
   9+ 6085              ; R%(6,n) is height
  10+ 6085              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 6085              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 6085              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 6085
  14+ 6085              ; ************************************************************************************************
  15+ 6085              ; quick test if HL<=DE<=HL+BC
  16+ 6085              ; input BC=width, DE=x, HL=min
  17+ 6085              ; if not true flag C set
  18+ 6085              ; modifies AF
  19+ 6085              GENERIC_INNER_CHECK:
  20+ 6085 E5               PUSH HL
  21+ 6086 D5               PUSH DE
  22+ 6087 EB               EX DE,HL
  23+ 6088 A7               AND A
  24+ 6089 ED 52            SBC HL, DE
  25+ 608B FA 99 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 608E A7               AND A
  27+ 608F ED 42            SBC HL, BC
  28+ 6091 28 03            JR Z, .L2
  29+ 6093 F2 99 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 6096              .L2:
  31+ 6096 A7               AND A
  32+ 6097 18 01            JR .EXIT
  33+ 6099              .GENERIC_INNER_CHECK_NOT:
  34+ 6099 37               SCF
  35+ 609A              .EXIT:
  36+ 609A D1               POP DE
  37+ 609B E1               POP HL
  38+ 609C C9               RET
  39+ 609D              ; ************************************************************************************************
  40+ 609D
  41+ 609D              ; ************************************************************************************************
  42+ 609D              ; function to check if rectangles are overlapping
  43+ 609D              ; input IX=IY=pointer to struct
  44+ 609D              ;  +00 active flag
  45+ 609D              ;  +02 x coordinate
  46+ 609D              ;  +04 y coordinate
  47+ 609D              ;  +06 x offset where rectangle begins
  48+ 609D              ;  +08 y offset where rectangle begins
  49+ 609D              ;  +10 width
  50+ 609D              ;  +12 height
  51+ 609D              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 609D              ; this is a hack to allow location being taken from sprite attributes table
  53+ 609D              ; input BLIT_STRUCT data
  54+ 609D              ;  +00 x coordinate
  55+ 609D              ;  +02 y coordinate
  56+ 609D              ;  +04 width
  57+ 609D              ;  +06 height
  58+ 609D              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 609D              RECTANGLE_OVERLAP_CHECK:
  60+ 609D                  ; first check which rectangle is higher
  61+ 609D DD 6E 0C         LD L,(IX+12)
  62+ 60A0 DD 66 0D         LD H,(IX+13)
  63+ 60A3 ED 5B 24 62      LD DE,(BLIT_STRUCT+6)
  64+ 60A7 A7               AND A
  65+ 60A8 ED 52            SBC HL,DE
  66+ 60AA FD 6E 04         LD L,(IY+4)
  67+ 60AD FD 66 05         LD H,(IY+5)
  68+ 60B0 DD 5E 08         LD E,(IX+8)
  69+ 60B3 DD 56 09         LD D,(IX+9)
  70+ 60B6 FA D6 60         JP M,.L1
  71+ 60B9                  ; equally high or IX defined one higher
  72+ 60B9                  ; check upper boundary
  73+ 60B9 19               ADD HL,DE
  74+ 60BA ED 5B 20 62      LD DE,(BLIT_STRUCT+2)
  75+ 60BE DD 4E 0C         LD C,(IX+12)
  76+ 60C1 DD 46 0D         LD B,(IX+13)
  77+ 60C4 CD 85 60         CALL GENERIC_INNER_CHECK
  78+ 60C7 30 29            JR NC,.INSIDE
  79+ 60C9                  ; check lower boundary
  80+ 60C9 E5               PUSH HL
  81+ 60CA 2A 24 62         LD HL,(BLIT_STRUCT+6)
  82+ 60CD 19               ADD HL,DE
  83+ 60CE EB               EX DE,HL
  84+ 60CF E1               POP HL
  85+ 60D0 CD 85 60         CALL GENERIC_INNER_CHECK
  86+ 60D3 30 1D            JR NC,.INSIDE
  87+ 60D5 C9               RET ; not overlapping
  88+ 60D6              .L1:
  89+ 60D6                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 60D6 19               ADD HL,DE
  91+ 60D7 EB               EX DE,HL
  92+ 60D8 2A 20 62         LD HL,(BLIT_STRUCT+2)
  93+ 60DB ED 4B 24 62      LD BC,(BLIT_STRUCT+6)
  94+ 60DF CD 85 60         CALL GENERIC_INNER_CHECK
  95+ 60E2 30 0E            JR NC,.INSIDE
  96+ 60E4 E5               PUSH HL
  97+ 60E5 DD 6E 0C         LD L,(IX+12)
  98+ 60E8 DD 66 0D         LD H,(IX+13)
  99+ 60EB 19               ADD HL,DE
 100+ 60EC EB               EX DE,HL
 101+ 60ED E1               POP HL
 102+ 60EE CD 85 60         CALL GENERIC_INNER_CHECK
 103+ 60F1 D8               RET C
 104+ 60F2              .INSIDE:
 105+ 60F2                  ; check x coordinate
 106+ 60F2                  ; first check which rectangle is wider
 107+ 60F2 DD 6E 0A         LD L,(IX+10)
 108+ 60F5 DD 66 0B         LD H,(IX+11)
 109+ 60F8 ED 5B 22 62      LD DE,(BLIT_STRUCT+4)
 110+ 60FC A7               AND A
 111+ 60FD ED 52            SBC HL,DE
 112+ 60FF FD 6E 02         LD L,(IY+2)
 113+ 6102 FD 66 03         LD H,(IY+3)
 114+ 6105 DD 5E 06         LD E,(IX+6)
 115+ 6108 DD 56 07         LD D,(IX+7)
 116+ 610B FA 27 61         JP M,.L2
 117+ 610E                  ; equally wide or IX defined one wider
 118+ 610E                  ; check left boundary
 119+ 610E 19               ADD HL,DE
 120+ 610F ED 5B 1E 62      LD DE,(BLIT_STRUCT+0)
 121+ 6113 DD 4E 0A         LD C,(IX+10)
 122+ 6116 DD 46 0B         LD B,(IX+11)
 123+ 6119 CD 85 60         CALL GENERIC_INNER_CHECK
 124+ 611C D0               RET NC ; overlap
 125+ 611D                  ; check right boundary
 126+ 611D E5               PUSH HL
 127+ 611E 2A 22 62         LD HL,(BLIT_STRUCT+4)
 128+ 6121 19               ADD HL,DE
 129+ 6122 EB               EX DE,HL
 130+ 6123 E1               POP HL
 131+ 6124 C3 85 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 6127              .L2:
 133+ 6127                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 6127 19               ADD HL,DE
 135+ 6128 EB               EX DE,HL
 136+ 6129 2A 1E 62         LD HL,(BLIT_STRUCT+0)
 137+ 612C ED 4B 22 62      LD BC,(BLIT_STRUCT+4)
 138+ 6130 CD 85 60         CALL GENERIC_INNER_CHECK
 139+ 6133 D0               RET NC ; overlap
 140+ 6134 E5               PUSH HL
 141+ 6135 DD 6E 0A         LD L,(IX+10)
 142+ 6138 DD 66 0B         LD H,(IX+11)
 143+ 613B 19               ADD HL,DE
 144+ 613C EB               EX DE,HL
 145+ 613D E1               POP HL
 146+ 613E C3 85 60         JP GENERIC_INNER_CHECK
 147+ 6141              ; ************************************************************************************************
 148+ 6141
 149+ 6141              ; ************************************************************************************************
 150+ 6141              ; function tries to find rectangle overlap and returns an index if found
 151+ 6141              ; input BLIT_STRUCT data
 152+ 6141              ;  +00 x coordinate
 153+ 6141              ;  +02 y coordinate
 154+ 6141              ;  +04 width
 155+ 6141              ;  +06 height
 156+ 6141              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 6141              ;  +09 pointer to first element of R%(7,n)
 158+ 6141              ;  +11 pointer to INT result variable
 159+ 6141              ; returns CF=1 if not overlapping
 160+ 6141              ; returns A=list index and CF=0 if overlapping
 161+ 6141              FIND_OVERLAP:
 162+ 6141 3A 26 62         LD A,(BLIT_STRUCT+8)
 163+ 6144 47               LD B,A
 164+ 6145 DD 2A 27 62      LD IX,(BLIT_STRUCT+9)
 165+ 6149              .L1:
 166+ 6149 C5               PUSH BC
 167+ 614A                  ; check active flag
 168+ 614A DD 7E 00         LD A,(IX)
 169+ 614D DD B6 01         OR (IX+1)
 170+ 6150 28 18            JR Z,.NEXT
 171+ 6152                  ; check type
 172+ 6152 DD 7E 0E         LD A,(IX+14)
 173+ 6155 DD B6 0F         OR (IX+15)
 174+ 6158 20 1A            JR NZ,.L2
 175+ 615A DD E5            PUSH IX
 176+ 615C FD E1            POP IY
 177+ 615E              .L3:
 178+ 615E CD 9D 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 6161 38 07            JR C,.NEXT
 180+ 6163                  ; found
 181+ 6163 C1               POP BC
 182+ 6164 3A 26 62         LD A,(BLIT_STRUCT+8)
 183+ 6167 90               SUB B
 184+ 6168 A7               AND A
 185+ 6169 C9               RET
 186+ 616A              .NEXT:
 187+ 616A 11 10 00         LD DE,16
 188+ 616D DD 19            ADD IX,DE
 189+ 616F C1               POP BC
 190+ 6170 10 D7            DJNZ .L1
 191+ 6172 37               SCF
 192+ 6173 C9               RET
 193+ 6174              .L2:
 194+ 6174                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 6174                  ; at BLIT_STRUCT+13
 196+ 6174 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 6177 CD 85 4D         CALL GETnthSPRATTR
 198+ 617A FD 21 29 62      LD IY,BLIT_STRUCT+11
 199+ 617E 7E               LD A,(HL)
 200+ 617F FD 77 04         LD (IY+4),A
 201+ 6182 23               INC HL
 202+ 6183 7E               LD A,(HL)
 203+ 6184 FD 77 05         LD (IY+5),A
 204+ 6187 23               INC HL
 205+ 6188 7E               LD A,(HL)
 206+ 6189 FD 77 02         LD (IY+2),A
 207+ 618C 23               INC HL
 208+ 618D 7E               LD A,(HL)
 209+ 618E FD 77 03         LD (IY+3),A
 210+ 6191 18 CB            JR .L3
 211+ 6193              ; ************************************************************************************************
 212+ 6193
 213+ 6193              ; ************************************************************************************************
 214+ 6193              ; function to handle CALL COLL basic extension
 215+ 6193              ; checks for collision between player and other rectangles
 216+ 6193              ; COLL ( INT result variable,
 217+ 6193              ;	     INT player x value,
 218+ 6193              ;	     INT player y value,
 219+ 6193              ;	     INT player width,
 220+ 6193              ;	     INT player height,
 221+ 6193              ;	     INT number of items in a list,
 222+ 6193              ;		 INT[6][n] rectangle struct )
 223+ 6193              ; will fill result variable with index or -1 if no collision
 224+ 6193              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 225+ 6193              COLL:
 226+ 6193              	; opening (
 227+ 6193 CD 23 65     	CALL CHKCHAR
 228+ 6196 28           	DB '('
 229+ 6197              	; get address of result variable
 230+ 6197 DD 21 A4 5E  	LD IX, PTRGET
 231+ 619B CD 59 01     	CALL CALBAS
 232+ 619E ED 53 29 62  	LD (BLIT_STRUCT+11),DE
 233+ 61A2              	; comma
 234+ 61A2 CD 23 65     	CALL CHKCHAR
 235+ 61A5 2C           	DB ','
 236+ 61A6              	; get x
 237+ 61A6 DD 21 2F 54  	LD IX, FRMQNT
 238+ 61AA CD 59 01     	CALL CALBAS
 239+ 61AD ED 53 1E 62  	LD (BLIT_STRUCT+0),DE
 240+ 61B1              	; comma
 241+ 61B1 CD 23 65     	CALL CHKCHAR
 242+ 61B4 2C           	DB ','
 243+ 61B5              	; get y
 244+ 61B5 DD 21 2F 54  	LD IX, FRMQNT
 245+ 61B9 CD 59 01     	CALL CALBAS
 246+ 61BC ED 53 20 62  	LD (BLIT_STRUCT+2),DE
 247+ 61C0              	; comma
 248+ 61C0 CD 23 65     	CALL CHKCHAR
 249+ 61C3 2C           	DB ','
 250+ 61C4              	; get width
 251+ 61C4 DD 21 2F 54  	LD IX, FRMQNT
 252+ 61C8 CD 59 01     	CALL CALBAS
 253+ 61CB ED 53 22 62  	LD (BLIT_STRUCT+4),DE
 254+ 61CF              	; comma
 255+ 61CF CD 23 65     	CALL CHKCHAR
 256+ 61D2 2C           	DB ','
 257+ 61D3              	; get height
 258+ 61D3 DD 21 2F 54  	LD IX, FRMQNT
 259+ 61D7 CD 59 01     	CALL CALBAS
 260+ 61DA ED 53 24 62  	LD (BLIT_STRUCT+6),DE
 261+ 61DE              	; comma
 262+ 61DE CD 23 65     	CALL CHKCHAR
 263+ 61E1 2C           	DB ','
 264+ 61E2              	; get number of items in a list
 265+ 61E2 DD 21 1C 52  	LD IX, GETBYT
 266+ 61E6 CD 59 01     	CALL CALBAS
 267+ 61E9 32 26 62     	LD (BLIT_STRUCT+8),A
 268+ 61EC              	; comma
 269+ 61EC CD 23 65     	CALL CHKCHAR
 270+ 61EF 2C           	DB ','
 271+ 61F0              	; get address of rectangle structure array DIM R%(7,n)
 272+ 61F0 3A 26 62     	LD A,(BLIT_STRUCT+8)
 273+ 61F3 5F               LD E,A
 274+ 61F4 3E 02            LD A,2
 275+ 61F6 47           	LD B,A
 276+ 61F7 16 07        	LD D,7
 277+ 61F9 CD 50 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 278+ 61FC ED 43 27 62  	LD (BLIT_STRUCT+9),BC
 279+ 6200              	; ending )
 280+ 6200 CD 23 65     	CALL CHKCHAR
 281+ 6203 29           	DB ')'
 282+ 6204
 283+ 6204 E5               PUSH HL
 284+ 6205 CD 41 61         CALL FIND_OVERLAP
 285+ 6208 2A 29 62         LD HL,(BLIT_STRUCT+11)
 286+ 620B 38 06            JR C,.NOTFOUND
 287+ 620D 77               LD (HL),A
 288+ 620E 23               INC HL
 289+ 620F 36 00            LD (HL),0
 290+ 6211 E1               POP HL
 291+ 6212 C9               RET
 292+ 6213              .NOTFOUND:
 293+ 6213 36 FF            LD (HL),#FF
 294+ 6215 23               INC HL
 295+ 6216 36 FF            LD (HL),#FF
 296+ 6218 E1               POP HL
 297+ 6219 C9               RET
 298+ 621A              ; ************************************************************************************************
 299+ 621A
# file closed: asm\COLLISION.asm
 156  621A               ENDIF
 157  621A
 158  621A              ; temp variables for BLIT, TILE functions
 159  621A               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 160  621A              BLIT_TMP:
 161  621A              TILETMP1:
 162  621A              BLIT_TMP1:
 163  621A 00 00         DW 0
 164  621C              TILETMP2:
 165  621C              BLIT_TMP2:
 166  621C 00 00         DW 0
 167  621E                IFDEF CMDS_WITH_PARAMETERS
 168  621E              BLIT_STRUCT:
 169  621E 00 00 00...   DS 17
 170  6222                ENDIF
 171  6222               ENDIF
 172  622F
 173  622F               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 174  622F              VRAM_UPDATE_IN_PROGRESS:
 175  622F 00            DB 0
 176  6230               ENDIF
 177  6230
 178  6230              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 179  6230              ; per starting letter, if no commands with this letter, NULL value
 180  6230              CMDS:
 181  6230               IF (ANIM_CMDS == 1)
 182  6230 66 63        	DW CMDS_A ;
 183  6232               ELSE
 184  6232 ~                DW 0 ; A
 185  6232               ENDIF
 186  6232               IF (BLIT_CMDS + BOX_CMDS > 0)
 187  6232 31 63            DW CMDS_B ; B
 188  6234               ELSE
 189  6234 ~            	DW 0
 190  6234               ENDIF
 191  6234               IF (COLL_CMD == 1)
 192  6234 F4 63        	DW CMDS_C ;
 193  6236               ELSE
 194  6236 ~                DW 0 ; C
 195  6236               ENDIF
 196  6236 00 00            DW 0 ; D
 197  6238 00 00            DW 0 ; E
 198  623A               IF (VRAM_CMDS + RAM_CMDS > 0)
 199  623A B1 62            DW CMDS_F; F
 200  623C               ELSE
 201  623C ~            	DW 0
 202  623C               ENDIF
 203  623C               IF (GENCAL_CMD > 0)
 204  623C C4 62            DW CMDS_G; G
 205  623E               ELSE
 206  623E ~            	DW 0
 207  623E               ENDIF
 208  623E 00 00            DW 0 ; H
 209  6240 00 00            DW 0 ; I
 210  6242 00 00            DW 0 ; J
 211  6244 00 00            DW 0 ; K
 212  6246 00 00            DW 0 ; L
 213  6248               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 214  6248 64 62            DW CMDS_M ; M
 215  624A               ELSE
 216  624A ~            	DW 0
 217  624A               ENDIF
 218  624A 00 00            DW 0 ; N
 219  624C 00 00            DW 0 ; O
 220  624E 00 00            DW 0 ; P
 221  6250 00 00            DW 0 ; Q
 222  6252 00 00            DW 0 ; R
 223  6254               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 224  6254 D8 62            DW CMDS_S ; S
 225  6256               ELSE
 226  6256 ~            	DW 0
 227  6256               ENDIF
 228  6256               IF (TILE_CMDS > 0)
 229  6256 51 63            DW CMDS_T ; T
 230  6258               ELSE
 231  6258 ~            	DW 0
 232  6258               ENDIF
 233  6258 00 00            DW 0 ; U
 234  625A               IF (VRAM_CMDS > 0)
 235  625A CE 62            DW CMDS_V ; V
 236  625C               ELSE
 237  625C ~            	DW 0
 238  625C               ENDIF
 239  625C 00 00            DW 0 ; W
 240  625E 00 00            DW 0 ; X
 241  6260 00 00            DW 0 ; Y
 242  6262 00 00            DW 0 ; Z
 243  6264
 244  6264              CMDS_M:
 245  6264               IF (VRAM_CMDS == 1)
 246  6264 4D 45 4D 56      DB "MEMVRM", 0
 246  6268 52 4D 00
 247  626B D9 59            DW MEMVRM
 248  626D               ENDIF
 249  626D               IF (RAM_CMDS == 1)
 250  626D 4D 45 4D 43  	DB "MEMCPY", 0
 250  6271 50 59 00
 251  6274 0E 58        	DW MEMCPY
 252  6276               ENDIF
 253  6276               IF (ANIM_CMDS == 1)
 254  6276 4D 41 58 41  	DB "MAXANIMITEMS",0
 254  627A 4E 49 4D 49
 254  627E 54 45 4D 53
 254  6282 00
 255  6283 8A 4F        	DW MAXANIMITEMS
 256  6285 4D 41 58 41  	DB "MAXANIMDEFS",0
 256  6289 4E 49 4D 44
 256  628D 45 46 53 00
 257  6291 1A 51        	DW MAXANIMDEFS
 258  6293 4D 41 58 41  	DB "MAXANIMSPRS",0
 258  6297 4E 49 4D 53
 258  629B 50 52 53 00
 259  629F B0 51        	DW MAXANIMSPRS
 260  62A1 4D 41 58 41     DB "MAXAUTOSGAMS",0
 260  62A5 55 54 4F 53
 260  62A9 47 41 4D 53
 260  62AD 00
 261  62AE FA 52           DW MAXAUTOSGAMS
 262  62B0               ENDIF
 263  62B0               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 264  62B0 00           	DB 0
 265  62B1               ENDIF
 266  62B1              CMDS_F:
 267  62B1               IF (VRAM_CMDS == 1)
 268  62B1 46 49 4C 56      DB "FILVRM", 0
 268  62B5 52 4D 00
 269  62B8 8A 59            DW FILVRM
 270  62BA               ENDIF
 271  62BA               IF (RAM_CMDS == 1)
 272  62BA 46 49 4C 52      DB "FILRAM", 0
 272  62BE 41 4D 00
 273  62C1 52 58            DW FILRAM
 274  62C3               ENDIF
 275  62C3               IF (VRAM_CMDS + RAM_CMDS > 0)
 276  62C3 00               DB 0
 277  62C4               ENDIF
 278  62C4              CMDS_G:
 279  62C4               IF (GENCAL_CMD == 1)
 280  62C4 47 45 4E 43      DB "GENCAL", 0
 280  62C8 41 4C 00
 281  62CB B9 5A            DW GENCAL
 282  62CD               ENDIF
 283  62CD               IF (GENCAL_CMD > 0)
 284  62CD 00           	DB	0
 285  62CE               ENDIF
 286  62CE              CMDS_V:
 287  62CE               IF (VRAM_CMDS == 1)
 288  62CE 56 52 4D 4D  	DB "VRMMEM", 0
 288  62D2 45 4D 00
 289  62D5 57 5A        	DW VRMMEM
 290  62D7               ENDIF
 291  62D7               IF (VRAM_CMDS > 0)
 292  62D7 00           	DB 0
 293  62D8               ENDIF
 294  62D8              CMDS_S:
 295  62D8               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 296  62D8 53 47 41 4D      DB "SGAM",0
 296  62DC 00
 297  62DD 79 56            DW SGAM
 298  62DF               ENDIF
 299  62DF               IF (SPRITE_CMDS == 1)
 300  62DF 53 50 52 47  	DB "SPRGRPMOV", 0
 300  62E3 52 50 4D 4F
 300  62E7 56 00
 301  62E9 C5 4E        	DW SPRGRPMOV
 302  62EB               ENDIF
 303  62EB               IF (SOUND_CMDS == 1)
 304  62EB 53 4E 44 53  	DB "SNDSFX", 0
 304  62EF 46 58 00
 305  62F2 30 59        	DW SNDSFX
 306  62F4 53 4E 44 50  	DB "SNDPLYON", 0
 306  62F8 4C 59 4F 4E
 306  62FC 00
 307  62FD FA 58        	DW SNDPLYON
 308  62FF 53 4E 44 50  	DB "SNDPLYOFF", 0
 308  6303 4C 59 4F 46
 308  6307 46 00
 309  6309 0D 59        	DW SNDPLYOFF
 310  630B 53 4E 44 50  	DB "SNDPLYINI", 0
 310  630F 4C 59 49 4E
 310  6313 49 00
 311  6315 B0 58        	DW SNDPLYINIT
 312  6317               ENDIF
 313  6317               IF (SPRITE_CMDS == 1)
 314  6317 53 50 52 45  	DB "SPRENABLE", 0
 314  631B 4E 41 42 4C
 314  631F 45 00
 315  6321 5D 4E        	DW SPRENABLE
 316  6323 53 50 52 44  	DB "SPRDISABLE", 0
 316  6327 49 53 41 42
 316  632B 4C 45 00
 317  632E 9D 4E        	DW SPRDISABLE
 318  6330               ENDIF
 319  6330               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 320  6330 00           	DB 0
 321  6331               ENDIF
 322  6331              CMDS_B:
 323  6331               IF (BLIT_CMDS == 1)
 324  6331 42 4C 49 54  	DB "BLIT", 0
 324  6335 00
 325  6336 8C 5D        	DW BLIT
 326  6338               ENDIF
 327  6338               IF (BOX_CMDS == 1)
 328  6338 42 4F 58 4D  	DB "BOXMEMCPY", 0
 328  633C 45 4D 43 50
 328  6340 59 00
 329  6342 48 5B        	DW BOXMEMCPY
 330  6344 42 4F 58 4D  	DB "BOXMEMVRM", 0
 330  6348 45 4D 56 52
 330  634C 4D 00
 331  634E DE 5B        	DW BOXMEMVRM
 332  6350               ENDIF
 333  6350               IF (BLIT_CMDS + BOX_CMDS > 0)
 334  6350 00           	DB 0
 335  6351               ENDIF
 336  6351              CMDS_T:
 337  6351               IF (TILE_CMDS == 1)
 338  6351 54 49 4C 45  	DB "TILERAM", 0
 338  6355 52 41 4D 00
 339  6359 C2 5E        	DW TILERAM
 340  635B 54 49 4C 45  	DB "TILEVRM", 0
 340  635F 56 52 4D 00
 341  6363 C6 5F        	DW TILEVRM
 342  6365               ENDIF
 343  6365               IF (TILE_CMDS > 0)
 344  6365 00           	DB 0
 345  6366               ENDIF
 346  6366              CMDS_A:
 347  6366               IF (ANIM_CMDS == 1)
 348  6366 41 4E 49 4D     DB "ANIMSTEP",0
 348  636A 53 54 45 50
 348  636E 00
 349  636F CD 54           DW ANIMSTEP
 350  6371 41 4E 49 4D  	DB "ANIMSTART",0
 350  6375 53 54 41 52
 350  6379 54 00
 351  637B D2 54        	DW ANIMSTART
 352  637D 41 4E 49 4D  	DB "ANIMSTOP",0
 352  6381 53 54 4F 50
 352  6385 00
 353  6386 D7 54        	DW ANIMSTOP
 354  6388 41 4E 49 4D  	DB "ANIMITEMPAT",0
 354  638C 49 54 45 4D
 354  6390 50 41 54 00
 355  6394 5B 50        	DW ANIMITEMPAT
 356  6396 41 4E 49 4D  	DB "ANIMITEMPTR",0
 356  639A 49 54 45 4D
 356  639E 50 54 52 00
 357  63A2 C1 50        	DW ANIMITEMPTR_CMD
 358  63A4 41 4E 49 4D  	DB "ANIMDEF",0
 358  63A8 44 45 46 00
 359  63AC 5D 51        	DW ANIMDEF
 360  63AE 41 4E 49 4D  	DB "ANIMSPRITE",0
 360  63B2 53 50 52 49
 360  63B6 54 45 00
 361  63B9 09 52        	DW ANIMSPRITE
 362  63BB 41 4E 49 4D     DB "ANIMCHAR",0
 362  63BF 43 48 41 52
 362  63C3 00
 363  63C4 81 52           DW ANIMCHAR
 364  63C6 41 55 54 4F     DB "AUTOSGAMDEF",0
 364  63CA 53 47 41 4D
 364  63CE 44 45 46 00
 365  63D2 57 53           DW AUTOSGAMDEF
 366  63D4 41 55 54 4F     DB "AUTOSGAMSTART",0
 366  63D8 53 47 41 4D
 366  63DC 53 54 41 52
 366  63E0 54 00
 367  63E2 8E 54           DW AUTOSGAMSTART
 368  63E4 41 55 54 4F     DB "AUTOSGAMSTOP",0
 368  63E8 53 47 41 4D
 368  63EC 53 54 4F 50
 368  63F0 00
 369  63F1 CA 54           DW AUTOSGAMSTOP
 370  63F3 00           	DB 0
 371  63F4               ENDIF
 372  63F4              CMDS_C:
 373  63F4               IF (COLL_CMD == 1)
 374  63F4 43 4F 4C 4C      DB "COLL", 0
 374  63F8 00
 375  63F9 93 61            DW COLL
 376  63FB               ENDIF
 377  63FB               IF (COLL_CMD > 0)
 378  63FB 00           	DB	0
 379  63FC               ENDIF
 380  63FC
 381  63FC               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 382  63FC              ; ****************************************************************************************************
 383  63FC              ; function sets VRAM address
 384  63FC              ; input HL=address
 385  63FC              ; modifies AF
 386  63FC              SETWRT_LOCAL:
 387  63FC 7D           	LD	A, L
 388  63FD D3 99        	OUT	(099H), A
 389  63FF 7C           	LD	A, H
 390  6400 E6 3F        	AND	03FH
 391  6402 F6 40        	OR	040H
 392  6404 D3 99        	OUT	(099H), A
 393  6406 C9           	RET
 394  6407              ; ****************************************************************************************************
 395  6407               ENDIF
 396  6407
 397  6407               IF (VRAM_CMDS + TILE_CMDS > 0)
 398  6407              ; ****************************************************************************************************
 399  6407              ; function copies data from RAM to VRAM
 400  6407              ; input HL=address in RAM
 401  6407              ; input B=count
 402  6407              ; modifies AF, BC, HL
 403  6407              BBYTECOPY:
 404  6407 0E 98        	LD C,#98
 405  6409              BBYTECOPY_NO_C:
 406  6409 ED A3        	OUTI
 407  640B C2 09 64     	JP	NZ, BBYTECOPY_NO_C
 408  640E C9           	RET
 409  640F              ; ****************************************************************************************************
 410  640F               ENDIF
 411  640F
 412  640F              ; ****************************************************************************************************
 413  640F              ; function multiplies HL by 32
 414  640F              HLx32:
 415  640F 29           	ADD HL,HL
 416  6410              ; ****************************************************************************************************
 417  6410              ; function multiplies HL by 16
 418  6410              HLx16:
 419  6410 29           	ADD HL,HL
 420  6411              ; ****************************************************************************************************
 421  6411              ; function multiplies HL by 8
 422  6411              HLx8:
 423  6411 29          > ADD HL, HL
 423  6412 29          > ADD HL, HL
 423  6413 29          > ADD HL, HL
 424  6414 C9           	RET
 425  6415              ; ****************************************************************************************************
 426  6415
 427  6415              ; ****************************************************************************************************
 428  6415              ; function gets slot and subslot data for specific page
 429  6415              ; input A=page (0, 1 or 2)
 430  6415              ; output B = 0A8H register value
 431  6415              ; output D = 0 is no subslots, 1 if yes
 432  6415              ; output C = 0A8H value when page 3 slot equals to requested page slot
 433  6415              ; output E = subslot value if present
 434  6415              ; modifies AF, BC, DE, HL
 435  6415              GET_PAGE_INFO:
 436  6415 6F               LD L, A
 437  6416 C6 C1            ADD A, low (EXPTBL)
 438  6418 32 22 64         LD (GET_PAGE_INFO_L1+1), A
 439  641B DB A8            IN A, (0A8H)
 440  641D 47               LD B, A
 441  641E E6 3F            AND 03FH
 442  6420 4F               LD C, A
 443  6421              GET_PAGE_INFO_L1:
 444  6421 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 445  6424 E6 80            AND 080H
 446  6426 28 1B            JR Z, GET_PAGE_INFO_L2
 447  6428                  ; expanded
 448  6428 2D               DEC L
 449  6429 FA 48 64         JP M, GET_PAGE_INFO_L3
 450  642C 2D               DEC L
 451  642D FA 46 64         JP M, GET_PAGE_INFO_L4
 452  6430                  ; page 2
 453  6430 07               RLCA
 454  6431 07               RLCA
 455  6432              GET_PAGE_INFO_L5:
 456  6432 E6 C0            AND 0C0H
 457  6434 B1               OR C
 458  6435 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 459  6437 4F               LD C, A
 460  6438 3A FF FF         LD A, (0FFFFH)
 461  643B 2F               CPL
 462  643C 5F               LD E, A
 463  643D 16 01            LD D, 1
 464  643F 78               LD A, B ; return stack
 465  6440 D3 A8            OUT (0A8H), A
 466  6442 C9               RET
 467  6443              GET_PAGE_INFO_L2:
 468  6443                  ; not expanded
 469  6443 16 00            LD D, 0
 470  6445 C9               RET
 471  6446              GET_PAGE_INFO_L4:
 472  6446                  ; page 1
 473  6446 0F               RRCA
 474  6447 0F               RRCA
 475  6448              GET_PAGE_INFO_L3:
 476  6448                  ; page 0
 477  6448 0F               RRCA
 478  6449 0F               RRCA
 479  644A 18 E6            JR GET_PAGE_INFO_L5
 480  644C              ; ****************************************************************************************************
 481  644C
 482  644C              ; ****************************************************************************************************
 483  644C              ; function returns original slot and subslot info
 484  644C              ; input B = 0A8H register value
 485  644C              ; input D = 0 is no subslots, 1 if yes
 486  644C              ; input C = 0A8H value when page 3 slot equals to requested page slot
 487  644C              ; input E = subslot value if present
 488  644C              ; modifies AF, disables interrupts
 489  644C              RESTORE_PAGE_INFO:
 490  644C 7A              LD A, D
 491  644D B7              OR A
 492  644E 28 08           JR Z, RESTORE_PAGE_INFO_L1
 493  6450 79              LD A, C
 494  6451 F3           	DI
 495  6452 D3 A8           OUT (0A8H), A
 496  6454 7B              LD A, E
 497  6455 32 FF FF        LD (0FFFFH), A
 498  6458              RESTORE_PAGE_INFO_L1:
 499  6458 78              LD A, B
 500  6459 D3 A8           OUT (0A8H), A
 501  645B C9              RET
 502  645C              ; ****************************************************************************************************
 503  645C
 504  645C              ; *******************************************************************************************************
 505  645C              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 506  645C              ; INPUT:  A = SLOT ID: EXXXSSPP
 507  645C              ; E = EXPANDED FLAG
 508  645C              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 509  645C              ; PP = PRIMARY SLOT NUMBER
 510  645C              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 511  645C              ; CHANGES: AF, BC, DE
 512  645C
 513  645C              LOCAL_ENASLT:
 514  645C CD 7C 64         CALL L0353
 515  645F FA 69 64         JP M, L0340
 516  6462 DB A8            IN A, (0A8H)
 517  6464 A1               AND C
 518  6465 B0               OR B
 519  6466 D3 A8            OUT (0A8H), A
 520  6468 C9               RET
 521  6469              L0340:
 522  6469 E5               PUSH HL
 523  646A CD A1 64         CALL L0378
 524  646D 4F               LD C, A
 525  646E 06 00            LD B, 0
 526  6470 7D               LD A, L
 527  6471 A4               AND H
 528  6472 B2               OR D
 529  6473 21 C5 FC         LD HL, 0FCC5H
 530  6476 09               ADD HL, BC
 531  6477 77               LD (HL), A
 532  6478 E1               POP HL
 533  6479 79               LD A, C
 534  647A 18 E0            JR LOCAL_ENASLT
 535  647C              L0353:
 536  647C F3               DI
 537  647D F5               PUSH AF
 538  647E 7C               LD A, H
 539  647F 07               RLCA
 540  6480 07               RLCA
 541  6481 E6 03            AND 3
 542  6483 5F               LD E, A
 543  6484 3E C0            LD A, 0C0H
 544  6486              L035D:
 545  6486 07               RLCA
 546  6487 07               RLCA
 547  6488 1D               DEC E
 548  6489 F2 86 64         JP P, L035D
 549  648C 5F               LD E, A
 550  648D 2F               CPL
 551  648E 4F               LD C, A
 552  648F F1               POP AF
 553  6490 F5               PUSH AF
 554  6491 E6 03            AND 3
 555  6493 3C               INC A
 556  6494 47               LD B, A
 557  6495 3E AB            LD A, 0ABH
 558  6497              L036E:
 559  6497 C6 55            ADD A, 055H
 560  6499 10 FC            DJNZ L036E
 561  649B 57               LD D, A
 562  649C A3               AND E
 563  649D 47               LD B, A
 564  649E F1               POP AF
 565  649F A7               AND A
 566  64A0 C9               RET
 567  64A1              L0378:
 568  64A1 F5               PUSH AF
 569  64A2 7A               LD A, D
 570  64A3 E6 C0            AND 0C0H
 571  64A5 4F               LD C, A
 572  64A6 F1               POP AF
 573  64A7 F5               PUSH AF
 574  64A8 57               LD D, A
 575  64A9 DB A8            IN A, (0A8H)
 576  64AB 47               LD B, A
 577  64AC E6 3F            AND 03FH
 578  64AE B1               OR C
 579  64AF D3 A8            OUT (0A8H), A
 580  64B1 7A               LD A, D
 581  64B2 0F               RRCA
 582  64B3 0F               RRCA
 583  64B4 E6 03            AND 3
 584  64B6 57               LD D, A
 585  64B7 3E AB            LD A, 0ABH
 586  64B9              L0390:
 587  64B9 C6 55            ADD A, 055H
 588  64BB 15               DEC D
 589  64BC F2 B9 64         JP P, L0390
 590  64BF A3               AND E
 591  64C0 57               LD D, A
 592  64C1 7B               LD A, E
 593  64C2 2F               CPL
 594  64C3 67               LD H, A
 595  64C4 3A FF FF         LD A, (0FFFFH)
 596  64C7 2F               CPL
 597  64C8 6F               LD L, A
 598  64C9 A4               AND H
 599  64CA B2               OR D
 600  64CB 32 FF FF         LD (0FFFFH), A
 601  64CE 78               LD A, B
 602  64CF D3 A8            OUT (0A8H), A
 603  64D1 F1               POP AF
 604  64D2 E6 03            AND 3
 605  64D4 C9               RET
 606  64D5              ; *******************************************************************************************************
 607  64D5
 608  64D5              ; *******************************************************************************************************
 609  64D5              ; some common code to activate page 0 and place values needed to restore original page on stack
 610  64D5              ; input IY=return address
 611  64D5              ENABLE_PAGE0:
 612  64D5 AF              XOR A
 613  64D6 CD 15 64        CALL GET_PAGE_INFO
 614  64D9 C5              PUSH BC
 615  64DA D5              PUSH DE
 616  64DB 3A 41 F3        LD A, (RAMAD0)
 617  64DE 26 00           LD H, 0
 618  64E0 CD 5C 64        CALL LOCAL_ENASLT
 619  64E3 FD E9        	JP (IY)
 620  64E5              ; *******************************************************************************************************
 621  64E5
 622  64E5              ; General BASIC CALL-instruction handler
 623  64E5              CALLHAND:
 624  64E5 FB              EI
 625  64E6 E5           	PUSH HL
 626  64E7 21 30 62     	LD	HL, CMDS ; pointer table based on starting letter
 627  64EA 3A 89 FD        LD A, (PROCNM)
 628  64ED D6 41           SUB 'A'
 629  64EF 87              ADD A, A
 630  64F0 16 00           LD D, 0
 631  64F2 5F              LD E, A
 632  64F3 19              ADD HL, DE
 633  64F4 5E              LD E, (HL)
 634  64F5 23              INC HL
 635  64F6 56              LD D, (HL)
 636  64F7 7A              LD A, D
 637  64F8 B3              OR E
 638  64F9 28 23           JR Z, .CMDNOTRECOGNIZED
 639  64FB EB              EX DE, HL
 640  64FC              .CHKCMD:
 641  64FC 11 89 FD     	LD	DE, PROCNM
 642  64FF              .LOOP:
 643  64FF 1A              LD	A,(DE)
 644  6500 BE           	CP	(HL)
 645  6501 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 646  6503 13           	INC	DE
 647  6504 23           	INC	HL
 648  6505 A7           	AND	A
 649  6506 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 650  6508 5E           	LD	E,(HL)
 651  6509 23           	INC	HL
 652  650A 56           	LD	D,(HL)
 653  650B E1           	POP	HL		; routine address
 654  650C CD 2D 65     	CALL	GETPREVCHAR
 655  650F CD 21 65     	CALL	.CALLDE		; Call routine
 656  6512 A7           	AND	A
 657  6513 C9           	RET
 658  6514
 659  6514              .TONEXTCMD:
 660  6514 0E FF        	LD	C,0FFH
 661  6516 AF           	XOR	A
 662  6517 ED B1        	CPIR			; Skip to end of instruction name
 663  6519 23           	INC	HL
 664  651A 23           	INC	HL		; Skip address
 665  651B BE           	CP	(HL)
 666  651C 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 667  651E              .CMDNOTRECOGNIZED:
 668  651E E1           	POP	HL
 669  651F 37              SCF
 670  6520 C9           	RET
 671  6521
 672  6521              .CALLDE:
 673  6521 D5           	PUSH	DE
 674  6522 C9           	RET
 675  6523
 676  6523              ;---------------------------
 677  6523
 678  6523              ;GETSTRPNT:
 679  6523              ; OUT:
 680  6523              ; HL = String Address
 681  6523              ; B  = Lenght
 682  6523              ;        LD      HL,(USR)
 683  6523              ;        LD      B,(HL)
 684  6523              ;        INC     HL
 685  6523              ;        LD      E,(HL)
 686  6523              ;        INC     HL
 687  6523              ;        LD      D,(HL)
 688  6523              ;        EX      DE,HL
 689  6523              ;        RET
 690  6523
 691  6523              ;EVALTXTPARAM:
 692  6523              ;	CALL	CHKCHAR
 693  6523              ;	DEFB	"("             ; Check for (
 694  6523              ;	LD	IX,FRMEVL
 695  6523              ;	CALL	CALBAS		; Evaluate expression
 696  6523              ;       LD      A,(VALTYP)
 697  6523              ;        CP      3               ; Text type?
 698  6523              ;        JP      NZ,TYPE_MISMATCH
 699  6523              ;        PUSH	HL
 700  6523              ;        LD	IX,FRESTR         ; Free the temporary string
 701  6523              ;        CALL	CALBAS
 702  6523              ;        POP	HL
 703  6523              ;	CALL	CHKCHAR
 704  6523              ;	DEFB	")"             ; Check for )
 705  6523              ;        RET
 706  6523
 707  6523
 708  6523              CHKCHAR:
 709  6523 CD 2D 65     	CALL	GETPREVCHAR	; Get previous basic char
 710  6526 E3           	EX	(SP),HL
 711  6527 BE           	CP	(HL) 	        ; Check if good char
 712  6528 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 713  652A 23           	INC	HL
 714  652B E3           	EX	(SP),HL
 715  652C 23           	INC	HL		; Get next basic char
 716  652D
 717  652D              GETPREVCHAR:
 718  652D 2B           	DEC HL
 719  652E DD 21 66 46  	LD	IX,CHRGTR
 720  6532 CD 59 01     	CALL CALBAS
 721  6535 FB              EI
 722  6536 C9              RET
 723  6537
 724  6537
 725  6537              TYPE_MISMATCH:
 726  6537 1E 0D            LD E, 13 ; Type mismatch
 727  6539 18 0E            JR THROW_ERROR
 728  653B              SUBSCRIPT_OUT_OF_RANGE:
 729  653B 1E 09            LD E,9 ; subscript out of range
 730  653D 18 0A        	JR THROW_ERROR
 731  653F              OVERFLOW:
 732  653F 1E 06        	LD E,6
 733  6541 18 06        	JR THROW_ERROR
 734  6543              ILLEGAL_FUNCTION:
 735  6543 1E 05            LD E, 5 ; illegal function call
 736  6545 18 02            JR THROW_ERROR
 737  6547              SYNTAX_ERROR:
 738  6547 1E 02            LD E, 2 ; Syntax error
 739  6549              THROW_ERROR:
 740  6549 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 741  654D C3 59 01     	JP	CALBAS
 742  6550
 743  6550              ;---------------------------
 744  6550
 745  6550              ; *******************************************************************************************************
 746  6550              ; helper function to get pointer to BASIC array data
 747  6550              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 748  6550              ; input B=dimensions (1 or 2)
 749  6550              ; input D=minimal first dimension
 750  6550              ; input E=minimal second dimension, if applicable
 751  6550              ; returns BC=pointer to first data element
 752  6550              ; throws BASIC error if invalid type
 753  6550              GET_BASIC_ARRAY_DATA_POINTER:
 754  6550 D5           	PUSH DE
 755  6551 C5           	PUSH BC
 756  6552 F5           	PUSH AF
 757  6553 3E 01           LD A,1
 758  6555 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 759  6558 DD 21 A4 5E  	LD IX, PTRGET
 760  655C CD 59 01     	CALL CALBAS
 761  655F AF              XOR A
 762  6560 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 763  6563 3A 63 F6     	LD A,(VALTYP)
 764  6566 D1           	POP DE ; required type
 765  6567 BA           	CP D
 766  6568 C2 37 65     	JP NZ,TYPE_MISMATCH
 767  656B 0A           	LD A,(BC)
 768  656C 03           	INC BC
 769  656D D1           	POP DE ; required number of dimensions
 770  656E BA           	CP D
 771  656F C2 37 65     	JP NZ,TYPE_MISMATCH
 772  6572 D1           	POP DE ; required minimal array dimensions
 773  6573 3D           	DEC A
 774  6574 28 07        	JR Z,.ONE_DIMENSION
 775  6576              	; 2-dimension array
 776  6576 0A           	LD A,(BC)
 777  6577 03          > INC BC
 777  6578 03          > INC BC
 778  6579 BB           	CP E
 779  657A DA 3B 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 780  657D              .ONE_DIMENSION:
 781  657D 0A           	LD A,(BC)
 782  657E 03          > INC BC
 782  657F 03          > INC BC
 783  6580 BA           	CP D
 784  6581 DA 3B 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 785  6584 C9           	RET
 786  6585              ; *******************************************************************************************************
 787  6585
 788  6585              EXT_END:
 789  6585
# file closed: asm\main.asm
