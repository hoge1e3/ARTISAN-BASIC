# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000
 14   4000               DEFINE CMDS_WITH_PARAMETERS
 15   4000
 16   4000              CHPUT   EQU     #A2
 17   4000              CALBAS	EQU		#159
 18   4000              ERRHAND EQU     #406F
 19   4000              FRMEVL  EQU     #4C64
 20   4000              FRESTR	EQU		#67D0
 21   4000              ; FRMQNT = formula quantificator
 22   4000              ; input HL=pointer to current program expression
 23   4000              ; output HL=next address
 24   4000              ; output DE=integer datum
 25   4000              FRMQNT	EQU		#542F
 26   4000              ; GETBYT = get byte parameter
 27   4000              ; input HL=pointer to current program expression
 28   4000              ; output HL=next address
 29   4000              ; output A=E=byte read
 30   4000              GETBYT		EQU		#521C
 31   4000              CHRGTR  	EQU     #4666
 32   4000              PTRGET		EQU 	#5EA4
 33   4000              SUBFLG		EQU		#F6A5
 34   4000              SYNCHR		EQU		#558C
 35   4000              VALTYP  	EQU     #F663
 36   4000              USR     	EQU     #F7F8
 37   4000              PROCNM		EQU		#FD89
 38   4000              BIOS_FILVRM EQU     #0056
 39   4000              CLIKSW		EQU		#F3DB
 40   4000              ATRBAS		EQU		#F928
 41   4000              GRPCGP		EQU		#F3CB
 42   4000
 43   4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 44   4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 45   4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 46   4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 47   4000              EXPTBL	EQU #FCC1
 48   4000              SCRMOD	EQU #FCAF ; current screen mode
 49   4000              REG1SAV EQU #F3E0 ; VDP(1)
 50   4000              JIFFY	EQU #FC9E
 51   4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
 52   4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
 53   4000              PATBAS  EQU #F926 ; current sprite generator table address
 54   4000
 55   4000              ; BASIC error codes
 56   4000              ;01 NEXT without FOR
 57   4000              ;02 Syntax error
 58   4000              ;03 RETURN without GOSUB
 59   4000              ;04 Out of DATA
 60   4000              ;05 Illegal function call
 61   4000              ;06 Overflow
 62   4000              ;07 Out of memory
 63   4000              ;08 Undefined line number
 64   4000              ;09 Subscript out of range
 65   4000              ;10 Redimensioned array
 66   4000              ;11 Division by zero
 67   4000              ;12 Illegal direct
 68   4000              ;13 Type mismatch
 69   4000              ;14 Out of string space
 70   4000              ;15 String too long
 71   4000              ;16 String formula too complex
 72   4000              ;17 Can't CONTINUE
 73   4000              ;18 Undefined user function
 74   4000              ;19 Device I/O error
 75   4000              ;20 Verify error
 76   4000              ;21 No RESUME
 77   4000              ;22 RESUME without error
 78   4000              ;23 Unprintable error
 79   4000              ;24 Missing operand
 80   4000              ;25 Line buffer overflow
 81   4000              ;50 FIELD overflow
 82   4000              ;51 Internal error
 83   4000              ;52 Bad file number
 84   4000              ;53 File not found
 85   4000              ;54 File already open
 86   4000              ;55 Input past end
 87   4000              ;56 Bad file name
 88   4000              ;57 Direct statement in file
 89   4000              ;58 Sequential I/O only
 90   4000              ;59 File not OPEN
 91   4000
 92   4000
 93   4000               ; simulate cartridge with BASIC extension
 94   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 94   4004 AD 5E 00 00
 94   4008 00 00 00 00
 94   400C 00 00 00 00
 95   4010
 96   4010              ; this location #4010 stores last location used by basic extension
 97   4010              ; free memory after that point
 98   4010              FREEMEMPTR:
 99   4010 46 5F         DW EXT_END
100   4012
101   4012              ; this location #4012 stores extension version in DAA format
102   4012              ; first byte is major version and second minor
103   4012              VERSION:
104   4012 00 70         DB #00, #70
105   4014
106   4014              ; binary included AKG player compiled at #4014
107   4014               IF (SOUND_CMDS == 1)
108   4014              	INCBIN "bin/AKG.bin"
109   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
110   4CF0               ENDIF
111   4CF0
112   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 27 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A 9A 54     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13 2A 9E FC         LD HL,(JIFFY)
 43+  4D16 23               INC HL
 44+  4D17 22 9E FC         LD (JIFFY),HL
 45+  4D1A
 46+  4D1A FD E1            POP IY
 47+  4D1C DD E1            POP IX
 48+  4D1E E1               POP HL
 49+  4D1F D1               POP DE
 50+  4D20 C1               POP BC
 51+  4D21 F1               POP AF
 52+  4D22 08               EX AF, AF'
 53+  4D23 D9               EXX
 54+  4D24 E1               POP HL
 55+  4D25 D1               POP DE
 56+  4D26 C1               POP BC
 57+  4D27               ENDIF
 58+  4D27
 59+  4D27              .EXIT:
 60+  4D27 F1           	POP AF
 61+  4D28 FB           	EI
 62+  4D29 ED 4D        	RETI
 63+  4D2B              ; *******************************************************************************************************
 64+  4D2B
 65+  4D2B              ; *******************************************************************************************************
 66+  4D2B              ; H.TIMI function
 67+  4D2B              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D2B              MBGE_HTIMI:
 69+  4D2B               EXPORT MBGE_HTIMI
 70+  4D2B
 71+  4D2B               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D2B
 73+  4D2B F5           	PUSH AF
 74+  4D2C
 75+  4D2C              	; enable page 2
 76+  4D2C 3E 02            LD A, 2
 77+  4D2E CD DD 5D         CALL GET_PAGE_INFO
 78+  4D31 C5               PUSH BC
 79+  4D32 D5               PUSH DE
 80+  4D33 3A 43 F3         LD A, (RAMAD2)
 81+  4D36 26 80            LD H, 080H
 82+  4D38 CD 24 5E         CALL LOCAL_ENASLT
 83+  4D3B              	; enable page 0
 84+  4D3B AF               XOR A
 85+  4D3C CD DD 5D         CALL GET_PAGE_INFO
 86+  4D3F C5               PUSH BC
 87+  4D40 D5               PUSH DE
 88+  4D41 3A 41 F3         LD A, (RAMAD0)
 89+  4D44 26 00            LD H, 0
 90+  4D46 CD 24 5E         CALL LOCAL_ENASLT
 91+  4D49
 92+  4D49               IF (SPRITE_CMDS == 1)
 93+  4D49 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D4C               ENDIF
 95+  4D4C
 96+  4D4C               IF (SOUND_CMDS == 1)
 97+  4D4C 3A 9A 54     	LD A, (SOUND_ENABLED)
 98+  4D4F B7           	OR A
 99+  4D50 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D53               ENDIF
101+  4D53
102+  4D53              	; restore page 0
103+  4D53 D1               POP DE
104+  4D54 C1               POP BC
105+  4D55 CD 14 5E         CALL RESTORE_PAGE_INFO
106+  4D58              	; restore page 2
107+  4D58 D1               POP DE
108+  4D59 C1               POP BC
109+  4D5A CD 14 5E         CALL RESTORE_PAGE_INFO
110+  4D5D
111+  4D5D F1           	POP AF
112+  4D5E               ENDIF
113+  4D5E C3 F0 4C     	JP ORIG.HTIMI
114+  4D61              ; *******************************************************************************************************
115+  4D61
116+  4D61              ; *******************************************************************************************************
117+  4D61              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D61              ; also checks if some VRAM modifying command is running
119+  4D61              ; when that checks out calls sprite updates and animation processing
120+  4D61              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D61              	; check if initialized
122+  4D61 3A 7A 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D64 B7           	OR A
124+  4D65 C8           	RET Z
125+  4D66              	; check screen mode
126+  4D66 3A AF FC     	LD A, (SCRMOD)
127+  4D69 3D           	DEC A
128+  4D6A 28 02        	JR Z, .L0 ; screen 1
129+  4D6C 3D           	DEC A
130+  4D6D C0           	RET NZ ; not screen 2
131+  4D6E              .L0:
132+  4D6E                  ; check if anyone else is working with VRAM
133+  4D6E 3A 4F 5C         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D71 B7               OR A
135+  4D72 C0               RET NZ
136+  4D73
137+  4D73 CD 8F 4D         CALL SPRATR_UPDATE
138+  4D76
139+  4D76               IF (ANIM_CMDS == 1)
140+  4D76 CD 24 53         CALL PROCESS_ANIMATIONS
141+  4D79               ENDIF
142+  4D79 C9               RET
143+  4D7A              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
113   4D7A
114   4D7A               IF (SPRITE_CMDS == 1)
115   4D7A               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D7A              ; commands and variables related to sprites
  2+  4D7A
  3+  4D7A              SPRATR_INIT_STATUS:
  4+  4D7A 00            DB 0
  5+  4D7B              SPRATR_UPDATE_FLAG:
  6+  4D7B 00 00         DW 0
  7+  4D7D              SPRATR_DATA:
  8+  4D7D 00 00         DW 0
  9+  4D7F              SPRFLICKER_ENABLED:
 10+  4D7F 00            DB 0
 11+  4D80              ; to support sprite flicker
 12+  4D80              FLICKER:
 13+  4D80 00            DB 0
 14+  4D81
 15+  4D81              ; to temporarily store stack pointer
 16+  4D81              TMPSP:
 17+  4D81 00 00         DW 0
 18+  4D83
 19+  4D83              ; *******************************************************************************************************
 20+  4D83              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D83              ; changes HL,DE;
 22+  4D83              GETnthSPRATTR:
 23+  4D83 26 00            LD H,0
 24+  4D85 6F               LD L,A
 25+  4D86 CD D9 5D         CALL HLx8
 26+  4D89 ED 5B 7D 4D      LD DE,(SPRATR_DATA)
 27+  4D8D 19               ADD HL,DE
 28+  4D8E C9               RET
 29+  4D8F              ; *******************************************************************************************************
 30+  4D8F
 31+  4D8F              ; *******************************************************************************************************
 32+  4D8F              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D8F              ; struct {
 34+  4D8F              ; DW y
 35+  4D8F              ; DW x
 36+  4D8F              ; DW pattern (0-63)
 37+  4D8F              ; DW color
 38+  4D8F              ; } [32]
 39+  4D8F              ; will hide sprites whose location is outside of visible area
 40+  4D8F              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D8F              ; modifies AF, AF', BC, DE, HL
 42+  4D8F              SPRATR_UPDATE:
 43+  4D8F              	; check if update requested
 44+  4D8F 2A 7B 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D92 7E           	LD A, (HL)
 46+  4D93 B7           	OR A
 47+  4D94 C8           	RET Z
 48+  4D95              .L0:
 49+  4D95 06 20        	LD B, 32 ; sprite number
 50+  4D97 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D99              	; set VDP address
 52+  4D99 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D9C 3A 7F 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D9F B7           	OR A
 55+  4DA0 28 03        	JR Z, .L3
 56+  4DA2 3A 80 4D     	LD A, (FLICKER)
 57+  4DA5              .L3:
 58+  4DA5 5F           	LD E, A
 59+  4DA6 08           	EX AF, AF'
 60+  4DA7 7B           	LD A, E
 61+  4DA8 87           	ADD A, A
 62+  4DA9 87           	ADD A, A
 63+  4DAA 16 00        	LD D, 0
 64+  4DAC 5F           	LD E, A
 65+  4DAD 19           	ADD HL, DE
 66+  4DAE CD C4 5D     	CALL SETWRT_LOCAL
 67+  4DB1 ED 73 81 4D  	LD (TMPSP), SP
 68+  4DB5 ED 7B 7D 4D  	LD SP, (SPRATR_DATA)
 69+  4DB9
 70+  4DB9              .LOOP:
 71+  4DB9 E1           	POP HL
 72+  4DBA 24           	INC H
 73+  4DBB 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DBD 25           	DEC H
 75+  4DBE 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DC0 7D           	LD A, L
 77+  4DC1 FE C0        	CP 192
 78+  4DC3 30 10        	JR NC, .OUT3
 79+  4DC5 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DC6 57           	LD D, A
 81+  4DC7 C3 EE 4D     	JP .X
 82+  4DCA              .L1:
 83+  4DCA 7D           	LD A, L
 84+  4DCB C6 10        	ADD 16
 85+  4DCD FA D5 4D     	JP M, .OUT3 ; below -16
 86+  4DD0 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DD1 55           	LD D, L
 88+  4DD2 C3 EE 4D     	JP .X
 89+  4DD5              .OUT3:
 90+  4DD5 E1           	POP HL ; skip x value
 91+  4DD6              .OUT2:
 92+  4DD6 E1           	POP HL ; skip pattern
 93+  4DD7 E1           	POP HL ; skip color
 94+  4DD8 3E D1        	LD A, #D1
 95+  4DDA ED 79        	OUT (C), A ; sprite hidden
 96+  4DDC 00          > NOP
 96+  4DDD 00          > NOP
 96+  4DDE 00          > NOP
 97+  4DDF ED 79        	OUT (C), A ; value unimportant
 98+  4DE1 00          > NOP
 98+  4DE2 00          > NOP
 98+  4DE3 00          > NOP
 99+  4DE4 ED 79        	OUT (C), A ; value unimportant
100+  4DE6 00          > NOP
100+  4DE7 00          > NOP
100+  4DE8 00          > NOP
101+  4DE9 ED 79        	OUT (C), A ; value unimportant
102+  4DEB C3 19 4E     	JP .NEXT
103+  4DEE              .X:
104+  4DEE E1           	POP HL
105+  4DEF 24           	INC H
106+  4DF0 28 08        	JR Z, .L2
107+  4DF2 25           	DEC H
108+  4DF3 20 E1        	JR NZ, .OUT2
109+  4DF5 1E 00        	LD E, 0 ; EC bit
110+  4DF7 C3 03 4E     	JP .XY
111+  4DFA              .L2:
112+  4DFA 7D           	LD A, L
113+  4DFB C6 20        	ADD 32
114+  4DFD FA D6 4D     	JP M, .OUT2
115+  4E00 6F           	LD L, A
116+  4E01 1E 80        	LD E, #80
117+  4E03              .XY:
118+  4E03 ED 51        	OUT (C), D
119+  4E05 3A E0 F3     	LD A, (REG1SAV)
120+  4E08 E6 02        	AND 2
121+  4E0A ED 69        	OUT (C), L
122+  4E0C E1           	POP HL ; pattern
123+  4E0D 7D           	LD A, L
124+  4E0E 28 02        	JR Z, .SMALLSPRITES
125+  4E10 87           	ADD A, A
126+  4E11 87           	ADD A, A ; needs to go at 4x
127+  4E12              .SMALLSPRITES:
128+  4E12 D3 98        	OUT (#98), A
129+  4E14 E1           	POP HL ; color
130+  4E15 7D           	LD A, L
131+  4E16 B3           	OR E
132+  4E17 D3 98        	OUT (#98), A
133+  4E19              .NEXT:
134+  4E19 08           	EX AF, AF'
135+  4E1A 3C           	INC A
136+  4E1B E6 1F        	AND 31
137+  4E1D C2 31 4E     	JP NZ, .NEXT2
138+  4E20 08           	EX AF, AF'
139+  4E21 2A 28 F9     	LD HL, (ATRBAS)
140+  4E24              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E24 7D           	LD	A, L
142+  4E25 D3 99        	OUT	(099H), A
143+  4E27 7C           	LD	A, H
144+  4E28 E6 3F        	AND	03FH
145+  4E2A F6 40        	OR	040H
146+  4E2C D3 99        	OUT	(099H), A
147+  4E2E C3 32 4E     	JP .NEXT3
148+  4E31              .NEXT2:
149+  4E31 08           	EX AF, AF'
150+  4E32              .NEXT3:
151+  4E32 10 85        	DJNZ .LOOP
152+  4E34 08           	EX AF, AF'
153+  4E35 3C           	INC A
154+  4E36 32 80 4D     	LD (FLICKER), A
155+  4E39
156+  4E39 ED 7B 81 4D  	LD SP, (TMPSP)
157+  4E3D 2A 7B 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E40 36 00        	LD (HL), 0 ; zero out update flag
159+  4E42 C9           	RET
160+  4E43              ; *******************************************************************************************************
161+  4E43
162+  4E43              ; *******************************************************************************************************
163+  4E43              ; function to handle CALL SPRENABLE basic extension
164+  4E43              ; initializes sprites handler
165+  4E43              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E43              ;			   INT update_variable,
167+  4E43              ;			   BYTE sprite_flicker_enabled )
168+  4E43              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E43              SPRENABLE:
170+  4E43              	; opening (
171+  4E43 CD EA 5E     	CALL CHKCHAR
172+  4E46 28           	DB '('
173+  4E47              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E47 3E 02        	LD A,2
175+  4E49 06 02        	LD B,2
176+  4E4B 11 20 04     	LD DE,#0420
177+  4E4E CD 11 5F     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E51 C5           	PUSH BC
179+  4E52              	; comma
180+  4E52 CD EA 5E     	CALL CHKCHAR
181+  4E55 2C           	DB ','
182+  4E56              	; get address of sprite update flag
183+  4E56 DD 21 A4 5E  	LD IX, PTRGET
184+  4E5A CD 59 01     	CALL CALBAS
185+  4E5D D5           	PUSH DE
186+  4E5E              	; comma
187+  4E5E CD EA 5E     	CALL CHKCHAR
188+  4E61 2C           	DB ','
189+  4E62              	; get flicker enabled flag
190+  4E62 DD 21 1C 52  	LD IX, GETBYT
191+  4E66 CD 59 01     	CALL CALBAS
192+  4E69 F5           	PUSH AF
193+  4E6A              	; ending )
194+  4E6A CD EA 5E     	CALL CHKCHAR
195+  4E6D 29           	DB ')'
196+  4E6E
197+  4E6E F1           	POP AF ; get flicker flag
198+  4E6F B7           	OR A
199+  4E70 32 7F 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E73
201+  4E73 D1           	POP DE ; update variable location
202+  4E74 ED 53 7B 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E78 D1           	POP DE ; address of sprite attribute table
204+  4E79 ED 53 7D 4D  	LD (SPRATR_DATA), DE
205+  4E7D 3E 01        	LD A, 1
206+  4E7F 32 7A 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E82 C9           	RET
208+  4E83              ; *******************************************************************************************************
209+  4E83
210+  4E83              ; *******************************************************************************************************
211+  4E83              ; function to handle CALL SPRDISABLE basic extension
212+  4E83              ; disables sprites handling
213+  4E83              ; _SPRDISABLE
214+  4E83              ; resets variable SPRATR_INIT_STATUS
215+  4E83              SPRDISABLE:
216+  4E83 AF           	XOR A
217+  4E84 32 7A 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E87 C9           	RET
219+  4E88              ; *******************************************************************************************************
220+  4E88
221+  4E88              ; *******************************************************************************************************
222+  4E88              ; function to handle CALL SPRSET basic extension
223+  4E88              ; sets position, and optionally pattern and color of sprite
224+  4E88              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E88              ;			INT x,
226+  4E88              ;			INT y,
227+  4E88              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E88              ;			INT color, valid 0-15, otherwise ignored
229+  4E88              SPRSET:
230+  4E88 3A 7A 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E8B B7           	OR A
232+  4E8C 20 05        	JR NZ, .L1
233+  4E8E 1E 05        	LD E, 5 ; illegal function call
234+  4E90 C3 0A 5F     	JP THROW_ERROR
235+  4E93              .L1:
236+  4E93              	; opening (
237+  4E93 CD EA 5E     	CALL CHKCHAR
238+  4E96 28           	DB '('
239+  4E97              	; get sprite number
240+  4E97 DD 21 1C 52  	LD IX, GETBYT
241+  4E9B CD 59 01     	CALL CALBAS
242+  4E9E F5           	PUSH AF
243+  4E9F              	; comma
244+  4E9F CD EA 5E     	CALL CHKCHAR
245+  4EA2 2C           	DB ','
246+  4EA3              	; get x
247+  4EA3 DD 21 2F 54  	LD IX, FRMQNT
248+  4EA7 CD 59 01     	CALL CALBAS
249+  4EAA D5           	PUSH DE
250+  4EAB              	; comma
251+  4EAB CD EA 5E     	CALL CHKCHAR
252+  4EAE 2C           	DB ','
253+  4EAF              	; get y
254+  4EAF DD 21 2F 54  	LD IX, FRMQNT
255+  4EB3 CD 59 01     	CALL CALBAS
256+  4EB6 D5           	PUSH DE
257+  4EB7              	; comma
258+  4EB7 CD EA 5E     	CALL CHKCHAR
259+  4EBA 2C           	DB ','
260+  4EBB              	; get pattern
261+  4EBB DD 21 2F 54  	LD IX, FRMQNT
262+  4EBF CD 59 01     	CALL CALBAS
263+  4EC2 D5           	PUSH DE
264+  4EC3              	; comma
265+  4EC3 CD EA 5E     	CALL CHKCHAR
266+  4EC6 2C           	DB ','
267+  4EC7              	; get color
268+  4EC7 DD 21 2F 54  	LD IX, FRMQNT
269+  4ECB CD 59 01     	CALL CALBAS
270+  4ECE D5           	PUSH DE
271+  4ECF              	; ending )
272+  4ECF CD EA 5E     	CALL CHKCHAR
273+  4ED2 29           	DB ')'
274+  4ED3
275+  4ED3                  ; save position in BASIC text
276+  4ED3 E5           	PUSH HL
277+  4ED4 DD E1        	POP IX
278+  4ED6
279+  4ED6 C1           	POP BC ; color
280+  4ED7 D1           	POP DE ; pattern
281+  4ED8 D9           	EXX
282+  4ED9 C1           	POP BC ; y
283+  4EDA D1           	POP DE ; x
284+  4EDB F1           	POP AF ; sprite number
285+  4EDC FE 20        	CP 32
286+  4EDE 38 05        	JR C, .L2
287+  4EE0 1E 05        	LD E, 5 ; illegal function call
288+  4EE2 C3 0A 5F     	JP THROW_ERROR
289+  4EE5              .L2:
290+  4EE5              	; find location in sprite attributes table
291+  4EE5 D5           	PUSH DE
292+  4EE6 CD 83 4D     	CALL GETnthSPRATTR
293+  4EE9 D1           	POP DE
294+  4EEA              	; set y
295+  4EEA 71           	LD (HL), C
296+  4EEB 23           	INC HL
297+  4EEC 70           	LD (HL), B
298+  4EED 23           	INC HL
299+  4EEE              	; set x
300+  4EEE 73           	LD (HL), E
301+  4EEF 23           	INC HL
302+  4EF0 72           	LD (HL), D
303+  4EF1 23           	INC HL
304+  4EF2 E5           	PUSH HL
305+  4EF3 D9           	EXX
306+  4EF4 E1           	POP HL
307+  4EF5              	; check if 0<=pattern<64
308+  4EF5 7A           	LD A, D
309+  4EF6 B7           	OR A
310+  4EF7 20 0B        	JR NZ, .L3
311+  4EF9 7B           	LD A, E
312+  4EFA FE 40        	CP 64
313+  4EFC 30 06        	JR NC, .L3
314+  4EFE              	; set pattern
315+  4EFE              	;ADD A, A
316+  4EFE              	;ADD A, A
317+  4EFE              	;ADD A, A
318+  4EFE 77           	LD (HL), A
319+  4EFF 23           	INC HL
320+  4F00 72           	LD (HL), D
321+  4F01 23           	INC HL
322+  4F02 18 02        	JR .L4
323+  4F04              .L3:
324+  4F04              	; skip pattern
325+  4F04 23          > INC HL
325+  4F05 23          > INC HL
326+  4F06              .L4:
327+  4F06              	; check if 0<=color<16
328+  4F06 78           	LD A, B
329+  4F07 B7           	OR A
330+  4F08 20 08        	JR NZ, .L5
331+  4F0A 79           	LD A, C
332+  4F0B FE 10        	CP 16
333+  4F0D 30 03        	JR NC, .L5
334+  4F0F              	; set color
335+  4F0F 71           	LD (HL), C
336+  4F10 23           	INC HL
337+  4F11 70           	LD (HL), B
338+  4F12
339+  4F12              .L5:
340+  4F12 DD E5        	PUSH IX
341+  4F14 E1           	POP HL
342+  4F15 C9           	RET
343+  4F16              ; *******************************************************************************************************
344+  4F16
345+  4F16              ; *******************************************************************************************************
346+  4F16              ; function sets sprite location based on initial coordinates and offset provided
347+  4F16              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F16              ; input DE=initial x
349+  4F16              ; input BC=initial y
350+  4F16              ; input IY=location where delta y,x are located
351+  4F16              ; modifies AF, HL, IX
352+  4F16              SPRSET_DELTA_POS:
353+  4F16 D5           	PUSH DE
354+  4F17 CD 83 4D     	CALL GETnthSPRATTR
355+  4F1A E5           	PUSH HL
356+  4F1B DD E1        	POP IX
357+  4F1D D1           	POP DE
358+  4F1E              	; IX=sprite's y location
359+  4F1E FD 6E 00     	LD L, (IY)
360+  4F21 FD 66 01     	LD H, (IY+1)
361+  4F24 09           	ADD HL, BC
362+  4F25 DD 75 00     	LD (IX), L
363+  4F28 DD 74 01     	LD (IX+1), H
364+  4F2B FD 6E 02     	LD L, (IY+2)
365+  4F2E FD 66 03     	LD H, (IY+3)
366+  4F31 19           	ADD HL, DE
367+  4F32 DD 75 02     	LD (IX+2), L
368+  4F35 DD 74 03     	LD (IX+3), H
369+  4F38 C9           	RET
370+  4F39              ; *******************************************************************************************************
371+  4F39
372+  4F39              ; *******************************************************************************************************
373+  4F39              ; function to handle CALL SPRGRPMOV basic extension
374+  4F39              ; sets position of a group of sprites described with
375+  4F39              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F39              ; _SPRGRPMOV ( INT x,
377+  4F39              ;			   INT y,
378+  4F39              ;			   INT data_ptr,
379+  4F39              ;			   BYTE count,
380+  4F39              ; will put ram in page 0 also, page 1 is already there
381+  4F39              SPRGRPMOV:
382+  4F39 3A 7A 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F3C B7           	OR A
384+  4F3D 20 05        	JR NZ, .L1
385+  4F3F 1E 05        	LD E, 5 ; illegal function call
386+  4F41 C3 0A 5F     	JP THROW_ERROR
387+  4F44              .L1:
388+  4F44              	; opening (
389+  4F44 CD EA 5E     	CALL CHKCHAR
390+  4F47 28           	DB '('
391+  4F48              	; get x
392+  4F48 DD 21 2F 54  	LD IX, FRMQNT
393+  4F4C CD 59 01     	CALL CALBAS
394+  4F4F D5           	PUSH DE
395+  4F50              	; comma
396+  4F50 CD EA 5E     	CALL CHKCHAR
397+  4F53 2C           	DB ','
398+  4F54              	; get y
399+  4F54 DD 21 2F 54  	LD IX, FRMQNT
400+  4F58 CD 59 01     	CALL CALBAS
401+  4F5B D5           	PUSH DE
402+  4F5C              	; comma
403+  4F5C CD EA 5E     	CALL CHKCHAR
404+  4F5F 2C           	DB ','
405+  4F60              	; get data pointer
406+  4F60 DD 21 2F 54  	LD IX, FRMQNT
407+  4F64 CD 59 01     	CALL CALBAS
408+  4F67 D5           	PUSH DE
409+  4F68              	; comma
410+  4F68 CD EA 5E     	CALL CHKCHAR
411+  4F6B 2C           	DB ','
412+  4F6C              	; get count
413+  4F6C DD 21 1C 52  	LD IX, GETBYT
414+  4F70 CD 59 01     	CALL CALBAS
415+  4F73 F5           	PUSH AF
416+  4F74              	; ending )
417+  4F74 CD EA 5E     	CALL CHKCHAR
418+  4F77 29           	DB ')'
419+  4F78
420+  4F78 E5           	PUSH HL
421+  4F79 DD E1        	POP IX
422+  4F7B
423+  4F7B C1           	POP BC ; count
424+  4F7C E1           	POP HL ; data pointer
425+  4F7D D9           	EXX
426+  4F7E C1           	POP BC ; y
427+  4F7F D1           	POP DE ; x
428+  4F80 D9           	EXX
429+  4F81
430+  4F81 DD E5        	PUSH IX ; save position in BASIC buffer
431+  4F83
432+  4F83 C5           	PUSH BC
433+  4F84 E5           	PUSH HL
434+  4F85 AF               XOR A
435+  4F86 CD DD 5D         CALL GET_PAGE_INFO
436+  4F89 D9           	EXX
437+  4F8A E1           	POP HL
438+  4F8B F1           	POP AF
439+  4F8C D9           	EXX
440+  4F8D C5               PUSH BC
441+  4F8E D5               PUSH DE
442+  4F8F D9           	EXX
443+  4F90 F5           	PUSH AF
444+  4F91 E5           	PUSH HL
445+  4F92 D9           	EXX
446+  4F93 3A 41 F3         LD A, (RAMAD0)
447+  4F96 26 00            LD H, 0
448+  4F98 CD 24 5E         CALL LOCAL_ENASLT
449+  4F9B FB           	EI
450+  4F9C E1           	POP HL
451+  4F9D C1           	POP BC
452+  4F9E CD A8 4F     	CALL .UPDATE_LOC
453+  4FA1 D1               POP DE
454+  4FA2 C1               POP BC
455+  4FA3 CD 14 5E         CALL RESTORE_PAGE_INFO
456+  4FA6 E1           	POP HL
457+  4FA7 C9           	RET
458+  4FA8
459+  4FA8              .UPDATE_LOC:
460+  4FA8              .L4:
461+  4FA8 7E           	LD A, (HL)
462+  4FA9 23           	INC HL
463+  4FAA 23           	INC HL
464+  4FAB E5           	PUSH HL
465+  4FAC FD E1        	POP IY
466+  4FAE D9           	EXX
467+  4FAF CD 16 4F     	CALL SPRSET_DELTA_POS
468+  4FB2 D9           	EXX
469+  4FB3 23          > INC HL
469+  4FB4 23          > INC HL
469+  4FB5 23          > INC HL
469+  4FB6 23          > INC HL
470+  4FB7 10 EF        	DJNZ .L4
471+  4FB9 C9           	RET
472+  4FBA              ; *******************************************************************************************************
473+  4FBA
# file closed: asm\SPRITES.asm
116   4FBA               ENDIF
117   4FBA
118   4FBA               IF (ANIM_CMDS == 1)
119   4FBA               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FBA              ; sprite animation routines
  2+  4FBA
  3+  4FBA              ; number of animation items and pointer
  4+  4FBA              ANIMITEMNUM:
  5+  4FBA 00            DB 0
  6+  4FBB              ANIMITEMPTR:
  7+  4FBB 46 5F         DW EXT_END
  8+  4FBD              ; number of animation definitions and pointer
  9+  4FBD              ANIMDEFNUM:
 10+  4FBD 00            DB 0
 11+  4FBE              ANIMDEFPTR:
 12+  4FBE 46 5F         DW EXT_END
 13+  4FC0              ; number of links between sprite and animation definitions
 14+  4FC0              ANIMSPRNUM:
 15+  4FC0 00            DB 0
 16+  4FC1              ANIMSPRPTR:
 17+  4FC1 46 5F         DW EXT_END
 18+  4FC3
 19+  4FC3              ; ANIMATION ITEM
 20+  4FC3              ; byte type = [0 - pattern and color change
 21+  4FC3              ;              1 - pattern definition change ]
 22+  4FC3              ; word ticks - number of ticks to hold this state
 23+  4FC3              ; for type = 0
 24+  4FC3              ;   byte pattern;
 25+  4FC3              ;   byte color;
 26+  4FC3              ; for type = 1
 27+  4FC3              ;   work data_pointer;
 28+  4FC3              ; total size = 5b
 29+  4FC3
 30+  4FC3              ; ANIMATION DEFINITION
 31+  4FC3              ; byte number of items 1-15
 32+  4FC3              ; byte[15] anim_item;
 33+  4FC3              ; total size = 16b
 34+  4FC3
 35+  4FC3              ; SPRITE ANIMATION
 36+  4FC3              ; +00 byte sprite number;
 37+  4FC3              ; +01 word time;
 38+  4FC3              ; +03 byte current item;
 39+  4FC3              ; +04 byte animation definition;
 40+  4FC3              ; +05 byte cyclic;
 41+  4FC3              ; +06 byte active;
 42+  4FC3              ; +07 byte reserved
 43+  4FC3              ; total size = 8b
 44+  4FC3
 45+  4FC3              ; *******************************************************************************************************
 46+  4FC3              ; helper function HL=A*5
 47+  4FC3              ; changes HL,DE;
 48+  4FC3              Ax5:
 49+  4FC3 26 00            LD H,0
 50+  4FC5 6F               LD L,A
 51+  4FC6 54               LD D,H
 52+  4FC7 5D               LD E,L
 53+  4FC8 29               ADD HL,HL
 54+  4FC9 29               ADD HL,HL
 55+  4FCA 19               ADD HL,DE
 56+  4FCB C9               RET
 57+  4FCC              ; *******************************************************************************************************
 58+  4FCC
 59+  4FCC              ; *******************************************************************************************************
 60+  4FCC              ; helper function gets pointer to n-th animation item
 61+  4FCC              ; changes HL,DE;
 62+  4FCC              GETnthANIMITEM:
 63+  4FCC CD C3 4F         CALL Ax5
 64+  4FCF ED 5B BB 4F      LD DE,(ANIMITEMPTR)
 65+  4FD3 19               ADD HL,DE
 66+  4FD4 C9               RET
 67+  4FD5              ; *******************************************************************************************************
 68+  4FD5
 69+  4FD5              ; *******************************************************************************************************
 70+  4FD5              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD5              ; changes HL,DE;
 72+  4FD5              GETnthANIMDEF:
 73+  4FD5 26 00            LD H,0
 74+  4FD7 6F               LD L,A
 75+  4FD8 CD D9 5D         CALL HLx8
 76+  4FDB ED 5B BE 4F      LD DE,(ANIMDEFPTR)
 77+  4FDF 19               ADD HL,DE
 78+  4FE0 C9               RET
 79+  4FE1              ; *******************************************************************************************************
 80+  4FE1
 81+  4FE1              ; *******************************************************************************************************
 82+  4FE1              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FE1              ; changes HL,DE;
 84+  4FE1              GETnthSPRANIM:
 85+  4FE1 26 00            LD H,0
 86+  4FE3 6F               LD L,A
 87+  4FE4 CD D8 5D         CALL HLx16
 88+  4FE7 ED 5B C1 4F      LD DE,(ANIMSPRPTR)
 89+  4FEB 19               ADD HL,DE
 90+  4FEC C9               RET
 91+  4FED              ; *******************************************************************************************************
 92+  4FED
 93+  4FED              ; *******************************************************************************************************
 94+  4FED              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FED              ; MAXANIMITEMS (BYTE number)
 96+  4FED              ; sets new number and moves memory buffers as needed
 97+  4FED              MAXANIMITEMS:
 98+  4FED              	; opening (
 99+  4FED CD EA 5E     	CALL CHKCHAR
100+  4FF0 28           	DB '('
101+  4FF1              	; get value
102+  4FF1 DD 21 1C 52  	LD IX, GETBYT
103+  4FF5 CD 59 01     	CALL CALBAS
104+  4FF8 F5               PUSH AF
105+  4FF9              	; ending )
106+  4FF9 CD EA 5E     	CALL CHKCHAR
107+  4FFC 29           	DB ')'
108+  4FFD F1               POP AF
109+  4FFE
110+  4FFE              	; save position
111+  4FFE E5           	PUSH HL
112+  4FFF              .ENTRY:
113+  4FFF 47               LD B,A
114+  5000 3A BA 4F         LD A,(ANIMITEMNUM)
115+  5003 90               SUB B
116+  5004 28 1F            JR Z, .EXIT; same value as before
117+  5006 FD 21 BE 4F      LD IY,ANIMDEFPTR
118+  500A FA 28 50         JP M, .INCREASE
119+  500D                  ; new value is lower than previous one
120+  500D CD 40 50         CALL .SIZEDIFF
121+  5010 CD 5B 50         CALL .DECREASE_COMMON
122+  5013 2A C1 4F         LD HL,(ANIMSPRPTR)
123+  5016 AF               XOR A
124+  5017 ED 42            SBC HL,BC
125+  5019 22 C1 4F         LD (ANIMSPRPTR),HL
126+  501C              .E1:
127+  501C 2A 10 40         LD HL,(FREEMEMPTR)
128+  501F AF               XOR A
129+  5020 ED 42            SBC HL,BC
130+  5022 22 10 40         LD (FREEMEMPTR),HL
131+  5025              .EXIT:
132+  5025 FB               EI
133+  5026 E1           	POP HL
134+  5027 C9           	RET
135+  5028              .INCREASE:
136+  5028 ED 44            NEG
137+  502A CD 40 50         CALL .SIZEDIFF
138+  502D CD 87 50         CALL .INCREASE_COMMON
139+  5030 2A C1 4F         LD HL,(ANIMSPRPTR)
140+  5033 09               ADD HL,BC
141+  5034 22 C1 4F         LD (ANIMSPRPTR),HL
142+  5037              .E2:
143+  5037 2A 10 40         LD HL,(FREEMEMPTR)
144+  503A 09               ADD HL,BC
145+  503B 22 10 40         LD (FREEMEMPTR),HL
146+  503E 18 E5            JR .EXIT
147+  5040              .SIZEDIFF:
148+  5040 CD C3 4F         CALL Ax5
149+  5043 78               LD A,B
150+  5044 32 BA 4F         LD (ANIMITEMNUM),A
151+  5047 44               LD B,H
152+  5048 4D               LD C,L
153+  5049 C9               RET ; BC=size difference in bytes
154+  504A              .SIZETOMOVE:
155+  504A D5               PUSH DE
156+  504B 2A 10 40         LD HL,(FREEMEMPTR)
157+  504E FD 5E 00         LD E,(IY)
158+  5051 FD 56 01         LD D,(IY+1)
159+  5054 AF               XOR A
160+  5055 ED 52            SBC HL,DE
161+  5057 44               LD B,H
162+  5058 4D               LD C,L
163+  5059 D1               POP DE
164+  505A C9               RET
165+  505B              .DECREASE_COMMON:
166+  505B FD 6E 00         LD L,(IY)
167+  505E FD 66 01         LD H,(IY+1)
168+  5061 AF               XOR A
169+  5062 ED 42            SBC HL,BC
170+  5064 EB               EX DE,HL
171+  5065 C5               PUSH BC
172+  5066 CD 4A 50         CALL .SIZETOMOVE
173+  5069 F3               DI
174+  506A 78               LD A,B
175+  506B B1               OR C
176+  506C 28 08            JR Z,.L1
177+  506E FD 6E 00         LD L,(IY)
178+  5071 FD 66 01         LD H,(IY+1)
179+  5074 ED B0            LDIR
180+  5076              .L1:
181+  5076 C1               POP BC
182+  5077 FD 6E 00         LD L,(IY)
183+  507A FD 66 01         LD H,(IY+1)
184+  507D AF               XOR A
185+  507E ED 42            SBC HL,BC
186+  5080 FD 75 00         LD (IY),L
187+  5083 FD 74 01         LD (IY+1),H
188+  5086 C9               RET
189+  5087              .INCREASE_COMMON:
190+  5087 2A 10 40         LD HL,(FREEMEMPTR)
191+  508A 2B               DEC HL
192+  508B AF               XOR A
193+  508C ED 42            SBC HL,BC
194+  508E EB               EX DE,HL
195+  508F C5               PUSH BC
196+  5090 CD 4A 50         CALL .SIZETOMOVE
197+  5093 F3               DI
198+  5094 78               LD A,B
199+  5095 B1               OR C
200+  5096 28 06            JR Z,.L2
201+  5098 2A 10 40         LD HL,(FREEMEMPTR)
202+  509B 2B               DEC HL
203+  509C ED B8            LDDR
204+  509E              .L2:
205+  509E C1               POP BC
206+  509F FD 6E 00         LD L,(IY)
207+  50A2 FD 66 01         LD H,(IY+1)
208+  50A5 09               ADD HL,BC
209+  50A6 FD 75 00         LD (IY),L
210+  50A9 FD 74 01         LD (IY+1),H
211+  50AC C9               RET
212+  50AD              ; *******************************************************************************************************
213+  50AD
214+  50AD              ; *******************************************************************************************************
215+  50AD              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AD              ; ANIMITEMPAT ( BYTE id,
217+  50AD              ;               INT ticks,
218+  50AD              ;               BYTE pattern,
219+  50AD              ;               BYTE color )
220+  50AD              ; fills animation item data, returns an error if out of bounds
221+  50AD              ANIMITEMPAT:
222+  50AD                  ; opening (
223+  50AD CD EA 5E     	CALL CHKCHAR
224+  50B0 28           	DB '('
225+  50B1              	; get id
226+  50B1 DD 21 1C 52  	LD IX, GETBYT
227+  50B5 CD 59 01     	CALL CALBAS
228+  50B8 F5               PUSH AF
229+  50B9                  ; check if out of bounds
230+  50B9 3C               INC A
231+  50BA 4F               LD C,A
232+  50BB 3A BA 4F         LD A,(ANIMITEMNUM)
233+  50BE B9               CP C
234+  50BF DA 00 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50C2              	; comma
236+  50C2 CD EA 5E     	CALL CHKCHAR
237+  50C5 2C           	DB ','
238+  50C6              	; get ticks
239+  50C6 DD 21 2F 54  	LD IX, FRMQNT
240+  50CA CD 59 01     	CALL CALBAS
241+  50CD D5           	PUSH DE
242+  50CE              	; comma
243+  50CE CD EA 5E     	CALL CHKCHAR
244+  50D1 2C           	DB ','
245+  50D2              	; get pattern
246+  50D2 DD 21 1C 52  	LD IX, GETBYT
247+  50D6 CD 59 01     	CALL CALBAS
248+  50D9 F5               PUSH AF
249+  50DA              	; comma
250+  50DA CD EA 5E     	CALL CHKCHAR
251+  50DD 2C           	DB ','
252+  50DE              	; get color
253+  50DE DD 21 1C 52  	LD IX, GETBYT
254+  50E2 CD 59 01     	CALL CALBAS
255+  50E5 F5               PUSH AF
256+  50E6              	; ending )
257+  50E6 CD EA 5E     	CALL CHKCHAR
258+  50E9 29           	DB ')'
259+  50EA              .ENTRY:
260+  50EA E5               PUSH HL
261+  50EB DD E1            POP IX
262+  50ED D9               EXX
263+  50EE C1               POP BC ; color
264+  50EF D1               POP DE ; pattern
265+  50F0 E1               POP HL ; ticks
266+  50F1 D9               EXX
267+  50F2 F1               POP AF
268+  50F3 CD CC 4F         CALL GETnthANIMITEM
269+  50F6 E5               PUSH HL
270+  50F7 FD E1            POP IY
271+  50F9 D9               EXX
272+  50FA FD 36 00 00      LD (IY),0 ; type=0
273+  50FE FD 75 01         LD (IY+1),L
274+  5101 FD 74 02         LD (IY+2),H
275+  5104 FD 72 03         LD (IY+3),D
276+  5107 FD 70 04         LD (IY+4),B
277+  510A
278+  510A DD E5            PUSH IX
279+  510C E1               POP HL
280+  510D C9               RET
281+  510E              ; *******************************************************************************************************
282+  510E
283+  510E              ; *******************************************************************************************************
284+  510E              ; function to handle CALL ANIMITEMPTR basic extension
285+  510E              ; ANIMITEMPTR ( BYTE id,
286+  510E              ;               INT ticks,
287+  510E              ;               INT pointer,
288+  510E              ; fills animation item data, returns an error if out of bounds
289+  510E              ANIMITEMPTR_CMD:
290+  510E                  ; opening (
291+  510E CD EA 5E     	CALL CHKCHAR
292+  5111 28           	DB '('
293+  5112              	; get id
294+  5112 DD 21 1C 52  	LD IX, GETBYT
295+  5116 CD 59 01     	CALL CALBAS
296+  5119 F5               PUSH AF
297+  511A                  ; check if out of bounds
298+  511A 3C               INC A
299+  511B 4F               LD C,A
300+  511C 3A BA 4F         LD A,(ANIMITEMNUM)
301+  511F B9               CP C
302+  5120 DA 00 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5123              	; comma
304+  5123 CD EA 5E     	CALL CHKCHAR
305+  5126 2C           	DB ','
306+  5127              	; get ticks
307+  5127 DD 21 2F 54  	LD IX, FRMQNT
308+  512B CD 59 01     	CALL CALBAS
309+  512E D5           	PUSH DE
310+  512F              	; comma
311+  512F CD EA 5E     	CALL CHKCHAR
312+  5132 2C           	DB ','
313+  5133              	; get pointer
314+  5133 DD 21 2F 54  	LD IX, FRMQNT
315+  5137 CD 59 01     	CALL CALBAS
316+  513A D5           	PUSH DE
317+  513B              	; ending )
318+  513B CD EA 5E     	CALL CHKCHAR
319+  513E 29           	DB ')'
320+  513F              .ENTRY:
321+  513F E5               PUSH HL
322+  5140 DD E1            POP IX
323+  5142 D9               EXX
324+  5143 D1               POP DE ; pointer
325+  5144 E1               POP HL ; ticks
326+  5145 D9               EXX
327+  5146 F1               POP AF
328+  5147 CD CC 4F         CALL GETnthANIMITEM
329+  514A E5               PUSH HL
330+  514B FD E1            POP IY
331+  514D D9               EXX
332+  514E FD 36 00 01      LD (IY),1 ; type=1
333+  5152 FD 75 01         LD (IY+1),L
334+  5155 FD 74 02         LD (IY+2),H
335+  5158 FD 73 03         LD (IY+3),E
336+  515B FD 72 04         LD (IY+4),D
337+  515E
338+  515E DD E5            PUSH IX
339+  5160 E1               POP HL
340+  5161 C9               RET
341+  5162              ; *******************************************************************************************************
342+  5162
343+  5162              ; *******************************************************************************************************
344+  5162              ; function to handle CALL MAXANIMDEFS basic extension
345+  5162              ; MAXANIMDEFS (BYTE number)
346+  5162              ; sets new number and moves memory buffers as needed
347+  5162              MAXANIMDEFS:
348+  5162              	; opening (
349+  5162 CD EA 5E     	CALL CHKCHAR
350+  5165 28           	DB '('
351+  5166              	; get value
352+  5166 DD 21 1C 52  	LD IX, GETBYT
353+  516A CD 59 01     	CALL CALBAS
354+  516D F5               PUSH AF
355+  516E              	; ending )
356+  516E CD EA 5E     	CALL CHKCHAR
357+  5171 29           	DB ')'
358+  5172 F1               POP AF
359+  5173
360+  5173              	; save position
361+  5173 E5           	PUSH HL
362+  5174              .ENTRY:
363+  5174 47               LD B,A
364+  5175 3A BD 4F         LD A,(ANIMDEFNUM)
365+  5178 90               SUB B
366+  5179 CA 25 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  517C FD 21 C1 4F      LD IY,ANIMSPRPTR
368+  5180 FA 8C 51         JP M, .INCREASE
369+  5183                  ; new value is lower than previous one
370+  5183 CD 97 51         CALL .SIZEDIFF
371+  5186 CD 5B 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  5189 C3 1C 50         JP MAXANIMITEMS.E1
373+  518C              .INCREASE:
374+  518C ED 44            NEG
375+  518E CD 97 51         CALL .SIZEDIFF
376+  5191 CD 87 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5194 C3 37 50         JP MAXANIMITEMS.E2
378+  5197              .SIZEDIFF:
379+  5197 26 00            LD H,0
380+  5199 6F               LD L,A
381+  519A CD D8 5D         CALL HLx16
382+  519D 78               LD A,B
383+  519E 32 BD 4F         LD (ANIMDEFNUM),A
384+  51A1 44               LD B,H
385+  51A2 4D               LD C,L
386+  51A3 C9               RET ; BC=size difference in bytes
387+  51A4              ; *******************************************************************************************************
388+  51A4
389+  51A4              ; *******************************************************************************************************
390+  51A4              ; function to handle CALL ANIMDEF basic extension
391+  51A4              ; ANIMITEMPAT ( BYTE id,
392+  51A4              ;               BYTE size,
393+  51A4              ;               INT[] list )
394+  51A4              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A4              ANIMDEF:
396+  51A4                  ; opening (
397+  51A4 CD EA 5E     	CALL CHKCHAR
398+  51A7 28           	DB '('
399+  51A8              	; get id
400+  51A8 DD 21 1C 52  	LD IX, GETBYT
401+  51AC CD 59 01     	CALL CALBAS
402+  51AF F5               PUSH AF
403+  51B0                  ; check if out of bounds
404+  51B0 3C               INC A
405+  51B1 4F               LD C,A
406+  51B2 3A BD 4F         LD A,(ANIMDEFNUM)
407+  51B5 B9               CP C
408+  51B6 DA 00 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51B9              	; comma
410+  51B9 CD EA 5E     	CALL CHKCHAR
411+  51BC 2C           	DB ','
412+  51BD              	; get size
413+  51BD DD 21 1C 52  	LD IX, GETBYT
414+  51C1 CD 59 01     	CALL CALBAS
415+  51C4 FE 10            CP 16
416+  51C6 D2 04 5F         JP NC, OVERFLOW
417+  51C9 B7               OR A
418+  51CA CA 04 5F         JP Z, OVERFLOW
419+  51CD F5           	PUSH AF
420+  51CE              	; comma
421+  51CE CD EA 5E     	CALL CHKCHAR
422+  51D1 2C           	DB ','
423+  51D2              	; get pointer to a list of animation items in integer array format
424+  51D2                  ; get array pointer
425+  51D2 D1               POP DE
426+  51D3 D5               PUSH DE
427+  51D4 3E 02            LD A,2
428+  51D6 06 01            LD B,1
429+  51D8 CD 11 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51DB C5               PUSH BC
431+  51DC              	; ending )
432+  51DC CD EA 5E     	CALL CHKCHAR
433+  51DF 29           	DB ')'
434+  51E0              .ENTRY:
435+  51E0 E5               PUSH HL
436+  51E1 DD E1            POP IX
437+  51E3 D1               POP DE ; pointer to INT array
438+  51E4 C1               POP BC ; B=item number
439+  51E5 F1               POP AF ; id
440+  51E6 D5               PUSH DE
441+  51E7 CD D5 4F         CALL GETnthANIMDEF
442+  51EA D1               POP DE
443+  51EB 70               LD (HL),B
444+  51EC              .L1:
445+  51EC 23               INC HL
446+  51ED 1A               LD A,(DE)
447+  51EE 13          > INC DE
447+  51EF 13          > INC DE
448+  51F0 77               LD (HL),A
449+  51F1 10 F9            DJNZ .L1
450+  51F3 DD E5            PUSH IX
451+  51F5 E1               POP HL
452+  51F6 C9               RET
453+  51F7              ; *******************************************************************************************************
454+  51F7
455+  51F7              ; *******************************************************************************************************
456+  51F7              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F7              ; MAXANIMSPRS (BYTE number)
458+  51F7              ; sets new number and moves memory buffers as needed
459+  51F7              MAXANIMSPRS:
460+  51F7              	; opening (
461+  51F7 CD EA 5E     	CALL CHKCHAR
462+  51FA 28           	DB '('
463+  51FB              	; get value
464+  51FB DD 21 1C 52  	LD IX, GETBYT
465+  51FF CD 59 01     	CALL CALBAS
466+  5202 F5               PUSH AF
467+  5203              	; ending )
468+  5203 CD EA 5E     	CALL CHKCHAR
469+  5206 29           	DB ')'
470+  5207 F1               POP AF
471+  5208
472+  5208              	; save position
473+  5208 E5           	PUSH HL
474+  5209              .ENTRY:
475+  5209 47               LD B,A
476+  520A 3A C0 4F         LD A,(ANIMSPRNUM)
477+  520D 90               SUB B
478+  520E CA 25 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  5211 FD 21 10 40      LD IY,FREEMEMPTR
480+  5215 FA 21 52         JP M, .INCREASE
481+  5218                  ; new value is lower than previous one
482+  5218 CD 40 52         CALL .SIZEDIFF
483+  521B CD 5B 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  521E C3 25 50         JP MAXANIMITEMS.EXIT
485+  5221              .INCREASE:
486+  5221 ED 44            NEG
487+  5223 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5224 CD 40 52         CALL .SIZEDIFF
489+  5227 CD 87 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  522A AF               XOR A
491+  522B ED 42            SBC HL,BC ; location of new stuff
492+  522D F1               POP AF
493+  522E 47               LD B,A
494+  522F 11 08 00         LD DE,8
495+  5232 E5               PUSH HL
496+  5233 DD E1            POP IX
497+  5235              .L1:
498+  5235 DD 36 06 00      LD (IX+6),0
499+  5239 DD 19            ADD IX,DE
500+  523B 10 F8            DJNZ .L1
501+  523D C3 25 50         JP MAXANIMITEMS.EXIT
502+  5240              .SIZEDIFF:
503+  5240 26 00            LD H,0
504+  5242 6F               LD L,A
505+  5243 CD D9 5D         CALL HLx8
506+  5246 78               LD A,B
507+  5247 32 C0 4F         LD (ANIMSPRNUM),A
508+  524A 44               LD B,H
509+  524B 4D               LD C,L
510+  524C C9               RET ; BC=size difference in bytes
511+  524D              ; *******************************************************************************************************
512+  524D
513+  524D              ; *******************************************************************************************************
514+  524D              ; function to handle CALL ANIMSPRITE basic extension
515+  524D              ; ANIMSPRITE ( BYTE id,
516+  524D              ;              BYTE sprite_number,
517+  524D              ;              BYTE animation_definition_id,
518+  524D              ;              BYTE cyclic_flag )
519+  524D              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524D              ANIMSPRITE:
521+  524D                  ; opening (
522+  524D CD EA 5E     	CALL CHKCHAR
523+  5250 28           	DB '('
524+  5251              	; get sprite animation id
525+  5251 DD 21 1C 52  	LD IX, GETBYT
526+  5255 CD 59 01     	CALL CALBAS
527+  5258 F5               PUSH AF
528+  5259 3C               INC A
529+  525A 4F               LD C,A
530+  525B 3A C0 4F         LD A,(ANIMSPRNUM)
531+  525E B9               CP C
532+  525F DA 00 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  5262              	; comma
534+  5262 CD EA 5E     	CALL CHKCHAR
535+  5265 2C           	DB ','
536+  5266              	; get sprite number
537+  5266 DD 21 1C 52  	LD IX, GETBYT
538+  526A CD 59 01     	CALL CALBAS
539+  526D F5               PUSH AF
540+  526E                  ; check if out of bounds
541+  526E FE 20            CP 32
542+  5270 D2 00 5F         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5273              	; comma
544+  5273 CD EA 5E     	CALL CHKCHAR
545+  5276 2C           	DB ','
546+  5277              	; get animation definition id
547+  5277 DD 21 1C 52  	LD IX, GETBYT
548+  527B CD 59 01     	CALL CALBAS
549+  527E F5               PUSH AF
550+  527F 3C               INC A
551+  5280 4F               LD C,A
552+  5281 3A BD 4F         LD A,(ANIMDEFNUM)
553+  5284 B9               CP C
554+  5285 DA 00 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  5288              	; comma
556+  5288 CD EA 5E     	CALL CHKCHAR
557+  528B 2C           	DB ','
558+  528C              	; get cyclic flag
559+  528C DD 21 1C 52  	LD IX, GETBYT
560+  5290 CD 59 01         CALL CALBAS
561+  5293 F5           	PUSH AF
562+  5294              	; ending )
563+  5294 CD EA 5E     	CALL CHKCHAR
564+  5297 29           	DB ')'
565+  5298              .ENTRY:
566+  5298 E5               PUSH HL
567+  5299 DD E1            POP IX
568+  529B D9               EXX
569+  529C D1               POP DE ; cyclic
570+  529D C1               POP BC ; animation definition id
571+  529E E1               POP HL ; sprite number
572+  529F D9               EXX
573+  52A0 F1               POP AF ; sprite animation id
574+  52A1 CD E1 4F         CALL GETnthSPRANIM
575+  52A4 E5               PUSH HL
576+  52A5 FD E1            POP IY
577+  52A7 D9               EXX
578+  52A8 FD 74 00         LD (IY),H
579+  52AB FD 70 04         LD (IY+4),B
580+  52AE FD 72 05         LD (IY+5),D
581+  52B1                  ;LD (IY+6),0
582+  52B1 DD E5            PUSH IX
583+  52B3 E1               POP HL
584+  52B4 C9               RET
585+  52B5              ; *******************************************************************************************************
586+  52B5
587+  52B5              ; *******************************************************************************************************
588+  52B5              ; function to handle CALL ANIMSTART basic extension
589+  52B5              ; two forms
590+  52B5              ; ANIMSTART ( BYTE id )
591+  52B5              ; or
592+  52B5              ; ANIMSTART ( BYTE item_number,
593+  52B5              ;             INT[] sprite_animations )
594+  52B5              ; sets active flag to 1
595+  52B5              ANIMSTART:
596+  52B5 3E 01            LD A,1
597+  52B7 18 01            JR ANIMSTARTSTOP_COMMON
598+  52B9              ; *******************************************************************************************************
599+  52B9              ; *******************************************************************************************************
600+  52B9              ; function to handle CALL ANIMSTOP basic extension
601+  52B9              ; two forms
602+  52B9              ; ANIMSTOP ( BYTE id )
603+  52B9              ; or
604+  52B9              ; ANIMSTOP ( BYTE item_number,
605+  52B9              ;            INT[] sprite_animations )
606+  52B9              ; sets active flag to 1
607+  52B9              ANIMSTOP:
608+  52B9 AF               XOR A
609+  52BA              ANIMSTARTSTOP_COMMON:
610+  52BA 32 17 53         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
611+  52BD              ; *******************************************************************************************************
612+  52BD                  ; opening (
613+  52BD CD EA 5E     	CALL CHKCHAR
614+  52C0 28           	DB '('
615+  52C1              	; get sprite animation id or array size
616+  52C1 DD 21 1C 52  	LD IX,GETBYT
617+  52C5 CD 59 01     	CALL CALBAS
618+  52C8 F5               PUSH AF
619+  52C9                  ; check if comma present
620+  52C9 CD F4 5E         CALL GETPREVCHAR
621+  52CC 23               INC HL
622+  52CD FE 2C            CP ','
623+  52CF 28 0C            JR Z,.L1
624+  52D1 FE 29            CP ')'
625+  52D3 C2 08 5F         JP NZ,SYNTAX_ERROR
626+  52D6                  ; ok so single argument variant
627+  52D6 F1               POP AF
628+  52D7 E5               PUSH HL
629+  52D8 CD 03 53         CALL .SETVALUE
630+  52DB E1               POP HL
631+  52DC C9               RET
632+  52DD              .L1:
633+  52DD                  ; get array pointer
634+  52DD D1               POP DE
635+  52DE D5               PUSH DE
636+  52DF 3E 02            LD A,2
637+  52E1 06 01            LD B,1
638+  52E3 CD 11 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
639+  52E6 C5               PUSH BC
640+  52E7              	; ending )
641+  52E7 CD EA 5E     	CALL CHKCHAR
642+  52EA 29           	DB ')'
643+  52EB D1               POP DE ; array pointer
644+  52EC C1               POP BC ; number of items
645+  52ED 78               LD A,B
646+  52EE B7               OR A
647+  52EF CA 00 5F         JP Z,SUBSCRIPT_OUT_OF_RANGE
648+  52F2 E5               PUSH HL
649+  52F3 F3               DI
650+  52F4              .L2:
651+  52F4 C5               PUSH BC
652+  52F5 1A               LD A,(DE)
653+  52F6 13          > INC DE
653+  52F7 13          > INC DE
654+  52F8 D5               PUSH DE
655+  52F9 CD 03 53         CALL .SETVALUE
656+  52FC D1               POP DE
657+  52FD C1               POP BC
658+  52FE 10 F4            DJNZ .L2
659+  5300 FB               EI
660+  5301 E1               POP HL
661+  5302 C9               RET
662+  5303
663+  5303              .SETVALUE:
664+  5303 47               LD B,A
665+  5304 3C               INC A
666+  5305 4F               LD C,A
667+  5306 3A C0 4F         LD A,(ANIMSPRNUM)
668+  5309 B9               CP C
669+  530A DA 00 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
670+  530D 78               LD A,B
671+  530E CD E1 4F         CALL GETnthSPRANIM
672+  5311 E5               PUSH HL
673+  5312 DD E1            POP IX
674+  5314              .VALUE:
675+  5314 DD 36 06 01      LD (IX+6),1 ; active flag
676+  5318 3A 17 53         LD A,(.VALUE+3)
677+  531B B7               OR A
678+  531C C8               RET Z
679+  531D DD 36 03 00      LD (IX+3),0 ; current item
680+  5321 C3 92 53         JP SETUP_ANIM_STEP
681+  5324              ; *******************************************************************************************************
682+  5324
683+  5324              ; *******************************************************************************************************
684+  5324              ; function processes animations during vblank period
685+  5324              PROCESS_ANIMATIONS:
686+  5324 3A C0 4F         LD A,(ANIMSPRNUM)
687+  5327 B7               OR A
688+  5328 C8               RET Z; no animations defined
689+  5329 47               LD B,A
690+  532A DD 2A C1 4F      LD IX,(ANIMSPRPTR)
691+  532E              .L1:
692+  532E C5               PUSH BC
693+  532F DD 7E 06         LD A,(IX+6); active
694+  5332 B7               OR A
695+  5333 28 16            JR Z,.SKIP ; inactive animation
696+  5335 DD 6E 01         LD L,(IX+1)
697+  5338 DD 66 02         LD H,(IX+2) ; HL=end time
698+  533B ED 5B 9E FC      LD DE,(JIFFY)
699+  533F AF               XOR A
700+  5340 ED 52            SBC HL,DE
701+  5342 F2 4B 53         JP P,.SKIP ; time until next animation item not yet reached
702+  5345 DD 34 03         INC (IX+3) ; current animation item
703+  5348 CD 92 53         CALL SETUP_ANIM_STEP
704+  534B              .SKIP:
705+  534B 11 08 00         LD DE,8
706+  534E DD 19            ADD IX,DE
707+  5350 C1               POP BC
708+  5351 10 DB            DJNZ .L1
709+  5353 C9               RET
710+  5354              ; *******************************************************************************************************
711+  5354
712+  5354              ; *******************************************************************************************************
713+  5354              ; function will setup sprite animation after current item change
714+  5354              ; input A=current animation definition
715+  5354              ; input IX=pointer to sprite animation
716+  5354              ; output IY=pointer to animation item
717+  5354              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
718+  5354              ; basically sets new end time for current animation
719+  5354              INIT_CURRENT_ANIMATION:
720+  5354 CD D5 4F         CALL GETnthANIMDEF
721+  5357 7E               LD A,(HL); number of animation items in the animation definition
722+  5358 DD BE 03         CP (IX+3) ; current animation item
723+  535B 20 0A            JR NZ,.L3 ; last item not reached
724+  535D                  ; last item reached
725+  535D DD 7E 05         LD A,(IX+5) ; cyclic flag
726+  5360 B7               OR A
727+  5361 28 2D            JR Z,.ERROR ; non-cyclic animation
728+  5363                  ; cyclic animation, restart
729+  5363 DD 36 03 00      LD (IX+3),0; current item
730+  5367              .L3:
731+  5367                  ; HL = animation definition
732+  5367 23               INC HL ; skip animation definition size field
733+  5368 16 00            LD D,0
734+  536A DD 5E 03         LD E,(IX+3); current item
735+  536D 19               ADD HL,DE
736+  536E 4E               LD C,(HL) ; current animation item
737+  536F 0C               INC C
738+  5370 3A BA 4F         LD A,(ANIMITEMNUM)
739+  5373 B9               CP C
740+  5374 38 1A            JR C,.ERROR ; invalid animation item, stop animation
741+  5376 0D               DEC C
742+  5377 79               LD A,C
743+  5378 CD CC 4F         CALL GETnthANIMITEM
744+  537B E5               PUSH HL
745+  537C FD E1            POP IY ; IY=animation item
746+  537E 2A 9E FC         LD HL,(JIFFY)
747+  5381 FD 5E 01         LD E,(IY+1)
748+  5384 FD 56 02         LD D,(IY+2) ; duration
749+  5387 19               ADD HL,DE
750+  5388 DD 75 01         LD (IX+1),L
751+  538B DD 74 02         LD (IX+2),H ; end time for current item
752+  538E              .EXIT:
753+  538E AF               XOR A
754+  538F C9               RET
755+  5390              .ERROR:
756+  5390 37               SCF
757+  5391 C9               RET
758+  5392              ; *******************************************************************************************************
759+  5392
760+  5392              ; *******************************************************************************************************
761+  5392              ; function will display currect item and set up expiry time
762+  5392              ; it will also stop the animation if expired
763+  5392              ; sets sprite update flag if any changes in sprite data made
764+  5392              ; input IX=current sprite animation
765+  5392              SETUP_ANIM_STEP:
766+  5392 DD 4E 04         LD C,(IX+4) ; animation definition ID
767+  5395 0C               INC C
768+  5396 3A BD 4F         LD A,(ANIMDEFNUM)
769+  5399 B9               CP C
770+  539A 30 05            JR NC,.L2
771+  539C                  ; given animation item is outside of bounds, deactivate animation
772+  539C              .STOPANIM:
773+  539C DD 36 06 00      LD (IX+6),0
774+  53A0 C9               RET
775+  53A1              .L2:
776+  53A1 0D               DEC C
777+  53A2 79               LD A,C
778+  53A3 CD 54 53         CALL INIT_CURRENT_ANIMATION
779+  53A6 38 F4            JR C, .STOPANIM
780+  53A8 FD 7E 00         LD A,(IY) ; type of animation item
781+  53AB B7               OR A
782+  53AC CA E1 53         JP Z,.L4 ; change pattern and/or color
783+  53AF              .PAT:
784+  53AF                  ; change sprite pattern definition
785+  53AF DD 7E 00         LD A,(IX) ; sprite number
786+  53B2 CD 83 4D         CALL GETnthSPRATTR
787+  53B5 23          > INC HL ; skip y and x
787+  53B6 23          > INC HL
787+  53B7 23          > INC HL
787+  53B8 23          > INC HL
788+  53B9 7E               LD A,(HL); current pattern
789+  53BA 26 00            LD H,0
790+  53BC 6F               LD L,A
791+  53BD 3A E0 F3         LD A,(REG1SAV)
792+  53C0 E6 02            AND 2
793+  53C2 20 07            JR NZ,.L6
794+  53C4                  ; 8x8 sprite
795+  53C4 CD D9 5D         CALL HLx8
796+  53C7 06 08            LD B,8
797+  53C9 18 05            JR .L5
798+  53CB              .L6:
799+  53CB CD D7 5D         CALL HLx32
800+  53CE 06 20            LD B,32
801+  53D0              .L5:
802+  53D0 ED 5B 26 F9      LD DE,(PATBAS)
803+  53D4 19               ADD HL,DE
804+  53D5 CD C4 5D         CALL SETWRT_LOCAL
805+  53D8 FD 6E 03         LD L,(IY+3)
806+  53DB FD 66 04         LD H,(IY+4) ; pointer to sprite patter data
807+  53DE C3 CF 5D         JP BBYTECOPY
808+  53E1              .L4:
809+  53E1                  ; change pattern and color in sprite attributes table
810+  53E1 DD 7E 00         LD A,(IX) ; sprite number
811+  53E4 CD 83 4D         CALL GETnthSPRATTR
812+  53E7 23          > INC HL ; skip y and x
812+  53E8 23          > INC HL
812+  53E9 23          > INC HL
812+  53EA 23          > INC HL
813+  53EB FD 7E 03         LD A,(IY+3) ; new pattern
814+  53EE 77               LD (HL),A
815+  53EF 23          > INC HL
815+  53F0 23          > INC HL
816+  53F1 FD 7E 04         LD A,(IY+4) ; new color
817+  53F4 77               LD (HL),A
818+  53F5 2A 7B 4D         LD HL,(SPRATR_UPDATE_FLAG)
819+  53F8 36 01            LD (HL),1
820+  53FA C9               RET
821+  53FB              ; *******************************************************************************************************
822+  53FB
# file closed: asm\ANIMATION.asm
120   53FB               ENDIF
121   53FB
122   53FB               IF (RAM_CMDS == 1)
123   53FB               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  53FB              ; *******************************************************************************************************
  2+  53FB              ; function to handle CALL MEMCPY basic extension
  3+  53FB              ; _MEMCPY ( INT source,
  4+  53FB              ;			INT destination,
  5+  53FB              ;			INT count,
  6+  53FB              ; will put ram in page 0 also, page 1 is already there
  7+  53FB              MEMCPY:
  8+  53FB              	; opening (
  9+  53FB CD EA 5E     	CALL CHKCHAR
 10+  53FE 28           	DB '('
 11+  53FF              	; get source address
 12+  53FF DD 21 2F 54  	LD IX, FRMQNT
 13+  5403 CD 59 01     	CALL CALBAS
 14+  5406 D5           	PUSH DE
 15+  5407              	; comma
 16+  5407 CD EA 5E     	CALL CHKCHAR
 17+  540A 2C           	DB ','
 18+  540B              	; get destination address
 19+  540B DD 21 2F 54  	LD IX, FRMQNT
 20+  540F CD 59 01     	CALL CALBAS
 21+  5412 D5           	PUSH DE
 22+  5413              	; comma
 23+  5413 CD EA 5E     	CALL CHKCHAR
 24+  5416 2C           	DB ','
 25+  5417              	; get length
 26+  5417 DD 21 2F 54  	LD IX, FRMQNT
 27+  541B CD 59 01     	CALL CALBAS
 28+  541E D5           	PUSH DE
 29+  541F              	; ending )
 30+  541F CD EA 5E     	CALL CHKCHAR
 31+  5422 29           	DB ')'
 32+  5423
 33+  5423              	; save position
 34+  5423 E5           	PUSH HL
 35+  5424 DD E1        	POP IX
 36+  5426
 37+  5426 C1           	POP BC ; count
 38+  5427 D1           	POP DE ; destination
 39+  5428 E1           	POP HL ; source
 40+  5429 D9           	EXX
 41+  542A              	; enable page 0
 42+  542A FD 21 31 54  	LD IY, .RET
 43+  542E C3 9D 5E     	JP ENABLE_PAGE0
 44+  5431              .RET:
 45+  5431 FB           	EI
 46+  5432 D9           	EXX
 47+  5433 ED B0        	LDIR
 48+  5435 D1               POP DE
 49+  5436 C1               POP BC
 50+  5437 CD 14 5E         CALL RESTORE_PAGE_INFO
 51+  543A DD E5        	PUSH IX
 52+  543C E1           	POP HL
 53+  543D C9           	RET
 54+  543E              ; *******************************************************************************************************
 55+  543E
 56+  543E              ; *******************************************************************************************************
 57+  543E              ; function to handle CALL FILRAM basic extension
 58+  543E              ; FILRAM ( INT start address,
 59+  543E              ;		   INT count,
 60+  543E              ;		   BYTE value,
 61+  543E              ; will put ram in page 0 also, page 1 is already there
 62+  543E              FILRAM:
 63+  543E              	; opening (
 64+  543E CD EA 5E     	CALL CHKCHAR
 65+  5441 28           	DB '('
 66+  5442              	; get start address
 67+  5442 DD 21 2F 54  	LD IX, FRMQNT
 68+  5446 CD 59 01     	CALL CALBAS
 69+  5449 D5           	PUSH DE
 70+  544A              	; comma
 71+  544A CD EA 5E     	CALL CHKCHAR
 72+  544D 2C           	DB ','
 73+  544E              	; get count
 74+  544E DD 21 2F 54  	LD IX, FRMQNT
 75+  5452 CD 59 01     	CALL CALBAS
 76+  5455 D5           	PUSH DE
 77+  5456              	; comma
 78+  5456 CD EA 5E     	CALL CHKCHAR
 79+  5459 2C           	DB ','
 80+  545A              	; get value
 81+  545A DD 21 1C 52  	LD IX, GETBYT
 82+  545E CD 59 01     	CALL CALBAS
 83+  5461 F5           	PUSH AF
 84+  5462              	; ending )
 85+  5462 CD EA 5E     	CALL CHKCHAR
 86+  5465 29           	DB ')'
 87+  5466
 88+  5466              	; save position
 89+  5466 E5           	PUSH HL
 90+  5467 DD E1        	POP IX
 91+  5469
 92+  5469 D1           	POP DE ; actually AF
 93+  546A C1           	POP BC ; count
 94+  546B E1           	POP HL ; start address
 95+  546C 78           	LD A, B
 96+  546D B7           	OR A
 97+  546E 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  5470 B1           	OR C
 99+  5471 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  5473 79           	LD A, C
101+  5474 3D           	DEC A
102+  5475 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  5477              	; one byte to fill
104+  5477 72           	LD (HL), D
105+  5478 18 12        	JR .EXIT
106+  547A              .L1:
107+  547A D9           	EXX
108+  547B              	; enable page 0
109+  547B FD 21 82 54  	LD IY, .RET
110+  547F C3 9D 5E     	JP ENABLE_PAGE0
111+  5482              .RET:
112+  5482 FB           	EI
113+  5483 D9           	EXX
114+  5484 CD 90 54     	CALL .FILLVALUE
115+  5487 D1               POP DE
116+  5488 C1               POP BC
117+  5489 CD 14 5E         CALL RESTORE_PAGE_INFO
118+  548C              .EXIT:
119+  548C DD E5        	PUSH IX
120+  548E E1           	POP HL
121+  548F C9           	RET
122+  5490
123+  5490              .FILLVALUE:
124+  5490 72               LD (HL), D
125+  5491 54               LD D, H
126+  5492 5D               LD E, L
127+  5493 13               INC DE
128+  5494 0B               DEC BC
129+  5495 ED B0            LDIR
130+  5497 C9               RET
131+  5498              ; *******************************************************************************************************
132+  5498
# file closed: asm\MEMORY.asm
124   5498               ENDIF
125   5498
126   5498               IF (SOUND_CMDS == 1)
127   5498               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  5498              MUSIC_INIT_STATUS:
  2+  5498 00            DB 0
  3+  5499              SFX_INIT_STATUS:
  4+  5499 00            DB 0
  5+  549A              SOUND_ENABLED:
  6+  549A 00            DB 0
  7+  549B
  8+  549B              ; *******************************************************************************************************
  9+  549B              ; function to handle CALL SNDPLYINIT basic extension
 10+  549B              ; initializes sound player
 11+  549B              ; _SNDPLYINIT ( INT music_offset,
 12+  549B              ;				INT sfx_offset, can be -1 if no SFX
 13+  549B              ; will put ram in page 0 also, page 1 is already there
 14+  549B              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  549B              SNDPLYINIT:
 16+  549B              	; opening (
 17+  549B CD EA 5E     	CALL CHKCHAR
 18+  549E 28           	DB '('
 19+  549F              	; get music address
 20+  549F DD 21 2F 54  	LD IX, FRMQNT
 21+  54A3 CD 59 01     	CALL CALBAS
 22+  54A6 D5           	PUSH DE
 23+  54A7              	; comma
 24+  54A7 CD EA 5E     	CALL CHKCHAR
 25+  54AA 2C           	DB ','
 26+  54AB              	; get sfx address
 27+  54AB DD 21 2F 54  	LD IX, FRMQNT
 28+  54AF CD 59 01     	CALL CALBAS
 29+  54B2 D5           	PUSH DE
 30+  54B3              	; ending )
 31+  54B3 CD EA 5E     	CALL CHKCHAR
 32+  54B6 29           	DB ')'
 33+  54B7
 34+  54B7                  ; save position in BASIC text
 35+  54B7 44           	LD B, H
 36+  54B8 4D           	LD C, L
 37+  54B9
 38+  54B9              	; pop LDIR parameters and store away for later
 39+  54B9 D1           	POP DE ; sfx address
 40+  54BA E1           	POP HL ; music address
 41+  54BB C5           	PUSH BC ; basic text location
 42+  54BC D9           	EXX
 43+  54BD FD 21 C4 54  	LD IY, .RET
 44+  54C1 C3 9D 5E     	JP ENABLE_PAGE0
 45+  54C4              .RET:
 46+  54C4 D9           	EXX
 47+  54C5
 48+  54C5 D5           	PUSH DE
 49+  54C6 AF           	XOR A
 50+  54C7              	; HL = music location
 51+  54C7 CD 62 41     	CALL PLY_AKG_INIT
 52+  54CA 3E 01        	LD A, 1
 53+  54CC 32 98 54     	LD (MUSIC_INIT_STATUS), A
 54+  54CF
 55+  54CF E1           	POP HL ; SFX
 56+  54D0              	; check if SFX address -1
 57+  54D0 23           	INC HL
 58+  54D1 7D           	LD A, L
 59+  54D2 B4           	OR H
 60+  54D3 28 09        	JR Z,.L1
 61+  54D5 2B           	DEC HL
 62+  54D6 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  54D9 3E 01        	LD A, 1
 64+  54DB 32 99 54     	LD (SFX_INIT_STATUS), A
 65+  54DE              .L1:
 66+  54DE D1               POP DE
 67+  54DF C1               POP BC
 68+  54E0 CD 14 5E         CALL RESTORE_PAGE_INFO
 69+  54E3
 70+  54E3 E1           	POP HL
 71+  54E4 C9           	RET
 72+  54E5              ; *******************************************************************************************************
 73+  54E5
 74+  54E5              ; *******************************************************************************************************
 75+  54E5              ; function to handle CALL SNDPLYON basic extension
 76+  54E5              ; enables sound player
 77+  54E5              ; _SNDPLYON
 78+  54E5              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  54E5              ; if not throws out of data error
 80+  54E5              SNDPLYON:
 81+  54E5 3A 98 54     	LD A, (MUSIC_INIT_STATUS)
 82+  54E8 B7           	OR A
 83+  54E9 20 05        	JR NZ, .L1
 84+  54EB              	; player not initialized, throw error
 85+  54EB 1E 04        	LD E, 04 ; Out of DATA
 86+  54ED C3 0A 5F     	JP THROW_ERROR
 87+  54F0              .L1:
 88+  54F0 32 9A 54     	LD (SOUND_ENABLED), A
 89+  54F3              	; disable key click
 90+  54F3 AF           	XOR A
 91+  54F4 32 DB F3     	LD (CLIKSW), A
 92+  54F7 C9           	RET
 93+  54F8              ; *******************************************************************************************************
 94+  54F8
 95+  54F8              ; *******************************************************************************************************
 96+  54F8              ; function to handle CALL SNDPLYOFF basic extension
 97+  54F8              ; disables sound player
 98+  54F8              ; _SNDPLYOFF
 99+  54F8              ; sets SOUND_ENABLED variable to 0
100+  54F8              ; calls AKG to stop music and SFX on all channels if initialized
101+  54F8              SNDPLYOFF:
102+  54F8 3A 9A 54     	LD A, (SOUND_ENABLED)
103+  54FB B7           	OR A
104+  54FC C8           	RET Z ; already stopped
105+  54FD AF           	XOR A
106+  54FE 32 9A 54     	LD (SOUND_ENABLED), A
107+  5501 E5           	PUSH HL
108+  5502 CD 21 42     	CALL PLY_AKG_STOP
109+  5505 3A 99 54     	LD A, (SFX_INIT_STATUS)
110+  5508 B7           	OR A
111+  5509 28 0E        	JR Z, .EXIT ; SFX not in use
112+  550B AF           	XOR A
113+  550C CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  550F 3E 01        	LD A, 1
115+  5511 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  5514 3E 02        	LD A, 2
117+  5516 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  5519              .EXIT:
119+  5519 E1           	POP HL
120+  551A C9           	RET
121+  551B              ; *******************************************************************************************************
122+  551B
123+  551B              ; *******************************************************************************************************
124+  551B              ; function to handle CALL SNDSFX basic extension
125+  551B              ; plays a sound effect
126+  551B              ; _SNDSFX ( BYTE sfx_number, >0
127+  551B              ;			BYTE channel, = 0,1 or 2
128+  551B              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  551B              ; will put ram in page 0 also, page 1 is already there
130+  551B              ; if sound off throws illegal function call
131+  551B              ; if sfx not initialized, throws out of data
132+  551B              SNDSFX:
133+  551B              	; opening (
134+  551B CD EA 5E     	CALL CHKCHAR
135+  551E 28           	DB '('
136+  551F              	; get sfx_number
137+  551F DD 21 1C 52  	LD IX, GETBYT
138+  5523 CD 59 01     	CALL CALBAS
139+  5526 D5           	PUSH DE
140+  5527              	; comma
141+  5527 CD EA 5E     	CALL CHKCHAR
142+  552A 2C           	DB ','
143+  552B              	; get sfx address
144+  552B DD 21 1C 52  	LD IX, GETBYT
145+  552F CD 59 01     	CALL CALBAS
146+  5532 D5           	PUSH DE
147+  5533              	; comma
148+  5533 CD EA 5E     	CALL CHKCHAR
149+  5536 2C           	DB ','
150+  5537              	; get inverted volume
151+  5537 DD 21 1C 52  	LD IX, GETBYT
152+  553B CD 59 01     	CALL CALBAS
153+  553E D5           	PUSH DE
154+  553F              	; ending )
155+  553F CD EA 5E     	CALL CHKCHAR
156+  5542 29           	DB ')'
157+  5543
158+  5543 3A 9A 54     	LD A, (SOUND_ENABLED)
159+  5546 B7           	OR A
160+  5547 20 05        	JR NZ, .L1
161+  5549              	; sound disabled, throw illegal function call
162+  5549 1E 05        	LD E, 5
163+  554B C3 0A 5F     	JP THROW_ERROR
164+  554E              .L1:
165+  554E 3A 99 54     	LD A, (SFX_INIT_STATUS)
166+  5551 B7           	OR A
167+  5552 20 05        	JR NZ, .L2
168+  5554              	; sfx data not initialized, throw out of data
169+  5554 1E 04        	LD E, 4
170+  5556 C3 0A 5F     	JP THROW_ERROR
171+  5559              .L2:
172+  5559              	; pop  parameters and store away for later
173+  5559 D1           	POP DE ; inverted volume
174+  555A 43           	LD B, E
175+  555B D1           	POP DE ; channel
176+  555C 4B           	LD C, E
177+  555D D1           	POP DE
178+  555E 7B           	LD A, E
179+  555F 08           	EX AF, AF'
180+  5560 E5           	PUSH HL ; basic text location
181+  5561 D9           	EXX
182+  5562 FD 21 69 55  	LD IY, .RET
183+  5566 C3 9D 5E     	JP ENABLE_PAGE0
184+  5569              .RET:
185+  5569 D9           	EXX
186+  556A 08           	EX AF, AF'
187+  556B CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  556E
189+  556E D1               POP DE
190+  556F C1               POP BC
191+  5570 CD 14 5E         CALL RESTORE_PAGE_INFO
192+  5573
193+  5573 E1           	POP HL
194+  5574 C9           	RET
195+  5575              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
128   5575               ENDIF
129   5575
130   5575               IF (VRAM_CMDS == 1)
131   5575               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  5575              ; *******************************************************************************************************
  2+  5575              ; function to handle CALL FILVRM basic extension
  3+  5575              ; FILVRM ( INT offset,
  4+  5575              ;		   INT count,
  5+  5575              ;		   BYTE value,
  6+  5575              ;		   BYTE wait_vsync) >0 = true
  7+  5575              ; wait_vsync will issue HALT before copying
  8+  5575              FILVRM:
  9+  5575              	; opening (
 10+  5575 CD EA 5E     	CALL CHKCHAR
 11+  5578 28           	DB '('
 12+  5579              	; get offset address
 13+  5579 DD 21 2F 54  	LD IX, FRMQNT
 14+  557D CD 59 01     	CALL CALBAS
 15+  5580 D5           	PUSH DE
 16+  5581              	; comma
 17+  5581 CD EA 5E     	CALL CHKCHAR
 18+  5584 2C           	DB ','
 19+  5585              	; get count
 20+  5585 DD 21 2F 54  	LD IX, FRMQNT
 21+  5589 CD 59 01     	CALL CALBAS
 22+  558C D5           	PUSH DE
 23+  558D              	; comma
 24+  558D CD EA 5E     	CALL CHKCHAR
 25+  5590 2C           	DB ','
 26+  5591              	; get value
 27+  5591 DD 21 1C 52  	LD IX, GETBYT
 28+  5595 CD 59 01     	CALL CALBAS
 29+  5598 F5           	PUSH AF
 30+  5599              	; comma
 31+  5599 CD EA 5E     	CALL CHKCHAR
 32+  559C 2C           	DB ','
 33+  559D              	; get vsync wait
 34+  559D DD 21 1C 52  	LD IX, GETBYT
 35+  55A1 CD 59 01     	CALL CALBAS
 36+  55A4 F5           	PUSH AF
 37+  55A5              	; ending )
 38+  55A5 CD EA 5E     	CALL CHKCHAR
 39+  55A8 29           	DB ')'
 40+  55A9
 41+  55A9 FB               EI
 42+  55AA              	; save position
 43+  55AA E5           	PUSH HL
 44+  55AB DD E1        	POP IX
 45+  55AD
 46+  55AD              	; syntax ok
 47+  55AD              	; wait for vsync if needed
 48+  55AD F1           	POP AF
 49+  55AE B7           	OR A
 50+  55AF 28 01        	JR Z, .L1
 51+  55B1 76           	HALT
 52+  55B2
 53+  55B2              .L1:
 54+  55B2 3E 01        	LD A,1
 55+  55B4 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  55B7 F1               POP AF ; value
 57+  55B8 C1               POP BC ; count
 58+  55B9 E1               POP HL ; offset
 59+  55BA CD 56 00         CALL BIOS_FILVRM
 60+  55BD AF           	XOR A
 61+  55BE 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  55C1
 63+  55C1              .L3:
 64+  55C1 DD E5        	PUSH IX
 65+  55C3 E1           	POP HL
 66+  55C4 C9           	RET
 67+  55C5              ; *******************************************************************************************************
 68+  55C5
 69+  55C5              ; *******************************************************************************************************
 70+  55C5              ; function to handle CALL MEMVRM basic extension
 71+  55C5              ; copies from RAM to VRAM
 72+  55C5              ; _MEMVRM ( INT source,
 73+  55C5              ;			INT destination,
 74+  55C5              ;			INT count,
 75+  55C5              ;			BYTE wait_vsync) >0 = true
 76+  55C5              ; will put ram in page 0 also, page 1 is already there
 77+  55C5              ; wait_vsync will issue HALT before copying
 78+  55C5              MEMVRM:
 79+  55C5              	; opening (
 80+  55C5 CD EA 5E     	CALL CHKCHAR
 81+  55C8 28           	DB '('
 82+  55C9              	; get source address
 83+  55C9 DD 21 2F 54  	LD IX, FRMQNT
 84+  55CD CD 59 01     	CALL CALBAS
 85+  55D0 D5           	PUSH DE
 86+  55D1              	; comma
 87+  55D1 CD EA 5E     	CALL CHKCHAR
 88+  55D4 2C           	DB ','
 89+  55D5              	; get destination address
 90+  55D5 DD 21 2F 54  	LD IX, FRMQNT
 91+  55D9 CD 59 01     	CALL CALBAS
 92+  55DC D5           	PUSH DE
 93+  55DD              	; comma
 94+  55DD CD EA 5E     	CALL CHKCHAR
 95+  55E0 2C           	DB ','
 96+  55E1              	; get length
 97+  55E1 DD 21 2F 54  	LD IX, FRMQNT
 98+  55E5 CD 59 01     	CALL CALBAS
 99+  55E8 D5           	PUSH DE
100+  55E9              	; comma
101+  55E9 CD EA 5E     	CALL CHKCHAR
102+  55EC 2C           	DB ','
103+  55ED              	; get vsync wait
104+  55ED DD 21 1C 52  	LD IX, GETBYT
105+  55F1 CD 59 01     	CALL CALBAS
106+  55F4 F5           	PUSH AF
107+  55F5              	; ending )
108+  55F5 CD EA 5E     	CALL CHKCHAR
109+  55F8 29           	DB ')'
110+  55F9
111+  55F9                  ; save position in BASIC text
112+  55F9 E5           	PUSH HL
113+  55FA DD E1        	POP IX
114+  55FC
115+  55FC F1           	POP AF ; wait vsync
116+  55FD B7           	OR A
117+  55FE 28 03        	JR Z, .L1
118+  5600 FB               EI
119+  5601 76           	HALT
120+  5602 F3           	DI
121+  5603              .L1:
122+  5603              	; pop LDIR parameters and store away for later
123+  5603 C1           	POP BC ; count
124+  5604 D1           	POP DE ; vram destination
125+  5605 E1           	POP HL ; ram source
126+  5606 D9           	EXX
127+  5607 FD 21 0E 56   	LD IY, .RET
128+  560B C3 9D 5E     	JP ENABLE_PAGE0
129+  560E              .RET:
130+  560E FB           	EI
131+  560F D9           	EXX
132+  5610 3E 01        	LD A,1
133+  5612 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  5615 CD 25 56     	CALL .LDIRVM
135+  5618 AF           	XOR A
136+  5619 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  561C D1               POP DE
138+  561D C1               POP BC
139+  561E CD 14 5E         CALL RESTORE_PAGE_INFO
140+  5621 DD E5        	PUSH IX
141+  5623 E1           	POP HL
142+  5624 C9           	RET
143+  5625
144+  5625              .LDIRVM:
145+  5625 EB           	EX DE, HL
146+  5626 F3           	DI
147+  5627 CD C4 5D     	CALL SETWRT_LOCAL
148+  562A FB           	EI
149+  562B EB           	EX DE, HL
150+  562C 78           	LD A, B
151+  562D B7           	OR A
152+  562E 28 0D        	JR Z, .L3
153+  5630 C5           	PUSH BC
154+  5631 0E 98        	LD C, #98
155+  5633              .L2:
156+  5633 50           	LD D, B
157+  5634 06 00        	LD B, 0
158+  5636 CD D1 5D     	CALL BBYTECOPY_NO_C
159+  5639 42           	LD B, D
160+  563A 10 F7        	DJNZ .L2
161+  563C C1           	POP BC
162+  563D              .L3:
163+  563D 79           	LD A, C
164+  563E B7           	OR A
165+  563F C8           	RET Z
166+  5640 41           	LD B, C
167+  5641 C3 CF 5D     	JP BBYTECOPY
168+  5644              ; *******************************************************************************************************
169+  5644
170+  5644              ; *******************************************************************************************************
171+  5644              ; function to handle CALL VRMMEM basic extension
172+  5644              ; copies from RAM to VRAM
173+  5644              ; _VRMMEM ( INT source,
174+  5644              ;			INT destination,
175+  5644              ;			INT count
176+  5644              ; will put ram in page 0 also, page 1 is already there
177+  5644              VRMMEM:
178+  5644              	; opening (
179+  5644 CD EA 5E     	CALL CHKCHAR
180+  5647 28           	DB '('
181+  5648              	; get source address
182+  5648 DD 21 2F 54  	LD IX, FRMQNT
183+  564C CD 59 01     	CALL CALBAS
184+  564F D5           	PUSH DE
185+  5650              	; comma
186+  5650 CD EA 5E     	CALL CHKCHAR
187+  5653 2C           	DB ','
188+  5654              	; get destination address
189+  5654 DD 21 2F 54  	LD IX, FRMQNT
190+  5658 CD 59 01     	CALL CALBAS
191+  565B D5           	PUSH DE
192+  565C              	; comma
193+  565C CD EA 5E     	CALL CHKCHAR
194+  565F 2C           	DB ','
195+  5660              	; get length
196+  5660 DD 21 2F 54  	LD IX, FRMQNT
197+  5664 CD 59 01     	CALL CALBAS
198+  5667 D5           	PUSH DE
199+  5668              	; ending )
200+  5668 CD EA 5E     	CALL CHKCHAR
201+  566B 29           	DB ')'
202+  566C
203+  566C                  ; save position in BASIC text
204+  566C E5           	PUSH HL
205+  566D DD E1        	POP IX
206+  566F
207+  566F C1           	POP BC ; count
208+  5670 D1           	POP DE ; destination
209+  5671 E1           	POP HL ; source
210+  5672 D9           	EXX
211+  5673 FD 21 7A 56  	LD IY, .RET
212+  5677 C3 9D 5E     	JP ENABLE_PAGE0
213+  567A              .RET:
214+  567A FB           	EI
215+  567B D9           	EXX
216+  567C 3E 01        	LD A,1
217+  567E 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  5681 CD 91 56     	CALL .LDIRMV
219+  5684 AF           	XOR A
220+  5685 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  5688 D1               POP DE
222+  5689 C1               POP BC
223+  568A CD 14 5E         CALL RESTORE_PAGE_INFO
224+  568D DD E5        	PUSH IX
225+  568F E1           	POP HL
226+  5690 C9           	RET
227+  5691
228+  5691              .LDIRMV:
229+  5691              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  5691 7D           	LD	A, L
231+  5692 F3           	DI
232+  5693 D3 99        	OUT	(099H), A
233+  5695 7C           	LD	A, H
234+  5696 E6 3F        	AND	03FH
235+  5698 D3 99        	OUT	(099H), A
236+  569A FB           	EI
237+  569B              	;EX (SP), HL
238+  569B              	;EX (SP), HL
239+  569B              	;NOP
240+  569B              	;NOP
241+  569B              .L4:
242+  569B DB 98            IN A, (#98)
243+  569D 12           	LD (DE), A
244+  569E 13               INC DE
245+  569F 0B               DEC BC
246+  56A0 79               LD A, C
247+  56A1 B0               OR B
248+  56A2 20 F7            JR NZ, .L4
249+  56A4 C9               RET
250+  56A5              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
132   56A5               ENDIF
133   56A5
134   56A5               IF (GENCAL_CMD == 1)
135   56A5               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  56A5              ; *******************************************************************************************************
  2+  56A5              ; function to handle CALL GENCAL basic extension
  3+  56A5              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  56A5              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  56A5              ; output values of registers will also be stored at reg_list_ptr
  6+  56A5              GENCAL_VAR_SP:
  7+  56A5 00 00            DW 0
  8+  56A7              GENCAL_VAR_SP2:
  9+  56A7 00 00            DW 0
 10+  56A9              GENCAL:
 11+  56A9              	; opening (
 12+  56A9 CD EA 5E     	CALL CHKCHAR
 13+  56AC 28           	DB '('
 14+  56AD              	; get function address
 15+  56AD DD 21 2F 54  	LD IX, FRMQNT
 16+  56B1 CD 59 01     	CALL CALBAS
 17+  56B4 D5           	PUSH DE
 18+  56B5              	; comma
 19+  56B5 CD EA 5E     	CALL CHKCHAR
 20+  56B8 2C           	DB ','
 21+  56B9              	; get pointer to register list
 22+  56B9 3E 02            LD A,2
 23+  56BB 06 01            LD B,1
 24+  56BD 11 00 05         LD DE,#0500
 25+  56C0 CD 11 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  56C3 C5           	PUSH BC
 27+  56C4              	; ending )
 28+  56C4 CD EA 5E     	CALL CHKCHAR
 29+  56C7 29           	DB ')'
 30+  56C8
 31+  56C8              	; save BASIC token position
 32+  56C8 E5           	PUSH HL
 33+  56C9 D9               EXX
 34+  56CA E1           	POP HL ; HL'=next basic token
 35+  56CB D9               EXX
 36+  56CC
 37+  56CC E1               POP HL ; get pointer to register values
 38+  56CD F3           	DI
 39+  56CE ED 73 A5 56      LD (GENCAL_VAR_SP), SP
 40+  56D2 F9               LD SP, HL
 41+  56D3 F1               POP AF
 42+  56D4 C1               POP BC
 43+  56D5 D1               POP DE
 44+  56D6 E1               POP HL
 45+  56D7 DD E1            POP IX
 46+  56D9 FD E1            POP IY
 47+  56DB D9               EXX
 48+  56DC ED 73 A7 56      LD (GENCAL_VAR_SP2), SP
 49+  56E0 ED 7B A5 56      LD SP, (GENCAL_VAR_SP)
 50+  56E4 FB               EI
 51+  56E5 D1               POP DE ; get function to call
 52+  56E6 E5               PUSH HL
 53+  56E7 CD 02 57         CALL .EXXDECALL
 54+  56EA F3               DI
 55+  56EB ED 73 A5 56      LD (GENCAL_VAR_SP), SP
 56+  56EF ED 7B A7 56      LD SP, (GENCAL_VAR_SP2)
 57+  56F3 FD E5            PUSH IY
 58+  56F5 DD E5            PUSH IX
 59+  56F7 E5               PUSH HL
 60+  56F8 D5               PUSH DE
 61+  56F9 C5               PUSH BC
 62+  56FA F5               PUSH AF
 63+  56FB ED 7B A5 56      LD SP, (GENCAL_VAR_SP)
 64+  56FF FB               EI
 65+  5700 E1               POP HL
 66+  5701 C9           	RET
 67+  5702
 68+  5702              .EXXDECALL:
 69+  5702 D5               PUSH DE
 70+  5703 D9               EXX
 71+  5704 C9               RET
 72+  5705              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
136   5705               ENDIF
137   5705
138   5705               IF (BOX_CMDS == 1)
139   5705               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  5705              ; *******************************************************************************************************
  2+  5705              ; generic function to implement rectangle data copy
  3+  5705              ; should be modified to call appropriate function for memory or vram
  4+  5705              ; input IX=pointer to following structure
  5+  5705              ; +00 source data pointer
  6+  5705              ; +02 num bytes in a row
  7+  5705              ; +04 number of rows
  8+  5705              ; +06 source add-to value till next row
  9+  5705              ; +08 destination address
 10+  5705              ; +10 destination add-to value till next row
 11+  5705              ; modifies AF, BC, DE, HL
 12+  5705              RECTANGLE_COPY:
 13+  5705 DD 6E 00     	LD L, (IX+0)
 14+  5708 DD 66 01     	LD H, (IX+1) ; source address
 15+  570B DD 5E 08     	LD E, (IX+8)
 16+  570E DD 56 09     	LD D, (IX+9) ; destination
 17+  5711 DD 46 04     	LD B, (IX+4) ; row number
 18+  5714              .L1:
 19+  5714 C5           	PUSH BC
 20+  5715 E5           		PUSH HL
 21+  5716 D5           			PUSH DE
 22+  5717 DD 4E 02     				LD C, (IX+2)
 23+  571A DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  571D              .CALL1:
 25+  571D CD 00 00     				CALL 0 ; set destination address from DE
 26+  5720              .CALL2:
 27+  5720 CD 00 00     				CALL 0 ; copy data fn
 28+  5723 E1           			POP HL
 29+  5724 DD 4E 0A     			LD C, (IX+10)
 30+  5727 DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  572A 09           			ADD HL, BC
 32+  572B EB           			EX DE, HL
 33+  572C E1           		POP HL
 34+  572D DD 4E 06     		LD C, (IX+6)
 35+  5730 DD 46 07     		LD B, (IX+7) ; src add-to
 36+  5733 09           		ADD HL, BC
 37+  5734 C1           	POP BC
 38+  5735 10 DD        	DJNZ .L1
 39+  5737 C9           	RET
 40+  5738              ; *******************************************************************************************************
 41+  5738
 42+  5738              ; *******************************************************************************************************
 43+  5738              ; function to handle CALL BOXMEMCPY basic extension
 44+  5738              ; copies data with window like boundaries to ram
 45+  5738              ; BOXMEMCPY ( INT request_data_ptr )
 46+  5738              ; request_data_ptr described in RECTANGLE_COPY
 47+  5738              ; will put ram in page 0 also, page 1 is already there
 48+  5738              BOXMEMCPY:
 49+  5738              	; opening (
 50+  5738 CD EA 5E     	CALL CHKCHAR
 51+  573B 28           	DB '('
 52+  573C              	; get pointer to request struct
 53+  573C DD 21 2F 54  	LD IX, FRMQNT
 54+  5740 CD 59 01     	CALL CALBAS
 55+  5743 D5           	PUSH DE
 56+  5744              	; ending )
 57+  5744 CD EA 5E     	CALL CHKCHAR
 58+  5747 29           	DB ')'
 59+  5748
 60+  5748 DD E1        	POP IX ; pointer to request struct
 61+  574A
 62+  574A E5           	PUSH HL ; save position in BASIC buffer
 63+  574B
 64+  574B FD 21 52 57  	LD IY, .RET
 65+  574F C3 9D 5E     	JP ENABLE_PAGE0
 66+  5752              .RET:
 67+  5752 FB           	EI
 68+  5753              	; set RAM functions to call
 69+  5753 21 00 00     	LD HL, 0
 70+  5756 22 1D 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 71+  5759 22 1F 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 72+  575C 21 ED B0     	LD HL, #B0ED ; LDIR
 73+  575F 22 21 57     	LD (RECTANGLE_COPY.CALL1+4), HL
 74+  5762 CD 05 57     	CALL RECTANGLE_COPY
 75+  5765
 76+  5765 D1               POP DE
 77+  5766 C1               POP BC
 78+  5767 CD 14 5E         CALL RESTORE_PAGE_INFO
 79+  576A
 80+  576A E1           	POP HL
 81+  576B C9           	RET
 82+  576C              ; *******************************************************************************************************
 83+  576C
 84+  576C              ; *******************************************************************************************************
 85+  576C              ; function to handle CALL BOXMEMVRM basic extension
 86+  576C              ; copies data with window like boundaries to Vram
 87+  576C              ; BOXMEMVRM ( INT request_data_ptr )
 88+  576C              ; request_data_ptr described in RECTANGLE_COPY
 89+  576C              ; will put ram in page 0 also, page 1 is already there
 90+  576C              BOXMEMVRM:
 91+  576C              	; opening (
 92+  576C CD EA 5E     	CALL CHKCHAR
 93+  576F 28           	DB '('
 94+  5770              	; get pointer to request struct
 95+  5770 DD 21 2F 54  	LD IX, FRMQNT
 96+  5774 CD 59 01     	CALL CALBAS
 97+  5777 D5           	PUSH DE
 98+  5778              	; ending )
 99+  5778 CD EA 5E     	CALL CHKCHAR
100+  577B 29           	DB ')'
101+  577C
102+  577C DD E1        	POP IX ; pointer to request struct
103+  577E
104+  577E E5           	PUSH HL ; save position in BASIC buffer
105+  577F
106+  577F FD 21 86 57  	LD IY, .RET
107+  5783 C3 9D 5E     	JP ENABLE_PAGE0
108+  5786              .RET:
109+  5786 FB           	EI
110+  5787              	; set RAM functions to call
111+  5787 21 AC 57     	LD HL, .SETDEST
112+  578A 22 1E 57     	LD (RECTANGLE_COPY.CALL1+1), HL
113+  578D 21 B4 57     	LD HL, .COPYDATA
114+  5790 22 21 57     	LD (RECTANGLE_COPY.CALL2+1), HL
115+  5793 3E CD        	LD A, #CD ; CALL
116+  5795 32 1D 57     	LD (RECTANGLE_COPY.CALL1), A
117+  5798 32 20 57     	LD (RECTANGLE_COPY.CALL2), A
118+  579B              	;LD A,1
119+  579B 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
120+  579E CD 05 57     	CALL RECTANGLE_COPY
121+  57A1 AF           	XOR A
122+  57A2 32 4F 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
123+  57A5
124+  57A5 D1               POP DE
125+  57A6 C1               POP BC
126+  57A7 CD 14 5E         CALL RESTORE_PAGE_INFO
127+  57AA
128+  57AA E1           	POP HL
129+  57AB C9           	RET
130+  57AC              .SETDEST:
131+  57AC EB           	EX DE, HL
132+  57AD F3           	DI
133+  57AE CD C4 5D     	CALL SETWRT_LOCAL
134+  57B1 FB           	EI
135+  57B2 EB           	EX DE, HL
136+  57B3 C9           	RET
137+  57B4              .COPYDATA:
138+  57B4 41           	LD B, C
139+  57B5 C3 CF 5D     	JP BBYTECOPY
140+  57B8              ; *******************************************************************************************************
# file closed: asm\BOX.asm
140   57B8               ENDIF
141   57B8
142   57B8               IF (BLIT_CMDS == 1)
143   57B8               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  57B8              ; *******************************************************************************************************
  2+  57B8              ; function rotates mask and data of several characters and applies to background data
  3+  57B8              ; this handles x-shift from 0 to 4
  4+  57B8              ; contains self-modifying code that is set-up from external function
  5+  57B8              ; input HL=pointer to mask data
  6+  57B8              ; input HL'=pointer to character data
  7+  57B8              ; input DE=output buffer containing background data
  8+  57B8              ; input BC=DE+8
  9+  57B8              ; input A=number of characters to process
 10+  57B8              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  57B8              SHIFT04:
 12+  57B8 08           	EX AF, AF'
 13+  57B9 7E           	LD A, (HL) ; get mask
 14+  57BA D9           	EXX
 15+  57BB 57           	LD D, A
 16+  57BC 1E FF        	LD E, #FF
 17+  57BE 37           	SCF
 18+  57BF              .M1:
 19+  57BF 18 FE        	JR .M1 ; this is self-modifying part
 20+  57C1 CB 1A        	RR D
 21+  57C3 CB 1B        	RR E
 22+  57C5 CB 1A        	RR D
 23+  57C7 CB 1B        	RR E
 24+  57C9 CB 1A        	RR D
 25+  57CB CB 1B        	RR E
 26+  57CD CB 1A        	RR D
 27+  57CF CB 1B        	RR E
 28+  57D1
 29+  57D1 46           	LD B, (HL) ; get data
 30+  57D2 0E 00        	LD C, 0
 31+  57D4              .M2:
 32+  57D4 18 FE        	JR .M2 ; also self-modifying part
 33+  57D6 CB 38        	SRL B
 34+  57D8 CB 19        	RR C
 35+  57DA CB 38        	SRL B
 36+  57DC CB 19        	RR C
 37+  57DE CB 38        	SRL B
 38+  57E0 CB 19        	RR C
 39+  57E2 CB 38        	SRL B
 40+  57E4 CB 19        	RR C
 41+  57E6
 42+  57E6 D9           	EXX
 43+  57E7 1A           	LD A, (DE) ; background
 44+  57E8 D9           	EXX
 45+  57E9 A2           	AND D
 46+  57EA B0           	OR B
 47+  57EB D9           	EXX
 48+  57EC 12           	LD (DE), A
 49+  57ED
 50+  57ED 0A           	LD A, (BC)
 51+  57EE D9           	EXX
 52+  57EF A3           	AND E
 53+  57F0 B1           	OR C
 54+  57F1 23           	INC HL
 55+  57F2 D9           	EXX
 56+  57F3 02           	LD (BC), A
 57+  57F4
 58+  57F4 23           	INC HL
 59+  57F5 13           	INC DE
 60+  57F6 03           	INC BC
 61+  57F7
 62+  57F7 08           	EX AF, AF'
 63+  57F8 3D           	DEC A
 64+  57F9 C2 B8 57     	JP NZ, SHIFT04
 65+  57FC C9           	RET
 66+  57FD              ; *******************************************************************************************************
 67+  57FD
 68+  57FD              ; *******************************************************************************************************
 69+  57FD              ; function rotates mask and data of several characters and applies to background data
 70+  57FD              ; this handles x-shift from 5 to 8
 71+  57FD              ; contains self-modifying code that is set-up from external function
 72+  57FD              ; input HL=pointer to mask data
 73+  57FD              ; input HL'=pointer to character data
 74+  57FD              ; input DE=output buffer containing background data
 75+  57FD              ; input BC=DE+8
 76+  57FD              ; input A=number of characters to process
 77+  57FD              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  57FD              SHIFT58:
 79+  57FD 08           	EX AF, AF'
 80+  57FE 7E           	LD A, (HL) ; get mask
 81+  57FF D9           	EXX
 82+  5800 57           	LD D, A
 83+  5801 1E FF        	LD E, #FF
 84+  5803 37           	SCF
 85+  5804              .M1:
 86+  5804 18 FE        	JR .M1 ; this is self-modifying part
 87+  5806 CB 12        	RL D
 88+  5808 CB 13        	RL E
 89+  580A CB 12        	RL D
 90+  580C CB 13        	RL E
 91+  580E CB 12        	RL D
 92+  5810 CB 13        	RL E
 93+  5812
 94+  5812 46           	LD B, (HL)
 95+  5813 0E 00        	LD C, 0
 96+  5815              .M2:
 97+  5815 18 FE        	JR .M2 ; also self-modifying part
 98+  5817 CB 20        	SLA B
 99+  5819 CB 11        	RL C
100+  581B CB 20        	SLA B
101+  581D CB 11        	RL C
102+  581F CB 20        	SLA B
103+  5821 CB 11        	RL C
104+  5823
105+  5823 D9           	EXX
106+  5824 1A           	LD A, (DE) ; background
107+  5825 D9           	EXX
108+  5826 A3           	AND E
109+  5827 B1           	OR C
110+  5828 D9           	EXX
111+  5829 12           	LD (DE), A
112+  582A
113+  582A 0A           	LD A, (BC)
114+  582B D9           	EXX
115+  582C A2           	AND D
116+  582D B0           	OR B
117+  582E 23           	INC HL
118+  582F D9           	EXX
119+  5830 02           	LD (BC), A
120+  5831
121+  5831 23           	INC HL
122+  5832 13           	INC DE
123+  5833 03           	INC BC
124+  5834
125+  5834 08           	EX AF, AF'
126+  5835 3D           	DEC A
127+  5836 C2 FD 57     	JP NZ, SHIFT58
128+  5839 C9           	RET
129+  583A              ; *******************************************************************************************************
130+  583A
131+  583A              ; *******************************************************************************************************
132+  583A              ; routine that shifts one row of characters
133+  583A              ; contains self-modifying code that is set-up from external function
134+  583A              ; input HL=pointer to mask data
135+  583A              ; input HL'=pointer to character data
136+  583A              ; input DE=output buffer containing background data
137+  583A              ; input A=number of characters to process
138+  583A              ; input IX=pointer to structure describing input data
139+  583A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  583A              SHIFT_ROW:
141+  583A F5           	PUSH AF
142+  583B ED 53 3A 5C  		LD (BLIT_TMP1), DE
143+  583F E5           		PUSH HL
144+  5840 CD 83 58     			CALL .ADDYSHIFT
145+  5843 E1           		POP HL
146+  5844 ED 53 3C 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  5848              .L1:
148+  5848 3E 08        		LD A, 8
149+  584A DD 96 02     		SUB (IX+2) ; y shift
150+  584D              .CALL1:
151+  584D CD 00 00     		CALL 0
152+  5850 DD 7E 02     		LD A, (IX+2); y shift
153+  5853 B7           		OR A
154+  5854 28 26        		JR Z, .DONE
155+  5856 ED 5B 3A 5C  		LD DE, (BLIT_TMP1)
156+  585A E5           		PUSH HL
157+  585B CD 91 58     			CALL .DETONEXTROW
158+  585E E1           		POP HL
159+  585F              .CALL2:
160+  585F CD 00 00     		CALL 0
161+  5862 ED 5B 3A 5C  		LD DE, (BLIT_TMP1)
162+  5866 E5           		PUSH HL
163+  5867 CD 8B 58     			CALL .ADD8
164+  586A E1           		POP HL
165+  586B ED 53 3A 5C  		LD (BLIT_TMP1), DE
166+  586F ED 5B 3C 5C  		LD DE, (BLIT_TMP2)
167+  5873 E5           		PUSH HL
168+  5874 CD 8B 58     			CALL .ADD8
169+  5877 E1           		POP HL
170+  5878 ED 53 3C 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  587C              .DONE:
172+  587C F1           	POP AF
173+  587D 3D           	DEC A
174+  587E C8           	RET Z
175+  587F F5           	PUSH AF
176+  5880 C3 48 58     	JP .L1
177+  5883              .ADDYSHIFT:
178+  5883 EB           	EX DE, HL
179+  5884 16 00        	LD D, 0
180+  5886 DD 5E 02     	LD E, (IX+2); y shift
181+  5889 18 0C        	JR .MOVDEBC
182+  588B              .ADD8:
183+  588B 21 08 00     	LD HL, 8
184+  588E C3 97 58     	JP .MOVDEBC
185+  5891              .DETONEXTROW:
186+  5891 DD 6E 06     	LD L, (IX+6)
187+  5894 DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5897              .MOVDEBC:
189+  5897 19           	ADD HL, DE
190+  5898 54           	LD D, H
191+  5899 5D           	LD E, L
192+  589A 01 08 00     	LD BC, 8
193+  589D 09           	ADD HL, BC
194+  589E 44           	LD B, H
195+  589F 4D           	LD C, L
196+  58A0 C9           	RET
197+  58A1              ; *******************************************************************************************************
198+  58A1
199+  58A1              ; *******************************************************************************************************
200+  58A1              ; function rotates mask and character data and applies it to background
201+  58A1              ; input IX=pointer to structure describing input data
202+  58A1              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  58A1              ; +2  DW vertical shift count 0-7 (low byte used)
204+  58A1              ; +4  DW background data start;
205+  58A1              ; +6  DW background add to value to next row of background data
206+  58A1              ; +8  DW mask data start;
207+  58A1              ; +10  DW character data start;
208+  58A1              ; +12 DW character&mask add to value to next row of data
209+  58A1              ; +14 DW columns (low byte used)
210+  58A1              ; +16 DW rows (low byte used)
211+  58A1              SHIFT_MERGE_CHARACTER:
212+  58A1 DD 7E 00     	LD A, (IX) ; shift
213+  58A4 FE 05        	CP 5
214+  58A6 38 25        	JR C, .RIGHT
215+  58A8              	; shifts 5-7, use rotate towards left 1-3
216+  58A8 21 FD 57     	LD HL, SHIFT58
217+  58AB 22 4E 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  58AE 22 60 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  58B1 D6 05        	SUB 5
220+  58B3 28 0D        	JR Z, .L1
221+  58B5 87           	ADD A, A
222+  58B6 87           	ADD A, A
223+  58B7 67           	LD H, A
224+  58B8 2E 18        	LD L, #18 ; JR opcode
225+  58BA 22 04 58     	LD (SHIFT58.M1), HL
226+  58BD 22 15 58     	LD (SHIFT58.M2), HL
227+  58C0 18 32        	JR .DO
228+  58C2              .L1:
229+  58C2 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  58C5 22 04 58     	LD (SHIFT58.M1), HL
231+  58C8 22 15 58     	LD (SHIFT58.M2), HL
232+  58CB 18 27        	JR .DO
233+  58CD              .RIGHT:
234+  58CD              	; shifts 0-4, rotate towards right
235+  58CD 21 B8 57     	LD HL, SHIFT04
236+  58D0 22 4E 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  58D3 22 60 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  58D6 FE 04        	CP 4
239+  58D8 28 11        	JR Z, .R1
240+  58DA D6 04        	SUB 4
241+  58DC ED 44        	NEG
242+  58DE 87           	ADD A, A
243+  58DF 87           	ADD A, A
244+  58E0 67           	LD H, A
245+  58E1 2E 18        	LD L, #18 ; JR opcode
246+  58E3 22 BF 57     	LD (SHIFT04.M1), HL
247+  58E6 22 D4 57     	LD (SHIFT04.M2), HL
248+  58E9 18 09        	JR .DO
249+  58EB              .R1:
250+  58EB 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  58EE 22 BF 57     	LD (SHIFT04.M1), HL
252+  58F1 22 D4 57     	LD (SHIFT04.M2), HL
253+  58F4              .DO:
254+  58F4 DD 46 10     	LD B, (IX+16) ; rows
255+  58F7 DD 6E 08     	LD L, (IX+8)
256+  58FA DD 66 09     	LD H, (IX+9) ; mask data
257+  58FD DD 5E 04     	LD E, (IX+4)
258+  5900 DD 56 05     	LD D, (IX+5) ; background data
259+  5903 D9           	EXX
260+  5904 DD 6E 0A     	LD L, (IX+10)
261+  5907 DD 66 0B     	LD H, (IX+11) ; character data
262+  590A D9           	EXX
263+  590B              .LOOP:
264+  590B C5           	PUSH BC
265+  590C E5           		PUSH HL
266+  590D D5           			PUSH DE
267+  590E D9           				EXX
268+  590F E5           				PUSH HL
269+  5910 D9           					EXX
270+  5911 DD 7E 0E     					LD A, (IX+14) ; columns
271+  5914              .CALL:
272+  5914 CD 3A 58     					CALL SHIFT_ROW
273+  5917 E1           				POP HL
274+  5918 DD 5E 0C     				LD E, (IX+12)
275+  591B DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  591E 19           				ADD HL, DE
277+  591F D9           				EXX
278+  5920 E1           			POP HL
279+  5921 DD 5E 06     			LD E, (IX+6)
280+  5924 DD 56 07     			LD D, (IX+7) ; background to next row
281+  5927 19           			ADD HL, DE
282+  5928 EB           			EX DE, HL
283+  5929 E1           		POP HL
284+  592A DD 4E 0C     		LD C, (IX+12)
285+  592D DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  5930 09           		ADD HL, BC
287+  5931 C1           	POP BC
288+  5932 10 D7        	DJNZ .LOOP
289+  5934 C9           	RET
290+  5935              ; *******************************************************************************************************
291+  5935
292+  5935               IFNDEF CMDS_WITH_PARAMETERS
293+  5935 ~            ; *******************************************************************************************************
294+  5935 ~            ; function to handle CALL BLIT basic extension
295+  5935 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  5935 ~            ; fuses with background data and applies vertical shift too
297+  5935 ~            ; BLIT ( INT request_data_ptr )
298+  5935 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  5935 ~            ; will put ram in page 0 also, page 1 is already there
300+  5935 ~            BLIT:
301+  5935 ~            	; opening (
302+  5935 ~            	CALL CHKCHAR
303+  5935 ~            	DB '('
304+  5935 ~            	; get pointer to request struct
305+  5935 ~            	LD IX, FRMQNT
306+  5935 ~            	CALL CALBAS
307+  5935 ~            	PUSH DE
308+  5935 ~            	; ending )
309+  5935 ~            	CALL CHKCHAR
310+  5935 ~            	DB ')'
311+  5935 ~
312+  5935 ~            	POP IX ; pointer to request struct
313+  5935 ~
314+  5935 ~            	PUSH HL ; save position in BASIC buffer
315+  5935 ~
316+  5935 ~            	LD IY, .RET
317+  5935 ~            	JP ENABLE_PAGE0
318+  5935 ~            .RET:
319+  5935 ~            	EI
320+  5935 ~            	CALL SHIFT_MERGE_CHARACTER
321+  5935 ~
322+  5935 ~                POP DE
323+  5935 ~                POP BC
324+  5935 ~                CALL RESTORE_PAGE_INFO
325+  5935 ~
326+  5935 ~            	POP HL
327+  5935 ~            	RET
328+  5935 ~            ; *******************************************************************************************************
329+  5935               ENDIF
330+  5935
331+  5935               IFDEF CMDS_WITH_PARAMETERS
332+  5935              ; *******************************************************************************************************
333+  5935              ; function to handle CALL BLIT basic extension
334+  5935              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  5935              ; fuses with background data and applies vertical shift too
336+  5935              ; in form without pointers
337+  5935              ; BLIT ( INT x,
338+  5935              ;		 INT y,
339+  5935              ;		 INT char_data_pointer,
340+  5935              ;		 INT mask_data_pointer,
341+  5935              ;		 INT width (in characters),
342+  5935              ;		 INT height (in characters),
343+  5935              ;		 INT background_pointer (top left),
344+  5935              ;		 INT background_width (in characters),
345+  5935              ;		 INT background_height (in characters))
346+  5935              ; will put ram in page 0 also, page 1 is already there
347+  5935              BLIT:
348+  5935              	; opening (
349+  5935 CD EA 5E     	CALL CHKCHAR
350+  5938 28           	DB '('
351+  5939              	; get x coordinate
352+  5939 DD 21 2F 54  	LD IX, FRMQNT
353+  593D CD 59 01     	CALL CALBAS
354+  5940 7B           	LD A, E
355+  5941 E6 07        	AND 7
356+  5943 32 3E 5C     	LD (BLIT_STRUCT+0), A
357+  5946 CD 23 5A     	CALL .DAdiv8
358+  5949 32 3A 5C     	LD (BLIT_TMP+0),A
359+  594C              	; comma
360+  594C CD EA 5E     	CALL CHKCHAR
361+  594F 2C           	DB ','
362+  5950              	; get y coordinate
363+  5950 DD 21 2F 54  	LD IX, FRMQNT
364+  5954 CD 59 01     	CALL CALBAS
365+  5957 7B           	LD A, E
366+  5958 E6 07        	AND 7
367+  595A 32 40 5C     	LD (BLIT_STRUCT+2), A
368+  595D CD 23 5A     	CALL .DAdiv8
369+  5960 32 3B 5C     	LD (BLIT_TMP+1),A
370+  5963              	; comma
371+  5963 CD EA 5E     	CALL CHKCHAR
372+  5966 2C           	DB ','
373+  5967              	; get char data pointer
374+  5967 DD 21 2F 54  	LD IX, FRMQNT
375+  596B CD 59 01     	CALL CALBAS
376+  596E ED 53 48 5C  	LD (BLIT_STRUCT+10), DE
377+  5972              	; comma
378+  5972 CD EA 5E     	CALL CHKCHAR
379+  5975 2C           	DB ','
380+  5976              	; get mask data pointer
381+  5976 DD 21 2F 54  	LD IX, FRMQNT
382+  597A CD 59 01     	CALL CALBAS
383+  597D ED 53 46 5C  	LD (BLIT_STRUCT+8), DE
384+  5981              	; comma
385+  5981 CD EA 5E     	CALL CHKCHAR
386+  5984 2C           	DB ','
387+  5985              	; get width
388+  5985 DD 21 2F 54  	LD IX, FRMQNT
389+  5989 CD 59 01     	CALL CALBAS
390+  598C 7B           	LD A, E
391+  598D 32 4C 5C     	LD (BLIT_STRUCT+14), A
392+  5990              	; comma
393+  5990 CD EA 5E     	CALL CHKCHAR
394+  5993 2C           	DB ','
395+  5994              	; get height
396+  5994 DD 21 2F 54  	LD IX, FRMQNT
397+  5998 CD 59 01     	CALL CALBAS
398+  599B 7B           	LD A, E
399+  599C 32 4E 5C     	LD (BLIT_STRUCT+16), A
400+  599F              	; comma
401+  599F CD EA 5E     	CALL CHKCHAR
402+  59A2 2C           	DB ','
403+  59A3              	; get background pointer
404+  59A3 DD 21 2F 54  	LD IX, FRMQNT
405+  59A7 CD 59 01     	CALL CALBAS
406+  59AA ED 53 42 5C  	LD (BLIT_STRUCT+4), DE
407+  59AE              	; comma
408+  59AE CD EA 5E     	CALL CHKCHAR
409+  59B1 2C           	DB ','
410+  59B2              	; get background width
411+  59B2 DD 21 2F 54  	LD IX, FRMQNT
412+  59B6 CD 59 01     	CALL CALBAS
413+  59B9 7B           	LD A, E
414+  59BA 32 3C 5C     	LD (BLIT_TMP+2), A
415+  59BD              	; comma
416+  59BD CD EA 5E     	CALL CHKCHAR
417+  59C0 2C           	DB ','
418+  59C1              	; get background height
419+  59C1 DD 21 2F 54  	LD IX, FRMQNT
420+  59C5 CD 59 01     	CALL CALBAS
421+  59C8 7B           	LD A, E
422+  59C9 32 3D 5C     	LD (BLIT_TMP+3), A
423+  59CC              	; ending )
424+  59CC CD EA 5E     	CALL CHKCHAR
425+  59CF 29           	DB ')'
426+  59D0
427+  59D0 E5           	PUSH HL ; save position in BASIC buffer
428+  59D1
429+  59D1              	; calculate char&mask add to value
430+  59D1 26 00        	LD H, 0
431+  59D3 3A 4C 5C     	LD A, (BLIT_STRUCT+14)
432+  59D6 6F           	LD L, A
433+  59D7 CD D9 5D     	CALL HLx8
434+  59DA 22 4A 5C     	LD (BLIT_STRUCT+12), HL
435+  59DD              	; calculate background add to value
436+  59DD 26 00        	LD H, 0
437+  59DF 3A 3C 5C     	LD A, (BLIT_TMP+2)
438+  59E2 6F           	LD L, A
439+  59E3 CD D9 5D     	CALL HLx8
440+  59E6 22 44 5C     	LD (BLIT_STRUCT+6), HL
441+  59E9              	; calculate pointer to background location
442+  59E9 21 00 00     	LD HL, 0
443+  59EC 3A 3B 5C     	LD A,(BLIT_TMP+1)
444+  59EF B7           	OR A
445+  59F0 28 08        	JR Z, .L1
446+  59F2 47           	LD B,A
447+  59F3 ED 5B 44 5C  	LD DE,(BLIT_STRUCT+6)
448+  59F7              .L0:
449+  59F7 19           	ADD HL, DE
450+  59F8 10 FD        	DJNZ .L0
451+  59FA              .L1:
452+  59FA EB           	EX DE,HL
453+  59FB 26 00        	LD H,0
454+  59FD 3A 3A 5C     	LD A,(BLIT_TMP+0)
455+  5A00 6F           	LD L,A
456+  5A01 CD D9 5D     	CALL HLx8
457+  5A04 19           	ADD HL,DE
458+  5A05 ED 5B 42 5C  	LD DE,(BLIT_STRUCT+4)
459+  5A09 19           	ADD HL,DE
460+  5A0A 22 42 5C     	LD (BLIT_STRUCT+4),HL
461+  5A0D
462+  5A0D FD 21 14 5A  	LD IY, .RET
463+  5A11 C3 9D 5E     	JP ENABLE_PAGE0
464+  5A14              .RET:
465+  5A14 FB           	EI
466+  5A15 DD 21 3E 5C  	LD IX, BLIT_STRUCT
467+  5A19 CD A1 58     	CALL SHIFT_MERGE_CHARACTER
468+  5A1C
469+  5A1C D1               POP DE
470+  5A1D C1               POP BC
471+  5A1E CD 14 5E         CALL RESTORE_PAGE_INFO
472+  5A21
473+  5A21 E1           	POP HL
474+  5A22 C9           	RET
475+  5A23              .DAdiv8:
476+  5A23 7B           	LD A,E
477+  5A24 CB 2A        	SRA D
478+  5A26 CB 1F            RR  A
479+  5A28 CB 2A            SRA D
480+  5A2A CB 1F            RR  A
481+  5A2C CB 2A            SRA D
482+  5A2E CB 1F            RR  A
483+  5A30 C9           	RET
484+  5A31              ; *******************************************************************************************************
485+  5A31               ENDIF
# file closed: asm\BLIT.asm
144   5A31               ENDIF
145   5A31
146   5A31               IF (TILE_CMDS == 1)
147   5A31               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5A31              ; *******************************************************************************************************
  2+  5A31              ; generic function to implement tiling
  3+  5A31              ; should be modified to call appropriate function for memory or vram
  4+  5A31              ; input IX=pointer to following structure
  5+  5A31              ; +00 tile_data_ptr
  6+  5A31              ; +02 tile_rows
  7+  5A31              ; +04 tile_columns
  8+  5A31              ; +06 destination_address
  9+  5A31              ; +08 dest_to_next_row_add_to_value
 10+  5A31              ; +10 num_horizontal_tiles
 11+  5A31              ; +12 num_vertical_tiles
 12+  5A31              ; modifies AF, BC, DE, HL
 13+  5A31              TILE:
 14+  5A31 DD 6E 06     	LD L, (IX+6)
 15+  5A34 DD 66 07     	LD H, (IX+7) ; destination address
 16+  5A37 22 3A 5C     	LD (TILETMP1), HL
 17+  5A3A DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5A3D              .L1:
 19+  5A3D C5           	PUSH BC
 20+  5A3E DD 6E 00     		LD L, (IX+0)
 21+  5A41 DD 66 01     		LD H, (IX+1) ; tile address
 22+  5A44 22 3C 5C     		LD (TILETMP2), HL
 23+  5A47 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5A4A              .L2:
 25+  5A4A C5           		PUSH BC
 26+  5A4B CD 00 00     .CALL1:		CALL 0
 27+  5A4E DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5A51              .L3:
 29+  5A51 C5           			PUSH BC
 30+  5A52 2A 3C 5C     				LD HL, (TILETMP2)
 31+  5A55 DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5A58              .L4:
 33+  5A58 C5           				PUSH BC
 34+  5A59              .CALL2:
 35+  5A59 CD 00 00     					CALL 0
 36+  5A5C C1           				POP BC
 37+  5A5D 10 F9        				DJNZ .L4
 38+  5A5F C1           			POP BC
 39+  5A60 10 EF        			DJNZ .L3
 40+  5A62 22 3C 5C     			LD (TILETMP2), HL
 41+  5A65 2A 3A 5C     			LD HL, (TILETMP1)
 42+  5A68 DD 5E 08     			LD E, (IX+8)
 43+  5A6B DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5A6E 19           			ADD HL, DE
 45+  5A6F 22 3A 5C     			LD (TILETMP1), HL
 46+  5A72 C1           		POP BC
 47+  5A73 10 D5        		DJNZ .L2
 48+  5A75 C1           	POP BC
 49+  5A76 10 C5        	DJNZ .L1
 50+  5A78 C9           	RET
 51+  5A79              ; *******************************************************************************************************
 52+  5A79
 53+  5A79               IFNDEF CMDS_WITH_PARAMETERS
 54+  5A79 ~            ; *******************************************************************************************************
 55+  5A79 ~            ; function to handle CALL TILERAM basic extension
 56+  5A79 ~            ; fills memory with tiles
 57+  5A79 ~            ; TILERAM ( INT request_data_ptr )
 58+  5A79 ~            ; request_data_ptr described in TILE
 59+  5A79 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5A79 ~            TILERAM:
 61+  5A79 ~            	; opening (
 62+  5A79 ~            	CALL CHKCHAR
 63+  5A79 ~            	DB '('
 64+  5A79 ~            	; get pointer to request struct
 65+  5A79 ~            	LD IX, FRMQNT
 66+  5A79 ~            	CALL CALBAS
 67+  5A79 ~            	PUSH DE
 68+  5A79 ~            	; ending )
 69+  5A79 ~            	CALL CHKCHAR
 70+  5A79 ~            	DB ')'
 71+  5A79 ~
 72+  5A79 ~            	POP IX ; pointer to request struct
 73+  5A79 ~
 74+  5A79 ~            	PUSH HL ; save position in BASIC buffer
 75+  5A79 ~
 76+  5A79 ~            	LD IY, .RET
 77+  5A79 ~            	JP ENABLE_PAGE0
 78+  5A79 ~            .RET:
 79+  5A79 ~            	EI
 80+  5A79 ~            	; set RAM functions to call
 81+  5A79 ~            	LD HL, .TILECOPY
 82+  5A79 ~            	LD (TILE.CALL2+1), HL
 83+  5A79 ~            	LD HL, .SETDESTROW
 84+  5A79 ~            	LD (TILE.CALL1+1), HL
 85+  5A79 ~            	LD A,1
 86+  5A79 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5A79 ~            	CALL TILE
 88+  5A79 ~            	XOR A
 89+  5A79 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5A79 ~
 91+  5A79 ~                POP DE
 92+  5A79 ~                POP BC
 93+  5A79 ~                CALL RESTORE_PAGE_INFO
 94+  5A79 ~
 95+  5A79 ~            	POP HL
 96+  5A79 ~            	RET
 97+  5A79 ~            .TILECOPY:
 98+  5A79 ~            	.8 LDI
 99+  5A79 ~            	RET
100+  5A79 ~            .SETDESTROW:
101+  5A79 ~            	LD DE, (TILETMP1)
102+  5A79 ~            	RET
103+  5A79 ~            ; *******************************************************************************************************
104+  5A79               ENDIF
105+  5A79
106+  5A79               IFDEF CMDS_WITH_PARAMETERS
107+  5A79              ; *******************************************************************************************************
108+  5A79              ; function to handle CALL TILERAM basic extension
109+  5A79              ; fills memory with tiles
110+  5A79              ; TILERAM ( INT tile_data_pointer,
111+  5A79              ;			INT tile_columns,
112+  5A79              ;			INT tile_rows,
113+  5A79              ;			INT destination_pointer,
114+  5A79              ;			INT destination_columns,
115+  5A79              ;			INT destination_rows,
116+  5A79              ;			INT destination_begin_column,
117+  5A79              ;			INT destination_begin_row,
118+  5A79              ;			INT number_of_tiles_horizontally,
119+  5A79              ;			INT	number_of_tiles_vertically )
120+  5A79              ; will put ram in page 0 also, page 1 is already there
121+  5A79              TILERAM:
122+  5A79              	; opening (
123+  5A79 CD EA 5E     	CALL CHKCHAR
124+  5A7C 28           	DB '('
125+  5A7D              	; get tile data pointer coordinate
126+  5A7D DD 21 2F 54  	LD IX, FRMQNT
127+  5A81 CD 59 01     	CALL CALBAS
128+  5A84 ED 53 3E 5C  	LD (BLIT_STRUCT+0), DE
129+  5A88              	; comma
130+  5A88 CD EA 5E     	CALL CHKCHAR
131+  5A8B 2C           	DB ','
132+  5A8C              	; get tile columns
133+  5A8C DD 21 2F 54  	LD IX, FRMQNT
134+  5A90 CD 59 01     	CALL CALBAS
135+  5A93 ED 53 42 5C  	LD (BLIT_STRUCT+4), DE
136+  5A97              	; comma
137+  5A97 CD EA 5E     	CALL CHKCHAR
138+  5A9A 2C           	DB ','
139+  5A9B              	; get tile columns
140+  5A9B DD 21 2F 54  	LD IX, FRMQNT
141+  5A9F CD 59 01     	CALL CALBAS
142+  5AA2 ED 53 40 5C  	LD (BLIT_STRUCT+2), DE
143+  5AA6              	; comma
144+  5AA6 CD EA 5E     	CALL CHKCHAR
145+  5AA9 2C           	DB ','
146+  5AAA              	; get destintion pointer
147+  5AAA DD 21 2F 54  	LD IX, FRMQNT
148+  5AAE CD 59 01     	CALL CALBAS
149+  5AB1 ED 53 44 5C  	LD (BLIT_STRUCT+6), DE
150+  5AB5              	; comma
151+  5AB5 CD EA 5E     	CALL CHKCHAR
152+  5AB8 2C           	DB ','
153+  5AB9              	; get destination columns
154+  5AB9 DD 21 2F 54  	LD IX, FRMQNT
155+  5ABD CD 59 01     	CALL CALBAS
156+  5AC0 7B           	LD A, E
157+  5AC1 32 3A 5C     	LD (BLIT_TMP+0), A
158+  5AC4              	; comma
159+  5AC4 CD EA 5E     	CALL CHKCHAR
160+  5AC7 2C           	DB ','
161+  5AC8              	; get destination rows
162+  5AC8 DD 21 2F 54  	LD IX, FRMQNT
163+  5ACC CD 59 01     	CALL CALBAS
164+  5ACF 7B           	LD A, E
165+  5AD0 32 3B 5C     	LD (BLIT_TMP+1), A
166+  5AD3              	; comma
167+  5AD3 CD EA 5E     	CALL CHKCHAR
168+  5AD6 2C           	DB ','
169+  5AD7              	; get destination begin column
170+  5AD7 DD 21 2F 54  	LD IX, FRMQNT
171+  5ADB CD 59 01     	CALL CALBAS
172+  5ADE 7B           	LD A, E
173+  5ADF 32 3C 5C     	LD (BLIT_TMP+2), A
174+  5AE2              	; comma
175+  5AE2 CD EA 5E     	CALL CHKCHAR
176+  5AE5 2C           	DB ','
177+  5AE6              	; get destination begin row
178+  5AE6 DD 21 2F 54  	LD IX, FRMQNT
179+  5AEA CD 59 01     	CALL CALBAS
180+  5AED 7B           	LD A, E
181+  5AEE 32 3D 5C     	LD (BLIT_TMP+3), A
182+  5AF1              	; comma
183+  5AF1 CD EA 5E     	CALL CHKCHAR
184+  5AF4 2C           	DB ','
185+  5AF5              	; get number of tiles horizontally
186+  5AF5 DD 21 2F 54  	LD IX, FRMQNT
187+  5AF9 CD 59 01     	CALL CALBAS
188+  5AFC ED 53 48 5C  	LD (BLIT_STRUCT+10), DE
189+  5B00              	; comma
190+  5B00 CD EA 5E     	CALL CHKCHAR
191+  5B03 2C           	DB ','
192+  5B04              	; get number of tiles vertically
193+  5B04 DD 21 2F 54  	LD IX, FRMQNT
194+  5B08 CD 59 01     	CALL CALBAS
195+  5B0B ED 53 4A 5C  	LD (BLIT_STRUCT+12), DE
196+  5B0F              	; ending )
197+  5B0F CD EA 5E     	CALL CHKCHAR
198+  5B12 29           	DB ')'
199+  5B13
200+  5B13 E5           	PUSH HL ; save position in BASIC buffer
201+  5B14
202+  5B14              	; calculate destination add to value
203+  5B14 26 00        	LD H, 0
204+  5B16 3A 3A 5C     	LD A, (BLIT_TMP+0)
205+  5B19 6F           	LD L, A
206+  5B1A CD D9 5D     	CALL HLx8
207+  5B1D 22 46 5C     	LD (BLIT_STRUCT+8), HL
208+  5B20              	; calculate pointer to background location
209+  5B20 21 00 00     	LD HL, 0
210+  5B23 3A 3D 5C     	LD A,(BLIT_TMP+3)
211+  5B26 B7           	OR A
212+  5B27 28 08        	JR Z, .L1
213+  5B29 47           	LD B,A
214+  5B2A ED 5B 46 5C  	LD DE,(BLIT_STRUCT+8)
215+  5B2E              .L0:
216+  5B2E 19           	ADD HL, DE
217+  5B2F 10 FD        	DJNZ .L0
218+  5B31              .L1:
219+  5B31 EB           	EX DE,HL
220+  5B32 26 00        	LD H,0
221+  5B34 3A 3C 5C     	LD A,(BLIT_TMP+2)
222+  5B37 6F           	LD L,A
223+  5B38 CD D9 5D     	CALL HLx8
224+  5B3B 19           	ADD HL,DE
225+  5B3C ED 5B 44 5C  	LD DE,(BLIT_STRUCT+6)
226+  5B40 19           	ADD HL,DE
227+  5B41 22 44 5C     	LD (BLIT_STRUCT+6),HL
228+  5B44
229+  5B44 FD 21 4B 5B  	LD IY, .RET
230+  5B48 C3 9D 5E     	JP ENABLE_PAGE0
231+  5B4B              .RET:
232+  5B4B FB           	EI
233+  5B4C              	; set RAM functions to call
234+  5B4C 21 66 5B     	LD HL, .TILECOPY
235+  5B4F 22 5A 5A     	LD (TILE.CALL2+1), HL
236+  5B52 21 77 5B     	LD HL, .SETDESTROW
237+  5B55 22 4C 5A     	LD (TILE.CALL1+1), HL
238+  5B58 DD 21 3E 5C  	LD IX,BLIT_STRUCT
239+  5B5C CD 31 5A     	CALL TILE
240+  5B5F
241+  5B5F D1               POP DE
242+  5B60 C1               POP BC
243+  5B61 CD 14 5E         CALL RESTORE_PAGE_INFO
244+  5B64
245+  5B64 E1           	POP HL
246+  5B65 C9           	RET
247+  5B66              .TILECOPY:
248+  5B66 ED A0       > LDI
248+  5B68 ED A0       > LDI
248+  5B6A ED A0       > LDI
248+  5B6C ED A0       > LDI
248+  5B6E ED A0       > LDI
248+  5B70 ED A0       > LDI
248+  5B72 ED A0       > LDI
248+  5B74 ED A0       > LDI
249+  5B76 C9           	RET
250+  5B77              .SETDESTROW:
251+  5B77 ED 5B 3A 5C  	LD DE, (TILETMP1)
252+  5B7B C9           	RET
253+  5B7C              ; *******************************************************************************************************
254+  5B7C               ENDIF
255+  5B7C
256+  5B7C               IFDEF CMDS_WITH_PARAMETERS
257+  5B7C              ; *******************************************************************************************************
258+  5B7C              ; function to handle CALL TILEVRM basic extension
259+  5B7C              ; fills vram with tiles
260+  5B7C              ; TILEVRM ( INT tile_data_pointer,
261+  5B7C              ;			INT tile_columns,
262+  5B7C              ;			INT tile_rows,
263+  5B7C              ;			INT destination_begin_column,
264+  5B7C              ;			INT destination_begin_row,
265+  5B7C              ;			INT number_of_tiles_horizontally,
266+  5B7C              ;			INT	number_of_tiles_vertically )
267+  5B7C              ; will put ram in page 0 also, page 1 is already there
268+  5B7C              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5B7C              TILEVRM:
270+  5B7C              	; opening (
271+  5B7C CD EA 5E     	CALL CHKCHAR
272+  5B7F 28           	DB '('
273+  5B80              	; get tile data pointer coordinate
274+  5B80 DD 21 2F 54  	LD IX, FRMQNT
275+  5B84 CD 59 01     	CALL CALBAS
276+  5B87 ED 53 3E 5C  	LD (BLIT_STRUCT+0), DE
277+  5B8B              	; comma
278+  5B8B CD EA 5E     	CALL CHKCHAR
279+  5B8E 2C           	DB ','
280+  5B8F              	; get tile columns
281+  5B8F DD 21 2F 54  	LD IX, FRMQNT
282+  5B93 CD 59 01     	CALL CALBAS
283+  5B96 ED 53 42 5C  	LD (BLIT_STRUCT+4), DE
284+  5B9A              	; comma
285+  5B9A CD EA 5E     	CALL CHKCHAR
286+  5B9D 2C           	DB ','
287+  5B9E              	; get tile columns
288+  5B9E DD 21 2F 54  	LD IX, FRMQNT
289+  5BA2 CD 59 01     	CALL CALBAS
290+  5BA5 ED 53 40 5C  	LD (BLIT_STRUCT+2), DE
291+  5BA9              	; comma
292+  5BA9 CD EA 5E     	CALL CHKCHAR
293+  5BAC 2C           	DB ','
294+  5BAD              	; get destination begin column
295+  5BAD DD 21 2F 54  	LD IX, FRMQNT
296+  5BB1 CD 59 01     	CALL CALBAS
297+  5BB4 7B           	LD A, E
298+  5BB5 32 3C 5C     	LD (BLIT_TMP+2), A
299+  5BB8              	; comma
300+  5BB8 CD EA 5E     	CALL CHKCHAR
301+  5BBB 2C           	DB ','
302+  5BBC              	; get destination begin row
303+  5BBC DD 21 2F 54  	LD IX, FRMQNT
304+  5BC0 CD 59 01     	CALL CALBAS
305+  5BC3 7B           	LD A, E
306+  5BC4 32 3D 5C     	LD (BLIT_TMP+3), A
307+  5BC7              	; comma
308+  5BC7 CD EA 5E     	CALL CHKCHAR
309+  5BCA 2C           	DB ','
310+  5BCB              	; get number of tiles horizontally
311+  5BCB DD 21 2F 54  	LD IX, FRMQNT
312+  5BCF CD 59 01     	CALL CALBAS
313+  5BD2 ED 53 48 5C  	LD (BLIT_STRUCT+10), DE
314+  5BD6              	; comma
315+  5BD6 CD EA 5E     	CALL CHKCHAR
316+  5BD9 2C           	DB ','
317+  5BDA              	; get number of tiles vertically
318+  5BDA DD 21 2F 54  	LD IX, FRMQNT
319+  5BDE CD 59 01     	CALL CALBAS
320+  5BE1 ED 53 4A 5C  	LD (BLIT_STRUCT+12), DE
321+  5BE5              	; ending )
322+  5BE5 CD EA 5E     	CALL CHKCHAR
323+  5BE8 29           	DB ')'
324+  5BE9
325+  5BE9 E5           	PUSH HL ; save position in BASIC buffer
326+  5BEA
327+  5BEA              	; calculate destination add to value
328+  5BEA 21 00 01     	LD HL, 256
329+  5BED 22 46 5C     	LD (BLIT_STRUCT+8), HL
330+  5BF0              	; calculate pointer to background location
331+  5BF0 3A 3D 5C     	LD A,(BLIT_TMP+3)
332+  5BF3 67           	LD H,A
333+  5BF4 2E 00        	LD L,0
334+  5BF6 EB           	EX DE,HL
335+  5BF7 26 00        	LD H,0
336+  5BF9 3A 3C 5C     	LD A,(BLIT_TMP+2)
337+  5BFC 6F           	LD L,A
338+  5BFD CD D9 5D     	CALL HLx8
339+  5C00 19           	ADD HL,DE
340+  5C01 ED 5B CB F3  	LD DE,(GRPCGP)
341+  5C05 19           	ADD HL,DE
342+  5C06 22 44 5C     	LD (BLIT_STRUCT+6),HL
343+  5C09
344+  5C09 FD 21 10 5C  	LD IY, .RET
345+  5C0D C3 9D 5E     	JP ENABLE_PAGE0
346+  5C10              .RET:
347+  5C10 FB           	EI
348+  5C11              	; set RAM functions to call
349+  5C11 21 2B 5C     	LD HL, .TILECOPY
350+  5C14 22 5A 5A     	LD (TILE.CALL2+1), HL
351+  5C17 21 31 5C     	LD HL, .SETDESTROW
352+  5C1A 22 4C 5A     	LD (TILE.CALL1+1), HL
353+  5C1D DD 21 3E 5C  	LD IX,BLIT_STRUCT
354+  5C21 CD 31 5A     	CALL TILE
355+  5C24
356+  5C24 D1               POP DE
357+  5C25 C1               POP BC
358+  5C26 CD 14 5E         CALL RESTORE_PAGE_INFO
359+  5C29
360+  5C29 E1           	POP HL
361+  5C2A C9           	RET
362+  5C2B              .TILECOPY:
363+  5C2B 01 98 08     	LD BC, #0898
364+  5C2E C3 D1 5D     	JP BBYTECOPY_NO_C
365+  5C31              .SETDESTROW:
366+  5C31 2A 3A 5C     	LD HL, (TILETMP1)
367+  5C34 F3           	DI
368+  5C35 CD C4 5D     	CALL SETWRT_LOCAL
369+  5C38 FB           	EI
370+  5C39 C9           	RET
371+  5C3A              ; *******************************************************************************************************
372+  5C3A               ENDIF
373+  5C3A
374+  5C3A               IFNDEF CMDS_WITH_PARAMETERS
375+  5C3A ~            ; *******************************************************************************************************
376+  5C3A ~            ; function to handle CALL TILEVRM basic extension
377+  5C3A ~            ; fills vram with tiles
378+  5C3A ~            ; TILEVRM ( INT request_data_ptr )
379+  5C3A ~            ; request_data_ptr described in TILE
380+  5C3A ~            ; will put ram in page 0 also, page 1 is already there
381+  5C3A ~            TILEVRM:
382+  5C3A ~            	; opening (
383+  5C3A ~            	CALL CHKCHAR
384+  5C3A ~            	DB '('
385+  5C3A ~            	; get pointer to request struct
386+  5C3A ~            	LD IX, FRMQNT
387+  5C3A ~            	CALL CALBAS
388+  5C3A ~            	PUSH DE
389+  5C3A ~            	; ending )
390+  5C3A ~            	CALL CHKCHAR
391+  5C3A ~            	DB ')'
392+  5C3A ~
393+  5C3A ~            	POP IX ; pointer to request struct
394+  5C3A ~
395+  5C3A ~            	PUSH HL ; save position in BASIC buffer
396+  5C3A ~
397+  5C3A ~            	LD IY, .RET
398+  5C3A ~            	JP ENABLE_PAGE0
399+  5C3A ~            .RET:
400+  5C3A ~            	EI
401+  5C3A ~            	; set RAM functions to call
402+  5C3A ~            	LD HL, .TILECOPY
403+  5C3A ~            	LD (TILE.CALL2+1), HL
404+  5C3A ~            	LD HL, .SETDESTROW
405+  5C3A ~            	LD (TILE.CALL1+1), HL
406+  5C3A ~            	CALL TILE
407+  5C3A ~
408+  5C3A ~                POP DE
409+  5C3A ~                POP BC
410+  5C3A ~                CALL RESTORE_PAGE_INFO
411+  5C3A ~
412+  5C3A ~            	POP HL
413+  5C3A ~            	RET
414+  5C3A ~            .TILECOPY:
415+  5C3A ~            	LD BC, #0898
416+  5C3A ~            	JP BBYTECOPY_NO_C
417+  5C3A ~            .SETDESTROW:
418+  5C3A ~            	LD HL, (TILETMP1)
419+  5C3A ~            	DI
420+  5C3A ~            	CALL SETWRT_LOCAL
421+  5C3A ~            	EI
422+  5C3A ~            	RET
423+  5C3A ~            ; *******************************************************************************************************
424+  5C3A               ENDIF
# file closed: asm\TILE.asm
148   5C3A               ENDIF
149   5C3A
150   5C3A              ; temp variables for BLIT, TILE functions
151   5C3A               IF (BLIT_CMDS + TILE_CMDS > 0)
152   5C3A              BLIT_TMP:
153   5C3A              TILETMP1:
154   5C3A              BLIT_TMP1:
155   5C3A 00 00         DW 0
156   5C3C              TILETMP2:
157   5C3C              BLIT_TMP2:
158   5C3C 00 00         DW 0
159   5C3E                IFDEF CMDS_WITH_PARAMETERS
160   5C3E              BLIT_STRUCT:
161   5C3E 00 00 00...   DS 17
162   5C42                ENDIF
163   5C42               ENDIF
164   5C4F
165   5C4F               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS > 0)
166   5C4F              VRAM_UPDATE_IN_PROGRESS:
167   5C4F 00            DB 0
168   5C50               ENDIF
169   5C50
170   5C50              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
171   5C50              ; per starting letter, if no commands with this letter, NULL value
172   5C50              CMDS:
173   5C50               IF (ANIM_CMDS == 1)
174   5C50 79 5D        	DW CMDS_A ;
175   5C52               ELSE
176   5C52 ~                DW 0 ; A
177   5C52               ENDIF
178   5C52               IF (BLIT_CMDS + BOX_CMDS > 0)
179   5C52 44 5D            DW CMDS_B ; B
180   5C54               ELSE
181   5C54 ~            	DW 0
182   5C54               ENDIF
183   5C54 00 00            DW 0 ; C
184   5C56 00 00            DW 0 ; D
185   5C58 00 00            DW 0 ; E
186   5C5A               IF (VRAM_CMDS + RAM_CMDS > 0)
187   5C5A C2 5C            DW CMDS_F; F
188   5C5C               ELSE
189   5C5C ~            	DW 0
190   5C5C               ENDIF
191   5C5C               IF (GENCAL_CMD > 0)
192   5C5C D5 5C            DW CMDS_G; G
193   5C5E               ELSE
194   5C5E ~            	DW 0
195   5C5E               ENDIF
196   5C5E 00 00            DW 0 ; H
197   5C60 00 00            DW 0 ; I
198   5C62 00 00            DW 0 ; J
199   5C64 00 00            DW 0 ; K
200   5C66 00 00            DW 0 ; L
201   5C68               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
202   5C68 84 5C            DW CMDS_M ; M
203   5C6A               ELSE
204   5C6A ~            	DW 0
205   5C6A               ENDIF
206   5C6A 00 00            DW 0 ; N
207   5C6C 00 00            DW 0 ; O
208   5C6E 00 00            DW 0 ; P
209   5C70 00 00            DW 0 ; Q
210   5C72 00 00            DW 0 ; R
211   5C74               IF (SOUND_CMDS + SPRITE_CMDS > 0)
212   5C74 E9 5C            DW CMDS_S ; S
213   5C76               ELSE
214   5C76 ~            	DW 0
215   5C76               ENDIF
216   5C76               IF (TILE_CMDS > 0)
217   5C76 64 5D            DW CMDS_T ; T
218   5C78               ELSE
219   5C78 ~            	DW 0
220   5C78               ENDIF
221   5C78 00 00            DW 0 ; U
222   5C7A               IF (VRAM_CMDS > 0)
223   5C7A DF 5C            DW CMDS_V ; V
224   5C7C               ELSE
225   5C7C ~            	DW 0
226   5C7C               ENDIF
227   5C7C 00 00            DW 0 ; W
228   5C7E 00 00            DW 0 ; X
229   5C80 00 00            DW 0 ; Y
230   5C82 00 00            DW 0 ; Z
231   5C84
232   5C84              CMDS_M:
233   5C84               IF (VRAM_CMDS == 1)
234   5C84 4D 45 4D 56      DB "MEMVRM", 0
234   5C88 52 4D 00
235   5C8B C5 55            DW MEMVRM
236   5C8D               ENDIF
237   5C8D               IF (RAM_CMDS == 1)
238   5C8D 4D 45 4D 43  	DB "MEMCPY", 0
238   5C91 50 59 00
239   5C94 FB 53        	DW MEMCPY
240   5C96               ENDIF
241   5C96               IF (ANIM_CMDS == 1)
242   5C96 4D 41 58 41  	DB "MAXANIMITEMS",0
242   5C9A 4E 49 4D 49
242   5C9E 54 45 4D 53
242   5CA2 00
243   5CA3 ED 4F        	DW MAXANIMITEMS
244   5CA5 4D 41 58 41  	DB "MAXANIMDEFS",0
244   5CA9 4E 49 4D 44
244   5CAD 45 46 53 00
245   5CB1 62 51        	DW MAXANIMDEFS
246   5CB3 4D 41 58 41  	DB "MAXANIMSPRS",0
246   5CB7 4E 49 4D 53
246   5CBB 50 52 53 00
247   5CBF F7 51        	DW MAXANIMSPRS
248   5CC1               ENDIF
249   5CC1               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
250   5CC1 00           	DB 0
251   5CC2               ENDIF
252   5CC2              CMDS_F:
253   5CC2               IF (VRAM_CMDS == 1)
254   5CC2 46 49 4C 56      DB "FILVRM", 0
254   5CC6 52 4D 00
255   5CC9 75 55            DW FILVRM
256   5CCB               ENDIF
257   5CCB               IF (RAM_CMDS == 1)
258   5CCB 46 49 4C 52      DB "FILRAM", 0
258   5CCF 41 4D 00
259   5CD2 3E 54            DW FILRAM
260   5CD4               ENDIF
261   5CD4               IF (VRAM_CMDS + RAM_CMDS > 0)
262   5CD4 00               DB 0
263   5CD5               ENDIF
264   5CD5              CMDS_G:
265   5CD5               IF (GENCAL_CMD == 1)
266   5CD5 47 45 4E 43      DB "GENCAL", 0
266   5CD9 41 4C 00
267   5CDC A9 56            DW GENCAL
268   5CDE               ENDIF
269   5CDE               IF (GENCAL_CMD > 0)
270   5CDE 00           	DB	0
271   5CDF               ENDIF
272   5CDF              CMDS_V:
273   5CDF               IF (VRAM_CMDS == 1)
274   5CDF 56 52 4D 4D  	DB "VRMMEM", 0
274   5CE3 45 4D 00
275   5CE6 44 56        	DW VRMMEM
276   5CE8               ENDIF
277   5CE8               IF (VRAM_CMDS > 0)
278   5CE8 00           	DB 0
279   5CE9               ENDIF
280   5CE9              CMDS_S:
281   5CE9               IF (SPRITE_CMDS == 1)
282   5CE9 53 50 52 53  	DB "SPRSET", 0
282   5CED 45 54 00
283   5CF0 88 4E        	DW SPRSET
284   5CF2 53 50 52 47  	DB "SPRGRPMOV", 0
284   5CF6 52 50 4D 4F
284   5CFA 56 00
285   5CFC 39 4F        	DW SPRGRPMOV
286   5CFE               ENDIF
287   5CFE               IF (SOUND_CMDS == 1)
288   5CFE 53 4E 44 53  	DB "SNDSFX", 0
288   5D02 46 58 00
289   5D05 1B 55        	DW SNDSFX
290   5D07 53 4E 44 50  	DB "SNDPLYON", 0
290   5D0B 4C 59 4F 4E
290   5D0F 00
291   5D10 E5 54        	DW SNDPLYON
292   5D12 53 4E 44 50  	DB "SNDPLYOFF", 0
292   5D16 4C 59 4F 46
292   5D1A 46 00
293   5D1C F8 54        	DW SNDPLYOFF
294   5D1E 53 4E 44 50  	DB "SNDPLYINI", 0
294   5D22 4C 59 49 4E
294   5D26 49 00
295   5D28 9B 54        	DW SNDPLYINIT
296   5D2A               ENDIF
297   5D2A               IF (SPRITE_CMDS == 1)
298   5D2A 53 50 52 45  	DB "SPRENABLE", 0
298   5D2E 4E 41 42 4C
298   5D32 45 00
299   5D34 43 4E        	DW SPRENABLE
300   5D36 53 50 52 44  	DB "SPRDISABLE", 0
300   5D3A 49 53 41 42
300   5D3E 4C 45 00
301   5D41 83 4E        	DW SPRDISABLE
302   5D43               ENDIF
303   5D43               IF (SOUND_CMDS + SPRITE_CMDS > 0)
304   5D43 00           	DB 0
305   5D44               ENDIF
306   5D44              CMDS_B:
307   5D44               IF (BLIT_CMDS == 1)
308   5D44 42 4C 49 54  	DB "BLIT", 0
308   5D48 00
309   5D49 35 59        	DW BLIT
310   5D4B               ENDIF
311   5D4B               IF (BOX_CMDS == 1)
312   5D4B 42 4F 58 4D  	DB "BOXMEMCPY", 0
312   5D4F 45 4D 43 50
312   5D53 59 00
313   5D55 38 57        	DW BOXMEMCPY
314   5D57 42 4F 58 4D  	DB "BOXMEMVRM", 0
314   5D5B 45 4D 56 52
314   5D5F 4D 00
315   5D61 6C 57        	DW BOXMEMVRM
316   5D63               ENDIF
317   5D63               IF (BLIT_CMDS + BOX_CMDS > 0)
318   5D63 00           	DB 0
319   5D64               ENDIF
320   5D64              CMDS_T:
321   5D64               IF (TILE_CMDS == 1)
322   5D64 54 49 4C 45  	DB "TILERAM", 0
322   5D68 52 41 4D 00
323   5D6C 79 5A        	DW TILERAM
324   5D6E 54 49 4C 45  	DB "TILEVRM", 0
324   5D72 56 52 4D 00
325   5D76 7C 5B        	DW TILEVRM
326   5D78               ENDIF
327   5D78               IF (TILE_CMDS > 0)
328   5D78 00           	DB 0
329   5D79               ENDIF
330   5D79              CMDS_A:
331   5D79               IF (ANIM_CMDS == 1)
332   5D79 41 4E 49 4D  	DB "ANIMSTART",0
332   5D7D 53 54 41 52
332   5D81 54 00
333   5D83 B5 52        	DW ANIMSTART
334   5D85 41 4E 49 4D  	DB "ANIMSTOP",0
334   5D89 53 54 4F 50
334   5D8D 00
335   5D8E B9 52        	DW ANIMSTOP
336   5D90 41 4E 49 4D  	DB "ANIMITEMPAT",0
336   5D94 49 54 45 4D
336   5D98 50 41 54 00
337   5D9C AD 50        	DW ANIMITEMPAT
338   5D9E 41 4E 49 4D  	DB "ANIMITEMPTR",0
338   5DA2 49 54 45 4D
338   5DA6 50 54 52 00
339   5DAA 0E 51        	DW ANIMITEMPTR_CMD
340   5DAC 41 4E 49 4D  	DB "ANIMDEF",0
340   5DB0 44 45 46 00
341   5DB4 A4 51        	DW ANIMDEF
342   5DB6 41 4E 49 4D  	DB "ANIMSPRITE",0
342   5DBA 53 50 52 49
342   5DBE 54 45 00
343   5DC1 4D 52        	DW ANIMSPRITE
344   5DC3 00           	DB 0
345   5DC4               ENDIF
346   5DC4
347   5DC4               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
348   5DC4              ; ****************************************************************************************************
349   5DC4              ; function sets VRAM address
350   5DC4              ; input HL=address
351   5DC4              ; modifies AF
352   5DC4              SETWRT_LOCAL:
353   5DC4 7D           	LD	A, L
354   5DC5 D3 99        	OUT	(099H), A
355   5DC7 7C           	LD	A, H
356   5DC8 E6 3F        	AND	03FH
357   5DCA F6 40        	OR	040H
358   5DCC D3 99        	OUT	(099H), A
359   5DCE C9           	RET
360   5DCF              ; ****************************************************************************************************
361   5DCF               ENDIF
362   5DCF
363   5DCF               IF (VRAM_CMDS + TILE_CMDS > 0)
364   5DCF              ; ****************************************************************************************************
365   5DCF              ; function copies data from RAM to VRAM
366   5DCF              ; input HL=address in RAM
367   5DCF              ; input B=count
368   5DCF              ; modifies AF, BC, HL
369   5DCF              BBYTECOPY:
370   5DCF 0E 98        	LD C,#98
371   5DD1              BBYTECOPY_NO_C:
372   5DD1 ED A3        	OUTI
373   5DD3 C2 D1 5D     	JP	NZ, BBYTECOPY_NO_C
374   5DD6 C9           	RET
375   5DD7              ; ****************************************************************************************************
376   5DD7               ENDIF
377   5DD7
378   5DD7              ; ****************************************************************************************************
379   5DD7              ; function multiplies HL by 32
380   5DD7              HLx32:
381   5DD7 29           	ADD HL,HL
382   5DD8              ; ****************************************************************************************************
383   5DD8              ; function multiplies HL by 16
384   5DD8              HLx16:
385   5DD8 29           	ADD HL,HL
386   5DD9              ; ****************************************************************************************************
387   5DD9              ; function multiplies HL by 8
388   5DD9              HLx8:
389   5DD9 29          > ADD HL, HL
389   5DDA 29          > ADD HL, HL
389   5DDB 29          > ADD HL, HL
390   5DDC C9           	RET
391   5DDD              ; ****************************************************************************************************
392   5DDD
393   5DDD              ; ****************************************************************************************************
394   5DDD              ; function gets slot and subslot data for specific page
395   5DDD              ; input A=page (0, 1 or 2)
396   5DDD              ; output B = 0A8H register value
397   5DDD              ; output D = 0 is no subslots, 1 if yes
398   5DDD              ; output C = 0A8H value when page 3 slot equals to requested page slot
399   5DDD              ; output E = subslot value if present
400   5DDD              ; modifies AF, BC, DE, HL
401   5DDD              GET_PAGE_INFO:
402   5DDD 6F               LD L, A
403   5DDE C6 C1            ADD A, low (EXPTBL)
404   5DE0 32 EA 5D         LD (GET_PAGE_INFO_L1+1), A
405   5DE3 DB A8            IN A, (0A8H)
406   5DE5 47               LD B, A
407   5DE6 E6 3F            AND 03FH
408   5DE8 4F               LD C, A
409   5DE9              GET_PAGE_INFO_L1:
410   5DE9 3A C1 FC         LD A, (EXPTBL) ; modified by code above
411   5DEC E6 80            AND 080H
412   5DEE 28 1B            JR Z, GET_PAGE_INFO_L2
413   5DF0                  ; expanded
414   5DF0 2D               DEC L
415   5DF1 FA 10 5E         JP M, GET_PAGE_INFO_L3
416   5DF4 2D               DEC L
417   5DF5 FA 0E 5E         JP M, GET_PAGE_INFO_L4
418   5DF8                  ; page 2
419   5DF8 07               RLCA
420   5DF9 07               RLCA
421   5DFA              GET_PAGE_INFO_L5:
422   5DFA E6 C0            AND 0C0H
423   5DFC B1               OR C
424   5DFD D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
425   5DFF 4F               LD C, A
426   5E00 3A FF FF         LD A, (0FFFFH)
427   5E03 2F               CPL
428   5E04 5F               LD E, A
429   5E05 16 01            LD D, 1
430   5E07 78               LD A, B ; return stack
431   5E08 D3 A8            OUT (0A8H), A
432   5E0A C9               RET
433   5E0B              GET_PAGE_INFO_L2:
434   5E0B                  ; not expanded
435   5E0B 16 00            LD D, 0
436   5E0D C9               RET
437   5E0E              GET_PAGE_INFO_L4:
438   5E0E                  ; page 1
439   5E0E 0F               RRCA
440   5E0F 0F               RRCA
441   5E10              GET_PAGE_INFO_L3:
442   5E10                  ; page 0
443   5E10 0F               RRCA
444   5E11 0F               RRCA
445   5E12 18 E6            JR GET_PAGE_INFO_L5
446   5E14              ; ****************************************************************************************************
447   5E14
448   5E14              ; ****************************************************************************************************
449   5E14              ; function returns original slot and subslot info
450   5E14              ; input B = 0A8H register value
451   5E14              ; input D = 0 is no subslots, 1 if yes
452   5E14              ; input C = 0A8H value when page 3 slot equals to requested page slot
453   5E14              ; input E = subslot value if present
454   5E14              ; modifies AF, disables interrupts
455   5E14              RESTORE_PAGE_INFO:
456   5E14 7A               LD A, D
457   5E15 B7               OR A
458   5E16 28 08            JR Z, RESTORE_PAGE_INFO_L1
459   5E18 79               LD A, C
460   5E19 F3           	DI
461   5E1A D3 A8            OUT (0A8H), A
462   5E1C 7B               LD A, E
463   5E1D 32 FF FF         LD (0FFFFH), A
464   5E20              RESTORE_PAGE_INFO_L1:
465   5E20 78               LD A, B
466   5E21 D3 A8            OUT (0A8H), A
467   5E23 C9               RET
468   5E24              ; ****************************************************************************************************
469   5E24
470   5E24              ; *******************************************************************************************************
471   5E24              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
472   5E24              ; INPUT:  A = SLOT ID: EXXXSSPP
473   5E24              ; E = EXPANDED FLAG
474   5E24              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
475   5E24              ; PP = PRIMARY SLOT NUMBER
476   5E24              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
477   5E24              ; CHANGES: AF, BC, DE
478   5E24
479   5E24              LOCAL_ENASLT:
480   5E24 CD 44 5E         CALL L0353
481   5E27 FA 31 5E         JP M, L0340
482   5E2A DB A8            IN A, (0A8H)
483   5E2C A1               AND C
484   5E2D B0               OR B
485   5E2E D3 A8            OUT (0A8H), A
486   5E30 C9               RET
487   5E31              L0340:
488   5E31 E5               PUSH HL
489   5E32 CD 69 5E         CALL L0378
490   5E35 4F               LD C, A
491   5E36 06 00            LD B, 0
492   5E38 7D               LD A, L
493   5E39 A4               AND H
494   5E3A B2               OR D
495   5E3B 21 C5 FC         LD HL, 0FCC5H
496   5E3E 09               ADD HL, BC
497   5E3F 77               LD (HL), A
498   5E40 E1               POP HL
499   5E41 79               LD A, C
500   5E42 18 E0            JR LOCAL_ENASLT
501   5E44              L0353:
502   5E44 F3               DI
503   5E45 F5               PUSH AF
504   5E46 7C               LD A, H
505   5E47 07               RLCA
506   5E48 07               RLCA
507   5E49 E6 03            AND 3
508   5E4B 5F               LD E, A
509   5E4C 3E C0            LD A, 0C0H
510   5E4E              L035D:
511   5E4E 07               RLCA
512   5E4F 07               RLCA
513   5E50 1D               DEC E
514   5E51 F2 4E 5E         JP P, L035D
515   5E54 5F               LD E, A
516   5E55 2F               CPL
517   5E56 4F               LD C, A
518   5E57 F1               POP AF
519   5E58 F5               PUSH AF
520   5E59 E6 03            AND 3
521   5E5B 3C               INC A
522   5E5C 47               LD B, A
523   5E5D 3E AB            LD A, 0ABH
524   5E5F              L036E:
525   5E5F C6 55            ADD A, 055H
526   5E61 10 FC            DJNZ L036E
527   5E63 57               LD D, A
528   5E64 A3               AND E
529   5E65 47               LD B, A
530   5E66 F1               POP AF
531   5E67 A7               AND A
532   5E68 C9               RET
533   5E69              L0378:
534   5E69 F5               PUSH AF
535   5E6A 7A               LD A, D
536   5E6B E6 C0            AND 0C0H
537   5E6D 4F               LD C, A
538   5E6E F1               POP AF
539   5E6F F5               PUSH AF
540   5E70 57               LD D, A
541   5E71 DB A8            IN A, (0A8H)
542   5E73 47               LD B, A
543   5E74 E6 3F            AND 03FH
544   5E76 B1               OR C
545   5E77 D3 A8            OUT (0A8H), A
546   5E79 7A               LD A, D
547   5E7A 0F               RRCA
548   5E7B 0F               RRCA
549   5E7C E6 03            AND 3
550   5E7E 57               LD D, A
551   5E7F 3E AB            LD A, 0ABH
552   5E81              L0390:
553   5E81 C6 55            ADD A, 055H
554   5E83 15               DEC D
555   5E84 F2 81 5E         JP P, L0390
556   5E87 A3               AND E
557   5E88 57               LD D, A
558   5E89 7B               LD A, E
559   5E8A 2F               CPL
560   5E8B 67               LD H, A
561   5E8C 3A FF FF         LD A, (0FFFFH)
562   5E8F 2F               CPL
563   5E90 6F               LD L, A
564   5E91 A4               AND H
565   5E92 B2               OR D
566   5E93 32 FF FF         LD (0FFFFH), A
567   5E96 78               LD A, B
568   5E97 D3 A8            OUT (0A8H), A
569   5E99 F1               POP AF
570   5E9A E6 03            AND 3
571   5E9C C9               RET
572   5E9D              ; *******************************************************************************************************
573   5E9D
574   5E9D              ; *******************************************************************************************************
575   5E9D              ; some common code to activate page 0 and place values needed to restore original page on stack
576   5E9D              ; input IY=return address
577   5E9D              ENABLE_PAGE0:
578   5E9D AF               XOR A
579   5E9E CD DD 5D         CALL GET_PAGE_INFO
580   5EA1 C5               PUSH BC
581   5EA2 D5               PUSH DE
582   5EA3 3A 41 F3         LD A, (RAMAD0)
583   5EA6 26 00            LD H, 0
584   5EA8 CD 24 5E         CALL LOCAL_ENASLT
585   5EAB FD E9        	JP (IY)
586   5EAD              ; *******************************************************************************************************
587   5EAD
588   5EAD              ; General BASIC CALL-instruction handler
589   5EAD              CALLHAND:
590   5EAD E5           	PUSH HL
591   5EAE 21 50 5C     	LD	HL, CMDS ; pointer table based on starting letter
592   5EB1 3A 89 FD         LD A, (PROCNM)
593   5EB4 D6 41            SUB 'A'
594   5EB6 87               ADD A, A
595   5EB7 16 00            LD D, 0
596   5EB9 5F               LD E, A
597   5EBA 19               ADD HL, DE
598   5EBB 5E               LD E, (HL)
599   5EBC 23               INC HL
600   5EBD 56               LD D, (HL)
601   5EBE 7A               LD A, D
602   5EBF B3               OR E
603   5EC0 28 23            JR Z, .CMDNOTRECOGNIZED
604   5EC2 EB               EX DE, HL
605   5EC3              .CHKCMD:
606   5EC3 11 89 FD     	LD	DE, PROCNM
607   5EC6 1A           .LOOP:	LD	A,(DE)
608   5EC7 BE           	CP	(HL)
609   5EC8 20 11        	JR	NZ,.TONEXTCMD	; Not equal
610   5ECA 13           	INC	DE
611   5ECB 23           	INC	HL
612   5ECC A7           	AND	A
613   5ECD 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
614   5ECF 5E           	LD	E,(HL)
615   5ED0 23           	INC	HL
616   5ED1 56           	LD	D,(HL)
617   5ED2 E1           	POP	HL		; routine address
618   5ED3 CD F4 5E     	CALL	GETPREVCHAR
619   5ED6 CD E8 5E     	CALL	.CALLDE		; Call routine
620   5ED9 A7           	AND	A
621   5EDA C9           	RET
622   5EDB
623   5EDB              .TONEXTCMD:
624   5EDB 0E FF        	LD	C,0FFH
625   5EDD AF           	XOR	A
626   5EDE ED B1        	CPIR			; Skip to end of instruction name
627   5EE0 23           	INC	HL
628   5EE1 23           	INC	HL		; Skip address
629   5EE2 BE           	CP	(HL)
630   5EE3 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
631   5EE5              .CMDNOTRECOGNIZED:
632   5EE5 E1           	POP	HL
633   5EE6 37               SCF
634   5EE7 C9           	RET
635   5EE8
636   5EE8              .CALLDE:
637   5EE8 D5           	PUSH	DE
638   5EE9 C9           	RET
639   5EEA
640   5EEA              ;---------------------------
641   5EEA
642   5EEA              ;GETSTRPNT:
643   5EEA              ; OUT:
644   5EEA              ; HL = String Address
645   5EEA              ; B  = Lenght
646   5EEA              ;        LD      HL,(USR)
647   5EEA              ;        LD      B,(HL)
648   5EEA              ;        INC     HL
649   5EEA              ;        LD      E,(HL)
650   5EEA              ;        INC     HL
651   5EEA              ;        LD      D,(HL)
652   5EEA              ;        EX      DE,HL
653   5EEA              ;        RET
654   5EEA
655   5EEA              ;EVALTXTPARAM:
656   5EEA              ;	CALL	CHKCHAR
657   5EEA              ;	DEFB	"("             ; Check for (
658   5EEA              ;	LD	IX,FRMEVL
659   5EEA              ;	CALL	CALBAS		; Evaluate expression
660   5EEA              ;       LD      A,(VALTYP)
661   5EEA              ;        CP      3               ; Text type?
662   5EEA              ;        JP      NZ,TYPE_MISMATCH
663   5EEA              ;        PUSH	HL
664   5EEA              ;        LD	IX,FRESTR         ; Free the temporary string
665   5EEA              ;        CALL	CALBAS
666   5EEA              ;        POP	HL
667   5EEA              ;	CALL	CHKCHAR
668   5EEA              ;	DEFB	")"             ; Check for )
669   5EEA              ;        RET
670   5EEA
671   5EEA
672   5EEA              CHKCHAR:
673   5EEA CD F4 5E     	CALL	GETPREVCHAR	; Get previous basic char
674   5EED E3           	EX	(SP),HL
675   5EEE BE           	CP	(HL) 	        ; Check if good char
676   5EEF 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
677   5EF1 23           	INC	HL
678   5EF2 E3           	EX	(SP),HL
679   5EF3 23           	INC	HL		; Get next basic char
680   5EF4
681   5EF4              GETPREVCHAR:
682   5EF4 2B           	DEC	HL
683   5EF5 DD 21 66 46  	LD	IX,CHRGTR
684   5EF9 C3 59 01     	JP      CALBAS
685   5EFC
686   5EFC
687   5EFC              TYPE_MISMATCH:
688   5EFC 1E 0D            LD E, 13 ; Type mismatch
689   5EFE 18 0A            JR THROW_ERROR
690   5F00              SUBSCRIPT_OUT_OF_RANGE:
691   5F00 1E 09            LD E,9 ; subscript out of range
692   5F02 18 06        	JR THROW_ERROR
693   5F04              OVERFLOW:
694   5F04 1E 06        	LD E,6
695   5F06 18 02        	JR THROW_ERROR
696   5F08              SYNTAX_ERROR:
697   5F08 1E 02            LD E, 2 ; Syntax error
698   5F0A              THROW_ERROR:
699   5F0A DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
700   5F0E C3 59 01     	JP	CALBAS
701   5F11
702   5F11              ;---------------------------
703   5F11
704   5F11              ; *******************************************************************************************************
705   5F11              ; helper function to get pointer to BASIC array data
706   5F11              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
707   5F11              ; input B=dimensions (1 or 2)
708   5F11              ; input D=minimal first dimension
709   5F11              ; input E=minimal second dimension, if applicable
710   5F11              ; returns BC=pointer to first data element
711   5F11              ; throws BASIC error if invalid type
712   5F11              GET_BASIC_ARRAY_DATA_POINTER:
713   5F11 D5           	PUSH DE
714   5F12 C5           	PUSH BC
715   5F13 F5           	PUSH AF
716   5F14 3E 01            LD A,1
717   5F16 32 A5 F6         LD (SUBFLG),A ; search for arrays only
718   5F19 DD 21 A4 5E  	LD IX, PTRGET
719   5F1D CD 59 01     	CALL CALBAS
720   5F20 AF               XOR A
721   5F21 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
722   5F24 3A 63 F6     	LD A,(VALTYP)
723   5F27 D1           	POP DE ; required type
724   5F28 BA           	CP D
725   5F29 C2 FC 5E     	JP NZ,TYPE_MISMATCH
726   5F2C 0A           	LD A,(BC)
727   5F2D 03           	INC BC
728   5F2E D1           	POP DE ; required number of dimensions
729   5F2F BA           	CP D
730   5F30 C2 FC 5E     	JP NZ,TYPE_MISMATCH
731   5F33 D1           	POP DE ; required minimal array dimensions
732   5F34 3D           	DEC A
733   5F35 28 07        	JR Z,.ONE_DIMENSION
734   5F37              	; 2-dimension array
735   5F37 0A           	LD A,(BC)
736   5F38 03          > INC BC
736   5F39 03          > INC BC
737   5F3A BB           	CP E
738   5F3B DA 00 5F     	JP C,SUBSCRIPT_OUT_OF_RANGE
739   5F3E              .ONE_DIMENSION:
740   5F3E 0A           	LD A,(BC)
741   5F3F 03          > INC BC
741   5F40 03          > INC BC
742   5F41 BA           	CP D
743   5F42 DA 00 5F     	JP C,SUBSCRIPT_OUT_OF_RANGE
744   5F45 C9           	RET
745   5F46              ; *******************************************************************************************************
746   5F46
747   5F46              EXT_END:
748   5F46
# file closed: asm\main.asm
