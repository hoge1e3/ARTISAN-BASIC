# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000
  51  4000              ; BASIC error codes
  52  4000              ;01 NEXT without FOR
  53  4000              ;02 Syntax error
  54  4000              ;03 RETURN without GOSUB
  55  4000              ;04 Out of DATA
  56  4000              ;05 Illegal function call
  57  4000              ;06 Overflow
  58  4000              ;07 Out of memory
  59  4000              ;08 Undefined line number
  60  4000              ;09 Subscript out of range
  61  4000              ;10 Redimensioned array
  62  4000              ;11 Division by zero
  63  4000              ;12 Illegal direct
  64  4000              ;13 Type mismatch
  65  4000              ;14 Out of string space
  66  4000              ;15 String too long
  67  4000              ;16 String formula too complex
  68  4000              ;17 Can't CONTINUE
  69  4000              ;18 Undefined user function
  70  4000              ;19 Device I/O error
  71  4000              ;20 Verify error
  72  4000              ;21 No RESUME
  73  4000              ;22 RESUME without error
  74  4000              ;23 Unprintable error
  75  4000              ;24 Missing operand
  76  4000              ;25 Line buffer overflow
  77  4000              ;50 FIELD overflow
  78  4000              ;51 Internal error
  79  4000              ;52 Bad file number
  80  4000              ;53 File not found
  81  4000              ;54 File already open
  82  4000              ;55 Input past end
  83  4000              ;56 Bad file name
  84  4000              ;57 Direct statement in file
  85  4000              ;58 Sequential I/O only
  86  4000              ;59 File not OPEN
  87  4000
  88  4000
  89  4000               ; simulate cartridge with BASIC extension
  90  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  90  4004 58 55 00 00
  90  4008 00 00 00 00
  90  400C 00 00 00 00
  91  4010
  92  4010              ; this location #4010 stores last location used by basic extension
  93  4010              ; free memory after that point
  94  4010              FREEMEMPTR:
  95  4010 3D 5E         DW EXT_END
  96  4012
  97  4012              ; this location #4012 stores extension version in DAA format
  98  4012              ; first byte is major version and second minor
  99  4012              VERSION:
 100  4012 00 70         DB #00, #70
 101  4014
 102  4014              ; binary included AKG player compiled at #4014
 103  4014               IF (SOUND_CMDS == 1)
 104  4014              	INCBIN "bin/AKG.bin"
 105  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 106  4CF0               ENDIF
 107  4CF0
 108  4CF0              ORIG.HTIMI:
 109  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 109  4CF4 00
 110  4CF5               EXPORT ORIG.HTIMI
 111  4CF5
 112  4CF5               IF (SOUND_CMDS == 1)
 113  4CF5              MUSIC_INIT_STATUS:
 114  4CF5 00            DB 0
 115  4CF6              SFX_INIT_STATUS:
 116  4CF6 00            DB 0
 117  4CF7              SOUND_ENABLED:
 118  4CF7 00            DB 0
 119  4CF8               ENDIF
 120  4CF8
 121  4CF8               IF (SPRITE_CMDS == 1)
 122  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 71 54     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 95 55     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 95 55     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 95 55     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 95 55     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 B5 55     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 B5 55     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 B5 55     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 95 55     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 95 55     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 95 55     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 95 55     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 95 55     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 95 55     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 B5 55     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 B5 55     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 95 55     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 95 55     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 95 55     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 95 55     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 95 55     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 88 54         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD CF 54         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD BF 54         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 123  4F4D               ENDIF
 124  4F4D
 125  4F4D               IF (ANIM_CMDS == 1)
 126  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E 3D 5E         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 3D 5E         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 3D 5E         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; ANIMATION DEFINITION
  31+ 4F56              ; byte number of items 1-15
  32+ 4F56              ; byte[15] anim_item;
  33+ 4F56              ; total size = 16b
  34+ 4F56
  35+ 4F56              ; SPRITE ANIMATION
  36+ 4F56              ; +00 byte sprite number;
  37+ 4F56              ; +01 word time;
  38+ 4F56              ; +03 byte current item;
  39+ 4F56              ; +04 byte animation definition;
  40+ 4F56              ; +05 byte cyclic;
  41+ 4F56              ; +06 byte active;
  42+ 4F56              ; +07 byte reserved
  43+ 4F56              ; total size = 8b
  44+ 4F56
  45+ 4F56              ; *******************************************************************************************************
  46+ 4F56              ; helper function HL=A*5
  47+ 4F56              ; changes HL,DE;
  48+ 4F56              Ax5:
  49+ 4F56 26 00            LD H,0
  50+ 4F58 6F               LD L,A
  51+ 4F59 54               LD D,H
  52+ 4F5A 5D               LD E,L
  53+ 4F5B 29               ADD HL,HL
  54+ 4F5C 29               ADD HL,HL
  55+ 4F5D 19               ADD HL,DE
  56+ 4F5E C9               RET
  57+ 4F5F              ; *******************************************************************************************************
  58+ 4F5F
  59+ 4F5F              ; *******************************************************************************************************
  60+ 4F5F              ; helper function gets pointer to n-th entry in sprite animation
  61+ 4F5F              ; changes HL,DE;
  62+ 4F5F              GETnthSPRANIM:
  63+ 4F5F 26 00            LD H,0
  64+ 4F61 6F               LD L,A
  65+ 4F62 CD 83 54         CALL HLx16
  66+ 4F65 ED 5B 54 4F      LD DE,(ANIMSPRPTR)
  67+ 4F69 19               ADD HL,DE
  68+ 4F6A C9               RET
  69+ 4F6B              ; *******************************************************************************************************
  70+ 4F6B
  71+ 4F6B              ; *******************************************************************************************************
  72+ 4F6B              ; function to handle CALL MAXANIMITEMS basic extension
  73+ 4F6B              ; MAXANIMITEMS (BYTE number)
  74+ 4F6B              ; sets new number and moves memory buffers as needed
  75+ 4F6B              MAXANIMITEMS:
  76+ 4F6B              	; opening (
  77+ 4F6B CD 95 55     	CALL CHKCHAR
  78+ 4F6E 28           	DB '('
  79+ 4F6F              	; get value
  80+ 4F6F DD 21 1C 52  	LD IX, GETBYT
  81+ 4F73 CD 59 01     	CALL CALBAS
  82+ 4F76 F5               PUSH AF
  83+ 4F77              	; ending )
  84+ 4F77 CD 95 55     	CALL CHKCHAR
  85+ 4F7A 29           	DB ')'
  86+ 4F7B F1               POP AF
  87+ 4F7C
  88+ 4F7C              	; save position
  89+ 4F7C E5           	PUSH HL
  90+ 4F7D              .ENTRY:
  91+ 4F7D 47               LD B,A
  92+ 4F7E 3A 4D 4F         LD A,(ANIMITEMNUM)
  93+ 4F81 90               SUB B
  94+ 4F82 28 1F            JR Z, .EXIT; same value as before
  95+ 4F84 FD 21 51 4F      LD IY,ANIMDEFPTR
  96+ 4F88 FA A6 4F         JP M, .INCREASE
  97+ 4F8B                  ; new value is lower than previous one
  98+ 4F8B CD BE 4F         CALL .SIZEDIFF
  99+ 4F8E CD D9 4F         CALL .DECREASE_COMMON
 100+ 4F91 2A 54 4F         LD HL,(ANIMSPRPTR)
 101+ 4F94 AF               XOR A
 102+ 4F95 ED 42            SBC HL,BC
 103+ 4F97 22 54 4F         LD (ANIMSPRPTR),HL
 104+ 4F9A              .E1:
 105+ 4F9A 2A 10 40         LD HL,(FREEMEMPTR)
 106+ 4F9D AF               XOR A
 107+ 4F9E ED 42            SBC HL,BC
 108+ 4FA0 22 10 40         LD (FREEMEMPTR),HL
 109+ 4FA3              .EXIT:
 110+ 4FA3 FB               EI
 111+ 4FA4 E1           	POP HL
 112+ 4FA5 C9           	RET
 113+ 4FA6              .INCREASE:
 114+ 4FA6 ED 44            NEG
 115+ 4FA8 CD BE 4F         CALL .SIZEDIFF
 116+ 4FAB CD 05 50         CALL .INCREASE_COMMON
 117+ 4FAE 2A 54 4F         LD HL,(ANIMSPRPTR)
 118+ 4FB1 09               ADD HL,BC
 119+ 4FB2 22 54 4F         LD (ANIMSPRPTR),HL
 120+ 4FB5              .E2:
 121+ 4FB5 2A 10 40         LD HL,(FREEMEMPTR)
 122+ 4FB8 09               ADD HL,BC
 123+ 4FB9 22 10 40         LD (FREEMEMPTR),HL
 124+ 4FBC 18 E5            JR .EXIT
 125+ 4FBE              .SIZEDIFF:
 126+ 4FBE CD 56 4F         CALL Ax5
 127+ 4FC1 78               LD A,B
 128+ 4FC2 32 4D 4F         LD (ANIMITEMNUM),A
 129+ 4FC5 44               LD B,H
 130+ 4FC6 4D               LD C,L
 131+ 4FC7 C9               RET ; BC=size difference in bytes
 132+ 4FC8              .SIZETOMOVE:
 133+ 4FC8 D5               PUSH DE
 134+ 4FC9 2A 10 40         LD HL,(FREEMEMPTR)
 135+ 4FCC FD 5E 00         LD E,(IY)
 136+ 4FCF FD 56 01         LD D,(IY+1)
 137+ 4FD2 AF               XOR A
 138+ 4FD3 ED 52            SBC HL,DE
 139+ 4FD5 44               LD B,H
 140+ 4FD6 4D               LD C,L
 141+ 4FD7 D1               POP DE
 142+ 4FD8 C9               RET
 143+ 4FD9              .DECREASE_COMMON:
 144+ 4FD9 FD 6E 00         LD L,(IY)
 145+ 4FDC FD 66 01         LD H,(IY+1)
 146+ 4FDF AF               XOR A
 147+ 4FE0 ED 42            SBC HL,BC
 148+ 4FE2 EB               EX DE,HL
 149+ 4FE3 C5               PUSH BC
 150+ 4FE4 CD C8 4F         CALL .SIZETOMOVE
 151+ 4FE7 F3               DI
 152+ 4FE8 78               LD A,B
 153+ 4FE9 B1               OR C
 154+ 4FEA 28 08            JR Z,.L1
 155+ 4FEC FD 6E 00         LD L,(IY)
 156+ 4FEF FD 66 01         LD H,(IY+1)
 157+ 4FF2 ED B0            LDIR
 158+ 4FF4              .L1:
 159+ 4FF4 C1               POP BC
 160+ 4FF5 FD 6E 00         LD L,(IY)
 161+ 4FF8 FD 66 01         LD H,(IY+1)
 162+ 4FFB AF               XOR A
 163+ 4FFC ED 42            SBC HL,BC
 164+ 4FFE FD 75 00         LD (IY),L
 165+ 5001 FD 74 01         LD (IY+1),H
 166+ 5004 C9               RET
 167+ 5005              .INCREASE_COMMON:
 168+ 5005 2A 10 40         LD HL,(FREEMEMPTR)
 169+ 5008 2B               DEC HL
 170+ 5009 AF               XOR A
 171+ 500A ED 42            SBC HL,BC
 172+ 500C EB               EX DE,HL
 173+ 500D C5               PUSH BC
 174+ 500E CD C8 4F         CALL .SIZETOMOVE
 175+ 5011 F3               DI
 176+ 5012 78               LD A,B
 177+ 5013 B1               OR C
 178+ 5014 28 06            JR Z,.L2
 179+ 5016 2A 10 40         LD HL,(FREEMEMPTR)
 180+ 5019 2B               DEC HL
 181+ 501A ED B8            LDDR
 182+ 501C              .L2:
 183+ 501C C1               POP BC
 184+ 501D FD 6E 00         LD L,(IY)
 185+ 5020 FD 66 01         LD H,(IY+1)
 186+ 5023 09               ADD HL,BC
 187+ 5024 FD 75 00         LD (IY),L
 188+ 5027 FD 74 01         LD (IY+1),H
 189+ 502A C9               RET
 190+ 502B              ; *******************************************************************************************************
 191+ 502B
 192+ 502B              ; *******************************************************************************************************
 193+ 502B              ; function to handle CALL ANIMITEMPAT basic extension
 194+ 502B              ; ANIMITEMPAT ( BYTE id,
 195+ 502B              ;               INT ticks,
 196+ 502B              ;               BYTE pattern,
 197+ 502B              ;               BYTE color )
 198+ 502B              ; fills animation item data, returns an error if out of bounds
 199+ 502B              ANIMITEMPAT:
 200+ 502B                  ; opening (
 201+ 502B CD 95 55     	CALL CHKCHAR
 202+ 502E 28           	DB '('
 203+ 502F              	; get id
 204+ 502F DD 21 1C 52  	LD IX, GETBYT
 205+ 5033 CD 59 01     	CALL CALBAS
 206+ 5036 F5               PUSH AF
 207+ 5037                  ; check if out of bounds
 208+ 5037 3C               INC A
 209+ 5038 4F               LD C,A
 210+ 5039 3A 4D 4F         LD A,(ANIMITEMNUM)
 211+ 503C B9               CP C
 212+ 503D DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 213+ 5040              	; comma
 214+ 5040 CD 95 55     	CALL CHKCHAR
 215+ 5043 2C           	DB ','
 216+ 5044              	; get ticks
 217+ 5044 DD 21 2F 54  	LD IX, FRMQNT
 218+ 5048 CD 59 01     	CALL CALBAS
 219+ 504B D5           	PUSH DE
 220+ 504C              	; comma
 221+ 504C CD 95 55     	CALL CHKCHAR
 222+ 504F 2C           	DB ','
 223+ 5050              	; get pattern
 224+ 5050 DD 21 1C 52  	LD IX, GETBYT
 225+ 5054 CD 59 01     	CALL CALBAS
 226+ 5057 F5               PUSH AF
 227+ 5058              	; comma
 228+ 5058 CD 95 55     	CALL CHKCHAR
 229+ 505B 2C           	DB ','
 230+ 505C              	; get color
 231+ 505C DD 21 1C 52  	LD IX, GETBYT
 232+ 5060 CD 59 01     	CALL CALBAS
 233+ 5063 F5               PUSH AF
 234+ 5064              	; ending )
 235+ 5064 CD 95 55     	CALL CHKCHAR
 236+ 5067 29           	DB ')'
 237+ 5068              .ENTRY:
 238+ 5068 E5               PUSH HL
 239+ 5069 DD E1            POP IX
 240+ 506B D9               EXX
 241+ 506C C1               POP BC ; color
 242+ 506D D1               POP DE ; pattern
 243+ 506E E1               POP HL ; ticks
 244+ 506F D9               EXX
 245+ 5070 F1               POP AF
 246+ 5071 CD 56 4F         CALL Ax5
 247+ 5074 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 248+ 5078 19               ADD HL,DE
 249+ 5079 E5               PUSH HL
 250+ 507A FD E1            POP IY
 251+ 507C D9               EXX
 252+ 507D FD 36 00 00      LD (IY),0 ; type=0
 253+ 5081 FD 75 01         LD (IY+1),L
 254+ 5084 FD 74 02         LD (IY+2),H
 255+ 5087 FD 72 03         LD (IY+3),D
 256+ 508A FD 70 04         LD (IY+4),B
 257+ 508D
 258+ 508D DD E5            PUSH IX
 259+ 508F E1               POP HL
 260+ 5090 C9               RET
 261+ 5091              ; *******************************************************************************************************
 262+ 5091
 263+ 5091              ; *******************************************************************************************************
 264+ 5091              ; function to handle CALL ANIMITEMPTR basic extension
 265+ 5091              ; ANIMITEMPTR ( BYTE id,
 266+ 5091              ;               INT ticks,
 267+ 5091              ;               INT pointer,
 268+ 5091              ; fills animation item data, returns an error if out of bounds
 269+ 5091              ANIMITEMPTR_CMD:
 270+ 5091                  ; opening (
 271+ 5091 CD 95 55     	CALL CHKCHAR
 272+ 5094 28           	DB '('
 273+ 5095              	; get id
 274+ 5095 DD 21 1C 52  	LD IX, GETBYT
 275+ 5099 CD 59 01     	CALL CALBAS
 276+ 509C F5               PUSH AF
 277+ 509D                  ; check if out of bounds
 278+ 509D 3C               INC A
 279+ 509E 4F               LD C,A
 280+ 509F 3A 4D 4F         LD A,(ANIMITEMNUM)
 281+ 50A2 B9               CP C
 282+ 50A3 DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 283+ 50A6              	; comma
 284+ 50A6 CD 95 55     	CALL CHKCHAR
 285+ 50A9 2C           	DB ','
 286+ 50AA              	; get ticks
 287+ 50AA DD 21 2F 54  	LD IX, FRMQNT
 288+ 50AE CD 59 01     	CALL CALBAS
 289+ 50B1 D5           	PUSH DE
 290+ 50B2              	; comma
 291+ 50B2 CD 95 55     	CALL CHKCHAR
 292+ 50B5 2C           	DB ','
 293+ 50B6              	; get pointer
 294+ 50B6 DD 21 2F 54  	LD IX, FRMQNT
 295+ 50BA CD 59 01     	CALL CALBAS
 296+ 50BD D5           	PUSH DE
 297+ 50BE              	; ending )
 298+ 50BE CD 95 55     	CALL CHKCHAR
 299+ 50C1 29           	DB ')'
 300+ 50C2              .ENTRY:
 301+ 50C2 E5               PUSH HL
 302+ 50C3 DD E1            POP IX
 303+ 50C5 D9               EXX
 304+ 50C6 D1               POP DE ; pointer
 305+ 50C7 E1               POP HL ; ticks
 306+ 50C8 D9               EXX
 307+ 50C9 F1               POP AF
 308+ 50CA CD 56 4F         CALL Ax5
 309+ 50CD ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 310+ 50D1 19               ADD HL,DE
 311+ 50D2 E5               PUSH HL
 312+ 50D3 FD E1            POP IY
 313+ 50D5 D9               EXX
 314+ 50D6 FD 36 00 01      LD (IY),1 ; type=1
 315+ 50DA FD 75 01         LD (IY+1),L
 316+ 50DD FD 74 02         LD (IY+2),H
 317+ 50E0 FD 73 03         LD (IY+3),E
 318+ 50E3 FD 72 04         LD (IY+4),D
 319+ 50E6
 320+ 50E6 DD E5            PUSH IX
 321+ 50E8 E1               POP HL
 322+ 50E9 C9               RET
 323+ 50EA              ; *******************************************************************************************************
 324+ 50EA
 325+ 50EA              ; *******************************************************************************************************
 326+ 50EA              ; function to handle CALL MAXANIMDEFS basic extension
 327+ 50EA              ; MAXANIMDEFS (BYTE number)
 328+ 50EA              ; sets new number and moves memory buffers as needed
 329+ 50EA              MAXANIMDEFS:
 330+ 50EA              	; opening (
 331+ 50EA CD 95 55     	CALL CHKCHAR
 332+ 50ED 28           	DB '('
 333+ 50EE              	; get value
 334+ 50EE DD 21 1C 52  	LD IX, GETBYT
 335+ 50F2 CD 59 01     	CALL CALBAS
 336+ 50F5 F5               PUSH AF
 337+ 50F6              	; ending )
 338+ 50F6 CD 95 55     	CALL CHKCHAR
 339+ 50F9 29           	DB ')'
 340+ 50FA F1               POP AF
 341+ 50FB
 342+ 50FB              	; save position
 343+ 50FB E5           	PUSH HL
 344+ 50FC              .ENTRY:
 345+ 50FC 47               LD B,A
 346+ 50FD 3A 50 4F         LD A,(ANIMDEFNUM)
 347+ 5100 90               SUB B
 348+ 5101 CA A3 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 349+ 5104 FD 21 54 4F      LD IY,ANIMSPRPTR
 350+ 5108 FA 14 51         JP M, .INCREASE
 351+ 510B                  ; new value is lower than previous one
 352+ 510B CD 1F 51         CALL .SIZEDIFF
 353+ 510E CD D9 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 354+ 5111 C3 9A 4F         JP MAXANIMITEMS.E1
 355+ 5114              .INCREASE:
 356+ 5114 ED 44            NEG
 357+ 5116 CD 1F 51         CALL .SIZEDIFF
 358+ 5119 CD 05 50         CALL MAXANIMITEMS.INCREASE_COMMON
 359+ 511C C3 B5 4F         JP MAXANIMITEMS.E2
 360+ 511F              .SIZEDIFF:
 361+ 511F 26 00            LD H,0
 362+ 5121 6F               LD L,A
 363+ 5122 CD 83 54         CALL HLx16
 364+ 5125 78               LD A,B
 365+ 5126 32 50 4F         LD (ANIMDEFNUM),A
 366+ 5129 44               LD B,H
 367+ 512A 4D               LD C,L
 368+ 512B C9               RET ; BC=size difference in bytes
 369+ 512C              ; *******************************************************************************************************
 370+ 512C
 371+ 512C              ; *******************************************************************************************************
 372+ 512C              ; function to handle CALL ANIMDEF basic extension
 373+ 512C              ; ANIMITEMPAT ( BYTE id,
 374+ 512C              ;               BYTE size,
 375+ 512C              ;               INT[] list )
 376+ 512C              ; fills animation definition data, returns an error if out of bounds, or invalid type
 377+ 512C              ANIMDEF:
 378+ 512C                  ; opening (
 379+ 512C CD 95 55     	CALL CHKCHAR
 380+ 512F 28           	DB '('
 381+ 5130              	; get id
 382+ 5130 DD 21 1C 52  	LD IX, GETBYT
 383+ 5134 CD 59 01     	CALL CALBAS
 384+ 5137 F5               PUSH AF
 385+ 5138                  ; check if out of bounds
 386+ 5138 3C               INC A
 387+ 5139 4F               LD C,A
 388+ 513A 3A 50 4F         LD A,(ANIMDEFNUM)
 389+ 513D B9               CP C
 390+ 513E DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 391+ 5141              	; comma
 392+ 5141 CD 95 55     	CALL CHKCHAR
 393+ 5144 2C           	DB ','
 394+ 5145              	; get size
 395+ 5145 DD 21 1C 52  	LD IX, GETBYT
 396+ 5149 CD 59 01     	CALL CALBAS
 397+ 514C FE 10            CP 16
 398+ 514E D2 AF 55         JP NC, OVERFLOW
 399+ 5151 B7               OR A
 400+ 5152 CA AF 55         JP Z, OVERFLOW
 401+ 5155 F5           	PUSH AF
 402+ 5156              	; comma
 403+ 5156 CD 95 55     	CALL CHKCHAR
 404+ 5159 2C           	DB ','
 405+ 515A              	; get pointer to a list of animation items in integer array format
 406+ 515A 3E 01            LD A,1
 407+ 515C 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 408+ 515F DD 21 A4 5E  	LD IX, PTRGET
 409+ 5163 CD 59 01     	CALL CALBAS
 410+ 5166                  ; contrary to documentation we get a pointer to array dimension in BC
 411+ 5166                  ; and type in VALTYP
 412+ 5166 3A 63 F6         LD A,(VALTYP)
 413+ 5169 FE 02            CP 2
 414+ 516B C2 A7 55         JP NZ,TYPE_MISMATCH
 415+ 516E 0A               LD A,(BC)
 416+ 516F FE 01            CP 1
 417+ 5171 C2 A7 55         JP NZ,TYPE_MISMATCH
 418+ 5174 03               INC BC
 419+ 5175 0A               LD A,(BC)
 420+ 5176 D1               POP DE
 421+ 5177 D5               PUSH DE
 422+ 5178 3C               INC A
 423+ 5179 BA               CP D
 424+ 517A DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 425+ 517D 03          > INC BC
 425+ 517E 03          > INC BC
 426+ 517F C5               PUSH BC
 427+ 5180              	; ending )
 428+ 5180 CD 95 55     	CALL CHKCHAR
 429+ 5183 29           	DB ')'
 430+ 5184              .ENTRY:
 431+ 5184 E5               PUSH HL
 432+ 5185 DD E1            POP IX
 433+ 5187 D1               POP DE ; pointer to INT array
 434+ 5188 C1               POP BC ; B=item number
 435+ 5189 F1               POP AF ; id
 436+ 518A 26 00            LD H,0
 437+ 518C 6F               LD L,A
 438+ 518D CD 83 54         CALL HLx16
 439+ 5190 D5               PUSH DE
 440+ 5191 ED 5B 51 4F      LD DE,(ANIMDEFPTR)
 441+ 5195 19               ADD HL,DE
 442+ 5196 D1               POP DE
 443+ 5197 70               LD (HL),B
 444+ 5198              .L1:
 445+ 5198 23               INC HL
 446+ 5199 1A               LD A,(DE)
 447+ 519A 13          > INC DE
 447+ 519B 13          > INC DE
 448+ 519C 77               LD (HL),A
 449+ 519D 10 F9            DJNZ .L1
 450+ 519F DD E5            PUSH IX
 451+ 51A1 E1               POP HL
 452+ 51A2 C9               RET
 453+ 51A3              ; *******************************************************************************************************
 454+ 51A3
 455+ 51A3              ; *******************************************************************************************************
 456+ 51A3              ; function to handle CALL MAXANIMSPRS basic extension
 457+ 51A3              ; MAXANIMSPRS (BYTE number)
 458+ 51A3              ; sets new number and moves memory buffers as needed
 459+ 51A3              MAXANIMSPRS:
 460+ 51A3              	; opening (
 461+ 51A3 CD 95 55     	CALL CHKCHAR
 462+ 51A6 28           	DB '('
 463+ 51A7              	; get value
 464+ 51A7 DD 21 1C 52  	LD IX, GETBYT
 465+ 51AB CD 59 01     	CALL CALBAS
 466+ 51AE F5               PUSH AF
 467+ 51AF              	; ending )
 468+ 51AF CD 95 55     	CALL CHKCHAR
 469+ 51B2 29           	DB ')'
 470+ 51B3 F1               POP AF
 471+ 51B4
 472+ 51B4              	; save position
 473+ 51B4 E5           	PUSH HL
 474+ 51B5              .ENTRY:
 475+ 51B5 47               LD B,A
 476+ 51B6 3A 53 4F         LD A,(ANIMSPRNUM)
 477+ 51B9 90               SUB B
 478+ 51BA CA A3 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 479+ 51BD FD 21 10 40      LD IY,FREEMEMPTR
 480+ 51C1 FA CD 51         JP M, .INCREASE
 481+ 51C4                  ; new value is lower than previous one
 482+ 51C4 CD EC 51         CALL .SIZEDIFF
 483+ 51C7 CD D9 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 484+ 51CA C3 A3 4F         JP MAXANIMITEMS.EXIT
 485+ 51CD              .INCREASE:
 486+ 51CD ED 44            NEG
 487+ 51CF F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 488+ 51D0 CD EC 51         CALL .SIZEDIFF
 489+ 51D3 CD 05 50         CALL MAXANIMITEMS.INCREASE_COMMON
 490+ 51D6 AF               XOR A
 491+ 51D7 ED 42            SBC HL,BC ; location of new stuff
 492+ 51D9 F1               POP AF
 493+ 51DA 47               LD B,A
 494+ 51DB 11 08 00         LD DE,8
 495+ 51DE E5               PUSH HL
 496+ 51DF DD E1            POP IX
 497+ 51E1              .L1:
 498+ 51E1 DD 36 06 00      LD (IX+6),0
 499+ 51E5 DD 19            ADD IX,DE
 500+ 51E7 10 F8            DJNZ .L1
 501+ 51E9 C3 A3 4F         JP MAXANIMITEMS.EXIT
 502+ 51EC              .SIZEDIFF:
 503+ 51EC 26 00            LD H,0
 504+ 51EE 6F               LD L,A
 505+ 51EF CD 84 54         CALL HLx8
 506+ 51F2 78               LD A,B
 507+ 51F3 32 53 4F         LD (ANIMSPRNUM),A
 508+ 51F6 44               LD B,H
 509+ 51F7 4D               LD C,L
 510+ 51F8 C9               RET ; BC=size difference in bytes
 511+ 51F9              ; *******************************************************************************************************
 512+ 51F9
 513+ 51F9              ; *******************************************************************************************************
 514+ 51F9              ; function to handle CALL ANIMSPRITE basic extension
 515+ 51F9              ; ANIMSPRITE ( BYTE id,
 516+ 51F9              ;              BYTE sprite_number,
 517+ 51F9              ;              BYTE animation_definition_id,
 518+ 51F9              ;              BYTE cyclic_flag )
 519+ 51F9              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 520+ 51F9              ANIMSPRITE:
 521+ 51F9                  ; opening (
 522+ 51F9 CD 95 55     	CALL CHKCHAR
 523+ 51FC 28           	DB '('
 524+ 51FD              	; get sprite animation id
 525+ 51FD DD 21 1C 52  	LD IX, GETBYT
 526+ 5201 CD 59 01     	CALL CALBAS
 527+ 5204 F5               PUSH AF
 528+ 5205 3C               INC A
 529+ 5206 4F               LD C,A
 530+ 5207 3A 53 4F         LD A,(ANIMSPRNUM)
 531+ 520A B9               CP C
 532+ 520B DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 533+ 520E              	; comma
 534+ 520E CD 95 55     	CALL CHKCHAR
 535+ 5211 2C           	DB ','
 536+ 5212              	; get sprite number
 537+ 5212 DD 21 1C 52  	LD IX, GETBYT
 538+ 5216 CD 59 01     	CALL CALBAS
 539+ 5219 F5               PUSH AF
 540+ 521A                  ; check if out of bounds
 541+ 521A FE 20            CP 32
 542+ 521C D2 AB 55         JP NC, SUBSCRIPT_OUT_OF_RANGE
 543+ 521F              	; comma
 544+ 521F CD 95 55     	CALL CHKCHAR
 545+ 5222 2C           	DB ','
 546+ 5223              	; get animation definition id
 547+ 5223 DD 21 1C 52  	LD IX, GETBYT
 548+ 5227 CD 59 01     	CALL CALBAS
 549+ 522A F5               PUSH AF
 550+ 522B 3C               INC A
 551+ 522C 4F               LD C,A
 552+ 522D 3A 50 4F         LD A,(ANIMDEFNUM)
 553+ 5230 B9               CP C
 554+ 5231 DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 555+ 5234              	; comma
 556+ 5234 CD 95 55     	CALL CHKCHAR
 557+ 5237 2C           	DB ','
 558+ 5238              	; get cyclic flag
 559+ 5238 DD 21 1C 52  	LD IX, GETBYT
 560+ 523C CD 59 01         CALL CALBAS
 561+ 523F F5           	PUSH AF
 562+ 5240              	; ending )
 563+ 5240 CD 95 55     	CALL CHKCHAR
 564+ 5243 29           	DB ')'
 565+ 5244              .ENTRY:
 566+ 5244 E5               PUSH HL
 567+ 5245 DD E1            POP IX
 568+ 5247 D9               EXX
 569+ 5248 D1               POP DE ; cyclic
 570+ 5249 C1               POP BC ; animation definition id
 571+ 524A E1               POP HL ; sprite number
 572+ 524B D9               EXX
 573+ 524C F1               POP AF ; sprite animation id
 574+ 524D 26 00            LD H,0
 575+ 524F 6F               LD L,A
 576+ 5250 CD 84 54         CALL HLx8
 577+ 5253 ED 5B 54 4F      LD DE,(ANIMSPRPTR)
 578+ 5257 19               ADD HL,DE
 579+ 5258 E5               PUSH HL
 580+ 5259 FD E1            POP IY
 581+ 525B D9               EXX
 582+ 525C FD 74 00         LD (IY),H
 583+ 525F FD 70 04         LD (IY+4),B
 584+ 5262 FD 72 05         LD (IY+5),D
 585+ 5265                  ;LD (IY+6),0
 586+ 5265 DD E5            PUSH IX
 587+ 5267 E1               POP HL
 588+ 5268 C9               RET
 589+ 5269              ; *******************************************************************************************************
 590+ 5269
 591+ 5269              ; *******************************************************************************************************
 592+ 5269              ; function to handle CALL ANIMSTART basic extension
 593+ 5269              ; two forms
 594+ 5269              ; ANIMSTART ( BYTE id )
 595+ 5269              ; or
 596+ 5269              ; ANIMSTART ( BYTE item_number,
 597+ 5269              ;             INT[] sprite_animations )
 598+ 5269              ; sets active flag to 1
 599+ 5269              ANIMSTART:
 600+ 5269 3E 01            LD A,1
 601+ 526B 18 01            JR ANIMSTARTSTOP_COMMON
 602+ 526D              ; *******************************************************************************************************
 603+ 526D              ; *******************************************************************************************************
 604+ 526D              ; function to handle CALL ANIMSTOP basic extension
 605+ 526D              ; two forms
 606+ 526D              ; ANIMSTOP ( BYTE id )
 607+ 526D              ; or
 608+ 526D              ; ANIMSTOP ( BYTE item_number,
 609+ 526D              ;            INT[] sprite_animations )
 610+ 526D              ; sets active flag to 1
 611+ 526D              ANIMSTOP:
 612+ 526D AF               XOR A
 613+ 526E              ANIMSTARTSTOP_COMMON:
 614+ 526E 32 E6 52         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
 615+ 5271              ; *******************************************************************************************************
 616+ 5271                  ; opening (
 617+ 5271 CD 95 55     	CALL CHKCHAR
 618+ 5274 28           	DB '('
 619+ 5275              	; get sprite animation id or array size
 620+ 5275 DD 21 1C 52  	LD IX,GETBYT
 621+ 5279 CD 59 01     	CALL CALBAS
 622+ 527C F5               PUSH AF
 623+ 527D                  ; check if comma present
 624+ 527D CD 9F 55         CALL GETPREVCHAR
 625+ 5280 23               INC HL
 626+ 5281 FE 2C            CP ','
 627+ 5283 28 0C            JR Z,.L1
 628+ 5285 FE 29            CP ')'
 629+ 5287 C2 B3 55         JP NZ,SYNTAX_ERROR
 630+ 528A                  ; ok so single argument variant
 631+ 528A F1               POP AF
 632+ 528B E5               PUSH HL
 633+ 528C CD D3 52         CALL .SETVALUE
 634+ 528F E1               POP HL
 635+ 5290 C9               RET
 636+ 5291              .L1:
 637+ 5291                  ; array of items
 638+ 5291              	; get pointer to a list of animation items in integer array format
 639+ 5291 3E 01            LD A,1
 640+ 5293 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 641+ 5296 DD 21 A4 5E  	LD IX, PTRGET
 642+ 529A CD 59 01     	CALL CALBAS
 643+ 529D                  ; contrary to documentation we get a pointer to array dimension in BC
 644+ 529D                  ; and type in VALTYP
 645+ 529D 3A 63 F6         LD A,(VALTYP)
 646+ 52A0 FE 02            CP 2
 647+ 52A2 C2 A7 55         JP NZ,TYPE_MISMATCH
 648+ 52A5 0A               LD A,(BC)
 649+ 52A6 FE 01            CP 1
 650+ 52A8 C2 A7 55         JP NZ,TYPE_MISMATCH
 651+ 52AB 03               INC BC
 652+ 52AC 0A               LD A,(BC)
 653+ 52AD D1               POP DE
 654+ 52AE D5               PUSH DE
 655+ 52AF 3C               INC A
 656+ 52B0 BA               CP D
 657+ 52B1 DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 658+ 52B4 03          > INC BC
 658+ 52B5 03          > INC BC
 659+ 52B6 C5               PUSH BC
 660+ 52B7              	; ending )
 661+ 52B7 CD 95 55     	CALL CHKCHAR
 662+ 52BA 29           	DB ')'
 663+ 52BB D1               POP DE ; array pointer
 664+ 52BC C1               POP BC ; number of items
 665+ 52BD 78               LD A,B
 666+ 52BE B7               OR A
 667+ 52BF CA AB 55         JP Z,SUBSCRIPT_OUT_OF_RANGE
 668+ 52C2 E5               PUSH HL
 669+ 52C3 F3               DI
 670+ 52C4              .L2:
 671+ 52C4 C5               PUSH BC
 672+ 52C5 1A               LD A,(DE)
 673+ 52C6 13          > INC DE
 673+ 52C7 13          > INC DE
 674+ 52C8 D5               PUSH DE
 675+ 52C9 CD D3 52         CALL .SETVALUE
 676+ 52CC D1               POP DE
 677+ 52CD C1               POP BC
 678+ 52CE 10 F4            DJNZ .L2
 679+ 52D0 FB               EI
 680+ 52D1 E1               POP HL
 681+ 52D2 C9               RET
 682+ 52D3
 683+ 52D3              .SETVALUE:
 684+ 52D3 47               LD B,A
 685+ 52D4 3C               INC A
 686+ 52D5 4F               LD C,A
 687+ 52D6 3A 53 4F         LD A,(ANIMSPRNUM)
 688+ 52D9 B9               CP C
 689+ 52DA DA AB 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 690+ 52DD CD 5F 4F         CALL GETnthSPRANIM
 691+ 52E0 E5               PUSH HL
 692+ 52E1 DD E1            POP IX
 693+ 52E3              .VALUE:
 694+ 52E3 DD 36 06 01      LD (IX+6),1
 695+ 52E7 C9               RET
 696+ 52E8              ; *******************************************************************************************************
 697+ 52E8
# file closed: asm\ANIMATION.asm
 127  52E8               ENDIF
 128  52E8
 129  52E8              ; temp variables for BLIT, TILE functions
 130  52E8               IF (BLIT_CMDS + TILE_CMDS > 0)
 131  52E8              BLIT_TMP:
 132  52E8              TILETMP1:
 133  52E8              BLIT_TMP1:
 134  52E8 00 00         DW 0
 135  52EA              TILETMP2:
 136  52EA              BLIT_TMP2:
 137  52EA 00 00         DW 0
 138  52EC                IFDEF CMDS_WITH_PARAMETERS
 139  52EC              BLIT_STRUCT:
 140  52EC 00 00 00...   DS 17
 141  52F0                ENDIF
 142  52F0               ENDIF
 143  52FD
 144  52FD              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 145  52FD              ; per starting letter, if no commands with this letter, NULL value
 146  52FD              CMDS:
 147  52FD               IF (ANIM_CMDS == 1)
 148  52FD 26 54        	DW CMDS_A ;
 149  52FF               ELSE
 150  52FF ~                DW 0 ; A
 151  52FF               ENDIF
 152  52FF               IF (BLIT_CMDS + BOX_CMDS > 0)
 153  52FF F1 53            DW CMDS_B ; B
 154  5301               ELSE
 155  5301 ~            	DW 0
 156  5301               ENDIF
 157  5301 00 00            DW 0 ; C
 158  5303 00 00            DW 0 ; D
 159  5305 00 00            DW 0 ; E
 160  5307               IF (VRAM_CMDS + RAM_CMDS > 0)
 161  5307 6F 53            DW CMDS_F; F
 162  5309               ELSE
 163  5309 ~            	DW 0
 164  5309               ENDIF
 165  5309               IF (GENCAL_CMD > 0)
 166  5309 82 53            DW CMDS_G; G
 167  530B               ELSE
 168  530B ~            	DW 0
 169  530B               ENDIF
 170  530B 00 00            DW 0 ; H
 171  530D 00 00            DW 0 ; I
 172  530F 00 00            DW 0 ; J
 173  5311 00 00            DW 0 ; K
 174  5313 00 00            DW 0 ; L
 175  5315               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 176  5315 31 53            DW CMDS_M ; M
 177  5317               ELSE
 178  5317 ~            	DW 0
 179  5317               ENDIF
 180  5317 00 00            DW 0 ; N
 181  5319 00 00            DW 0 ; O
 182  531B 00 00            DW 0 ; P
 183  531D 00 00            DW 0 ; Q
 184  531F 00 00            DW 0 ; R
 185  5321               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 186  5321 96 53            DW CMDS_S ; S
 187  5323               ELSE
 188  5323 ~            	DW 0
 189  5323               ENDIF
 190  5323               IF (TILE_CMDS > 0)
 191  5323 11 54            DW CMDS_T ; T
 192  5325               ELSE
 193  5325 ~            	DW 0
 194  5325               ENDIF
 195  5325 00 00            DW 0 ; U
 196  5327               IF (VRAM_CMDS > 0)
 197  5327 8C 53            DW CMDS_V ; V
 198  5329               ELSE
 199  5329 ~            	DW 0
 200  5329               ENDIF
 201  5329 00 00            DW 0 ; W
 202  532B 00 00            DW 0 ; X
 203  532D 00 00            DW 0 ; Y
 204  532F 00 00            DW 0 ; Z
 205  5331
 206  5331              CMDS_M:
 207  5331               IF (VRAM_CMDS == 1)
 208  5331 4D 45 4D 56      DB "MEMVRM", 0
 208  5335 52 4D 00
 209  5338 FD 56            DW MEMVRM
 210  533A               ENDIF
 211  533A               IF (RAM_CMDS == 1)
 212  533A 4D 45 4D 43  	DB "MEMCPY", 0
 212  533E 50 59 00
 213  5341 BC 55        	DW MEMCPY
 214  5343               ENDIF
 215  5343               IF (ANIM_CMDS == 1)
 216  5343 4D 41 58 41  	DB "MAXANIMITEMS",0
 216  5347 4E 49 4D 49
 216  534B 54 45 4D 53
 216  534F 00
 217  5350 6B 4F        	DW MAXANIMITEMS
 218  5352 4D 41 58 41  	DB "MAXANIMDEFS",0
 218  5356 4E 49 4D 44
 218  535A 45 46 53 00
 219  535E EA 50        	DW MAXANIMDEFS
 220  5360 4D 41 58 41  	DB "MAXANIMSPRS",0
 220  5364 4E 49 4D 53
 220  5368 50 52 53 00
 221  536C A3 51        	DW MAXANIMSPRS
 222  536E               ENDIF
 223  536E               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 224  536E 00           	DB 0
 225  536F               ENDIF
 226  536F              CMDS_F:
 227  536F               IF (VRAM_CMDS == 1)
 228  536F 46 49 4C 56      DB "FILVRM", 0
 228  5373 52 4D 00
 229  5376 FF 55            DW FILVRM
 230  5378               ENDIF
 231  5378               IF (RAM_CMDS == 1)
 232  5378 46 49 4C 52      DB "FILRAM", 0
 232  537C 41 4D 00
 233  537F 46 56            DW FILRAM
 234  5381               ENDIF
 235  5381               IF (VRAM_CMDS + RAM_CMDS > 0)
 236  5381 00               DB 0
 237  5382               ENDIF
 238  5382              CMDS_G:
 239  5382               IF (GENCAL_CMD == 1)
 240  5382 47 45 4E 43      DB "GENCAL", 0
 240  5386 41 4C 00
 241  5389 A4 56            DW GENCAL
 242  538B               ENDIF
 243  538B               IF (GENCAL_CMD > 0)
 244  538B 00           	DB	0
 245  538C               ENDIF
 246  538C              CMDS_V:
 247  538C               IF (VRAM_CMDS == 1)
 248  538C 56 52 4D 4D  	DB "VRMMEM", 0
 248  5390 45 4D 00
 249  5393 75 57        	DW VRMMEM
 250  5395               ENDIF
 251  5395               IF (VRAM_CMDS > 0)
 252  5395 00           	DB 0
 253  5396               ENDIF
 254  5396              CMDS_S:
 255  5396               IF (SPRITE_CMDS == 1)
 256  5396 53 50 52 53  	DB "SPRSET", 0
 256  539A 45 54 00
 257  539D 0E 4E        	DW SPRSET
 258  539F 53 50 52 47  	DB "SPRGRPMOV", 0
 258  53A3 52 50 4D 4F
 258  53A7 56 00
 259  53A9 CC 4E        	DW SPRGRPMOV
 260  53AB               ENDIF
 261  53AB               IF (SOUND_CMDS == 1)
 262  53AB 53 4E 44 53  	DB "SNDSFX", 0
 262  53AF 46 58 00
 263  53B2 B3 58        	DW SNDSFX
 264  53B4 53 4E 44 50  	DB "SNDPLYON", 0
 264  53B8 4C 59 4F 4E
 264  53BC 00
 265  53BD 7D 58        	DW SNDPLYON
 266  53BF 53 4E 44 50  	DB "SNDPLYOFF", 0
 266  53C3 4C 59 4F 46
 266  53C7 46 00
 267  53C9 90 58        	DW SNDPLYOFF
 268  53CB 53 4E 44 50  	DB "SNDPLYINI", 0
 268  53CF 4C 59 49 4E
 268  53D3 49 00
 269  53D5 33 58        	DW SNDPLYINIT
 270  53D7               ENDIF
 271  53D7               IF (SPRITE_CMDS == 1)
 272  53D7 53 50 52 45  	DB "SPRENABLE", 0
 272  53DB 4E 41 42 4C
 272  53DF 45 00
 273  53E1 B9 4D        	DW SPRENABLE
 274  53E3 53 50 52 44  	DB "SPRDISABLE", 0
 274  53E7 49 53 41 42
 274  53EB 4C 45 00
 275  53EE 09 4E        	DW SPRDISABLE
 276  53F0               ENDIF
 277  53F0               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 278  53F0 00           	DB 0
 279  53F1               ENDIF
 280  53F1              CMDS_B:
 281  53F1               IF (BLIT_CMDS == 1)
 282  53F1 42 4C 49 54  	DB "BLIT", 0
 282  53F5 00
 283  53F6 8A 5A        	DW BLIT
 284  53F8               ENDIF
 285  53F8               IF (BOX_CMDS == 1)
 286  53F8 42 4F 58 4D  	DB "BOXMEMCPY", 0
 286  53FC 45 4D 43 50
 286  5400 59 00
 287  5402 C2 5D        	DW BOXMEMCPY
 288  5404 42 4F 58 4D  	DB "BOXMEMVRM", 0
 288  5408 45 4D 56 52
 288  540C 4D 00
 289  540E F6 5D        	DW BOXMEMVRM
 290  5410               ENDIF
 291  5410               IF (BLIT_CMDS + BOX_CMDS > 0)
 292  5410 00           	DB 0
 293  5411               ENDIF
 294  5411              CMDS_T:
 295  5411               IF (TILE_CMDS == 1)
 296  5411 54 49 4C 45  	DB "TILERAM", 0
 296  5415 52 41 4D 00
 297  5419 CE 5B        	DW TILERAM
 298  541B 54 49 4C 45  	DB "TILEVRM", 0
 298  541F 56 52 4D 00
 299  5423 D1 5C        	DW TILEVRM
 300  5425               ENDIF
 301  5425               IF (TILE_CMDS > 0)
 302  5425 00           	DB 0
 303  5426               ENDIF
 304  5426              CMDS_A:
 305  5426               IF (ANIM_CMDS == 1)
 306  5426 41 4E 49 4D  	DB "ANIMSTART",0
 306  542A 53 54 41 52
 306  542E 54 00
 307  5430 69 52        	DW ANIMSTART
 308  5432 41 4E 49 4D  	DB "ANIMSTOP",0
 308  5436 53 54 4F 50
 308  543A 00
 309  543B 6D 52        	DW ANIMSTOP
 310  543D 41 4E 49 4D  	DB "ANIMITEMPAT",0
 310  5441 49 54 45 4D
 310  5445 50 41 54 00
 311  5449 2B 50        	DW ANIMITEMPAT
 312  544B 41 4E 49 4D  	DB "ANIMITEMPTR",0
 312  544F 49 54 45 4D
 312  5453 50 54 52 00
 313  5457 91 50        	DW ANIMITEMPTR_CMD
 314  5459 41 4E 49 4D  	DB "ANIMDEF",0
 314  545D 44 45 46 00
 315  5461 2C 51        	DW ANIMDEF
 316  5463 41 4E 49 4D  	DB "ANIMSPRITE",0
 316  5467 53 50 52 49
 316  546B 54 45 00
 317  546E F9 51        	DW ANIMSPRITE
 318  5470 00           	DB 0
 319  5471               ENDIF
 320  5471
 321  5471               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 322  5471              ; ****************************************************************************************************
 323  5471              ; function sets VRAM address
 324  5471              ; input HL=address
 325  5471              ; modifies AF
 326  5471              SETWRT_LOCAL:
 327  5471 7D           	LD	A, L
 328  5472 D3 99        	OUT	(099H), A
 329  5474 7C           	LD	A, H
 330  5475 E6 3F        	AND	03FH
 331  5477 F6 40        	OR	040H
 332  5479 D3 99        	OUT	(099H), A
 333  547B C9           	RET
 334  547C              ; ****************************************************************************************************
 335  547C               ENDIF
 336  547C
 337  547C               IF (VRAM_CMDS + TILE_CMDS > 0)
 338  547C              ; ****************************************************************************************************
 339  547C              ; function copies data from RAM to VRAM
 340  547C              ; input HL=address in RAM
 341  547C              ; input B=count
 342  547C              ; modifies AF
 343  547C              BBYTECOPY:
 344  547C ED A3        	OUTI
 345  547E C2 7C 54     	JP	NZ, BBYTECOPY
 346  5481 C9           	RET
 347  5482              ; ****************************************************************************************************
 348  5482               ENDIF
 349  5482
 350  5482              ; ****************************************************************************************************
 351  5482              ; function multiplies HL by 32
 352  5482              HPx32:
 353  5482 29           	ADD HL,HL
 354  5483              ; ****************************************************************************************************
 355  5483              ; function multiplies HL by 16
 356  5483              HLx16:
 357  5483 29           	ADD HL,HL
 358  5484              ; ****************************************************************************************************
 359  5484              ; function multiplies HL by 8
 360  5484              HLx8:
 361  5484 29          > ADD HL, HL
 361  5485 29          > ADD HL, HL
 361  5486 29          > ADD HL, HL
 362  5487 C9           	RET
 363  5488              ; ****************************************************************************************************
 364  5488
 365  5488              ; ****************************************************************************************************
 366  5488              ; function gets slot and subslot data for specific page
 367  5488              ; input A=page (0, 1 or 2)
 368  5488              ; output B = 0A8H register value
 369  5488              ; output D = 0 is no subslots, 1 if yes
 370  5488              ; output C = 0A8H value when page 3 slot equals to requested page slot
 371  5488              ; output E = subslot value if present
 372  5488              ; modifies AF, BC, DE, HL
 373  5488              GET_PAGE_INFO:
 374  5488 6F               LD L, A
 375  5489 C6 C1            ADD A, low (EXPTBL)
 376  548B 32 95 54         LD (GET_PAGE_INFO_L1+1), A
 377  548E DB A8            IN A, (0A8H)
 378  5490 47               LD B, A
 379  5491 E6 3F            AND 03FH
 380  5493 4F               LD C, A
 381  5494              GET_PAGE_INFO_L1:
 382  5494 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 383  5497 E6 80            AND 080H
 384  5499 28 1B            JR Z, GET_PAGE_INFO_L2
 385  549B                  ; expanded
 386  549B 2D               DEC L
 387  549C FA BB 54         JP M, GET_PAGE_INFO_L3
 388  549F 2D               DEC L
 389  54A0 FA B9 54         JP M, GET_PAGE_INFO_L4
 390  54A3                  ; page 2
 391  54A3 07               RLCA
 392  54A4 07               RLCA
 393  54A5              GET_PAGE_INFO_L5:
 394  54A5 E6 C0            AND 0C0H
 395  54A7 B1               OR C
 396  54A8 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 397  54AA 4F               LD C, A
 398  54AB 3A FF FF         LD A, (0FFFFH)
 399  54AE 2F               CPL
 400  54AF 5F               LD E, A
 401  54B0 16 01            LD D, 1
 402  54B2 78               LD A, B ; return stack
 403  54B3 D3 A8            OUT (0A8H), A
 404  54B5 C9               RET
 405  54B6              GET_PAGE_INFO_L2:
 406  54B6                  ; not expanded
 407  54B6 16 00            LD D, 0
 408  54B8 C9               RET
 409  54B9              GET_PAGE_INFO_L4:
 410  54B9                  ; page 1
 411  54B9 0F               RRCA
 412  54BA 0F               RRCA
 413  54BB              GET_PAGE_INFO_L3:
 414  54BB                  ; page 0
 415  54BB 0F               RRCA
 416  54BC 0F               RRCA
 417  54BD 18 E6            JR GET_PAGE_INFO_L5
 418  54BF              ; ****************************************************************************************************
 419  54BF
 420  54BF              ; ****************************************************************************************************
 421  54BF              ; function returns original slot and subslot info
 422  54BF              ; input B = 0A8H register value
 423  54BF              ; input D = 0 is no subslots, 1 if yes
 424  54BF              ; input C = 0A8H value when page 3 slot equals to requested page slot
 425  54BF              ; input E = subslot value if present
 426  54BF              ; modifies AF, disables interrupts
 427  54BF              RESTORE_PAGE_INFO:
 428  54BF 7A               LD A, D
 429  54C0 B7               OR A
 430  54C1 28 08            JR Z, RESTORE_PAGE_INFO_L1
 431  54C3 79               LD A, C
 432  54C4 F3           	DI
 433  54C5 D3 A8            OUT (0A8H), A
 434  54C7 7B               LD A, E
 435  54C8 32 FF FF         LD (0FFFFH), A
 436  54CB              RESTORE_PAGE_INFO_L1:
 437  54CB 78               LD A, B
 438  54CC D3 A8            OUT (0A8H), A
 439  54CE C9               RET
 440  54CF              ; ****************************************************************************************************
 441  54CF
 442  54CF              ; *******************************************************************************************************
 443  54CF              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 444  54CF              ; INPUT:  A = SLOT ID: EXXXSSPP
 445  54CF              ; E = EXPANDED FLAG
 446  54CF              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 447  54CF              ; PP = PRIMARY SLOT NUMBER
 448  54CF              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 449  54CF              ; CHANGES: AF, BC, DE
 450  54CF
 451  54CF              LOCAL_ENASLT:
 452  54CF CD EF 54         CALL L0353
 453  54D2 FA DC 54         JP M, L0340
 454  54D5 DB A8            IN A, (0A8H)
 455  54D7 A1               AND C
 456  54D8 B0               OR B
 457  54D9 D3 A8            OUT (0A8H), A
 458  54DB C9               RET
 459  54DC              L0340:
 460  54DC E5               PUSH HL
 461  54DD CD 14 55         CALL L0378
 462  54E0 4F               LD C, A
 463  54E1 06 00            LD B, 0
 464  54E3 7D               LD A, L
 465  54E4 A4               AND H
 466  54E5 B2               OR D
 467  54E6 21 C5 FC         LD HL, 0FCC5H
 468  54E9 09               ADD HL, BC
 469  54EA 77               LD (HL), A
 470  54EB E1               POP HL
 471  54EC 79               LD A, C
 472  54ED 18 E0            JR LOCAL_ENASLT
 473  54EF              L0353:
 474  54EF F3               DI
 475  54F0 F5               PUSH AF
 476  54F1 7C               LD A, H
 477  54F2 07               RLCA
 478  54F3 07               RLCA
 479  54F4 E6 03            AND 3
 480  54F6 5F               LD E, A
 481  54F7 3E C0            LD A, 0C0H
 482  54F9              L035D:
 483  54F9 07               RLCA
 484  54FA 07               RLCA
 485  54FB 1D               DEC E
 486  54FC F2 F9 54         JP P, L035D
 487  54FF 5F               LD E, A
 488  5500 2F               CPL
 489  5501 4F               LD C, A
 490  5502 F1               POP AF
 491  5503 F5               PUSH AF
 492  5504 E6 03            AND 3
 493  5506 3C               INC A
 494  5507 47               LD B, A
 495  5508 3E AB            LD A, 0ABH
 496  550A              L036E:
 497  550A C6 55            ADD A, 055H
 498  550C 10 FC            DJNZ L036E
 499  550E 57               LD D, A
 500  550F A3               AND E
 501  5510 47               LD B, A
 502  5511 F1               POP AF
 503  5512 A7               AND A
 504  5513 C9               RET
 505  5514              L0378:
 506  5514 F5               PUSH AF
 507  5515 7A               LD A, D
 508  5516 E6 C0            AND 0C0H
 509  5518 4F               LD C, A
 510  5519 F1               POP AF
 511  551A F5               PUSH AF
 512  551B 57               LD D, A
 513  551C DB A8            IN A, (0A8H)
 514  551E 47               LD B, A
 515  551F E6 3F            AND 03FH
 516  5521 B1               OR C
 517  5522 D3 A8            OUT (0A8H), A
 518  5524 7A               LD A, D
 519  5525 0F               RRCA
 520  5526 0F               RRCA
 521  5527 E6 03            AND 3
 522  5529 57               LD D, A
 523  552A 3E AB            LD A, 0ABH
 524  552C              L0390:
 525  552C C6 55            ADD A, 055H
 526  552E 15               DEC D
 527  552F F2 2C 55         JP P, L0390
 528  5532 A3               AND E
 529  5533 57               LD D, A
 530  5534 7B               LD A, E
 531  5535 2F               CPL
 532  5536 67               LD H, A
 533  5537 3A FF FF         LD A, (0FFFFH)
 534  553A 2F               CPL
 535  553B 6F               LD L, A
 536  553C A4               AND H
 537  553D B2               OR D
 538  553E 32 FF FF         LD (0FFFFH), A
 539  5541 78               LD A, B
 540  5542 D3 A8            OUT (0A8H), A
 541  5544 F1               POP AF
 542  5545 E6 03            AND 3
 543  5547 C9               RET
 544  5548              ; *******************************************************************************************************
 545  5548
 546  5548              ; *******************************************************************************************************
 547  5548              ; some common code to activate page 0 and place values needed to restore original page on stack
 548  5548              ; input IY=return address
 549  5548              ENABLE_PAGE0:
 550  5548 AF               XOR A
 551  5549 CD 88 54         CALL GET_PAGE_INFO
 552  554C C5               PUSH BC
 553  554D D5               PUSH DE
 554  554E 3A 41 F3         LD A, (RAMAD0)
 555  5551 26 00            LD H, 0
 556  5553 CD CF 54         CALL LOCAL_ENASLT
 557  5556 FD E9        	JP (IY)
 558  5558              ; *******************************************************************************************************
 559  5558
 560  5558              ; General BASIC CALL-instruction handler
 561  5558              CALLHAND:
 562  5558 E5           	PUSH HL
 563  5559 21 FD 52     	LD	HL, CMDS ; pointer table based on starting letter
 564  555C 3A 89 FD         LD A, (PROCNM)
 565  555F D6 41            SUB 'A'
 566  5561 87               ADD A, A
 567  5562 16 00            LD D, 0
 568  5564 5F               LD E, A
 569  5565 19               ADD HL, DE
 570  5566 5E               LD E, (HL)
 571  5567 23               INC HL
 572  5568 56               LD D, (HL)
 573  5569 7A               LD A, D
 574  556A B3               OR E
 575  556B 28 23            JR Z, .CMDNOTRECOGNIZED
 576  556D EB               EX DE, HL
 577  556E              .CHKCMD:
 578  556E 11 89 FD     	LD	DE, PROCNM
 579  5571 1A           .LOOP:	LD	A,(DE)
 580  5572 BE           	CP	(HL)
 581  5573 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 582  5575 13           	INC	DE
 583  5576 23           	INC	HL
 584  5577 A7           	AND	A
 585  5578 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 586  557A 5E           	LD	E,(HL)
 587  557B 23           	INC	HL
 588  557C 56           	LD	D,(HL)
 589  557D E1           	POP	HL		; routine address
 590  557E CD 9F 55     	CALL	GETPREVCHAR
 591  5581 CD 93 55     	CALL	.CALLDE		; Call routine
 592  5584 A7           	AND	A
 593  5585 C9           	RET
 594  5586
 595  5586              .TONEXTCMD:
 596  5586 0E FF        	LD	C,0FFH
 597  5588 AF           	XOR	A
 598  5589 ED B1        	CPIR			; Skip to end of instruction name
 599  558B 23           	INC	HL
 600  558C 23           	INC	HL		; Skip address
 601  558D BE           	CP	(HL)
 602  558E 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 603  5590              .CMDNOTRECOGNIZED:
 604  5590 E1           	POP	HL
 605  5591 37               SCF
 606  5592 C9           	RET
 607  5593
 608  5593              .CALLDE:
 609  5593 D5           	PUSH	DE
 610  5594 C9           	RET
 611  5595
 612  5595              ;---------------------------
 613  5595
 614  5595              ;GETSTRPNT:
 615  5595              ; OUT:
 616  5595              ; HL = String Address
 617  5595              ; B  = Lenght
 618  5595              ;        LD      HL,(USR)
 619  5595              ;        LD      B,(HL)
 620  5595              ;        INC     HL
 621  5595              ;        LD      E,(HL)
 622  5595              ;        INC     HL
 623  5595              ;        LD      D,(HL)
 624  5595              ;        EX      DE,HL
 625  5595              ;        RET
 626  5595
 627  5595              ;EVALTXTPARAM:
 628  5595              ;	CALL	CHKCHAR
 629  5595              ;	DEFB	"("             ; Check for (
 630  5595              ;	LD	IX,FRMEVL
 631  5595              ;	CALL	CALBAS		; Evaluate expression
 632  5595              ;       LD      A,(VALTYP)
 633  5595              ;        CP      3               ; Text type?
 634  5595              ;        JP      NZ,TYPE_MISMATCH
 635  5595              ;        PUSH	HL
 636  5595              ;        LD	IX,FRESTR         ; Free the temporary string
 637  5595              ;        CALL	CALBAS
 638  5595              ;        POP	HL
 639  5595              ;	CALL	CHKCHAR
 640  5595              ;	DEFB	")"             ; Check for )
 641  5595              ;        RET
 642  5595
 643  5595
 644  5595              CHKCHAR:
 645  5595 CD 9F 55     	CALL	GETPREVCHAR	; Get previous basic char
 646  5598 E3           	EX	(SP),HL
 647  5599 BE           	CP	(HL) 	        ; Check if good char
 648  559A 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 649  559C 23           	INC	HL
 650  559D E3           	EX	(SP),HL
 651  559E 23           	INC	HL		; Get next basic char
 652  559F
 653  559F              GETPREVCHAR:
 654  559F 2B           	DEC	HL
 655  55A0 DD 21 66 46  	LD	IX,CHRGTR
 656  55A4 C3 59 01     	JP      CALBAS
 657  55A7
 658  55A7
 659  55A7              TYPE_MISMATCH:
 660  55A7 1E 0D            LD E, 13 ; Type mismatch
 661  55A9 18 0A            JR THROW_ERROR
 662  55AB              SUBSCRIPT_OUT_OF_RANGE:
 663  55AB 1E 09            LD E,9 ; subscript out of range
 664  55AD 18 06        	JR THROW_ERROR
 665  55AF              OVERFLOW:
 666  55AF 1E 06        	LD E,6
 667  55B1 18 02        	JR THROW_ERROR
 668  55B3              SYNTAX_ERROR:
 669  55B3 1E 02            LD E, 2 ; Syntax error
 670  55B5              THROW_ERROR:
 671  55B5 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 672  55B9 C3 59 01     	JP	CALBAS
 673  55BC
 674  55BC              ;---------------------------
 675  55BC
 676  55BC               IF (RAM_CMDS == 1)
 677  55BC              ; *******************************************************************************************************
 678  55BC              ; function to handle CALL MEMCPY basic extension
 679  55BC              ; _MEMCPY ( INT source,
 680  55BC              ;			INT destination,
 681  55BC              ;			INT count,
 682  55BC              ; will put ram in page 0 also, page 1 is already there
 683  55BC              MEMCPY:
 684  55BC              	; opening (
 685  55BC CD 95 55     	CALL CHKCHAR
 686  55BF 28           	DB '('
 687  55C0              	; get source address
 688  55C0 DD 21 2F 54  	LD IX, FRMQNT
 689  55C4 CD 59 01     	CALL CALBAS
 690  55C7 D5           	PUSH DE
 691  55C8              	; comma
 692  55C8 CD 95 55     	CALL CHKCHAR
 693  55CB 2C           	DB ','
 694  55CC              	; get destination address
 695  55CC DD 21 2F 54  	LD IX, FRMQNT
 696  55D0 CD 59 01     	CALL CALBAS
 697  55D3 D5           	PUSH DE
 698  55D4              	; comma
 699  55D4 CD 95 55     	CALL CHKCHAR
 700  55D7 2C           	DB ','
 701  55D8              	; get length
 702  55D8 DD 21 2F 54  	LD IX, FRMQNT
 703  55DC CD 59 01     	CALL CALBAS
 704  55DF D5           	PUSH DE
 705  55E0              	; ending )
 706  55E0 CD 95 55     	CALL CHKCHAR
 707  55E3 29           	DB ')'
 708  55E4
 709  55E4              	; save position
 710  55E4 E5           	PUSH HL
 711  55E5 DD E1        	POP IX
 712  55E7
 713  55E7 C1           	POP BC ; count
 714  55E8 D1           	POP DE ; destination
 715  55E9 E1           	POP HL ; source
 716  55EA D9           	EXX
 717  55EB              	; enable page 0
 718  55EB FD 21 F2 55  	LD IY, .RET
 719  55EF C3 48 55     	JP ENABLE_PAGE0
 720  55F2              .RET:
 721  55F2 FB           	EI
 722  55F3 D9           	EXX
 723  55F4 ED B0        	LDIR
 724  55F6 D1               POP DE
 725  55F7 C1               POP BC
 726  55F8 CD BF 54         CALL RESTORE_PAGE_INFO
 727  55FB DD E5        	PUSH IX
 728  55FD E1           	POP HL
 729  55FE C9           	RET
 730  55FF              ; *******************************************************************************************************
 731  55FF               ENDIF
 732  55FF
 733  55FF               IF (VRAM_CMDS == 1)
 734  55FF              ; *******************************************************************************************************
 735  55FF              ; function to handle CALL FILVRM basic extension
 736  55FF              ; FILVRM ( INT offset,
 737  55FF              ;		   INT count,
 738  55FF              ;		   BYTE value,
 739  55FF              ;		   BYTE wait_vsync) >0 = true
 740  55FF              ; wait_vsync will issue HALT before copying
 741  55FF              FILVRM:
 742  55FF              	; opening (
 743  55FF CD 95 55     	CALL CHKCHAR
 744  5602 28           	DB '('
 745  5603              	; get offset address
 746  5603 DD 21 2F 54  	LD IX, FRMQNT
 747  5607 CD 59 01     	CALL CALBAS
 748  560A D5           	PUSH DE
 749  560B              	; comma
 750  560B CD 95 55     	CALL CHKCHAR
 751  560E 2C           	DB ','
 752  560F              	; get count
 753  560F DD 21 2F 54  	LD IX, FRMQNT
 754  5613 CD 59 01     	CALL CALBAS
 755  5616 D5           	PUSH DE
 756  5617              	; comma
 757  5617 CD 95 55     	CALL CHKCHAR
 758  561A 2C           	DB ','
 759  561B              	; get value
 760  561B DD 21 1C 52  	LD IX, GETBYT
 761  561F CD 59 01     	CALL CALBAS
 762  5622 F5           	PUSH AF
 763  5623              	; comma
 764  5623 CD 95 55     	CALL CHKCHAR
 765  5626 2C           	DB ','
 766  5627              	; get vsync wait
 767  5627 DD 21 1C 52  	LD IX, GETBYT
 768  562B CD 59 01     	CALL CALBAS
 769  562E F5           	PUSH AF
 770  562F              	; ending )
 771  562F CD 95 55     	CALL CHKCHAR
 772  5632 29           	DB ')'
 773  5633
 774  5633 FB               EI
 775  5634              	; save position
 776  5634 E5           	PUSH HL
 777  5635 DD E1        	POP IX
 778  5637
 779  5637              	; syntax ok
 780  5637              	; wait for vsync if needed
 781  5637 F1           	POP AF
 782  5638 B7           	OR A
 783  5639 28 01        	JR Z, .L1
 784  563B 76           	HALT
 785  563C
 786  563C              .L1:
 787  563C F1               POP AF ; value
 788  563D C1               POP BC ; count
 789  563E E1               POP HL ; offset
 790  563F CD 56 00         CALL BIOS_FILVRM
 791  5642
 792  5642              .L3:
 793  5642 DD E5        	PUSH IX
 794  5644 E1           	POP HL
 795  5645 C9           	RET
 796  5646              ; *******************************************************************************************************
 797  5646               ENDIF
 798  5646
 799  5646               IF (RAM_CMDS == 1)
 800  5646              ; *******************************************************************************************************
 801  5646              ; function to handle CALL FILRAM basic extension
 802  5646              ; FILRAM ( INT start address,
 803  5646              ;		   INT count,
 804  5646              ;		   BYTE value,
 805  5646              ; will put ram in page 0 also, page 1 is already there
 806  5646              FILRAM:
 807  5646              	; opening (
 808  5646 CD 95 55     	CALL CHKCHAR
 809  5649 28           	DB '('
 810  564A              	; get start address
 811  564A DD 21 2F 54  	LD IX, FRMQNT
 812  564E CD 59 01     	CALL CALBAS
 813  5651 D5           	PUSH DE
 814  5652              	; comma
 815  5652 CD 95 55     	CALL CHKCHAR
 816  5655 2C           	DB ','
 817  5656              	; get count
 818  5656 DD 21 2F 54  	LD IX, FRMQNT
 819  565A CD 59 01     	CALL CALBAS
 820  565D D5           	PUSH DE
 821  565E              	; comma
 822  565E CD 95 55     	CALL CHKCHAR
 823  5661 2C           	DB ','
 824  5662              	; get value
 825  5662 DD 21 1C 52  	LD IX, GETBYT
 826  5666 CD 59 01     	CALL CALBAS
 827  5669 F5           	PUSH AF
 828  566A              	; ending )
 829  566A CD 95 55     	CALL CHKCHAR
 830  566D 29           	DB ')'
 831  566E
 832  566E              	; save position
 833  566E E5           	PUSH HL
 834  566F DD E1        	POP IX
 835  5671
 836  5671 D1           	POP DE ; actually AF
 837  5672 C1           	POP BC ; count
 838  5673 E1           	POP HL ; start address
 839  5674 78           	LD A, B
 840  5675 B7           	OR A
 841  5676 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 842  5678 B1           	OR C
 843  5679 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 844  567B 79           	LD A, C
 845  567C 3D           	DEC A
 846  567D 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 847  567F              	; one byte to fill
 848  567F 72           	LD (HL), D
 849  5680 18 12        	JR .EXIT
 850  5682              .L1:
 851  5682 D9           	EXX
 852  5683              	; enable page 0
 853  5683 FD 21 8A 56  	LD IY, .RET
 854  5687 C3 48 55     	JP ENABLE_PAGE0
 855  568A              .RET:
 856  568A FB           	EI
 857  568B D9           	EXX
 858  568C CD 98 56     	CALL .FILLVALUE
 859  568F D1               POP DE
 860  5690 C1               POP BC
 861  5691 CD BF 54         CALL RESTORE_PAGE_INFO
 862  5694              .EXIT:
 863  5694 DD E5        	PUSH IX
 864  5696 E1           	POP HL
 865  5697 C9           	RET
 866  5698
 867  5698              .FILLVALUE:
 868  5698 72               LD (HL), D
 869  5699 54               LD D, H
 870  569A 5D               LD E, L
 871  569B 13               INC DE
 872  569C 0B               DEC BC
 873  569D ED B0            LDIR
 874  569F C9               RET
 875  56A0              ; *******************************************************************************************************
 876  56A0               ENDIF
 877  56A0
 878  56A0               IF (GENCAL_CMD == 1)
 879  56A0              ; *******************************************************************************************************
 880  56A0              ; function to handle CALL GENCAL basic extension
 881  56A0              ; GENCAL ( INT fn_addr, = address of the function to call
 882  56A0              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 883  56A0              ; output values of reristers will also be stored at reg_list_ptr
 884  56A0              GENCAL_VAR_SP:
 885  56A0 00 00            DW 0
 886  56A2              GENCAL_VAR_SP2:
 887  56A2 00 00            DW 0
 888  56A4              GENCAL:
 889  56A4              	; opening (
 890  56A4 CD 95 55     	CALL CHKCHAR
 891  56A7 28           	DB '('
 892  56A8              	; get function address
 893  56A8 DD 21 2F 54  	LD IX, FRMQNT
 894  56AC CD 59 01     	CALL CALBAS
 895  56AF D5           	PUSH DE
 896  56B0              	; comma
 897  56B0 CD 95 55     	CALL CHKCHAR
 898  56B3 2C           	DB ','
 899  56B4              	; get pointer to register list
 900  56B4 DD 21 2F 54  	LD IX, FRMQNT
 901  56B8 CD 59 01     	CALL CALBAS
 902  56BB D5           	PUSH DE
 903  56BC              	; ending )
 904  56BC CD 95 55     	CALL CHKCHAR
 905  56BF 29           	DB ')'
 906  56C0
 907  56C0              	; save BASIC token position
 908  56C0 E5           	PUSH HL
 909  56C1 D9               EXX
 910  56C2 E1           	POP HL ; HL'=next basic token
 911  56C3 D9               EXX
 912  56C4
 913  56C4 E1               POP HL ; get pointer to register values
 914  56C5 F3           	DI
 915  56C6 ED 73 A0 56      LD (GENCAL_VAR_SP), SP
 916  56CA F9               LD SP, HL
 917  56CB F1               POP AF
 918  56CC C1               POP BC
 919  56CD D1               POP DE
 920  56CE E1               POP HL
 921  56CF DD E1            POP IX
 922  56D1 FD E1            POP IY
 923  56D3 D9               EXX
 924  56D4 ED 73 A2 56      LD (GENCAL_VAR_SP2), SP
 925  56D8 ED 7B A0 56      LD SP, (GENCAL_VAR_SP)
 926  56DC FB               EI
 927  56DD D1               POP DE ; get function to call
 928  56DE E5               PUSH HL
 929  56DF CD FA 56         CALL .EXXDECALL
 930  56E2 F3               DI
 931  56E3 ED 73 A0 56      LD (GENCAL_VAR_SP), SP
 932  56E7 ED 7B A2 56      LD SP, (GENCAL_VAR_SP2)
 933  56EB FD E5            PUSH IY
 934  56ED DD E5            PUSH IX
 935  56EF E5               PUSH HL
 936  56F0 D5               PUSH DE
 937  56F1 C5               PUSH BC
 938  56F2 F5               PUSH AF
 939  56F3 ED 7B A0 56      LD SP, (GENCAL_VAR_SP)
 940  56F7 FB               EI
 941  56F8 E1               POP HL
 942  56F9 C9           	RET
 943  56FA
 944  56FA              .EXXDECALL:
 945  56FA D5               PUSH DE
 946  56FB D9               EXX
 947  56FC C9               RET
 948  56FD              ; *******************************************************************************************************
 949  56FD               ENDIF
 950  56FD
 951  56FD               IF (VRAM_CMDS == 1)
 952  56FD              ; *******************************************************************************************************
 953  56FD              ; function to handle CALL MEMVRM basic extension
 954  56FD              ; copies from RAM to VRAM
 955  56FD              ; _MEMVRM ( INT source,
 956  56FD              ;			INT destination,
 957  56FD              ;			INT count,
 958  56FD              ;			BYTE wait_vsync) >0 = true
 959  56FD              ; will put ram in page 0 also, page 1 is already there
 960  56FD              ; wait_vsync will issue HALT before copying
 961  56FD              MEMVRM:
 962  56FD              	; opening (
 963  56FD CD 95 55     	CALL CHKCHAR
 964  5700 28           	DB '('
 965  5701              	; get source address
 966  5701 DD 21 2F 54  	LD IX, FRMQNT
 967  5705 CD 59 01     	CALL CALBAS
 968  5708 D5           	PUSH DE
 969  5709              	; comma
 970  5709 CD 95 55     	CALL CHKCHAR
 971  570C 2C           	DB ','
 972  570D              	; get destination address
 973  570D DD 21 2F 54  	LD IX, FRMQNT
 974  5711 CD 59 01     	CALL CALBAS
 975  5714 D5           	PUSH DE
 976  5715              	; comma
 977  5715 CD 95 55     	CALL CHKCHAR
 978  5718 2C           	DB ','
 979  5719              	; get length
 980  5719 DD 21 2F 54  	LD IX, FRMQNT
 981  571D CD 59 01     	CALL CALBAS
 982  5720 D5           	PUSH DE
 983  5721              	; comma
 984  5721 CD 95 55     	CALL CHKCHAR
 985  5724 2C           	DB ','
 986  5725              	; get vsync wait
 987  5725 DD 21 1C 52  	LD IX, GETBYT
 988  5729 CD 59 01     	CALL CALBAS
 989  572C F5           	PUSH AF
 990  572D              	; ending )
 991  572D CD 95 55     	CALL CHKCHAR
 992  5730 29           	DB ')'
 993  5731
 994  5731                  ; save position in BASIC text
 995  5731 E5           	PUSH HL
 996  5732 DD E1        	POP IX
 997  5734
 998  5734 F1           	POP AF ; wait vsync
 999  5735 B7           	OR A
1000  5736 28 03        	JR Z, .L1
1001  5738 FB               EI
1002  5739 76           	HALT
1003  573A F3           	DI
1004  573B              .L1:
1005  573B              	; pop LDIR parameters and store away for later
1006  573B C1           	POP BC ; count
1007  573C D1           	POP DE ; vram destination
1008  573D E1           	POP HL ; ram source
1009  573E D9           	EXX
1010  573F FD 21 46 57   	LD IY, .RET
1011  5743 C3 48 55     	JP ENABLE_PAGE0
1012  5746              .RET:
1013  5746 FB           	EI
1014  5747 D9           	EXX
1015  5748 CD 54 57     	CALL .LDIRVM
1016  574B D1               POP DE
1017  574C C1               POP BC
1018  574D CD BF 54         CALL RESTORE_PAGE_INFO
1019  5750 DD E5        	PUSH IX
1020  5752 E1           	POP HL
1021  5753 C9           	RET
1022  5754
1023  5754              .LDIRVM:
1024  5754 EB           	EX DE, HL
1025  5755 F3           	DI
1026  5756 CD 71 54     	CALL SETWRT_LOCAL
1027  5759 FB           	EI
1028  575A EB           	EX DE, HL
1029  575B 78           	LD A, B
1030  575C B7           	OR A
1031  575D 28 0D        	JR Z, .L3
1032  575F C5           	PUSH BC
1033  5760 0E 98        	LD C, #98
1034  5762              .L2:
1035  5762 50           	LD D, B
1036  5763 06 00        	LD B, 0
1037  5765 CD 7C 54     	CALL BBYTECOPY
1038  5768 42           	LD B, D
1039  5769 10 F7        	DJNZ .L2
1040  576B C1           	POP BC
1041  576C              .L3:
1042  576C 79           	LD A, C
1043  576D B7           	OR A
1044  576E C8           	RET Z
1045  576F 41           	LD B, C
1046  5770 0E 98        	LD C, #98
1047  5772 C3 7C 54     	JP BBYTECOPY
1048  5775              ; *******************************************************************************************************
1049  5775               ENDIF
1050  5775
1051  5775               IF (VRAM_CMDS == 1)
1052  5775              ; *******************************************************************************************************
1053  5775              ; function to handle CALL VRMMEM basic extension
1054  5775              ; copies from RAM to VRAM
1055  5775              ; _VRMMEM ( INT source,
1056  5775              ;			INT destination,
1057  5775              ;			INT count
1058  5775              ; will put ram in page 0 also, page 1 is already there
1059  5775              VRMMEM:
1060  5775              	; opening (
1061  5775 CD 95 55     	CALL CHKCHAR
1062  5778 28           	DB '('
1063  5779              	; get source address
1064  5779 DD 21 2F 54  	LD IX, FRMQNT
1065  577D CD 59 01     	CALL CALBAS
1066  5780 D5           	PUSH DE
1067  5781              	; comma
1068  5781 CD 95 55     	CALL CHKCHAR
1069  5784 2C           	DB ','
1070  5785              	; get destination address
1071  5785 DD 21 2F 54  	LD IX, FRMQNT
1072  5789 CD 59 01     	CALL CALBAS
1073  578C D5           	PUSH DE
1074  578D              	; comma
1075  578D CD 95 55     	CALL CHKCHAR
1076  5790 2C           	DB ','
1077  5791              	; get length
1078  5791 DD 21 2F 54  	LD IX, FRMQNT
1079  5795 CD 59 01     	CALL CALBAS
1080  5798 D5           	PUSH DE
1081  5799              	; ending )
1082  5799 CD 95 55     	CALL CHKCHAR
1083  579C 29           	DB ')'
1084  579D
1085  579D                  ; save position in BASIC text
1086  579D E5           	PUSH HL
1087  579E DD E1        	POP IX
1088  57A0
1089  57A0 C1           	POP BC ; count
1090  57A1 D1           	POP DE ; destination
1091  57A2 E1           	POP HL ; source
1092  57A3 D9           	EXX
1093  57A4 FD 21 AB 57  	LD IY, .RET
1094  57A8 C3 48 55     	JP ENABLE_PAGE0
1095  57AB              .RET:
1096  57AB FB           	EI
1097  57AC D9           	EXX
1098  57AD CD B9 57     	CALL .LDIRMV
1099  57B0 D1               POP DE
1100  57B1 C1               POP BC
1101  57B2 CD BF 54         CALL RESTORE_PAGE_INFO
1102  57B5 DD E5        	PUSH IX
1103  57B7 E1           	POP HL
1104  57B8 C9           	RET
1105  57B9
1106  57B9              .LDIRMV:
1107  57B9              	; set VRAM address *exactly* as in ROM, otherwise corruption
1108  57B9 7D           	LD	A, L
1109  57BA F3           	DI
1110  57BB D3 99        	OUT	(099H), A
1111  57BD 7C           	LD	A, H
1112  57BE E6 3F        	AND	03FH
1113  57C0 D3 99        	OUT	(099H), A
1114  57C2 FB           	EI
1115  57C3              	;EX (SP), HL
1116  57C3              	;EX (SP), HL
1117  57C3              	;NOP
1118  57C3              	;NOP
1119  57C3              .L4:
1120  57C3 DB 98            IN A, (#98)
1121  57C5 12           	LD (DE), A
1122  57C6 13               INC DE
1123  57C7 0B               DEC BC
1124  57C8 79               LD A, C
1125  57C9 B0               OR B
1126  57CA 20 F7            JR NZ, .L4
1127  57CC C9               RET
1128  57CD              ; *******************************************************************************************************
1129  57CD               ENDIF
1130  57CD
1131  57CD              ; *******************************************************************************************************
1132  57CD              ; H.TIMI function
1133  57CD              MBGE_HTIMI:
1134  57CD               EXPORT MBGE_HTIMI
1135  57CD F5           	PUSH AF
1136  57CE
1137  57CE               IF (SPRITE_CMDS == 1)
1138  57CE CD 01 4D     	CALL SPRATR_UPDATE
1139  57D1               ENDIF
1140  57D1
1141  57D1               IF (SOUND_CMDS == 1)
1142  57D1 3A F7 4C     	LD A, (SOUND_ENABLED)
1143  57D4 B7           	OR A
1144  57D5 28 2A        	JR Z, .EXIT
1145  57D7
1146  57D7              	; enable page 2
1147  57D7 3E 02            LD A, 2
1148  57D9 CD 88 54         CALL GET_PAGE_INFO
1149  57DC C5               PUSH BC
1150  57DD D5               PUSH DE
1151  57DE 3A 43 F3         LD A, (RAMAD2)
1152  57E1 26 80            LD H, 080H
1153  57E3 CD CF 54         CALL LOCAL_ENASLT
1154  57E6              	; enable page 0
1155  57E6 AF               XOR A
1156  57E7 CD 88 54         CALL GET_PAGE_INFO
1157  57EA C5               PUSH BC
1158  57EB D5               PUSH DE
1159  57EC 3A 41 F3         LD A, (RAMAD0)
1160  57EF 26 00            LD H, 0
1161  57F1 CD CF 54         CALL LOCAL_ENASLT
1162  57F4
1163  57F4 CD 33 42     	CALL PLY_AKG_PLAY
1164  57F7
1165  57F7              	; restore page 0
1166  57F7 D1               POP DE
1167  57F8 C1               POP BC
1168  57F9 CD BF 54         CALL RESTORE_PAGE_INFO
1169  57FC              	; restore page 2
1170  57FC D1               POP DE
1171  57FD C1               POP BC
1172  57FE CD BF 54         CALL RESTORE_PAGE_INFO
1173  5801               ENDIF
1174  5801
1175  5801              .EXIT:
1176  5801 F1           	POP AF
1177  5802 C3 F0 4C     	JP ORIG.HTIMI
1178  5805              ; *******************************************************************************************************
1179  5805
1180  5805              ; *******************************************************************************************************
1181  5805              ; interrupt handler when page 0 enabled
1182  5805              VBLANK:
1183  5805              	EXPORT VBLANK
1184  5805
1185  5805 F5               PUSH AF
1186  5806              	; is VDP originator ?
1187  5806 DB 99        	IN	A, (099H)
1188  5808 A7           	AND	A
1189  5809 F2 2F 58     	JP P, .EXIT
1190  580C
1191  580C               IF (SOUND_CMDS == 1)
1192  580C 3A F7 4C     	LD A, (SOUND_ENABLED)
1193  580F B7           	OR A
1194  5810 28 1D        	JR Z, .EXIT
1195  5812
1196  5812 C5               PUSH BC
1197  5813 D5               PUSH DE
1198  5814 E5               PUSH HL
1199  5815 08               EX AF, AF'
1200  5816 D9               EXX
1201  5817 F5               PUSH AF
1202  5818 C5               PUSH BC
1203  5819 D5               PUSH DE
1204  581A E5               PUSH HL
1205  581B DD E5            PUSH IX
1206  581D FD E5            PUSH IY
1207  581F
1208  581F CD 33 42     	CALL PLY_AKG_PLAY
1209  5822
1210  5822 FD E1            POP IY
1211  5824 DD E1            POP IX
1212  5826 E1               POP HL
1213  5827 D1               POP DE
1214  5828 C1               POP BC
1215  5829 F1               POP AF
1216  582A 08               EX AF, AF'
1217  582B D9               EXX
1218  582C E1               POP HL
1219  582D D1               POP DE
1220  582E C1               POP BC
1221  582F               ENDIF
1222  582F
1223  582F              .EXIT:
1224  582F F1           	POP AF
1225  5830 FB           	EI
1226  5831 ED 4D        	RETI
1227  5833              ; *******************************************************************************************************
1228  5833
1229  5833               IF (SOUND_CMDS == 1)
1230  5833              ; *******************************************************************************************************
1231  5833              ; function to handle CALL SNDPLYINIT basic extension
1232  5833              ; initializes sound player
1233  5833              ; _SNDPLYINIT ( INT music_offset,
1234  5833              ;				INT sfx_offset, can be -1 if no SFX
1235  5833              ; will put ram in page 0 also, page 1 is already there
1236  5833              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1237  5833              SNDPLYINIT:
1238  5833              	; opening (
1239  5833 CD 95 55     	CALL CHKCHAR
1240  5836 28           	DB '('
1241  5837              	; get music address
1242  5837 DD 21 2F 54  	LD IX, FRMQNT
1243  583B CD 59 01     	CALL CALBAS
1244  583E D5           	PUSH DE
1245  583F              	; comma
1246  583F CD 95 55     	CALL CHKCHAR
1247  5842 2C           	DB ','
1248  5843              	; get sfx address
1249  5843 DD 21 2F 54  	LD IX, FRMQNT
1250  5847 CD 59 01     	CALL CALBAS
1251  584A D5           	PUSH DE
1252  584B              	; ending )
1253  584B CD 95 55     	CALL CHKCHAR
1254  584E 29           	DB ')'
1255  584F
1256  584F                  ; save position in BASIC text
1257  584F 44           	LD B, H
1258  5850 4D           	LD C, L
1259  5851
1260  5851              	; pop LDIR parameters and store away for later
1261  5851 D1           	POP DE ; sfx address
1262  5852 E1           	POP HL ; music address
1263  5853 C5           	PUSH BC ; basic text location
1264  5854 D9           	EXX
1265  5855 FD 21 5C 58  	LD IY, .RET
1266  5859 C3 48 55     	JP ENABLE_PAGE0
1267  585C              .RET:
1268  585C D9           	EXX
1269  585D
1270  585D D5           	PUSH DE
1271  585E AF           	XOR A
1272  585F              	; HL = music location
1273  585F CD 62 41     	CALL PLY_AKG_INIT
1274  5862 3E 01        	LD A, 1
1275  5864 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1276  5867
1277  5867 E1           	POP HL ; SFX
1278  5868              	; check if SFX address -1
1279  5868 23           	INC HL
1280  5869 7D           	LD A, L
1281  586A B4           	OR H
1282  586B 28 09        	JR Z,.L1
1283  586D 2B           	DEC HL
1284  586E CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1285  5871 3E 01        	LD A, 1
1286  5873 32 F6 4C     	LD (SFX_INIT_STATUS), A
1287  5876              .L1:
1288  5876 D1               POP DE
1289  5877 C1               POP BC
1290  5878 CD BF 54         CALL RESTORE_PAGE_INFO
1291  587B
1292  587B E1           	POP HL
1293  587C C9           	RET
1294  587D              ; *******************************************************************************************************
1295  587D
1296  587D              ; *******************************************************************************************************
1297  587D              ; function to handle CALL SNDPLYON basic extension
1298  587D              ; enables sound player
1299  587D              ; _SNDPLYON
1300  587D              ; sets SOUND_ENABLED variable to 1 if init call was done
1301  587D              ; if not throws out of data error
1302  587D              SNDPLYON:
1303  587D 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1304  5880 B7           	OR A
1305  5881 20 05        	JR NZ, .L1
1306  5883              	; player not initialized, throw error
1307  5883 1E 04        	LD E, 04 ; Out of DATA
1308  5885 C3 B5 55     	JP THROW_ERROR
1309  5888              .L1:
1310  5888 32 F7 4C     	LD (SOUND_ENABLED), A
1311  588B              	; disable key click
1312  588B AF           	XOR A
1313  588C 32 DB F3     	LD (CLIKSW), A
1314  588F C9           	RET
1315  5890              ; *******************************************************************************************************
1316  5890
1317  5890              ; *******************************************************************************************************
1318  5890              ; function to handle CALL SNDPLYOFF basic extension
1319  5890              ; disables sound player
1320  5890              ; _SNDPLYOFF
1321  5890              ; sets SOUND_ENABLED variable to 0
1322  5890              ; calls AKG to stop music and SFX on all channels if initialized
1323  5890              SNDPLYOFF:
1324  5890 3A F7 4C     	LD A, (SOUND_ENABLED)
1325  5893 B7           	OR A
1326  5894 C8           	RET Z ; already stopped
1327  5895 AF           	XOR A
1328  5896 32 F7 4C     	LD (SOUND_ENABLED), A
1329  5899 E5           	PUSH HL
1330  589A CD 21 42     	CALL PLY_AKG_STOP
1331  589D 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1332  58A0 B7           	OR A
1333  58A1 28 0E        	JR Z, .EXIT ; SFX not in use
1334  58A3 AF           	XOR A
1335  58A4 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1336  58A7 3E 01        	LD A, 1
1337  58A9 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1338  58AC 3E 02        	LD A, 2
1339  58AE CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1340  58B1              .EXIT:
1341  58B1 E1           	POP HL
1342  58B2 C9           	RET
1343  58B3              ; *******************************************************************************************************
1344  58B3
1345  58B3              ; *******************************************************************************************************
1346  58B3              ; function to handle CALL SNDSFX basic extension
1347  58B3              ; plays a sound effect
1348  58B3              ; _SNDSFX ( BYTE sfx_number, >0
1349  58B3              ;			BYTE channel, = 0,1 or 2
1350  58B3              ;			BYTE inverted_volume = 0-16, 0 being full volume
1351  58B3              ; will put ram in page 0 also, page 1 is already there
1352  58B3              ; if sound off throws illegal function call
1353  58B3              ; if sfx not initialized, throws out of data
1354  58B3              SNDSFX:
1355  58B3              	; opening (
1356  58B3 CD 95 55     	CALL CHKCHAR
1357  58B6 28           	DB '('
1358  58B7              	; get sfx_number
1359  58B7 DD 21 1C 52  	LD IX, GETBYT
1360  58BB CD 59 01     	CALL CALBAS
1361  58BE D5           	PUSH DE
1362  58BF              	; comma
1363  58BF CD 95 55     	CALL CHKCHAR
1364  58C2 2C           	DB ','
1365  58C3              	; get sfx address
1366  58C3 DD 21 1C 52  	LD IX, GETBYT
1367  58C7 CD 59 01     	CALL CALBAS
1368  58CA D5           	PUSH DE
1369  58CB              	; comma
1370  58CB CD 95 55     	CALL CHKCHAR
1371  58CE 2C           	DB ','
1372  58CF              	; get inverted volume
1373  58CF DD 21 1C 52  	LD IX, GETBYT
1374  58D3 CD 59 01     	CALL CALBAS
1375  58D6 D5           	PUSH DE
1376  58D7              	; ending )
1377  58D7 CD 95 55     	CALL CHKCHAR
1378  58DA 29           	DB ')'
1379  58DB
1380  58DB 3A F7 4C     	LD A, (SOUND_ENABLED)
1381  58DE B7           	OR A
1382  58DF 20 05        	JR NZ, .L1
1383  58E1              	; sound disabled, throw illegal function call
1384  58E1 1E 05        	LD E, 5
1385  58E3 C3 B5 55     	JP THROW_ERROR
1386  58E6              .L1:
1387  58E6 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1388  58E9 B7           	OR A
1389  58EA 20 05        	JR NZ, .L2
1390  58EC              	; sfx data not initialized, throw out of data
1391  58EC 1E 04        	LD E, 4
1392  58EE C3 B5 55     	JP THROW_ERROR
1393  58F1              .L2:
1394  58F1              	; pop  parameters and store away for later
1395  58F1 D1           	POP DE ; inverted volume
1396  58F2 43           	LD B, E
1397  58F3 D1           	POP DE ; channel
1398  58F4 4B           	LD C, E
1399  58F5 D1           	POP DE
1400  58F6 7B           	LD A, E
1401  58F7 08           	EX AF, AF'
1402  58F8 E5           	PUSH HL ; basic text location
1403  58F9 D9           	EXX
1404  58FA FD 21 01 59  	LD IY, .RET
1405  58FE C3 48 55     	JP ENABLE_PAGE0
1406  5901              .RET:
1407  5901 D9           	EXX
1408  5902 08           	EX AF, AF'
1409  5903 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1410  5906
1411  5906 D1               POP DE
1412  5907 C1               POP BC
1413  5908 CD BF 54         CALL RESTORE_PAGE_INFO
1414  590B
1415  590B E1           	POP HL
1416  590C C9           	RET
1417  590D              ; *******************************************************************************************************
1418  590D               ENDIF
1419  590D
1420  590D               IF (BLIT_CMDS == 1)
1421  590D              ; *******************************************************************************************************
1422  590D              ; function rotates mask and data of several characters and applies to background data
1423  590D              ; this handles x-shift from 0 to 4
1424  590D              ; contains self-modifying code that is set-up from external function
1425  590D              ; input HL=pointer to mask data
1426  590D              ; input HL'=pointer to character data
1427  590D              ; input DE=output buffer containing background data
1428  590D              ; input BC=DE+8
1429  590D              ; input A=number of characters to process
1430  590D              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1431  590D              SHIFT04:
1432  590D 08           	EX AF, AF'
1433  590E 7E           	LD A, (HL) ; get mask
1434  590F D9           	EXX
1435  5910 57           	LD D, A
1436  5911 1E FF        	LD E, #FF
1437  5913 37           	SCF
1438  5914              .M1:
1439  5914 18 FE        	JR .M1 ; this is self-modifying part
1440  5916 CB 1A        	RR D
1441  5918 CB 1B        	RR E
1442  591A CB 1A        	RR D
1443  591C CB 1B        	RR E
1444  591E CB 1A        	RR D
1445  5920 CB 1B        	RR E
1446  5922 CB 1A        	RR D
1447  5924 CB 1B        	RR E
1448  5926
1449  5926 46           	LD B, (HL) ; get data
1450  5927 0E 00        	LD C, 0
1451  5929              .M2:
1452  5929 18 FE        	JR .M2 ; also self-modifying part
1453  592B CB 38        	SRL B
1454  592D CB 19        	RR C
1455  592F CB 38        	SRL B
1456  5931 CB 19        	RR C
1457  5933 CB 38        	SRL B
1458  5935 CB 19        	RR C
1459  5937 CB 38        	SRL B
1460  5939 CB 19        	RR C
1461  593B
1462  593B D9           	EXX
1463  593C 1A           	LD A, (DE) ; background
1464  593D D9           	EXX
1465  593E A2           	AND D
1466  593F B0           	OR B
1467  5940 D9           	EXX
1468  5941 12           	LD (DE), A
1469  5942
1470  5942 0A           	LD A, (BC)
1471  5943 D9           	EXX
1472  5944 A3           	AND E
1473  5945 B1           	OR C
1474  5946 23           	INC HL
1475  5947 D9           	EXX
1476  5948 02           	LD (BC), A
1477  5949
1478  5949 23           	INC HL
1479  594A 13           	INC DE
1480  594B 03           	INC BC
1481  594C
1482  594C 08           	EX AF, AF'
1483  594D 3D           	DEC A
1484  594E C2 0D 59     	JP NZ, SHIFT04
1485  5951 C9           	RET
1486  5952              ; *******************************************************************************************************
1487  5952
1488  5952              ; *******************************************************************************************************
1489  5952              ; function rotates mask and data of several characters and applies to background data
1490  5952              ; this handles x-shift from 5 to 8
1491  5952              ; contains self-modifying code that is set-up from external function
1492  5952              ; input HL=pointer to mask data
1493  5952              ; input HL'=pointer to character data
1494  5952              ; input DE=output buffer containing background data
1495  5952              ; input BC=DE+8
1496  5952              ; input A=number of characters to process
1497  5952              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1498  5952              SHIFT58:
1499  5952 08           	EX AF, AF'
1500  5953 7E           	LD A, (HL) ; get mask
1501  5954 D9           	EXX
1502  5955 57           	LD D, A
1503  5956 1E FF        	LD E, #FF
1504  5958 37           	SCF
1505  5959              .M1:
1506  5959 18 FE        	JR .M1 ; this is self-modifying part
1507  595B CB 12        	RL D
1508  595D CB 13        	RL E
1509  595F CB 12        	RL D
1510  5961 CB 13        	RL E
1511  5963 CB 12        	RL D
1512  5965 CB 13        	RL E
1513  5967
1514  5967 46           	LD B, (HL)
1515  5968 0E 00        	LD C, 0
1516  596A              .M2:
1517  596A 18 FE        	JR .M2 ; also self-modifying part
1518  596C CB 20        	SLA B
1519  596E CB 11        	RL C
1520  5970 CB 20        	SLA B
1521  5972 CB 11        	RL C
1522  5974 CB 20        	SLA B
1523  5976 CB 11        	RL C
1524  5978
1525  5978 D9           	EXX
1526  5979 1A           	LD A, (DE) ; background
1527  597A D9           	EXX
1528  597B A3           	AND E
1529  597C B1           	OR C
1530  597D D9           	EXX
1531  597E 12           	LD (DE), A
1532  597F
1533  597F 0A           	LD A, (BC)
1534  5980 D9           	EXX
1535  5981 A2           	AND D
1536  5982 B0           	OR B
1537  5983 23           	INC HL
1538  5984 D9           	EXX
1539  5985 02           	LD (BC), A
1540  5986
1541  5986 23           	INC HL
1542  5987 13           	INC DE
1543  5988 03           	INC BC
1544  5989
1545  5989 08           	EX AF, AF'
1546  598A 3D           	DEC A
1547  598B C2 52 59     	JP NZ, SHIFT58
1548  598E C9           	RET
1549  598F              ; *******************************************************************************************************
1550  598F
1551  598F              ; *******************************************************************************************************
1552  598F              ; routine that shifts one row of characters
1553  598F              ; contains self-modifying code that is set-up from external function
1554  598F              ; input HL=pointer to mask data
1555  598F              ; input HL'=pointer to character data
1556  598F              ; input DE=output buffer containing background data
1557  598F              ; input A=number of characters to process
1558  598F              ; input IX=pointer to structure describing input data
1559  598F              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1560  598F              SHIFT_ROW:
1561  598F F5           	PUSH AF
1562  5990 ED 53 E8 52  		LD (BLIT_TMP1), DE
1563  5994 E5           		PUSH HL
1564  5995 CD D8 59     			CALL .ADDYSHIFT
1565  5998 E1           		POP HL
1566  5999 ED 53 EA 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1567  599D              .L1:
1568  599D 3E 08        		LD A, 8
1569  599F DD 96 02     		SUB (IX+2) ; y shift
1570  59A2              .CALL1:
1571  59A2 CD 00 00     		CALL 0
1572  59A5 DD 7E 02     		LD A, (IX+2); y shift
1573  59A8 B7           		OR A
1574  59A9 28 26        		JR Z, .DONE
1575  59AB ED 5B E8 52  		LD DE, (BLIT_TMP1)
1576  59AF E5           		PUSH HL
1577  59B0 CD E6 59     			CALL .DETONEXTROW
1578  59B3 E1           		POP HL
1579  59B4              .CALL2:
1580  59B4 CD 00 00     		CALL 0
1581  59B7 ED 5B E8 52  		LD DE, (BLIT_TMP1)
1582  59BB E5           		PUSH HL
1583  59BC CD E0 59     			CALL .ADD8
1584  59BF E1           		POP HL
1585  59C0 ED 53 E8 52  		LD (BLIT_TMP1), DE
1586  59C4 ED 5B EA 52  		LD DE, (BLIT_TMP2)
1587  59C8 E5           		PUSH HL
1588  59C9 CD E0 59     			CALL .ADD8
1589  59CC E1           		POP HL
1590  59CD ED 53 EA 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1591  59D1              .DONE:
1592  59D1 F1           	POP AF
1593  59D2 3D           	DEC A
1594  59D3 C8           	RET Z
1595  59D4 F5           	PUSH AF
1596  59D5 C3 9D 59     	JP .L1
1597  59D8              .ADDYSHIFT:
1598  59D8 EB           	EX DE, HL
1599  59D9 16 00        	LD D, 0
1600  59DB DD 5E 02     	LD E, (IX+2); y shift
1601  59DE 18 0C        	JR .MOVDEBC
1602  59E0              .ADD8:
1603  59E0 21 08 00     	LD HL, 8
1604  59E3 C3 EC 59     	JP .MOVDEBC
1605  59E6              .DETONEXTROW:
1606  59E6 DD 6E 06     	LD L, (IX+6)
1607  59E9 DD 66 07     	LD H, (IX+7) ; bkg add to value
1608  59EC              .MOVDEBC:
1609  59EC 19           	ADD HL, DE
1610  59ED 54           	LD D, H
1611  59EE 5D           	LD E, L
1612  59EF 01 08 00     	LD BC, 8
1613  59F2 09           	ADD HL, BC
1614  59F3 44           	LD B, H
1615  59F4 4D           	LD C, L
1616  59F5 C9           	RET
1617  59F6              ; *******************************************************************************************************
1618  59F6
1619  59F6              ; *******************************************************************************************************
1620  59F6              ; function rotates mask and character data and applies it to background
1621  59F6              ; input IX=pointer to structure describing input data
1622  59F6              ; +0  DW horizontal shift count 0-7 (low byte used)
1623  59F6              ; +2  DW vertical shift count 0-7 (low byte used)
1624  59F6              ; +4  DW background data start;
1625  59F6              ; +6  DW background add to value to next row of background data
1626  59F6              ; +8  DW mask data start;
1627  59F6              ; +10  DW character data start;
1628  59F6              ; +12 DW character&mask add to value to next row of data
1629  59F6              ; +14 DW columns (low byte used)
1630  59F6              ; +16 DW rows (low byte used)
1631  59F6              SHIFT_MERGE_CHARACTER:
1632  59F6 DD 7E 00     	LD A, (IX) ; shift
1633  59F9 FE 05        	CP 5
1634  59FB 38 25        	JR C, .RIGHT
1635  59FD              	; shifts 5-7, use rotate towards left 1-3
1636  59FD 21 52 59     	LD HL, SHIFT58
1637  5A00 22 A3 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1638  5A03 22 B5 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1639  5A06 D6 05        	SUB 5
1640  5A08 28 0D        	JR Z, .L1
1641  5A0A 87           	ADD A, A
1642  5A0B 87           	ADD A, A
1643  5A0C 67           	LD H, A
1644  5A0D 2E 18        	LD L, #18 ; JR opcode
1645  5A0F 22 59 59     	LD (SHIFT58.M1), HL
1646  5A12 22 6A 59     	LD (SHIFT58.M2), HL
1647  5A15 18 32        	JR .DO
1648  5A17              .L1:
1649  5A17 21 00 00     	LD HL, 0 ; 2xNOP opcode
1650  5A1A 22 59 59     	LD (SHIFT58.M1), HL
1651  5A1D 22 6A 59     	LD (SHIFT58.M2), HL
1652  5A20 18 27        	JR .DO
1653  5A22              .RIGHT:
1654  5A22              	; shifts 0-4, rotate towards right
1655  5A22 21 0D 59     	LD HL, SHIFT04
1656  5A25 22 A3 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1657  5A28 22 B5 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1658  5A2B FE 04        	CP 4
1659  5A2D 28 11        	JR Z, .R1
1660  5A2F D6 04        	SUB 4
1661  5A31 ED 44        	NEG
1662  5A33 87           	ADD A, A
1663  5A34 87           	ADD A, A
1664  5A35 67           	LD H, A
1665  5A36 2E 18        	LD L, #18 ; JR opcode
1666  5A38 22 14 59     	LD (SHIFT04.M1), HL
1667  5A3B 22 29 59     	LD (SHIFT04.M2), HL
1668  5A3E 18 09        	JR .DO
1669  5A40              .R1:
1670  5A40 21 00 00     	LD HL, 0 ; 2xNOP opcode
1671  5A43 22 14 59     	LD (SHIFT04.M1), HL
1672  5A46 22 29 59     	LD (SHIFT04.M2), HL
1673  5A49              .DO:
1674  5A49 DD 46 10     	LD B, (IX+16) ; rows
1675  5A4C DD 6E 08     	LD L, (IX+8)
1676  5A4F DD 66 09     	LD H, (IX+9) ; mask data
1677  5A52 DD 5E 04     	LD E, (IX+4)
1678  5A55 DD 56 05     	LD D, (IX+5) ; background data
1679  5A58 D9           	EXX
1680  5A59 DD 6E 0A     	LD L, (IX+10)
1681  5A5C DD 66 0B     	LD H, (IX+11) ; character data
1682  5A5F D9           	EXX
1683  5A60              .LOOP:
1684  5A60 C5           	PUSH BC
1685  5A61 E5           		PUSH HL
1686  5A62 D5           			PUSH DE
1687  5A63 D9           				EXX
1688  5A64 E5           				PUSH HL
1689  5A65 D9           					EXX
1690  5A66 DD 7E 0E     					LD A, (IX+14) ; columns
1691  5A69              .CALL:
1692  5A69 CD 8F 59     					CALL SHIFT_ROW
1693  5A6C E1           				POP HL
1694  5A6D DD 5E 0C     				LD E, (IX+12)
1695  5A70 DD 56 0D     				LD D, (IX+13) ; char data to next row
1696  5A73 19           				ADD HL, DE
1697  5A74 D9           				EXX
1698  5A75 E1           			POP HL
1699  5A76 DD 5E 06     			LD E, (IX+6)
1700  5A79 DD 56 07     			LD D, (IX+7) ; background to next row
1701  5A7C 19           			ADD HL, DE
1702  5A7D EB           			EX DE, HL
1703  5A7E E1           		POP HL
1704  5A7F DD 4E 0C     		LD C, (IX+12)
1705  5A82 DD 46 0D     		LD B, (IX+13) ; char data to next row
1706  5A85 09           		ADD HL, BC
1707  5A86 C1           	POP BC
1708  5A87 10 D7        	DJNZ .LOOP
1709  5A89 C9           	RET
1710  5A8A              ; *******************************************************************************************************
1711  5A8A
1712  5A8A               IFNDEF CMDS_WITH_PARAMETERS
1713  5A8A ~            ; *******************************************************************************************************
1714  5A8A ~            ; function to handle CALL BLIT basic extension
1715  5A8A ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1716  5A8A ~            ; fuses with background data and applies vertical shift too
1717  5A8A ~            ; BLIT ( INT request_data_ptr )
1718  5A8A ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1719  5A8A ~            ; will put ram in page 0 also, page 1 is already there
1720  5A8A ~            BLIT:
1721  5A8A ~            	; opening (
1722  5A8A ~            	CALL CHKCHAR
1723  5A8A ~            	DB '('
1724  5A8A ~            	; get pointer to request struct
1725  5A8A ~            	LD IX, FRMQNT
1726  5A8A ~            	CALL CALBAS
1727  5A8A ~            	PUSH DE
1728  5A8A ~            	; ending )
1729  5A8A ~            	CALL CHKCHAR
1730  5A8A ~            	DB ')'
1731  5A8A ~
1732  5A8A ~            	POP IX ; pointer to request struct
1733  5A8A ~
1734  5A8A ~            	PUSH HL ; save position in BASIC buffer
1735  5A8A ~
1736  5A8A ~            	LD IY, .RET
1737  5A8A ~            	JP ENABLE_PAGE0
1738  5A8A ~            .RET:
1739  5A8A ~            	EI
1740  5A8A ~            	CALL SHIFT_MERGE_CHARACTER
1741  5A8A ~
1742  5A8A ~                POP DE
1743  5A8A ~                POP BC
1744  5A8A ~                CALL RESTORE_PAGE_INFO
1745  5A8A ~
1746  5A8A ~            	POP HL
1747  5A8A ~            	RET
1748  5A8A ~            ; *******************************************************************************************************
1749  5A8A               ENDIF
1750  5A8A
1751  5A8A               IFDEF CMDS_WITH_PARAMETERS
1752  5A8A              ; *******************************************************************************************************
1753  5A8A              ; function to handle CALL BLIT basic extension
1754  5A8A              ; rotates 1-bit character drawing horizontally with mask and character data and
1755  5A8A              ; fuses with background data and applies vertical shift too
1756  5A8A              ; in form without pointers
1757  5A8A              ; BLIT ( INT x,
1758  5A8A              ;		 INT y,
1759  5A8A              ;		 INT char_data_pointer,
1760  5A8A              ;		 INT mask_data_pointer,
1761  5A8A              ;		 INT width (in characters),
1762  5A8A              ;		 INT height (in characters),
1763  5A8A              ;		 INT background_pointer (top left),
1764  5A8A              ;		 INT background_width (in characters),
1765  5A8A              ;		 INT background_height (in characters))
1766  5A8A              ; will put ram in page 0 also, page 1 is already there
1767  5A8A              BLIT:
1768  5A8A              	; opening (
1769  5A8A CD 95 55     	CALL CHKCHAR
1770  5A8D 28           	DB '('
1771  5A8E              	; get x coordinate
1772  5A8E DD 21 2F 54  	LD IX, FRMQNT
1773  5A92 CD 59 01     	CALL CALBAS
1774  5A95 7B           	LD A, E
1775  5A96 E6 07        	AND 7
1776  5A98 32 EC 52     	LD (BLIT_STRUCT+0), A
1777  5A9B CD 78 5B     	CALL .DAdiv8
1778  5A9E 32 E8 52     	LD (BLIT_TMP+0),A
1779  5AA1              	; comma
1780  5AA1 CD 95 55     	CALL CHKCHAR
1781  5AA4 2C           	DB ','
1782  5AA5              	; get y coordinate
1783  5AA5 DD 21 2F 54  	LD IX, FRMQNT
1784  5AA9 CD 59 01     	CALL CALBAS
1785  5AAC 7B           	LD A, E
1786  5AAD E6 07        	AND 7
1787  5AAF 32 EE 52     	LD (BLIT_STRUCT+2), A
1788  5AB2 CD 78 5B     	CALL .DAdiv8
1789  5AB5 32 E9 52     	LD (BLIT_TMP+1),A
1790  5AB8              	; comma
1791  5AB8 CD 95 55     	CALL CHKCHAR
1792  5ABB 2C           	DB ','
1793  5ABC              	; get char data pointer
1794  5ABC DD 21 2F 54  	LD IX, FRMQNT
1795  5AC0 CD 59 01     	CALL CALBAS
1796  5AC3 ED 53 F6 52  	LD (BLIT_STRUCT+10), DE
1797  5AC7              	; comma
1798  5AC7 CD 95 55     	CALL CHKCHAR
1799  5ACA 2C           	DB ','
1800  5ACB              	; get mask data pointer
1801  5ACB DD 21 2F 54  	LD IX, FRMQNT
1802  5ACF CD 59 01     	CALL CALBAS
1803  5AD2 ED 53 F4 52  	LD (BLIT_STRUCT+8), DE
1804  5AD6              	; comma
1805  5AD6 CD 95 55     	CALL CHKCHAR
1806  5AD9 2C           	DB ','
1807  5ADA              	; get width
1808  5ADA DD 21 2F 54  	LD IX, FRMQNT
1809  5ADE CD 59 01     	CALL CALBAS
1810  5AE1 7B           	LD A, E
1811  5AE2 32 FA 52     	LD (BLIT_STRUCT+14), A
1812  5AE5              	; comma
1813  5AE5 CD 95 55     	CALL CHKCHAR
1814  5AE8 2C           	DB ','
1815  5AE9              	; get height
1816  5AE9 DD 21 2F 54  	LD IX, FRMQNT
1817  5AED CD 59 01     	CALL CALBAS
1818  5AF0 7B           	LD A, E
1819  5AF1 32 FC 52     	LD (BLIT_STRUCT+16), A
1820  5AF4              	; comma
1821  5AF4 CD 95 55     	CALL CHKCHAR
1822  5AF7 2C           	DB ','
1823  5AF8              	; get background pointer
1824  5AF8 DD 21 2F 54  	LD IX, FRMQNT
1825  5AFC CD 59 01     	CALL CALBAS
1826  5AFF ED 53 F0 52  	LD (BLIT_STRUCT+4), DE
1827  5B03              	; comma
1828  5B03 CD 95 55     	CALL CHKCHAR
1829  5B06 2C           	DB ','
1830  5B07              	; get background width
1831  5B07 DD 21 2F 54  	LD IX, FRMQNT
1832  5B0B CD 59 01     	CALL CALBAS
1833  5B0E 7B           	LD A, E
1834  5B0F 32 EA 52     	LD (BLIT_TMP+2), A
1835  5B12              	; comma
1836  5B12 CD 95 55     	CALL CHKCHAR
1837  5B15 2C           	DB ','
1838  5B16              	; get background height
1839  5B16 DD 21 2F 54  	LD IX, FRMQNT
1840  5B1A CD 59 01     	CALL CALBAS
1841  5B1D 7B           	LD A, E
1842  5B1E 32 EB 52     	LD (BLIT_TMP+3), A
1843  5B21              	; ending )
1844  5B21 CD 95 55     	CALL CHKCHAR
1845  5B24 29           	DB ')'
1846  5B25
1847  5B25 E5           	PUSH HL ; save position in BASIC buffer
1848  5B26
1849  5B26              	; calculate char&mask add to value
1850  5B26 26 00        	LD H, 0
1851  5B28 3A FA 52     	LD A, (BLIT_STRUCT+14)
1852  5B2B 6F           	LD L, A
1853  5B2C CD 84 54     	CALL HLx8
1854  5B2F 22 F8 52     	LD (BLIT_STRUCT+12), HL
1855  5B32              	; calculate background add to value
1856  5B32 26 00        	LD H, 0
1857  5B34 3A EA 52     	LD A, (BLIT_TMP+2)
1858  5B37 6F           	LD L, A
1859  5B38 CD 84 54     	CALL HLx8
1860  5B3B 22 F2 52     	LD (BLIT_STRUCT+6), HL
1861  5B3E              	; calculate pointer to background location
1862  5B3E 21 00 00     	LD HL, 0
1863  5B41 3A E9 52     	LD A,(BLIT_TMP+1)
1864  5B44 B7           	OR A
1865  5B45 28 08        	JR Z, .L1
1866  5B47 47           	LD B,A
1867  5B48 ED 5B F2 52  	LD DE,(BLIT_STRUCT+6)
1868  5B4C              .L0:
1869  5B4C 19           	ADD HL, DE
1870  5B4D 10 FD        	DJNZ .L0
1871  5B4F              .L1:
1872  5B4F EB           	EX DE,HL
1873  5B50 26 00        	LD H,0
1874  5B52 3A E8 52     	LD A,(BLIT_TMP+0)
1875  5B55 6F           	LD L,A
1876  5B56 CD 84 54     	CALL HLx8
1877  5B59 19           	ADD HL,DE
1878  5B5A ED 5B F0 52  	LD DE,(BLIT_STRUCT+4)
1879  5B5E 19           	ADD HL,DE
1880  5B5F 22 F0 52     	LD (BLIT_STRUCT+4),HL
1881  5B62
1882  5B62 FD 21 69 5B  	LD IY, .RET
1883  5B66 C3 48 55     	JP ENABLE_PAGE0
1884  5B69              .RET:
1885  5B69 FB           	EI
1886  5B6A DD 21 EC 52  	LD IX, BLIT_STRUCT
1887  5B6E CD F6 59     	CALL SHIFT_MERGE_CHARACTER
1888  5B71
1889  5B71 D1               POP DE
1890  5B72 C1               POP BC
1891  5B73 CD BF 54         CALL RESTORE_PAGE_INFO
1892  5B76
1893  5B76 E1           	POP HL
1894  5B77 C9           	RET
1895  5B78              .DAdiv8:
1896  5B78 7B           	LD A,E
1897  5B79 CB 2A        	SRA D
1898  5B7B CB 1F            RR  A
1899  5B7D CB 2A            SRA D
1900  5B7F CB 1F            RR  A
1901  5B81 CB 2A            SRA D
1902  5B83 CB 1F            RR  A
1903  5B85 C9           	RET
1904  5B86              ; *******************************************************************************************************
1905  5B86               ENDIF
1906  5B86               ENDIF
1907  5B86
1908  5B86               IF (TILE_CMDS == 1)
1909  5B86              ; *******************************************************************************************************
1910  5B86              ; generic function to implement tiling
1911  5B86              ; should be modified to call appropriate function for memory or vram
1912  5B86              ; input IX=pointer to following structure
1913  5B86              ; +00 tile_data_ptr
1914  5B86              ; +02 tile_rows
1915  5B86              ; +04 tile_columns
1916  5B86              ; +06 destination_address
1917  5B86              ; +08 dest_to_next_row_add_to_value
1918  5B86              ; +10 num_horizontal_tiles
1919  5B86              ; +12 num_vertical_tiles
1920  5B86              ; modifies AF, BC, DE, HL
1921  5B86              TILE:
1922  5B86 DD 6E 06     	LD L, (IX+6)
1923  5B89 DD 66 07     	LD H, (IX+7) ; destination address
1924  5B8C 22 E8 52     	LD (TILETMP1), HL
1925  5B8F DD 46 0C     	LD B, (IX+12) ; vertical tile number
1926  5B92              .L1:
1927  5B92 C5           	PUSH BC
1928  5B93 DD 6E 00     		LD L, (IX+0)
1929  5B96 DD 66 01     		LD H, (IX+1) ; tile address
1930  5B99 22 EA 52     		LD (TILETMP2), HL
1931  5B9C DD 46 02     		LD B, (IX+2) ; tile rows
1932  5B9F              .L2:
1933  5B9F C5           		PUSH BC
1934  5BA0              .CALL1:
1935  5BA0 CD 00 00     			CALL 0
1936  5BA3 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1937  5BA6              .L3:
1938  5BA6 C5           			PUSH BC
1939  5BA7 2A EA 52     				LD HL, (TILETMP2)
1940  5BAA DD 46 04     				LD B, (IX+4) ; tile columns
1941  5BAD              .L4:
1942  5BAD C5           				PUSH BC
1943  5BAE              .CALL2:
1944  5BAE CD 00 00     					CALL 0
1945  5BB1 C1           				POP BC
1946  5BB2 10 F9        				DJNZ .L4
1947  5BB4 C1           			POP BC
1948  5BB5 10 EF        			DJNZ .L3
1949  5BB7 22 EA 52     			LD (TILETMP2), HL
1950  5BBA 2A E8 52     			LD HL, (TILETMP1)
1951  5BBD DD 5E 08     			LD E, (IX+8)
1952  5BC0 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1953  5BC3 19           			ADD HL, DE
1954  5BC4 22 E8 52     			LD (TILETMP1), HL
1955  5BC7 C1           		POP BC
1956  5BC8 10 D5        		DJNZ .L2
1957  5BCA C1           	POP BC
1958  5BCB 10 C5        	DJNZ .L1
1959  5BCD C9           	RET
1960  5BCE              ; *******************************************************************************************************
1961  5BCE
1962  5BCE               IFNDEF CMDS_WITH_PARAMETERS
1963  5BCE ~            ; *******************************************************************************************************
1964  5BCE ~            ; function to handle CALL TILERAM basic extension
1965  5BCE ~            ; fills memory with tiles
1966  5BCE ~            ; TILERAM ( INT request_data_ptr )
1967  5BCE ~            ; request_data_ptr described in TILE
1968  5BCE ~            ; will put ram in page 0 also, page 1 is already there
1969  5BCE ~            TILERAM:
1970  5BCE ~            	; opening (
1971  5BCE ~            	CALL CHKCHAR
1972  5BCE ~            	DB '('
1973  5BCE ~            	; get pointer to request struct
1974  5BCE ~            	LD IX, FRMQNT
1975  5BCE ~            	CALL CALBAS
1976  5BCE ~            	PUSH DE
1977  5BCE ~            	; ending )
1978  5BCE ~            	CALL CHKCHAR
1979  5BCE ~            	DB ')'
1980  5BCE ~
1981  5BCE ~            	POP IX ; pointer to request struct
1982  5BCE ~
1983  5BCE ~            	PUSH HL ; save position in BASIC buffer
1984  5BCE ~
1985  5BCE ~            	LD IY, .RET
1986  5BCE ~            	JP ENABLE_PAGE0
1987  5BCE ~            .RET:
1988  5BCE ~            	EI
1989  5BCE ~            	; set RAM functions to call
1990  5BCE ~            	LD HL, .TILECOPY
1991  5BCE ~            	LD (TILE.CALL2+1), HL
1992  5BCE ~            	LD HL, .SETDESTROW
1993  5BCE ~            	LD (TILE.CALL1+1), HL
1994  5BCE ~            	CALL TILE
1995  5BCE ~
1996  5BCE ~                POP DE
1997  5BCE ~                POP BC
1998  5BCE ~                CALL RESTORE_PAGE_INFO
1999  5BCE ~
2000  5BCE ~            	POP HL
2001  5BCE ~            	RET
2002  5BCE ~            .TILECOPY:
2003  5BCE ~            	.8 LDI
2004  5BCE ~            	RET
2005  5BCE ~            .SETDESTROW:
2006  5BCE ~            	LD DE, (TILETMP1)
2007  5BCE ~            	RET
2008  5BCE ~            ; *******************************************************************************************************
2009  5BCE               ENDIF
2010  5BCE
2011  5BCE               IFDEF CMDS_WITH_PARAMETERS
2012  5BCE              ; *******************************************************************************************************
2013  5BCE              ; function to handle CALL TILERAM basic extension
2014  5BCE              ; fills memory with tiles
2015  5BCE              ; TILERAM ( INT tile_data_pointer,
2016  5BCE              ;			INT tile_columns,
2017  5BCE              ;			INT tile_rows,
2018  5BCE              ;			INT destination_pointer,
2019  5BCE              ;			INT destination_columns,
2020  5BCE              ;			INT destination_rows,
2021  5BCE              ;			INT destination_begin_column,
2022  5BCE              ;			INT destination_begin_row,
2023  5BCE              ;			INT number_of_tiles_horizontally,
2024  5BCE              ;			INT	number_of_tiles_vertically )
2025  5BCE              ; will put ram in page 0 also, page 1 is already there
2026  5BCE              TILERAM:
2027  5BCE              	; opening (
2028  5BCE CD 95 55     	CALL CHKCHAR
2029  5BD1 28           	DB '('
2030  5BD2              	; get tile data pointer coordinate
2031  5BD2 DD 21 2F 54  	LD IX, FRMQNT
2032  5BD6 CD 59 01     	CALL CALBAS
2033  5BD9 ED 53 EC 52  	LD (BLIT_STRUCT+0), DE
2034  5BDD              	; comma
2035  5BDD CD 95 55     	CALL CHKCHAR
2036  5BE0 2C           	DB ','
2037  5BE1              	; get tile columns
2038  5BE1 DD 21 2F 54  	LD IX, FRMQNT
2039  5BE5 CD 59 01     	CALL CALBAS
2040  5BE8 ED 53 F0 52  	LD (BLIT_STRUCT+4), DE
2041  5BEC              	; comma
2042  5BEC CD 95 55     	CALL CHKCHAR
2043  5BEF 2C           	DB ','
2044  5BF0              	; get tile columns
2045  5BF0 DD 21 2F 54  	LD IX, FRMQNT
2046  5BF4 CD 59 01     	CALL CALBAS
2047  5BF7 ED 53 EE 52  	LD (BLIT_STRUCT+2), DE
2048  5BFB              	; comma
2049  5BFB CD 95 55     	CALL CHKCHAR
2050  5BFE 2C           	DB ','
2051  5BFF              	; get destintion pointer
2052  5BFF DD 21 2F 54  	LD IX, FRMQNT
2053  5C03 CD 59 01     	CALL CALBAS
2054  5C06 ED 53 F2 52  	LD (BLIT_STRUCT+6), DE
2055  5C0A              	; comma
2056  5C0A CD 95 55     	CALL CHKCHAR
2057  5C0D 2C           	DB ','
2058  5C0E              	; get destination columns
2059  5C0E DD 21 2F 54  	LD IX, FRMQNT
2060  5C12 CD 59 01     	CALL CALBAS
2061  5C15 7B           	LD A, E
2062  5C16 32 E8 52     	LD (BLIT_TMP+0), A
2063  5C19              	; comma
2064  5C19 CD 95 55     	CALL CHKCHAR
2065  5C1C 2C           	DB ','
2066  5C1D              	; get destination rows
2067  5C1D DD 21 2F 54  	LD IX, FRMQNT
2068  5C21 CD 59 01     	CALL CALBAS
2069  5C24 7B           	LD A, E
2070  5C25 32 E9 52     	LD (BLIT_TMP+1), A
2071  5C28              	; comma
2072  5C28 CD 95 55     	CALL CHKCHAR
2073  5C2B 2C           	DB ','
2074  5C2C              	; get destination begin column
2075  5C2C DD 21 2F 54  	LD IX, FRMQNT
2076  5C30 CD 59 01     	CALL CALBAS
2077  5C33 7B           	LD A, E
2078  5C34 32 EA 52     	LD (BLIT_TMP+2), A
2079  5C37              	; comma
2080  5C37 CD 95 55     	CALL CHKCHAR
2081  5C3A 2C           	DB ','
2082  5C3B              	; get destination begin row
2083  5C3B DD 21 2F 54  	LD IX, FRMQNT
2084  5C3F CD 59 01     	CALL CALBAS
2085  5C42 7B           	LD A, E
2086  5C43 32 EB 52     	LD (BLIT_TMP+3), A
2087  5C46              	; comma
2088  5C46 CD 95 55     	CALL CHKCHAR
2089  5C49 2C           	DB ','
2090  5C4A              	; get number of tiles horizontally
2091  5C4A DD 21 2F 54  	LD IX, FRMQNT
2092  5C4E CD 59 01     	CALL CALBAS
2093  5C51 ED 53 F6 52  	LD (BLIT_STRUCT+10), DE
2094  5C55              	; comma
2095  5C55 CD 95 55     	CALL CHKCHAR
2096  5C58 2C           	DB ','
2097  5C59              	; get number of tiles vertically
2098  5C59 DD 21 2F 54  	LD IX, FRMQNT
2099  5C5D CD 59 01     	CALL CALBAS
2100  5C60 ED 53 F8 52  	LD (BLIT_STRUCT+12), DE
2101  5C64              	; ending )
2102  5C64 CD 95 55     	CALL CHKCHAR
2103  5C67 29           	DB ')'
2104  5C68
2105  5C68 E5           	PUSH HL ; save position in BASIC buffer
2106  5C69
2107  5C69              	; calculate destination add to value
2108  5C69 26 00        	LD H, 0
2109  5C6B 3A E8 52     	LD A, (BLIT_TMP+0)
2110  5C6E 6F           	LD L, A
2111  5C6F CD 84 54     	CALL HLx8
2112  5C72 22 F4 52     	LD (BLIT_STRUCT+8), HL
2113  5C75              	; calculate pointer to background location
2114  5C75 21 00 00     	LD HL, 0
2115  5C78 3A EB 52     	LD A,(BLIT_TMP+3)
2116  5C7B B7           	OR A
2117  5C7C 28 08        	JR Z, .L1
2118  5C7E 47           	LD B,A
2119  5C7F ED 5B F4 52  	LD DE,(BLIT_STRUCT+8)
2120  5C83              .L0:
2121  5C83 19           	ADD HL, DE
2122  5C84 10 FD        	DJNZ .L0
2123  5C86              .L1:
2124  5C86 EB           	EX DE,HL
2125  5C87 26 00        	LD H,0
2126  5C89 3A EA 52     	LD A,(BLIT_TMP+2)
2127  5C8C 6F           	LD L,A
2128  5C8D CD 84 54     	CALL HLx8
2129  5C90 19           	ADD HL,DE
2130  5C91 ED 5B F2 52  	LD DE,(BLIT_STRUCT+6)
2131  5C95 19           	ADD HL,DE
2132  5C96 22 F2 52     	LD (BLIT_STRUCT+6),HL
2133  5C99
2134  5C99 FD 21 A0 5C  	LD IY, .RET
2135  5C9D C3 48 55     	JP ENABLE_PAGE0
2136  5CA0              .RET:
2137  5CA0 FB           	EI
2138  5CA1              	; set RAM functions to call
2139  5CA1 21 BB 5C     	LD HL, .TILECOPY
2140  5CA4 22 AF 5B     	LD (TILE.CALL2+1), HL
2141  5CA7 21 CC 5C     	LD HL, .SETDESTROW
2142  5CAA 22 A1 5B     	LD (TILE.CALL1+1), HL
2143  5CAD DD 21 EC 52  	LD IX,BLIT_STRUCT
2144  5CB1 CD 86 5B     	CALL TILE
2145  5CB4
2146  5CB4 D1               POP DE
2147  5CB5 C1               POP BC
2148  5CB6 CD BF 54         CALL RESTORE_PAGE_INFO
2149  5CB9
2150  5CB9 E1           	POP HL
2151  5CBA C9           	RET
2152  5CBB              .TILECOPY:
2153  5CBB ED A0       > LDI
2153  5CBD ED A0       > LDI
2153  5CBF ED A0       > LDI
2153  5CC1 ED A0       > LDI
2153  5CC3 ED A0       > LDI
2153  5CC5 ED A0       > LDI
2153  5CC7 ED A0       > LDI
2153  5CC9 ED A0       > LDI
2154  5CCB C9           	RET
2155  5CCC              .SETDESTROW:
2156  5CCC ED 5B E8 52  	LD DE, (TILETMP1)
2157  5CD0 C9           	RET
2158  5CD1              ; *******************************************************************************************************
2159  5CD1               ENDIF
2160  5CD1
2161  5CD1               IFDEF CMDS_WITH_PARAMETERS
2162  5CD1              ; *******************************************************************************************************
2163  5CD1              ; function to handle CALL TILEVRM basic extension
2164  5CD1              ; fills vram with tiles
2165  5CD1              ; TILEVRM ( INT tile_data_pointer,
2166  5CD1              ;			INT tile_columns,
2167  5CD1              ;			INT tile_rows,
2168  5CD1              ;			INT destination_begin_column,
2169  5CD1              ;			INT destination_begin_row,
2170  5CD1              ;			INT number_of_tiles_horizontally,
2171  5CD1              ;			INT	number_of_tiles_vertically )
2172  5CD1              ; will put ram in page 0 also, page 1 is already there
2173  5CD1              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2174  5CD1              TILEVRM:
2175  5CD1              	; opening (
2176  5CD1 CD 95 55     	CALL CHKCHAR
2177  5CD4 28           	DB '('
2178  5CD5              	; get tile data pointer coordinate
2179  5CD5 DD 21 2F 54  	LD IX, FRMQNT
2180  5CD9 CD 59 01     	CALL CALBAS
2181  5CDC ED 53 EC 52  	LD (BLIT_STRUCT+0), DE
2182  5CE0              	; comma
2183  5CE0 CD 95 55     	CALL CHKCHAR
2184  5CE3 2C           	DB ','
2185  5CE4              	; get tile columns
2186  5CE4 DD 21 2F 54  	LD IX, FRMQNT
2187  5CE8 CD 59 01     	CALL CALBAS
2188  5CEB ED 53 F0 52  	LD (BLIT_STRUCT+4), DE
2189  5CEF              	; comma
2190  5CEF CD 95 55     	CALL CHKCHAR
2191  5CF2 2C           	DB ','
2192  5CF3              	; get tile columns
2193  5CF3 DD 21 2F 54  	LD IX, FRMQNT
2194  5CF7 CD 59 01     	CALL CALBAS
2195  5CFA ED 53 EE 52  	LD (BLIT_STRUCT+2), DE
2196  5CFE              	; comma
2197  5CFE CD 95 55     	CALL CHKCHAR
2198  5D01 2C           	DB ','
2199  5D02              	; get destination begin column
2200  5D02 DD 21 2F 54  	LD IX, FRMQNT
2201  5D06 CD 59 01     	CALL CALBAS
2202  5D09 7B           	LD A, E
2203  5D0A 32 EA 52     	LD (BLIT_TMP+2), A
2204  5D0D              	; comma
2205  5D0D CD 95 55     	CALL CHKCHAR
2206  5D10 2C           	DB ','
2207  5D11              	; get destination begin row
2208  5D11 DD 21 2F 54  	LD IX, FRMQNT
2209  5D15 CD 59 01     	CALL CALBAS
2210  5D18 7B           	LD A, E
2211  5D19 32 EB 52     	LD (BLIT_TMP+3), A
2212  5D1C              	; comma
2213  5D1C CD 95 55     	CALL CHKCHAR
2214  5D1F 2C           	DB ','
2215  5D20              	; get number of tiles horizontally
2216  5D20 DD 21 2F 54  	LD IX, FRMQNT
2217  5D24 CD 59 01     	CALL CALBAS
2218  5D27 ED 53 F6 52  	LD (BLIT_STRUCT+10), DE
2219  5D2B              	; comma
2220  5D2B CD 95 55     	CALL CHKCHAR
2221  5D2E 2C           	DB ','
2222  5D2F              	; get number of tiles vertically
2223  5D2F DD 21 2F 54  	LD IX, FRMQNT
2224  5D33 CD 59 01     	CALL CALBAS
2225  5D36 ED 53 F8 52  	LD (BLIT_STRUCT+12), DE
2226  5D3A              	; ending )
2227  5D3A CD 95 55     	CALL CHKCHAR
2228  5D3D 29           	DB ')'
2229  5D3E
2230  5D3E E5           	PUSH HL ; save position in BASIC buffer
2231  5D3F
2232  5D3F              	; calculate destination add to value
2233  5D3F 21 00 01     	LD HL, 256
2234  5D42 22 F4 52     	LD (BLIT_STRUCT+8), HL
2235  5D45              	; calculate pointer to background location
2236  5D45 3A EB 52     	LD A,(BLIT_TMP+3)
2237  5D48 67           	LD H,A
2238  5D49 2E 00        	LD L,0
2239  5D4B EB           	EX DE,HL
2240  5D4C 26 00        	LD H,0
2241  5D4E 3A EA 52     	LD A,(BLIT_TMP+2)
2242  5D51 6F           	LD L,A
2243  5D52 CD 84 54     	CALL HLx8
2244  5D55 19           	ADD HL,DE
2245  5D56 ED 5B CB F3  	LD DE,(GRPCGP)
2246  5D5A 19           	ADD HL,DE
2247  5D5B 22 F2 52     	LD (BLIT_STRUCT+6),HL
2248  5D5E
2249  5D5E FD 21 65 5D  	LD IY, .RET
2250  5D62 C3 48 55     	JP ENABLE_PAGE0
2251  5D65              .RET:
2252  5D65 FB           	EI
2253  5D66              	; set RAM functions to call
2254  5D66 21 80 5D     	LD HL, .TILECOPY
2255  5D69 22 AF 5B     	LD (TILE.CALL2+1), HL
2256  5D6C 21 86 5D     	LD HL, .SETDESTROW
2257  5D6F 22 A1 5B     	LD (TILE.CALL1+1), HL
2258  5D72 DD 21 EC 52  	LD IX,BLIT_STRUCT
2259  5D76 CD 86 5B     	CALL TILE
2260  5D79
2261  5D79 D1               POP DE
2262  5D7A C1               POP BC
2263  5D7B CD BF 54         CALL RESTORE_PAGE_INFO
2264  5D7E
2265  5D7E E1           	POP HL
2266  5D7F C9           	RET
2267  5D80              .TILECOPY:
2268  5D80 01 98 08     	LD BC, #0898
2269  5D83 C3 7C 54     	JP BBYTECOPY
2270  5D86              .SETDESTROW:
2271  5D86 2A E8 52     	LD HL, (TILETMP1)
2272  5D89 F3           	DI
2273  5D8A CD 71 54     	CALL SETWRT_LOCAL
2274  5D8D FB           	EI
2275  5D8E C9           	RET
2276  5D8F              ; *******************************************************************************************************
2277  5D8F               ENDIF
2278  5D8F
2279  5D8F               IFNDEF CMDS_WITH_PARAMETERS
2280  5D8F ~            ; *******************************************************************************************************
2281  5D8F ~            ; function to handle CALL TILEVRM basic extension
2282  5D8F ~            ; fills vram with tiles
2283  5D8F ~            ; TILEVRM ( INT request_data_ptr )
2284  5D8F ~            ; request_data_ptr described in TILE
2285  5D8F ~            ; will put ram in page 0 also, page 1 is already there
2286  5D8F ~            TILEVRM:
2287  5D8F ~            	; opening (
2288  5D8F ~            	CALL CHKCHAR
2289  5D8F ~            	DB '('
2290  5D8F ~            	; get pointer to request struct
2291  5D8F ~            	LD IX, FRMQNT
2292  5D8F ~            	CALL CALBAS
2293  5D8F ~            	PUSH DE
2294  5D8F ~            	; ending )
2295  5D8F ~            	CALL CHKCHAR
2296  5D8F ~            	DB ')'
2297  5D8F ~
2298  5D8F ~            	POP IX ; pointer to request struct
2299  5D8F ~
2300  5D8F ~            	PUSH HL ; save position in BASIC buffer
2301  5D8F ~
2302  5D8F ~            	LD IY, .RET
2303  5D8F ~            	JP ENABLE_PAGE0
2304  5D8F ~            .RET:
2305  5D8F ~            	EI
2306  5D8F ~            	; set RAM functions to call
2307  5D8F ~            	LD HL, .TILECOPY
2308  5D8F ~            	LD (TILE.CALL2+1), HL
2309  5D8F ~            	LD HL, .SETDESTROW
2310  5D8F ~            	LD (TILE.CALL1+1), HL
2311  5D8F ~            	CALL TILE
2312  5D8F ~
2313  5D8F ~                POP DE
2314  5D8F ~                POP BC
2315  5D8F ~                CALL RESTORE_PAGE_INFO
2316  5D8F ~
2317  5D8F ~            	POP HL
2318  5D8F ~            	RET
2319  5D8F ~            .TILECOPY:
2320  5D8F ~            	LD BC, #0898
2321  5D8F ~            	JP BBYTECOPY
2322  5D8F ~            .SETDESTROW:
2323  5D8F ~            	LD HL, (TILETMP1)
2324  5D8F ~            	DI
2325  5D8F ~            	CALL SETWRT_LOCAL
2326  5D8F ~            	EI
2327  5D8F ~            	RET
2328  5D8F ~            ; *******************************************************************************************************
2329  5D8F               ENDIF
2330  5D8F               ENDIF
2331  5D8F
2332  5D8F               IF (BOX_CMDS == 1)
2333  5D8F              ; *******************************************************************************************************
2334  5D8F              ; generic function to implement rectangle data copy
2335  5D8F              ; should be modified to call appropriate function for memory or vram
2336  5D8F              ; input IX=pointer to following structure
2337  5D8F              ; +00 source data pointer
2338  5D8F              ; +02 num bytes in a row
2339  5D8F              ; +04 number of rows
2340  5D8F              ; +06 source add-to value till next row
2341  5D8F              ; +08 destination address
2342  5D8F              ; +10 destination add-to value till next row
2343  5D8F              ; modifies AF, BC, DE, HL
2344  5D8F              RECTANGLE_COPY:
2345  5D8F DD 6E 00     	LD L, (IX+0)
2346  5D92 DD 66 01     	LD H, (IX+1) ; source address
2347  5D95 DD 5E 08     	LD E, (IX+8)
2348  5D98 DD 56 09     	LD D, (IX+9) ; destination
2349  5D9B DD 46 04     	LD B, (IX+4) ; row number
2350  5D9E              .L1:
2351  5D9E C5           	PUSH BC
2352  5D9F E5           		PUSH HL
2353  5DA0 D5           			PUSH DE
2354  5DA1 DD 4E 02     				LD C, (IX+2)
2355  5DA4 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2356  5DA7              .CALL1:
2357  5DA7 CD 00 00     				CALL 0 ; set destination address from DE
2358  5DAA              .CALL2:
2359  5DAA CD 00 00     				CALL 0 ; copy data fn
2360  5DAD E1           			POP HL
2361  5DAE DD 4E 0A     			LD C, (IX+10)
2362  5DB1 DD 46 0B     			LD B, (IX+11) ; destination add-to
2363  5DB4 09           			ADD HL, BC
2364  5DB5 EB           			EX DE, HL
2365  5DB6 E1           		POP HL
2366  5DB7 DD 4E 06     		LD C, (IX+6)
2367  5DBA DD 46 07     		LD B, (IX+7) ; src add-to
2368  5DBD 09           		ADD HL, BC
2369  5DBE C1           	POP BC
2370  5DBF 10 DD        	DJNZ .L1
2371  5DC1 C9           	RET
2372  5DC2              ; *******************************************************************************************************
2373  5DC2
2374  5DC2              ; *******************************************************************************************************
2375  5DC2              ; function to handle CALL BOXMEMCPY basic extension
2376  5DC2              ; copies data with window like boundaries to ram
2377  5DC2              ; BOXMEMCPY ( INT request_data_ptr )
2378  5DC2              ; request_data_ptr described in RECTANGLE_COPY
2379  5DC2              ; will put ram in page 0 also, page 1 is already there
2380  5DC2              BOXMEMCPY:
2381  5DC2              	; opening (
2382  5DC2 CD 95 55     	CALL CHKCHAR
2383  5DC5 28           	DB '('
2384  5DC6              	; get pointer to request struct
2385  5DC6 DD 21 2F 54  	LD IX, FRMQNT
2386  5DCA CD 59 01     	CALL CALBAS
2387  5DCD D5           	PUSH DE
2388  5DCE              	; ending )
2389  5DCE CD 95 55     	CALL CHKCHAR
2390  5DD1 29           	DB ')'
2391  5DD2
2392  5DD2 DD E1        	POP IX ; pointer to request struct
2393  5DD4
2394  5DD4 E5           	PUSH HL ; save position in BASIC buffer
2395  5DD5
2396  5DD5 FD 21 DC 5D  	LD IY, .RET
2397  5DD9 C3 48 55     	JP ENABLE_PAGE0
2398  5DDC              .RET:
2399  5DDC FB           	EI
2400  5DDD              	; set RAM functions to call
2401  5DDD 21 00 00     	LD HL, 0
2402  5DE0 22 A7 5D     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2403  5DE3 22 A9 5D     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2404  5DE6 21 ED B0     	LD HL, #B0ED ; LDIR
2405  5DE9 22 AB 5D     	LD (RECTANGLE_COPY.CALL1+4), HL
2406  5DEC CD 8F 5D     	CALL RECTANGLE_COPY
2407  5DEF
2408  5DEF D1               POP DE
2409  5DF0 C1               POP BC
2410  5DF1 CD BF 54         CALL RESTORE_PAGE_INFO
2411  5DF4
2412  5DF4 E1           	POP HL
2413  5DF5 C9           	RET
2414  5DF6              ; *******************************************************************************************************
2415  5DF6
2416  5DF6              ; *******************************************************************************************************
2417  5DF6              ; function to handle CALL BOXMEMVRM basic extension
2418  5DF6              ; copies data with window like boundaries to ram
2419  5DF6              ; BOXMEMVRM ( INT request_data_ptr )
2420  5DF6              ; request_data_ptr described in RECTANGLE_COPY
2421  5DF6              ; will put ram in page 0 also, page 1 is already there
2422  5DF6              BOXMEMVRM:
2423  5DF6              	; opening (
2424  5DF6 CD 95 55     	CALL CHKCHAR
2425  5DF9 28           	DB '('
2426  5DFA              	; get pointer to request struct
2427  5DFA DD 21 2F 54  	LD IX, FRMQNT
2428  5DFE CD 59 01     	CALL CALBAS
2429  5E01 D5           	PUSH DE
2430  5E02              	; ending )
2431  5E02 CD 95 55     	CALL CHKCHAR
2432  5E05 29           	DB ')'
2433  5E06
2434  5E06 DD E1        	POP IX ; pointer to request struct
2435  5E08
2436  5E08 E5           	PUSH HL ; save position in BASIC buffer
2437  5E09
2438  5E09 FD 21 10 5E  	LD IY, .RET
2439  5E0D C3 48 55     	JP ENABLE_PAGE0
2440  5E10              .RET:
2441  5E10 FB           	EI
2442  5E11              	; set RAM functions to call
2443  5E11 21 2F 5E     	LD HL, .SETDEST
2444  5E14 22 A8 5D     	LD (RECTANGLE_COPY.CALL1+1), HL
2445  5E17 21 37 5E     	LD HL, .COPYDATA
2446  5E1A 22 AB 5D     	LD (RECTANGLE_COPY.CALL2+1), HL
2447  5E1D 3E CD        	LD A, #CD ; CALL
2448  5E1F 32 A7 5D     	LD (RECTANGLE_COPY.CALL1), A
2449  5E22 32 AA 5D     	LD (RECTANGLE_COPY.CALL2), A
2450  5E25 CD 8F 5D     	CALL RECTANGLE_COPY
2451  5E28
2452  5E28 D1               POP DE
2453  5E29 C1               POP BC
2454  5E2A CD BF 54         CALL RESTORE_PAGE_INFO
2455  5E2D
2456  5E2D E1           	POP HL
2457  5E2E C9           	RET
2458  5E2F              .SETDEST:
2459  5E2F EB           	EX DE, HL
2460  5E30 F3           	DI
2461  5E31 CD 71 54     	CALL SETWRT_LOCAL
2462  5E34 FB           	EI
2463  5E35 EB           	EX DE, HL
2464  5E36 C9           	RET
2465  5E37              .COPYDATA:
2466  5E37 41           	LD B, C
2467  5E38 0E 98        	LD C, #98
2468  5E3A C3 7C 54     	JP BBYTECOPY
2469  5E3D              ; *******************************************************************************************************
2470  5E3D               ENDIF
2471  5E3D
2472  5E3D              EXT_END:
2473  5E3D
# file closed: asm\main.asm
