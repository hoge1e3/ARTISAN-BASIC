# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000              JIFFY	EQU #FC9E
  51  4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
  52  4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
  53  4000              PATBAS  EQU #F926 ; current sprite generator table address
  54  4000
  55  4000              ; BASIC error codes
  56  4000              ;01 NEXT without FOR
  57  4000              ;02 Syntax error
  58  4000              ;03 RETURN without GOSUB
  59  4000              ;04 Out of DATA
  60  4000              ;05 Illegal function call
  61  4000              ;06 Overflow
  62  4000              ;07 Out of memory
  63  4000              ;08 Undefined line number
  64  4000              ;09 Subscript out of range
  65  4000              ;10 Redimensioned array
  66  4000              ;11 Division by zero
  67  4000              ;12 Illegal direct
  68  4000              ;13 Type mismatch
  69  4000              ;14 Out of string space
  70  4000              ;15 String too long
  71  4000              ;16 String formula too complex
  72  4000              ;17 Can't CONTINUE
  73  4000              ;18 Undefined user function
  74  4000              ;19 Device I/O error
  75  4000              ;20 Verify error
  76  4000              ;21 No RESUME
  77  4000              ;22 RESUME without error
  78  4000              ;23 Unprintable error
  79  4000              ;24 Missing operand
  80  4000              ;25 Line buffer overflow
  81  4000              ;50 FIELD overflow
  82  4000              ;51 Internal error
  83  4000              ;52 Bad file number
  84  4000              ;53 File not found
  85  4000              ;54 File already open
  86  4000              ;55 Input past end
  87  4000              ;56 Bad file name
  88  4000              ;57 Direct statement in file
  89  4000              ;58 Sequential I/O only
  90  4000              ;59 File not OPEN
  91  4000
  92  4000
  93  4000               ; simulate cartridge with BASIC extension
  94  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  94  4004 87 56 00 00
  94  4008 00 00 00 00
  94  400C 00 00 00 00
  95  4010
  96  4010              ; this location #4010 stores last location used by basic extension
  97  4010              ; free memory after that point
  98  4010              FREEMEMPTR:
  99  4010 56 5F         DW EXT_END
 100  4012
 101  4012              ; this location #4012 stores extension version in DAA format
 102  4012              ; first byte is major version and second minor
 103  4012              VERSION:
 104  4012 00 70         DB #00, #70
 105  4014
 106  4014              ; binary included AKG player compiled at #4014
 107  4014               IF (SOUND_CMDS == 1)
 108  4014              	INCBIN "bin/AKG.bin"
 109  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 110  4CF0               ENDIF
 111  4CF0
 112  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 27 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A 7C 4D     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13 2A 9E FC         LD HL,(JIFFY)
  43+ 4D16 23               INC HL
  44+ 4D17 22 9E FC         LD (JIFFY),HL
  45+ 4D1A
  46+ 4D1A FD E1            POP IY
  47+ 4D1C DD E1            POP IX
  48+ 4D1E E1               POP HL
  49+ 4D1F D1               POP DE
  50+ 4D20 C1               POP BC
  51+ 4D21 F1               POP AF
  52+ 4D22 08               EX AF, AF'
  53+ 4D23 D9               EXX
  54+ 4D24 E1               POP HL
  55+ 4D25 D1               POP DE
  56+ 4D26 C1               POP BC
  57+ 4D27               ENDIF
  58+ 4D27
  59+ 4D27              .EXIT:
  60+ 4D27 F1           	POP AF
  61+ 4D28 FB           	EI
  62+ 4D29 ED 4D        	RETI
  63+ 4D2B              ; *******************************************************************************************************
  64+ 4D2B
  65+ 4D2B              ; *******************************************************************************************************
  66+ 4D2B              ; H.TIMI function
  67+ 4D2B              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2B              MBGE_HTIMI:
  69+ 4D2B               EXPORT MBGE_HTIMI
  70+ 4D2B
  71+ 4D2B               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2B
  73+ 4D2B F5           	PUSH AF
  74+ 4D2C
  75+ 4D2C              	; enable page 2
  76+ 4D2C 3E 02            LD A, 2
  77+ 4D2E CD B7 55         CALL GET_PAGE_INFO
  78+ 4D31 C5               PUSH BC
  79+ 4D32 D5               PUSH DE
  80+ 4D33 3A 43 F3         LD A, (RAMAD2)
  81+ 4D36 26 80            LD H, 080H
  82+ 4D38 CD FE 55         CALL LOCAL_ENASLT
  83+ 4D3B              	; enable page 0
  84+ 4D3B AF               XOR A
  85+ 4D3C CD B7 55         CALL GET_PAGE_INFO
  86+ 4D3F C5               PUSH BC
  87+ 4D40 D5               PUSH DE
  88+ 4D41 3A 41 F3         LD A, (RAMAD0)
  89+ 4D44 26 00            LD H, 0
  90+ 4D46 CD FE 55         CALL LOCAL_ENASLT
  91+ 4D49
  92+ 4D49               IF (SPRITE_CMDS == 1)
  93+ 4D49 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4C               ENDIF
  95+ 4D4C
  96+ 4D4C               IF (SOUND_CMDS == 1)
  97+ 4D4C 3A 7C 4D     	LD A, (SOUND_ENABLED)
  98+ 4D4F B7           	OR A
  99+ 4D50 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D53               ENDIF
 101+ 4D53
 102+ 4D53              	; restore page 0
 103+ 4D53 D1               POP DE
 104+ 4D54 C1               POP BC
 105+ 4D55 CD EE 55         CALL RESTORE_PAGE_INFO
 106+ 4D58              	; restore page 2
 107+ 4D58 D1               POP DE
 108+ 4D59 C1               POP BC
 109+ 4D5A CD EE 55         CALL RESTORE_PAGE_INFO
 110+ 4D5D
 111+ 4D5D F1           	POP AF
 112+ 4D5E               ENDIF
 113+ 4D5E C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D61              ; *******************************************************************************************************
 115+ 4D61
 116+ 4D61              ; *******************************************************************************************************
 117+ 4D61              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D61              ; also checks if some VRAM modifying command is running
 119+ 4D61              ; when that checks out calls sprite updates and animation processing
 120+ 4D61              PROCESS_SPRITES_AND_ANIMATIONS:
 121+ 4D61              	; check if initialized
 122+ 4D61 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 123+ 4D64 B7           	OR A
 124+ 4D65 C8           	RET Z
 125+ 4D66              	; check screen mode
 126+ 4D66 3A AF FC     	LD A, (SCRMOD)
 127+ 4D69 3D           	DEC A
 128+ 4D6A 28 02        	JR Z, .L0 ; screen 1
 129+ 4D6C 3D           	DEC A
 130+ 4D6D C0           	RET NZ ; not screen 2
 131+ 4D6E              .L0:
 132+ 4D6E                  ; check if anyone else is working with VRAM
 133+ 4D6E 3A 29 54         LD A,(VRAM_UPDATE_IN_PROGRESS)
 134+ 4D71 B7               OR A
 135+ 4D72 C0               RET NZ
 136+ 4D73
 137+ 4D73 CD 92 4D         CALL SPRATR_UPDATE
 138+ 4D76
 139+ 4D76               IF (ANIM_CMDS == 1)
 140+ 4D76 CD 3D 53         CALL PROCESS_ANIMATIONS
 141+ 4D79               ENDIF
 142+ 4D79 C9               RET
 143+ 4D7A              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 113  4D7A
 114  4D7A               IF (SOUND_CMDS == 1)
 115  4D7A              MUSIC_INIT_STATUS:
 116  4D7A 00            DB 0
 117  4D7B              SFX_INIT_STATUS:
 118  4D7B 00            DB 0
 119  4D7C              SOUND_ENABLED:
 120  4D7C 00            DB 0
 121  4D7D               ENDIF
 122  4D7D
 123  4D7D               IF (SPRITE_CMDS == 1)
 124  4D7D               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7D              ; commands and variables related to sprites
   2+ 4D7D
   3+ 4D7D              SPRATR_INIT_STATUS:
   4+ 4D7D 00            DB 0
   5+ 4D7E              SPRATR_UPDATE_FLAG:
   6+ 4D7E 00 00         DW 0
   7+ 4D80              SPRATR_DATA:
   8+ 4D80 00 00         DW 0
   9+ 4D82              SPRFLICKER_ENABLED:
  10+ 4D82 00            DB 0
  11+ 4D83              ; to support sprite flicker
  12+ 4D83              FLICKER:
  13+ 4D83 00            DB 0
  14+ 4D84
  15+ 4D84              ; to temporarily store stack pointer
  16+ 4D84              TMPSP:
  17+ 4D84 00 00         DW 0
  18+ 4D86
  19+ 4D86              ; *******************************************************************************************************
  20+ 4D86              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D86              ; changes HL,DE;
  22+ 4D86              GETnthSPRATTR:
  23+ 4D86 26 00            LD H,0
  24+ 4D88 6F               LD L,A
  25+ 4D89 CD B3 55         CALL HLx8
  26+ 4D8C ED 5B 80 4D      LD DE,(SPRATR_DATA)
  27+ 4D90 19               ADD HL,DE
  28+ 4D91 C9               RET
  29+ 4D92              ; *******************************************************************************************************
  30+ 4D92
  31+ 4D92              ; *******************************************************************************************************
  32+ 4D92              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D92              ; struct {
  34+ 4D92              ; DW y
  35+ 4D92              ; DW x
  36+ 4D92              ; DW pattern (0-63)
  37+ 4D92              ; DW color
  38+ 4D92              ; } [32]
  39+ 4D92              ; will hide sprites whose location is outside of visible area
  40+ 4D92              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D92              ; modifies AF, AF', BC, DE, HL
  42+ 4D92              SPRATR_UPDATE:
  43+ 4D92              	; check if update requested
  44+ 4D92 2A 7E 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D95 7E           	LD A, (HL)
  46+ 4D96 B7           	OR A
  47+ 4D97 C8           	RET Z
  48+ 4D98              .L0:
  49+ 4D98 06 20        	LD B, 32 ; sprite number
  50+ 4D9A 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D9C              	; set VDP address
  52+ 4D9C 2A 28 F9     	LD HL, (ATRBAS)
  53+ 4D9F 3A 82 4D     	LD A, (SPRFLICKER_ENABLED)
  54+ 4DA2 B7           	OR A
  55+ 4DA3 28 03        	JR Z, .L3
  56+ 4DA5 3A 83 4D     	LD A, (FLICKER)
  57+ 4DA8              .L3:
  58+ 4DA8 5F           	LD E, A
  59+ 4DA9 08           	EX AF, AF'
  60+ 4DAA 7B           	LD A, E
  61+ 4DAB 87           	ADD A, A
  62+ 4DAC 87           	ADD A, A
  63+ 4DAD 16 00        	LD D, 0
  64+ 4DAF 5F           	LD E, A
  65+ 4DB0 19           	ADD HL, DE
  66+ 4DB1 CD 9E 55     	CALL SETWRT_LOCAL
  67+ 4DB4 ED 73 84 4D  	LD (TMPSP), SP
  68+ 4DB8 ED 7B 80 4D  	LD SP, (SPRATR_DATA)
  69+ 4DBC
  70+ 4DBC              .LOOP:
  71+ 4DBC E1           	POP HL
  72+ 4DBD 24           	INC H
  73+ 4DBE 28 0D        	JR Z, .L1 ; negative number above -256
  74+ 4DC0 25           	DEC H
  75+ 4DC1 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  76+ 4DC3 7D           	LD A, L
  77+ 4DC4 FE C0        	CP 192
  78+ 4DC6 30 10        	JR NC, .OUT3
  79+ 4DC8 3D           	DEC A ; due to VDP rule that top of screen is -1
  80+ 4DC9 57           	LD D, A
  81+ 4DCA C3 F1 4D     	JP .X
  82+ 4DCD              .L1:
  83+ 4DCD 7D           	LD A, L
  84+ 4DCE C6 10        	ADD 16
  85+ 4DD0 FA D8 4D     	JP M, .OUT3 ; below -16
  86+ 4DD3 2D           	DEC L ; due to VDP rule that top of screen is -1
  87+ 4DD4 55           	LD D, L
  88+ 4DD5 C3 F1 4D     	JP .X
  89+ 4DD8              .OUT3:
  90+ 4DD8 E1           	POP HL ; skip x value
  91+ 4DD9              .OUT2:
  92+ 4DD9 E1           	POP HL ; skip pattern
  93+ 4DDA E1           	POP HL ; skip color
  94+ 4DDB 3E D1        	LD A, #D1
  95+ 4DDD ED 79        	OUT (C), A ; sprite hidden
  96+ 4DDF 00          > NOP
  96+ 4DE0 00          > NOP
  96+ 4DE1 00          > NOP
  97+ 4DE2 ED 79        	OUT (C), A ; value unimportant
  98+ 4DE4 00          > NOP
  98+ 4DE5 00          > NOP
  98+ 4DE6 00          > NOP
  99+ 4DE7 ED 79        	OUT (C), A ; value unimportant
 100+ 4DE9 00          > NOP
 100+ 4DEA 00          > NOP
 100+ 4DEB 00          > NOP
 101+ 4DEC ED 79        	OUT (C), A ; value unimportant
 102+ 4DEE C3 1C 4E     	JP .NEXT
 103+ 4DF1              .X:
 104+ 4DF1 E1           	POP HL
 105+ 4DF2 24           	INC H
 106+ 4DF3 28 08        	JR Z, .L2
 107+ 4DF5 25           	DEC H
 108+ 4DF6 20 E1        	JR NZ, .OUT2
 109+ 4DF8 1E 00        	LD E, 0 ; EC bit
 110+ 4DFA C3 06 4E     	JP .XY
 111+ 4DFD              .L2:
 112+ 4DFD 7D           	LD A, L
 113+ 4DFE C6 20        	ADD 32
 114+ 4E00 FA D9 4D     	JP M, .OUT2
 115+ 4E03 6F           	LD L, A
 116+ 4E04 1E 80        	LD E, #80
 117+ 4E06              .XY:
 118+ 4E06 ED 51        	OUT (C), D
 119+ 4E08 3A E0 F3     	LD A, (REG1SAV)
 120+ 4E0B E6 02        	AND 2
 121+ 4E0D ED 69        	OUT (C), L
 122+ 4E0F E1           	POP HL ; pattern
 123+ 4E10 7D           	LD A, L
 124+ 4E11 28 02        	JR Z, .SMALLSPRITES
 125+ 4E13 87           	ADD A, A
 126+ 4E14 87           	ADD A, A ; needs to go at 4x
 127+ 4E15              .SMALLSPRITES:
 128+ 4E15 D3 98        	OUT (#98), A
 129+ 4E17 E1           	POP HL ; color
 130+ 4E18 7D           	LD A, L
 131+ 4E19 B3           	OR E
 132+ 4E1A D3 98        	OUT (#98), A
 133+ 4E1C              .NEXT:
 134+ 4E1C 08           	EX AF, AF'
 135+ 4E1D 3C           	INC A
 136+ 4E1E E6 1F        	AND 31
 137+ 4E20 C2 34 4E     	JP NZ, .NEXT2
 138+ 4E23 08           	EX AF, AF'
 139+ 4E24 2A 28 F9     	LD HL, (ATRBAS)
 140+ 4E27              	; CALL SETWRT_LOCAL not allowed as SP modified
 141+ 4E27 7D           	LD	A, L
 142+ 4E28 D3 99        	OUT	(099H), A
 143+ 4E2A 7C           	LD	A, H
 144+ 4E2B E6 3F        	AND	03FH
 145+ 4E2D F6 40        	OR	040H
 146+ 4E2F D3 99        	OUT	(099H), A
 147+ 4E31 C3 35 4E     	JP .NEXT3
 148+ 4E34              .NEXT2:
 149+ 4E34 08           	EX AF, AF'
 150+ 4E35              .NEXT3:
 151+ 4E35 10 85        	DJNZ .LOOP
 152+ 4E37 08           	EX AF, AF'
 153+ 4E38 3C           	INC A
 154+ 4E39 32 83 4D     	LD (FLICKER), A
 155+ 4E3C
 156+ 4E3C ED 7B 84 4D  	LD SP, (TMPSP)
 157+ 4E40 2A 7E 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 158+ 4E43 36 00        	LD (HL), 0 ; zero out update flag
 159+ 4E45 C9           	RET
 160+ 4E46              ; *******************************************************************************************************
 161+ 4E46
 162+ 4E46              ; *******************************************************************************************************
 163+ 4E46              ; function to handle CALL SPRENABLE basic extension
 164+ 4E46              ; initializes sprites handler
 165+ 4E46              ; _SPRENABLE ( INT sprites_attributes_data,
 166+ 4E46              ;			   INT update_variable_location,
 167+ 4E46              ;			   INT sprite_flicker_enabled )
 168+ 4E46              ; expects both locations to be in range #8000+ or throws an error
 169+ 4E46              ; since these should be BASIC variables
 170+ 4E46              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 171+ 4E46              SPRENABLE:
 172+ 4E46              	; opening (
 173+ 4E46 CD C4 56     	CALL CHKCHAR
 174+ 4E49 28           	DB '('
 175+ 4E4A              	; get address of sprite attribute table DIM SA%(3,31)
 176+ 4E4A DD 21 2F 54  	LD IX, FRMQNT
 177+ 4E4E CD 59 01     	CALL CALBAS
 178+ 4E51 D5           	PUSH DE
 179+ 4E52              	; comma
 180+ 4E52 CD C4 56     	CALL CHKCHAR
 181+ 4E55 2C           	DB ','
 182+ 4E56              	; get address of sprite update flag location
 183+ 4E56 DD 21 2F 54  	LD IX, FRMQNT
 184+ 4E5A CD 59 01     	CALL CALBAS
 185+ 4E5D D5           	PUSH DE
 186+ 4E5E              	; comma
 187+ 4E5E CD C4 56     	CALL CHKCHAR
 188+ 4E61 2C           	DB ','
 189+ 4E62              	; get flicker enabled flag
 190+ 4E62 DD 21 2F 54  	LD IX, FRMQNT
 191+ 4E66 CD 59 01     	CALL CALBAS
 192+ 4E69 D5           	PUSH DE
 193+ 4E6A              	; ending )
 194+ 4E6A CD C4 56     	CALL CHKCHAR
 195+ 4E6D 29           	DB ')'
 196+ 4E6E
 197+ 4E6E D1           	POP DE ; get flicker flag
 198+ 4E6F 7A           	LD A, D
 199+ 4E70 B3           	OR E
 200+ 4E71 32 82 4D     	LD (SPRFLICKER_ENABLED), A
 201+ 4E74
 202+ 4E74 D1           	POP DE ; update variable location
 203+ 4E75 CB 7A        	BIT 7, D ; is address >= &h8000
 204+ 4E77 20 05        	JR NZ, .L1
 205+ 4E79 1E 05        	LD E, 5 ; illegal function call
 206+ 4E7B C3 E4 56     	JP THROW_ERROR
 207+ 4E7E              .L1:
 208+ 4E7E ED 53 7E 4D  	LD (SPRATR_UPDATE_FLAG), DE
 209+ 4E82 D1           	POP DE ; address of sprite attribute table
 210+ 4E83 CB 7A        	BIT 7, D ; is address >= &h8000
 211+ 4E85 20 05        	JR NZ, .L2
 212+ 4E87 1E 05        	LD E, 5 ; illegal function call
 213+ 4E89 C3 E4 56     	JP THROW_ERROR
 214+ 4E8C              .L2:
 215+ 4E8C ED 53 80 4D  	LD (SPRATR_DATA), DE
 216+ 4E90 3E 01        	LD A, 1
 217+ 4E92 32 7D 4D     	LD (SPRATR_INIT_STATUS), A
 218+ 4E95 C9           	RET
 219+ 4E96              ; *******************************************************************************************************
 220+ 4E96
 221+ 4E96              ; *******************************************************************************************************
 222+ 4E96              ; function to handle CALL SPRDISABLE basic extension
 223+ 4E96              ; disables sprites handling
 224+ 4E96              ; _SPRDISABLE
 225+ 4E96              ; resets variable SPRATR_INIT_STATUS
 226+ 4E96              SPRDISABLE:
 227+ 4E96 AF           	XOR A
 228+ 4E97 32 7D 4D     	LD (SPRATR_INIT_STATUS), A
 229+ 4E9A C9           	RET
 230+ 4E9B              ; *******************************************************************************************************
 231+ 4E9B
 232+ 4E9B              ; *******************************************************************************************************
 233+ 4E9B              ; function to handle CALL SPRSET basic extension
 234+ 4E9B              ; sets position, and optionally pattern and color of sprite
 235+ 4E9B              ; _SPRSET ( BYTE sprite_num , valid 0-31
 236+ 4E9B              ;			INT x,
 237+ 4E9B              ;			INT y,
 238+ 4E9B              ;			INT pattern, valid 0-63, otherwise ignored
 239+ 4E9B              ;			INT color, valid 0-15, otherwise ignored
 240+ 4E9B              SPRSET:
 241+ 4E9B 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 242+ 4E9E B7           	OR A
 243+ 4E9F 20 05        	JR NZ, .L1
 244+ 4EA1 1E 05        	LD E, 5 ; illegal function call
 245+ 4EA3 C3 E4 56     	JP THROW_ERROR
 246+ 4EA6              .L1:
 247+ 4EA6              	; opening (
 248+ 4EA6 CD C4 56     	CALL CHKCHAR
 249+ 4EA9 28           	DB '('
 250+ 4EAA              	; get sprite number
 251+ 4EAA DD 21 1C 52  	LD IX, GETBYT
 252+ 4EAE CD 59 01     	CALL CALBAS
 253+ 4EB1 F5           	PUSH AF
 254+ 4EB2              	; comma
 255+ 4EB2 CD C4 56     	CALL CHKCHAR
 256+ 4EB5 2C           	DB ','
 257+ 4EB6              	; get x
 258+ 4EB6 DD 21 2F 54  	LD IX, FRMQNT
 259+ 4EBA CD 59 01     	CALL CALBAS
 260+ 4EBD D5           	PUSH DE
 261+ 4EBE              	; comma
 262+ 4EBE CD C4 56     	CALL CHKCHAR
 263+ 4EC1 2C           	DB ','
 264+ 4EC2              	; get y
 265+ 4EC2 DD 21 2F 54  	LD IX, FRMQNT
 266+ 4EC6 CD 59 01     	CALL CALBAS
 267+ 4EC9 D5           	PUSH DE
 268+ 4ECA              	; comma
 269+ 4ECA CD C4 56     	CALL CHKCHAR
 270+ 4ECD 2C           	DB ','
 271+ 4ECE              	; get pattern
 272+ 4ECE DD 21 2F 54  	LD IX, FRMQNT
 273+ 4ED2 CD 59 01     	CALL CALBAS
 274+ 4ED5 D5           	PUSH DE
 275+ 4ED6              	; comma
 276+ 4ED6 CD C4 56     	CALL CHKCHAR
 277+ 4ED9 2C           	DB ','
 278+ 4EDA              	; get color
 279+ 4EDA DD 21 2F 54  	LD IX, FRMQNT
 280+ 4EDE CD 59 01     	CALL CALBAS
 281+ 4EE1 D5           	PUSH DE
 282+ 4EE2              	; ending )
 283+ 4EE2 CD C4 56     	CALL CHKCHAR
 284+ 4EE5 29           	DB ')'
 285+ 4EE6
 286+ 4EE6                  ; save position in BASIC text
 287+ 4EE6 E5           	PUSH HL
 288+ 4EE7 DD E1        	POP IX
 289+ 4EE9
 290+ 4EE9 C1           	POP BC ; color
 291+ 4EEA D1           	POP DE ; pattern
 292+ 4EEB D9           	EXX
 293+ 4EEC C1           	POP BC ; y
 294+ 4EED D1           	POP DE ; x
 295+ 4EEE F1           	POP AF ; sprite number
 296+ 4EEF FE 20        	CP 32
 297+ 4EF1 38 05        	JR C, .L2
 298+ 4EF3 1E 05        	LD E, 5 ; illegal function call
 299+ 4EF5 C3 E4 56     	JP THROW_ERROR
 300+ 4EF8              .L2:
 301+ 4EF8              	; find location in sprite attributes table
 302+ 4EF8 D5           	PUSH DE
 303+ 4EF9 CD 86 4D     	CALL GETnthSPRATTR
 304+ 4EFC D1           	POP DE
 305+ 4EFD              	; set y
 306+ 4EFD 71           	LD (HL), C
 307+ 4EFE 23           	INC HL
 308+ 4EFF 70           	LD (HL), B
 309+ 4F00 23           	INC HL
 310+ 4F01              	; set x
 311+ 4F01 73           	LD (HL), E
 312+ 4F02 23           	INC HL
 313+ 4F03 72           	LD (HL), D
 314+ 4F04 23           	INC HL
 315+ 4F05 E5           	PUSH HL
 316+ 4F06 D9           	EXX
 317+ 4F07 E1           	POP HL
 318+ 4F08              	; check if 0<=pattern<64
 319+ 4F08 7A           	LD A, D
 320+ 4F09 B7           	OR A
 321+ 4F0A 20 0B        	JR NZ, .L3
 322+ 4F0C 7B           	LD A, E
 323+ 4F0D FE 40        	CP 64
 324+ 4F0F 30 06        	JR NC, .L3
 325+ 4F11              	; set pattern
 326+ 4F11              	;ADD A, A
 327+ 4F11              	;ADD A, A
 328+ 4F11              	;ADD A, A
 329+ 4F11 77           	LD (HL), A
 330+ 4F12 23           	INC HL
 331+ 4F13 72           	LD (HL), D
 332+ 4F14 23           	INC HL
 333+ 4F15 18 02        	JR .L4
 334+ 4F17              .L3:
 335+ 4F17              	; skip pattern
 336+ 4F17 23          > INC HL
 336+ 4F18 23          > INC HL
 337+ 4F19              .L4:
 338+ 4F19              	; check if 0<=color<16
 339+ 4F19 78           	LD A, B
 340+ 4F1A B7           	OR A
 341+ 4F1B 20 08        	JR NZ, .L5
 342+ 4F1D 79           	LD A, C
 343+ 4F1E FE 10        	CP 16
 344+ 4F20 30 03        	JR NC, .L5
 345+ 4F22              	; set color
 346+ 4F22 71           	LD (HL), C
 347+ 4F23 23           	INC HL
 348+ 4F24 70           	LD (HL), B
 349+ 4F25
 350+ 4F25              .L5:
 351+ 4F25 DD E5        	PUSH IX
 352+ 4F27 E1           	POP HL
 353+ 4F28 C9           	RET
 354+ 4F29              ; *******************************************************************************************************
 355+ 4F29
 356+ 4F29              ; *******************************************************************************************************
 357+ 4F29              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4F29              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4F29              ; input DE=initial x
 360+ 4F29              ; input BC=initial y
 361+ 4F29              ; input IY=location where delta y,x are located
 362+ 4F29              ; modifies AF, HL, IX
 363+ 4F29              SPRSET_DELTA_POS:
 364+ 4F29 D5           	PUSH DE
 365+ 4F2A CD 86 4D     	CALL GETnthSPRATTR
 366+ 4F2D E5           	PUSH HL
 367+ 4F2E DD E1        	POP IX
 368+ 4F30 D1           	POP DE
 369+ 4F31              	; IX=sprite's y location
 370+ 4F31 FD 6E 00     	LD L, (IY)
 371+ 4F34 FD 66 01     	LD H, (IY+1)
 372+ 4F37 09           	ADD HL, BC
 373+ 4F38 DD 75 00     	LD (IX), L
 374+ 4F3B DD 74 01     	LD (IX+1), H
 375+ 4F3E FD 6E 02     	LD L, (IY+2)
 376+ 4F41 FD 66 03     	LD H, (IY+3)
 377+ 4F44 19           	ADD HL, DE
 378+ 4F45 DD 75 02     	LD (IX+2), L
 379+ 4F48 DD 74 03     	LD (IX+3), H
 380+ 4F4B C9           	RET
 381+ 4F4C              ; *******************************************************************************************************
 382+ 4F4C
 383+ 4F4C              ; *******************************************************************************************************
 384+ 4F4C              ; function to handle CALL SPRGRPMOV basic extension
 385+ 4F4C              ; sets position of a group of sprites described with
 386+ 4F4C              ; { int sprite_num, int delta_y, int delta_x } [count]
 387+ 4F4C              ; _SPRGRPMOV ( INT x,
 388+ 4F4C              ;			   INT y,
 389+ 4F4C              ;			   INT data_ptr,
 390+ 4F4C              ;			   BYTE count,
 391+ 4F4C              ; will put ram in page 0 also, page 1 is already there
 392+ 4F4C              SPRGRPMOV:
 393+ 4F4C 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 394+ 4F4F B7           	OR A
 395+ 4F50 20 05        	JR NZ, .L1
 396+ 4F52 1E 05        	LD E, 5 ; illegal function call
 397+ 4F54 C3 E4 56     	JP THROW_ERROR
 398+ 4F57              .L1:
 399+ 4F57              	; opening (
 400+ 4F57 CD C4 56     	CALL CHKCHAR
 401+ 4F5A 28           	DB '('
 402+ 4F5B              	; get x
 403+ 4F5B DD 21 2F 54  	LD IX, FRMQNT
 404+ 4F5F CD 59 01     	CALL CALBAS
 405+ 4F62 D5           	PUSH DE
 406+ 4F63              	; comma
 407+ 4F63 CD C4 56     	CALL CHKCHAR
 408+ 4F66 2C           	DB ','
 409+ 4F67              	; get y
 410+ 4F67 DD 21 2F 54  	LD IX, FRMQNT
 411+ 4F6B CD 59 01     	CALL CALBAS
 412+ 4F6E D5           	PUSH DE
 413+ 4F6F              	; comma
 414+ 4F6F CD C4 56     	CALL CHKCHAR
 415+ 4F72 2C           	DB ','
 416+ 4F73              	; get data pointer
 417+ 4F73 DD 21 2F 54  	LD IX, FRMQNT
 418+ 4F77 CD 59 01     	CALL CALBAS
 419+ 4F7A D5           	PUSH DE
 420+ 4F7B              	; comma
 421+ 4F7B CD C4 56     	CALL CHKCHAR
 422+ 4F7E 2C           	DB ','
 423+ 4F7F              	; get count
 424+ 4F7F DD 21 1C 52  	LD IX, GETBYT
 425+ 4F83 CD 59 01     	CALL CALBAS
 426+ 4F86 F5           	PUSH AF
 427+ 4F87              	; ending )
 428+ 4F87 CD C4 56     	CALL CHKCHAR
 429+ 4F8A 29           	DB ')'
 430+ 4F8B
 431+ 4F8B E5           	PUSH HL
 432+ 4F8C DD E1        	POP IX
 433+ 4F8E
 434+ 4F8E C1           	POP BC ; count
 435+ 4F8F E1           	POP HL ; data pointer
 436+ 4F90 D9           	EXX
 437+ 4F91 C1           	POP BC ; y
 438+ 4F92 D1           	POP DE ; x
 439+ 4F93 D9           	EXX
 440+ 4F94
 441+ 4F94 DD E5        	PUSH IX ; save position in BASIC buffer
 442+ 4F96
 443+ 4F96 C5           	PUSH BC
 444+ 4F97 E5           	PUSH HL
 445+ 4F98 AF               XOR A
 446+ 4F99 CD B7 55         CALL GET_PAGE_INFO
 447+ 4F9C D9           	EXX
 448+ 4F9D E1           	POP HL
 449+ 4F9E F1           	POP AF
 450+ 4F9F D9           	EXX
 451+ 4FA0 C5               PUSH BC
 452+ 4FA1 D5               PUSH DE
 453+ 4FA2 D9           	EXX
 454+ 4FA3 F5           	PUSH AF
 455+ 4FA4 E5           	PUSH HL
 456+ 4FA5 D9           	EXX
 457+ 4FA6 3A 41 F3         LD A, (RAMAD0)
 458+ 4FA9 26 00            LD H, 0
 459+ 4FAB CD FE 55         CALL LOCAL_ENASLT
 460+ 4FAE FB           	EI
 461+ 4FAF E1           	POP HL
 462+ 4FB0 C1           	POP BC
 463+ 4FB1 CD BB 4F     	CALL .UPDATE_LOC
 464+ 4FB4 D1               POP DE
 465+ 4FB5 C1               POP BC
 466+ 4FB6 CD EE 55         CALL RESTORE_PAGE_INFO
 467+ 4FB9 E1           	POP HL
 468+ 4FBA C9           	RET
 469+ 4FBB
 470+ 4FBB              .UPDATE_LOC:
 471+ 4FBB              .L4:
 472+ 4FBB 7E           	LD A, (HL)
 473+ 4FBC 23           	INC HL
 474+ 4FBD 23           	INC HL
 475+ 4FBE E5           	PUSH HL
 476+ 4FBF FD E1        	POP IY
 477+ 4FC1 D9           	EXX
 478+ 4FC2 CD 29 4F     	CALL SPRSET_DELTA_POS
 479+ 4FC5 D9           	EXX
 480+ 4FC6 23          > INC HL
 480+ 4FC7 23          > INC HL
 480+ 4FC8 23          > INC HL
 480+ 4FC9 23          > INC HL
 481+ 4FCA 10 EF        	DJNZ .L4
 482+ 4FCC C9           	RET
 483+ 4FCD              ; *******************************************************************************************************
 484+ 4FCD
# file closed: asm\SPRITES.asm
 125  4FCD               ENDIF
 126  4FCD
 127  4FCD               IF (ANIM_CMDS == 1)
 128  4FCD               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4FCD              ; sprite animation routines
   2+ 4FCD
   3+ 4FCD              ; number of animation items and pointer
   4+ 4FCD              ANIMITEMNUM:
   5+ 4FCD 00            DB 0
   6+ 4FCE              ANIMITEMPTR:
   7+ 4FCE 56 5F         DW EXT_END
   8+ 4FD0              ; number of animation definitions and pointer
   9+ 4FD0              ANIMDEFNUM:
  10+ 4FD0 00            DB 0
  11+ 4FD1              ANIMDEFPTR:
  12+ 4FD1 56 5F         DW EXT_END
  13+ 4FD3              ; number of links between sprite and animation definitions
  14+ 4FD3              ANIMSPRNUM:
  15+ 4FD3 00            DB 0
  16+ 4FD4              ANIMSPRPTR:
  17+ 4FD4 56 5F         DW EXT_END
  18+ 4FD6
  19+ 4FD6              ; ANIMATION ITEM
  20+ 4FD6              ; byte type = [0 - pattern and color change
  21+ 4FD6              ;              1 - pattern definition change ]
  22+ 4FD6              ; word ticks - number of ticks to hold this state
  23+ 4FD6              ; for type = 0
  24+ 4FD6              ;   byte pattern;
  25+ 4FD6              ;   byte color;
  26+ 4FD6              ; for type = 1
  27+ 4FD6              ;   work data_pointer;
  28+ 4FD6              ; total size = 5b
  29+ 4FD6
  30+ 4FD6              ; ANIMATION DEFINITION
  31+ 4FD6              ; byte number of items 1-15
  32+ 4FD6              ; byte[15] anim_item;
  33+ 4FD6              ; total size = 16b
  34+ 4FD6
  35+ 4FD6              ; SPRITE ANIMATION
  36+ 4FD6              ; +00 byte sprite number;
  37+ 4FD6              ; +01 word time;
  38+ 4FD6              ; +03 byte current item;
  39+ 4FD6              ; +04 byte animation definition;
  40+ 4FD6              ; +05 byte cyclic;
  41+ 4FD6              ; +06 byte active;
  42+ 4FD6              ; +07 byte reserved
  43+ 4FD6              ; total size = 8b
  44+ 4FD6
  45+ 4FD6              ; *******************************************************************************************************
  46+ 4FD6              ; helper function HL=A*5
  47+ 4FD6              ; changes HL,DE;
  48+ 4FD6              Ax5:
  49+ 4FD6 26 00            LD H,0
  50+ 4FD8 6F               LD L,A
  51+ 4FD9 54               LD D,H
  52+ 4FDA 5D               LD E,L
  53+ 4FDB 29               ADD HL,HL
  54+ 4FDC 29               ADD HL,HL
  55+ 4FDD 19               ADD HL,DE
  56+ 4FDE C9               RET
  57+ 4FDF              ; *******************************************************************************************************
  58+ 4FDF
  59+ 4FDF              ; *******************************************************************************************************
  60+ 4FDF              ; helper function gets pointer to n-th animation item
  61+ 4FDF              ; changes HL,DE;
  62+ 4FDF              GETnthANIMITEM:
  63+ 4FDF CD D6 4F         CALL Ax5
  64+ 4FE2 ED 5B CE 4F      LD DE,(ANIMITEMPTR)
  65+ 4FE6 19               ADD HL,DE
  66+ 4FE7 C9               RET
  67+ 4FE8              ; *******************************************************************************************************
  68+ 4FE8
  69+ 4FE8              ; *******************************************************************************************************
  70+ 4FE8              ; helper function gets pointer to n-th entry in animation definition
  71+ 4FE8              ; changes HL,DE;
  72+ 4FE8              GETnthANIMDEF:
  73+ 4FE8 26 00            LD H,0
  74+ 4FEA 6F               LD L,A
  75+ 4FEB CD B3 55         CALL HLx8
  76+ 4FEE ED 5B D1 4F      LD DE,(ANIMDEFPTR)
  77+ 4FF2 19               ADD HL,DE
  78+ 4FF3 C9               RET
  79+ 4FF4              ; *******************************************************************************************************
  80+ 4FF4
  81+ 4FF4              ; *******************************************************************************************************
  82+ 4FF4              ; helper function gets pointer to n-th entry in sprite animation
  83+ 4FF4              ; changes HL,DE;
  84+ 4FF4              GETnthSPRANIM:
  85+ 4FF4 26 00            LD H,0
  86+ 4FF6 6F               LD L,A
  87+ 4FF7 CD B2 55         CALL HLx16
  88+ 4FFA ED 5B D4 4F      LD DE,(ANIMSPRPTR)
  89+ 4FFE 19               ADD HL,DE
  90+ 4FFF C9               RET
  91+ 5000              ; *******************************************************************************************************
  92+ 5000
  93+ 5000              ; *******************************************************************************************************
  94+ 5000              ; function to handle CALL MAXANIMITEMS basic extension
  95+ 5000              ; MAXANIMITEMS (BYTE number)
  96+ 5000              ; sets new number and moves memory buffers as needed
  97+ 5000              MAXANIMITEMS:
  98+ 5000              	; opening (
  99+ 5000 CD C4 56     	CALL CHKCHAR
 100+ 5003 28           	DB '('
 101+ 5004              	; get value
 102+ 5004 DD 21 1C 52  	LD IX, GETBYT
 103+ 5008 CD 59 01     	CALL CALBAS
 104+ 500B F5               PUSH AF
 105+ 500C              	; ending )
 106+ 500C CD C4 56     	CALL CHKCHAR
 107+ 500F 29           	DB ')'
 108+ 5010 F1               POP AF
 109+ 5011
 110+ 5011              	; save position
 111+ 5011 E5           	PUSH HL
 112+ 5012              .ENTRY:
 113+ 5012 47               LD B,A
 114+ 5013 3A CD 4F         LD A,(ANIMITEMNUM)
 115+ 5016 90               SUB B
 116+ 5017 28 1F            JR Z, .EXIT; same value as before
 117+ 5019 FD 21 D1 4F      LD IY,ANIMDEFPTR
 118+ 501D FA 3B 50         JP M, .INCREASE
 119+ 5020                  ; new value is lower than previous one
 120+ 5020 CD 53 50         CALL .SIZEDIFF
 121+ 5023 CD 6E 50         CALL .DECREASE_COMMON
 122+ 5026 2A D4 4F         LD HL,(ANIMSPRPTR)
 123+ 5029 AF               XOR A
 124+ 502A ED 42            SBC HL,BC
 125+ 502C 22 D4 4F         LD (ANIMSPRPTR),HL
 126+ 502F              .E1:
 127+ 502F 2A 10 40         LD HL,(FREEMEMPTR)
 128+ 5032 AF               XOR A
 129+ 5033 ED 42            SBC HL,BC
 130+ 5035 22 10 40         LD (FREEMEMPTR),HL
 131+ 5038              .EXIT:
 132+ 5038 FB               EI
 133+ 5039 E1           	POP HL
 134+ 503A C9           	RET
 135+ 503B              .INCREASE:
 136+ 503B ED 44            NEG
 137+ 503D CD 53 50         CALL .SIZEDIFF
 138+ 5040 CD 9A 50         CALL .INCREASE_COMMON
 139+ 5043 2A D4 4F         LD HL,(ANIMSPRPTR)
 140+ 5046 09               ADD HL,BC
 141+ 5047 22 D4 4F         LD (ANIMSPRPTR),HL
 142+ 504A              .E2:
 143+ 504A 2A 10 40         LD HL,(FREEMEMPTR)
 144+ 504D 09               ADD HL,BC
 145+ 504E 22 10 40         LD (FREEMEMPTR),HL
 146+ 5051 18 E5            JR .EXIT
 147+ 5053              .SIZEDIFF:
 148+ 5053 CD D6 4F         CALL Ax5
 149+ 5056 78               LD A,B
 150+ 5057 32 CD 4F         LD (ANIMITEMNUM),A
 151+ 505A 44               LD B,H
 152+ 505B 4D               LD C,L
 153+ 505C C9               RET ; BC=size difference in bytes
 154+ 505D              .SIZETOMOVE:
 155+ 505D D5               PUSH DE
 156+ 505E 2A 10 40         LD HL,(FREEMEMPTR)
 157+ 5061 FD 5E 00         LD E,(IY)
 158+ 5064 FD 56 01         LD D,(IY+1)
 159+ 5067 AF               XOR A
 160+ 5068 ED 52            SBC HL,DE
 161+ 506A 44               LD B,H
 162+ 506B 4D               LD C,L
 163+ 506C D1               POP DE
 164+ 506D C9               RET
 165+ 506E              .DECREASE_COMMON:
 166+ 506E FD 6E 00         LD L,(IY)
 167+ 5071 FD 66 01         LD H,(IY+1)
 168+ 5074 AF               XOR A
 169+ 5075 ED 42            SBC HL,BC
 170+ 5077 EB               EX DE,HL
 171+ 5078 C5               PUSH BC
 172+ 5079 CD 5D 50         CALL .SIZETOMOVE
 173+ 507C F3               DI
 174+ 507D 78               LD A,B
 175+ 507E B1               OR C
 176+ 507F 28 08            JR Z,.L1
 177+ 5081 FD 6E 00         LD L,(IY)
 178+ 5084 FD 66 01         LD H,(IY+1)
 179+ 5087 ED B0            LDIR
 180+ 5089              .L1:
 181+ 5089 C1               POP BC
 182+ 508A FD 6E 00         LD L,(IY)
 183+ 508D FD 66 01         LD H,(IY+1)
 184+ 5090 AF               XOR A
 185+ 5091 ED 42            SBC HL,BC
 186+ 5093 FD 75 00         LD (IY),L
 187+ 5096 FD 74 01         LD (IY+1),H
 188+ 5099 C9               RET
 189+ 509A              .INCREASE_COMMON:
 190+ 509A 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 509D 2B               DEC HL
 192+ 509E AF               XOR A
 193+ 509F ED 42            SBC HL,BC
 194+ 50A1 EB               EX DE,HL
 195+ 50A2 C5               PUSH BC
 196+ 50A3 CD 5D 50         CALL .SIZETOMOVE
 197+ 50A6 F3               DI
 198+ 50A7 78               LD A,B
 199+ 50A8 B1               OR C
 200+ 50A9 28 06            JR Z,.L2
 201+ 50AB 2A 10 40         LD HL,(FREEMEMPTR)
 202+ 50AE 2B               DEC HL
 203+ 50AF ED B8            LDDR
 204+ 50B1              .L2:
 205+ 50B1 C1               POP BC
 206+ 50B2 FD 6E 00         LD L,(IY)
 207+ 50B5 FD 66 01         LD H,(IY+1)
 208+ 50B8 09               ADD HL,BC
 209+ 50B9 FD 75 00         LD (IY),L
 210+ 50BC FD 74 01         LD (IY+1),H
 211+ 50BF C9               RET
 212+ 50C0              ; *******************************************************************************************************
 213+ 50C0
 214+ 50C0              ; *******************************************************************************************************
 215+ 50C0              ; function to handle CALL ANIMITEMPAT basic extension
 216+ 50C0              ; ANIMITEMPAT ( BYTE id,
 217+ 50C0              ;               INT ticks,
 218+ 50C0              ;               BYTE pattern,
 219+ 50C0              ;               BYTE color )
 220+ 50C0              ; fills animation item data, returns an error if out of bounds
 221+ 50C0              ANIMITEMPAT:
 222+ 50C0                  ; opening (
 223+ 50C0 CD C4 56     	CALL CHKCHAR
 224+ 50C3 28           	DB '('
 225+ 50C4              	; get id
 226+ 50C4 DD 21 1C 52  	LD IX, GETBYT
 227+ 50C8 CD 59 01     	CALL CALBAS
 228+ 50CB F5               PUSH AF
 229+ 50CC                  ; check if out of bounds
 230+ 50CC 3C               INC A
 231+ 50CD 4F               LD C,A
 232+ 50CE 3A CD 4F         LD A,(ANIMITEMNUM)
 233+ 50D1 B9               CP C
 234+ 50D2 DA DA 56         JP C,SUBSCRIPT_OUT_OF_RANGE
 235+ 50D5              	; comma
 236+ 50D5 CD C4 56     	CALL CHKCHAR
 237+ 50D8 2C           	DB ','
 238+ 50D9              	; get ticks
 239+ 50D9 DD 21 2F 54  	LD IX, FRMQNT
 240+ 50DD CD 59 01     	CALL CALBAS
 241+ 50E0 D5           	PUSH DE
 242+ 50E1              	; comma
 243+ 50E1 CD C4 56     	CALL CHKCHAR
 244+ 50E4 2C           	DB ','
 245+ 50E5              	; get pattern
 246+ 50E5 DD 21 1C 52  	LD IX, GETBYT
 247+ 50E9 CD 59 01     	CALL CALBAS
 248+ 50EC F5               PUSH AF
 249+ 50ED              	; comma
 250+ 50ED CD C4 56     	CALL CHKCHAR
 251+ 50F0 2C           	DB ','
 252+ 50F1              	; get color
 253+ 50F1 DD 21 1C 52  	LD IX, GETBYT
 254+ 50F5 CD 59 01     	CALL CALBAS
 255+ 50F8 F5               PUSH AF
 256+ 50F9              	; ending )
 257+ 50F9 CD C4 56     	CALL CHKCHAR
 258+ 50FC 29           	DB ')'
 259+ 50FD              .ENTRY:
 260+ 50FD E5               PUSH HL
 261+ 50FE DD E1            POP IX
 262+ 5100 D9               EXX
 263+ 5101 C1               POP BC ; color
 264+ 5102 D1               POP DE ; pattern
 265+ 5103 E1               POP HL ; ticks
 266+ 5104 D9               EXX
 267+ 5105 F1               POP AF
 268+ 5106 CD DF 4F         CALL GETnthANIMITEM
 269+ 5109 E5               PUSH HL
 270+ 510A FD E1            POP IY
 271+ 510C D9               EXX
 272+ 510D FD 36 00 00      LD (IY),0 ; type=0
 273+ 5111 FD 75 01         LD (IY+1),L
 274+ 5114 FD 74 02         LD (IY+2),H
 275+ 5117 FD 72 03         LD (IY+3),D
 276+ 511A FD 70 04         LD (IY+4),B
 277+ 511D
 278+ 511D DD E5            PUSH IX
 279+ 511F E1               POP HL
 280+ 5120 C9               RET
 281+ 5121              ; *******************************************************************************************************
 282+ 5121
 283+ 5121              ; *******************************************************************************************************
 284+ 5121              ; function to handle CALL ANIMITEMPTR basic extension
 285+ 5121              ; ANIMITEMPTR ( BYTE id,
 286+ 5121              ;               INT ticks,
 287+ 5121              ;               INT pointer,
 288+ 5121              ; fills animation item data, returns an error if out of bounds
 289+ 5121              ANIMITEMPTR_CMD:
 290+ 5121                  ; opening (
 291+ 5121 CD C4 56     	CALL CHKCHAR
 292+ 5124 28           	DB '('
 293+ 5125              	; get id
 294+ 5125 DD 21 1C 52  	LD IX, GETBYT
 295+ 5129 CD 59 01     	CALL CALBAS
 296+ 512C F5               PUSH AF
 297+ 512D                  ; check if out of bounds
 298+ 512D 3C               INC A
 299+ 512E 4F               LD C,A
 300+ 512F 3A CD 4F         LD A,(ANIMITEMNUM)
 301+ 5132 B9               CP C
 302+ 5133 DA DA 56         JP C,SUBSCRIPT_OUT_OF_RANGE
 303+ 5136              	; comma
 304+ 5136 CD C4 56     	CALL CHKCHAR
 305+ 5139 2C           	DB ','
 306+ 513A              	; get ticks
 307+ 513A DD 21 2F 54  	LD IX, FRMQNT
 308+ 513E CD 59 01     	CALL CALBAS
 309+ 5141 D5           	PUSH DE
 310+ 5142              	; comma
 311+ 5142 CD C4 56     	CALL CHKCHAR
 312+ 5145 2C           	DB ','
 313+ 5146              	; get pointer
 314+ 5146 DD 21 2F 54  	LD IX, FRMQNT
 315+ 514A CD 59 01     	CALL CALBAS
 316+ 514D D5           	PUSH DE
 317+ 514E              	; ending )
 318+ 514E CD C4 56     	CALL CHKCHAR
 319+ 5151 29           	DB ')'
 320+ 5152              .ENTRY:
 321+ 5152 E5               PUSH HL
 322+ 5153 DD E1            POP IX
 323+ 5155 D9               EXX
 324+ 5156 D1               POP DE ; pointer
 325+ 5157 E1               POP HL ; ticks
 326+ 5158 D9               EXX
 327+ 5159 F1               POP AF
 328+ 515A CD DF 4F         CALL GETnthANIMITEM
 329+ 515D E5               PUSH HL
 330+ 515E FD E1            POP IY
 331+ 5160 D9               EXX
 332+ 5161 FD 36 00 01      LD (IY),1 ; type=1
 333+ 5165 FD 75 01         LD (IY+1),L
 334+ 5168 FD 74 02         LD (IY+2),H
 335+ 516B FD 73 03         LD (IY+3),E
 336+ 516E FD 72 04         LD (IY+4),D
 337+ 5171
 338+ 5171 DD E5            PUSH IX
 339+ 5173 E1               POP HL
 340+ 5174 C9               RET
 341+ 5175              ; *******************************************************************************************************
 342+ 5175
 343+ 5175              ; *******************************************************************************************************
 344+ 5175              ; function to handle CALL MAXANIMDEFS basic extension
 345+ 5175              ; MAXANIMDEFS (BYTE number)
 346+ 5175              ; sets new number and moves memory buffers as needed
 347+ 5175              MAXANIMDEFS:
 348+ 5175              	; opening (
 349+ 5175 CD C4 56     	CALL CHKCHAR
 350+ 5178 28           	DB '('
 351+ 5179              	; get value
 352+ 5179 DD 21 1C 52  	LD IX, GETBYT
 353+ 517D CD 59 01     	CALL CALBAS
 354+ 5180 F5               PUSH AF
 355+ 5181              	; ending )
 356+ 5181 CD C4 56     	CALL CHKCHAR
 357+ 5184 29           	DB ')'
 358+ 5185 F1               POP AF
 359+ 5186
 360+ 5186              	; save position
 361+ 5186 E5           	PUSH HL
 362+ 5187              .ENTRY:
 363+ 5187 47               LD B,A
 364+ 5188 3A D0 4F         LD A,(ANIMDEFNUM)
 365+ 518B 90               SUB B
 366+ 518C CA 38 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 367+ 518F FD 21 D4 4F      LD IY,ANIMSPRPTR
 368+ 5193 FA 9F 51         JP M, .INCREASE
 369+ 5196                  ; new value is lower than previous one
 370+ 5196 CD AA 51         CALL .SIZEDIFF
 371+ 5199 CD 6E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 372+ 519C C3 2F 50         JP MAXANIMITEMS.E1
 373+ 519F              .INCREASE:
 374+ 519F ED 44            NEG
 375+ 51A1 CD AA 51         CALL .SIZEDIFF
 376+ 51A4 CD 9A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 377+ 51A7 C3 4A 50         JP MAXANIMITEMS.E2
 378+ 51AA              .SIZEDIFF:
 379+ 51AA 26 00            LD H,0
 380+ 51AC 6F               LD L,A
 381+ 51AD CD B2 55         CALL HLx16
 382+ 51B0 78               LD A,B
 383+ 51B1 32 D0 4F         LD (ANIMDEFNUM),A
 384+ 51B4 44               LD B,H
 385+ 51B5 4D               LD C,L
 386+ 51B6 C9               RET ; BC=size difference in bytes
 387+ 51B7              ; *******************************************************************************************************
 388+ 51B7
 389+ 51B7              ; *******************************************************************************************************
 390+ 51B7              ; function to handle CALL ANIMDEF basic extension
 391+ 51B7              ; ANIMITEMPAT ( BYTE id,
 392+ 51B7              ;               BYTE size,
 393+ 51B7              ;               INT[] list )
 394+ 51B7              ; fills animation definition data, returns an error if out of bounds, or invalid type
 395+ 51B7              ANIMDEF:
 396+ 51B7                  ; opening (
 397+ 51B7 CD C4 56     	CALL CHKCHAR
 398+ 51BA 28           	DB '('
 399+ 51BB              	; get id
 400+ 51BB DD 21 1C 52  	LD IX, GETBYT
 401+ 51BF CD 59 01     	CALL CALBAS
 402+ 51C2 F5               PUSH AF
 403+ 51C3                  ; check if out of bounds
 404+ 51C3 3C               INC A
 405+ 51C4 4F               LD C,A
 406+ 51C5 3A D0 4F         LD A,(ANIMDEFNUM)
 407+ 51C8 B9               CP C
 408+ 51C9 DA DA 56         JP C,SUBSCRIPT_OUT_OF_RANGE
 409+ 51CC              	; comma
 410+ 51CC CD C4 56     	CALL CHKCHAR
 411+ 51CF 2C           	DB ','
 412+ 51D0              	; get size
 413+ 51D0 DD 21 1C 52  	LD IX, GETBYT
 414+ 51D4 CD 59 01     	CALL CALBAS
 415+ 51D7 FE 10            CP 16
 416+ 51D9 D2 DE 56         JP NC, OVERFLOW
 417+ 51DC B7               OR A
 418+ 51DD CA DE 56         JP Z, OVERFLOW
 419+ 51E0 F5           	PUSH AF
 420+ 51E1              	; comma
 421+ 51E1 CD C4 56     	CALL CHKCHAR
 422+ 51E4 2C           	DB ','
 423+ 51E5              	; get pointer to a list of animation items in integer array format
 424+ 51E5                  ; get array pointer
 425+ 51E5 D1               POP DE
 426+ 51E6 D5               PUSH DE
 427+ 51E7 15               DEC D
 428+ 51E8 1E 00            LD E,0
 429+ 51EA 3E 02            LD A,2
 430+ 51EC 06 01            LD B,1
 431+ 51EE CD EB 56         CALL GET_BASIC_ARRAY_DATA_POINTER
 432+ 51F1 C5               PUSH BC
 433+ 51F2              	; ending )
 434+ 51F2 CD C4 56     	CALL CHKCHAR
 435+ 51F5 29           	DB ')'
 436+ 51F6              .ENTRY:
 437+ 51F6 E5               PUSH HL
 438+ 51F7 DD E1            POP IX
 439+ 51F9 D1               POP DE ; pointer to INT array
 440+ 51FA C1               POP BC ; B=item number
 441+ 51FB F1               POP AF ; id
 442+ 51FC D5               PUSH DE
 443+ 51FD CD E8 4F         CALL GETnthANIMDEF
 444+ 5200 D1               POP DE
 445+ 5201 70               LD (HL),B
 446+ 5202              .L1:
 447+ 5202 23               INC HL
 448+ 5203 1A               LD A,(DE)
 449+ 5204 13          > INC DE
 449+ 5205 13          > INC DE
 450+ 5206 77               LD (HL),A
 451+ 5207 10 F9            DJNZ .L1
 452+ 5209 DD E5            PUSH IX
 453+ 520B E1               POP HL
 454+ 520C C9               RET
 455+ 520D              ; *******************************************************************************************************
 456+ 520D
 457+ 520D              ; *******************************************************************************************************
 458+ 520D              ; function to handle CALL MAXANIMSPRS basic extension
 459+ 520D              ; MAXANIMSPRS (BYTE number)
 460+ 520D              ; sets new number and moves memory buffers as needed
 461+ 520D              MAXANIMSPRS:
 462+ 520D              	; opening (
 463+ 520D CD C4 56     	CALL CHKCHAR
 464+ 5210 28           	DB '('
 465+ 5211              	; get value
 466+ 5211 DD 21 1C 52  	LD IX, GETBYT
 467+ 5215 CD 59 01     	CALL CALBAS
 468+ 5218 F5               PUSH AF
 469+ 5219              	; ending )
 470+ 5219 CD C4 56     	CALL CHKCHAR
 471+ 521C 29           	DB ')'
 472+ 521D F1               POP AF
 473+ 521E
 474+ 521E              	; save position
 475+ 521E E5           	PUSH HL
 476+ 521F              .ENTRY:
 477+ 521F 47               LD B,A
 478+ 5220 3A D3 4F         LD A,(ANIMSPRNUM)
 479+ 5223 90               SUB B
 480+ 5224 CA 38 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 481+ 5227 FD 21 10 40      LD IY,FREEMEMPTR
 482+ 522B FA 37 52         JP M, .INCREASE
 483+ 522E                  ; new value is lower than previous one
 484+ 522E CD 56 52         CALL .SIZEDIFF
 485+ 5231 CD 6E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 486+ 5234 C3 38 50         JP MAXANIMITEMS.EXIT
 487+ 5237              .INCREASE:
 488+ 5237 ED 44            NEG
 489+ 5239 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 490+ 523A CD 56 52         CALL .SIZEDIFF
 491+ 523D CD 9A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 492+ 5240 AF               XOR A
 493+ 5241 ED 42            SBC HL,BC ; location of new stuff
 494+ 5243 F1               POP AF
 495+ 5244 47               LD B,A
 496+ 5245 11 08 00         LD DE,8
 497+ 5248 E5               PUSH HL
 498+ 5249 DD E1            POP IX
 499+ 524B              .L1:
 500+ 524B DD 36 06 00      LD (IX+6),0
 501+ 524F DD 19            ADD IX,DE
 502+ 5251 10 F8            DJNZ .L1
 503+ 5253 C3 38 50         JP MAXANIMITEMS.EXIT
 504+ 5256              .SIZEDIFF:
 505+ 5256 26 00            LD H,0
 506+ 5258 6F               LD L,A
 507+ 5259 CD B3 55         CALL HLx8
 508+ 525C 78               LD A,B
 509+ 525D 32 D3 4F         LD (ANIMSPRNUM),A
 510+ 5260 44               LD B,H
 511+ 5261 4D               LD C,L
 512+ 5262 C9               RET ; BC=size difference in bytes
 513+ 5263              ; *******************************************************************************************************
 514+ 5263
 515+ 5263              ; *******************************************************************************************************
 516+ 5263              ; function to handle CALL ANIMSPRITE basic extension
 517+ 5263              ; ANIMSPRITE ( BYTE id,
 518+ 5263              ;              BYTE sprite_number,
 519+ 5263              ;              BYTE animation_definition_id,
 520+ 5263              ;              BYTE cyclic_flag )
 521+ 5263              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 522+ 5263              ANIMSPRITE:
 523+ 5263                  ; opening (
 524+ 5263 CD C4 56     	CALL CHKCHAR
 525+ 5266 28           	DB '('
 526+ 5267              	; get sprite animation id
 527+ 5267 DD 21 1C 52  	LD IX, GETBYT
 528+ 526B CD 59 01     	CALL CALBAS
 529+ 526E F5               PUSH AF
 530+ 526F 3C               INC A
 531+ 5270 4F               LD C,A
 532+ 5271 3A D3 4F         LD A,(ANIMSPRNUM)
 533+ 5274 B9               CP C
 534+ 5275 DA DA 56         JP C,SUBSCRIPT_OUT_OF_RANGE
 535+ 5278              	; comma
 536+ 5278 CD C4 56     	CALL CHKCHAR
 537+ 527B 2C           	DB ','
 538+ 527C              	; get sprite number
 539+ 527C DD 21 1C 52  	LD IX, GETBYT
 540+ 5280 CD 59 01     	CALL CALBAS
 541+ 5283 F5               PUSH AF
 542+ 5284                  ; check if out of bounds
 543+ 5284 FE 20            CP 32
 544+ 5286 D2 DA 56         JP NC, SUBSCRIPT_OUT_OF_RANGE
 545+ 5289              	; comma
 546+ 5289 CD C4 56     	CALL CHKCHAR
 547+ 528C 2C           	DB ','
 548+ 528D              	; get animation definition id
 549+ 528D DD 21 1C 52  	LD IX, GETBYT
 550+ 5291 CD 59 01     	CALL CALBAS
 551+ 5294 F5               PUSH AF
 552+ 5295 3C               INC A
 553+ 5296 4F               LD C,A
 554+ 5297 3A D0 4F         LD A,(ANIMDEFNUM)
 555+ 529A B9               CP C
 556+ 529B DA DA 56         JP C,SUBSCRIPT_OUT_OF_RANGE
 557+ 529E              	; comma
 558+ 529E CD C4 56     	CALL CHKCHAR
 559+ 52A1 2C           	DB ','
 560+ 52A2              	; get cyclic flag
 561+ 52A2 DD 21 1C 52  	LD IX, GETBYT
 562+ 52A6 CD 59 01         CALL CALBAS
 563+ 52A9 F5           	PUSH AF
 564+ 52AA              	; ending )
 565+ 52AA CD C4 56     	CALL CHKCHAR
 566+ 52AD 29           	DB ')'
 567+ 52AE              .ENTRY:
 568+ 52AE E5               PUSH HL
 569+ 52AF DD E1            POP IX
 570+ 52B1 D9               EXX
 571+ 52B2 D1               POP DE ; cyclic
 572+ 52B3 C1               POP BC ; animation definition id
 573+ 52B4 E1               POP HL ; sprite number
 574+ 52B5 D9               EXX
 575+ 52B6 F1               POP AF ; sprite animation id
 576+ 52B7 CD F4 4F         CALL GETnthSPRANIM
 577+ 52BA E5               PUSH HL
 578+ 52BB FD E1            POP IY
 579+ 52BD D9               EXX
 580+ 52BE FD 74 00         LD (IY),H
 581+ 52C1 FD 70 04         LD (IY+4),B
 582+ 52C4 FD 72 05         LD (IY+5),D
 583+ 52C7                  ;LD (IY+6),0
 584+ 52C7 DD E5            PUSH IX
 585+ 52C9 E1               POP HL
 586+ 52CA C9               RET
 587+ 52CB              ; *******************************************************************************************************
 588+ 52CB
 589+ 52CB              ; *******************************************************************************************************
 590+ 52CB              ; function to handle CALL ANIMSTART basic extension
 591+ 52CB              ; two forms
 592+ 52CB              ; ANIMSTART ( BYTE id )
 593+ 52CB              ; or
 594+ 52CB              ; ANIMSTART ( BYTE item_number,
 595+ 52CB              ;             INT[] sprite_animations )
 596+ 52CB              ; sets active flag to 1
 597+ 52CB              ANIMSTART:
 598+ 52CB 3E 01            LD A,1
 599+ 52CD 18 01            JR ANIMSTARTSTOP_COMMON
 600+ 52CF              ; *******************************************************************************************************
 601+ 52CF              ; *******************************************************************************************************
 602+ 52CF              ; function to handle CALL ANIMSTOP basic extension
 603+ 52CF              ; two forms
 604+ 52CF              ; ANIMSTOP ( BYTE id )
 605+ 52CF              ; or
 606+ 52CF              ; ANIMSTOP ( BYTE item_number,
 607+ 52CF              ;            INT[] sprite_animations )
 608+ 52CF              ; sets active flag to 1
 609+ 52CF              ANIMSTOP:
 610+ 52CF AF               XOR A
 611+ 52D0              ANIMSTARTSTOP_COMMON:
 612+ 52D0 32 30 53         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
 613+ 52D3              ; *******************************************************************************************************
 614+ 52D3                  ; opening (
 615+ 52D3 CD C4 56     	CALL CHKCHAR
 616+ 52D6 28           	DB '('
 617+ 52D7              	; get sprite animation id or array size
 618+ 52D7 DD 21 1C 52  	LD IX,GETBYT
 619+ 52DB CD 59 01     	CALL CALBAS
 620+ 52DE F5               PUSH AF
 621+ 52DF                  ; check if comma present
 622+ 52DF CD CE 56         CALL GETPREVCHAR
 623+ 52E2 23               INC HL
 624+ 52E3 FE 2C            CP ','
 625+ 52E5 28 0C            JR Z,.L1
 626+ 52E7 FE 29            CP ')'
 627+ 52E9 C2 E2 56         JP NZ,SYNTAX_ERROR
 628+ 52EC                  ; ok so single argument variant
 629+ 52EC F1               POP AF
 630+ 52ED E5               PUSH HL
 631+ 52EE CD 1C 53         CALL .SETVALUE
 632+ 52F1 E1               POP HL
 633+ 52F2 C9               RET
 634+ 52F3              .L1:
 635+ 52F3                  ; get array pointer
 636+ 52F3 D1               POP DE
 637+ 52F4 D5               PUSH DE
 638+ 52F5 15               DEC D
 639+ 52F6 1E 00            LD E,0
 640+ 52F8 3E 02            LD A,2
 641+ 52FA 06 01            LD B,1
 642+ 52FC CD EB 56         CALL GET_BASIC_ARRAY_DATA_POINTER
 643+ 52FF C5               PUSH BC
 644+ 5300              	; ending )
 645+ 5300 CD C4 56     	CALL CHKCHAR
 646+ 5303 29           	DB ')'
 647+ 5304 D1               POP DE ; array pointer
 648+ 5305 C1               POP BC ; number of items
 649+ 5306 78               LD A,B
 650+ 5307 B7               OR A
 651+ 5308 CA DA 56         JP Z,SUBSCRIPT_OUT_OF_RANGE
 652+ 530B E5               PUSH HL
 653+ 530C F3               DI
 654+ 530D              .L2:
 655+ 530D C5               PUSH BC
 656+ 530E 1A               LD A,(DE)
 657+ 530F 13          > INC DE
 657+ 5310 13          > INC DE
 658+ 5311 D5               PUSH DE
 659+ 5312 CD 1C 53         CALL .SETVALUE
 660+ 5315 D1               POP DE
 661+ 5316 C1               POP BC
 662+ 5317 10 F4            DJNZ .L2
 663+ 5319 FB               EI
 664+ 531A E1               POP HL
 665+ 531B C9               RET
 666+ 531C
 667+ 531C              .SETVALUE:
 668+ 531C 47               LD B,A
 669+ 531D 3C               INC A
 670+ 531E 4F               LD C,A
 671+ 531F 3A D3 4F         LD A,(ANIMSPRNUM)
 672+ 5322 B9               CP C
 673+ 5323 DA DA 56         JP C,SUBSCRIPT_OUT_OF_RANGE
 674+ 5326 78               LD A,B
 675+ 5327 CD F4 4F         CALL GETnthSPRANIM
 676+ 532A E5               PUSH HL
 677+ 532B DD E1            POP IX
 678+ 532D              .VALUE:
 679+ 532D DD 36 06 01      LD (IX+6),1 ; active flag
 680+ 5331 3A 30 53         LD A,(.VALUE+3)
 681+ 5334 B7               OR A
 682+ 5335 C8               RET Z
 683+ 5336 DD 36 03 00      LD (IX+3),0 ; current item
 684+ 533A C3 AB 53         JP SETUP_ANIM_STEP
 685+ 533D              ; *******************************************************************************************************
 686+ 533D
 687+ 533D              ; *******************************************************************************************************
 688+ 533D              ; function processes animations during vblank period
 689+ 533D              PROCESS_ANIMATIONS:
 690+ 533D 3A D3 4F         LD A,(ANIMSPRNUM)
 691+ 5340 B7               OR A
 692+ 5341 C8               RET Z; no animations defined
 693+ 5342 47               LD B,A
 694+ 5343 DD 2A D4 4F      LD IX,(ANIMSPRPTR)
 695+ 5347              .L1:
 696+ 5347 C5               PUSH BC
 697+ 5348 DD 7E 06         LD A,(IX+6); active
 698+ 534B B7               OR A
 699+ 534C 28 16            JR Z,.SKIP ; inactive animation
 700+ 534E DD 6E 01         LD L,(IX+1)
 701+ 5351 DD 66 02         LD H,(IX+2) ; HL=end time
 702+ 5354 ED 5B 9E FC      LD DE,(JIFFY)
 703+ 5358 AF               XOR A
 704+ 5359 ED 52            SBC HL,DE
 705+ 535B F2 64 53         JP P,.SKIP ; time until next animation item not yet reached
 706+ 535E DD 34 03         INC (IX+3) ; current animation item
 707+ 5361 CD AB 53         CALL SETUP_ANIM_STEP
 708+ 5364              .SKIP:
 709+ 5364 11 08 00         LD DE,8
 710+ 5367 DD 19            ADD IX,DE
 711+ 5369 C1               POP BC
 712+ 536A 10 DB            DJNZ .L1
 713+ 536C C9               RET
 714+ 536D              ; *******************************************************************************************************
 715+ 536D
 716+ 536D              ; *******************************************************************************************************
 717+ 536D              ; function will setup sprite animation after current item change
 718+ 536D              ; input A=current animation definition
 719+ 536D              ; input IX=pointer to sprite animation
 720+ 536D              ; output IY=pointer to animation item
 721+ 536D              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
 722+ 536D              ; basically sets new end time for current animation
 723+ 536D              INIT_CURRENT_ANIMATION:
 724+ 536D CD E8 4F         CALL GETnthANIMDEF
 725+ 5370 7E               LD A,(HL); number of animation items in the animation definition
 726+ 5371 DD BE 03         CP (IX+3) ; current animation item
 727+ 5374 20 0A            JR NZ,.L3 ; last item not reached
 728+ 5376                  ; last item reached
 729+ 5376 DD 7E 05         LD A,(IX+5) ; cyclic flag
 730+ 5379 B7               OR A
 731+ 537A 28 2D            JR Z,.ERROR ; non-cyclic animation
 732+ 537C                  ; cyclic animation, restart
 733+ 537C DD 36 03 00      LD (IX+3),0; current item
 734+ 5380              .L3:
 735+ 5380                  ; HL = animation definition
 736+ 5380 23               INC HL ; skip animation definition size field
 737+ 5381 16 00            LD D,0
 738+ 5383 DD 5E 03         LD E,(IX+3); current item
 739+ 5386 19               ADD HL,DE
 740+ 5387 4E               LD C,(HL) ; current animation item
 741+ 5388 0C               INC C
 742+ 5389 3A CD 4F         LD A,(ANIMITEMNUM)
 743+ 538C B9               CP C
 744+ 538D 38 1A            JR C,.ERROR ; invalid animation item, stop animation
 745+ 538F 0D               DEC C
 746+ 5390 79               LD A,C
 747+ 5391 CD DF 4F         CALL GETnthANIMITEM
 748+ 5394 E5               PUSH HL
 749+ 5395 FD E1            POP IY ; IY=animation item
 750+ 5397 2A 9E FC         LD HL,(JIFFY)
 751+ 539A FD 5E 01         LD E,(IY+1)
 752+ 539D FD 56 02         LD D,(IY+2) ; duration
 753+ 53A0 19               ADD HL,DE
 754+ 53A1 DD 75 01         LD (IX+1),L
 755+ 53A4 DD 74 02         LD (IX+2),H ; end time for current item
 756+ 53A7              .EXIT:
 757+ 53A7 AF               XOR A
 758+ 53A8 C9               RET
 759+ 53A9              .ERROR:
 760+ 53A9 37               SCF
 761+ 53AA C9               RET
 762+ 53AB              ; *******************************************************************************************************
 763+ 53AB
 764+ 53AB              ; *******************************************************************************************************
 765+ 53AB              ; function will display currect item and set up expiry time
 766+ 53AB              ; it will also stop the animation if expired
 767+ 53AB              ; sets sprite update flag if any changes in sprite data made
 768+ 53AB              ; input IX=current sprite animation
 769+ 53AB              SETUP_ANIM_STEP:
 770+ 53AB DD 4E 04         LD C,(IX+4) ; animation definition ID
 771+ 53AE 0C               INC C
 772+ 53AF 3A D0 4F         LD A,(ANIMDEFNUM)
 773+ 53B2 B9               CP C
 774+ 53B3 30 05            JR NC,.L2
 775+ 53B5                  ; given animation item is outside of bounds, deactivate animation
 776+ 53B5              .STOPANIM:
 777+ 53B5 DD 36 06 00      LD (IX+6),0
 778+ 53B9 C9               RET
 779+ 53BA              .L2:
 780+ 53BA 0D               DEC C
 781+ 53BB 79               LD A,C
 782+ 53BC CD 6D 53         CALL INIT_CURRENT_ANIMATION
 783+ 53BF 38 F4            JR C, .STOPANIM
 784+ 53C1 FD 7E 00         LD A,(IY) ; type of animation item
 785+ 53C4 B7               OR A
 786+ 53C5 CA FA 53         JP Z,.L4 ; change pattern and/or color
 787+ 53C8              .PAT:
 788+ 53C8                  ; change sprite pattern definition
 789+ 53C8 DD 7E 00         LD A,(IX) ; sprite number
 790+ 53CB CD 86 4D         CALL GETnthSPRATTR
 791+ 53CE 23          > INC HL ; skip y and x
 791+ 53CF 23          > INC HL
 791+ 53D0 23          > INC HL
 791+ 53D1 23          > INC HL
 792+ 53D2 7E               LD A,(HL); current pattern
 793+ 53D3 26 00            LD H,0
 794+ 53D5 6F               LD L,A
 795+ 53D6 3A E0 F3         LD A,(REG1SAV)
 796+ 53D9 E6 02            AND 2
 797+ 53DB 20 07            JR NZ,.L6
 798+ 53DD                  ; 8x8 sprite
 799+ 53DD CD B3 55         CALL HLx8
 800+ 53E0 06 08            LD B,8
 801+ 53E2 18 05            JR .L5
 802+ 53E4              .L6:
 803+ 53E4 CD B1 55         CALL HLx32
 804+ 53E7 06 20            LD B,32
 805+ 53E9              .L5:
 806+ 53E9 ED 5B 26 F9      LD DE,(PATBAS)
 807+ 53ED 19               ADD HL,DE
 808+ 53EE CD 9E 55         CALL SETWRT_LOCAL
 809+ 53F1 FD 6E 03         LD L,(IY+3)
 810+ 53F4 FD 66 04         LD H,(IY+4) ; pointer to sprite patter data
 811+ 53F7 C3 A9 55         JP BBYTECOPY
 812+ 53FA              .L4:
 813+ 53FA                  ; change pattern and color in sprite attributes table
 814+ 53FA DD 7E 00         LD A,(IX) ; sprite number
 815+ 53FD CD 86 4D         CALL GETnthSPRATTR
 816+ 5400 23          > INC HL ; skip y and x
 816+ 5401 23          > INC HL
 816+ 5402 23          > INC HL
 816+ 5403 23          > INC HL
 817+ 5404 FD 7E 03         LD A,(IY+3) ; new pattern
 818+ 5407 77               LD (HL),A
 819+ 5408 23          > INC HL
 819+ 5409 23          > INC HL
 820+ 540A FD 7E 04         LD A,(IY+4) ; new color
 821+ 540D 77               LD (HL),A
 822+ 540E 2A 7E 4D         LD HL,(SPRATR_UPDATE_FLAG)
 823+ 5411 36 01            LD (HL),1
 824+ 5413 C9               RET
 825+ 5414              ; *******************************************************************************************************
 826+ 5414
# file closed: asm\ANIMATION.asm
 129  5414               ENDIF
 130  5414
 131  5414              ; temp variables for BLIT, TILE functions
 132  5414               IF (BLIT_CMDS + TILE_CMDS > 0)
 133  5414              BLIT_TMP:
 134  5414              TILETMP1:
 135  5414              BLIT_TMP1:
 136  5414 00 00         DW 0
 137  5416              TILETMP2:
 138  5416              BLIT_TMP2:
 139  5416 00 00         DW 0
 140  5418                IFDEF CMDS_WITH_PARAMETERS
 141  5418              BLIT_STRUCT:
 142  5418 00 00 00...   DS 17
 143  541C                ENDIF
 144  541C               ENDIF
 145  5429
 146  5429               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS > 0)
 147  5429              VRAM_UPDATE_IN_PROGRESS:
 148  5429 00            DB 0
 149  542A               ENDIF
 150  542A
 151  542A              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 152  542A              ; per starting letter, if no commands with this letter, NULL value
 153  542A              CMDS:
 154  542A               IF (ANIM_CMDS == 1)
 155  542A 53 55        	DW CMDS_A ;
 156  542C               ELSE
 157  542C ~                DW 0 ; A
 158  542C               ENDIF
 159  542C               IF (BLIT_CMDS + BOX_CMDS > 0)
 160  542C 1E 55            DW CMDS_B ; B
 161  542E               ELSE
 162  542E ~            	DW 0
 163  542E               ENDIF
 164  542E 00 00            DW 0 ; C
 165  5430 00 00            DW 0 ; D
 166  5432 00 00            DW 0 ; E
 167  5434               IF (VRAM_CMDS + RAM_CMDS > 0)
 168  5434 9C 54            DW CMDS_F; F
 169  5436               ELSE
 170  5436 ~            	DW 0
 171  5436               ENDIF
 172  5436               IF (GENCAL_CMD > 0)
 173  5436 AF 54            DW CMDS_G; G
 174  5438               ELSE
 175  5438 ~            	DW 0
 176  5438               ENDIF
 177  5438 00 00            DW 0 ; H
 178  543A 00 00            DW 0 ; I
 179  543C 00 00            DW 0 ; J
 180  543E 00 00            DW 0 ; K
 181  5440 00 00            DW 0 ; L
 182  5442               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 183  5442 5E 54            DW CMDS_M ; M
 184  5444               ELSE
 185  5444 ~            	DW 0
 186  5444               ENDIF
 187  5444 00 00            DW 0 ; N
 188  5446 00 00            DW 0 ; O
 189  5448 00 00            DW 0 ; P
 190  544A 00 00            DW 0 ; Q
 191  544C 00 00            DW 0 ; R
 192  544E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 193  544E C3 54            DW CMDS_S ; S
 194  5450               ELSE
 195  5450 ~            	DW 0
 196  5450               ENDIF
 197  5450               IF (TILE_CMDS > 0)
 198  5450 3E 55            DW CMDS_T ; T
 199  5452               ELSE
 200  5452 ~            	DW 0
 201  5452               ENDIF
 202  5452 00 00            DW 0 ; U
 203  5454               IF (VRAM_CMDS > 0)
 204  5454 B9 54            DW CMDS_V ; V
 205  5456               ELSE
 206  5456 ~            	DW 0
 207  5456               ENDIF
 208  5456 00 00            DW 0 ; W
 209  5458 00 00            DW 0 ; X
 210  545A 00 00            DW 0 ; Y
 211  545C 00 00            DW 0 ; Z
 212  545E
 213  545E              CMDS_M:
 214  545E               IF (VRAM_CMDS == 1)
 215  545E 4D 45 4D 56      DB "MEMVRM", 0
 215  5462 52 4D 00
 216  5465 65 58            DW MEMVRM
 217  5467               ENDIF
 218  5467               IF (RAM_CMDS == 1)
 219  5467 4D 45 4D 43  	DB "MEMCPY", 0
 219  546B 50 59 00
 220  546E 1B 57        	DW MEMCPY
 221  5470               ENDIF
 222  5470               IF (ANIM_CMDS == 1)
 223  5470 4D 41 58 41  	DB "MAXANIMITEMS",0
 223  5474 4E 49 4D 49
 223  5478 54 45 4D 53
 223  547C 00
 224  547D 00 50        	DW MAXANIMITEMS
 225  547F 4D 41 58 41  	DB "MAXANIMDEFS",0
 225  5483 4E 49 4D 44
 225  5487 45 46 53 00
 226  548B 75 51        	DW MAXANIMDEFS
 227  548D 4D 41 58 41  	DB "MAXANIMSPRS",0
 227  5491 4E 49 4D 53
 227  5495 50 52 53 00
 228  5499 0D 52        	DW MAXANIMSPRS
 229  549B               ENDIF
 230  549B               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 231  549B 00           	DB 0
 232  549C               ENDIF
 233  549C              CMDS_F:
 234  549C               IF (VRAM_CMDS == 1)
 235  549C 46 49 4C 56      DB "FILVRM", 0
 235  54A0 52 4D 00
 236  54A3 5E 57            DW FILVRM
 237  54A5               ENDIF
 238  54A5               IF (RAM_CMDS == 1)
 239  54A5 46 49 4C 52      DB "FILRAM", 0
 239  54A9 41 4D 00
 240  54AC AE 57            DW FILRAM
 241  54AE               ENDIF
 242  54AE               IF (VRAM_CMDS + RAM_CMDS > 0)
 243  54AE 00               DB 0
 244  54AF               ENDIF
 245  54AF              CMDS_G:
 246  54AF               IF (GENCAL_CMD == 1)
 247  54AF 47 45 4E 43      DB "GENCAL", 0
 247  54B3 41 4C 00
 248  54B6 0C 58            DW GENCAL
 249  54B8               ENDIF
 250  54B8               IF (GENCAL_CMD > 0)
 251  54B8 00           	DB	0
 252  54B9               ENDIF
 253  54B9              CMDS_V:
 254  54B9               IF (VRAM_CMDS == 1)
 255  54B9 56 52 4D 4D  	DB "VRMMEM", 0
 255  54BD 45 4D 00
 256  54C0 E4 58        	DW VRMMEM
 257  54C2               ENDIF
 258  54C2               IF (VRAM_CMDS > 0)
 259  54C2 00           	DB 0
 260  54C3               ENDIF
 261  54C3              CMDS_S:
 262  54C3               IF (SPRITE_CMDS == 1)
 263  54C3 53 50 52 53  	DB "SPRSET", 0
 263  54C7 45 54 00
 264  54CA 9B 4E        	DW SPRSET
 265  54CC 53 50 52 47  	DB "SPRGRPMOV", 0
 265  54D0 52 50 4D 4F
 265  54D4 56 00
 266  54D6 4C 4F        	DW SPRGRPMOV
 267  54D8               ENDIF
 268  54D8               IF (SOUND_CMDS == 1)
 269  54D8 53 4E 44 53  	DB "SNDSFX", 0
 269  54DC 46 58 00
 270  54DF C5 59        	DW SNDSFX
 271  54E1 53 4E 44 50  	DB "SNDPLYON", 0
 271  54E5 4C 59 4F 4E
 271  54E9 00
 272  54EA 8F 59        	DW SNDPLYON
 273  54EC 53 4E 44 50  	DB "SNDPLYOFF", 0
 273  54F0 4C 59 4F 46
 273  54F4 46 00
 274  54F6 A2 59        	DW SNDPLYOFF
 275  54F8 53 4E 44 50  	DB "SNDPLYINI", 0
 275  54FC 4C 59 49 4E
 275  5500 49 00
 276  5502 45 59        	DW SNDPLYINIT
 277  5504               ENDIF
 278  5504               IF (SPRITE_CMDS == 1)
 279  5504 53 50 52 45  	DB "SPRENABLE", 0
 279  5508 4E 41 42 4C
 279  550C 45 00
 280  550E 46 4E        	DW SPRENABLE
 281  5510 53 50 52 44  	DB "SPRDISABLE", 0
 281  5514 49 53 41 42
 281  5518 4C 45 00
 282  551B 96 4E        	DW SPRDISABLE
 283  551D               ENDIF
 284  551D               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 285  551D 00           	DB 0
 286  551E               ENDIF
 287  551E              CMDS_B:
 288  551E               IF (BLIT_CMDS == 1)
 289  551E 42 4C 49 54  	DB "BLIT", 0
 289  5522 00
 290  5523 9C 5B        	DW BLIT
 291  5525               ENDIF
 292  5525               IF (BOX_CMDS == 1)
 293  5525 42 4F 58 4D  	DB "BOXMEMCPY", 0
 293  5529 45 4D 43 50
 293  552D 59 00
 294  552F D4 5E        	DW BOXMEMCPY
 295  5531 42 4F 58 4D  	DB "BOXMEMVRM", 0
 295  5535 45 4D 56 52
 295  5539 4D 00
 296  553B 08 5F        	DW BOXMEMVRM
 297  553D               ENDIF
 298  553D               IF (BLIT_CMDS + BOX_CMDS > 0)
 299  553D 00           	DB 0
 300  553E               ENDIF
 301  553E              CMDS_T:
 302  553E               IF (TILE_CMDS == 1)
 303  553E 54 49 4C 45  	DB "TILERAM", 0
 303  5542 52 41 4D 00
 304  5546 E0 5C        	DW TILERAM
 305  5548 54 49 4C 45  	DB "TILEVRM", 0
 305  554C 56 52 4D 00
 306  5550 E3 5D        	DW TILEVRM
 307  5552               ENDIF
 308  5552               IF (TILE_CMDS > 0)
 309  5552 00           	DB 0
 310  5553               ENDIF
 311  5553              CMDS_A:
 312  5553               IF (ANIM_CMDS == 1)
 313  5553 41 4E 49 4D  	DB "ANIMSTART",0
 313  5557 53 54 41 52
 313  555B 54 00
 314  555D CB 52        	DW ANIMSTART
 315  555F 41 4E 49 4D  	DB "ANIMSTOP",0
 315  5563 53 54 4F 50
 315  5567 00
 316  5568 CF 52        	DW ANIMSTOP
 317  556A 41 4E 49 4D  	DB "ANIMITEMPAT",0
 317  556E 49 54 45 4D
 317  5572 50 41 54 00
 318  5576 C0 50        	DW ANIMITEMPAT
 319  5578 41 4E 49 4D  	DB "ANIMITEMPTR",0
 319  557C 49 54 45 4D
 319  5580 50 54 52 00
 320  5584 21 51        	DW ANIMITEMPTR_CMD
 321  5586 41 4E 49 4D  	DB "ANIMDEF",0
 321  558A 44 45 46 00
 322  558E B7 51        	DW ANIMDEF
 323  5590 41 4E 49 4D  	DB "ANIMSPRITE",0
 323  5594 53 50 52 49
 323  5598 54 45 00
 324  559B 63 52        	DW ANIMSPRITE
 325  559D 00           	DB 0
 326  559E               ENDIF
 327  559E
 328  559E               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 329  559E              ; ****************************************************************************************************
 330  559E              ; function sets VRAM address
 331  559E              ; input HL=address
 332  559E              ; modifies AF
 333  559E              SETWRT_LOCAL:
 334  559E 7D           	LD	A, L
 335  559F D3 99        	OUT	(099H), A
 336  55A1 7C           	LD	A, H
 337  55A2 E6 3F        	AND	03FH
 338  55A4 F6 40        	OR	040H
 339  55A6 D3 99        	OUT	(099H), A
 340  55A8 C9           	RET
 341  55A9              ; ****************************************************************************************************
 342  55A9               ENDIF
 343  55A9
 344  55A9               IF (VRAM_CMDS + TILE_CMDS > 0)
 345  55A9              ; ****************************************************************************************************
 346  55A9              ; function copies data from RAM to VRAM
 347  55A9              ; input HL=address in RAM
 348  55A9              ; input B=count
 349  55A9              ; modifies AF, BC, HL
 350  55A9              BBYTECOPY:
 351  55A9 0E 98        	LD C,#98
 352  55AB              BBYTECOPY_NO_C:
 353  55AB ED A3        	OUTI
 354  55AD C2 AB 55     	JP	NZ, BBYTECOPY_NO_C
 355  55B0 C9           	RET
 356  55B1              ; ****************************************************************************************************
 357  55B1               ENDIF
 358  55B1
 359  55B1              ; ****************************************************************************************************
 360  55B1              ; function multiplies HL by 32
 361  55B1              HLx32:
 362  55B1 29           	ADD HL,HL
 363  55B2              ; ****************************************************************************************************
 364  55B2              ; function multiplies HL by 16
 365  55B2              HLx16:
 366  55B2 29           	ADD HL,HL
 367  55B3              ; ****************************************************************************************************
 368  55B3              ; function multiplies HL by 8
 369  55B3              HLx8:
 370  55B3 29          > ADD HL, HL
 370  55B4 29          > ADD HL, HL
 370  55B5 29          > ADD HL, HL
 371  55B6 C9           	RET
 372  55B7              ; ****************************************************************************************************
 373  55B7
 374  55B7              ; ****************************************************************************************************
 375  55B7              ; function gets slot and subslot data for specific page
 376  55B7              ; input A=page (0, 1 or 2)
 377  55B7              ; output B = 0A8H register value
 378  55B7              ; output D = 0 is no subslots, 1 if yes
 379  55B7              ; output C = 0A8H value when page 3 slot equals to requested page slot
 380  55B7              ; output E = subslot value if present
 381  55B7              ; modifies AF, BC, DE, HL
 382  55B7              GET_PAGE_INFO:
 383  55B7 6F               LD L, A
 384  55B8 C6 C1            ADD A, low (EXPTBL)
 385  55BA 32 C4 55         LD (GET_PAGE_INFO_L1+1), A
 386  55BD DB A8            IN A, (0A8H)
 387  55BF 47               LD B, A
 388  55C0 E6 3F            AND 03FH
 389  55C2 4F               LD C, A
 390  55C3              GET_PAGE_INFO_L1:
 391  55C3 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 392  55C6 E6 80            AND 080H
 393  55C8 28 1B            JR Z, GET_PAGE_INFO_L2
 394  55CA                  ; expanded
 395  55CA 2D               DEC L
 396  55CB FA EA 55         JP M, GET_PAGE_INFO_L3
 397  55CE 2D               DEC L
 398  55CF FA E8 55         JP M, GET_PAGE_INFO_L4
 399  55D2                  ; page 2
 400  55D2 07               RLCA
 401  55D3 07               RLCA
 402  55D4              GET_PAGE_INFO_L5:
 403  55D4 E6 C0            AND 0C0H
 404  55D6 B1               OR C
 405  55D7 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 406  55D9 4F               LD C, A
 407  55DA 3A FF FF         LD A, (0FFFFH)
 408  55DD 2F               CPL
 409  55DE 5F               LD E, A
 410  55DF 16 01            LD D, 1
 411  55E1 78               LD A, B ; return stack
 412  55E2 D3 A8            OUT (0A8H), A
 413  55E4 C9               RET
 414  55E5              GET_PAGE_INFO_L2:
 415  55E5                  ; not expanded
 416  55E5 16 00            LD D, 0
 417  55E7 C9               RET
 418  55E8              GET_PAGE_INFO_L4:
 419  55E8                  ; page 1
 420  55E8 0F               RRCA
 421  55E9 0F               RRCA
 422  55EA              GET_PAGE_INFO_L3:
 423  55EA                  ; page 0
 424  55EA 0F               RRCA
 425  55EB 0F               RRCA
 426  55EC 18 E6            JR GET_PAGE_INFO_L5
 427  55EE              ; ****************************************************************************************************
 428  55EE
 429  55EE              ; ****************************************************************************************************
 430  55EE              ; function returns original slot and subslot info
 431  55EE              ; input B = 0A8H register value
 432  55EE              ; input D = 0 is no subslots, 1 if yes
 433  55EE              ; input C = 0A8H value when page 3 slot equals to requested page slot
 434  55EE              ; input E = subslot value if present
 435  55EE              ; modifies AF, disables interrupts
 436  55EE              RESTORE_PAGE_INFO:
 437  55EE 7A               LD A, D
 438  55EF B7               OR A
 439  55F0 28 08            JR Z, RESTORE_PAGE_INFO_L1
 440  55F2 79               LD A, C
 441  55F3 F3           	DI
 442  55F4 D3 A8            OUT (0A8H), A
 443  55F6 7B               LD A, E
 444  55F7 32 FF FF         LD (0FFFFH), A
 445  55FA              RESTORE_PAGE_INFO_L1:
 446  55FA 78               LD A, B
 447  55FB D3 A8            OUT (0A8H), A
 448  55FD C9               RET
 449  55FE              ; ****************************************************************************************************
 450  55FE
 451  55FE              ; *******************************************************************************************************
 452  55FE              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 453  55FE              ; INPUT:  A = SLOT ID: EXXXSSPP
 454  55FE              ; E = EXPANDED FLAG
 455  55FE              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 456  55FE              ; PP = PRIMARY SLOT NUMBER
 457  55FE              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 458  55FE              ; CHANGES: AF, BC, DE
 459  55FE
 460  55FE              LOCAL_ENASLT:
 461  55FE CD 1E 56         CALL L0353
 462  5601 FA 0B 56         JP M, L0340
 463  5604 DB A8            IN A, (0A8H)
 464  5606 A1               AND C
 465  5607 B0               OR B
 466  5608 D3 A8            OUT (0A8H), A
 467  560A C9               RET
 468  560B              L0340:
 469  560B E5               PUSH HL
 470  560C CD 43 56         CALL L0378
 471  560F 4F               LD C, A
 472  5610 06 00            LD B, 0
 473  5612 7D               LD A, L
 474  5613 A4               AND H
 475  5614 B2               OR D
 476  5615 21 C5 FC         LD HL, 0FCC5H
 477  5618 09               ADD HL, BC
 478  5619 77               LD (HL), A
 479  561A E1               POP HL
 480  561B 79               LD A, C
 481  561C 18 E0            JR LOCAL_ENASLT
 482  561E              L0353:
 483  561E F3               DI
 484  561F F5               PUSH AF
 485  5620 7C               LD A, H
 486  5621 07               RLCA
 487  5622 07               RLCA
 488  5623 E6 03            AND 3
 489  5625 5F               LD E, A
 490  5626 3E C0            LD A, 0C0H
 491  5628              L035D:
 492  5628 07               RLCA
 493  5629 07               RLCA
 494  562A 1D               DEC E
 495  562B F2 28 56         JP P, L035D
 496  562E 5F               LD E, A
 497  562F 2F               CPL
 498  5630 4F               LD C, A
 499  5631 F1               POP AF
 500  5632 F5               PUSH AF
 501  5633 E6 03            AND 3
 502  5635 3C               INC A
 503  5636 47               LD B, A
 504  5637 3E AB            LD A, 0ABH
 505  5639              L036E:
 506  5639 C6 55            ADD A, 055H
 507  563B 10 FC            DJNZ L036E
 508  563D 57               LD D, A
 509  563E A3               AND E
 510  563F 47               LD B, A
 511  5640 F1               POP AF
 512  5641 A7               AND A
 513  5642 C9               RET
 514  5643              L0378:
 515  5643 F5               PUSH AF
 516  5644 7A               LD A, D
 517  5645 E6 C0            AND 0C0H
 518  5647 4F               LD C, A
 519  5648 F1               POP AF
 520  5649 F5               PUSH AF
 521  564A 57               LD D, A
 522  564B DB A8            IN A, (0A8H)
 523  564D 47               LD B, A
 524  564E E6 3F            AND 03FH
 525  5650 B1               OR C
 526  5651 D3 A8            OUT (0A8H), A
 527  5653 7A               LD A, D
 528  5654 0F               RRCA
 529  5655 0F               RRCA
 530  5656 E6 03            AND 3
 531  5658 57               LD D, A
 532  5659 3E AB            LD A, 0ABH
 533  565B              L0390:
 534  565B C6 55            ADD A, 055H
 535  565D 15               DEC D
 536  565E F2 5B 56         JP P, L0390
 537  5661 A3               AND E
 538  5662 57               LD D, A
 539  5663 7B               LD A, E
 540  5664 2F               CPL
 541  5665 67               LD H, A
 542  5666 3A FF FF         LD A, (0FFFFH)
 543  5669 2F               CPL
 544  566A 6F               LD L, A
 545  566B A4               AND H
 546  566C B2               OR D
 547  566D 32 FF FF         LD (0FFFFH), A
 548  5670 78               LD A, B
 549  5671 D3 A8            OUT (0A8H), A
 550  5673 F1               POP AF
 551  5674 E6 03            AND 3
 552  5676 C9               RET
 553  5677              ; *******************************************************************************************************
 554  5677
 555  5677              ; *******************************************************************************************************
 556  5677              ; some common code to activate page 0 and place values needed to restore original page on stack
 557  5677              ; input IY=return address
 558  5677              ENABLE_PAGE0:
 559  5677 AF               XOR A
 560  5678 CD B7 55         CALL GET_PAGE_INFO
 561  567B C5               PUSH BC
 562  567C D5               PUSH DE
 563  567D 3A 41 F3         LD A, (RAMAD0)
 564  5680 26 00            LD H, 0
 565  5682 CD FE 55         CALL LOCAL_ENASLT
 566  5685 FD E9        	JP (IY)
 567  5687              ; *******************************************************************************************************
 568  5687
 569  5687              ; General BASIC CALL-instruction handler
 570  5687              CALLHAND:
 571  5687 E5           	PUSH HL
 572  5688 21 2A 54     	LD	HL, CMDS ; pointer table based on starting letter
 573  568B 3A 89 FD         LD A, (PROCNM)
 574  568E D6 41            SUB 'A'
 575  5690 87               ADD A, A
 576  5691 16 00            LD D, 0
 577  5693 5F               LD E, A
 578  5694 19               ADD HL, DE
 579  5695 5E               LD E, (HL)
 580  5696 23               INC HL
 581  5697 56               LD D, (HL)
 582  5698 7A               LD A, D
 583  5699 B3               OR E
 584  569A 28 23            JR Z, .CMDNOTRECOGNIZED
 585  569C EB               EX DE, HL
 586  569D              .CHKCMD:
 587  569D 11 89 FD     	LD	DE, PROCNM
 588  56A0 1A           .LOOP:	LD	A,(DE)
 589  56A1 BE           	CP	(HL)
 590  56A2 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 591  56A4 13           	INC	DE
 592  56A5 23           	INC	HL
 593  56A6 A7           	AND	A
 594  56A7 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 595  56A9 5E           	LD	E,(HL)
 596  56AA 23           	INC	HL
 597  56AB 56           	LD	D,(HL)
 598  56AC E1           	POP	HL		; routine address
 599  56AD CD CE 56     	CALL	GETPREVCHAR
 600  56B0 CD C2 56     	CALL	.CALLDE		; Call routine
 601  56B3 A7           	AND	A
 602  56B4 C9           	RET
 603  56B5
 604  56B5              .TONEXTCMD:
 605  56B5 0E FF        	LD	C,0FFH
 606  56B7 AF           	XOR	A
 607  56B8 ED B1        	CPIR			; Skip to end of instruction name
 608  56BA 23           	INC	HL
 609  56BB 23           	INC	HL		; Skip address
 610  56BC BE           	CP	(HL)
 611  56BD 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 612  56BF              .CMDNOTRECOGNIZED:
 613  56BF E1           	POP	HL
 614  56C0 37               SCF
 615  56C1 C9           	RET
 616  56C2
 617  56C2              .CALLDE:
 618  56C2 D5           	PUSH	DE
 619  56C3 C9           	RET
 620  56C4
 621  56C4              ;---------------------------
 622  56C4
 623  56C4              ;GETSTRPNT:
 624  56C4              ; OUT:
 625  56C4              ; HL = String Address
 626  56C4              ; B  = Lenght
 627  56C4              ;        LD      HL,(USR)
 628  56C4              ;        LD      B,(HL)
 629  56C4              ;        INC     HL
 630  56C4              ;        LD      E,(HL)
 631  56C4              ;        INC     HL
 632  56C4              ;        LD      D,(HL)
 633  56C4              ;        EX      DE,HL
 634  56C4              ;        RET
 635  56C4
 636  56C4              ;EVALTXTPARAM:
 637  56C4              ;	CALL	CHKCHAR
 638  56C4              ;	DEFB	"("             ; Check for (
 639  56C4              ;	LD	IX,FRMEVL
 640  56C4              ;	CALL	CALBAS		; Evaluate expression
 641  56C4              ;       LD      A,(VALTYP)
 642  56C4              ;        CP      3               ; Text type?
 643  56C4              ;        JP      NZ,TYPE_MISMATCH
 644  56C4              ;        PUSH	HL
 645  56C4              ;        LD	IX,FRESTR         ; Free the temporary string
 646  56C4              ;        CALL	CALBAS
 647  56C4              ;        POP	HL
 648  56C4              ;	CALL	CHKCHAR
 649  56C4              ;	DEFB	")"             ; Check for )
 650  56C4              ;        RET
 651  56C4
 652  56C4
 653  56C4              CHKCHAR:
 654  56C4 CD CE 56     	CALL	GETPREVCHAR	; Get previous basic char
 655  56C7 E3           	EX	(SP),HL
 656  56C8 BE           	CP	(HL) 	        ; Check if good char
 657  56C9 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 658  56CB 23           	INC	HL
 659  56CC E3           	EX	(SP),HL
 660  56CD 23           	INC	HL		; Get next basic char
 661  56CE
 662  56CE              GETPREVCHAR:
 663  56CE 2B           	DEC	HL
 664  56CF DD 21 66 46  	LD	IX,CHRGTR
 665  56D3 C3 59 01     	JP      CALBAS
 666  56D6
 667  56D6
 668  56D6              TYPE_MISMATCH:
 669  56D6 1E 0D            LD E, 13 ; Type mismatch
 670  56D8 18 0A            JR THROW_ERROR
 671  56DA              SUBSCRIPT_OUT_OF_RANGE:
 672  56DA 1E 09            LD E,9 ; subscript out of range
 673  56DC 18 06        	JR THROW_ERROR
 674  56DE              OVERFLOW:
 675  56DE 1E 06        	LD E,6
 676  56E0 18 02        	JR THROW_ERROR
 677  56E2              SYNTAX_ERROR:
 678  56E2 1E 02            LD E, 2 ; Syntax error
 679  56E4              THROW_ERROR:
 680  56E4 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 681  56E8 C3 59 01     	JP	CALBAS
 682  56EB
 683  56EB              ;---------------------------
 684  56EB
 685  56EB              ; *******************************************************************************************************
 686  56EB              ; helper function to get pointer to BASIC array data
 687  56EB              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 688  56EB              ; input B=dimensions (1 or 2)
 689  56EB              ; input D=minimal first dimension
 690  56EB              ; input E=minimal second dimension
 691  56EB              ; returns BC=pointer to first data element
 692  56EB              ; throws BASIC error if invalid type
 693  56EB              GET_BASIC_ARRAY_DATA_POINTER:
 694  56EB D5           	PUSH DE
 695  56EC C5           	PUSH BC
 696  56ED F5           	PUSH AF
 697  56EE 3E 01            LD A,1
 698  56F0 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 699  56F3 DD 21 A4 5E  	LD IX, PTRGET
 700  56F7 CD 59 01     	CALL CALBAS
 701  56FA AF               XOR A
 702  56FB 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
 703  56FE 3A 63 F6     	LD A,(VALTYP)
 704  5701 D1           	POP DE ; required type
 705  5702 BA           	CP D
 706  5703 C2 D6 56     	JP NZ,TYPE_MISMATCH
 707  5706 0A           	LD A,(BC)
 708  5707 03           	INC BC
 709  5708 D1           	POP DE ; required number of dimensions
 710  5709 BA           	CP D
 711  570A C2 D6 56     	JP NZ,TYPE_MISMATCH
 712  570D 0A           	LD A,(BC)
 713  570E 03           	INC BC
 714  570F D1           	POP DE ; required minimal array dimensions
 715  5710 BA           	CP D
 716  5711 DA DA 56     	JP C,SUBSCRIPT_OUT_OF_RANGE
 717  5714 0A           	LD A,(BC)
 718  5715 03           	INC BC
 719  5716 BB           	CP E
 720  5717 DA DA 56     	JP C,SUBSCRIPT_OUT_OF_RANGE
 721  571A C9           	RET
 722  571B              ; *******************************************************************************************************
 723  571B
 724  571B               IF (RAM_CMDS == 1)
 725  571B              ; *******************************************************************************************************
 726  571B              ; function to handle CALL MEMCPY basic extension
 727  571B              ; _MEMCPY ( INT source,
 728  571B              ;			INT destination,
 729  571B              ;			INT count,
 730  571B              ; will put ram in page 0 also, page 1 is already there
 731  571B              MEMCPY:
 732  571B              	; opening (
 733  571B CD C4 56     	CALL CHKCHAR
 734  571E 28           	DB '('
 735  571F              	; get source address
 736  571F DD 21 2F 54  	LD IX, FRMQNT
 737  5723 CD 59 01     	CALL CALBAS
 738  5726 D5           	PUSH DE
 739  5727              	; comma
 740  5727 CD C4 56     	CALL CHKCHAR
 741  572A 2C           	DB ','
 742  572B              	; get destination address
 743  572B DD 21 2F 54  	LD IX, FRMQNT
 744  572F CD 59 01     	CALL CALBAS
 745  5732 D5           	PUSH DE
 746  5733              	; comma
 747  5733 CD C4 56     	CALL CHKCHAR
 748  5736 2C           	DB ','
 749  5737              	; get length
 750  5737 DD 21 2F 54  	LD IX, FRMQNT
 751  573B CD 59 01     	CALL CALBAS
 752  573E D5           	PUSH DE
 753  573F              	; ending )
 754  573F CD C4 56     	CALL CHKCHAR
 755  5742 29           	DB ')'
 756  5743
 757  5743              	; save position
 758  5743 E5           	PUSH HL
 759  5744 DD E1        	POP IX
 760  5746
 761  5746 C1           	POP BC ; count
 762  5747 D1           	POP DE ; destination
 763  5748 E1           	POP HL ; source
 764  5749 D9           	EXX
 765  574A              	; enable page 0
 766  574A FD 21 51 57  	LD IY, .RET
 767  574E C3 77 56     	JP ENABLE_PAGE0
 768  5751              .RET:
 769  5751 FB           	EI
 770  5752 D9           	EXX
 771  5753 ED B0        	LDIR
 772  5755 D1               POP DE
 773  5756 C1               POP BC
 774  5757 CD EE 55         CALL RESTORE_PAGE_INFO
 775  575A DD E5        	PUSH IX
 776  575C E1           	POP HL
 777  575D C9           	RET
 778  575E              ; *******************************************************************************************************
 779  575E               ENDIF
 780  575E
 781  575E               IF (VRAM_CMDS == 1)
 782  575E              ; *******************************************************************************************************
 783  575E              ; function to handle CALL FILVRM basic extension
 784  575E              ; FILVRM ( INT offset,
 785  575E              ;		   INT count,
 786  575E              ;		   BYTE value,
 787  575E              ;		   BYTE wait_vsync) >0 = true
 788  575E              ; wait_vsync will issue HALT before copying
 789  575E              FILVRM:
 790  575E              	; opening (
 791  575E CD C4 56     	CALL CHKCHAR
 792  5761 28           	DB '('
 793  5762              	; get offset address
 794  5762 DD 21 2F 54  	LD IX, FRMQNT
 795  5766 CD 59 01     	CALL CALBAS
 796  5769 D5           	PUSH DE
 797  576A              	; comma
 798  576A CD C4 56     	CALL CHKCHAR
 799  576D 2C           	DB ','
 800  576E              	; get count
 801  576E DD 21 2F 54  	LD IX, FRMQNT
 802  5772 CD 59 01     	CALL CALBAS
 803  5775 D5           	PUSH DE
 804  5776              	; comma
 805  5776 CD C4 56     	CALL CHKCHAR
 806  5779 2C           	DB ','
 807  577A              	; get value
 808  577A DD 21 1C 52  	LD IX, GETBYT
 809  577E CD 59 01     	CALL CALBAS
 810  5781 F5           	PUSH AF
 811  5782              	; comma
 812  5782 CD C4 56     	CALL CHKCHAR
 813  5785 2C           	DB ','
 814  5786              	; get vsync wait
 815  5786 DD 21 1C 52  	LD IX, GETBYT
 816  578A CD 59 01     	CALL CALBAS
 817  578D F5           	PUSH AF
 818  578E              	; ending )
 819  578E CD C4 56     	CALL CHKCHAR
 820  5791 29           	DB ')'
 821  5792
 822  5792 FB               EI
 823  5793              	; save position
 824  5793 E5           	PUSH HL
 825  5794 DD E1        	POP IX
 826  5796
 827  5796              	; syntax ok
 828  5796              	; wait for vsync if needed
 829  5796 F1           	POP AF
 830  5797 B7           	OR A
 831  5798 28 01        	JR Z, .L1
 832  579A 76           	HALT
 833  579B
 834  579B              .L1:
 835  579B F1               POP AF ; value
 836  579C C1               POP BC ; count
 837  579D E1               POP HL ; offset
 838  579E 3E 01        	LD A,1
 839  57A0 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
 840  57A3 CD 56 00         CALL BIOS_FILVRM
 841  57A6 AF           	XOR A
 842  57A7 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
 843  57AA
 844  57AA              .L3:
 845  57AA DD E5        	PUSH IX
 846  57AC E1           	POP HL
 847  57AD C9           	RET
 848  57AE              ; *******************************************************************************************************
 849  57AE               ENDIF
 850  57AE
 851  57AE               IF (RAM_CMDS == 1)
 852  57AE              ; *******************************************************************************************************
 853  57AE              ; function to handle CALL FILRAM basic extension
 854  57AE              ; FILRAM ( INT start address,
 855  57AE              ;		   INT count,
 856  57AE              ;		   BYTE value,
 857  57AE              ; will put ram in page 0 also, page 1 is already there
 858  57AE              FILRAM:
 859  57AE              	; opening (
 860  57AE CD C4 56     	CALL CHKCHAR
 861  57B1 28           	DB '('
 862  57B2              	; get start address
 863  57B2 DD 21 2F 54  	LD IX, FRMQNT
 864  57B6 CD 59 01     	CALL CALBAS
 865  57B9 D5           	PUSH DE
 866  57BA              	; comma
 867  57BA CD C4 56     	CALL CHKCHAR
 868  57BD 2C           	DB ','
 869  57BE              	; get count
 870  57BE DD 21 2F 54  	LD IX, FRMQNT
 871  57C2 CD 59 01     	CALL CALBAS
 872  57C5 D5           	PUSH DE
 873  57C6              	; comma
 874  57C6 CD C4 56     	CALL CHKCHAR
 875  57C9 2C           	DB ','
 876  57CA              	; get value
 877  57CA DD 21 1C 52  	LD IX, GETBYT
 878  57CE CD 59 01     	CALL CALBAS
 879  57D1 F5           	PUSH AF
 880  57D2              	; ending )
 881  57D2 CD C4 56     	CALL CHKCHAR
 882  57D5 29           	DB ')'
 883  57D6
 884  57D6              	; save position
 885  57D6 E5           	PUSH HL
 886  57D7 DD E1        	POP IX
 887  57D9
 888  57D9 D1           	POP DE ; actually AF
 889  57DA C1           	POP BC ; count
 890  57DB E1           	POP HL ; start address
 891  57DC 78           	LD A, B
 892  57DD B7           	OR A
 893  57DE 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 894  57E0 B1           	OR C
 895  57E1 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 896  57E3 79           	LD A, C
 897  57E4 3D           	DEC A
 898  57E5 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 899  57E7              	; one byte to fill
 900  57E7 72           	LD (HL), D
 901  57E8 18 12        	JR .EXIT
 902  57EA              .L1:
 903  57EA D9           	EXX
 904  57EB              	; enable page 0
 905  57EB FD 21 F2 57  	LD IY, .RET
 906  57EF C3 77 56     	JP ENABLE_PAGE0
 907  57F2              .RET:
 908  57F2 FB           	EI
 909  57F3 D9           	EXX
 910  57F4 CD 00 58     	CALL .FILLVALUE
 911  57F7 D1               POP DE
 912  57F8 C1               POP BC
 913  57F9 CD EE 55         CALL RESTORE_PAGE_INFO
 914  57FC              .EXIT:
 915  57FC DD E5        	PUSH IX
 916  57FE E1           	POP HL
 917  57FF C9           	RET
 918  5800
 919  5800              .FILLVALUE:
 920  5800 72               LD (HL), D
 921  5801 54               LD D, H
 922  5802 5D               LD E, L
 923  5803 13               INC DE
 924  5804 0B               DEC BC
 925  5805 ED B0            LDIR
 926  5807 C9               RET
 927  5808              ; *******************************************************************************************************
 928  5808               ENDIF
 929  5808
 930  5808               IF (GENCAL_CMD == 1)
 931  5808              ; *******************************************************************************************************
 932  5808              ; function to handle CALL GENCAL basic extension
 933  5808              ; GENCAL ( INT fn_addr, = address of the function to call
 934  5808              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 935  5808              ; output values of reristers will also be stored at reg_list_ptr
 936  5808              GENCAL_VAR_SP:
 937  5808 00 00            DW 0
 938  580A              GENCAL_VAR_SP2:
 939  580A 00 00            DW 0
 940  580C              GENCAL:
 941  580C              	; opening (
 942  580C CD C4 56     	CALL CHKCHAR
 943  580F 28           	DB '('
 944  5810              	; get function address
 945  5810 DD 21 2F 54  	LD IX, FRMQNT
 946  5814 CD 59 01     	CALL CALBAS
 947  5817 D5           	PUSH DE
 948  5818              	; comma
 949  5818 CD C4 56     	CALL CHKCHAR
 950  581B 2C           	DB ','
 951  581C              	; get pointer to register list
 952  581C DD 21 2F 54  	LD IX, FRMQNT
 953  5820 CD 59 01     	CALL CALBAS
 954  5823 D5           	PUSH DE
 955  5824              	; ending )
 956  5824 CD C4 56     	CALL CHKCHAR
 957  5827 29           	DB ')'
 958  5828
 959  5828              	; save BASIC token position
 960  5828 E5           	PUSH HL
 961  5829 D9               EXX
 962  582A E1           	POP HL ; HL'=next basic token
 963  582B D9               EXX
 964  582C
 965  582C E1               POP HL ; get pointer to register values
 966  582D F3           	DI
 967  582E ED 73 08 58      LD (GENCAL_VAR_SP), SP
 968  5832 F9               LD SP, HL
 969  5833 F1               POP AF
 970  5834 C1               POP BC
 971  5835 D1               POP DE
 972  5836 E1               POP HL
 973  5837 DD E1            POP IX
 974  5839 FD E1            POP IY
 975  583B D9               EXX
 976  583C ED 73 0A 58      LD (GENCAL_VAR_SP2), SP
 977  5840 ED 7B 08 58      LD SP, (GENCAL_VAR_SP)
 978  5844 FB               EI
 979  5845 D1               POP DE ; get function to call
 980  5846 E5               PUSH HL
 981  5847 CD 62 58         CALL .EXXDECALL
 982  584A F3               DI
 983  584B ED 73 08 58      LD (GENCAL_VAR_SP), SP
 984  584F ED 7B 0A 58      LD SP, (GENCAL_VAR_SP2)
 985  5853 FD E5            PUSH IY
 986  5855 DD E5            PUSH IX
 987  5857 E5               PUSH HL
 988  5858 D5               PUSH DE
 989  5859 C5               PUSH BC
 990  585A F5               PUSH AF
 991  585B ED 7B 08 58      LD SP, (GENCAL_VAR_SP)
 992  585F FB               EI
 993  5860 E1               POP HL
 994  5861 C9           	RET
 995  5862
 996  5862              .EXXDECALL:
 997  5862 D5               PUSH DE
 998  5863 D9               EXX
 999  5864 C9               RET
1000  5865              ; *******************************************************************************************************
1001  5865               ENDIF
1002  5865
1003  5865               IF (VRAM_CMDS == 1)
1004  5865              ; *******************************************************************************************************
1005  5865              ; function to handle CALL MEMVRM basic extension
1006  5865              ; copies from RAM to VRAM
1007  5865              ; _MEMVRM ( INT source,
1008  5865              ;			INT destination,
1009  5865              ;			INT count,
1010  5865              ;			BYTE wait_vsync) >0 = true
1011  5865              ; will put ram in page 0 also, page 1 is already there
1012  5865              ; wait_vsync will issue HALT before copying
1013  5865              MEMVRM:
1014  5865              	; opening (
1015  5865 CD C4 56     	CALL CHKCHAR
1016  5868 28           	DB '('
1017  5869              	; get source address
1018  5869 DD 21 2F 54  	LD IX, FRMQNT
1019  586D CD 59 01     	CALL CALBAS
1020  5870 D5           	PUSH DE
1021  5871              	; comma
1022  5871 CD C4 56     	CALL CHKCHAR
1023  5874 2C           	DB ','
1024  5875              	; get destination address
1025  5875 DD 21 2F 54  	LD IX, FRMQNT
1026  5879 CD 59 01     	CALL CALBAS
1027  587C D5           	PUSH DE
1028  587D              	; comma
1029  587D CD C4 56     	CALL CHKCHAR
1030  5880 2C           	DB ','
1031  5881              	; get length
1032  5881 DD 21 2F 54  	LD IX, FRMQNT
1033  5885 CD 59 01     	CALL CALBAS
1034  5888 D5           	PUSH DE
1035  5889              	; comma
1036  5889 CD C4 56     	CALL CHKCHAR
1037  588C 2C           	DB ','
1038  588D              	; get vsync wait
1039  588D DD 21 1C 52  	LD IX, GETBYT
1040  5891 CD 59 01     	CALL CALBAS
1041  5894 F5           	PUSH AF
1042  5895              	; ending )
1043  5895 CD C4 56     	CALL CHKCHAR
1044  5898 29           	DB ')'
1045  5899
1046  5899                  ; save position in BASIC text
1047  5899 E5           	PUSH HL
1048  589A DD E1        	POP IX
1049  589C
1050  589C F1           	POP AF ; wait vsync
1051  589D B7           	OR A
1052  589E 28 03        	JR Z, .L1
1053  58A0 FB               EI
1054  58A1 76           	HALT
1055  58A2 F3           	DI
1056  58A3              .L1:
1057  58A3              	; pop LDIR parameters and store away for later
1058  58A3 C1           	POP BC ; count
1059  58A4 D1           	POP DE ; vram destination
1060  58A5 E1           	POP HL ; ram source
1061  58A6 D9           	EXX
1062  58A7 FD 21 AE 58   	LD IY, .RET
1063  58AB C3 77 56     	JP ENABLE_PAGE0
1064  58AE              .RET:
1065  58AE FB           	EI
1066  58AF D9           	EXX
1067  58B0 3E 01        	LD A,1
1068  58B2 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1069  58B5 CD C5 58     	CALL .LDIRVM
1070  58B8 AF           	XOR A
1071  58B9 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1072  58BC D1               POP DE
1073  58BD C1               POP BC
1074  58BE CD EE 55         CALL RESTORE_PAGE_INFO
1075  58C1 DD E5        	PUSH IX
1076  58C3 E1           	POP HL
1077  58C4 C9           	RET
1078  58C5
1079  58C5              .LDIRVM:
1080  58C5 EB           	EX DE, HL
1081  58C6 F3           	DI
1082  58C7 CD 9E 55     	CALL SETWRT_LOCAL
1083  58CA FB           	EI
1084  58CB EB           	EX DE, HL
1085  58CC 78           	LD A, B
1086  58CD B7           	OR A
1087  58CE 28 0D        	JR Z, .L3
1088  58D0 C5           	PUSH BC
1089  58D1 0E 98        	LD C, #98
1090  58D3              .L2:
1091  58D3 50           	LD D, B
1092  58D4 06 00        	LD B, 0
1093  58D6 CD AB 55     	CALL BBYTECOPY_NO_C
1094  58D9 42           	LD B, D
1095  58DA 10 F7        	DJNZ .L2
1096  58DC C1           	POP BC
1097  58DD              .L3:
1098  58DD 79           	LD A, C
1099  58DE B7           	OR A
1100  58DF C8           	RET Z
1101  58E0 41           	LD B, C
1102  58E1 C3 A9 55     	JP BBYTECOPY
1103  58E4              ; *******************************************************************************************************
1104  58E4               ENDIF
1105  58E4
1106  58E4               IF (VRAM_CMDS == 1)
1107  58E4              ; *******************************************************************************************************
1108  58E4              ; function to handle CALL VRMMEM basic extension
1109  58E4              ; copies from RAM to VRAM
1110  58E4              ; _VRMMEM ( INT source,
1111  58E4              ;			INT destination,
1112  58E4              ;			INT count
1113  58E4              ; will put ram in page 0 also, page 1 is already there
1114  58E4              VRMMEM:
1115  58E4              	; opening (
1116  58E4 CD C4 56     	CALL CHKCHAR
1117  58E7 28           	DB '('
1118  58E8              	; get source address
1119  58E8 DD 21 2F 54  	LD IX, FRMQNT
1120  58EC CD 59 01     	CALL CALBAS
1121  58EF D5           	PUSH DE
1122  58F0              	; comma
1123  58F0 CD C4 56     	CALL CHKCHAR
1124  58F3 2C           	DB ','
1125  58F4              	; get destination address
1126  58F4 DD 21 2F 54  	LD IX, FRMQNT
1127  58F8 CD 59 01     	CALL CALBAS
1128  58FB D5           	PUSH DE
1129  58FC              	; comma
1130  58FC CD C4 56     	CALL CHKCHAR
1131  58FF 2C           	DB ','
1132  5900              	; get length
1133  5900 DD 21 2F 54  	LD IX, FRMQNT
1134  5904 CD 59 01     	CALL CALBAS
1135  5907 D5           	PUSH DE
1136  5908              	; ending )
1137  5908 CD C4 56     	CALL CHKCHAR
1138  590B 29           	DB ')'
1139  590C
1140  590C                  ; save position in BASIC text
1141  590C E5           	PUSH HL
1142  590D DD E1        	POP IX
1143  590F
1144  590F C1           	POP BC ; count
1145  5910 D1           	POP DE ; destination
1146  5911 E1           	POP HL ; source
1147  5912 D9           	EXX
1148  5913 FD 21 1A 59  	LD IY, .RET
1149  5917 C3 77 56     	JP ENABLE_PAGE0
1150  591A              .RET:
1151  591A FB           	EI
1152  591B D9           	EXX
1153  591C 3E 01        	LD A,1
1154  591E 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1155  5921 CD 31 59     	CALL .LDIRMV
1156  5924 AF           	XOR A
1157  5925 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1158  5928 D1               POP DE
1159  5929 C1               POP BC
1160  592A CD EE 55         CALL RESTORE_PAGE_INFO
1161  592D DD E5        	PUSH IX
1162  592F E1           	POP HL
1163  5930 C9           	RET
1164  5931
1165  5931              .LDIRMV:
1166  5931              	; set VRAM address *exactly* as in ROM, otherwise corruption
1167  5931 7D           	LD	A, L
1168  5932 F3           	DI
1169  5933 D3 99        	OUT	(099H), A
1170  5935 7C           	LD	A, H
1171  5936 E6 3F        	AND	03FH
1172  5938 D3 99        	OUT	(099H), A
1173  593A FB           	EI
1174  593B              	;EX (SP), HL
1175  593B              	;EX (SP), HL
1176  593B              	;NOP
1177  593B              	;NOP
1178  593B              .L4:
1179  593B DB 98            IN A, (#98)
1180  593D 12           	LD (DE), A
1181  593E 13               INC DE
1182  593F 0B               DEC BC
1183  5940 79               LD A, C
1184  5941 B0               OR B
1185  5942 20 F7            JR NZ, .L4
1186  5944 C9               RET
1187  5945              ; *******************************************************************************************************
1188  5945               ENDIF
1189  5945
1190  5945               IF (SOUND_CMDS == 1)
1191  5945              ; *******************************************************************************************************
1192  5945              ; function to handle CALL SNDPLYINIT basic extension
1193  5945              ; initializes sound player
1194  5945              ; _SNDPLYINIT ( INT music_offset,
1195  5945              ;				INT sfx_offset, can be -1 if no SFX
1196  5945              ; will put ram in page 0 also, page 1 is already there
1197  5945              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1198  5945              SNDPLYINIT:
1199  5945              	; opening (
1200  5945 CD C4 56     	CALL CHKCHAR
1201  5948 28           	DB '('
1202  5949              	; get music address
1203  5949 DD 21 2F 54  	LD IX, FRMQNT
1204  594D CD 59 01     	CALL CALBAS
1205  5950 D5           	PUSH DE
1206  5951              	; comma
1207  5951 CD C4 56     	CALL CHKCHAR
1208  5954 2C           	DB ','
1209  5955              	; get sfx address
1210  5955 DD 21 2F 54  	LD IX, FRMQNT
1211  5959 CD 59 01     	CALL CALBAS
1212  595C D5           	PUSH DE
1213  595D              	; ending )
1214  595D CD C4 56     	CALL CHKCHAR
1215  5960 29           	DB ')'
1216  5961
1217  5961                  ; save position in BASIC text
1218  5961 44           	LD B, H
1219  5962 4D           	LD C, L
1220  5963
1221  5963              	; pop LDIR parameters and store away for later
1222  5963 D1           	POP DE ; sfx address
1223  5964 E1           	POP HL ; music address
1224  5965 C5           	PUSH BC ; basic text location
1225  5966 D9           	EXX
1226  5967 FD 21 6E 59  	LD IY, .RET
1227  596B C3 77 56     	JP ENABLE_PAGE0
1228  596E              .RET:
1229  596E D9           	EXX
1230  596F
1231  596F D5           	PUSH DE
1232  5970 AF           	XOR A
1233  5971              	; HL = music location
1234  5971 CD 62 41     	CALL PLY_AKG_INIT
1235  5974 3E 01        	LD A, 1
1236  5976 32 7A 4D     	LD (MUSIC_INIT_STATUS), A
1237  5979
1238  5979 E1           	POP HL ; SFX
1239  597A              	; check if SFX address -1
1240  597A 23           	INC HL
1241  597B 7D           	LD A, L
1242  597C B4           	OR H
1243  597D 28 09        	JR Z,.L1
1244  597F 2B           	DEC HL
1245  5980 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1246  5983 3E 01        	LD A, 1
1247  5985 32 7B 4D     	LD (SFX_INIT_STATUS), A
1248  5988              .L1:
1249  5988 D1               POP DE
1250  5989 C1               POP BC
1251  598A CD EE 55         CALL RESTORE_PAGE_INFO
1252  598D
1253  598D E1           	POP HL
1254  598E C9           	RET
1255  598F              ; *******************************************************************************************************
1256  598F
1257  598F              ; *******************************************************************************************************
1258  598F              ; function to handle CALL SNDPLYON basic extension
1259  598F              ; enables sound player
1260  598F              ; _SNDPLYON
1261  598F              ; sets SOUND_ENABLED variable to 1 if init call was done
1262  598F              ; if not throws out of data error
1263  598F              SNDPLYON:
1264  598F 3A 7A 4D     	LD A, (MUSIC_INIT_STATUS)
1265  5992 B7           	OR A
1266  5993 20 05        	JR NZ, .L1
1267  5995              	; player not initialized, throw error
1268  5995 1E 04        	LD E, 04 ; Out of DATA
1269  5997 C3 E4 56     	JP THROW_ERROR
1270  599A              .L1:
1271  599A 32 7C 4D     	LD (SOUND_ENABLED), A
1272  599D              	; disable key click
1273  599D AF           	XOR A
1274  599E 32 DB F3     	LD (CLIKSW), A
1275  59A1 C9           	RET
1276  59A2              ; *******************************************************************************************************
1277  59A2
1278  59A2              ; *******************************************************************************************************
1279  59A2              ; function to handle CALL SNDPLYOFF basic extension
1280  59A2              ; disables sound player
1281  59A2              ; _SNDPLYOFF
1282  59A2              ; sets SOUND_ENABLED variable to 0
1283  59A2              ; calls AKG to stop music and SFX on all channels if initialized
1284  59A2              SNDPLYOFF:
1285  59A2 3A 7C 4D     	LD A, (SOUND_ENABLED)
1286  59A5 B7           	OR A
1287  59A6 C8           	RET Z ; already stopped
1288  59A7 AF           	XOR A
1289  59A8 32 7C 4D     	LD (SOUND_ENABLED), A
1290  59AB E5           	PUSH HL
1291  59AC CD 21 42     	CALL PLY_AKG_STOP
1292  59AF 3A 7B 4D     	LD A, (SFX_INIT_STATUS)
1293  59B2 B7           	OR A
1294  59B3 28 0E        	JR Z, .EXIT ; SFX not in use
1295  59B5 AF           	XOR A
1296  59B6 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1297  59B9 3E 01        	LD A, 1
1298  59BB CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1299  59BE 3E 02        	LD A, 2
1300  59C0 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1301  59C3              .EXIT:
1302  59C3 E1           	POP HL
1303  59C4 C9           	RET
1304  59C5              ; *******************************************************************************************************
1305  59C5
1306  59C5              ; *******************************************************************************************************
1307  59C5              ; function to handle CALL SNDSFX basic extension
1308  59C5              ; plays a sound effect
1309  59C5              ; _SNDSFX ( BYTE sfx_number, >0
1310  59C5              ;			BYTE channel, = 0,1 or 2
1311  59C5              ;			BYTE inverted_volume = 0-16, 0 being full volume
1312  59C5              ; will put ram in page 0 also, page 1 is already there
1313  59C5              ; if sound off throws illegal function call
1314  59C5              ; if sfx not initialized, throws out of data
1315  59C5              SNDSFX:
1316  59C5              	; opening (
1317  59C5 CD C4 56     	CALL CHKCHAR
1318  59C8 28           	DB '('
1319  59C9              	; get sfx_number
1320  59C9 DD 21 1C 52  	LD IX, GETBYT
1321  59CD CD 59 01     	CALL CALBAS
1322  59D0 D5           	PUSH DE
1323  59D1              	; comma
1324  59D1 CD C4 56     	CALL CHKCHAR
1325  59D4 2C           	DB ','
1326  59D5              	; get sfx address
1327  59D5 DD 21 1C 52  	LD IX, GETBYT
1328  59D9 CD 59 01     	CALL CALBAS
1329  59DC D5           	PUSH DE
1330  59DD              	; comma
1331  59DD CD C4 56     	CALL CHKCHAR
1332  59E0 2C           	DB ','
1333  59E1              	; get inverted volume
1334  59E1 DD 21 1C 52  	LD IX, GETBYT
1335  59E5 CD 59 01     	CALL CALBAS
1336  59E8 D5           	PUSH DE
1337  59E9              	; ending )
1338  59E9 CD C4 56     	CALL CHKCHAR
1339  59EC 29           	DB ')'
1340  59ED
1341  59ED 3A 7C 4D     	LD A, (SOUND_ENABLED)
1342  59F0 B7           	OR A
1343  59F1 20 05        	JR NZ, .L1
1344  59F3              	; sound disabled, throw illegal function call
1345  59F3 1E 05        	LD E, 5
1346  59F5 C3 E4 56     	JP THROW_ERROR
1347  59F8              .L1:
1348  59F8 3A 7B 4D     	LD A, (SFX_INIT_STATUS)
1349  59FB B7           	OR A
1350  59FC 20 05        	JR NZ, .L2
1351  59FE              	; sfx data not initialized, throw out of data
1352  59FE 1E 04        	LD E, 4
1353  5A00 C3 E4 56     	JP THROW_ERROR
1354  5A03              .L2:
1355  5A03              	; pop  parameters and store away for later
1356  5A03 D1           	POP DE ; inverted volume
1357  5A04 43           	LD B, E
1358  5A05 D1           	POP DE ; channel
1359  5A06 4B           	LD C, E
1360  5A07 D1           	POP DE
1361  5A08 7B           	LD A, E
1362  5A09 08           	EX AF, AF'
1363  5A0A E5           	PUSH HL ; basic text location
1364  5A0B D9           	EXX
1365  5A0C FD 21 13 5A  	LD IY, .RET
1366  5A10 C3 77 56     	JP ENABLE_PAGE0
1367  5A13              .RET:
1368  5A13 D9           	EXX
1369  5A14 08           	EX AF, AF'
1370  5A15 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1371  5A18
1372  5A18 D1               POP DE
1373  5A19 C1               POP BC
1374  5A1A CD EE 55         CALL RESTORE_PAGE_INFO
1375  5A1D
1376  5A1D E1           	POP HL
1377  5A1E C9           	RET
1378  5A1F              ; *******************************************************************************************************
1379  5A1F               ENDIF
1380  5A1F
1381  5A1F               IF (BLIT_CMDS == 1)
1382  5A1F              ; *******************************************************************************************************
1383  5A1F              ; function rotates mask and data of several characters and applies to background data
1384  5A1F              ; this handles x-shift from 0 to 4
1385  5A1F              ; contains self-modifying code that is set-up from external function
1386  5A1F              ; input HL=pointer to mask data
1387  5A1F              ; input HL'=pointer to character data
1388  5A1F              ; input DE=output buffer containing background data
1389  5A1F              ; input BC=DE+8
1390  5A1F              ; input A=number of characters to process
1391  5A1F              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1392  5A1F              SHIFT04:
1393  5A1F 08           	EX AF, AF'
1394  5A20 7E           	LD A, (HL) ; get mask
1395  5A21 D9           	EXX
1396  5A22 57           	LD D, A
1397  5A23 1E FF        	LD E, #FF
1398  5A25 37           	SCF
1399  5A26              .M1:
1400  5A26 18 FE        	JR .M1 ; this is self-modifying part
1401  5A28 CB 1A        	RR D
1402  5A2A CB 1B        	RR E
1403  5A2C CB 1A        	RR D
1404  5A2E CB 1B        	RR E
1405  5A30 CB 1A        	RR D
1406  5A32 CB 1B        	RR E
1407  5A34 CB 1A        	RR D
1408  5A36 CB 1B        	RR E
1409  5A38
1410  5A38 46           	LD B, (HL) ; get data
1411  5A39 0E 00        	LD C, 0
1412  5A3B              .M2:
1413  5A3B 18 FE        	JR .M2 ; also self-modifying part
1414  5A3D CB 38        	SRL B
1415  5A3F CB 19        	RR C
1416  5A41 CB 38        	SRL B
1417  5A43 CB 19        	RR C
1418  5A45 CB 38        	SRL B
1419  5A47 CB 19        	RR C
1420  5A49 CB 38        	SRL B
1421  5A4B CB 19        	RR C
1422  5A4D
1423  5A4D D9           	EXX
1424  5A4E 1A           	LD A, (DE) ; background
1425  5A4F D9           	EXX
1426  5A50 A2           	AND D
1427  5A51 B0           	OR B
1428  5A52 D9           	EXX
1429  5A53 12           	LD (DE), A
1430  5A54
1431  5A54 0A           	LD A, (BC)
1432  5A55 D9           	EXX
1433  5A56 A3           	AND E
1434  5A57 B1           	OR C
1435  5A58 23           	INC HL
1436  5A59 D9           	EXX
1437  5A5A 02           	LD (BC), A
1438  5A5B
1439  5A5B 23           	INC HL
1440  5A5C 13           	INC DE
1441  5A5D 03           	INC BC
1442  5A5E
1443  5A5E 08           	EX AF, AF'
1444  5A5F 3D           	DEC A
1445  5A60 C2 1F 5A     	JP NZ, SHIFT04
1446  5A63 C9           	RET
1447  5A64              ; *******************************************************************************************************
1448  5A64
1449  5A64              ; *******************************************************************************************************
1450  5A64              ; function rotates mask and data of several characters and applies to background data
1451  5A64              ; this handles x-shift from 5 to 8
1452  5A64              ; contains self-modifying code that is set-up from external function
1453  5A64              ; input HL=pointer to mask data
1454  5A64              ; input HL'=pointer to character data
1455  5A64              ; input DE=output buffer containing background data
1456  5A64              ; input BC=DE+8
1457  5A64              ; input A=number of characters to process
1458  5A64              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1459  5A64              SHIFT58:
1460  5A64 08           	EX AF, AF'
1461  5A65 7E           	LD A, (HL) ; get mask
1462  5A66 D9           	EXX
1463  5A67 57           	LD D, A
1464  5A68 1E FF        	LD E, #FF
1465  5A6A 37           	SCF
1466  5A6B              .M1:
1467  5A6B 18 FE        	JR .M1 ; this is self-modifying part
1468  5A6D CB 12        	RL D
1469  5A6F CB 13        	RL E
1470  5A71 CB 12        	RL D
1471  5A73 CB 13        	RL E
1472  5A75 CB 12        	RL D
1473  5A77 CB 13        	RL E
1474  5A79
1475  5A79 46           	LD B, (HL)
1476  5A7A 0E 00        	LD C, 0
1477  5A7C              .M2:
1478  5A7C 18 FE        	JR .M2 ; also self-modifying part
1479  5A7E CB 20        	SLA B
1480  5A80 CB 11        	RL C
1481  5A82 CB 20        	SLA B
1482  5A84 CB 11        	RL C
1483  5A86 CB 20        	SLA B
1484  5A88 CB 11        	RL C
1485  5A8A
1486  5A8A D9           	EXX
1487  5A8B 1A           	LD A, (DE) ; background
1488  5A8C D9           	EXX
1489  5A8D A3           	AND E
1490  5A8E B1           	OR C
1491  5A8F D9           	EXX
1492  5A90 12           	LD (DE), A
1493  5A91
1494  5A91 0A           	LD A, (BC)
1495  5A92 D9           	EXX
1496  5A93 A2           	AND D
1497  5A94 B0           	OR B
1498  5A95 23           	INC HL
1499  5A96 D9           	EXX
1500  5A97 02           	LD (BC), A
1501  5A98
1502  5A98 23           	INC HL
1503  5A99 13           	INC DE
1504  5A9A 03           	INC BC
1505  5A9B
1506  5A9B 08           	EX AF, AF'
1507  5A9C 3D           	DEC A
1508  5A9D C2 64 5A     	JP NZ, SHIFT58
1509  5AA0 C9           	RET
1510  5AA1              ; *******************************************************************************************************
1511  5AA1
1512  5AA1              ; *******************************************************************************************************
1513  5AA1              ; routine that shifts one row of characters
1514  5AA1              ; contains self-modifying code that is set-up from external function
1515  5AA1              ; input HL=pointer to mask data
1516  5AA1              ; input HL'=pointer to character data
1517  5AA1              ; input DE=output buffer containing background data
1518  5AA1              ; input A=number of characters to process
1519  5AA1              ; input IX=pointer to structure describing input data
1520  5AA1              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1521  5AA1              SHIFT_ROW:
1522  5AA1 F5           	PUSH AF
1523  5AA2 ED 53 14 54  		LD (BLIT_TMP1), DE
1524  5AA6 E5           		PUSH HL
1525  5AA7 CD EA 5A     			CALL .ADDYSHIFT
1526  5AAA E1           		POP HL
1527  5AAB ED 53 16 54  		LD (BLIT_TMP2), DE ; DE+vertical shift
1528  5AAF              .L1:
1529  5AAF 3E 08        		LD A, 8
1530  5AB1 DD 96 02     		SUB (IX+2) ; y shift
1531  5AB4              .CALL1:
1532  5AB4 CD 00 00     		CALL 0
1533  5AB7 DD 7E 02     		LD A, (IX+2); y shift
1534  5ABA B7           		OR A
1535  5ABB 28 26        		JR Z, .DONE
1536  5ABD ED 5B 14 54  		LD DE, (BLIT_TMP1)
1537  5AC1 E5           		PUSH HL
1538  5AC2 CD F8 5A     			CALL .DETONEXTROW
1539  5AC5 E1           		POP HL
1540  5AC6              .CALL2:
1541  5AC6 CD 00 00     		CALL 0
1542  5AC9 ED 5B 14 54  		LD DE, (BLIT_TMP1)
1543  5ACD E5           		PUSH HL
1544  5ACE CD F2 5A     			CALL .ADD8
1545  5AD1 E1           		POP HL
1546  5AD2 ED 53 14 54  		LD (BLIT_TMP1), DE
1547  5AD6 ED 5B 16 54  		LD DE, (BLIT_TMP2)
1548  5ADA E5           		PUSH HL
1549  5ADB CD F2 5A     			CALL .ADD8
1550  5ADE E1           		POP HL
1551  5ADF ED 53 16 54  		LD (BLIT_TMP2), DE ; DE+vertical shift
1552  5AE3              .DONE:
1553  5AE3 F1           	POP AF
1554  5AE4 3D           	DEC A
1555  5AE5 C8           	RET Z
1556  5AE6 F5           	PUSH AF
1557  5AE7 C3 AF 5A     	JP .L1
1558  5AEA              .ADDYSHIFT:
1559  5AEA EB           	EX DE, HL
1560  5AEB 16 00        	LD D, 0
1561  5AED DD 5E 02     	LD E, (IX+2); y shift
1562  5AF0 18 0C        	JR .MOVDEBC
1563  5AF2              .ADD8:
1564  5AF2 21 08 00     	LD HL, 8
1565  5AF5 C3 FE 5A     	JP .MOVDEBC
1566  5AF8              .DETONEXTROW:
1567  5AF8 DD 6E 06     	LD L, (IX+6)
1568  5AFB DD 66 07     	LD H, (IX+7) ; bkg add to value
1569  5AFE              .MOVDEBC:
1570  5AFE 19           	ADD HL, DE
1571  5AFF 54           	LD D, H
1572  5B00 5D           	LD E, L
1573  5B01 01 08 00     	LD BC, 8
1574  5B04 09           	ADD HL, BC
1575  5B05 44           	LD B, H
1576  5B06 4D           	LD C, L
1577  5B07 C9           	RET
1578  5B08              ; *******************************************************************************************************
1579  5B08
1580  5B08              ; *******************************************************************************************************
1581  5B08              ; function rotates mask and character data and applies it to background
1582  5B08              ; input IX=pointer to structure describing input data
1583  5B08              ; +0  DW horizontal shift count 0-7 (low byte used)
1584  5B08              ; +2  DW vertical shift count 0-7 (low byte used)
1585  5B08              ; +4  DW background data start;
1586  5B08              ; +6  DW background add to value to next row of background data
1587  5B08              ; +8  DW mask data start;
1588  5B08              ; +10  DW character data start;
1589  5B08              ; +12 DW character&mask add to value to next row of data
1590  5B08              ; +14 DW columns (low byte used)
1591  5B08              ; +16 DW rows (low byte used)
1592  5B08              SHIFT_MERGE_CHARACTER:
1593  5B08 DD 7E 00     	LD A, (IX) ; shift
1594  5B0B FE 05        	CP 5
1595  5B0D 38 25        	JR C, .RIGHT
1596  5B0F              	; shifts 5-7, use rotate towards left 1-3
1597  5B0F 21 64 5A     	LD HL, SHIFT58
1598  5B12 22 B5 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1599  5B15 22 C7 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1600  5B18 D6 05        	SUB 5
1601  5B1A 28 0D        	JR Z, .L1
1602  5B1C 87           	ADD A, A
1603  5B1D 87           	ADD A, A
1604  5B1E 67           	LD H, A
1605  5B1F 2E 18        	LD L, #18 ; JR opcode
1606  5B21 22 6B 5A     	LD (SHIFT58.M1), HL
1607  5B24 22 7C 5A     	LD (SHIFT58.M2), HL
1608  5B27 18 32        	JR .DO
1609  5B29              .L1:
1610  5B29 21 00 00     	LD HL, 0 ; 2xNOP opcode
1611  5B2C 22 6B 5A     	LD (SHIFT58.M1), HL
1612  5B2F 22 7C 5A     	LD (SHIFT58.M2), HL
1613  5B32 18 27        	JR .DO
1614  5B34              .RIGHT:
1615  5B34              	; shifts 0-4, rotate towards right
1616  5B34 21 1F 5A     	LD HL, SHIFT04
1617  5B37 22 B5 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1618  5B3A 22 C7 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1619  5B3D FE 04        	CP 4
1620  5B3F 28 11        	JR Z, .R1
1621  5B41 D6 04        	SUB 4
1622  5B43 ED 44        	NEG
1623  5B45 87           	ADD A, A
1624  5B46 87           	ADD A, A
1625  5B47 67           	LD H, A
1626  5B48 2E 18        	LD L, #18 ; JR opcode
1627  5B4A 22 26 5A     	LD (SHIFT04.M1), HL
1628  5B4D 22 3B 5A     	LD (SHIFT04.M2), HL
1629  5B50 18 09        	JR .DO
1630  5B52              .R1:
1631  5B52 21 00 00     	LD HL, 0 ; 2xNOP opcode
1632  5B55 22 26 5A     	LD (SHIFT04.M1), HL
1633  5B58 22 3B 5A     	LD (SHIFT04.M2), HL
1634  5B5B              .DO:
1635  5B5B DD 46 10     	LD B, (IX+16) ; rows
1636  5B5E DD 6E 08     	LD L, (IX+8)
1637  5B61 DD 66 09     	LD H, (IX+9) ; mask data
1638  5B64 DD 5E 04     	LD E, (IX+4)
1639  5B67 DD 56 05     	LD D, (IX+5) ; background data
1640  5B6A D9           	EXX
1641  5B6B DD 6E 0A     	LD L, (IX+10)
1642  5B6E DD 66 0B     	LD H, (IX+11) ; character data
1643  5B71 D9           	EXX
1644  5B72              .LOOP:
1645  5B72 C5           	PUSH BC
1646  5B73 E5           		PUSH HL
1647  5B74 D5           			PUSH DE
1648  5B75 D9           				EXX
1649  5B76 E5           				PUSH HL
1650  5B77 D9           					EXX
1651  5B78 DD 7E 0E     					LD A, (IX+14) ; columns
1652  5B7B              .CALL:
1653  5B7B CD A1 5A     					CALL SHIFT_ROW
1654  5B7E E1           				POP HL
1655  5B7F DD 5E 0C     				LD E, (IX+12)
1656  5B82 DD 56 0D     				LD D, (IX+13) ; char data to next row
1657  5B85 19           				ADD HL, DE
1658  5B86 D9           				EXX
1659  5B87 E1           			POP HL
1660  5B88 DD 5E 06     			LD E, (IX+6)
1661  5B8B DD 56 07     			LD D, (IX+7) ; background to next row
1662  5B8E 19           			ADD HL, DE
1663  5B8F EB           			EX DE, HL
1664  5B90 E1           		POP HL
1665  5B91 DD 4E 0C     		LD C, (IX+12)
1666  5B94 DD 46 0D     		LD B, (IX+13) ; char data to next row
1667  5B97 09           		ADD HL, BC
1668  5B98 C1           	POP BC
1669  5B99 10 D7        	DJNZ .LOOP
1670  5B9B C9           	RET
1671  5B9C              ; *******************************************************************************************************
1672  5B9C
1673  5B9C               IFNDEF CMDS_WITH_PARAMETERS
1674  5B9C ~            ; *******************************************************************************************************
1675  5B9C ~            ; function to handle CALL BLIT basic extension
1676  5B9C ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1677  5B9C ~            ; fuses with background data and applies vertical shift too
1678  5B9C ~            ; BLIT ( INT request_data_ptr )
1679  5B9C ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1680  5B9C ~            ; will put ram in page 0 also, page 1 is already there
1681  5B9C ~            BLIT:
1682  5B9C ~            	; opening (
1683  5B9C ~            	CALL CHKCHAR
1684  5B9C ~            	DB '('
1685  5B9C ~            	; get pointer to request struct
1686  5B9C ~            	LD IX, FRMQNT
1687  5B9C ~            	CALL CALBAS
1688  5B9C ~            	PUSH DE
1689  5B9C ~            	; ending )
1690  5B9C ~            	CALL CHKCHAR
1691  5B9C ~            	DB ')'
1692  5B9C ~
1693  5B9C ~            	POP IX ; pointer to request struct
1694  5B9C ~
1695  5B9C ~            	PUSH HL ; save position in BASIC buffer
1696  5B9C ~
1697  5B9C ~            	LD IY, .RET
1698  5B9C ~            	JP ENABLE_PAGE0
1699  5B9C ~            .RET:
1700  5B9C ~            	EI
1701  5B9C ~            	CALL SHIFT_MERGE_CHARACTER
1702  5B9C ~
1703  5B9C ~                POP DE
1704  5B9C ~                POP BC
1705  5B9C ~                CALL RESTORE_PAGE_INFO
1706  5B9C ~
1707  5B9C ~            	POP HL
1708  5B9C ~            	RET
1709  5B9C ~            ; *******************************************************************************************************
1710  5B9C               ENDIF
1711  5B9C
1712  5B9C               IFDEF CMDS_WITH_PARAMETERS
1713  5B9C              ; *******************************************************************************************************
1714  5B9C              ; function to handle CALL BLIT basic extension
1715  5B9C              ; rotates 1-bit character drawing horizontally with mask and character data and
1716  5B9C              ; fuses with background data and applies vertical shift too
1717  5B9C              ; in form without pointers
1718  5B9C              ; BLIT ( INT x,
1719  5B9C              ;		 INT y,
1720  5B9C              ;		 INT char_data_pointer,
1721  5B9C              ;		 INT mask_data_pointer,
1722  5B9C              ;		 INT width (in characters),
1723  5B9C              ;		 INT height (in characters),
1724  5B9C              ;		 INT background_pointer (top left),
1725  5B9C              ;		 INT background_width (in characters),
1726  5B9C              ;		 INT background_height (in characters))
1727  5B9C              ; will put ram in page 0 also, page 1 is already there
1728  5B9C              BLIT:
1729  5B9C              	; opening (
1730  5B9C CD C4 56     	CALL CHKCHAR
1731  5B9F 28           	DB '('
1732  5BA0              	; get x coordinate
1733  5BA0 DD 21 2F 54  	LD IX, FRMQNT
1734  5BA4 CD 59 01     	CALL CALBAS
1735  5BA7 7B           	LD A, E
1736  5BA8 E6 07        	AND 7
1737  5BAA 32 18 54     	LD (BLIT_STRUCT+0), A
1738  5BAD CD 8A 5C     	CALL .DAdiv8
1739  5BB0 32 14 54     	LD (BLIT_TMP+0),A
1740  5BB3              	; comma
1741  5BB3 CD C4 56     	CALL CHKCHAR
1742  5BB6 2C           	DB ','
1743  5BB7              	; get y coordinate
1744  5BB7 DD 21 2F 54  	LD IX, FRMQNT
1745  5BBB CD 59 01     	CALL CALBAS
1746  5BBE 7B           	LD A, E
1747  5BBF E6 07        	AND 7
1748  5BC1 32 1A 54     	LD (BLIT_STRUCT+2), A
1749  5BC4 CD 8A 5C     	CALL .DAdiv8
1750  5BC7 32 15 54     	LD (BLIT_TMP+1),A
1751  5BCA              	; comma
1752  5BCA CD C4 56     	CALL CHKCHAR
1753  5BCD 2C           	DB ','
1754  5BCE              	; get char data pointer
1755  5BCE DD 21 2F 54  	LD IX, FRMQNT
1756  5BD2 CD 59 01     	CALL CALBAS
1757  5BD5 ED 53 22 54  	LD (BLIT_STRUCT+10), DE
1758  5BD9              	; comma
1759  5BD9 CD C4 56     	CALL CHKCHAR
1760  5BDC 2C           	DB ','
1761  5BDD              	; get mask data pointer
1762  5BDD DD 21 2F 54  	LD IX, FRMQNT
1763  5BE1 CD 59 01     	CALL CALBAS
1764  5BE4 ED 53 20 54  	LD (BLIT_STRUCT+8), DE
1765  5BE8              	; comma
1766  5BE8 CD C4 56     	CALL CHKCHAR
1767  5BEB 2C           	DB ','
1768  5BEC              	; get width
1769  5BEC DD 21 2F 54  	LD IX, FRMQNT
1770  5BF0 CD 59 01     	CALL CALBAS
1771  5BF3 7B           	LD A, E
1772  5BF4 32 26 54     	LD (BLIT_STRUCT+14), A
1773  5BF7              	; comma
1774  5BF7 CD C4 56     	CALL CHKCHAR
1775  5BFA 2C           	DB ','
1776  5BFB              	; get height
1777  5BFB DD 21 2F 54  	LD IX, FRMQNT
1778  5BFF CD 59 01     	CALL CALBAS
1779  5C02 7B           	LD A, E
1780  5C03 32 28 54     	LD (BLIT_STRUCT+16), A
1781  5C06              	; comma
1782  5C06 CD C4 56     	CALL CHKCHAR
1783  5C09 2C           	DB ','
1784  5C0A              	; get background pointer
1785  5C0A DD 21 2F 54  	LD IX, FRMQNT
1786  5C0E CD 59 01     	CALL CALBAS
1787  5C11 ED 53 1C 54  	LD (BLIT_STRUCT+4), DE
1788  5C15              	; comma
1789  5C15 CD C4 56     	CALL CHKCHAR
1790  5C18 2C           	DB ','
1791  5C19              	; get background width
1792  5C19 DD 21 2F 54  	LD IX, FRMQNT
1793  5C1D CD 59 01     	CALL CALBAS
1794  5C20 7B           	LD A, E
1795  5C21 32 16 54     	LD (BLIT_TMP+2), A
1796  5C24              	; comma
1797  5C24 CD C4 56     	CALL CHKCHAR
1798  5C27 2C           	DB ','
1799  5C28              	; get background height
1800  5C28 DD 21 2F 54  	LD IX, FRMQNT
1801  5C2C CD 59 01     	CALL CALBAS
1802  5C2F 7B           	LD A, E
1803  5C30 32 17 54     	LD (BLIT_TMP+3), A
1804  5C33              	; ending )
1805  5C33 CD C4 56     	CALL CHKCHAR
1806  5C36 29           	DB ')'
1807  5C37
1808  5C37 E5           	PUSH HL ; save position in BASIC buffer
1809  5C38
1810  5C38              	; calculate char&mask add to value
1811  5C38 26 00        	LD H, 0
1812  5C3A 3A 26 54     	LD A, (BLIT_STRUCT+14)
1813  5C3D 6F           	LD L, A
1814  5C3E CD B3 55     	CALL HLx8
1815  5C41 22 24 54     	LD (BLIT_STRUCT+12), HL
1816  5C44              	; calculate background add to value
1817  5C44 26 00        	LD H, 0
1818  5C46 3A 16 54     	LD A, (BLIT_TMP+2)
1819  5C49 6F           	LD L, A
1820  5C4A CD B3 55     	CALL HLx8
1821  5C4D 22 1E 54     	LD (BLIT_STRUCT+6), HL
1822  5C50              	; calculate pointer to background location
1823  5C50 21 00 00     	LD HL, 0
1824  5C53 3A 15 54     	LD A,(BLIT_TMP+1)
1825  5C56 B7           	OR A
1826  5C57 28 08        	JR Z, .L1
1827  5C59 47           	LD B,A
1828  5C5A ED 5B 1E 54  	LD DE,(BLIT_STRUCT+6)
1829  5C5E              .L0:
1830  5C5E 19           	ADD HL, DE
1831  5C5F 10 FD        	DJNZ .L0
1832  5C61              .L1:
1833  5C61 EB           	EX DE,HL
1834  5C62 26 00        	LD H,0
1835  5C64 3A 14 54     	LD A,(BLIT_TMP+0)
1836  5C67 6F           	LD L,A
1837  5C68 CD B3 55     	CALL HLx8
1838  5C6B 19           	ADD HL,DE
1839  5C6C ED 5B 1C 54  	LD DE,(BLIT_STRUCT+4)
1840  5C70 19           	ADD HL,DE
1841  5C71 22 1C 54     	LD (BLIT_STRUCT+4),HL
1842  5C74
1843  5C74 FD 21 7B 5C  	LD IY, .RET
1844  5C78 C3 77 56     	JP ENABLE_PAGE0
1845  5C7B              .RET:
1846  5C7B FB           	EI
1847  5C7C DD 21 18 54  	LD IX, BLIT_STRUCT
1848  5C80 CD 08 5B     	CALL SHIFT_MERGE_CHARACTER
1849  5C83
1850  5C83 D1               POP DE
1851  5C84 C1               POP BC
1852  5C85 CD EE 55         CALL RESTORE_PAGE_INFO
1853  5C88
1854  5C88 E1           	POP HL
1855  5C89 C9           	RET
1856  5C8A              .DAdiv8:
1857  5C8A 7B           	LD A,E
1858  5C8B CB 2A        	SRA D
1859  5C8D CB 1F            RR  A
1860  5C8F CB 2A            SRA D
1861  5C91 CB 1F            RR  A
1862  5C93 CB 2A            SRA D
1863  5C95 CB 1F            RR  A
1864  5C97 C9           	RET
1865  5C98              ; *******************************************************************************************************
1866  5C98               ENDIF
1867  5C98               ENDIF
1868  5C98
1869  5C98               IF (TILE_CMDS == 1)
1870  5C98              ; *******************************************************************************************************
1871  5C98              ; generic function to implement tiling
1872  5C98              ; should be modified to call appropriate function for memory or vram
1873  5C98              ; input IX=pointer to following structure
1874  5C98              ; +00 tile_data_ptr
1875  5C98              ; +02 tile_rows
1876  5C98              ; +04 tile_columns
1877  5C98              ; +06 destination_address
1878  5C98              ; +08 dest_to_next_row_add_to_value
1879  5C98              ; +10 num_horizontal_tiles
1880  5C98              ; +12 num_vertical_tiles
1881  5C98              ; modifies AF, BC, DE, HL
1882  5C98              TILE:
1883  5C98 DD 6E 06     	LD L, (IX+6)
1884  5C9B DD 66 07     	LD H, (IX+7) ; destination address
1885  5C9E 22 14 54     	LD (TILETMP1), HL
1886  5CA1 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1887  5CA4              .L1:
1888  5CA4 C5           	PUSH BC
1889  5CA5 DD 6E 00     		LD L, (IX+0)
1890  5CA8 DD 66 01     		LD H, (IX+1) ; tile address
1891  5CAB 22 16 54     		LD (TILETMP2), HL
1892  5CAE DD 46 02     		LD B, (IX+2) ; tile rows
1893  5CB1              .L2:
1894  5CB1 C5           		PUSH BC
1895  5CB2              .CALL1:
1896  5CB2 CD 00 00     			CALL 0
1897  5CB5 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1898  5CB8              .L3:
1899  5CB8 C5           			PUSH BC
1900  5CB9 2A 16 54     				LD HL, (TILETMP2)
1901  5CBC DD 46 04     				LD B, (IX+4) ; tile columns
1902  5CBF              .L4:
1903  5CBF C5           				PUSH BC
1904  5CC0              .CALL2:
1905  5CC0 CD 00 00     					CALL 0
1906  5CC3 C1           				POP BC
1907  5CC4 10 F9        				DJNZ .L4
1908  5CC6 C1           			POP BC
1909  5CC7 10 EF        			DJNZ .L3
1910  5CC9 22 16 54     			LD (TILETMP2), HL
1911  5CCC 2A 14 54     			LD HL, (TILETMP1)
1912  5CCF DD 5E 08     			LD E, (IX+8)
1913  5CD2 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1914  5CD5 19           			ADD HL, DE
1915  5CD6 22 14 54     			LD (TILETMP1), HL
1916  5CD9 C1           		POP BC
1917  5CDA 10 D5        		DJNZ .L2
1918  5CDC C1           	POP BC
1919  5CDD 10 C5        	DJNZ .L1
1920  5CDF C9           	RET
1921  5CE0              ; *******************************************************************************************************
1922  5CE0
1923  5CE0               IFNDEF CMDS_WITH_PARAMETERS
1924  5CE0 ~            ; *******************************************************************************************************
1925  5CE0 ~            ; function to handle CALL TILERAM basic extension
1926  5CE0 ~            ; fills memory with tiles
1927  5CE0 ~            ; TILERAM ( INT request_data_ptr )
1928  5CE0 ~            ; request_data_ptr described in TILE
1929  5CE0 ~            ; will put ram in page 0 also, page 1 is already there
1930  5CE0 ~            TILERAM:
1931  5CE0 ~            	; opening (
1932  5CE0 ~            	CALL CHKCHAR
1933  5CE0 ~            	DB '('
1934  5CE0 ~            	; get pointer to request struct
1935  5CE0 ~            	LD IX, FRMQNT
1936  5CE0 ~            	CALL CALBAS
1937  5CE0 ~            	PUSH DE
1938  5CE0 ~            	; ending )
1939  5CE0 ~            	CALL CHKCHAR
1940  5CE0 ~            	DB ')'
1941  5CE0 ~
1942  5CE0 ~            	POP IX ; pointer to request struct
1943  5CE0 ~
1944  5CE0 ~            	PUSH HL ; save position in BASIC buffer
1945  5CE0 ~
1946  5CE0 ~            	LD IY, .RET
1947  5CE0 ~            	JP ENABLE_PAGE0
1948  5CE0 ~            .RET:
1949  5CE0 ~            	EI
1950  5CE0 ~            	; set RAM functions to call
1951  5CE0 ~            	LD HL, .TILECOPY
1952  5CE0 ~            	LD (TILE.CALL2+1), HL
1953  5CE0 ~            	LD HL, .SETDESTROW
1954  5CE0 ~            	LD (TILE.CALL1+1), HL
1955  5CE0 ~            	LD A,1
1956  5CE0 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1957  5CE0 ~            	CALL TILE
1958  5CE0 ~            	XOR A
1959  5CE0 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1960  5CE0 ~
1961  5CE0 ~                POP DE
1962  5CE0 ~                POP BC
1963  5CE0 ~                CALL RESTORE_PAGE_INFO
1964  5CE0 ~
1965  5CE0 ~            	POP HL
1966  5CE0 ~            	RET
1967  5CE0 ~            .TILECOPY:
1968  5CE0 ~            	.8 LDI
1969  5CE0 ~            	RET
1970  5CE0 ~            .SETDESTROW:
1971  5CE0 ~            	LD DE, (TILETMP1)
1972  5CE0 ~            	RET
1973  5CE0 ~            ; *******************************************************************************************************
1974  5CE0               ENDIF
1975  5CE0
1976  5CE0               IFDEF CMDS_WITH_PARAMETERS
1977  5CE0              ; *******************************************************************************************************
1978  5CE0              ; function to handle CALL TILERAM basic extension
1979  5CE0              ; fills memory with tiles
1980  5CE0              ; TILERAM ( INT tile_data_pointer,
1981  5CE0              ;			INT tile_columns,
1982  5CE0              ;			INT tile_rows,
1983  5CE0              ;			INT destination_pointer,
1984  5CE0              ;			INT destination_columns,
1985  5CE0              ;			INT destination_rows,
1986  5CE0              ;			INT destination_begin_column,
1987  5CE0              ;			INT destination_begin_row,
1988  5CE0              ;			INT number_of_tiles_horizontally,
1989  5CE0              ;			INT	number_of_tiles_vertically )
1990  5CE0              ; will put ram in page 0 also, page 1 is already there
1991  5CE0              TILERAM:
1992  5CE0              	; opening (
1993  5CE0 CD C4 56     	CALL CHKCHAR
1994  5CE3 28           	DB '('
1995  5CE4              	; get tile data pointer coordinate
1996  5CE4 DD 21 2F 54  	LD IX, FRMQNT
1997  5CE8 CD 59 01     	CALL CALBAS
1998  5CEB ED 53 18 54  	LD (BLIT_STRUCT+0), DE
1999  5CEF              	; comma
2000  5CEF CD C4 56     	CALL CHKCHAR
2001  5CF2 2C           	DB ','
2002  5CF3              	; get tile columns
2003  5CF3 DD 21 2F 54  	LD IX, FRMQNT
2004  5CF7 CD 59 01     	CALL CALBAS
2005  5CFA ED 53 1C 54  	LD (BLIT_STRUCT+4), DE
2006  5CFE              	; comma
2007  5CFE CD C4 56     	CALL CHKCHAR
2008  5D01 2C           	DB ','
2009  5D02              	; get tile columns
2010  5D02 DD 21 2F 54  	LD IX, FRMQNT
2011  5D06 CD 59 01     	CALL CALBAS
2012  5D09 ED 53 1A 54  	LD (BLIT_STRUCT+2), DE
2013  5D0D              	; comma
2014  5D0D CD C4 56     	CALL CHKCHAR
2015  5D10 2C           	DB ','
2016  5D11              	; get destintion pointer
2017  5D11 DD 21 2F 54  	LD IX, FRMQNT
2018  5D15 CD 59 01     	CALL CALBAS
2019  5D18 ED 53 1E 54  	LD (BLIT_STRUCT+6), DE
2020  5D1C              	; comma
2021  5D1C CD C4 56     	CALL CHKCHAR
2022  5D1F 2C           	DB ','
2023  5D20              	; get destination columns
2024  5D20 DD 21 2F 54  	LD IX, FRMQNT
2025  5D24 CD 59 01     	CALL CALBAS
2026  5D27 7B           	LD A, E
2027  5D28 32 14 54     	LD (BLIT_TMP+0), A
2028  5D2B              	; comma
2029  5D2B CD C4 56     	CALL CHKCHAR
2030  5D2E 2C           	DB ','
2031  5D2F              	; get destination rows
2032  5D2F DD 21 2F 54  	LD IX, FRMQNT
2033  5D33 CD 59 01     	CALL CALBAS
2034  5D36 7B           	LD A, E
2035  5D37 32 15 54     	LD (BLIT_TMP+1), A
2036  5D3A              	; comma
2037  5D3A CD C4 56     	CALL CHKCHAR
2038  5D3D 2C           	DB ','
2039  5D3E              	; get destination begin column
2040  5D3E DD 21 2F 54  	LD IX, FRMQNT
2041  5D42 CD 59 01     	CALL CALBAS
2042  5D45 7B           	LD A, E
2043  5D46 32 16 54     	LD (BLIT_TMP+2), A
2044  5D49              	; comma
2045  5D49 CD C4 56     	CALL CHKCHAR
2046  5D4C 2C           	DB ','
2047  5D4D              	; get destination begin row
2048  5D4D DD 21 2F 54  	LD IX, FRMQNT
2049  5D51 CD 59 01     	CALL CALBAS
2050  5D54 7B           	LD A, E
2051  5D55 32 17 54     	LD (BLIT_TMP+3), A
2052  5D58              	; comma
2053  5D58 CD C4 56     	CALL CHKCHAR
2054  5D5B 2C           	DB ','
2055  5D5C              	; get number of tiles horizontally
2056  5D5C DD 21 2F 54  	LD IX, FRMQNT
2057  5D60 CD 59 01     	CALL CALBAS
2058  5D63 ED 53 22 54  	LD (BLIT_STRUCT+10), DE
2059  5D67              	; comma
2060  5D67 CD C4 56     	CALL CHKCHAR
2061  5D6A 2C           	DB ','
2062  5D6B              	; get number of tiles vertically
2063  5D6B DD 21 2F 54  	LD IX, FRMQNT
2064  5D6F CD 59 01     	CALL CALBAS
2065  5D72 ED 53 24 54  	LD (BLIT_STRUCT+12), DE
2066  5D76              	; ending )
2067  5D76 CD C4 56     	CALL CHKCHAR
2068  5D79 29           	DB ')'
2069  5D7A
2070  5D7A E5           	PUSH HL ; save position in BASIC buffer
2071  5D7B
2072  5D7B              	; calculate destination add to value
2073  5D7B 26 00        	LD H, 0
2074  5D7D 3A 14 54     	LD A, (BLIT_TMP+0)
2075  5D80 6F           	LD L, A
2076  5D81 CD B3 55     	CALL HLx8
2077  5D84 22 20 54     	LD (BLIT_STRUCT+8), HL
2078  5D87              	; calculate pointer to background location
2079  5D87 21 00 00     	LD HL, 0
2080  5D8A 3A 17 54     	LD A,(BLIT_TMP+3)
2081  5D8D B7           	OR A
2082  5D8E 28 08        	JR Z, .L1
2083  5D90 47           	LD B,A
2084  5D91 ED 5B 20 54  	LD DE,(BLIT_STRUCT+8)
2085  5D95              .L0:
2086  5D95 19           	ADD HL, DE
2087  5D96 10 FD        	DJNZ .L0
2088  5D98              .L1:
2089  5D98 EB           	EX DE,HL
2090  5D99 26 00        	LD H,0
2091  5D9B 3A 16 54     	LD A,(BLIT_TMP+2)
2092  5D9E 6F           	LD L,A
2093  5D9F CD B3 55     	CALL HLx8
2094  5DA2 19           	ADD HL,DE
2095  5DA3 ED 5B 1E 54  	LD DE,(BLIT_STRUCT+6)
2096  5DA7 19           	ADD HL,DE
2097  5DA8 22 1E 54     	LD (BLIT_STRUCT+6),HL
2098  5DAB
2099  5DAB FD 21 B2 5D  	LD IY, .RET
2100  5DAF C3 77 56     	JP ENABLE_PAGE0
2101  5DB2              .RET:
2102  5DB2 FB           	EI
2103  5DB3              	; set RAM functions to call
2104  5DB3 21 CD 5D     	LD HL, .TILECOPY
2105  5DB6 22 C1 5C     	LD (TILE.CALL2+1), HL
2106  5DB9 21 DE 5D     	LD HL, .SETDESTROW
2107  5DBC 22 B3 5C     	LD (TILE.CALL1+1), HL
2108  5DBF DD 21 18 54  	LD IX,BLIT_STRUCT
2109  5DC3 CD 98 5C     	CALL TILE
2110  5DC6
2111  5DC6 D1               POP DE
2112  5DC7 C1               POP BC
2113  5DC8 CD EE 55         CALL RESTORE_PAGE_INFO
2114  5DCB
2115  5DCB E1           	POP HL
2116  5DCC C9           	RET
2117  5DCD              .TILECOPY:
2118  5DCD ED A0       > LDI
2118  5DCF ED A0       > LDI
2118  5DD1 ED A0       > LDI
2118  5DD3 ED A0       > LDI
2118  5DD5 ED A0       > LDI
2118  5DD7 ED A0       > LDI
2118  5DD9 ED A0       > LDI
2118  5DDB ED A0       > LDI
2119  5DDD C9           	RET
2120  5DDE              .SETDESTROW:
2121  5DDE ED 5B 14 54  	LD DE, (TILETMP1)
2122  5DE2 C9           	RET
2123  5DE3              ; *******************************************************************************************************
2124  5DE3               ENDIF
2125  5DE3
2126  5DE3               IFDEF CMDS_WITH_PARAMETERS
2127  5DE3              ; *******************************************************************************************************
2128  5DE3              ; function to handle CALL TILEVRM basic extension
2129  5DE3              ; fills vram with tiles
2130  5DE3              ; TILEVRM ( INT tile_data_pointer,
2131  5DE3              ;			INT tile_columns,
2132  5DE3              ;			INT tile_rows,
2133  5DE3              ;			INT destination_begin_column,
2134  5DE3              ;			INT destination_begin_row,
2135  5DE3              ;			INT number_of_tiles_horizontally,
2136  5DE3              ;			INT	number_of_tiles_vertically )
2137  5DE3              ; will put ram in page 0 also, page 1 is already there
2138  5DE3              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2139  5DE3              TILEVRM:
2140  5DE3              	; opening (
2141  5DE3 CD C4 56     	CALL CHKCHAR
2142  5DE6 28           	DB '('
2143  5DE7              	; get tile data pointer coordinate
2144  5DE7 DD 21 2F 54  	LD IX, FRMQNT
2145  5DEB CD 59 01     	CALL CALBAS
2146  5DEE ED 53 18 54  	LD (BLIT_STRUCT+0), DE
2147  5DF2              	; comma
2148  5DF2 CD C4 56     	CALL CHKCHAR
2149  5DF5 2C           	DB ','
2150  5DF6              	; get tile columns
2151  5DF6 DD 21 2F 54  	LD IX, FRMQNT
2152  5DFA CD 59 01     	CALL CALBAS
2153  5DFD ED 53 1C 54  	LD (BLIT_STRUCT+4), DE
2154  5E01              	; comma
2155  5E01 CD C4 56     	CALL CHKCHAR
2156  5E04 2C           	DB ','
2157  5E05              	; get tile columns
2158  5E05 DD 21 2F 54  	LD IX, FRMQNT
2159  5E09 CD 59 01     	CALL CALBAS
2160  5E0C ED 53 1A 54  	LD (BLIT_STRUCT+2), DE
2161  5E10              	; comma
2162  5E10 CD C4 56     	CALL CHKCHAR
2163  5E13 2C           	DB ','
2164  5E14              	; get destination begin column
2165  5E14 DD 21 2F 54  	LD IX, FRMQNT
2166  5E18 CD 59 01     	CALL CALBAS
2167  5E1B 7B           	LD A, E
2168  5E1C 32 16 54     	LD (BLIT_TMP+2), A
2169  5E1F              	; comma
2170  5E1F CD C4 56     	CALL CHKCHAR
2171  5E22 2C           	DB ','
2172  5E23              	; get destination begin row
2173  5E23 DD 21 2F 54  	LD IX, FRMQNT
2174  5E27 CD 59 01     	CALL CALBAS
2175  5E2A 7B           	LD A, E
2176  5E2B 32 17 54     	LD (BLIT_TMP+3), A
2177  5E2E              	; comma
2178  5E2E CD C4 56     	CALL CHKCHAR
2179  5E31 2C           	DB ','
2180  5E32              	; get number of tiles horizontally
2181  5E32 DD 21 2F 54  	LD IX, FRMQNT
2182  5E36 CD 59 01     	CALL CALBAS
2183  5E39 ED 53 22 54  	LD (BLIT_STRUCT+10), DE
2184  5E3D              	; comma
2185  5E3D CD C4 56     	CALL CHKCHAR
2186  5E40 2C           	DB ','
2187  5E41              	; get number of tiles vertically
2188  5E41 DD 21 2F 54  	LD IX, FRMQNT
2189  5E45 CD 59 01     	CALL CALBAS
2190  5E48 ED 53 24 54  	LD (BLIT_STRUCT+12), DE
2191  5E4C              	; ending )
2192  5E4C CD C4 56     	CALL CHKCHAR
2193  5E4F 29           	DB ')'
2194  5E50
2195  5E50 E5           	PUSH HL ; save position in BASIC buffer
2196  5E51
2197  5E51              	; calculate destination add to value
2198  5E51 21 00 01     	LD HL, 256
2199  5E54 22 20 54     	LD (BLIT_STRUCT+8), HL
2200  5E57              	; calculate pointer to background location
2201  5E57 3A 17 54     	LD A,(BLIT_TMP+3)
2202  5E5A 67           	LD H,A
2203  5E5B 2E 00        	LD L,0
2204  5E5D EB           	EX DE,HL
2205  5E5E 26 00        	LD H,0
2206  5E60 3A 16 54     	LD A,(BLIT_TMP+2)
2207  5E63 6F           	LD L,A
2208  5E64 CD B3 55     	CALL HLx8
2209  5E67 19           	ADD HL,DE
2210  5E68 ED 5B CB F3  	LD DE,(GRPCGP)
2211  5E6C 19           	ADD HL,DE
2212  5E6D 22 1E 54     	LD (BLIT_STRUCT+6),HL
2213  5E70
2214  5E70 FD 21 77 5E  	LD IY, .RET
2215  5E74 C3 77 56     	JP ENABLE_PAGE0
2216  5E77              .RET:
2217  5E77 FB           	EI
2218  5E78              	; set RAM functions to call
2219  5E78 21 92 5E     	LD HL, .TILECOPY
2220  5E7B 22 C1 5C     	LD (TILE.CALL2+1), HL
2221  5E7E 21 98 5E     	LD HL, .SETDESTROW
2222  5E81 22 B3 5C     	LD (TILE.CALL1+1), HL
2223  5E84 DD 21 18 54  	LD IX,BLIT_STRUCT
2224  5E88 CD 98 5C     	CALL TILE
2225  5E8B
2226  5E8B D1               POP DE
2227  5E8C C1               POP BC
2228  5E8D CD EE 55         CALL RESTORE_PAGE_INFO
2229  5E90
2230  5E90 E1           	POP HL
2231  5E91 C9           	RET
2232  5E92              .TILECOPY:
2233  5E92 01 98 08     	LD BC, #0898
2234  5E95 C3 AB 55     	JP BBYTECOPY_NO_C
2235  5E98              .SETDESTROW:
2236  5E98 2A 14 54     	LD HL, (TILETMP1)
2237  5E9B F3           	DI
2238  5E9C CD 9E 55     	CALL SETWRT_LOCAL
2239  5E9F FB           	EI
2240  5EA0 C9           	RET
2241  5EA1              ; *******************************************************************************************************
2242  5EA1               ENDIF
2243  5EA1
2244  5EA1               IFNDEF CMDS_WITH_PARAMETERS
2245  5EA1 ~            ; *******************************************************************************************************
2246  5EA1 ~            ; function to handle CALL TILEVRM basic extension
2247  5EA1 ~            ; fills vram with tiles
2248  5EA1 ~            ; TILEVRM ( INT request_data_ptr )
2249  5EA1 ~            ; request_data_ptr described in TILE
2250  5EA1 ~            ; will put ram in page 0 also, page 1 is already there
2251  5EA1 ~            TILEVRM:
2252  5EA1 ~            	; opening (
2253  5EA1 ~            	CALL CHKCHAR
2254  5EA1 ~            	DB '('
2255  5EA1 ~            	; get pointer to request struct
2256  5EA1 ~            	LD IX, FRMQNT
2257  5EA1 ~            	CALL CALBAS
2258  5EA1 ~            	PUSH DE
2259  5EA1 ~            	; ending )
2260  5EA1 ~            	CALL CHKCHAR
2261  5EA1 ~            	DB ')'
2262  5EA1 ~
2263  5EA1 ~            	POP IX ; pointer to request struct
2264  5EA1 ~
2265  5EA1 ~            	PUSH HL ; save position in BASIC buffer
2266  5EA1 ~
2267  5EA1 ~            	LD IY, .RET
2268  5EA1 ~            	JP ENABLE_PAGE0
2269  5EA1 ~            .RET:
2270  5EA1 ~            	EI
2271  5EA1 ~            	; set RAM functions to call
2272  5EA1 ~            	LD HL, .TILECOPY
2273  5EA1 ~            	LD (TILE.CALL2+1), HL
2274  5EA1 ~            	LD HL, .SETDESTROW
2275  5EA1 ~            	LD (TILE.CALL1+1), HL
2276  5EA1 ~            	CALL TILE
2277  5EA1 ~
2278  5EA1 ~                POP DE
2279  5EA1 ~                POP BC
2280  5EA1 ~                CALL RESTORE_PAGE_INFO
2281  5EA1 ~
2282  5EA1 ~            	POP HL
2283  5EA1 ~            	RET
2284  5EA1 ~            .TILECOPY:
2285  5EA1 ~            	LD BC, #0898
2286  5EA1 ~            	JP BBYTECOPY_NO_C
2287  5EA1 ~            .SETDESTROW:
2288  5EA1 ~            	LD HL, (TILETMP1)
2289  5EA1 ~            	DI
2290  5EA1 ~            	CALL SETWRT_LOCAL
2291  5EA1 ~            	EI
2292  5EA1 ~            	RET
2293  5EA1 ~            ; *******************************************************************************************************
2294  5EA1               ENDIF
2295  5EA1               ENDIF
2296  5EA1
2297  5EA1               IF (BOX_CMDS == 1)
2298  5EA1              ; *******************************************************************************************************
2299  5EA1              ; generic function to implement rectangle data copy
2300  5EA1              ; should be modified to call appropriate function for memory or vram
2301  5EA1              ; input IX=pointer to following structure
2302  5EA1              ; +00 source data pointer
2303  5EA1              ; +02 num bytes in a row
2304  5EA1              ; +04 number of rows
2305  5EA1              ; +06 source add-to value till next row
2306  5EA1              ; +08 destination address
2307  5EA1              ; +10 destination add-to value till next row
2308  5EA1              ; modifies AF, BC, DE, HL
2309  5EA1              RECTANGLE_COPY:
2310  5EA1 DD 6E 00     	LD L, (IX+0)
2311  5EA4 DD 66 01     	LD H, (IX+1) ; source address
2312  5EA7 DD 5E 08     	LD E, (IX+8)
2313  5EAA DD 56 09     	LD D, (IX+9) ; destination
2314  5EAD DD 46 04     	LD B, (IX+4) ; row number
2315  5EB0              .L1:
2316  5EB0 C5           	PUSH BC
2317  5EB1 E5           		PUSH HL
2318  5EB2 D5           			PUSH DE
2319  5EB3 DD 4E 02     				LD C, (IX+2)
2320  5EB6 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2321  5EB9              .CALL1:
2322  5EB9 CD 00 00     				CALL 0 ; set destination address from DE
2323  5EBC              .CALL2:
2324  5EBC CD 00 00     				CALL 0 ; copy data fn
2325  5EBF E1           			POP HL
2326  5EC0 DD 4E 0A     			LD C, (IX+10)
2327  5EC3 DD 46 0B     			LD B, (IX+11) ; destination add-to
2328  5EC6 09           			ADD HL, BC
2329  5EC7 EB           			EX DE, HL
2330  5EC8 E1           		POP HL
2331  5EC9 DD 4E 06     		LD C, (IX+6)
2332  5ECC DD 46 07     		LD B, (IX+7) ; src add-to
2333  5ECF 09           		ADD HL, BC
2334  5ED0 C1           	POP BC
2335  5ED1 10 DD        	DJNZ .L1
2336  5ED3 C9           	RET
2337  5ED4              ; *******************************************************************************************************
2338  5ED4
2339  5ED4              ; *******************************************************************************************************
2340  5ED4              ; function to handle CALL BOXMEMCPY basic extension
2341  5ED4              ; copies data with window like boundaries to ram
2342  5ED4              ; BOXMEMCPY ( INT request_data_ptr )
2343  5ED4              ; request_data_ptr described in RECTANGLE_COPY
2344  5ED4              ; will put ram in page 0 also, page 1 is already there
2345  5ED4              BOXMEMCPY:
2346  5ED4              	; opening (
2347  5ED4 CD C4 56     	CALL CHKCHAR
2348  5ED7 28           	DB '('
2349  5ED8              	; get pointer to request struct
2350  5ED8 DD 21 2F 54  	LD IX, FRMQNT
2351  5EDC CD 59 01     	CALL CALBAS
2352  5EDF D5           	PUSH DE
2353  5EE0              	; ending )
2354  5EE0 CD C4 56     	CALL CHKCHAR
2355  5EE3 29           	DB ')'
2356  5EE4
2357  5EE4 DD E1        	POP IX ; pointer to request struct
2358  5EE6
2359  5EE6 E5           	PUSH HL ; save position in BASIC buffer
2360  5EE7
2361  5EE7 FD 21 EE 5E  	LD IY, .RET
2362  5EEB C3 77 56     	JP ENABLE_PAGE0
2363  5EEE              .RET:
2364  5EEE FB           	EI
2365  5EEF              	; set RAM functions to call
2366  5EEF 21 00 00     	LD HL, 0
2367  5EF2 22 B9 5E     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2368  5EF5 22 BB 5E     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2369  5EF8 21 ED B0     	LD HL, #B0ED ; LDIR
2370  5EFB 22 BD 5E     	LD (RECTANGLE_COPY.CALL1+4), HL
2371  5EFE CD A1 5E     	CALL RECTANGLE_COPY
2372  5F01
2373  5F01 D1               POP DE
2374  5F02 C1               POP BC
2375  5F03 CD EE 55         CALL RESTORE_PAGE_INFO
2376  5F06
2377  5F06 E1           	POP HL
2378  5F07 C9           	RET
2379  5F08              ; *******************************************************************************************************
2380  5F08
2381  5F08              ; *******************************************************************************************************
2382  5F08              ; function to handle CALL BOXMEMVRM basic extension
2383  5F08              ; copies data with window like boundaries to ram
2384  5F08              ; BOXMEMVRM ( INT request_data_ptr )
2385  5F08              ; request_data_ptr described in RECTANGLE_COPY
2386  5F08              ; will put ram in page 0 also, page 1 is already there
2387  5F08              BOXMEMVRM:
2388  5F08              	; opening (
2389  5F08 CD C4 56     	CALL CHKCHAR
2390  5F0B 28           	DB '('
2391  5F0C              	; get pointer to request struct
2392  5F0C DD 21 2F 54  	LD IX, FRMQNT
2393  5F10 CD 59 01     	CALL CALBAS
2394  5F13 D5           	PUSH DE
2395  5F14              	; ending )
2396  5F14 CD C4 56     	CALL CHKCHAR
2397  5F17 29           	DB ')'
2398  5F18
2399  5F18 DD E1        	POP IX ; pointer to request struct
2400  5F1A
2401  5F1A E5           	PUSH HL ; save position in BASIC buffer
2402  5F1B
2403  5F1B FD 21 22 5F  	LD IY, .RET
2404  5F1F C3 77 56     	JP ENABLE_PAGE0
2405  5F22              .RET:
2406  5F22 FB           	EI
2407  5F23              	; set RAM functions to call
2408  5F23 21 4A 5F     	LD HL, .SETDEST
2409  5F26 22 BA 5E     	LD (RECTANGLE_COPY.CALL1+1), HL
2410  5F29 21 52 5F     	LD HL, .COPYDATA
2411  5F2C 22 BD 5E     	LD (RECTANGLE_COPY.CALL2+1), HL
2412  5F2F 3E CD        	LD A, #CD ; CALL
2413  5F31 32 B9 5E     	LD (RECTANGLE_COPY.CALL1), A
2414  5F34 32 BC 5E     	LD (RECTANGLE_COPY.CALL2), A
2415  5F37 3E 01        	LD A,1
2416  5F39 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
2417  5F3C CD A1 5E     	CALL RECTANGLE_COPY
2418  5F3F AF           	XOR A
2419  5F40 32 29 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
2420  5F43
2421  5F43 D1               POP DE
2422  5F44 C1               POP BC
2423  5F45 CD EE 55         CALL RESTORE_PAGE_INFO
2424  5F48
2425  5F48 E1           	POP HL
2426  5F49 C9           	RET
2427  5F4A              .SETDEST:
2428  5F4A EB           	EX DE, HL
2429  5F4B F3           	DI
2430  5F4C CD 9E 55     	CALL SETWRT_LOCAL
2431  5F4F FB           	EI
2432  5F50 EB           	EX DE, HL
2433  5F51 C9           	RET
2434  5F52              .COPYDATA:
2435  5F52 41           	LD B, C
2436  5F53 C3 A9 55     	JP BBYTECOPY
2437  5F56              ; *******************************************************************************************************
2438  5F56               ENDIF
2439  5F56
2440  5F56              EXT_END:
2441  5F56
# file closed: asm\main.asm
