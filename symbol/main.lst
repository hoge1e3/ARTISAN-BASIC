# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000
  13  4000               DEFINE CMDS_WITH_PARAMETERS
  14  4000
  15  4000              CHPUT   EQU     #A2
  16  4000              CALBAS	EQU		#159
  17  4000              ERRHAND EQU     #406F
  18  4000              FRMEVL  EQU     #4C64
  19  4000              FRESTR	EQU		#67D0
  20  4000              ; FRMQNT = formula quantificator
  21  4000              ; input HL=pointer to current program expression
  22  4000              ; output HL=next address
  23  4000              ; output DE=integer datum
  24  4000              FRMQNT	EQU		#542F
  25  4000              ; GETBYT = get byte parameter
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output A=E=byte read
  29  4000              GETBYT		EQU		#521C
  30  4000              CHRGTR  	EQU     #4666
  31  4000              SYNCHR		EQU		#558C
  32  4000              VALTYP  	EQU     #F663
  33  4000              USR     	EQU     #F7F8
  34  4000              PROCNM		EQU		#FD89
  35  4000              BIOS_FILVRM EQU     #0056
  36  4000              CLIKSW		EQU		#F3DB
  37  4000              ATRBAS		EQU		#F928
  38  4000              GRPCGP		EQU		#F3CB
  39  4000
  40  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  41  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  42  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  43  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  44  4000              EXPTBL	EQU #FCC1
  45  4000              SCRMOD	EQU #FCAF ; current screen mode
  46  4000              REG1SAV EQU #F3E0 ; VDP(1)
  47  4000
  48  4000              ; BASIC error codes
  49  4000              ;01 NEXT without FOR
  50  4000              ;02 Syntax error
  51  4000              ;03 RETURN without GOSUB
  52  4000              ;04 Out of DATA
  53  4000              ;05 Illegal function call
  54  4000              ;06 Overflow
  55  4000              ;07 Out of memory
  56  4000              ;08 Undefined line number
  57  4000              ;09 Subscript out of range
  58  4000              ;10 Redimensioned array
  59  4000              ;11 Division by zero
  60  4000              ;12 Illegal direct
  61  4000              ;13 Type mismatch
  62  4000              ;14 Out of string space
  63  4000              ;15 String too long
  64  4000              ;16 String formula too complex
  65  4000              ;17 Can't CONTINUE
  66  4000              ;18 Undefined user function
  67  4000              ;19 Device I/O error
  68  4000              ;20 Verify error
  69  4000              ;21 No RESUME
  70  4000              ;22 RESUME without error
  71  4000              ;23 Unprintable error
  72  4000              ;24 Missing operand
  73  4000              ;25 Line buffer overflow
  74  4000              ;50 FIELD overflow
  75  4000              ;51 Internal error
  76  4000              ;52 Bad file number
  77  4000              ;53 File not found
  78  4000              ;54 File already open
  79  4000              ;55 Input past end
  80  4000              ;56 Bad file name
  81  4000              ;57 Direct statement in file
  82  4000              ;58 Sequential I/O only
  83  4000              ;59 File not OPEN
  84  4000
  85  4000
  86  4000               ; simulate cartridge with BASIC extension
  87  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  87  4004 45 51 00 00
  87  4008 00 00 00 00
  87  400C 00 00 00 00
  88  4010
  89  4010              ; this location #4010 stores last location used by basic extension
  90  4010              ; free memory after that point
  91  4010              FREEMEMPTR:
  92  4010 22 5A         DW EXT_END
  93  4012
  94  4012              ; this location #4012 stores extension version in DAA format
  95  4012              ; first byte is major version and second minor
  96  4012              VERSION:
  97  4012 00 70         DB #00, #70
  98  4014
  99  4014              ; binary included AKG player compiled at #4014
 100  4014               IF (SOUND_CMDS == 1)
 101  4014              	INCBIN "bin/AKG.bin"
 102  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 103  4CF0               ENDIF
 104  4CF0
 105  4CF0              ORIG.HTIMI:
 106  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 106  4CF4 00
 107  4CF5               EXPORT ORIG.HTIMI
 108  4CF5
 109  4CF5               IF (SOUND_CMDS == 1)
 110  4CF5              MUSIC_INIT_STATUS:
 111  4CF5 00            DB 0
 112  4CF6              SFX_INIT_STATUS:
 113  4CF6 00            DB 0
 114  4CF7              SOUND_ENABLED:
 115  4CF7 00            DB 0
 116  4CF8               ENDIF
 117  4CF8
 118  4CF8               IF (SPRITE_CMDS == 1)
 119  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 60 50     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 82 51     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 82 51     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 82 51     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 82 51     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 9A 51     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 9A 51     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 9A 51     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 82 51     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 82 51     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 82 51     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 82 51     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 82 51     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 82 51     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 9A 51     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 9A 51     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 82 51     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 82 51     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 82 51     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 82 51     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 82 51     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 75 50         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD BC 50         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD AC 50         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 120  4F4D               ENDIF
 121  4F4D
 122  4F4D              ; temp variables for BLIT, TILE functions
 123  4F4D               IF (BLIT_CMDS + TILE_CMDS > 0)
 124  4F4D              BLIT_TMP:
 125  4F4D              TILETMP1:
 126  4F4D              BLIT_TMP1:
 127  4F4D 00 00         DW 0
 128  4F4F              TILETMP2:
 129  4F4F              BLIT_TMP2:
 130  4F4F 00 00         DW 0
 131  4F51                IFDEF CMDS_WITH_PARAMETERS
 132  4F51              BLIT_STRUCT:
 133  4F51 00 00 00...   DS 17
 134  4F55                ENDIF
 135  4F55               ENDIF
 136  4F62
 137  4F62              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 138  4F62              ; per starting letter, if no commands with this letter, NULL value
 139  4F62              CMDS:
 140  4F62 00 00            DW 0 ; A
 141  4F64               IF (BLIT_CMDS + BOX_CMDS > 0)
 142  4F64 2B 50            DW CMDS_B ; B
 143  4F66               ELSE
 144  4F66 ~            	DW 0
 145  4F66               ENDIF
 146  4F66 00 00            DW 0 ; C
 147  4F68 00 00            DW 0 ; D
 148  4F6A 00 00            DW 0 ; E
 149  4F6C               IF (VRAM_CMDS + RAM_CMDS > 0)
 150  4F6C A9 4F            DW CMDS_F; F
 151  4F6E               ELSE
 152  4F6E ~            	DW 0
 153  4F6E               ENDIF
 154  4F6E               IF (GENCAL_CMD > 0)
 155  4F6E BC 4F            DW CMDS_G; G
 156  4F70               ELSE
 157  4F70 ~            	DW 0
 158  4F70               ENDIF
 159  4F70 00 00            DW 0 ; H
 160  4F72 00 00            DW 0 ; I
 161  4F74 00 00            DW 0 ; J
 162  4F76 00 00            DW 0 ; K
 163  4F78 00 00            DW 0 ; L
 164  4F7A               IF (VRAM_CMDS + RAM_CMDS > 0)
 165  4F7A 96 4F            DW CMDS_M ; M
 166  4F7C               ELSE
 167  4F7C ~            	DW 0
 168  4F7C               ENDIF
 169  4F7C 00 00            DW 0 ; N
 170  4F7E 00 00            DW 0 ; O
 171  4F80 00 00            DW 0 ; P
 172  4F82 00 00            DW 0 ; Q
 173  4F84 00 00            DW 0 ; R
 174  4F86               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 175  4F86 D0 4F            DW CMDS_S ; S
 176  4F88               ELSE
 177  4F88 ~            	DW 0
 178  4F88               ENDIF
 179  4F88               IF (TILE_CMDS > 0)
 180  4F88 4B 50            DW CMDS_T ; T
 181  4F8A               ELSE
 182  4F8A ~            	DW 0
 183  4F8A               ENDIF
 184  4F8A 00 00            DW 0 ; U
 185  4F8C               IF (VRAM_CMDS > 0)
 186  4F8C C6 4F            DW CMDS_V ; V
 187  4F8E               ELSE
 188  4F8E ~            	DW 0
 189  4F8E               ENDIF
 190  4F8E 00 00            DW 0 ; W
 191  4F90 00 00            DW 0 ; X
 192  4F92 00 00            DW 0 ; Y
 193  4F94 00 00            DW 0 ; Z
 194  4F96
 195  4F96              CMDS_M:
 196  4F96               IF (VRAM_CMDS == 1)
 197  4F96 4D 45 4D 56      DB "MEMVRM", 0
 197  4F9A 52 4D 00
 198  4F9D E2 52            DW MEMVRM
 199  4F9F               ENDIF
 200  4F9F               IF (RAM_CMDS == 1)
 201  4F9F 4D 45 4D 43  	DB "MEMCPY", 0
 201  4FA3 50 59 00
 202  4FA6 A1 51        	DW MEMCPY
 203  4FA8               ENDIF
 204  4FA8               IF (VRAM_CMDS + RAM_CMDS > 0)
 205  4FA8 00           	DB 0
 206  4FA9               ENDIF
 207  4FA9              CMDS_F:
 208  4FA9               IF (VRAM_CMDS == 1)
 209  4FA9 46 49 4C 56      DB "FILVRM", 0
 209  4FAD 52 4D 00
 210  4FB0 E4 51            DW FILVRM
 211  4FB2               ENDIF
 212  4FB2               IF (RAM_CMDS == 1)
 213  4FB2 46 49 4C 52      DB "FILRAM", 0
 213  4FB6 41 4D 00
 214  4FB9 2B 52            DW FILRAM
 215  4FBB               ENDIF
 216  4FBB               IF (VRAM_CMDS + RAM_CMDS > 0)
 217  4FBB 00               DB 0
 218  4FBC               ENDIF
 219  4FBC              CMDS_G:
 220  4FBC               IF (GENCAL_CMD == 1)
 221  4FBC 47 45 4E 43      DB "GENCAL", 0
 221  4FC0 41 4C 00
 222  4FC3 89 52            DW GENCAL
 223  4FC5               ENDIF
 224  4FC5               IF (GENCAL_CMD > 0)
 225  4FC5 00           	DB	0
 226  4FC6               ENDIF
 227  4FC6              CMDS_V:
 228  4FC6               IF (VRAM_CMDS == 1)
 229  4FC6 56 52 4D 4D  	DB "VRMMEM", 0
 229  4FCA 45 4D 00
 230  4FCD 5A 53        	DW VRMMEM
 231  4FCF               ENDIF
 232  4FCF               IF (VRAM_CMDS > 0)
 233  4FCF 00           	DB 0
 234  4FD0               ENDIF
 235  4FD0              CMDS_S:
 236  4FD0               IF (SPRITE_CMDS == 1)
 237  4FD0 53 50 52 53  	DB "SPRSET", 0
 237  4FD4 45 54 00
 238  4FD7 0E 4E        	DW SPRSET
 239  4FD9 53 50 52 47  	DB "SPRGRPMOV", 0
 239  4FDD 52 50 4D 4F
 239  4FE1 56 00
 240  4FE3 CC 4E        	DW SPRGRPMOV
 241  4FE5               ENDIF
 242  4FE5               IF (SOUND_CMDS == 1)
 243  4FE5 53 4E 44 53  	DB "SNDSFX", 0
 243  4FE9 46 58 00
 244  4FEC 98 54        	DW SNDSFX
 245  4FEE 53 4E 44 50  	DB "SNDPLYON", 0
 245  4FF2 4C 59 4F 4E
 245  4FF6 00
 246  4FF7 62 54        	DW SNDPLYON
 247  4FF9 53 4E 44 50  	DB "SNDPLYOFF", 0
 247  4FFD 4C 59 4F 46
 247  5001 46 00
 248  5003 75 54        	DW SNDPLYOFF
 249  5005 53 4E 44 50  	DB "SNDPLYINI", 0
 249  5009 4C 59 49 4E
 249  500D 49 00
 250  500F 18 54        	DW SNDPLYINIT
 251  5011               ENDIF
 252  5011               IF (SPRITE_CMDS == 1)
 253  5011 53 50 52 45  	DB "SPRENABLE", 0
 253  5015 4E 41 42 4C
 253  5019 45 00
 254  501B B9 4D        	DW SPRENABLE
 255  501D 53 50 52 44  	DB "SPRDISABLE", 0
 255  5021 49 53 41 42
 255  5025 4C 45 00
 256  5028 09 4E        	DW SPRDISABLE
 257  502A               ENDIF
 258  502A               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 259  502A 00           	DB 0
 260  502B               ENDIF
 261  502B              CMDS_B:
 262  502B               IF (BLIT_CMDS == 1)
 263  502B 42 4C 49 54  	DB "BLIT", 0
 263  502F 00
 264  5030 6F 56        	DW BLIT
 265  5032               ENDIF
 266  5032               IF (BOX_CMDS == 1)
 267  5032 42 4F 58 4D  	DB "BOXMEMCPY", 0
 267  5036 45 4D 43 50
 267  503A 59 00
 268  503C A7 59        	DW BOXMEMCPY
 269  503E 42 4F 58 4D  	DB "BOXMEMVRM", 0
 269  5042 45 4D 56 52
 269  5046 4D 00
 270  5048 DB 59        	DW BOXMEMVRM
 271  504A               ENDIF
 272  504A               IF (BLIT_CMDS + BOX_CMDS > 0)
 273  504A 00           	DB 0
 274  504B               ENDIF
 275  504B              CMDS_T:
 276  504B               IF (TILE_CMDS == 1)
 277  504B 54 49 4C 45  	DB "TILERAM", 0
 277  504F 52 41 4D 00
 278  5053 B3 57        	DW TILERAM
 279  5055 54 49 4C 45  	DB "TILEVRM", 0
 279  5059 56 52 4D 00
 280  505D B6 58        	DW TILEVRM
 281  505F               ENDIF
 282  505F               IF (TILE_CMDS > 0)
 283  505F 00           	DB 0
 284  5060               ENDIF
 285  5060
 286  5060               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 287  5060              ; ****************************************************************************************************
 288  5060              ; function sets VRAM address
 289  5060              ; input HL=address
 290  5060              ; modifies AF
 291  5060              SETWRT_LOCAL:
 292  5060 7D           	LD	A, L
 293  5061 D3 99        	OUT	(099H), A
 294  5063 7C           	LD	A, H
 295  5064 E6 3F        	AND	03FH
 296  5066 F6 40        	OR	040H
 297  5068 D3 99        	OUT	(099H), A
 298  506A C9           	RET
 299  506B              ; ****************************************************************************************************
 300  506B               ENDIF
 301  506B
 302  506B               IF (VRAM_CMDS + TILE_CMDS > 0)
 303  506B              ; ****************************************************************************************************
 304  506B              ; function copies data from RAM to VRAM
 305  506B              ; input HL=address in RAM
 306  506B              ; input B=count
 307  506B              ; modifies AF
 308  506B              BBYTECOPY:
 309  506B ED A3        	OUTI
 310  506D C2 6B 50     	JP	NZ, BBYTECOPY
 311  5070 C9           	RET
 312  5071              ; ****************************************************************************************************
 313  5071               ENDIF
 314  5071
 315  5071              ; ****************************************************************************************************
 316  5071              ; function multiplies HL by 8
 317  5071              HLx8:
 318  5071 29          > ADD HL, HL
 318  5072 29          > ADD HL, HL
 318  5073 29          > ADD HL, HL
 319  5074 C9           	RET
 320  5075              ; ****************************************************************************************************
 321  5075
 322  5075              ; ****************************************************************************************************
 323  5075              ; function gets slot and subslot data for specific page
 324  5075              ; input A=page (0, 1 or 2)
 325  5075              ; output B = 0A8H register value
 326  5075              ; output D = 0 is no subslots, 1 if yes
 327  5075              ; output C = 0A8H value when page 3 slot equals to requested page slot
 328  5075              ; output E = subslot value if present
 329  5075              ; modifies AF, BC, DE, HL
 330  5075              GET_PAGE_INFO:
 331  5075 6F               LD L, A
 332  5076 C6 C1            ADD A, low (EXPTBL)
 333  5078 32 82 50         LD (GET_PAGE_INFO_L1+1), A
 334  507B DB A8            IN A, (0A8H)
 335  507D 47               LD B, A
 336  507E E6 3F            AND 03FH
 337  5080 4F               LD C, A
 338  5081              GET_PAGE_INFO_L1:
 339  5081 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 340  5084 E6 80            AND 080H
 341  5086 28 1B            JR Z, GET_PAGE_INFO_L2
 342  5088                  ; expanded
 343  5088 2D               DEC L
 344  5089 FA A8 50         JP M, GET_PAGE_INFO_L3
 345  508C 2D               DEC L
 346  508D FA A6 50         JP M, GET_PAGE_INFO_L4
 347  5090                  ; page 2
 348  5090 07               RLCA
 349  5091 07               RLCA
 350  5092              GET_PAGE_INFO_L5:
 351  5092 E6 C0            AND 0C0H
 352  5094 B1               OR C
 353  5095 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 354  5097 4F               LD C, A
 355  5098 3A FF FF         LD A, (0FFFFH)
 356  509B 2F               CPL
 357  509C 5F               LD E, A
 358  509D 16 01            LD D, 1
 359  509F 78               LD A, B ; return stack
 360  50A0 D3 A8            OUT (0A8H), A
 361  50A2 C9               RET
 362  50A3              GET_PAGE_INFO_L2:
 363  50A3                  ; not expanded
 364  50A3 16 00            LD D, 0
 365  50A5 C9               RET
 366  50A6              GET_PAGE_INFO_L4:
 367  50A6                  ; page 1
 368  50A6 0F               RRCA
 369  50A7 0F               RRCA
 370  50A8              GET_PAGE_INFO_L3:
 371  50A8                  ; page 0
 372  50A8 0F               RRCA
 373  50A9 0F               RRCA
 374  50AA 18 E6            JR GET_PAGE_INFO_L5
 375  50AC              ; ****************************************************************************************************
 376  50AC
 377  50AC              ; ****************************************************************************************************
 378  50AC              ; function returns original slot and subslot info
 379  50AC              ; input B = 0A8H register value
 380  50AC              ; input D = 0 is no subslots, 1 if yes
 381  50AC              ; input C = 0A8H value when page 3 slot equals to requested page slot
 382  50AC              ; input E = subslot value if present
 383  50AC              ; modifies AF, disables interrupts
 384  50AC              RESTORE_PAGE_INFO:
 385  50AC 7A               LD A, D
 386  50AD B7               OR A
 387  50AE 28 08            JR Z, RESTORE_PAGE_INFO_L1
 388  50B0 79               LD A, C
 389  50B1 F3           	DI
 390  50B2 D3 A8            OUT (0A8H), A
 391  50B4 7B               LD A, E
 392  50B5 32 FF FF         LD (0FFFFH), A
 393  50B8              RESTORE_PAGE_INFO_L1:
 394  50B8 78               LD A, B
 395  50B9 D3 A8            OUT (0A8H), A
 396  50BB C9               RET
 397  50BC              ; ****************************************************************************************************
 398  50BC
 399  50BC              ; *******************************************************************************************************
 400  50BC              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 401  50BC              ; INPUT:  A = SLOT ID: EXXXSSPP
 402  50BC              ; E = EXPANDED FLAG
 403  50BC              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 404  50BC              ; PP = PRIMARY SLOT NUMBER
 405  50BC              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 406  50BC              ; CHANGES: AF, BC, DE
 407  50BC
 408  50BC              LOCAL_ENASLT:
 409  50BC CD DC 50         CALL L0353
 410  50BF FA C9 50         JP M, L0340
 411  50C2 DB A8            IN A, (0A8H)
 412  50C4 A1               AND C
 413  50C5 B0               OR B
 414  50C6 D3 A8            OUT (0A8H), A
 415  50C8 C9               RET
 416  50C9              L0340:
 417  50C9 E5               PUSH HL
 418  50CA CD 01 51         CALL L0378
 419  50CD 4F               LD C, A
 420  50CE 06 00            LD B, 0
 421  50D0 7D               LD A, L
 422  50D1 A4               AND H
 423  50D2 B2               OR D
 424  50D3 21 C5 FC         LD HL, 0FCC5H
 425  50D6 09               ADD HL, BC
 426  50D7 77               LD (HL), A
 427  50D8 E1               POP HL
 428  50D9 79               LD A, C
 429  50DA 18 E0            JR LOCAL_ENASLT
 430  50DC              L0353:
 431  50DC F3               DI
 432  50DD F5               PUSH AF
 433  50DE 7C               LD A, H
 434  50DF 07               RLCA
 435  50E0 07               RLCA
 436  50E1 E6 03            AND 3
 437  50E3 5F               LD E, A
 438  50E4 3E C0            LD A, 0C0H
 439  50E6              L035D:
 440  50E6 07               RLCA
 441  50E7 07               RLCA
 442  50E8 1D               DEC E
 443  50E9 F2 E6 50         JP P, L035D
 444  50EC 5F               LD E, A
 445  50ED 2F               CPL
 446  50EE 4F               LD C, A
 447  50EF F1               POP AF
 448  50F0 F5               PUSH AF
 449  50F1 E6 03            AND 3
 450  50F3 3C               INC A
 451  50F4 47               LD B, A
 452  50F5 3E AB            LD A, 0ABH
 453  50F7              L036E:
 454  50F7 C6 55            ADD A, 055H
 455  50F9 10 FC            DJNZ L036E
 456  50FB 57               LD D, A
 457  50FC A3               AND E
 458  50FD 47               LD B, A
 459  50FE F1               POP AF
 460  50FF A7               AND A
 461  5100 C9               RET
 462  5101              L0378:
 463  5101 F5               PUSH AF
 464  5102 7A               LD A, D
 465  5103 E6 C0            AND 0C0H
 466  5105 4F               LD C, A
 467  5106 F1               POP AF
 468  5107 F5               PUSH AF
 469  5108 57               LD D, A
 470  5109 DB A8            IN A, (0A8H)
 471  510B 47               LD B, A
 472  510C E6 3F            AND 03FH
 473  510E B1               OR C
 474  510F D3 A8            OUT (0A8H), A
 475  5111 7A               LD A, D
 476  5112 0F               RRCA
 477  5113 0F               RRCA
 478  5114 E6 03            AND 3
 479  5116 57               LD D, A
 480  5117 3E AB            LD A, 0ABH
 481  5119              L0390:
 482  5119 C6 55            ADD A, 055H
 483  511B 15               DEC D
 484  511C F2 19 51         JP P, L0390
 485  511F A3               AND E
 486  5120 57               LD D, A
 487  5121 7B               LD A, E
 488  5122 2F               CPL
 489  5123 67               LD H, A
 490  5124 3A FF FF         LD A, (0FFFFH)
 491  5127 2F               CPL
 492  5128 6F               LD L, A
 493  5129 A4               AND H
 494  512A B2               OR D
 495  512B 32 FF FF         LD (0FFFFH), A
 496  512E 78               LD A, B
 497  512F D3 A8            OUT (0A8H), A
 498  5131 F1               POP AF
 499  5132 E6 03            AND 3
 500  5134 C9               RET
 501  5135              ; *******************************************************************************************************
 502  5135
 503  5135              ; *******************************************************************************************************
 504  5135              ; some common code to activate page 0 and place values needed to restore original page on stack
 505  5135              ; input IY=return address
 506  5135              ENABLE_PAGE0:
 507  5135 AF               XOR A
 508  5136 CD 75 50         CALL GET_PAGE_INFO
 509  5139 C5               PUSH BC
 510  513A D5               PUSH DE
 511  513B 3A 41 F3         LD A, (RAMAD0)
 512  513E 26 00            LD H, 0
 513  5140 CD BC 50         CALL LOCAL_ENASLT
 514  5143 FD E9        	JP (IY)
 515  5145              ; *******************************************************************************************************
 516  5145
 517  5145              ; General BASIC CALL-instruction handler
 518  5145              CALLHAND:
 519  5145 E5           	PUSH HL
 520  5146 21 62 4F     	LD	HL, CMDS ; pointer table based on starting letter
 521  5149 3A 89 FD         LD A, (PROCNM)
 522  514C D6 41            SUB 'A'
 523  514E 87               ADD A, A
 524  514F 16 00            LD D, 0
 525  5151 5F               LD E, A
 526  5152 19               ADD HL, DE
 527  5153 5E               LD E, (HL)
 528  5154 23               INC HL
 529  5155 56               LD D, (HL)
 530  5156 7A               LD A, D
 531  5157 B3               OR E
 532  5158 28 23            JR Z, .CMDNOTRECOGNIZED
 533  515A EB               EX DE, HL
 534  515B              .CHKCMD:
 535  515B 11 89 FD     	LD	DE, PROCNM
 536  515E 1A           .LOOP:	LD	A,(DE)
 537  515F BE           	CP	(HL)
 538  5160 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 539  5162 13           	INC	DE
 540  5163 23           	INC	HL
 541  5164 A7           	AND	A
 542  5165 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 543  5167 5E           	LD	E,(HL)
 544  5168 23           	INC	HL
 545  5169 56           	LD	D,(HL)
 546  516A E1           	POP	HL		; routine address
 547  516B CD 8C 51     	CALL	GETPREVCHAR
 548  516E CD 80 51     	CALL	.CALLDE		; Call routine
 549  5171 A7           	AND	A
 550  5172 C9           	RET
 551  5173
 552  5173              .TONEXTCMD:
 553  5173 0E FF        	LD	C,0FFH
 554  5175 AF           	XOR	A
 555  5176 ED B1        	CPIR			; Skip to end of instruction name
 556  5178 23           	INC	HL
 557  5179 23           	INC	HL		; Skip address
 558  517A BE           	CP	(HL)
 559  517B 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 560  517D              .CMDNOTRECOGNIZED:
 561  517D E1           	POP	HL
 562  517E 37               SCF
 563  517F C9           	RET
 564  5180
 565  5180              .CALLDE:
 566  5180 D5           	PUSH	DE
 567  5181 C9           	RET
 568  5182
 569  5182              ;---------------------------
 570  5182
 571  5182              ;GETSTRPNT:
 572  5182              ; OUT:
 573  5182              ; HL = String Address
 574  5182              ; B  = Lenght
 575  5182              ;        LD      HL,(USR)
 576  5182              ;        LD      B,(HL)
 577  5182              ;        INC     HL
 578  5182              ;        LD      E,(HL)
 579  5182              ;        INC     HL
 580  5182              ;        LD      D,(HL)
 581  5182              ;        EX      DE,HL
 582  5182              ;        RET
 583  5182
 584  5182              ;EVALTXTPARAM:
 585  5182              ;	CALL	CHKCHAR
 586  5182              ;	DEFB	"("             ; Check for (
 587  5182              ;	LD	IX,FRMEVL
 588  5182              ;	CALL	CALBAS		; Evaluate expression
 589  5182              ;       LD      A,(VALTYP)
 590  5182              ;        CP      3               ; Text type?
 591  5182              ;        JP      NZ,TYPE_MISMATCH
 592  5182              ;        PUSH	HL
 593  5182              ;        LD	IX,FRESTR         ; Free the temporary string
 594  5182              ;        CALL	CALBAS
 595  5182              ;        POP	HL
 596  5182              ;	CALL	CHKCHAR
 597  5182              ;	DEFB	")"             ; Check for )
 598  5182              ;        RET
 599  5182
 600  5182
 601  5182              CHKCHAR:
 602  5182 CD 8C 51     	CALL	GETPREVCHAR	; Get previous basic char
 603  5185 E3           	EX	(SP),HL
 604  5186 BE           	CP	(HL) 	        ; Check if good char
 605  5187 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 606  5189 23           	INC	HL
 607  518A E3           	EX	(SP),HL
 608  518B 23           	INC	HL		; Get next basic char
 609  518C
 610  518C              GETPREVCHAR:
 611  518C 2B           	DEC	HL
 612  518D DD 21 66 46  	LD	IX,CHRGTR
 613  5191 C3 59 01     	JP      CALBAS
 614  5194
 615  5194
 616  5194              TYPE_MISMATCH:
 617  5194 1E 0D            LD E, 13 ; Type mismatch
 618  5196 18 02            JR THROW_ERROR
 619  5198
 620  5198              SYNTAX_ERROR:
 621  5198 1E 02            LD E, 2 ; Syntax error
 622  519A              THROW_ERROR:
 623  519A DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 624  519E C3 59 01     	JP	CALBAS
 625  51A1
 626  51A1              ;---------------------------
 627  51A1
 628  51A1               IF (RAM_CMDS == 1)
 629  51A1              ; *******************************************************************************************************
 630  51A1              ; function to handle CALL MEMCPY basic extension
 631  51A1              ; _MEMCPY ( INT source,
 632  51A1              ;			INT destination,
 633  51A1              ;			INT count,
 634  51A1              ; will put ram in page 0 also, page 1 is already there
 635  51A1              MEMCPY:
 636  51A1              	; opening (
 637  51A1 CD 82 51     	CALL CHKCHAR
 638  51A4 28           	DB '('
 639  51A5              	; get source address
 640  51A5 DD 21 2F 54  	LD IX, FRMQNT
 641  51A9 CD 59 01     	CALL CALBAS
 642  51AC D5           	PUSH DE
 643  51AD              	; comma
 644  51AD CD 82 51     	CALL CHKCHAR
 645  51B0 2C           	DB ','
 646  51B1              	; get destination address
 647  51B1 DD 21 2F 54  	LD IX, FRMQNT
 648  51B5 CD 59 01     	CALL CALBAS
 649  51B8 D5           	PUSH DE
 650  51B9              	; comma
 651  51B9 CD 82 51     	CALL CHKCHAR
 652  51BC 2C           	DB ','
 653  51BD              	; get length
 654  51BD DD 21 2F 54  	LD IX, FRMQNT
 655  51C1 CD 59 01     	CALL CALBAS
 656  51C4 D5           	PUSH DE
 657  51C5              	; ending )
 658  51C5 CD 82 51     	CALL CHKCHAR
 659  51C8 29           	DB ')'
 660  51C9
 661  51C9              	; save position
 662  51C9 E5           	PUSH HL
 663  51CA DD E1        	POP IX
 664  51CC
 665  51CC C1           	POP BC ; count
 666  51CD D1           	POP DE ; destination
 667  51CE E1           	POP HL ; source
 668  51CF D9           	EXX
 669  51D0              	; enable page 0
 670  51D0 FD 21 D7 51  	LD IY, .RET
 671  51D4 C3 35 51     	JP ENABLE_PAGE0
 672  51D7              .RET:
 673  51D7 FB           	EI
 674  51D8 D9           	EXX
 675  51D9 ED B0        	LDIR
 676  51DB D1               POP DE
 677  51DC C1               POP BC
 678  51DD CD AC 50         CALL RESTORE_PAGE_INFO
 679  51E0 DD E5        	PUSH IX
 680  51E2 E1           	POP HL
 681  51E3 C9           	RET
 682  51E4              ; *******************************************************************************************************
 683  51E4               ENDIF
 684  51E4
 685  51E4               IF (VRAM_CMDS == 1)
 686  51E4              ; *******************************************************************************************************
 687  51E4              ; function to handle CALL FILVRM basic extension
 688  51E4              ; FILVRM ( INT offset,
 689  51E4              ;		   INT count,
 690  51E4              ;		   BYTE value,
 691  51E4              ;		   BYTE wait_vsync) >0 = true
 692  51E4              ; wait_vsync will issue HALT before copying
 693  51E4              FILVRM:
 694  51E4              	; opening (
 695  51E4 CD 82 51     	CALL CHKCHAR
 696  51E7 28           	DB '('
 697  51E8              	; get offset address
 698  51E8 DD 21 2F 54  	LD IX, FRMQNT
 699  51EC CD 59 01     	CALL CALBAS
 700  51EF D5           	PUSH DE
 701  51F0              	; comma
 702  51F0 CD 82 51     	CALL CHKCHAR
 703  51F3 2C           	DB ','
 704  51F4              	; get count
 705  51F4 DD 21 2F 54  	LD IX, FRMQNT
 706  51F8 CD 59 01     	CALL CALBAS
 707  51FB D5           	PUSH DE
 708  51FC              	; comma
 709  51FC CD 82 51     	CALL CHKCHAR
 710  51FF 2C           	DB ','
 711  5200              	; get value
 712  5200 DD 21 1C 52  	LD IX, GETBYT
 713  5204 CD 59 01     	CALL CALBAS
 714  5207 F5           	PUSH AF
 715  5208              	; comma
 716  5208 CD 82 51     	CALL CHKCHAR
 717  520B 2C           	DB ','
 718  520C              	; get vsync wait
 719  520C DD 21 1C 52  	LD IX, GETBYT
 720  5210 CD 59 01     	CALL CALBAS
 721  5213 F5           	PUSH AF
 722  5214              	; ending )
 723  5214 CD 82 51     	CALL CHKCHAR
 724  5217 29           	DB ')'
 725  5218
 726  5218 FB               EI
 727  5219              	; save position
 728  5219 E5           	PUSH HL
 729  521A DD E1        	POP IX
 730  521C
 731  521C              	; syntax ok
 732  521C              	; wait for vsync if needed
 733  521C F1           	POP AF
 734  521D B7           	OR A
 735  521E 28 01        	JR Z, .L1
 736  5220 76           	HALT
 737  5221
 738  5221              .L1:
 739  5221 F1               POP AF ; value
 740  5222 C1               POP BC ; count
 741  5223 E1               POP HL ; offset
 742  5224 CD 56 00         CALL BIOS_FILVRM
 743  5227
 744  5227              .L3:
 745  5227 DD E5        	PUSH IX
 746  5229 E1           	POP HL
 747  522A C9           	RET
 748  522B              ; *******************************************************************************************************
 749  522B               ENDIF
 750  522B
 751  522B               IF (RAM_CMDS == 1)
 752  522B              ; *******************************************************************************************************
 753  522B              ; function to handle CALL FILRAM basic extension
 754  522B              ; FILRAM ( INT start address,
 755  522B              ;		   INT count,
 756  522B              ;		   BYTE value,
 757  522B              ; will put ram in page 0 also, page 1 is already there
 758  522B              FILRAM:
 759  522B              	; opening (
 760  522B CD 82 51     	CALL CHKCHAR
 761  522E 28           	DB '('
 762  522F              	; get start address
 763  522F DD 21 2F 54  	LD IX, FRMQNT
 764  5233 CD 59 01     	CALL CALBAS
 765  5236 D5           	PUSH DE
 766  5237              	; comma
 767  5237 CD 82 51     	CALL CHKCHAR
 768  523A 2C           	DB ','
 769  523B              	; get count
 770  523B DD 21 2F 54  	LD IX, FRMQNT
 771  523F CD 59 01     	CALL CALBAS
 772  5242 D5           	PUSH DE
 773  5243              	; comma
 774  5243 CD 82 51     	CALL CHKCHAR
 775  5246 2C           	DB ','
 776  5247              	; get value
 777  5247 DD 21 1C 52  	LD IX, GETBYT
 778  524B CD 59 01     	CALL CALBAS
 779  524E F5           	PUSH AF
 780  524F              	; ending )
 781  524F CD 82 51     	CALL CHKCHAR
 782  5252 29           	DB ')'
 783  5253
 784  5253              	; save position
 785  5253 E5           	PUSH HL
 786  5254 DD E1        	POP IX
 787  5256
 788  5256 D1           	POP DE ; actually AF
 789  5257 C1           	POP BC ; count
 790  5258 E1           	POP HL ; start address
 791  5259 78           	LD A, B
 792  525A B7           	OR A
 793  525B 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 794  525D B1           	OR C
 795  525E 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 796  5260 79           	LD A, C
 797  5261 3D           	DEC A
 798  5262 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 799  5264              	; one byte to fill
 800  5264 72           	LD (HL), D
 801  5265 18 12        	JR .EXIT
 802  5267              .L1:
 803  5267 D9           	EXX
 804  5268              	; enable page 0
 805  5268 FD 21 6F 52  	LD IY, .RET
 806  526C C3 35 51     	JP ENABLE_PAGE0
 807  526F              .RET:
 808  526F FB           	EI
 809  5270 D9           	EXX
 810  5271 CD 7D 52     	CALL .FILLVALUE
 811  5274 D1               POP DE
 812  5275 C1               POP BC
 813  5276 CD AC 50         CALL RESTORE_PAGE_INFO
 814  5279              .EXIT:
 815  5279 DD E5        	PUSH IX
 816  527B E1           	POP HL
 817  527C C9           	RET
 818  527D
 819  527D              .FILLVALUE:
 820  527D 72               LD (HL), D
 821  527E 54               LD D, H
 822  527F 5D               LD E, L
 823  5280 13               INC DE
 824  5281 0B               DEC BC
 825  5282 ED B0            LDIR
 826  5284 C9               RET
 827  5285              ; *******************************************************************************************************
 828  5285               ENDIF
 829  5285
 830  5285               IF (GENCAL_CMD == 1)
 831  5285              ; *******************************************************************************************************
 832  5285              ; function to handle CALL GENCAL basic extension
 833  5285              ; GENCAL ( INT fn_addr, = address of the function to call
 834  5285              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 835  5285              ; output values of reristers will also be stored at reg_list_ptr
 836  5285              GENCAL_VAR_SP:
 837  5285 00 00            DW 0
 838  5287              GENCAL_VAR_SP2:
 839  5287 00 00            DW 0
 840  5289              GENCAL:
 841  5289              	; opening (
 842  5289 CD 82 51     	CALL CHKCHAR
 843  528C 28           	DB '('
 844  528D              	; get function address
 845  528D DD 21 2F 54  	LD IX, FRMQNT
 846  5291 CD 59 01     	CALL CALBAS
 847  5294 D5           	PUSH DE
 848  5295              	; comma
 849  5295 CD 82 51     	CALL CHKCHAR
 850  5298 2C           	DB ','
 851  5299              	; get pointer to register list
 852  5299 DD 21 2F 54  	LD IX, FRMQNT
 853  529D CD 59 01     	CALL CALBAS
 854  52A0 D5           	PUSH DE
 855  52A1              	; ending )
 856  52A1 CD 82 51     	CALL CHKCHAR
 857  52A4 29           	DB ')'
 858  52A5
 859  52A5              	; save BASIC token position
 860  52A5 E5           	PUSH HL
 861  52A6 D9               EXX
 862  52A7 E1           	POP HL ; HL'=next basic token
 863  52A8 D9               EXX
 864  52A9
 865  52A9 E1               POP HL ; get pointer to register values
 866  52AA F3           	DI
 867  52AB ED 73 85 52      LD (GENCAL_VAR_SP), SP
 868  52AF F9               LD SP, HL
 869  52B0 F1               POP AF
 870  52B1 C1               POP BC
 871  52B2 D1               POP DE
 872  52B3 E1               POP HL
 873  52B4 DD E1            POP IX
 874  52B6 FD E1            POP IY
 875  52B8 D9               EXX
 876  52B9 ED 73 87 52      LD (GENCAL_VAR_SP2), SP
 877  52BD ED 7B 85 52      LD SP, (GENCAL_VAR_SP)
 878  52C1 FB               EI
 879  52C2 D1               POP DE ; get function to call
 880  52C3 E5               PUSH HL
 881  52C4 CD DF 52         CALL .EXXDECALL
 882  52C7 F3               DI
 883  52C8 ED 73 85 52      LD (GENCAL_VAR_SP), SP
 884  52CC ED 7B 87 52      LD SP, (GENCAL_VAR_SP2)
 885  52D0 FD E5            PUSH IY
 886  52D2 DD E5            PUSH IX
 887  52D4 E5               PUSH HL
 888  52D5 D5               PUSH DE
 889  52D6 C5               PUSH BC
 890  52D7 F5               PUSH AF
 891  52D8 ED 7B 85 52      LD SP, (GENCAL_VAR_SP)
 892  52DC FB               EI
 893  52DD E1               POP HL
 894  52DE C9           	RET
 895  52DF
 896  52DF              .EXXDECALL:
 897  52DF D5               PUSH DE
 898  52E0 D9               EXX
 899  52E1 C9               RET
 900  52E2              ; *******************************************************************************************************
 901  52E2               ENDIF
 902  52E2
 903  52E2               IF (VRAM_CMDS == 1)
 904  52E2              ; *******************************************************************************************************
 905  52E2              ; function to handle CALL MEMVRM basic extension
 906  52E2              ; copies from RAM to VRAM
 907  52E2              ; _MEMVRM ( INT source,
 908  52E2              ;			INT destination,
 909  52E2              ;			INT count,
 910  52E2              ;			BYTE wait_vsync) >0 = true
 911  52E2              ; will put ram in page 0 also, page 1 is already there
 912  52E2              ; wait_vsync will issue HALT before copying
 913  52E2              MEMVRM:
 914  52E2              	; opening (
 915  52E2 CD 82 51     	CALL CHKCHAR
 916  52E5 28           	DB '('
 917  52E6              	; get source address
 918  52E6 DD 21 2F 54  	LD IX, FRMQNT
 919  52EA CD 59 01     	CALL CALBAS
 920  52ED D5           	PUSH DE
 921  52EE              	; comma
 922  52EE CD 82 51     	CALL CHKCHAR
 923  52F1 2C           	DB ','
 924  52F2              	; get destination address
 925  52F2 DD 21 2F 54  	LD IX, FRMQNT
 926  52F6 CD 59 01     	CALL CALBAS
 927  52F9 D5           	PUSH DE
 928  52FA              	; comma
 929  52FA CD 82 51     	CALL CHKCHAR
 930  52FD 2C           	DB ','
 931  52FE              	; get length
 932  52FE DD 21 2F 54  	LD IX, FRMQNT
 933  5302 CD 59 01     	CALL CALBAS
 934  5305 D5           	PUSH DE
 935  5306              	; comma
 936  5306 CD 82 51     	CALL CHKCHAR
 937  5309 2C           	DB ','
 938  530A              	; get vsync wait
 939  530A DD 21 1C 52  	LD IX, GETBYT
 940  530E CD 59 01     	CALL CALBAS
 941  5311 F5           	PUSH AF
 942  5312              	; ending )
 943  5312 CD 82 51     	CALL CHKCHAR
 944  5315 29           	DB ')'
 945  5316
 946  5316                  ; save position in BASIC text
 947  5316 E5           	PUSH HL
 948  5317 DD E1        	POP IX
 949  5319
 950  5319 F1           	POP AF ; wait vsync
 951  531A B7           	OR A
 952  531B 28 03        	JR Z, .L1
 953  531D FB               EI
 954  531E 76           	HALT
 955  531F F3           	DI
 956  5320              .L1:
 957  5320              	; pop LDIR parameters and store away for later
 958  5320 C1           	POP BC ; count
 959  5321 D1           	POP DE ; vram destination
 960  5322 E1           	POP HL ; ram source
 961  5323 D9           	EXX
 962  5324 FD 21 2B 53   	LD IY, .RET
 963  5328 C3 35 51     	JP ENABLE_PAGE0
 964  532B              .RET:
 965  532B FB           	EI
 966  532C D9           	EXX
 967  532D CD 39 53     	CALL .LDIRVM
 968  5330 D1               POP DE
 969  5331 C1               POP BC
 970  5332 CD AC 50         CALL RESTORE_PAGE_INFO
 971  5335 DD E5        	PUSH IX
 972  5337 E1           	POP HL
 973  5338 C9           	RET
 974  5339
 975  5339              .LDIRVM:
 976  5339 EB           	EX DE, HL
 977  533A F3           	DI
 978  533B CD 60 50     	CALL SETWRT_LOCAL
 979  533E FB           	EI
 980  533F EB           	EX DE, HL
 981  5340 78           	LD A, B
 982  5341 B7           	OR A
 983  5342 28 0D        	JR Z, .L3
 984  5344 C5           	PUSH BC
 985  5345 0E 98        	LD C, #98
 986  5347              .L2:
 987  5347 50           	LD D, B
 988  5348 06 00        	LD B, 0
 989  534A CD 6B 50     	CALL BBYTECOPY
 990  534D 42           	LD B, D
 991  534E 10 F7        	DJNZ .L2
 992  5350 C1           	POP BC
 993  5351              .L3:
 994  5351 79           	LD A, C
 995  5352 B7           	OR A
 996  5353 C8           	RET Z
 997  5354 41           	LD B, C
 998  5355 0E 98        	LD C, #98
 999  5357 C3 6B 50     	JP BBYTECOPY
1000  535A              ; *******************************************************************************************************
1001  535A               ENDIF
1002  535A
1003  535A               IF (VRAM_CMDS == 1)
1004  535A              ; *******************************************************************************************************
1005  535A              ; function to handle CALL VRMMEM basic extension
1006  535A              ; copies from RAM to VRAM
1007  535A              ; _VRMMEM ( INT source,
1008  535A              ;			INT destination,
1009  535A              ;			INT count
1010  535A              ; will put ram in page 0 also, page 1 is already there
1011  535A              VRMMEM:
1012  535A              	; opening (
1013  535A CD 82 51     	CALL CHKCHAR
1014  535D 28           	DB '('
1015  535E              	; get source address
1016  535E DD 21 2F 54  	LD IX, FRMQNT
1017  5362 CD 59 01     	CALL CALBAS
1018  5365 D5           	PUSH DE
1019  5366              	; comma
1020  5366 CD 82 51     	CALL CHKCHAR
1021  5369 2C           	DB ','
1022  536A              	; get destination address
1023  536A DD 21 2F 54  	LD IX, FRMQNT
1024  536E CD 59 01     	CALL CALBAS
1025  5371 D5           	PUSH DE
1026  5372              	; comma
1027  5372 CD 82 51     	CALL CHKCHAR
1028  5375 2C           	DB ','
1029  5376              	; get length
1030  5376 DD 21 2F 54  	LD IX, FRMQNT
1031  537A CD 59 01     	CALL CALBAS
1032  537D D5           	PUSH DE
1033  537E              	; ending )
1034  537E CD 82 51     	CALL CHKCHAR
1035  5381 29           	DB ')'
1036  5382
1037  5382                  ; save position in BASIC text
1038  5382 E5           	PUSH HL
1039  5383 DD E1        	POP IX
1040  5385
1041  5385 C1           	POP BC ; count
1042  5386 D1           	POP DE ; destination
1043  5387 E1           	POP HL ; source
1044  5388 D9           	EXX
1045  5389 FD 21 90 53  	LD IY, .RET
1046  538D C3 35 51     	JP ENABLE_PAGE0
1047  5390              .RET:
1048  5390 FB           	EI
1049  5391 D9           	EXX
1050  5392 CD 9E 53     	CALL .LDIRMV
1051  5395 D1               POP DE
1052  5396 C1               POP BC
1053  5397 CD AC 50         CALL RESTORE_PAGE_INFO
1054  539A DD E5        	PUSH IX
1055  539C E1           	POP HL
1056  539D C9           	RET
1057  539E
1058  539E              .LDIRMV:
1059  539E              	; set VRAM address *exactly* as in ROM, otherwise corruption
1060  539E 7D           	LD	A, L
1061  539F F3           	DI
1062  53A0 D3 99        	OUT	(099H), A
1063  53A2 7C           	LD	A, H
1064  53A3 E6 3F        	AND	03FH
1065  53A5 D3 99        	OUT	(099H), A
1066  53A7 FB           	EI
1067  53A8              	;EX (SP), HL
1068  53A8              	;EX (SP), HL
1069  53A8              	;NOP
1070  53A8              	;NOP
1071  53A8              .L4:
1072  53A8 DB 98            IN A, (#98)
1073  53AA 12           	LD (DE), A
1074  53AB 13               INC DE
1075  53AC 0B               DEC BC
1076  53AD 79               LD A, C
1077  53AE B0               OR B
1078  53AF 20 F7            JR NZ, .L4
1079  53B1 C9               RET
1080  53B2              ; *******************************************************************************************************
1081  53B2               ENDIF
1082  53B2
1083  53B2              ; *******************************************************************************************************
1084  53B2              ; H.TIMI function
1085  53B2              MBGE_HTIMI:
1086  53B2               EXPORT MBGE_HTIMI
1087  53B2 F5           	PUSH AF
1088  53B3
1089  53B3               IF (SPRITE_CMDS == 1)
1090  53B3 CD 01 4D     	CALL SPRATR_UPDATE
1091  53B6               ENDIF
1092  53B6
1093  53B6               IF (SOUND_CMDS == 1)
1094  53B6 3A F7 4C     	LD A, (SOUND_ENABLED)
1095  53B9 B7           	OR A
1096  53BA 28 2A        	JR Z, .EXIT
1097  53BC
1098  53BC              	; enable page 2
1099  53BC 3E 02            LD A, 2
1100  53BE CD 75 50         CALL GET_PAGE_INFO
1101  53C1 C5               PUSH BC
1102  53C2 D5               PUSH DE
1103  53C3 3A 43 F3         LD A, (RAMAD2)
1104  53C6 26 80            LD H, 080H
1105  53C8 CD BC 50         CALL LOCAL_ENASLT
1106  53CB              	; enable page 0
1107  53CB AF               XOR A
1108  53CC CD 75 50         CALL GET_PAGE_INFO
1109  53CF C5               PUSH BC
1110  53D0 D5               PUSH DE
1111  53D1 3A 41 F3         LD A, (RAMAD0)
1112  53D4 26 00            LD H, 0
1113  53D6 CD BC 50         CALL LOCAL_ENASLT
1114  53D9
1115  53D9 CD 33 42     	CALL PLY_AKG_PLAY
1116  53DC
1117  53DC              	; restore page 0
1118  53DC D1               POP DE
1119  53DD C1               POP BC
1120  53DE CD AC 50         CALL RESTORE_PAGE_INFO
1121  53E1              	; restore page 2
1122  53E1 D1               POP DE
1123  53E2 C1               POP BC
1124  53E3 CD AC 50         CALL RESTORE_PAGE_INFO
1125  53E6               ENDIF
1126  53E6
1127  53E6              .EXIT:
1128  53E6 F1           	POP AF
1129  53E7 C3 F0 4C     	JP ORIG.HTIMI
1130  53EA              ; *******************************************************************************************************
1131  53EA
1132  53EA              ; *******************************************************************************************************
1133  53EA              ; interrupt handler when page 0 enabled
1134  53EA              VBLANK:
1135  53EA              	EXPORT VBLANK
1136  53EA
1137  53EA F5               PUSH AF
1138  53EB              	; is VDP originator ?
1139  53EB DB 99        	IN	A, (099H)
1140  53ED A7           	AND	A
1141  53EE F2 14 54     	JP P, .EXIT
1142  53F1
1143  53F1               IF (SOUND_CMDS == 1)
1144  53F1 3A F7 4C     	LD A, (SOUND_ENABLED)
1145  53F4 B7           	OR A
1146  53F5 28 1D        	JR Z, .EXIT
1147  53F7
1148  53F7 C5               PUSH BC
1149  53F8 D5               PUSH DE
1150  53F9 E5               PUSH HL
1151  53FA 08               EX AF, AF'
1152  53FB D9               EXX
1153  53FC F5               PUSH AF
1154  53FD C5               PUSH BC
1155  53FE D5               PUSH DE
1156  53FF E5               PUSH HL
1157  5400 DD E5            PUSH IX
1158  5402 FD E5            PUSH IY
1159  5404
1160  5404 CD 33 42     	CALL PLY_AKG_PLAY
1161  5407
1162  5407 FD E1            POP IY
1163  5409 DD E1            POP IX
1164  540B E1               POP HL
1165  540C D1               POP DE
1166  540D C1               POP BC
1167  540E F1               POP AF
1168  540F 08               EX AF, AF'
1169  5410 D9               EXX
1170  5411 E1               POP HL
1171  5412 D1               POP DE
1172  5413 C1               POP BC
1173  5414               ENDIF
1174  5414
1175  5414              .EXIT:
1176  5414 F1           	POP AF
1177  5415 FB           	EI
1178  5416 ED 4D        	RETI
1179  5418              ; *******************************************************************************************************
1180  5418
1181  5418               IF (SOUND_CMDS == 1)
1182  5418              ; *******************************************************************************************************
1183  5418              ; function to handle CALL SNDPLYINIT basic extension
1184  5418              ; initializes sound player
1185  5418              ; _SNDPLYINIT ( INT music_offset,
1186  5418              ;				INT sfx_offset, can be -1 if no SFX
1187  5418              ; will put ram in page 0 also, page 1 is already there
1188  5418              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1189  5418              SNDPLYINIT:
1190  5418              	; opening (
1191  5418 CD 82 51     	CALL CHKCHAR
1192  541B 28           	DB '('
1193  541C              	; get music address
1194  541C DD 21 2F 54  	LD IX, FRMQNT
1195  5420 CD 59 01     	CALL CALBAS
1196  5423 D5           	PUSH DE
1197  5424              	; comma
1198  5424 CD 82 51     	CALL CHKCHAR
1199  5427 2C           	DB ','
1200  5428              	; get sfx address
1201  5428 DD 21 2F 54  	LD IX, FRMQNT
1202  542C CD 59 01     	CALL CALBAS
1203  542F D5           	PUSH DE
1204  5430              	; ending )
1205  5430 CD 82 51     	CALL CHKCHAR
1206  5433 29           	DB ')'
1207  5434
1208  5434                  ; save position in BASIC text
1209  5434 44           	LD B, H
1210  5435 4D           	LD C, L
1211  5436
1212  5436              	; pop LDIR parameters and store away for later
1213  5436 D1           	POP DE ; sfx address
1214  5437 E1           	POP HL ; music address
1215  5438 C5           	PUSH BC ; basic text location
1216  5439 D9           	EXX
1217  543A FD 21 41 54  	LD IY, .RET
1218  543E C3 35 51     	JP ENABLE_PAGE0
1219  5441              .RET:
1220  5441 D9           	EXX
1221  5442
1222  5442 D5           	PUSH DE
1223  5443 AF           	XOR A
1224  5444              	; HL = music location
1225  5444 CD 62 41     	CALL PLY_AKG_INIT
1226  5447 3E 01        	LD A, 1
1227  5449 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1228  544C
1229  544C E1           	POP HL ; SFX
1230  544D              	; check if SFX address -1
1231  544D 23           	INC HL
1232  544E 7D           	LD A, L
1233  544F B4           	OR H
1234  5450 28 09        	JR Z,.L1
1235  5452 2B           	DEC HL
1236  5453 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1237  5456 3E 01        	LD A, 1
1238  5458 32 F6 4C     	LD (SFX_INIT_STATUS), A
1239  545B              .L1:
1240  545B D1               POP DE
1241  545C C1               POP BC
1242  545D CD AC 50         CALL RESTORE_PAGE_INFO
1243  5460
1244  5460 E1           	POP HL
1245  5461 C9           	RET
1246  5462              ; *******************************************************************************************************
1247  5462
1248  5462              ; *******************************************************************************************************
1249  5462              ; function to handle CALL SNDPLYON basic extension
1250  5462              ; enables sound player
1251  5462              ; _SNDPLYON
1252  5462              ; sets SOUND_ENABLED variable to 1 if init call was done
1253  5462              ; if not throws out of data error
1254  5462              SNDPLYON:
1255  5462 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1256  5465 B7           	OR A
1257  5466 20 05        	JR NZ, .L1
1258  5468              	; player not initialized, throw error
1259  5468 1E 04        	LD E, 04 ; Out of DATA
1260  546A C3 9A 51     	JP THROW_ERROR
1261  546D              .L1:
1262  546D 32 F7 4C     	LD (SOUND_ENABLED), A
1263  5470              	; disable key click
1264  5470 AF           	XOR A
1265  5471 32 DB F3     	LD (CLIKSW), A
1266  5474 C9           	RET
1267  5475              ; *******************************************************************************************************
1268  5475
1269  5475              ; *******************************************************************************************************
1270  5475              ; function to handle CALL SNDPLYOFF basic extension
1271  5475              ; disables sound player
1272  5475              ; _SNDPLYOFF
1273  5475              ; sets SOUND_ENABLED variable to 0
1274  5475              ; calls AKG to stop music and SFX on all channels if initialized
1275  5475              SNDPLYOFF:
1276  5475 3A F7 4C     	LD A, (SOUND_ENABLED)
1277  5478 B7           	OR A
1278  5479 C8           	RET Z ; already stopped
1279  547A AF           	XOR A
1280  547B 32 F7 4C     	LD (SOUND_ENABLED), A
1281  547E E5           	PUSH HL
1282  547F CD 21 42     	CALL PLY_AKG_STOP
1283  5482 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1284  5485 B7           	OR A
1285  5486 28 0E        	JR Z, .EXIT ; SFX not in use
1286  5488 AF           	XOR A
1287  5489 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1288  548C 3E 01        	LD A, 1
1289  548E CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1290  5491 3E 02        	LD A, 2
1291  5493 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1292  5496              .EXIT:
1293  5496 E1           	POP HL
1294  5497 C9           	RET
1295  5498              ; *******************************************************************************************************
1296  5498
1297  5498              ; *******************************************************************************************************
1298  5498              ; function to handle CALL SNDSFX basic extension
1299  5498              ; plays a sound effect
1300  5498              ; _SNDSFX ( BYTE sfx_number, >0
1301  5498              ;			BYTE channel, = 0,1 or 2
1302  5498              ;			BYTE inverted_volume = 0-16, 0 being full volume
1303  5498              ; will put ram in page 0 also, page 1 is already there
1304  5498              ; if sound off throws illegal function call
1305  5498              ; if sfx not initialized, throws out of data
1306  5498              SNDSFX:
1307  5498              	; opening (
1308  5498 CD 82 51     	CALL CHKCHAR
1309  549B 28           	DB '('
1310  549C              	; get sfx_number
1311  549C DD 21 1C 52  	LD IX, GETBYT
1312  54A0 CD 59 01     	CALL CALBAS
1313  54A3 D5           	PUSH DE
1314  54A4              	; comma
1315  54A4 CD 82 51     	CALL CHKCHAR
1316  54A7 2C           	DB ','
1317  54A8              	; get sfx address
1318  54A8 DD 21 1C 52  	LD IX, GETBYT
1319  54AC CD 59 01     	CALL CALBAS
1320  54AF D5           	PUSH DE
1321  54B0              	; comma
1322  54B0 CD 82 51     	CALL CHKCHAR
1323  54B3 2C           	DB ','
1324  54B4              	; get inverted volume
1325  54B4 DD 21 1C 52  	LD IX, GETBYT
1326  54B8 CD 59 01     	CALL CALBAS
1327  54BB D5           	PUSH DE
1328  54BC              	; ending )
1329  54BC CD 82 51     	CALL CHKCHAR
1330  54BF 29           	DB ')'
1331  54C0
1332  54C0 3A F7 4C     	LD A, (SOUND_ENABLED)
1333  54C3 B7           	OR A
1334  54C4 20 05        	JR NZ, .L1
1335  54C6              	; sound disabled, throw illegal function call
1336  54C6 1E 05        	LD E, 5
1337  54C8 C3 9A 51     	JP THROW_ERROR
1338  54CB              .L1:
1339  54CB 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1340  54CE B7           	OR A
1341  54CF 20 05        	JR NZ, .L2
1342  54D1              	; sfx data not initialized, throw out of data
1343  54D1 1E 04        	LD E, 4
1344  54D3 C3 9A 51     	JP THROW_ERROR
1345  54D6              .L2:
1346  54D6              	; pop  parameters and store away for later
1347  54D6 D1           	POP DE ; inverted volume
1348  54D7 43           	LD B, E
1349  54D8 D1           	POP DE ; channel
1350  54D9 4B           	LD C, E
1351  54DA D1           	POP DE
1352  54DB 7B           	LD A, E
1353  54DC 08           	EX AF, AF'
1354  54DD E5           	PUSH HL ; basic text location
1355  54DE D9           	EXX
1356  54DF FD 21 E6 54  	LD IY, .RET
1357  54E3 C3 35 51     	JP ENABLE_PAGE0
1358  54E6              .RET:
1359  54E6 D9           	EXX
1360  54E7 08           	EX AF, AF'
1361  54E8 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1362  54EB
1363  54EB D1               POP DE
1364  54EC C1               POP BC
1365  54ED CD AC 50         CALL RESTORE_PAGE_INFO
1366  54F0
1367  54F0 E1           	POP HL
1368  54F1 C9           	RET
1369  54F2              ; *******************************************************************************************************
1370  54F2               ENDIF
1371  54F2
1372  54F2               IF (BLIT_CMDS == 1)
1373  54F2              ; *******************************************************************************************************
1374  54F2              ; function rotates mask and data of several characters and applies to background data
1375  54F2              ; this handles x-shift from 0 to 4
1376  54F2              ; contains self-modifying code that is set-up from external function
1377  54F2              ; input HL=pointer to mask data
1378  54F2              ; input HL'=pointer to character data
1379  54F2              ; input DE=output buffer containing background data
1380  54F2              ; input BC=DE+8
1381  54F2              ; input A=number of characters to process
1382  54F2              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1383  54F2              SHIFT04:
1384  54F2 08           	EX AF, AF'
1385  54F3 7E           	LD A, (HL) ; get mask
1386  54F4 D9           	EXX
1387  54F5 57           	LD D, A
1388  54F6 1E FF        	LD E, #FF
1389  54F8 37           	SCF
1390  54F9              .M1:
1391  54F9 18 FE        	JR .M1 ; this is self-modifying part
1392  54FB CB 1A        	RR D
1393  54FD CB 1B        	RR E
1394  54FF CB 1A        	RR D
1395  5501 CB 1B        	RR E
1396  5503 CB 1A        	RR D
1397  5505 CB 1B        	RR E
1398  5507 CB 1A        	RR D
1399  5509 CB 1B        	RR E
1400  550B
1401  550B 46           	LD B, (HL) ; get data
1402  550C 0E 00        	LD C, 0
1403  550E              .M2:
1404  550E 18 FE        	JR .M2 ; also self-modifying part
1405  5510 CB 38        	SRL B
1406  5512 CB 19        	RR C
1407  5514 CB 38        	SRL B
1408  5516 CB 19        	RR C
1409  5518 CB 38        	SRL B
1410  551A CB 19        	RR C
1411  551C CB 38        	SRL B
1412  551E CB 19        	RR C
1413  5520
1414  5520 D9           	EXX
1415  5521 1A           	LD A, (DE) ; background
1416  5522 D9           	EXX
1417  5523 A2           	AND D
1418  5524 B0           	OR B
1419  5525 D9           	EXX
1420  5526 12           	LD (DE), A
1421  5527
1422  5527 0A           	LD A, (BC)
1423  5528 D9           	EXX
1424  5529 A3           	AND E
1425  552A B1           	OR C
1426  552B 23           	INC HL
1427  552C D9           	EXX
1428  552D 02           	LD (BC), A
1429  552E
1430  552E 23           	INC HL
1431  552F 13           	INC DE
1432  5530 03           	INC BC
1433  5531
1434  5531 08           	EX AF, AF'
1435  5532 3D           	DEC A
1436  5533 C2 F2 54     	JP NZ, SHIFT04
1437  5536 C9           	RET
1438  5537              ; *******************************************************************************************************
1439  5537
1440  5537              ; *******************************************************************************************************
1441  5537              ; function rotates mask and data of several characters and applies to background data
1442  5537              ; this handles x-shift from 5 to 8
1443  5537              ; contains self-modifying code that is set-up from external function
1444  5537              ; input HL=pointer to mask data
1445  5537              ; input HL'=pointer to character data
1446  5537              ; input DE=output buffer containing background data
1447  5537              ; input BC=DE+8
1448  5537              ; input A=number of characters to process
1449  5537              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1450  5537              SHIFT58:
1451  5537 08           	EX AF, AF'
1452  5538 7E           	LD A, (HL) ; get mask
1453  5539 D9           	EXX
1454  553A 57           	LD D, A
1455  553B 1E FF        	LD E, #FF
1456  553D 37           	SCF
1457  553E              .M1:
1458  553E 18 FE        	JR .M1 ; this is self-modifying part
1459  5540 CB 12        	RL D
1460  5542 CB 13        	RL E
1461  5544 CB 12        	RL D
1462  5546 CB 13        	RL E
1463  5548 CB 12        	RL D
1464  554A CB 13        	RL E
1465  554C
1466  554C 46           	LD B, (HL)
1467  554D 0E 00        	LD C, 0
1468  554F              .M2:
1469  554F 18 FE        	JR .M2 ; also self-modifying part
1470  5551 CB 20        	SLA B
1471  5553 CB 11        	RL C
1472  5555 CB 20        	SLA B
1473  5557 CB 11        	RL C
1474  5559 CB 20        	SLA B
1475  555B CB 11        	RL C
1476  555D
1477  555D D9           	EXX
1478  555E 1A           	LD A, (DE) ; background
1479  555F D9           	EXX
1480  5560 A3           	AND E
1481  5561 B1           	OR C
1482  5562 D9           	EXX
1483  5563 12           	LD (DE), A
1484  5564
1485  5564 0A           	LD A, (BC)
1486  5565 D9           	EXX
1487  5566 A2           	AND D
1488  5567 B0           	OR B
1489  5568 23           	INC HL
1490  5569 D9           	EXX
1491  556A 02           	LD (BC), A
1492  556B
1493  556B 23           	INC HL
1494  556C 13           	INC DE
1495  556D 03           	INC BC
1496  556E
1497  556E 08           	EX AF, AF'
1498  556F 3D           	DEC A
1499  5570 C2 37 55     	JP NZ, SHIFT58
1500  5573 C9           	RET
1501  5574              ; *******************************************************************************************************
1502  5574
1503  5574              ; *******************************************************************************************************
1504  5574              ; routine that shifts one row of characters
1505  5574              ; contains self-modifying code that is set-up from external function
1506  5574              ; input HL=pointer to mask data
1507  5574              ; input HL'=pointer to character data
1508  5574              ; input DE=output buffer containing background data
1509  5574              ; input A=number of characters to process
1510  5574              ; input IX=pointer to structure describing input data
1511  5574              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1512  5574              SHIFT_ROW:
1513  5574 F5           	PUSH AF
1514  5575 ED 53 4D 4F  		LD (BLIT_TMP1), DE
1515  5579 E5           		PUSH HL
1516  557A CD BD 55     			CALL .ADDYSHIFT
1517  557D E1           		POP HL
1518  557E ED 53 4F 4F  		LD (BLIT_TMP2), DE ; DE+vertical shift
1519  5582              .L1:
1520  5582 3E 08        		LD A, 8
1521  5584 DD 96 02     		SUB (IX+2) ; y shift
1522  5587              .CALL1:
1523  5587 CD 00 00     		CALL 0
1524  558A DD 7E 02     		LD A, (IX+2); y shift
1525  558D B7           		OR A
1526  558E 28 26        		JR Z, .DONE
1527  5590 ED 5B 4D 4F  		LD DE, (BLIT_TMP1)
1528  5594 E5           		PUSH HL
1529  5595 CD CB 55     			CALL .DETONEXTROW
1530  5598 E1           		POP HL
1531  5599              .CALL2:
1532  5599 CD 00 00     		CALL 0
1533  559C ED 5B 4D 4F  		LD DE, (BLIT_TMP1)
1534  55A0 E5           		PUSH HL
1535  55A1 CD C5 55     			CALL .ADD8
1536  55A4 E1           		POP HL
1537  55A5 ED 53 4D 4F  		LD (BLIT_TMP1), DE
1538  55A9 ED 5B 4F 4F  		LD DE, (BLIT_TMP2)
1539  55AD E5           		PUSH HL
1540  55AE CD C5 55     			CALL .ADD8
1541  55B1 E1           		POP HL
1542  55B2 ED 53 4F 4F  		LD (BLIT_TMP2), DE ; DE+vertical shift
1543  55B6              .DONE:
1544  55B6 F1           	POP AF
1545  55B7 3D           	DEC A
1546  55B8 C8           	RET Z
1547  55B9 F5           	PUSH AF
1548  55BA C3 82 55     	JP .L1
1549  55BD              .ADDYSHIFT:
1550  55BD EB           	EX DE, HL
1551  55BE 16 00        	LD D, 0
1552  55C0 DD 5E 02     	LD E, (IX+2); y shift
1553  55C3 18 0C        	JR .MOVDEBC
1554  55C5              .ADD8:
1555  55C5 21 08 00     	LD HL, 8
1556  55C8 C3 D1 55     	JP .MOVDEBC
1557  55CB              .DETONEXTROW:
1558  55CB DD 6E 06     	LD L, (IX+6)
1559  55CE DD 66 07     	LD H, (IX+7) ; bkg add to value
1560  55D1              .MOVDEBC:
1561  55D1 19           	ADD HL, DE
1562  55D2 54           	LD D, H
1563  55D3 5D           	LD E, L
1564  55D4 01 08 00     	LD BC, 8
1565  55D7 09           	ADD HL, BC
1566  55D8 44           	LD B, H
1567  55D9 4D           	LD C, L
1568  55DA C9           	RET
1569  55DB              ; *******************************************************************************************************
1570  55DB
1571  55DB              ; *******************************************************************************************************
1572  55DB              ; function rotates mask and character data and applies it to background
1573  55DB              ; input IX=pointer to structure describing input data
1574  55DB              ; +0  DW horizontal shift count 0-7 (low byte used)
1575  55DB              ; +2  DW vertical shift count 0-7 (low byte used)
1576  55DB              ; +4  DW background data start;
1577  55DB              ; +6  DW background add to value to next row of background data
1578  55DB              ; +8  DW mask data start;
1579  55DB              ; +10  DW character data start;
1580  55DB              ; +12 DW character&mask add to value to next row of data
1581  55DB              ; +14 DW columns (low byte used)
1582  55DB              ; +16 DW rows (low byte used)
1583  55DB              SHIFT_MERGE_CHARACTER:
1584  55DB DD 7E 00     	LD A, (IX) ; shift
1585  55DE FE 05        	CP 5
1586  55E0 38 25        	JR C, .RIGHT
1587  55E2              	; shifts 5-7, use rotate towards left 1-3
1588  55E2 21 37 55     	LD HL, SHIFT58
1589  55E5 22 88 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1590  55E8 22 9A 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1591  55EB D6 05        	SUB 5
1592  55ED 28 0D        	JR Z, .L1
1593  55EF 87           	ADD A, A
1594  55F0 87           	ADD A, A
1595  55F1 67           	LD H, A
1596  55F2 2E 18        	LD L, #18 ; JR opcode
1597  55F4 22 3E 55     	LD (SHIFT58.M1), HL
1598  55F7 22 4F 55     	LD (SHIFT58.M2), HL
1599  55FA 18 32        	JR .DO
1600  55FC              .L1:
1601  55FC 21 00 00     	LD HL, 0 ; 2xNOP opcode
1602  55FF 22 3E 55     	LD (SHIFT58.M1), HL
1603  5602 22 4F 55     	LD (SHIFT58.M2), HL
1604  5605 18 27        	JR .DO
1605  5607              .RIGHT:
1606  5607              	; shifts 0-4, rotate towards right
1607  5607 21 F2 54     	LD HL, SHIFT04
1608  560A 22 88 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1609  560D 22 9A 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1610  5610 FE 04        	CP 4
1611  5612 28 11        	JR Z, .R1
1612  5614 D6 04        	SUB 4
1613  5616 ED 44        	NEG
1614  5618 87           	ADD A, A
1615  5619 87           	ADD A, A
1616  561A 67           	LD H, A
1617  561B 2E 18        	LD L, #18 ; JR opcode
1618  561D 22 F9 54     	LD (SHIFT04.M1), HL
1619  5620 22 0E 55     	LD (SHIFT04.M2), HL
1620  5623 18 09        	JR .DO
1621  5625              .R1:
1622  5625 21 00 00     	LD HL, 0 ; 2xNOP opcode
1623  5628 22 F9 54     	LD (SHIFT04.M1), HL
1624  562B 22 0E 55     	LD (SHIFT04.M2), HL
1625  562E              .DO:
1626  562E DD 46 10     	LD B, (IX+16) ; rows
1627  5631 DD 6E 08     	LD L, (IX+8)
1628  5634 DD 66 09     	LD H, (IX+9) ; mask data
1629  5637 DD 5E 04     	LD E, (IX+4)
1630  563A DD 56 05     	LD D, (IX+5) ; background data
1631  563D D9           	EXX
1632  563E DD 6E 0A     	LD L, (IX+10)
1633  5641 DD 66 0B     	LD H, (IX+11) ; character data
1634  5644 D9           	EXX
1635  5645              .LOOP:
1636  5645 C5           	PUSH BC
1637  5646 E5           		PUSH HL
1638  5647 D5           			PUSH DE
1639  5648 D9           				EXX
1640  5649 E5           				PUSH HL
1641  564A D9           					EXX
1642  564B DD 7E 0E     					LD A, (IX+14) ; columns
1643  564E              .CALL:
1644  564E CD 74 55     					CALL SHIFT_ROW
1645  5651 E1           				POP HL
1646  5652 DD 5E 0C     				LD E, (IX+12)
1647  5655 DD 56 0D     				LD D, (IX+13) ; char data to next row
1648  5658 19           				ADD HL, DE
1649  5659 D9           				EXX
1650  565A E1           			POP HL
1651  565B DD 5E 06     			LD E, (IX+6)
1652  565E DD 56 07     			LD D, (IX+7) ; background to next row
1653  5661 19           			ADD HL, DE
1654  5662 EB           			EX DE, HL
1655  5663 E1           		POP HL
1656  5664 DD 4E 0C     		LD C, (IX+12)
1657  5667 DD 46 0D     		LD B, (IX+13) ; char data to next row
1658  566A 09           		ADD HL, BC
1659  566B C1           	POP BC
1660  566C 10 D7        	DJNZ .LOOP
1661  566E C9           	RET
1662  566F              ; *******************************************************************************************************
1663  566F
1664  566F               IFNDEF CMDS_WITH_PARAMETERS
1665  566F ~            ; *******************************************************************************************************
1666  566F ~            ; function to handle CALL BLIT basic extension
1667  566F ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1668  566F ~            ; fuses with background data and applies vertical shift too
1669  566F ~            ; BLIT ( INT request_data_ptr )
1670  566F ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1671  566F ~            ; will put ram in page 0 also, page 1 is already there
1672  566F ~            BLIT:
1673  566F ~            	; opening (
1674  566F ~            	CALL CHKCHAR
1675  566F ~            	DB '('
1676  566F ~            	; get pointer to request struct
1677  566F ~            	LD IX, FRMQNT
1678  566F ~            	CALL CALBAS
1679  566F ~            	PUSH DE
1680  566F ~            	; ending )
1681  566F ~            	CALL CHKCHAR
1682  566F ~            	DB ')'
1683  566F ~
1684  566F ~            	POP IX ; pointer to request struct
1685  566F ~
1686  566F ~            	PUSH HL ; save position in BASIC buffer
1687  566F ~
1688  566F ~            	LD IY, .RET
1689  566F ~            	JP ENABLE_PAGE0
1690  566F ~            .RET:
1691  566F ~            	EI
1692  566F ~            	CALL SHIFT_MERGE_CHARACTER
1693  566F ~
1694  566F ~                POP DE
1695  566F ~                POP BC
1696  566F ~                CALL RESTORE_PAGE_INFO
1697  566F ~
1698  566F ~            	POP HL
1699  566F ~            	RET
1700  566F ~            ; *******************************************************************************************************
1701  566F               ENDIF
1702  566F
1703  566F               IFDEF CMDS_WITH_PARAMETERS
1704  566F              ; *******************************************************************************************************
1705  566F              ; function to handle CALL BLIT basic extension
1706  566F              ; rotates 1-bit character drawing horizontally with mask and character data and
1707  566F              ; fuses with background data and applies vertical shift too
1708  566F              ; in form without pointers
1709  566F              ; BLIT ( INT x,
1710  566F              ;		 INT y,
1711  566F              ;		 INT char_data_pointer,
1712  566F              ;		 INT mask_data_pointer,
1713  566F              ;		 INT width (in characters),
1714  566F              ;		 INT height (in characters),
1715  566F              ;		 INT background_pointer (top left),
1716  566F              ;		 INT background_width (in characters),
1717  566F              ;		 INT background_height (in characters))
1718  566F              ; will put ram in page 0 also, page 1 is already there
1719  566F              BLIT:
1720  566F              	; opening (
1721  566F CD 82 51     	CALL CHKCHAR
1722  5672 28           	DB '('
1723  5673              	; get x coordinate
1724  5673 DD 21 2F 54  	LD IX, FRMQNT
1725  5677 CD 59 01     	CALL CALBAS
1726  567A 7B           	LD A, E
1727  567B E6 07        	AND 7
1728  567D 32 51 4F     	LD (BLIT_STRUCT+0), A
1729  5680 CD 5D 57     	CALL .DAdiv8
1730  5683 32 4D 4F     	LD (BLIT_TMP+0),A
1731  5686              	; comma
1732  5686 CD 82 51     	CALL CHKCHAR
1733  5689 2C           	DB ','
1734  568A              	; get y coordinate
1735  568A DD 21 2F 54  	LD IX, FRMQNT
1736  568E CD 59 01     	CALL CALBAS
1737  5691 7B           	LD A, E
1738  5692 E6 07        	AND 7
1739  5694 32 53 4F     	LD (BLIT_STRUCT+2), A
1740  5697 CD 5D 57     	CALL .DAdiv8
1741  569A 32 4E 4F     	LD (BLIT_TMP+1),A
1742  569D              	; comma
1743  569D CD 82 51     	CALL CHKCHAR
1744  56A0 2C           	DB ','
1745  56A1              	; get char data pointer
1746  56A1 DD 21 2F 54  	LD IX, FRMQNT
1747  56A5 CD 59 01     	CALL CALBAS
1748  56A8 ED 53 5B 4F  	LD (BLIT_STRUCT+10), DE
1749  56AC              	; comma
1750  56AC CD 82 51     	CALL CHKCHAR
1751  56AF 2C           	DB ','
1752  56B0              	; get mask data pointer
1753  56B0 DD 21 2F 54  	LD IX, FRMQNT
1754  56B4 CD 59 01     	CALL CALBAS
1755  56B7 ED 53 59 4F  	LD (BLIT_STRUCT+8), DE
1756  56BB              	; comma
1757  56BB CD 82 51     	CALL CHKCHAR
1758  56BE 2C           	DB ','
1759  56BF              	; get width
1760  56BF DD 21 2F 54  	LD IX, FRMQNT
1761  56C3 CD 59 01     	CALL CALBAS
1762  56C6 7B           	LD A, E
1763  56C7 32 5F 4F     	LD (BLIT_STRUCT+14), A
1764  56CA              	; comma
1765  56CA CD 82 51     	CALL CHKCHAR
1766  56CD 2C           	DB ','
1767  56CE              	; get height
1768  56CE DD 21 2F 54  	LD IX, FRMQNT
1769  56D2 CD 59 01     	CALL CALBAS
1770  56D5 7B           	LD A, E
1771  56D6 32 61 4F     	LD (BLIT_STRUCT+16), A
1772  56D9              	; comma
1773  56D9 CD 82 51     	CALL CHKCHAR
1774  56DC 2C           	DB ','
1775  56DD              	; get background pointer
1776  56DD DD 21 2F 54  	LD IX, FRMQNT
1777  56E1 CD 59 01     	CALL CALBAS
1778  56E4 ED 53 55 4F  	LD (BLIT_STRUCT+4), DE
1779  56E8              	; comma
1780  56E8 CD 82 51     	CALL CHKCHAR
1781  56EB 2C           	DB ','
1782  56EC              	; get background width
1783  56EC DD 21 2F 54  	LD IX, FRMQNT
1784  56F0 CD 59 01     	CALL CALBAS
1785  56F3 7B           	LD A, E
1786  56F4 32 4F 4F     	LD (BLIT_TMP+2), A
1787  56F7              	; comma
1788  56F7 CD 82 51     	CALL CHKCHAR
1789  56FA 2C           	DB ','
1790  56FB              	; get background height
1791  56FB DD 21 2F 54  	LD IX, FRMQNT
1792  56FF CD 59 01     	CALL CALBAS
1793  5702 7B           	LD A, E
1794  5703 32 50 4F     	LD (BLIT_TMP+3), A
1795  5706              	; ending )
1796  5706 CD 82 51     	CALL CHKCHAR
1797  5709 29           	DB ')'
1798  570A
1799  570A E5           	PUSH HL ; save position in BASIC buffer
1800  570B
1801  570B              	; calculate char&mask add to value
1802  570B 26 00        	LD H, 0
1803  570D 3A 5F 4F     	LD A, (BLIT_STRUCT+14)
1804  5710 6F           	LD L, A
1805  5711 CD 71 50     	CALL HLx8
1806  5714 22 5D 4F     	LD (BLIT_STRUCT+12), HL
1807  5717              	; calculate background add to value
1808  5717 26 00        	LD H, 0
1809  5719 3A 4F 4F     	LD A, (BLIT_TMP+2)
1810  571C 6F           	LD L, A
1811  571D CD 71 50     	CALL HLx8
1812  5720 22 57 4F     	LD (BLIT_STRUCT+6), HL
1813  5723              	; calculate pointer to background location
1814  5723 21 00 00     	LD HL, 0
1815  5726 3A 4E 4F     	LD A,(BLIT_TMP+1)
1816  5729 B7           	OR A
1817  572A 28 08        	JR Z, .L1
1818  572C 47           	LD B,A
1819  572D ED 5B 57 4F  	LD DE,(BLIT_STRUCT+6)
1820  5731              .L0:
1821  5731 19           	ADD HL, DE
1822  5732 10 FD        	DJNZ .L0
1823  5734              .L1:
1824  5734 EB           	EX DE,HL
1825  5735 26 00        	LD H,0
1826  5737 3A 4D 4F     	LD A,(BLIT_TMP+0)
1827  573A 6F           	LD L,A
1828  573B CD 71 50     	CALL HLx8
1829  573E 19           	ADD HL,DE
1830  573F ED 5B 55 4F  	LD DE,(BLIT_STRUCT+4)
1831  5743 19           	ADD HL,DE
1832  5744 22 55 4F     	LD (BLIT_STRUCT+4),HL
1833  5747
1834  5747 FD 21 4E 57  	LD IY, .RET
1835  574B C3 35 51     	JP ENABLE_PAGE0
1836  574E              .RET:
1837  574E FB           	EI
1838  574F DD 21 51 4F  	LD IX, BLIT_STRUCT
1839  5753 CD DB 55     	CALL SHIFT_MERGE_CHARACTER
1840  5756
1841  5756 D1               POP DE
1842  5757 C1               POP BC
1843  5758 CD AC 50         CALL RESTORE_PAGE_INFO
1844  575B
1845  575B E1           	POP HL
1846  575C C9           	RET
1847  575D              .DAdiv8:
1848  575D 7B           	LD A,E
1849  575E CB 2A        	SRA D
1850  5760 CB 1F            RR  A
1851  5762 CB 2A            SRA D
1852  5764 CB 1F            RR  A
1853  5766 CB 2A            SRA D
1854  5768 CB 1F            RR  A
1855  576A C9           	RET
1856  576B              ; *******************************************************************************************************
1857  576B               ENDIF
1858  576B               ENDIF
1859  576B
1860  576B               IF (TILE_CMDS == 1)
1861  576B              ; *******************************************************************************************************
1862  576B              ; generic function to implement tiling
1863  576B              ; should be modified to call appropriate function for memory or vram
1864  576B              ; input IX=pointer to following structure
1865  576B              ; +00 tile_data_ptr
1866  576B              ; +02 tile_rows
1867  576B              ; +04 tile_columns
1868  576B              ; +06 destination_address
1869  576B              ; +08 dest_to_next_row_add_to_value
1870  576B              ; +10 num_horizontal_tiles
1871  576B              ; +12 num_vertical_tiles
1872  576B              ; modifies AF, BC, DE, HL
1873  576B              TILE:
1874  576B DD 6E 06     	LD L, (IX+6)
1875  576E DD 66 07     	LD H, (IX+7) ; destination address
1876  5771 22 4D 4F     	LD (TILETMP1), HL
1877  5774 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1878  5777              .L1:
1879  5777 C5           	PUSH BC
1880  5778 DD 6E 00     		LD L, (IX+0)
1881  577B DD 66 01     		LD H, (IX+1) ; tile address
1882  577E 22 4F 4F     		LD (TILETMP2), HL
1883  5781 DD 46 02     		LD B, (IX+2) ; tile rows
1884  5784              .L2:
1885  5784 C5           		PUSH BC
1886  5785              .CALL1:
1887  5785 CD 00 00     			CALL 0
1888  5788 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1889  578B              .L3:
1890  578B C5           			PUSH BC
1891  578C 2A 4F 4F     				LD HL, (TILETMP2)
1892  578F DD 46 04     				LD B, (IX+4) ; tile columns
1893  5792              .L4:
1894  5792 C5           				PUSH BC
1895  5793              .CALL2:
1896  5793 CD 00 00     					CALL 0
1897  5796 C1           				POP BC
1898  5797 10 F9        				DJNZ .L4
1899  5799 C1           			POP BC
1900  579A 10 EF        			DJNZ .L3
1901  579C 22 4F 4F     			LD (TILETMP2), HL
1902  579F 2A 4D 4F     			LD HL, (TILETMP1)
1903  57A2 DD 5E 08     			LD E, (IX+8)
1904  57A5 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1905  57A8 19           			ADD HL, DE
1906  57A9 22 4D 4F     			LD (TILETMP1), HL
1907  57AC C1           		POP BC
1908  57AD 10 D5        		DJNZ .L2
1909  57AF C1           	POP BC
1910  57B0 10 C5        	DJNZ .L1
1911  57B2 C9           	RET
1912  57B3              ; *******************************************************************************************************
1913  57B3
1914  57B3               IFNDEF CMDS_WITH_PARAMETERS
1915  57B3 ~            ; *******************************************************************************************************
1916  57B3 ~            ; function to handle CALL TILERAM basic extension
1917  57B3 ~            ; fills memory with tiles
1918  57B3 ~            ; TILERAM ( INT request_data_ptr )
1919  57B3 ~            ; request_data_ptr described in TILE
1920  57B3 ~            ; will put ram in page 0 also, page 1 is already there
1921  57B3 ~            TILERAM:
1922  57B3 ~            	; opening (
1923  57B3 ~            	CALL CHKCHAR
1924  57B3 ~            	DB '('
1925  57B3 ~            	; get pointer to request struct
1926  57B3 ~            	LD IX, FRMQNT
1927  57B3 ~            	CALL CALBAS
1928  57B3 ~            	PUSH DE
1929  57B3 ~            	; ending )
1930  57B3 ~            	CALL CHKCHAR
1931  57B3 ~            	DB ')'
1932  57B3 ~
1933  57B3 ~            	POP IX ; pointer to request struct
1934  57B3 ~
1935  57B3 ~            	PUSH HL ; save position in BASIC buffer
1936  57B3 ~
1937  57B3 ~            	LD IY, .RET
1938  57B3 ~            	JP ENABLE_PAGE0
1939  57B3 ~            .RET:
1940  57B3 ~            	EI
1941  57B3 ~            	; set RAM functions to call
1942  57B3 ~            	LD HL, .TILECOPY
1943  57B3 ~            	LD (TILE.CALL2+1), HL
1944  57B3 ~            	LD HL, .SETDESTROW
1945  57B3 ~            	LD (TILE.CALL1+1), HL
1946  57B3 ~            	CALL TILE
1947  57B3 ~
1948  57B3 ~                POP DE
1949  57B3 ~                POP BC
1950  57B3 ~                CALL RESTORE_PAGE_INFO
1951  57B3 ~
1952  57B3 ~            	POP HL
1953  57B3 ~            	RET
1954  57B3 ~            .TILECOPY:
1955  57B3 ~            	.8 LDI
1956  57B3 ~            	RET
1957  57B3 ~            .SETDESTROW:
1958  57B3 ~            	LD DE, (TILETMP1)
1959  57B3 ~            	RET
1960  57B3 ~            ; *******************************************************************************************************
1961  57B3               ENDIF
1962  57B3
1963  57B3               IFDEF CMDS_WITH_PARAMETERS
1964  57B3              ; *******************************************************************************************************
1965  57B3              ; function to handle CALL TILERAM basic extension
1966  57B3              ; fills memory with tiles
1967  57B3              ; TILERAM ( INT tile_data_pointer,
1968  57B3              ;			INT tile_columns,
1969  57B3              ;			INT tile_rows,
1970  57B3              ;			INT destination_pointer,
1971  57B3              ;			INT destination_columns,
1972  57B3              ;			INT destination_rows,
1973  57B3              ;			INT destination_begin_column,
1974  57B3              ;			INT destination_begin_row,
1975  57B3              ;			INT number_of_tiles_horizontally,
1976  57B3              ;			INT	number_of_tiles_vertically )
1977  57B3              ; will put ram in page 0 also, page 1 is already there
1978  57B3              TILERAM:
1979  57B3              	; opening (
1980  57B3 CD 82 51     	CALL CHKCHAR
1981  57B6 28           	DB '('
1982  57B7              	; get tile data pointer coordinate
1983  57B7 DD 21 2F 54  	LD IX, FRMQNT
1984  57BB CD 59 01     	CALL CALBAS
1985  57BE ED 53 51 4F  	LD (BLIT_STRUCT+0), DE
1986  57C2              	; comma
1987  57C2 CD 82 51     	CALL CHKCHAR
1988  57C5 2C           	DB ','
1989  57C6              	; get tile columns
1990  57C6 DD 21 2F 54  	LD IX, FRMQNT
1991  57CA CD 59 01     	CALL CALBAS
1992  57CD ED 53 55 4F  	LD (BLIT_STRUCT+4), DE
1993  57D1              	; comma
1994  57D1 CD 82 51     	CALL CHKCHAR
1995  57D4 2C           	DB ','
1996  57D5              	; get tile columns
1997  57D5 DD 21 2F 54  	LD IX, FRMQNT
1998  57D9 CD 59 01     	CALL CALBAS
1999  57DC ED 53 53 4F  	LD (BLIT_STRUCT+2), DE
2000  57E0              	; comma
2001  57E0 CD 82 51     	CALL CHKCHAR
2002  57E3 2C           	DB ','
2003  57E4              	; get destintion pointer
2004  57E4 DD 21 2F 54  	LD IX, FRMQNT
2005  57E8 CD 59 01     	CALL CALBAS
2006  57EB ED 53 57 4F  	LD (BLIT_STRUCT+6), DE
2007  57EF              	; comma
2008  57EF CD 82 51     	CALL CHKCHAR
2009  57F2 2C           	DB ','
2010  57F3              	; get destination columns
2011  57F3 DD 21 2F 54  	LD IX, FRMQNT
2012  57F7 CD 59 01     	CALL CALBAS
2013  57FA 7B           	LD A, E
2014  57FB 32 4D 4F     	LD (BLIT_TMP+0), A
2015  57FE              	; comma
2016  57FE CD 82 51     	CALL CHKCHAR
2017  5801 2C           	DB ','
2018  5802              	; get destination rows
2019  5802 DD 21 2F 54  	LD IX, FRMQNT
2020  5806 CD 59 01     	CALL CALBAS
2021  5809 7B           	LD A, E
2022  580A 32 4E 4F     	LD (BLIT_TMP+1), A
2023  580D              	; comma
2024  580D CD 82 51     	CALL CHKCHAR
2025  5810 2C           	DB ','
2026  5811              	; get destination begin column
2027  5811 DD 21 2F 54  	LD IX, FRMQNT
2028  5815 CD 59 01     	CALL CALBAS
2029  5818 7B           	LD A, E
2030  5819 32 4F 4F     	LD (BLIT_TMP+2), A
2031  581C              	; comma
2032  581C CD 82 51     	CALL CHKCHAR
2033  581F 2C           	DB ','
2034  5820              	; get destination begin row
2035  5820 DD 21 2F 54  	LD IX, FRMQNT
2036  5824 CD 59 01     	CALL CALBAS
2037  5827 7B           	LD A, E
2038  5828 32 50 4F     	LD (BLIT_TMP+3), A
2039  582B              	; comma
2040  582B CD 82 51     	CALL CHKCHAR
2041  582E 2C           	DB ','
2042  582F              	; get number of tiles horizontally
2043  582F DD 21 2F 54  	LD IX, FRMQNT
2044  5833 CD 59 01     	CALL CALBAS
2045  5836 ED 53 5B 4F  	LD (BLIT_STRUCT+10), DE
2046  583A              	; comma
2047  583A CD 82 51     	CALL CHKCHAR
2048  583D 2C           	DB ','
2049  583E              	; get number of tiles vertically
2050  583E DD 21 2F 54  	LD IX, FRMQNT
2051  5842 CD 59 01     	CALL CALBAS
2052  5845 ED 53 5D 4F  	LD (BLIT_STRUCT+12), DE
2053  5849              	; ending )
2054  5849 CD 82 51     	CALL CHKCHAR
2055  584C 29           	DB ')'
2056  584D
2057  584D E5           	PUSH HL ; save position in BASIC buffer
2058  584E
2059  584E              	; calculate destination add to value
2060  584E 26 00        	LD H, 0
2061  5850 3A 4D 4F     	LD A, (BLIT_TMP+0)
2062  5853 6F           	LD L, A
2063  5854 CD 71 50     	CALL HLx8
2064  5857 22 59 4F     	LD (BLIT_STRUCT+8), HL
2065  585A              	; calculate pointer to background location
2066  585A 21 00 00     	LD HL, 0
2067  585D 3A 50 4F     	LD A,(BLIT_TMP+3)
2068  5860 B7           	OR A
2069  5861 28 08        	JR Z, .L1
2070  5863 47           	LD B,A
2071  5864 ED 5B 59 4F  	LD DE,(BLIT_STRUCT+8)
2072  5868              .L0:
2073  5868 19           	ADD HL, DE
2074  5869 10 FD        	DJNZ .L0
2075  586B              .L1:
2076  586B EB           	EX DE,HL
2077  586C 26 00        	LD H,0
2078  586E 3A 4F 4F     	LD A,(BLIT_TMP+2)
2079  5871 6F           	LD L,A
2080  5872 CD 71 50     	CALL HLx8
2081  5875 19           	ADD HL,DE
2082  5876 ED 5B 57 4F  	LD DE,(BLIT_STRUCT+6)
2083  587A 19           	ADD HL,DE
2084  587B 22 57 4F     	LD (BLIT_STRUCT+6),HL
2085  587E
2086  587E FD 21 85 58  	LD IY, .RET
2087  5882 C3 35 51     	JP ENABLE_PAGE0
2088  5885              .RET:
2089  5885 FB           	EI
2090  5886              	; set RAM functions to call
2091  5886 21 A0 58     	LD HL, .TILECOPY
2092  5889 22 94 57     	LD (TILE.CALL2+1), HL
2093  588C 21 B1 58     	LD HL, .SETDESTROW
2094  588F 22 86 57     	LD (TILE.CALL1+1), HL
2095  5892 DD 21 51 4F  	LD IX,BLIT_STRUCT
2096  5896 CD 6B 57     	CALL TILE
2097  5899
2098  5899 D1               POP DE
2099  589A C1               POP BC
2100  589B CD AC 50         CALL RESTORE_PAGE_INFO
2101  589E
2102  589E E1           	POP HL
2103  589F C9           	RET
2104  58A0              .TILECOPY:
2105  58A0 ED A0       > LDI
2105  58A2 ED A0       > LDI
2105  58A4 ED A0       > LDI
2105  58A6 ED A0       > LDI
2105  58A8 ED A0       > LDI
2105  58AA ED A0       > LDI
2105  58AC ED A0       > LDI
2105  58AE ED A0       > LDI
2106  58B0 C9           	RET
2107  58B1              .SETDESTROW:
2108  58B1 ED 5B 4D 4F  	LD DE, (TILETMP1)
2109  58B5 C9           	RET
2110  58B6              ; *******************************************************************************************************
2111  58B6               ENDIF
2112  58B6
2113  58B6               IFDEF CMDS_WITH_PARAMETERS
2114  58B6              ; *******************************************************************************************************
2115  58B6              ; function to handle CALL TILEVRM basic extension
2116  58B6              ; fills vram with tiles
2117  58B6              ; TILEVRM ( INT tile_data_pointer,
2118  58B6              ;			INT tile_columns,
2119  58B6              ;			INT tile_rows,
2120  58B6              ;			INT destination_begin_column,
2121  58B6              ;			INT destination_begin_row,
2122  58B6              ;			INT number_of_tiles_horizontally,
2123  58B6              ;			INT	number_of_tiles_vertically )
2124  58B6              ; will put ram in page 0 also, page 1 is already there
2125  58B6              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2126  58B6              TILEVRM:
2127  58B6              	; opening (
2128  58B6 CD 82 51     	CALL CHKCHAR
2129  58B9 28           	DB '('
2130  58BA              	; get tile data pointer coordinate
2131  58BA DD 21 2F 54  	LD IX, FRMQNT
2132  58BE CD 59 01     	CALL CALBAS
2133  58C1 ED 53 51 4F  	LD (BLIT_STRUCT+0), DE
2134  58C5              	; comma
2135  58C5 CD 82 51     	CALL CHKCHAR
2136  58C8 2C           	DB ','
2137  58C9              	; get tile columns
2138  58C9 DD 21 2F 54  	LD IX, FRMQNT
2139  58CD CD 59 01     	CALL CALBAS
2140  58D0 ED 53 55 4F  	LD (BLIT_STRUCT+4), DE
2141  58D4              	; comma
2142  58D4 CD 82 51     	CALL CHKCHAR
2143  58D7 2C           	DB ','
2144  58D8              	; get tile columns
2145  58D8 DD 21 2F 54  	LD IX, FRMQNT
2146  58DC CD 59 01     	CALL CALBAS
2147  58DF ED 53 53 4F  	LD (BLIT_STRUCT+2), DE
2148  58E3              	; comma
2149  58E3 CD 82 51     	CALL CHKCHAR
2150  58E6 2C           	DB ','
2151  58E7              	; get destination begin column
2152  58E7 DD 21 2F 54  	LD IX, FRMQNT
2153  58EB CD 59 01     	CALL CALBAS
2154  58EE 7B           	LD A, E
2155  58EF 32 4F 4F     	LD (BLIT_TMP+2), A
2156  58F2              	; comma
2157  58F2 CD 82 51     	CALL CHKCHAR
2158  58F5 2C           	DB ','
2159  58F6              	; get destination begin row
2160  58F6 DD 21 2F 54  	LD IX, FRMQNT
2161  58FA CD 59 01     	CALL CALBAS
2162  58FD 7B           	LD A, E
2163  58FE 32 50 4F     	LD (BLIT_TMP+3), A
2164  5901              	; comma
2165  5901 CD 82 51     	CALL CHKCHAR
2166  5904 2C           	DB ','
2167  5905              	; get number of tiles horizontally
2168  5905 DD 21 2F 54  	LD IX, FRMQNT
2169  5909 CD 59 01     	CALL CALBAS
2170  590C ED 53 5B 4F  	LD (BLIT_STRUCT+10), DE
2171  5910              	; comma
2172  5910 CD 82 51     	CALL CHKCHAR
2173  5913 2C           	DB ','
2174  5914              	; get number of tiles vertically
2175  5914 DD 21 2F 54  	LD IX, FRMQNT
2176  5918 CD 59 01     	CALL CALBAS
2177  591B ED 53 5D 4F  	LD (BLIT_STRUCT+12), DE
2178  591F              	; ending )
2179  591F CD 82 51     	CALL CHKCHAR
2180  5922 29           	DB ')'
2181  5923
2182  5923 E5           	PUSH HL ; save position in BASIC buffer
2183  5924
2184  5924              	; calculate destination add to value
2185  5924 21 00 01     	LD HL, 256
2186  5927 22 59 4F     	LD (BLIT_STRUCT+8), HL
2187  592A              	; calculate pointer to background location
2188  592A 3A 50 4F     	LD A,(BLIT_TMP+3)
2189  592D 67           	LD H,A
2190  592E 2E 00        	LD L,0
2191  5930 EB           	EX DE,HL
2192  5931 26 00        	LD H,0
2193  5933 3A 4F 4F     	LD A,(BLIT_TMP+2)
2194  5936 6F           	LD L,A
2195  5937 CD 71 50     	CALL HLx8
2196  593A 19           	ADD HL,DE
2197  593B ED 5B CB F3  	LD DE,(GRPCGP)
2198  593F 19           	ADD HL,DE
2199  5940 22 57 4F     	LD (BLIT_STRUCT+6),HL
2200  5943
2201  5943 FD 21 4A 59  	LD IY, .RET
2202  5947 C3 35 51     	JP ENABLE_PAGE0
2203  594A              .RET:
2204  594A FB           	EI
2205  594B              	; set RAM functions to call
2206  594B 21 65 59     	LD HL, .TILECOPY
2207  594E 22 94 57     	LD (TILE.CALL2+1), HL
2208  5951 21 6B 59     	LD HL, .SETDESTROW
2209  5954 22 86 57     	LD (TILE.CALL1+1), HL
2210  5957 DD 21 51 4F  	LD IX,BLIT_STRUCT
2211  595B CD 6B 57     	CALL TILE
2212  595E
2213  595E D1               POP DE
2214  595F C1               POP BC
2215  5960 CD AC 50         CALL RESTORE_PAGE_INFO
2216  5963
2217  5963 E1           	POP HL
2218  5964 C9           	RET
2219  5965              .TILECOPY:
2220  5965 01 98 08     	LD BC, #0898
2221  5968 C3 6B 50     	JP BBYTECOPY
2222  596B              .SETDESTROW:
2223  596B 2A 4D 4F     	LD HL, (TILETMP1)
2224  596E F3           	DI
2225  596F CD 60 50     	CALL SETWRT_LOCAL
2226  5972 FB           	EI
2227  5973 C9           	RET
2228  5974              ; *******************************************************************************************************
2229  5974               ENDIF
2230  5974
2231  5974               IFNDEF CMDS_WITH_PARAMETERS
2232  5974 ~            ; *******************************************************************************************************
2233  5974 ~            ; function to handle CALL TILEVRM basic extension
2234  5974 ~            ; fills vram with tiles
2235  5974 ~            ; TILEVRM ( INT request_data_ptr )
2236  5974 ~            ; request_data_ptr described in TILE
2237  5974 ~            ; will put ram in page 0 also, page 1 is already there
2238  5974 ~            TILEVRM:
2239  5974 ~            	; opening (
2240  5974 ~            	CALL CHKCHAR
2241  5974 ~            	DB '('
2242  5974 ~            	; get pointer to request struct
2243  5974 ~            	LD IX, FRMQNT
2244  5974 ~            	CALL CALBAS
2245  5974 ~            	PUSH DE
2246  5974 ~            	; ending )
2247  5974 ~            	CALL CHKCHAR
2248  5974 ~            	DB ')'
2249  5974 ~
2250  5974 ~            	POP IX ; pointer to request struct
2251  5974 ~
2252  5974 ~            	PUSH HL ; save position in BASIC buffer
2253  5974 ~
2254  5974 ~            	LD IY, .RET
2255  5974 ~            	JP ENABLE_PAGE0
2256  5974 ~            .RET:
2257  5974 ~            	EI
2258  5974 ~            	; set RAM functions to call
2259  5974 ~            	LD HL, .TILECOPY
2260  5974 ~            	LD (TILE.CALL2+1), HL
2261  5974 ~            	LD HL, .SETDESTROW
2262  5974 ~            	LD (TILE.CALL1+1), HL
2263  5974 ~            	CALL TILE
2264  5974 ~
2265  5974 ~                POP DE
2266  5974 ~                POP BC
2267  5974 ~                CALL RESTORE_PAGE_INFO
2268  5974 ~
2269  5974 ~            	POP HL
2270  5974 ~            	RET
2271  5974 ~            .TILECOPY:
2272  5974 ~            	LD BC, #0898
2273  5974 ~            	JP BBYTECOPY
2274  5974 ~            .SETDESTROW:
2275  5974 ~            	LD HL, (TILETMP1)
2276  5974 ~            	DI
2277  5974 ~            	CALL SETWRT_LOCAL
2278  5974 ~            	EI
2279  5974 ~            	RET
2280  5974 ~            ; *******************************************************************************************************
2281  5974               ENDIF
2282  5974               ENDIF
2283  5974
2284  5974               IF (BOX_CMDS == 1)
2285  5974              ; *******************************************************************************************************
2286  5974              ; generic function to implement rectangle data copy
2287  5974              ; should be modified to call appropriate function for memory or vram
2288  5974              ; input IX=pointer to following structure
2289  5974              ; +00 source data pointer
2290  5974              ; +02 num bytes in a row
2291  5974              ; +04 number of rows
2292  5974              ; +06 source add-to value till next row
2293  5974              ; +08 destination address
2294  5974              ; +10 destination add-to value till next row
2295  5974              ; modifies AF, BC, DE, HL
2296  5974              RECTANGLE_COPY:
2297  5974 DD 6E 00     	LD L, (IX+0)
2298  5977 DD 66 01     	LD H, (IX+1) ; source address
2299  597A DD 5E 08     	LD E, (IX+8)
2300  597D DD 56 09     	LD D, (IX+9) ; destination
2301  5980 DD 46 04     	LD B, (IX+4) ; row number
2302  5983              .L1:
2303  5983 C5           	PUSH BC
2304  5984 E5           		PUSH HL
2305  5985 D5           			PUSH DE
2306  5986 DD 4E 02     				LD C, (IX+2)
2307  5989 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2308  598C              .CALL1:
2309  598C CD 00 00     				CALL 0 ; set destination address from DE
2310  598F              .CALL2:
2311  598F CD 00 00     				CALL 0 ; copy data fn
2312  5992 E1           			POP HL
2313  5993 DD 4E 0A     			LD C, (IX+10)
2314  5996 DD 46 0B     			LD B, (IX+11) ; destination add-to
2315  5999 09           			ADD HL, BC
2316  599A EB           			EX DE, HL
2317  599B E1           		POP HL
2318  599C DD 4E 06     		LD C, (IX+6)
2319  599F DD 46 07     		LD B, (IX+7) ; src add-to
2320  59A2 09           		ADD HL, BC
2321  59A3 C1           	POP BC
2322  59A4 10 DD        	DJNZ .L1
2323  59A6 C9           	RET
2324  59A7              ; *******************************************************************************************************
2325  59A7
2326  59A7              ; *******************************************************************************************************
2327  59A7              ; function to handle CALL BOXMEMCPY basic extension
2328  59A7              ; copies data with window like boundaries to ram
2329  59A7              ; BOXMEMCPY ( INT request_data_ptr )
2330  59A7              ; request_data_ptr described in RECTANGLE_COPY
2331  59A7              ; will put ram in page 0 also, page 1 is already there
2332  59A7              BOXMEMCPY:
2333  59A7              	; opening (
2334  59A7 CD 82 51     	CALL CHKCHAR
2335  59AA 28           	DB '('
2336  59AB              	; get pointer to request struct
2337  59AB DD 21 2F 54  	LD IX, FRMQNT
2338  59AF CD 59 01     	CALL CALBAS
2339  59B2 D5           	PUSH DE
2340  59B3              	; ending )
2341  59B3 CD 82 51     	CALL CHKCHAR
2342  59B6 29           	DB ')'
2343  59B7
2344  59B7 DD E1        	POP IX ; pointer to request struct
2345  59B9
2346  59B9 E5           	PUSH HL ; save position in BASIC buffer
2347  59BA
2348  59BA FD 21 C1 59  	LD IY, .RET
2349  59BE C3 35 51     	JP ENABLE_PAGE0
2350  59C1              .RET:
2351  59C1 FB           	EI
2352  59C2              	; set RAM functions to call
2353  59C2 21 00 00     	LD HL, 0
2354  59C5 22 8C 59     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2355  59C8 22 8E 59     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2356  59CB 21 ED B0     	LD HL, #B0ED ; LDIR
2357  59CE 22 90 59     	LD (RECTANGLE_COPY.CALL1+4), HL
2358  59D1 CD 74 59     	CALL RECTANGLE_COPY
2359  59D4
2360  59D4 D1               POP DE
2361  59D5 C1               POP BC
2362  59D6 CD AC 50         CALL RESTORE_PAGE_INFO
2363  59D9
2364  59D9 E1           	POP HL
2365  59DA C9           	RET
2366  59DB              ; *******************************************************************************************************
2367  59DB
2368  59DB              ; *******************************************************************************************************
2369  59DB              ; function to handle CALL BOXMEMVRM basic extension
2370  59DB              ; copies data with window like boundaries to ram
2371  59DB              ; BOXMEMVRM ( INT request_data_ptr )
2372  59DB              ; request_data_ptr described in RECTANGLE_COPY
2373  59DB              ; will put ram in page 0 also, page 1 is already there
2374  59DB              BOXMEMVRM:
2375  59DB              	; opening (
2376  59DB CD 82 51     	CALL CHKCHAR
2377  59DE 28           	DB '('
2378  59DF              	; get pointer to request struct
2379  59DF DD 21 2F 54  	LD IX, FRMQNT
2380  59E3 CD 59 01     	CALL CALBAS
2381  59E6 D5           	PUSH DE
2382  59E7              	; ending )
2383  59E7 CD 82 51     	CALL CHKCHAR
2384  59EA 29           	DB ')'
2385  59EB
2386  59EB DD E1        	POP IX ; pointer to request struct
2387  59ED
2388  59ED E5           	PUSH HL ; save position in BASIC buffer
2389  59EE
2390  59EE FD 21 F5 59  	LD IY, .RET
2391  59F2 C3 35 51     	JP ENABLE_PAGE0
2392  59F5              .RET:
2393  59F5 FB           	EI
2394  59F6              	; set RAM functions to call
2395  59F6 21 14 5A     	LD HL, .SETDEST
2396  59F9 22 8D 59     	LD (RECTANGLE_COPY.CALL1+1), HL
2397  59FC 21 1C 5A     	LD HL, .COPYDATA
2398  59FF 22 90 59     	LD (RECTANGLE_COPY.CALL2+1), HL
2399  5A02 3E CD        	LD A, #CD ; CALL
2400  5A04 32 8C 59     	LD (RECTANGLE_COPY.CALL1), A
2401  5A07 32 8F 59     	LD (RECTANGLE_COPY.CALL2), A
2402  5A0A CD 74 59     	CALL RECTANGLE_COPY
2403  5A0D
2404  5A0D D1               POP DE
2405  5A0E C1               POP BC
2406  5A0F CD AC 50         CALL RESTORE_PAGE_INFO
2407  5A12
2408  5A12 E1           	POP HL
2409  5A13 C9           	RET
2410  5A14              .SETDEST:
2411  5A14 EB           	EX DE, HL
2412  5A15 F3           	DI
2413  5A16 CD 60 50     	CALL SETWRT_LOCAL
2414  5A19 FB           	EI
2415  5A1A EB           	EX DE, HL
2416  5A1B C9           	RET
2417  5A1C              .COPYDATA:
2418  5A1C 41           	LD B, C
2419  5A1D 0E 98        	LD C, #98
2420  5A1F C3 6B 50     	JP BBYTECOPY
2421  5A22              ; *******************************************************************************************************
2422  5A22               ENDIF
2423  5A22
2424  5A22              EXT_END:
2425  5A22
# file closed: asm\main.asm
