# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              BYTEOPS_CMDS   EQU 0
  14  4000              COLL_CMD       EQU 1
  15  4000
  16  4000               DEFINE CMDS_WITH_PARAMETERS
  17  4000
  18  4000              CHPUT   EQU    #A2
  19  4000              CALBAS  EQU		#159
  20  4000              ERRHAND EQU    #406F
  21  4000              FRMEVL  EQU    #4C64
  22  4000              FRESTR  EQU		#67D0
  23  4000              ; FRMQNT = formula quantificator
  24  4000              ; input HL=pointer to current program expression
  25  4000              ; output HL=next address
  26  4000              ; output DE=integer datum
  27  4000              FRMQNT	EQU		#542F
  28  4000              ; GETBYT = get byte parameter
  29  4000              ; input HL=pointer to current program expression
  30  4000              ; output HL=next address
  31  4000              ; output A=E=byte read
  32  4000              GETBYT		EQU	#521C
  33  4000              CHRGTR  	   EQU   #4666
  34  4000              PTRGET		EQU 	#5EA4
  35  4000              SUBFLG		EQU	#F6A5
  36  4000              SYNCHR		EQU	#558C
  37  4000              VALTYP  	   EQU   #F663
  38  4000              DAC         EQU   #F7F6
  39  4000              USR     	   EQU   #F7F8
  40  4000              PROCNM		EQU	#FD89
  41  4000              BIOS_FILVRM EQU   #0056
  42  4000              CLIKSW		EQU	#F3DB
  43  4000
  44  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  45  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  46  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  47  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  48  4000              EXPTBL	   EQU   #FCC1
  49  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  50  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  51  4000              JIFFY	      EQU   #FC9E
  52  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  53  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  54  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  55  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  56  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  57  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  58  4000
  59  4000              ; BASIC error codes
  60  4000              ;01 NEXT without FOR
  61  4000              ;02 Syntax error
  62  4000              ;03 RETURN without GOSUB
  63  4000              ;04 Out of DATA
  64  4000              ;05 Illegal function call
  65  4000              ;06 Overflow
  66  4000              ;07 Out of memory
  67  4000              ;08 Undefined line number
  68  4000              ;09 Subscript out of range
  69  4000              ;10 Redimensioned array
  70  4000              ;11 Division by zero
  71  4000              ;12 Illegal direct
  72  4000              ;13 Type mismatch
  73  4000              ;14 Out of string space
  74  4000              ;15 String too long
  75  4000              ;16 String formula too complex
  76  4000              ;17 Can't CONTINUE
  77  4000              ;18 Undefined user function
  78  4000              ;19 Device I/O error
  79  4000              ;20 Verify error
  80  4000              ;21 No RESUME
  81  4000              ;22 RESUME without error
  82  4000              ;23 Unprintable error
  83  4000              ;24 Missing operand
  84  4000              ;25 Line buffer overflow
  85  4000              ;50 FIELD overflow
  86  4000              ;51 Internal error
  87  4000              ;52 Bad file number
  88  4000              ;53 File not found
  89  4000              ;54 File already open
  90  4000              ;55 Input past end
  91  4000              ;56 Bad file name
  92  4000              ;57 Direct statement in file
  93  4000              ;58 Sequential I/O only
  94  4000              ;59 File not OPEN
  95  4000
  96  4000
  97  4000               ; simulate cartridge with BASIC extension
  98  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  98  4004 FE 63 00 00
  98  4008 00 00 00 00
  98  400C 00 00 00 00
  99  4010
 100  4010              ; this location #4010 stores last location used by basic extension
 101  4010              ; free memory after that point
 102  4010              FREEMEMPTR:
 103  4010 9E 64         DW EXT_END
 104  4012
 105  4012              ; this location #4012 stores extension version in DAA format
 106  4012              ; first byte is major version and second minor
 107  4012              VERSION:
 108  4012 00 70         DB #00, #70
 109  4014
 110  4014              ; binary included AKG player compiled at #4014
 111  4014               IF (SOUND_CMDS == 1)
 112  4014              	INCBIN "bin/AKG.bin"
 113  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 114  4CF0               ENDIF
 115  4CF0
 116  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 20 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A F9 57     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13                  ;LD HL,(JIFFY)
  43+ 4D13                  ;INC HL
  44+ 4D13                  ;LD (JIFFY),HL
  45+ 4D13
  46+ 4D13 FD E1            POP IY
  47+ 4D15 DD E1            POP IX
  48+ 4D17 E1               POP HL
  49+ 4D18 D1               POP DE
  50+ 4D19 C1               POP BC
  51+ 4D1A F1               POP AF
  52+ 4D1B 08               EX AF, AF'
  53+ 4D1C D9               EXX
  54+ 4D1D E1               POP HL
  55+ 4D1E D1               POP DE
  56+ 4D1F C1               POP BC
  57+ 4D20               ENDIF
  58+ 4D20
  59+ 4D20              .EXIT:
  60+ 4D20 F1           	POP AF
  61+ 4D21 FB           	EI
  62+ 4D22 ED 4D        	RETI
  63+ 4D24              ; *******************************************************************************************************
  64+ 4D24
  65+ 4D24              ; *******************************************************************************************************
  66+ 4D24              ; H.TIMI function
  67+ 4D24              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D24              MBGE_HTIMI:
  69+ 4D24               EXPORT MBGE_HTIMI
  70+ 4D24
  71+ 4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D24
  73+ 4D24 F5           	PUSH AF
  74+ 4D25
  75+ 4D25              	; enable page 2
  76+ 4D25 3E 02            LD A, 2
  77+ 4D27 CD 2E 63         CALL GET_PAGE_INFO
  78+ 4D2A C5               PUSH BC
  79+ 4D2B D5               PUSH DE
  80+ 4D2C 3A 43 F3         LD A, (RAMAD2)
  81+ 4D2F 26 80            LD H, 080H
  82+ 4D31 CD 75 63         CALL LOCAL_ENASLT
  83+ 4D34              	; enable page 0
  84+ 4D34 AF               XOR A
  85+ 4D35 CD 2E 63         CALL GET_PAGE_INFO
  86+ 4D38 C5               PUSH BC
  87+ 4D39 D5               PUSH DE
  88+ 4D3A 3A 41 F3         LD A, (RAMAD0)
  89+ 4D3D 26 00            LD H, 0
  90+ 4D3F CD 75 63         CALL LOCAL_ENASLT
  91+ 4D42
  92+ 4D42               IF (SPRITE_CMDS == 1)
  93+ 4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D45               ENDIF
  95+ 4D45
  96+ 4D45               IF (SOUND_CMDS == 1)
  97+ 4D45 3A F9 57     	LD A, (SOUND_ENABLED)
  98+ 4D48 B7           	OR A
  99+ 4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4C               ENDIF
 101+ 4D4C
 102+ 4D4C              	; restore page 0
 103+ 4D4C D1               POP DE
 104+ 4D4D C1               POP BC
 105+ 4D4E CD 65 63         CALL RESTORE_PAGE_INFO
 106+ 4D51              	; restore page 2
 107+ 4D51 D1               POP DE
 108+ 4D52 C1               POP BC
 109+ 4D53 CD 65 63         CALL RESTORE_PAGE_INFO
 110+ 4D56
 111+ 4D56 F1           	POP AF
 112+ 4D57               ENDIF
 113+ 4D57 C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D5A              ; *******************************************************************************************************
 115+ 4D5A
 116+ 4D5A              ; *******************************************************************************************************
 117+ 4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5A              ; also checks if some VRAM modifying command is running
 119+ 4D5A              ; when that checks out calls sprite updates and animation processing
 120+ 4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
 121+ 4D5A              	; check if initialized
 122+ 4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
 123+ 4D5D B7           	OR A
 124+ 4D5E C8           	RET Z
 125+ 4D5F              	; check screen mode
 126+ 4D5F 3A AF FC     	LD A, (SCRMOD)
 127+ 4D62 3D           	DEC A
 128+ 4D63 28 02        	JR Z, .L0 ; screen 1
 129+ 4D65 3D           	DEC A
 130+ 4D66 C0           	RET NZ ; not screen 2
 131+ 4D67              .L0:
 132+ 4D67                  ; check if anyone else is working with VRAM
 133+ 4D67 3A 5E 61         LD A,(VRAM_UPDATE_IN_PROGRESS)
 134+ 4D6A B7               OR A
 135+ 4D6B C0               RET NZ
 136+ 4D6C
 137+ 4D6C CD 88 4D         CALL SPRATR_UPDATE
 138+ 4D6F
 139+ 4D6F               IF (ANIM_CMDS == 1)
 140+ 4D6F CD 8E 55         CALL PROCESS_ANIMATIONS
 141+ 4D72               ENDIF
 142+ 4D72 C9               RET
 143+ 4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 117  4D73
 118  4D73               IF (SPRITE_CMDS == 1)
 119  4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D73              ; commands and variables related to sprites
   2+ 4D73
   3+ 4D73              SPRATR_INIT_STATUS:
   4+ 4D73 00            DB 0
   5+ 4D74              SPRATR_UPDATE_FLAG:
   6+ 4D74 00 00         DW 0
   7+ 4D76              SPRATR_DATA:
   8+ 4D76 00 00         DW 0
   9+ 4D78              SPRFLICKER_ENABLED:
  10+ 4D78 00            DB 0
  11+ 4D79              ; to support sprite flicker
  12+ 4D79              FLICKER:
  13+ 4D79 00            DB 0
  14+ 4D7A
  15+ 4D7A              ; to temporarily store stack pointer
  16+ 4D7A              TMPSP:
  17+ 4D7A 00 00         DW 0
  18+ 4D7C
  19+ 4D7C              ; *******************************************************************************************************
  20+ 4D7C              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D7C              ; changes HL,DE;
  22+ 4D7C              GETnthSPRATTR:
  23+ 4D7C 26 00            LD H,0
  24+ 4D7E 6F               LD L,A
  25+ 4D7F CD 2A 63         CALL HLx8
  26+ 4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
  27+ 4D86 19               ADD HL,DE
  28+ 4D87 C9               RET
  29+ 4D88              ; *******************************************************************************************************
  30+ 4D88
  31+ 4D88              ; *******************************************************************************************************
  32+ 4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D88              ; struct {
  34+ 4D88              ; DW y
  35+ 4D88              ; DW x
  36+ 4D88              ; DW pattern (0-63)
  37+ 4D88              ; DW color
  38+ 4D88              ; } [32]
  39+ 4D88              ; will hide sprites whose location is outside of visible area
  40+ 4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D88              ; modifies AF, AF', BC, DE, HL
  42+ 4D88              SPRATR_UPDATE:
  43+ 4D88              	; check if update requested
  44+ 4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D8B 7E           	LD A, (HL)
  46+ 4D8C B7           	OR A
  47+ 4D8D C8           	RET Z
  48+ 4D8E              .L0:
  49+ 4D8E 06 20        	LD B, 32 ; sprite number
  50+ 4D90 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D92              	; set VDP address
  52+ 4D92 3A AF FC         LD A,(SCRMOD)
  53+ 4D95 3D               DEC A
  54+ 4D96 20 05            JR NZ,.L4
  55+ 4D98 2A C3 F3         LD HL, (T32ATR)
  56+ 4D9B 18 03            JR .L5
  57+ 4D9D              .L4:
  58+ 4D9D 2A CD F3         LD HL, (GRPATR)
  59+ 4DA0              .L5:
  60+ 4DA0 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
  61+ 4DA3 B7           	OR A
  62+ 4DA4 28 03        	JR Z, .L3
  63+ 4DA6 3A 79 4D     	LD A, (FLICKER)
  64+ 4DA9              .L3:
  65+ 4DA9 5F           	LD E, A
  66+ 4DAA 08           	EX AF, AF'
  67+ 4DAB 7B           	LD A, E
  68+ 4DAC 87           	ADD A, A
  69+ 4DAD 87           	ADD A, A
  70+ 4DAE 16 00        	LD D, 0
  71+ 4DB0 5F           	LD E, A
  72+ 4DB1 19           	ADD HL, DE
  73+ 4DB2 CD 15 63     	CALL SETWRT_LOCAL
  74+ 4DB5 ED 73 7A 4D  	LD (TMPSP), SP
  75+ 4DB9 ED 7B 76 4D  	LD SP, (SPRATR_DATA)
  76+ 4DBD
  77+ 4DBD              .LOOP:
  78+ 4DBD E1           	POP HL
  79+ 4DBE 24           	INC H
  80+ 4DBF 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  81+ 4DC1 25           	DEC H
  82+ 4DC2 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  83+ 4DC4 7D           	LD A, L
  84+ 4DC5 FE C0        	CP 192
  85+ 4DC7 30 10        	JR NC, .OUT3
  86+ 4DC9 3D           	DEC A ; due to VDP rule that top of screen is -1
  87+ 4DCA 57           	LD D, A
  88+ 4DCB C3 F2 4D     	JP .X
  89+ 4DCE              .L1:
  90+ 4DCE 7D           	LD A, L
  91+ 4DCF C6 10        	ADD 16
  92+ 4DD1 FA D9 4D     	JP M, .OUT3 ; below -16
  93+ 4DD4 2D           	DEC L ; due to VDP rule that top of screen is -1
  94+ 4DD5 55           	LD D, L
  95+ 4DD6 C3 F2 4D     	JP .X
  96+ 4DD9              .OUT3:
  97+ 4DD9 E1           	POP HL ; skip x value
  98+ 4DDA              .OUT2:
  99+ 4DDA E1           	POP HL ; skip pattern
 100+ 4DDB E1           	POP HL ; skip color
 101+ 4DDC 3E D1        	LD A, #D1
 102+ 4DDE ED 79        	OUT (C), A ; sprite hidden
 103+ 4DE0 00          > NOP
 103+ 4DE1 00          > NOP
 103+ 4DE2 00          > NOP
 104+ 4DE3 ED 79        	OUT (C), A ; value unimportant
 105+ 4DE5 00          > NOP
 105+ 4DE6 00          > NOP
 105+ 4DE7 00          > NOP
 106+ 4DE8 ED 79        	OUT (C), A ; value unimportant
 107+ 4DEA 00          > NOP
 107+ 4DEB 00          > NOP
 107+ 4DEC 00          > NOP
 108+ 4DED ED 79        	OUT (C), A ; value unimportant
 109+ 4DEF C3 1D 4E     	JP .NEXT
 110+ 4DF2              .X:
 111+ 4DF2 E1           	POP HL
 112+ 4DF3 24           	INC H
 113+ 4DF4 28 08        	JR Z, .L2
 114+ 4DF6 25           	DEC H
 115+ 4DF7 20 E1        	JR NZ, .OUT2
 116+ 4DF9 1E 00        	LD E, 0 ; EC bit
 117+ 4DFB C3 07 4E     	JP .XY
 118+ 4DFE              .L2:
 119+ 4DFE 7D           	LD A, L
 120+ 4DFF C6 20        	ADD 32
 121+ 4E01 FA DA 4D     	JP M, .OUT2
 122+ 4E04 6F           	LD L, A
 123+ 4E05 1E 80        	LD E, #80
 124+ 4E07              .XY:
 125+ 4E07 ED 51        	OUT (C), D
 126+ 4E09 3A E0 F3     	LD A, (REG1SAV)
 127+ 4E0C E6 02        	AND 2
 128+ 4E0E ED 69        	OUT (C), L
 129+ 4E10 E1           	POP HL ; pattern
 130+ 4E11 7D           	LD A, L
 131+ 4E12 28 02        	JR Z, .SMALLSPRITES
 132+ 4E14 87           	ADD A, A
 133+ 4E15 87           	ADD A, A ; needs to go at 4x
 134+ 4E16              .SMALLSPRITES:
 135+ 4E16 D3 98        	OUT (#98), A
 136+ 4E18 E1           	POP HL ; color
 137+ 4E19 7D           	LD A, L
 138+ 4E1A B3           	OR E
 139+ 4E1B D3 98        	OUT (#98), A
 140+ 4E1D              .NEXT:
 141+ 4E1D 08           	EX AF, AF'
 142+ 4E1E 3C           	INC A
 143+ 4E1F E6 1F        	AND 31
 144+ 4E21 C2 40 4E     	JP NZ, .NEXT2
 145+ 4E24 08           	EX AF, AF'
 146+ 4E25 3A AF FC         LD A,(SCRMOD)
 147+ 4E28 3D               DEC A
 148+ 4E29 20 05            JR NZ,.L6
 149+ 4E2B 2A C3 F3         LD HL, (T32ATR)
 150+ 4E2E 18 03            JR .L7
 151+ 4E30              .L6:
 152+ 4E30 2A CD F3         LD HL, (GRPATR)
 153+ 4E33              .L7:
 154+ 4E33              	; CALL SETWRT_LOCAL not allowed as SP modified
 155+ 4E33 7D           	LD	A, L
 156+ 4E34 D3 99        	OUT	(099H), A
 157+ 4E36 7C           	LD	A, H
 158+ 4E37 E6 3F        	AND	03FH
 159+ 4E39 F6 40        	OR	040H
 160+ 4E3B D3 99        	OUT	(099H), A
 161+ 4E3D C3 41 4E     	JP .NEXT3
 162+ 4E40              .NEXT2:
 163+ 4E40 08           	EX AF, AF'
 164+ 4E41              .NEXT3:
 165+ 4E41 05           	DEC B
 166+ 4E42 C2 BD 4D     	JP NZ, .LOOP
 167+ 4E45 08           	EX AF, AF'
 168+ 4E46 3C           	INC A
 169+ 4E47 32 79 4D     	LD (FLICKER), A
 170+ 4E4A
 171+ 4E4A ED 7B 7A 4D  	LD SP, (TMPSP)
 172+ 4E4E 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 173+ 4E51 36 00        	LD (HL), 0 ; zero out update flag
 174+ 4E53 C9           	RET
 175+ 4E54              ; *******************************************************************************************************
 176+ 4E54
 177+ 4E54              ; *******************************************************************************************************
 178+ 4E54              ; function to handle CALL SPRENABLE basic extension
 179+ 4E54              ; initializes sprites handler
 180+ 4E54              ; _SPRENABLE ( INT[][] sprites_attributes,
 181+ 4E54              ;			   INT update_variable,
 182+ 4E54              ;			   BYTE sprite_flicker_enabled )
 183+ 4E54              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 184+ 4E54              SPRENABLE:
 185+ 4E54              	; opening (
 186+ 4E54 CD 3C 64     	CALL CHKCHAR
 187+ 4E57 28           	DB '('
 188+ 4E58              	; get address of sprite attribute table DIM SA%(3,31)
 189+ 4E58 3E 02        	LD A,2
 190+ 4E5A 06 02        	LD B,2
 191+ 4E5C 11 20 04     	LD DE,#0420
 192+ 4E5F CD 69 64     	CALL GET_BASIC_ARRAY_DATA_POINTER
 193+ 4E62 C5           	PUSH BC
 194+ 4E63              	; comma
 195+ 4E63 CD 3C 64     	CALL CHKCHAR
 196+ 4E66 2C           	DB ','
 197+ 4E67              	; get address of sprite update flag
 198+ 4E67 DD 21 A4 5E  	LD IX, PTRGET
 199+ 4E6B CD 59 01     	CALL CALBAS
 200+ 4E6E D5           	PUSH DE
 201+ 4E6F              	; comma
 202+ 4E6F CD 3C 64     	CALL CHKCHAR
 203+ 4E72 2C           	DB ','
 204+ 4E73              	; get flicker enabled flag
 205+ 4E73 DD 21 1C 52  	LD IX, GETBYT
 206+ 4E77 CD 59 01     	CALL CALBAS
 207+ 4E7A F5           	PUSH AF
 208+ 4E7B              	; ending )
 209+ 4E7B CD 3C 64     	CALL CHKCHAR
 210+ 4E7E 29           	DB ')'
 211+ 4E7F
 212+ 4E7F F1           	POP AF ; get flicker flag
 213+ 4E80 B7           	OR A
 214+ 4E81 32 78 4D     	LD (SPRFLICKER_ENABLED), A
 215+ 4E84
 216+ 4E84 D1           	POP DE ; update variable location
 217+ 4E85 ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
 218+ 4E89 D1           	POP DE ; address of sprite attribute table
 219+ 4E8A ED 53 76 4D  	LD (SPRATR_DATA), DE
 220+ 4E8E 3E 01        	LD A, 1
 221+ 4E90 32 73 4D     	LD (SPRATR_INIT_STATUS), A
 222+ 4E93 C9           	RET
 223+ 4E94              ; *******************************************************************************************************
 224+ 4E94
 225+ 4E94              ; *******************************************************************************************************
 226+ 4E94              ; function to handle CALL SPRDISABLE basic extension
 227+ 4E94              ; disables sprites handling
 228+ 4E94              ; _SPRDISABLE
 229+ 4E94              ; resets variable SPRATR_INIT_STATUS
 230+ 4E94              SPRDISABLE:
 231+ 4E94 AF           	XOR A
 232+ 4E95 32 73 4D     	LD (SPRATR_INIT_STATUS), A
 233+ 4E98 C9           	RET
 234+ 4E99              ; *******************************************************************************************************
 235+ 4E99
 236+ 4E99              ; *******************************************************************************************************
 237+ 4E99              ; function to handle CALL SPRSET basic extension
 238+ 4E99              ; sets position, and optionally pattern and color of sprite
 239+ 4E99              ; _SPRSET ( BYTE sprite_num , valid 0-31
 240+ 4E99              ;			INT x,
 241+ 4E99              ;			INT y,
 242+ 4E99              ;			INT pattern, valid 0-63, otherwise ignored
 243+ 4E99              ;			INT color, valid 0-15, otherwise ignored
 244+ 4E99              SPRSET:
 245+ 4E99 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
 246+ 4E9C B7           	OR A
 247+ 4E9D 20 05        	JR NZ, .L1
 248+ 4E9F 1E 05        	LD E, 5 ; illegal function call
 249+ 4EA1 C3 62 64     	JP THROW_ERROR
 250+ 4EA4              .L1:
 251+ 4EA4              	; opening (
 252+ 4EA4 CD 3C 64     	CALL CHKCHAR
 253+ 4EA7 28           	DB '('
 254+ 4EA8              	; get sprite number
 255+ 4EA8 DD 21 1C 52  	LD IX, GETBYT
 256+ 4EAC CD 59 01     	CALL CALBAS
 257+ 4EAF F5           	PUSH AF
 258+ 4EB0              	; comma
 259+ 4EB0 CD 3C 64     	CALL CHKCHAR
 260+ 4EB3 2C           	DB ','
 261+ 4EB4              	; get x
 262+ 4EB4 DD 21 2F 54  	LD IX, FRMQNT
 263+ 4EB8 CD 59 01     	CALL CALBAS
 264+ 4EBB D5           	PUSH DE
 265+ 4EBC              	; comma
 266+ 4EBC CD 3C 64     	CALL CHKCHAR
 267+ 4EBF 2C           	DB ','
 268+ 4EC0              	; get y
 269+ 4EC0 DD 21 2F 54  	LD IX, FRMQNT
 270+ 4EC4 CD 59 01     	CALL CALBAS
 271+ 4EC7 D5           	PUSH DE
 272+ 4EC8              	; comma
 273+ 4EC8 CD 3C 64     	CALL CHKCHAR
 274+ 4ECB 2C           	DB ','
 275+ 4ECC              	; get pattern
 276+ 4ECC DD 21 2F 54  	LD IX, FRMQNT
 277+ 4ED0 CD 59 01     	CALL CALBAS
 278+ 4ED3 D5           	PUSH DE
 279+ 4ED4              	; comma
 280+ 4ED4 CD 3C 64     	CALL CHKCHAR
 281+ 4ED7 2C           	DB ','
 282+ 4ED8              	; get color
 283+ 4ED8 DD 21 2F 54  	LD IX, FRMQNT
 284+ 4EDC CD 59 01     	CALL CALBAS
 285+ 4EDF D5           	PUSH DE
 286+ 4EE0              	; ending )
 287+ 4EE0 CD 3C 64     	CALL CHKCHAR
 288+ 4EE3 29           	DB ')'
 289+ 4EE4
 290+ 4EE4                  ; save position in BASIC text
 291+ 4EE4 E5           	PUSH HL
 292+ 4EE5 DD E1        	POP IX
 293+ 4EE7
 294+ 4EE7 C1           	POP BC ; color
 295+ 4EE8 D1           	POP DE ; pattern
 296+ 4EE9 D9           	EXX
 297+ 4EEA C1           	POP BC ; y
 298+ 4EEB D1           	POP DE ; x
 299+ 4EEC F1           	POP AF ; sprite number
 300+ 4EED FE 20        	CP 32
 301+ 4EEF 38 05        	JR C, .L2
 302+ 4EF1 1E 05        	LD E, 5 ; illegal function call
 303+ 4EF3 C3 62 64     	JP THROW_ERROR
 304+ 4EF6              .L2:
 305+ 4EF6              	; find location in sprite attributes table
 306+ 4EF6 D5           	PUSH DE
 307+ 4EF7 CD 7C 4D     	CALL GETnthSPRATTR
 308+ 4EFA D1           	POP DE
 309+ 4EFB              	; set y
 310+ 4EFB 71           	LD (HL), C
 311+ 4EFC 23           	INC HL
 312+ 4EFD 70           	LD (HL), B
 313+ 4EFE 23           	INC HL
 314+ 4EFF              	; set x
 315+ 4EFF 73           	LD (HL), E
 316+ 4F00 23           	INC HL
 317+ 4F01 72           	LD (HL), D
 318+ 4F02 23           	INC HL
 319+ 4F03 E5           	PUSH HL
 320+ 4F04 D9           	EXX
 321+ 4F05 E1           	POP HL
 322+ 4F06              	; check if 0<=pattern<64
 323+ 4F06 7A           	LD A, D
 324+ 4F07 B7           	OR A
 325+ 4F08 20 0B        	JR NZ, .L3
 326+ 4F0A 7B           	LD A, E
 327+ 4F0B FE 40        	CP 64
 328+ 4F0D 30 06        	JR NC, .L3
 329+ 4F0F              	; set pattern
 330+ 4F0F              	;ADD A, A
 331+ 4F0F              	;ADD A, A
 332+ 4F0F              	;ADD A, A
 333+ 4F0F 77           	LD (HL), A
 334+ 4F10 23           	INC HL
 335+ 4F11 72           	LD (HL), D
 336+ 4F12 23           	INC HL
 337+ 4F13 18 02        	JR .L4
 338+ 4F15              .L3:
 339+ 4F15              	; skip pattern
 340+ 4F15 23          > INC HL
 340+ 4F16 23          > INC HL
 341+ 4F17              .L4:
 342+ 4F17              	; check if 0<=color<16
 343+ 4F17 78           	LD A, B
 344+ 4F18 B7           	OR A
 345+ 4F19 20 08        	JR NZ, .L5
 346+ 4F1B 79           	LD A, C
 347+ 4F1C FE 10        	CP 16
 348+ 4F1E 30 03        	JR NC, .L5
 349+ 4F20              	; set color
 350+ 4F20 71           	LD (HL), C
 351+ 4F21 23           	INC HL
 352+ 4F22 70           	LD (HL), B
 353+ 4F23
 354+ 4F23              .L5:
 355+ 4F23 DD E5        	PUSH IX
 356+ 4F25 E1           	POP HL
 357+ 4F26 C9           	RET
 358+ 4F27              ; *******************************************************************************************************
 359+ 4F27
 360+ 4F27              ; *******************************************************************************************************
 361+ 4F27              ; function sets sprite location based on initial coordinates and offset provided
 362+ 4F27              ; input A=sprite number in SPRATR_DATA , 0-31
 363+ 4F27              ; input DE=initial x
 364+ 4F27              ; input BC=initial y
 365+ 4F27              ; input IY=location where delta y,x are located
 366+ 4F27              ; modifies AF, HL, IX
 367+ 4F27              SPRSET_DELTA_POS:
 368+ 4F27 D5           	PUSH DE
 369+ 4F28 CD 7C 4D     	CALL GETnthSPRATTR
 370+ 4F2B E5           	PUSH HL
 371+ 4F2C DD E1        	POP IX
 372+ 4F2E D1           	POP DE
 373+ 4F2F              	; IX=sprite's y location
 374+ 4F2F FD 6E 00     	LD L, (IY)
 375+ 4F32 FD 66 01     	LD H, (IY+1)
 376+ 4F35 09           	ADD HL, BC
 377+ 4F36 DD 75 00     	LD (IX), L
 378+ 4F39 DD 74 01     	LD (IX+1), H
 379+ 4F3C FD 6E 02     	LD L, (IY+2)
 380+ 4F3F FD 66 03     	LD H, (IY+3)
 381+ 4F42 19           	ADD HL, DE
 382+ 4F43 DD 75 02     	LD (IX+2), L
 383+ 4F46 DD 74 03     	LD (IX+3), H
 384+ 4F49 C9           	RET
 385+ 4F4A              ; *******************************************************************************************************
 386+ 4F4A
 387+ 4F4A              ; *******************************************************************************************************
 388+ 4F4A              ; function to handle CALL SPRGRPMOV basic extension
 389+ 4F4A              ; sets position of a group of sprites described with
 390+ 4F4A              ; { int sprite_num, int delta_y, int delta_x } [count]
 391+ 4F4A              ; _SPRGRPMOV ( INT x,
 392+ 4F4A              ;			   INT y,
 393+ 4F4A              ;			   BYTE count,
 394+ 4F4A              ;			   INT[2][count] data_ptr
 395+ 4F4A              ; will put ram in page 0 also, page 1 is already there
 396+ 4F4A              SPRGRPMOV:
 397+ 4F4A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
 398+ 4F4D B7           	OR A
 399+ 4F4E CA 5C 64     	JP Z,ILLEGAL_FUNCTION
 400+ 4F51              	; opening (
 401+ 4F51 CD 3C 64     	CALL CHKCHAR
 402+ 4F54 28           	DB '('
 403+ 4F55              	; get x
 404+ 4F55 DD 21 2F 54  	LD IX, FRMQNT
 405+ 4F59 CD 59 01     	CALL CALBAS
 406+ 4F5C D5           	PUSH DE
 407+ 4F5D              	; comma
 408+ 4F5D CD 3C 64     	CALL CHKCHAR
 409+ 4F60 2C           	DB ','
 410+ 4F61              	; get y
 411+ 4F61 DD 21 2F 54  	LD IX, FRMQNT
 412+ 4F65 CD 59 01     	CALL CALBAS
 413+ 4F68 D5           	PUSH DE
 414+ 4F69              	; comma
 415+ 4F69 CD 3C 64     	CALL CHKCHAR
 416+ 4F6C 2C           	DB ','
 417+ 4F6D              	; get count
 418+ 4F6D DD 21 1C 52  	LD IX, GETBYT
 419+ 4F71 CD 59 01     	CALL CALBAS
 420+ 4F74 F5           	PUSH AF
 421+ 4F75              	; comma
 422+ 4F75 CD 3C 64     	CALL CHKCHAR
 423+ 4F78 2C           	DB ','
 424+ 4F79              	; get sprite group definition array data pointer
 425+ 4F79 D1           	POP DE
 426+ 4F7A D5           	PUSH DE
 427+ 4F7B 5A           	LD E,D
 428+ 4F7C 16 03        	LD D,3
 429+ 4F7E 3E 02        	LD A,2
 430+ 4F80 47           	LD B,A
 431+ 4F81 CD 69 64     	CALL GET_BASIC_ARRAY_DATA_POINTER
 432+ 4F84 C5           	PUSH BC
 433+ 4F85              	; ending )
 434+ 4F85 CD 3C 64     	CALL CHKCHAR
 435+ 4F88 29           	DB ')'
 436+ 4F89
 437+ 4F89 E5           	PUSH HL
 438+ 4F8A DD E1        	POP IX
 439+ 4F8C
 440+ 4F8C E1           	POP HL ; data pointer
 441+ 4F8D C1           	POP BC ; count
 442+ 4F8E D9           	EXX
 443+ 4F8F C1           	POP BC ; y
 444+ 4F90 D1           	POP DE ; x
 445+ 4F91 D9           	EXX
 446+ 4F92
 447+ 4F92 DD E5        	PUSH IX ; save position in BASIC buffer
 448+ 4F94
 449+ 4F94 C5           	PUSH BC
 450+ 4F95 E5           	PUSH HL
 451+ 4F96 AF               XOR A
 452+ 4F97 CD 2E 63         CALL GET_PAGE_INFO
 453+ 4F9A D9           	EXX
 454+ 4F9B E1           	POP HL
 455+ 4F9C F1           	POP AF
 456+ 4F9D D9           	EXX
 457+ 4F9E C5               PUSH BC
 458+ 4F9F D5               PUSH DE
 459+ 4FA0 D9           	EXX
 460+ 4FA1 F5           	PUSH AF
 461+ 4FA2 E5           	PUSH HL
 462+ 4FA3 D9           	EXX
 463+ 4FA4 3A 41 F3         LD A, (RAMAD0)
 464+ 4FA7 26 00            LD H, 0
 465+ 4FA9 CD 75 63         CALL LOCAL_ENASLT
 466+ 4FAC FB           	EI
 467+ 4FAD E1           	POP HL
 468+ 4FAE C1           	POP BC
 469+ 4FAF 3E 01        	LD A,1
 470+ 4FB1 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 471+ 4FB4 CD C2 4F     	CALL .UPDATE_LOC
 472+ 4FB7 AF           	XOR A
 473+ 4FB8 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 474+ 4FBB D1               POP DE
 475+ 4FBC C1               POP BC
 476+ 4FBD CD 65 63         CALL RESTORE_PAGE_INFO
 477+ 4FC0 E1           	POP HL
 478+ 4FC1 C9           	RET
 479+ 4FC2
 480+ 4FC2              .UPDATE_LOC:
 481+ 4FC2 7E           	LD A, (HL)
 482+ 4FC3 23           	INC HL
 483+ 4FC4 23           	INC HL
 484+ 4FC5 E5           	PUSH HL
 485+ 4FC6 FD E1        	POP IY
 486+ 4FC8 D9           	EXX
 487+ 4FC9 CD 27 4F     	CALL SPRSET_DELTA_POS
 488+ 4FCC D9           	EXX
 489+ 4FCD 23          > INC HL
 489+ 4FCE 23          > INC HL
 489+ 4FCF 23          > INC HL
 489+ 4FD0 23          > INC HL
 490+ 4FD1 10 EF        	DJNZ .UPDATE_LOC
 491+ 4FD3 C9           	RET
 492+ 4FD4              ; *******************************************************************************************************
 493+ 4FD4
# file closed: asm\SPRITES.asm
 120  4FD4               ENDIF
 121  4FD4
 122  4FD4               IF (ANIM_CMDS == 1)
 123  4FD4               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4FD4              ; sprite animation routines
   2+ 4FD4
   3+ 4FD4              ; number of animation items and pointer
   4+ 4FD4              ANIMITEMNUM:
   5+ 4FD4 00            DB 0
   6+ 4FD5              ANIMITEMPTR:
   7+ 4FD5 9E 64         DW EXT_END
   8+ 4FD7              ; number of animation definitions and pointer
   9+ 4FD7              ANIMDEFNUM:
  10+ 4FD7 00            DB 0
  11+ 4FD8              ANIMDEFPTR:
  12+ 4FD8 9E 64         DW EXT_END
  13+ 4FDA              ; number of links between sprite and animation definitions
  14+ 4FDA              ANIMSPRNUM:
  15+ 4FDA 00            DB 0
  16+ 4FDB              ANIMSPRPTR:
  17+ 4FDB 9E 64         DW EXT_END
  18+ 4FDD              ; number of automatic sprite group move and animate structures
  19+ 4FDD              AUTOSGAMNUM:
  20+ 4FDD 00            DB 0
  21+ 4FDE              AUTOSGAMPTR:
  22+ 4FDE 9E 64         DW EXT_END
  23+ 4FE0
  24+ 4FE0              ; ANIMATION ITEM
  25+ 4FE0              ; byte type = [0 - pattern and color change
  26+ 4FE0              ;              1 - pattern definition change ]
  27+ 4FE0              ; word ticks - number of ticks to hold this state
  28+ 4FE0              ; for type = 0
  29+ 4FE0              ;   byte pattern;
  30+ 4FE0              ;   byte color;
  31+ 4FE0              ; for type = 1
  32+ 4FE0              ;   work data_pointer;
  33+ 4FE0              ; total size = 5b
  34+ 4FE0
  35+ 4FE0              ; ANIMATION DEFINITION
  36+ 4FE0              ; byte number of items 1-15
  37+ 4FE0              ; byte[15] anim_item;
  38+ 4FE0              ; total size = 16b
  39+ 4FE0
  40+ 4FE0              ; SPRITE/CHAR ANIMATION
  41+ 4FE0              ; +00 byte sprite/char number;
  42+ 4FE0              ; +01 word time;
  43+ 4FE0              ; +03 byte current item;
  44+ 4FE0              ; +04 byte animation definition;
  45+ 4FE0              ; +05 byte cyclic;
  46+ 4FE0              ; +06 byte active;
  47+ 4FE0              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4FE0              ; total size = 8b
  49+ 4FE0
  50+ 4FE0              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4FE0              ; +00 pointer to X variable
  52+ 4FE0              ; +02 pointer to Y variable
  53+ 4FE0              ; +04 minimum value
  54+ 4FE0              ; +06 maximal value
  55+ 4FE0              ; +08 delta value
  56+ 4FE0              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4FE0              ; +11 sprite group size
  58+ 4FE0              ; +12 sprite group pointer
  59+ 4FE0              ; +14 animation list size
  60+ 4FE0              ; +15 animation list pointer for negative delta values
  61+ 4FE0              ; +17 animation list pointer for positive delta values
  62+ 4FE0              ; +19 active flag
  63+ 4FE0              ; +20 ticks for movement
  64+ 4FE0              ; +22 timer
  65+ 4FE0              ; total = 24b
  66+ 4FE0
  67+ 4FE0              ; *******************************************************************************************************
  68+ 4FE0              ; helper function HL=A*5
  69+ 4FE0              ; changes HL,DE;
  70+ 4FE0              Ax5:
  71+ 4FE0 26 00            LD H,0
  72+ 4FE2 6F               LD L,A
  73+ 4FE3 54               LD D,H
  74+ 4FE4 5D               LD E,L
  75+ 4FE5 29               ADD HL,HL
  76+ 4FE6 29               ADD HL,HL
  77+ 4FE7 19               ADD HL,DE
  78+ 4FE8 C9               RET
  79+ 4FE9              ; *******************************************************************************************************
  80+ 4FE9
  81+ 4FE9              ; *******************************************************************************************************
  82+ 4FE9              ; helper function gets pointer to n-th animation item
  83+ 4FE9              ; changes HL,DE;
  84+ 4FE9              GETnthANIMITEM:
  85+ 4FE9 CD E0 4F         CALL Ax5
  86+ 4FEC ED 5B D5 4F      LD DE,(ANIMITEMPTR)
  87+ 4FF0 19               ADD HL,DE
  88+ 4FF1 C9               RET
  89+ 4FF2              ; *******************************************************************************************************
  90+ 4FF2
  91+ 4FF2              ; *******************************************************************************************************
  92+ 4FF2              ; helper function gets pointer to n-th entry in animation definition
  93+ 4FF2              ; changes HL,DE;
  94+ 4FF2              GETnthANIMDEF:
  95+ 4FF2 26 00            LD H,0
  96+ 4FF4 6F               LD L,A
  97+ 4FF5 CD 29 63         CALL HLx16
  98+ 4FF8 ED 5B D8 4F      LD DE,(ANIMDEFPTR)
  99+ 4FFC 19               ADD HL,DE
 100+ 4FFD C9               RET
 101+ 4FFE              ; *******************************************************************************************************
 102+ 4FFE
 103+ 4FFE              ; *******************************************************************************************************
 104+ 4FFE              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4FFE              ; changes HL,DE;
 106+ 4FFE              GETnthSPRANIM:
 107+ 4FFE 26 00            LD H,0
 108+ 5000 6F               LD L,A
 109+ 5001 CD 2A 63         CALL HLx8
 110+ 5004 ED 5B DB 4F      LD DE,(ANIMSPRPTR)
 111+ 5008 19               ADD HL,DE
 112+ 5009 C9               RET
 113+ 500A              ; *******************************************************************************************************
 114+ 500A
 115+ 500A              ; *******************************************************************************************************
 116+ 500A              ; helper function gets pointer to n-th entry in autosgam table
 117+ 500A              ; changes HL,DE;
 118+ 500A              GETnthAUTOSGAM:
 119+ 500A 26 00            LD H,0
 120+ 500C 6F               LD L,A
 121+ 500D CD 2A 63         CALL HLx8
 122+ 5010 54               LD D,H
 123+ 5011 5D               LD E,L
 124+ 5012 29               ADD HL,HL
 125+ 5013 19               ADD HL,DE
 126+ 5014 ED 5B DE 4F      LD DE,(AUTOSGAMPTR)
 127+ 5018 19               ADD HL,DE
 128+ 5019 C9               RET
 129+ 501A              ; *******************************************************************************************************
 130+ 501A
 131+ 501A              ; *******************************************************************************************************
 132+ 501A              ; function to handle CALL MAXANIMITEMS basic extension
 133+ 501A              ; MAXANIMITEMS (BYTE number)
 134+ 501A              ; sets new number and moves memory buffers as needed
 135+ 501A              MAXANIMITEMS:
 136+ 501A              	; opening (
 137+ 501A CD 3C 64     	CALL CHKCHAR
 138+ 501D 28           	DB '('
 139+ 501E              	; get value
 140+ 501E DD 21 1C 52  	LD IX, GETBYT
 141+ 5022 CD 59 01     	CALL CALBAS
 142+ 5025 F5               PUSH AF
 143+ 5026              	; ending )
 144+ 5026 CD 3C 64     	CALL CHKCHAR
 145+ 5029 29           	DB ')'
 146+ 502A F1               POP AF
 147+ 502B
 148+ 502B              	; save position
 149+ 502B E5           	PUSH HL
 150+ 502C              .ENTRY:
 151+ 502C 47               LD B,A
 152+ 502D 3A D4 4F         LD A,(ANIMITEMNUM)
 153+ 5030 90               SUB B
 154+ 5031 28 28            JR Z, .EXIT; same value as before
 155+ 5033 FD 21 D8 4F      LD IY,ANIMDEFPTR
 156+ 5037 FA 5E 50         JP M, .INCREASE
 157+ 503A                  ; new value is lower than previous one
 158+ 503A CD 7D 50         CALL .SIZEDIFF
 159+ 503D CD 98 50         CALL .DECREASE_COMMON
 160+ 5040 2A DB 4F         LD HL,(ANIMSPRPTR)
 161+ 5043 AF               XOR A
 162+ 5044 ED 42            SBC HL,BC
 163+ 5046 22 DB 4F         LD (ANIMSPRPTR),HL
 164+ 5049              .E1:
 165+ 5049 2A DE 4F         LD HL,(AUTOSGAMPTR)
 166+ 504C AF               XOR A
 167+ 504D ED 42            SBC HL,BC
 168+ 504F 22 DE 4F         LD (AUTOSGAMPTR),HL
 169+ 5052              .E3:
 170+ 5052 2A 10 40         LD HL,(FREEMEMPTR)
 171+ 5055 AF               XOR A
 172+ 5056 ED 42            SBC HL,BC
 173+ 5058 22 10 40         LD (FREEMEMPTR),HL
 174+ 505B              .EXIT:
 175+ 505B FB               EI
 176+ 505C E1           	POP HL
 177+ 505D C9           	RET
 178+ 505E              .INCREASE:
 179+ 505E ED 44            NEG
 180+ 5060 CD 7D 50         CALL .SIZEDIFF
 181+ 5063 CD C4 50         CALL .INCREASE_COMMON
 182+ 5066 2A DB 4F         LD HL,(ANIMSPRPTR)
 183+ 5069 09               ADD HL,BC
 184+ 506A 22 DB 4F         LD (ANIMSPRPTR),HL
 185+ 506D              .E2:
 186+ 506D 2A DE 4F         LD HL,(AUTOSGAMPTR)
 187+ 5070 09               ADD HL,BC
 188+ 5071 22 DE 4F         LD (AUTOSGAMPTR),HL
 189+ 5074              .E4:
 190+ 5074 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 5077 09               ADD HL,BC
 192+ 5078 22 10 40         LD (FREEMEMPTR),HL
 193+ 507B 18 DE            JR .EXIT
 194+ 507D              .SIZEDIFF:
 195+ 507D CD E0 4F         CALL Ax5
 196+ 5080 78               LD A,B
 197+ 5081 32 D4 4F         LD (ANIMITEMNUM),A
 198+ 5084 44               LD B,H
 199+ 5085 4D               LD C,L
 200+ 5086 C9               RET ; BC=size difference in bytes
 201+ 5087              .SIZETOMOVE:
 202+ 5087 D5               PUSH DE
 203+ 5088 2A 10 40         LD HL,(FREEMEMPTR)
 204+ 508B FD 5E 00         LD E,(IY)
 205+ 508E FD 56 01         LD D,(IY+1)
 206+ 5091 AF               XOR A
 207+ 5092 ED 52            SBC HL,DE
 208+ 5094 44               LD B,H
 209+ 5095 4D               LD C,L
 210+ 5096 D1               POP DE
 211+ 5097 C9               RET
 212+ 5098              .DECREASE_COMMON:
 213+ 5098 FD 6E 00         LD L,(IY)
 214+ 509B FD 66 01         LD H,(IY+1)
 215+ 509E AF               XOR A
 216+ 509F ED 42            SBC HL,BC
 217+ 50A1 EB               EX DE,HL
 218+ 50A2 C5               PUSH BC
 219+ 50A3 CD 87 50         CALL .SIZETOMOVE
 220+ 50A6 F3               DI
 221+ 50A7 78               LD A,B
 222+ 50A8 B1               OR C
 223+ 50A9 28 08            JR Z,.L1
 224+ 50AB FD 6E 00         LD L,(IY)
 225+ 50AE FD 66 01         LD H,(IY+1)
 226+ 50B1 ED B0            LDIR
 227+ 50B3              .L1:
 228+ 50B3 C1               POP BC
 229+ 50B4 FD 6E 00         LD L,(IY)
 230+ 50B7 FD 66 01         LD H,(IY+1)
 231+ 50BA AF               XOR A
 232+ 50BB ED 42            SBC HL,BC
 233+ 50BD FD 75 00         LD (IY),L
 234+ 50C0 FD 74 01         LD (IY+1),H
 235+ 50C3 C9               RET
 236+ 50C4              .INCREASE_COMMON:
 237+ 50C4 2A 10 40         LD HL,(FREEMEMPTR)
 238+ 50C7 2B               DEC HL
 239+ 50C8 AF               XOR A
 240+ 50C9 ED 42            SBC HL,BC
 241+ 50CB EB               EX DE,HL
 242+ 50CC C5               PUSH BC
 243+ 50CD CD 87 50         CALL .SIZETOMOVE
 244+ 50D0 F3               DI
 245+ 50D1 78               LD A,B
 246+ 50D2 B1               OR C
 247+ 50D3 28 06            JR Z,.L2
 248+ 50D5 2A 10 40         LD HL,(FREEMEMPTR)
 249+ 50D8 2B               DEC HL
 250+ 50D9 ED B8            LDDR
 251+ 50DB              .L2:
 252+ 50DB C1               POP BC
 253+ 50DC FD 6E 00         LD L,(IY)
 254+ 50DF FD 66 01         LD H,(IY+1)
 255+ 50E2 09               ADD HL,BC
 256+ 50E3 FD 75 00         LD (IY),L
 257+ 50E6 FD 74 01         LD (IY+1),H
 258+ 50E9 C9               RET
 259+ 50EA              ; *******************************************************************************************************
 260+ 50EA
 261+ 50EA              ; *******************************************************************************************************
 262+ 50EA              ; function to handle CALL ANIMITEMPAT basic extension
 263+ 50EA              ; ANIMITEMPAT ( BYTE id,
 264+ 50EA              ;               INT ticks,
 265+ 50EA              ;               BYTE pattern,
 266+ 50EA              ;               BYTE color )
 267+ 50EA              ; fills animation item data, returns an error if out of bounds
 268+ 50EA              ANIMITEMPAT:
 269+ 50EA                  ; opening (
 270+ 50EA CD 3C 64     	CALL CHKCHAR
 271+ 50ED 28           	DB '('
 272+ 50EE              	; get id
 273+ 50EE DD 21 1C 52  	LD IX, GETBYT
 274+ 50F2 CD 59 01     	CALL CALBAS
 275+ 50F5 F5               PUSH AF
 276+ 50F6                  ; check if out of bounds
 277+ 50F6 3C               INC A
 278+ 50F7 4F               LD C,A
 279+ 50F8 3A D4 4F         LD A,(ANIMITEMNUM)
 280+ 50FB B9               CP C
 281+ 50FC DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 282+ 50FF              	; comma
 283+ 50FF CD 3C 64     	CALL CHKCHAR
 284+ 5102 2C           	DB ','
 285+ 5103              	; get ticks
 286+ 5103 DD 21 2F 54  	LD IX, FRMQNT
 287+ 5107 CD 59 01     	CALL CALBAS
 288+ 510A D5           	PUSH DE
 289+ 510B              	; comma
 290+ 510B CD 3C 64     	CALL CHKCHAR
 291+ 510E 2C           	DB ','
 292+ 510F              	; get pattern
 293+ 510F DD 21 1C 52  	LD IX, GETBYT
 294+ 5113 CD 59 01     	CALL CALBAS
 295+ 5116 F5               PUSH AF
 296+ 5117              	; comma
 297+ 5117 CD 3C 64     	CALL CHKCHAR
 298+ 511A 2C           	DB ','
 299+ 511B              	; get color
 300+ 511B DD 21 1C 52  	LD IX, GETBYT
 301+ 511F CD 59 01     	CALL CALBAS
 302+ 5122 F5               PUSH AF
 303+ 5123              	; ending )
 304+ 5123 CD 3C 64     	CALL CHKCHAR
 305+ 5126 29           	DB ')'
 306+ 5127              .ENTRY:
 307+ 5127 E5               PUSH HL
 308+ 5128 DD E1            POP IX
 309+ 512A D9               EXX
 310+ 512B C1               POP BC ; color
 311+ 512C D1               POP DE ; pattern
 312+ 512D E1               POP HL ; ticks
 313+ 512E D9               EXX
 314+ 512F F1               POP AF
 315+ 5130 CD E9 4F         CALL GETnthANIMITEM
 316+ 5133 E5               PUSH HL
 317+ 5134 FD E1            POP IY
 318+ 5136 D9               EXX
 319+ 5137 FD 36 00 00      LD (IY),0 ; type=0
 320+ 513B FD 75 01         LD (IY+1),L
 321+ 513E FD 74 02         LD (IY+2),H
 322+ 5141 FD 72 03         LD (IY+3),D
 323+ 5144 FD 70 04         LD (IY+4),B
 324+ 5147
 325+ 5147 DD E5            PUSH IX
 326+ 5149 E1               POP HL
 327+ 514A C9               RET
 328+ 514B              ; *******************************************************************************************************
 329+ 514B
 330+ 514B              ; *******************************************************************************************************
 331+ 514B              ; function to handle CALL ANIMITEMPTR basic extension
 332+ 514B              ; ANIMITEMPTR ( BYTE id,
 333+ 514B              ;               INT ticks,
 334+ 514B              ;               INT pointer,
 335+ 514B              ; fills animation item data, returns an error if out of bounds
 336+ 514B              ANIMITEMPTR_CMD:
 337+ 514B                  ; opening (
 338+ 514B CD 3C 64     	CALL CHKCHAR
 339+ 514E 28           	DB '('
 340+ 514F              	; get id
 341+ 514F DD 21 1C 52  	LD IX, GETBYT
 342+ 5153 CD 59 01     	CALL CALBAS
 343+ 5156 F5               PUSH AF
 344+ 5157                  ; check if out of bounds
 345+ 5157 3C               INC A
 346+ 5158 4F               LD C,A
 347+ 5159 3A D4 4F         LD A,(ANIMITEMNUM)
 348+ 515C B9               CP C
 349+ 515D DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 350+ 5160              	; comma
 351+ 5160 CD 3C 64     	CALL CHKCHAR
 352+ 5163 2C           	DB ','
 353+ 5164              	; get ticks
 354+ 5164 DD 21 2F 54  	LD IX, FRMQNT
 355+ 5168 CD 59 01     	CALL CALBAS
 356+ 516B D5           	PUSH DE
 357+ 516C              	; comma
 358+ 516C CD 3C 64     	CALL CHKCHAR
 359+ 516F 2C           	DB ','
 360+ 5170              	; get pointer
 361+ 5170 DD 21 2F 54  	LD IX, FRMQNT
 362+ 5174 CD 59 01     	CALL CALBAS
 363+ 5177 D5           	PUSH DE
 364+ 5178              	; ending )
 365+ 5178 CD 3C 64     	CALL CHKCHAR
 366+ 517B 29           	DB ')'
 367+ 517C              .ENTRY:
 368+ 517C E5               PUSH HL
 369+ 517D DD E1            POP IX
 370+ 517F D9               EXX
 371+ 5180 D1               POP DE ; pointer
 372+ 5181 E1               POP HL ; ticks
 373+ 5182 D9               EXX
 374+ 5183 F1               POP AF
 375+ 5184 CD E9 4F         CALL GETnthANIMITEM
 376+ 5187 E5               PUSH HL
 377+ 5188 FD E1            POP IY
 378+ 518A D9               EXX
 379+ 518B FD 36 00 01      LD (IY),1 ; type=1
 380+ 518F FD 75 01         LD (IY+1),L
 381+ 5192 FD 74 02         LD (IY+2),H
 382+ 5195 FD 73 03         LD (IY+3),E
 383+ 5198 FD 72 04         LD (IY+4),D
 384+ 519B
 385+ 519B DD E5            PUSH IX
 386+ 519D E1               POP HL
 387+ 519E C9               RET
 388+ 519F              ; *******************************************************************************************************
 389+ 519F
 390+ 519F              ; *******************************************************************************************************
 391+ 519F              ; function to handle CALL MAXANIMDEFS basic extension
 392+ 519F              ; MAXANIMDEFS (BYTE number)
 393+ 519F              ; sets new number and moves memory buffers as needed
 394+ 519F              MAXANIMDEFS:
 395+ 519F              	; opening (
 396+ 519F CD 3C 64     	CALL CHKCHAR
 397+ 51A2 28           	DB '('
 398+ 51A3              	; get value
 399+ 51A3 DD 21 1C 52  	LD IX, GETBYT
 400+ 51A7 CD 59 01     	CALL CALBAS
 401+ 51AA F5               PUSH AF
 402+ 51AB              	; ending )
 403+ 51AB CD 3C 64     	CALL CHKCHAR
 404+ 51AE 29           	DB ')'
 405+ 51AF F1               POP AF
 406+ 51B0
 407+ 51B0              	; save position
 408+ 51B0 E5           	PUSH HL
 409+ 51B1              .ENTRY:
 410+ 51B1 47               LD B,A
 411+ 51B2 3A D7 4F         LD A,(ANIMDEFNUM)
 412+ 51B5 90               SUB B
 413+ 51B6 CA 5B 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 414+ 51B9 FD 21 DB 4F      LD IY,ANIMSPRPTR
 415+ 51BD FA C9 51         JP M, .INCREASE
 416+ 51C0                  ; new value is lower than previous one
 417+ 51C0 CD D4 51         CALL .SIZEDIFF
 418+ 51C3 CD 98 50         CALL MAXANIMITEMS.DECREASE_COMMON
 419+ 51C6 C3 49 50         JP MAXANIMITEMS.E1
 420+ 51C9              .INCREASE:
 421+ 51C9 ED 44            NEG
 422+ 51CB CD D4 51         CALL .SIZEDIFF
 423+ 51CE CD C4 50         CALL MAXANIMITEMS.INCREASE_COMMON
 424+ 51D1 C3 6D 50         JP MAXANIMITEMS.E2
 425+ 51D4              .SIZEDIFF:
 426+ 51D4 26 00            LD H,0
 427+ 51D6 6F               LD L,A
 428+ 51D7 CD 29 63         CALL HLx16
 429+ 51DA 78               LD A,B
 430+ 51DB 32 D7 4F         LD (ANIMDEFNUM),A
 431+ 51DE 44               LD B,H
 432+ 51DF 4D               LD C,L
 433+ 51E0 C9               RET ; BC=size difference in bytes
 434+ 51E1              ; *******************************************************************************************************
 435+ 51E1
 436+ 51E1              ; *******************************************************************************************************
 437+ 51E1              ; function to handle CALL ANIMDEF basic extension
 438+ 51E1              ; ANIMITEMPAT ( BYTE id,
 439+ 51E1              ;               BYTE size,
 440+ 51E1              ;               INT[] list )
 441+ 51E1              ; fills animation definition data, returns an error if out of bounds, or invalid type
 442+ 51E1              ANIMDEF:
 443+ 51E1                  ; opening (
 444+ 51E1 CD 3C 64     	CALL CHKCHAR
 445+ 51E4 28           	DB '('
 446+ 51E5              	; get id
 447+ 51E5 DD 21 1C 52  	LD IX, GETBYT
 448+ 51E9 CD 59 01     	CALL CALBAS
 449+ 51EC F5               PUSH AF
 450+ 51ED                  ; check if out of bounds
 451+ 51ED 3C               INC A
 452+ 51EE 4F               LD C,A
 453+ 51EF 3A D7 4F         LD A,(ANIMDEFNUM)
 454+ 51F2 B9               CP C
 455+ 51F3 DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 456+ 51F6              	; comma
 457+ 51F6 CD 3C 64     	CALL CHKCHAR
 458+ 51F9 2C           	DB ','
 459+ 51FA              	; get size
 460+ 51FA DD 21 1C 52  	LD IX, GETBYT
 461+ 51FE CD 59 01     	CALL CALBAS
 462+ 5201 FE 10            CP 16
 463+ 5203 D2 58 64         JP NC, OVERFLOW
 464+ 5206 B7               OR A
 465+ 5207 CA 58 64         JP Z, OVERFLOW
 466+ 520A F5           	PUSH AF
 467+ 520B              	; comma
 468+ 520B CD 3C 64     	CALL CHKCHAR
 469+ 520E 2C           	DB ','
 470+ 520F              	; get pointer to a list of animation items in integer array format
 471+ 520F                  ; get array pointer
 472+ 520F D1               POP DE
 473+ 5210 D5               PUSH DE
 474+ 5211 3E 02            LD A,2
 475+ 5213 06 01            LD B,1
 476+ 5215 CD 69 64         CALL GET_BASIC_ARRAY_DATA_POINTER
 477+ 5218 C5               PUSH BC
 478+ 5219              	; ending )
 479+ 5219 CD 3C 64     	CALL CHKCHAR
 480+ 521C 29           	DB ')'
 481+ 521D              .ENTRY:
 482+ 521D E5               PUSH HL
 483+ 521E DD E1            POP IX
 484+ 5220 D1               POP DE ; pointer to INT array
 485+ 5221 C1               POP BC ; B=item number
 486+ 5222 F1               POP AF ; id
 487+ 5223 D5               PUSH DE
 488+ 5224 CD F2 4F         CALL GETnthANIMDEF
 489+ 5227 D1               POP DE
 490+ 5228 70               LD (HL),B
 491+ 5229              .L1:
 492+ 5229 23               INC HL
 493+ 522A 1A               LD A,(DE)
 494+ 522B 13          > INC DE
 494+ 522C 13          > INC DE
 495+ 522D 77               LD (HL),A
 496+ 522E 10 F9            DJNZ .L1
 497+ 5230 DD E5            PUSH IX
 498+ 5232 E1               POP HL
 499+ 5233 C9               RET
 500+ 5234              ; *******************************************************************************************************
 501+ 5234
 502+ 5234              ; *******************************************************************************************************
 503+ 5234              ; function to handle CALL MAXANIMSPRS basic extension
 504+ 5234              ; MAXANIMSPRS (BYTE number)
 505+ 5234              ; sets new number and moves memory buffers as needed
 506+ 5234              MAXANIMSPRS:
 507+ 5234              	; opening (
 508+ 5234 CD 3C 64     	CALL CHKCHAR
 509+ 5237 28           	DB '('
 510+ 5238              	; get value
 511+ 5238 DD 21 1C 52  	LD IX, GETBYT
 512+ 523C CD 59 01     	CALL CALBAS
 513+ 523F F5               PUSH AF
 514+ 5240              	; ending )
 515+ 5240 CD 3C 64     	CALL CHKCHAR
 516+ 5243 29           	DB ')'
 517+ 5244 F1               POP AF
 518+ 5245
 519+ 5245              	; save position
 520+ 5245 E5           	PUSH HL
 521+ 5246              .ENTRY:
 522+ 5246 47               LD B,A
 523+ 5247 3A DA 4F         LD A,(ANIMSPRNUM)
 524+ 524A 90               SUB B
 525+ 524B CA 5B 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 526+ 524E FD 21 DE 4F      LD IY,AUTOSGAMPTR
 527+ 5252 FA 5E 52         JP M, .INCREASE
 528+ 5255                  ; new value is lower than previous one
 529+ 5255 CD 7D 52         CALL .SIZEDIFF
 530+ 5258 CD 98 50         CALL MAXANIMITEMS.DECREASE_COMMON
 531+ 525B C3 52 50         JP MAXANIMITEMS.E3
 532+ 525E              .INCREASE:
 533+ 525E ED 44            NEG
 534+ 5260 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 535+ 5261 CD 7D 52         CALL .SIZEDIFF
 536+ 5264 CD C4 50         CALL MAXANIMITEMS.INCREASE_COMMON
 537+ 5267 AF               XOR A
 538+ 5268 ED 42            SBC HL,BC ; location of new stuff
 539+ 526A F1               POP AF
 540+ 526B 47               LD B,A
 541+ 526C 11 08 00         LD DE,8
 542+ 526F E5               PUSH HL
 543+ 5270 DD E1            POP IX
 544+ 5272              .L1:
 545+ 5272 DD 36 06 00      LD (IX+6),0
 546+ 5276 DD 19            ADD IX,DE
 547+ 5278 10 F8            DJNZ .L1
 548+ 527A C3 74 50         JP MAXANIMITEMS.E4
 549+ 527D              .SIZEDIFF:
 550+ 527D 26 00            LD H,0
 551+ 527F 6F               LD L,A
 552+ 5280 CD 2A 63         CALL HLx8
 553+ 5283 78               LD A,B
 554+ 5284 32 DA 4F         LD (ANIMSPRNUM),A
 555+ 5287 44               LD B,H
 556+ 5288 4D               LD C,L
 557+ 5289 C9               RET ; BC=size difference in bytes
 558+ 528A              ; *******************************************************************************************************
 559+ 528A
 560+ 528A              ; *******************************************************************************************************
 561+ 528A              ; function to handle CALL ANIMSPRITE basic extension
 562+ 528A              ; ANIMSPRITE ( BYTE id,
 563+ 528A              ;              BYTE sprite_number,
 564+ 528A              ;              BYTE animation_definition_id,
 565+ 528A              ;              BYTE cyclic_flag )
 566+ 528A              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 567+ 528A              ANIMSPRITE:
 568+ 528A                  ; opening (
 569+ 528A CD 3C 64     	CALL CHKCHAR
 570+ 528D 28           	DB '('
 571+ 528E              	; get sprite animation id
 572+ 528E DD 21 1C 52  	LD IX, GETBYT
 573+ 5292 CD 59 01     	CALL CALBAS
 574+ 5295 F5               PUSH AF
 575+ 5296 3C               INC A
 576+ 5297 4F               LD C,A
 577+ 5298 3A DA 4F         LD A,(ANIMSPRNUM)
 578+ 529B B9               CP C
 579+ 529C DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 580+ 529F              	; comma
 581+ 529F CD 3C 64     	CALL CHKCHAR
 582+ 52A2 2C           	DB ','
 583+ 52A3              	; get sprite number
 584+ 52A3 DD 21 1C 52  	LD IX, GETBYT
 585+ 52A7 CD 59 01     	CALL CALBAS
 586+ 52AA F5               PUSH AF
 587+ 52AB                  ; check if out of bounds
 588+ 52AB FE 20            CP 32
 589+ 52AD D2 54 64         JP NC, SUBSCRIPT_OUT_OF_RANGE
 590+ 52B0              	; comma
 591+ 52B0 CD 3C 64     	CALL CHKCHAR
 592+ 52B3 2C           	DB ','
 593+ 52B4              	; get animation definition id
 594+ 52B4 DD 21 1C 52  	LD IX, GETBYT
 595+ 52B8 CD 59 01     	CALL CALBAS
 596+ 52BB F5               PUSH AF
 597+ 52BC 3C               INC A
 598+ 52BD 4F               LD C,A
 599+ 52BE 3A D7 4F         LD A,(ANIMDEFNUM)
 600+ 52C1 B9               CP C
 601+ 52C2 DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 602+ 52C5              	; comma
 603+ 52C5 CD 3C 64     	CALL CHKCHAR
 604+ 52C8 2C           	DB ','
 605+ 52C9              	; get cyclic flag
 606+ 52C9 DD 21 1C 52  	LD IX, GETBYT
 607+ 52CD CD 59 01         CALL CALBAS
 608+ 52D0 F5           	PUSH AF
 609+ 52D1              	; ending )
 610+ 52D1 CD 3C 64     	CALL CHKCHAR
 611+ 52D4 29           	DB ')'
 612+ 52D5              .ENTRY:
 613+ 52D5 E5               PUSH HL
 614+ 52D6 DD E1            POP IX
 615+ 52D8 D9               EXX
 616+ 52D9 D1               POP DE ; cyclic
 617+ 52DA C1               POP BC ; animation definition id
 618+ 52DB E1               POP HL ; sprite number
 619+ 52DC D9               EXX
 620+ 52DD F1               POP AF ; sprite animation id
 621+ 52DE CD FE 4F         CALL GETnthSPRANIM
 622+ 52E1 E5               PUSH HL
 623+ 52E2 FD E1            POP IY
 624+ 52E4 D9               EXX
 625+ 52E5 FD 74 00         LD (IY),H
 626+ 52E8 FD 70 04         LD (IY+4),B
 627+ 52EB FD 72 05         LD (IY+5),D
 628+ 52EE                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 629+ 52EE                  ; following will do preparation for ANIMSTEP situation
 630+ 52EE                  ; current item set to above limit and timer to 1
 631+ 52EE                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 632+ 52EE FD 36 03 FF      LD (IY+3),255
 633+ 52F2 FD 36 01 01      LD (IY+1),1
 634+ 52F6 FD 36 02 00      LD (IY+2),0
 635+ 52FA                  ; mark as sprite animation
 636+ 52FA FD 36 07 00      LD (IY+7),0
 637+ 52FE DD E5            PUSH IX
 638+ 5300 E1               POP HL
 639+ 5301 C9               RET
 640+ 5302              ; *******************************************************************************************************
 641+ 5302
 642+ 5302              ; *******************************************************************************************************
 643+ 5302              ; function to handle CALL ANIMCHAR basic extension
 644+ 5302              ; ANIMCHAR ( BYTE id,
 645+ 5302              ;            INT character number 0-767,
 646+ 5302              ;            BYTE animation_definition_id,
 647+ 5302              ;            BYTE cyclic_flag )
 648+ 5302              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 649+ 5302              ANIMCHAR:
 650+ 5302                  ; opening (
 651+ 5302 CD 3C 64     	CALL CHKCHAR
 652+ 5305 28           	DB '('
 653+ 5306              	; get sprite animation id
 654+ 5306 DD 21 1C 52  	LD IX, GETBYT
 655+ 530A CD 59 01     	CALL CALBAS
 656+ 530D F5               PUSH AF
 657+ 530E 3C               INC A
 658+ 530F 4F               LD C,A
 659+ 5310 3A DA 4F         LD A,(ANIMSPRNUM)
 660+ 5313 B9               CP C
 661+ 5314 DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 662+ 5317              	; comma
 663+ 5317 CD 3C 64     	CALL CHKCHAR
 664+ 531A 2C           	DB ','
 665+ 531B              	; get character number
 666+ 531B DD 21 2F 54  	LD IX, FRMQNT
 667+ 531F CD 59 01     	CALL CALBAS
 668+ 5322 D5               PUSH DE
 669+ 5323                  ; check if out of bounds
 670+ 5323 7A               LD A,D
 671+ 5324 FE 03            CP 3
 672+ 5326 D2 54 64         JP NC, SUBSCRIPT_OUT_OF_RANGE
 673+ 5329              	; comma
 674+ 5329 CD 3C 64     	CALL CHKCHAR
 675+ 532C 2C           	DB ','
 676+ 532D              	; get animation definition id
 677+ 532D DD 21 1C 52  	LD IX, GETBYT
 678+ 5331 CD 59 01     	CALL CALBAS
 679+ 5334 F5               PUSH AF
 680+ 5335 3C               INC A
 681+ 5336 4F               LD C,A
 682+ 5337 3A D7 4F         LD A,(ANIMDEFNUM)
 683+ 533A B9               CP C
 684+ 533B DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 685+ 533E              	; comma
 686+ 533E CD 3C 64     	CALL CHKCHAR
 687+ 5341 2C           	DB ','
 688+ 5342              	; get cyclic flag
 689+ 5342 DD 21 1C 52  	LD IX, GETBYT
 690+ 5346 CD 59 01         CALL CALBAS
 691+ 5349 F5           	PUSH AF
 692+ 534A              	; ending )
 693+ 534A CD 3C 64     	CALL CHKCHAR
 694+ 534D 29           	DB ')'
 695+ 534E              .ENTRY:
 696+ 534E E5               PUSH HL
 697+ 534F DD E1            POP IX
 698+ 5351 D9               EXX
 699+ 5352 D1               POP DE ; cyclic
 700+ 5353 C1               POP BC ; animation definition id
 701+ 5354 E1               POP HL ; character number
 702+ 5355 D9               EXX
 703+ 5356 F1               POP AF ; sprite animation id
 704+ 5357 CD FE 4F         CALL GETnthSPRANIM
 705+ 535A E5               PUSH HL
 706+ 535B FD E1            POP IY
 707+ 535D D9               EXX
 708+ 535E FD 75 00         LD (IY),L
 709+ 5361 24               INC H ; save character bank+1
 710+ 5362 FD 74 07         LD (IY+7),H
 711+ 5365 FD 70 04         LD (IY+4),B
 712+ 5368 FD 72 05         LD (IY+5),D
 713+ 536B                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 714+ 536B                  ; following will do preparation for ANIMSTEP situation
 715+ 536B                  ; current item set to above limit and timer to 1
 716+ 536B                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 717+ 536B FD 36 03 FF      LD (IY+3),255
 718+ 536F FD 36 01 01      LD (IY+1),1
 719+ 5373 FD 36 02 00      LD (IY+2),0
 720+ 5377 DD E5            PUSH IX
 721+ 5379 E1               POP HL
 722+ 537A C9               RET
 723+ 537B              ; *******************************************************************************************************
 724+ 537B
 725+ 537B              ; *******************************************************************************************************
 726+ 537B              ; function to handle CALL MAXAUTOSGAMS basic extension
 727+ 537B              ; MAXAUTOSGAMS (BYTE number)
 728+ 537B              ; sets new number and moves memory buffers as needed
 729+ 537B              MAXAUTOSGAMS:
 730+ 537B              	; opening (
 731+ 537B CD 3C 64     	CALL CHKCHAR
 732+ 537E 28           	DB '('
 733+ 537F              	; get value
 734+ 537F DD 21 1C 52  	LD IX, GETBYT
 735+ 5383 CD 59 01     	CALL CALBAS
 736+ 5386 F5               PUSH AF
 737+ 5387              	; ending )
 738+ 5387 CD 3C 64     	CALL CHKCHAR
 739+ 538A 29           	DB ')'
 740+ 538B F1               POP AF
 741+ 538C
 742+ 538C              	; save position
 743+ 538C E5           	PUSH HL
 744+ 538D              .ENTRY:
 745+ 538D 47               LD B,A
 746+ 538E 3A DD 4F         LD A,(AUTOSGAMNUM)
 747+ 5391 90               SUB B
 748+ 5392 CA 5B 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 749+ 5395 FD 21 10 40      LD IY,FREEMEMPTR
 750+ 5399 FA A5 53         JP M, .INCREASE
 751+ 539C                  ; new value is lower than previous one
 752+ 539C CD C4 53         CALL .SIZEDIFF
 753+ 539F CD 98 50         CALL MAXANIMITEMS.DECREASE_COMMON
 754+ 53A2 C3 5B 50         JP MAXANIMITEMS.EXIT
 755+ 53A5              .INCREASE:
 756+ 53A5 ED 44            NEG
 757+ 53A7 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 758+ 53A8 CD C4 53         CALL .SIZEDIFF
 759+ 53AB CD C4 50         CALL MAXANIMITEMS.INCREASE_COMMON
 760+ 53AE AF               XOR A
 761+ 53AF ED 42            SBC HL,BC ; location of new stuff
 762+ 53B1 F1               POP AF
 763+ 53B2 47               LD B,A
 764+ 53B3 11 18 00         LD DE,24
 765+ 53B6 E5               PUSH HL
 766+ 53B7 DD E1            POP IX
 767+ 53B9              .L1:
 768+ 53B9 DD 36 13 00      LD (IX+19),0 ; active flag
 769+ 53BD DD 19            ADD IX,DE
 770+ 53BF 10 F8            DJNZ .L1
 771+ 53C1 C3 5B 50         JP MAXANIMITEMS.EXIT
 772+ 53C4              .SIZEDIFF:
 773+ 53C4 26 00            LD H,0
 774+ 53C6 6F               LD L,A
 775+ 53C7 CD 2A 63         CALL HLx8
 776+ 53CA 54               LD D,H
 777+ 53CB 5D               LD E,L
 778+ 53CC 29               ADD HL,HL
 779+ 53CD 19               ADD HL,DE
 780+ 53CE 78               LD A,B
 781+ 53CF 32 DD 4F         LD (AUTOSGAMNUM),A
 782+ 53D2 44               LD B,H
 783+ 53D3 4D               LD C,L
 784+ 53D4 C9               RET ; BC=size difference in bytes
 785+ 53D5              ; *******************************************************************************************************
 786+ 53D5
 787+ 53D5              ; *******************************************************************************************************
 788+ 53D5              ; function to handle CALL AUTOSGAMDEF basic extension
 789+ 53D5              ; AUTOSGAMDEF ( BYTE id,
 790+ 53D5              ;               INT VARIABLE x, INT VARIABLE y,
 791+ 53D5              ;               INT minimum, INT maximum, INT delta,
 792+ 53D5              ;               INT direction,
 793+ 53D5              ;               INT ticks,
 794+ 53D5              ;               BYTE sprite_group_count,
 795+ 53D5              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
 796+ 53D5              ;               BYTE item_number,
 797+ 53D5              ;               INT[] VARIABLE sprite_animations_negative_direction,
 798+ 53D5              ;               INT[] VARIABLE sprite_animations_positive_direction
 799+ 53D5              AUTOSGAMDEF:
 800+ 53D5                  ; opening (
 801+ 53D5 CD 3C 64     	CALL CHKCHAR
 802+ 53D8 28           	DB '('
 803+ 53D9              	; get sprite animation id
 804+ 53D9 DD 21 1C 52  	LD IX, GETBYT
 805+ 53DD CD 59 01     	CALL CALBAS
 806+ 53E0 F5               PUSH AF
 807+ 53E1 3C               INC A
 808+ 53E2 4F               LD C,A
 809+ 53E3 3A DD 4F         LD A,(AUTOSGAMNUM)
 810+ 53E6 B9               CP C
 811+ 53E7 DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
 812+ 53EA F1               POP AF
 813+ 53EB E5               PUSH HL
 814+ 53EC CD 0A 50         CALL GETnthAUTOSGAM
 815+ 53EF 22 49 61         LD (BLIT_TMP),HL ; for later
 816+ 53F2 E1               POP HL
 817+ 53F3              	; comma
 818+ 53F3 CD 3C 64     	CALL CHKCHAR
 819+ 53F6 2C           	DB ','
 820+ 53F7              	; get address of the X coordinate variable
 821+ 53F7 DD 21 A4 5E  	LD IX, PTRGET
 822+ 53FB CD 59 01     	CALL CALBAS
 823+ 53FE DD 2A 49 61  	LD IX,(BLIT_TMP)
 824+ 5402 DD 73 00         LD (IX+0),E
 825+ 5405 DD 72 01         LD (IX+1),D
 826+ 5408              	; comma
 827+ 5408 CD 3C 64     	CALL CHKCHAR
 828+ 540B 2C           	DB ','
 829+ 540C              	; get address of the Y coordinate variable
 830+ 540C DD 21 A4 5E  	LD IX, PTRGET
 831+ 5410 CD 59 01     	CALL CALBAS
 832+ 5413 DD 2A 49 61  	LD IX,(BLIT_TMP)
 833+ 5417 DD 73 02         LD (IX+2),E
 834+ 541A DD 72 03         LD (IX+3),D
 835+ 541D              	; comma
 836+ 541D CD 3C 64     	CALL CHKCHAR
 837+ 5420 2C           	DB ','
 838+ 5421              	; get minimum value
 839+ 5421 DD 21 2F 54  	LD IX, FRMQNT
 840+ 5425 CD 59 01     	CALL CALBAS
 841+ 5428 DD 2A 49 61  	LD IX,(BLIT_TMP)
 842+ 542C DD 73 04         LD (IX+4),E
 843+ 542F DD 72 05         LD (IX+5),D
 844+ 5432              	; comma
 845+ 5432 CD 3C 64     	CALL CHKCHAR
 846+ 5435 2C           	DB ','
 847+ 5436              	; get maximum value
 848+ 5436 DD 21 2F 54  	LD IX, FRMQNT
 849+ 543A CD 59 01     	CALL CALBAS
 850+ 543D DD 2A 49 61  	LD IX,(BLIT_TMP)
 851+ 5441 DD 73 06         LD (IX+6),E
 852+ 5444 DD 72 07         LD (IX+7),D
 853+ 5447              	; comma
 854+ 5447 CD 3C 64     	CALL CHKCHAR
 855+ 544A 2C           	DB ','
 856+ 544B              	; get delta value
 857+ 544B DD 21 2F 54  	LD IX, FRMQNT
 858+ 544F CD 59 01     	CALL CALBAS
 859+ 5452 DD 2A 49 61  	LD IX,(BLIT_TMP)
 860+ 5456 DD 73 08         LD (IX+8),E
 861+ 5459 DD 72 09         LD (IX+9),D
 862+ 545C              	; comma
 863+ 545C CD 3C 64     	CALL CHKCHAR
 864+ 545F 2C           	DB ','
 865+ 5460              	; get direction value
 866+ 5460 DD 21 2F 54  	LD IX, FRMQNT
 867+ 5464 CD 59 01     	CALL CALBAS
 868+ 5467 DD 2A 49 61  	LD IX,(BLIT_TMP)
 869+ 546B DD 73 0A         LD (IX+10),E
 870+ 546E DD 72 0B         LD (IX+11),D
 871+ 5471              	; comma
 872+ 5471 CD 3C 64     	CALL CHKCHAR
 873+ 5474 2C           	DB ','
 874+ 5475              	; get ticks value
 875+ 5475 DD 21 2F 54  	LD IX, FRMQNT
 876+ 5479 CD 59 01     	CALL CALBAS
 877+ 547C DD 2A 49 61  	LD IX,(BLIT_TMP)
 878+ 5480 DD 73 14         LD (IX+20),E
 879+ 5483 DD 72 15         LD (IX+21),D
 880+ 5486              	; comma
 881+ 5486 CD 3C 64     	CALL CHKCHAR
 882+ 5489 2C           	DB ','
 883+ 548A              	; get sprite group count
 884+ 548A DD 21 1C 52  	LD IX, GETBYT
 885+ 548E CD 59 01     	CALL CALBAS
 886+ 5491 B7               OR A
 887+ 5492 CA 54 64         JP Z,SUBSCRIPT_OUT_OF_RANGE
 888+ 5495 DD 2A 49 61  	LD IX,(BLIT_TMP)
 889+ 5499 DD 77 0B         LD (IX+11),A
 890+ 549C              	; comma
 891+ 549C CD 3C 64     	CALL CHKCHAR
 892+ 549F 2C           	DB ','
 893+ 54A0              	; get sprite group definition array data pointer
 894+ 54A0 DD 2A 49 61  	LD IX,(BLIT_TMP)
 895+ 54A4 DD 5E 0B         LD E,(IX+11)
 896+ 54A7 16 03        	LD D,3
 897+ 54A9 3E 02        	LD A,2
 898+ 54AB 47           	LD B,A
 899+ 54AC CD 69 64     	CALL GET_BASIC_ARRAY_DATA_POINTER
 900+ 54AF DD 2A 49 61  	LD IX,(BLIT_TMP)
 901+ 54B3 DD 71 0C     	LD (IX+12),C
 902+ 54B6 DD 70 0D         LD (IX+13),B
 903+ 54B9              	; comma
 904+ 54B9 CD 3C 64     	CALL CHKCHAR
 905+ 54BC 2C           	DB ','
 906+ 54BD              	; get sprite animation array size
 907+ 54BD DD 21 1C 52  	LD IX,GETBYT
 908+ 54C1 CD 59 01     	CALL CALBAS
 909+ 54C4 DD 2A 49 61  	LD IX,(BLIT_TMP)
 910+ 54C8 DD 77 0E         LD (IX+14),A
 911+ 54CB B7               OR A
 912+ 54CC CA 54 64         JP Z,SUBSCRIPT_OUT_OF_RANGE
 913+ 54CF              	; comma
 914+ 54CF CD 3C 64     	CALL CHKCHAR
 915+ 54D2 2C           	DB ','
 916+ 54D3                  ; get array pointer for negative direction
 917+ 54D3 DD 2A 49 61  	LD IX,(BLIT_TMP)
 918+ 54D7 DD 56 0E         LD D,(IX+14)
 919+ 54DA 3E 02            LD A,2
 920+ 54DC 06 01            LD B,1
 921+ 54DE CD 69 64         CALL GET_BASIC_ARRAY_DATA_POINTER
 922+ 54E1 DD 2A 49 61  	LD IX,(BLIT_TMP)
 923+ 54E5 DD 71 0F         LD (IX+15),C
 924+ 54E8 DD 70 10         LD (IX+16),B
 925+ 54EB              	; comma
 926+ 54EB CD 3C 64     	CALL CHKCHAR
 927+ 54EE 2C           	DB ','
 928+ 54EF                  ; get array pointer for positive direction
 929+ 54EF DD 2A 49 61  	LD IX,(BLIT_TMP)
 930+ 54F3 DD 56 0E         LD D,(IX+14)
 931+ 54F6 3E 02            LD A,2
 932+ 54F8 06 01            LD B,1
 933+ 54FA CD 69 64         CALL GET_BASIC_ARRAY_DATA_POINTER
 934+ 54FD DD 2A 49 61  	LD IX,(BLIT_TMP)
 935+ 5501 DD 71 11         LD (IX+17),C
 936+ 5504 DD 70 12         LD (IX+18),B
 937+ 5507              	; ending )
 938+ 5507 CD 3C 64     	CALL CHKCHAR
 939+ 550A 29           	DB ')'
 940+ 550B C9               RET
 941+ 550C              ; *******************************************************************************************************
 942+ 550C
 943+ 550C              ; *******************************************************************************************************
 944+ 550C              ; function to handle CALL ANIMSTEP basic extension
 945+ 550C              ; two forms
 946+ 550C              ; ANIMSTEP ( BYTE id )
 947+ 550C              ; or
 948+ 550C              ; ANIMSTEP ( BYTE item_number,
 949+ 550C              ;            INT[] sprite_animations )
 950+ 550C              ; sets active flag to 1
 951+ 550C              ANIMSTEP:
 952+ 550C 11 89 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
 953+ 550F 18 08            JR ANIMSTARTSTOP_COMMON
 954+ 5511              ; *******************************************************************************************************
 955+ 5511              ; *******************************************************************************************************
 956+ 5511              ; function to handle CALL ANIMSTART basic extension
 957+ 5511              ; two forms
 958+ 5511              ; ANIMSTART ( BYTE id )
 959+ 5511              ; or
 960+ 5511              ; ANIMSTART ( BYTE item_number,
 961+ 5511              ;             INT[] sprite_animations )
 962+ 5511              ; sets active flag to 1
 963+ 5511              ANIMSTART:
 964+ 5511 11 77 55         LD DE,ANIMSTARTSTOP_COMMON.START
 965+ 5514 18 03            JR ANIMSTARTSTOP_COMMON
 966+ 5516              ; *******************************************************************************************************
 967+ 5516              ; *******************************************************************************************************
 968+ 5516              ; function to handle CALL ANIMSTOP basic extension
 969+ 5516              ; two forms
 970+ 5516              ; ANIMSTOP ( BYTE id )
 971+ 5516              ; or
 972+ 5516              ; ANIMSTOP ( BYTE item_number,
 973+ 5516              ;            INT[] sprite_animations )
 974+ 5516              ; sets active flag to 1
 975+ 5516              ANIMSTOP:
 976+ 5516 11 84 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
 977+ 5519              ; *******************************************************************************************************
 978+ 5519              ANIMSTARTSTOP_COMMON:
 979+ 5519 ED 53 75 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
 980+ 551D                  ; opening (
 981+ 551D CD 3C 64     	CALL CHKCHAR
 982+ 5520 28           	DB '('
 983+ 5521              	; get sprite animation id or array size
 984+ 5521 DD 21 1C 52  	LD IX,GETBYT
 985+ 5525 CD 59 01     	CALL CALBAS
 986+ 5528 F5               PUSH AF
 987+ 5529                  ; check if comma present
 988+ 5529 CD 46 64         CALL GETPREVCHAR
 989+ 552C 23               INC HL
 990+ 552D FE 2C            CP ','
 991+ 552F 28 0C            JR Z,.L1
 992+ 5531 FE 29            CP ')'
 993+ 5533 C2 60 64         JP NZ,SYNTAX_ERROR
 994+ 5536                  ; ok so single argument variant
 995+ 5536 F1               POP AF
 996+ 5537 E5               PUSH HL
 997+ 5538 CD 63 55         CALL .SETVALUE
 998+ 553B E1               POP HL
 999+ 553C C9               RET
1000+ 553D              .L1:
1001+ 553D                  ; get array pointer
1002+ 553D D1               POP DE
1003+ 553E D5               PUSH DE
1004+ 553F 3E 02            LD A,2
1005+ 5541 06 01            LD B,1
1006+ 5543 CD 69 64         CALL GET_BASIC_ARRAY_DATA_POINTER
1007+ 5546 C5               PUSH BC
1008+ 5547              	; ending )
1009+ 5547 CD 3C 64     	CALL CHKCHAR
1010+ 554A 29           	DB ')'
1011+ 554B D1               POP DE ; array pointer
1012+ 554C C1               POP BC ; number of items
1013+ 554D 78               LD A,B
1014+ 554E B7               OR A
1015+ 554F CA 54 64         JP Z,SUBSCRIPT_OUT_OF_RANGE
1016+ 5552 E5               PUSH HL
1017+ 5553 F3               DI
1018+ 5554              .L2:
1019+ 5554 C5               PUSH BC
1020+ 5555 1A               LD A,(DE)
1021+ 5556 13          > INC DE
1021+ 5557 13          > INC DE
1022+ 5558 D5               PUSH DE
1023+ 5559 CD 63 55         CALL .SETVALUE
1024+ 555C D1               POP DE
1025+ 555D C1               POP BC
1026+ 555E 10 F4            DJNZ .L2
1027+ 5560 FB               EI
1028+ 5561 E1               POP HL
1029+ 5562 C9               RET
1030+ 5563
1031+ 5563              .SETVALUE:
1032+ 5563 47               LD B,A
1033+ 5564 3C               INC A
1034+ 5565 4F               LD C,A
1035+ 5566 3A DA 4F         LD A,(ANIMSPRNUM)
1036+ 5569 B9               CP C
1037+ 556A DA 54 64         JP C,SUBSCRIPT_OUT_OF_RANGE
1038+ 556D 78               LD A,B
1039+ 556E CD FE 4F         CALL GETnthSPRANIM
1040+ 5571 E5               PUSH HL
1041+ 5572 DD E1            POP IX
1042+ 5574              .FN:
1043+ 5574 C3 00 00         JP 0
1044+ 5577              .START:
1045+ 5577 DD 36 06 01      LD (IX+6),1 ; active flag
1046+ 557B DD 36 03 00      LD (IX+3),0 ; current item
1047+ 557F 06 00            LD B,0 ; setup timer
1048+ 5581 C3 08 56         JP SETUP_ANIM_STEP
1049+ 5584              .STOP:
1050+ 5584 DD 36 06 00      LD (IX+6),0 ; active flag
1051+ 5588 C9               RET
1052+ 5589              .STEP:
1053+ 5589 06 00            LD B,0
1054+ 558B C3 AC 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1055+ 558E              ; *******************************************************************************************************
1056+ 558E
1057+ 558E              ; *******************************************************************************************************
1058+ 558E              ; function processes animations during vblank period
1059+ 558E              PROCESS_ANIMATIONS:
1060+ 558E 3A DA 4F         LD A,(ANIMSPRNUM)
1061+ 5591 B7               OR A
1062+ 5592 C8               RET Z; no animations defined
1063+ 5593 47               LD B,A
1064+ 5594 DD 2A DB 4F      LD IX,(ANIMSPRPTR)
1065+ 5598              .L1:
1066+ 5598 C5               PUSH BC
1067+ 5599 06 00            LD B,0 ; normal mode, change on timer expiry only
1068+ 559B CD A7 55         CALL PROCESS_SINGLE_ANIMATION
1069+ 559E 11 08 00         LD DE,8
1070+ 55A1 DD 19            ADD IX,DE
1071+ 55A3 C1               POP BC
1072+ 55A4 10 F2            DJNZ .L1
1073+ 55A6 C9               RET
1074+ 55A7              ; *******************************************************************************************************
1075+ 55A7
1076+ 55A7              ; *******************************************************************************************************
1077+ 55A7              ; processes single sprite animation
1078+ 55A7              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1079+ 55A7              ; on timer expiry goes to next animation item
1080+ 55A7              ; input IX=sprite animation pointer
1081+ 55A7              ; input B=1 force mode, activate animation action regardless of expired timer
1082+ 55A7              PROCESS_SINGLE_ANIMATION:
1083+ 55A7 DD 7E 06         LD A,(IX+6); active
1084+ 55AA B7               OR A
1085+ 55AB C8               RET Z ; inactive animation
1086+ 55AC              .INACTIVE_TOO:
1087+ 55AC DD 6E 01         LD L,(IX+1)
1088+ 55AF DD 66 02         LD H,(IX+2) ; HL=end time
1089+ 55B2 2B               DEC HL
1090+ 55B3 DD 75 01         LD (IX+1),L
1091+ 55B6 DD 74 02         LD (IX+2),H
1092+ 55B9 7D               LD A,L
1093+ 55BA B4               OR H
1094+ 55BB 28 06            JR Z,.STEP
1095+ 55BD 05               DEC B
1096+ 55BE 04               INC B
1097+ 55BF C8               RET Z ; not forced mode, return
1098+ 55C0 C3 08 56         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1099+ 55C3              .STEP:
1100+ 55C3 06 00            LD B,0; setup timer
1101+ 55C5 DD 34 03         INC (IX+3) ; current animation item
1102+ 55C8 C3 08 56         JP SETUP_ANIM_STEP
1103+ 55CB              ; *******************************************************************************************************
1104+ 55CB
1105+ 55CB              ; *******************************************************************************************************
1106+ 55CB              ; function will setup sprite animation after current item change
1107+ 55CB              ; input A=current animation definition
1108+ 55CB              ; input IX=pointer to sprite animation
1109+ 55CB              ; input B=1 skip timer setup
1110+ 55CB              ; output IY=pointer to animation item
1111+ 55CB              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1112+ 55CB              ; basically sets new end time for current animation
1113+ 55CB              INIT_CURRENT_ANIMATION:
1114+ 55CB CD F2 4F         CALL GETnthANIMDEF
1115+ 55CE DD 7E 03         LD A,(IX+3) ; current animation item
1116+ 55D1 BE               CP (HL) ; number of animation items in the animation definition
1117+ 55D2 38 0A            JR C,.L3 ; last item not reached
1118+ 55D4                  ; last item reached
1119+ 55D4 DD 7E 05         LD A,(IX+5) ; cyclic flag
1120+ 55D7 B7               OR A
1121+ 55D8 28 2C            JR Z,.ERROR ; non-cyclic animation
1122+ 55DA                  ; cyclic animation, restart
1123+ 55DA DD 36 03 00      LD (IX+3),0; current item
1124+ 55DE              .L3:
1125+ 55DE                  ; HL = animation definition
1126+ 55DE 23               INC HL ; skip animation definition size field
1127+ 55DF 16 00            LD D,0
1128+ 55E1 DD 5E 03         LD E,(IX+3); current item
1129+ 55E4 19               ADD HL,DE
1130+ 55E5 4E               LD C,(HL) ; current animation item
1131+ 55E6 0C               INC C
1132+ 55E7 3A D4 4F         LD A,(ANIMITEMNUM)
1133+ 55EA B9               CP C
1134+ 55EB 38 19            JR C,.ERROR ; invalid animation item, stop animation
1135+ 55ED 0D               DEC C
1136+ 55EE 79               LD A,C
1137+ 55EF CD E9 4F         CALL GETnthANIMITEM
1138+ 55F2 E5               PUSH HL
1139+ 55F3 FD E1            POP IY ; IY=animation item
1140+ 55F5 05               DEC B
1141+ 55F6 28 0C            JR Z,.EXIT
1142+ 55F8 FD 5E 01         LD E,(IY+1)
1143+ 55FB FD 56 02         LD D,(IY+2) ; duration
1144+ 55FE DD 73 01         LD (IX+1),E
1145+ 5601 DD 72 02         LD (IX+2),D
1146+ 5604              .EXIT:
1147+ 5604 AF               XOR A
1148+ 5605 C9               RET
1149+ 5606              .ERROR:
1150+ 5606 37               SCF
1151+ 5607 C9               RET
1152+ 5608              ; *******************************************************************************************************
1153+ 5608
1154+ 5608              ; *******************************************************************************************************
1155+ 5608              ; function will display currect item and set up expiry time
1156+ 5608              ; it will also stop the animation if expired
1157+ 5608              ; sets sprite update flag if any changes in sprite data made
1158+ 5608              ; input IX=current sprite animation
1159+ 5608              ; input B=1 skip timer setup
1160+ 5608              SETUP_ANIM_STEP:
1161+ 5608 DD 4E 04         LD C,(IX+4) ; animation definition ID
1162+ 560B 0C               INC C
1163+ 560C 3A D7 4F         LD A,(ANIMDEFNUM)
1164+ 560F B9               CP C
1165+ 5610 30 05            JR NC,.L2
1166+ 5612                  ; given animation item is outside of bounds, deactivate animation
1167+ 5612              .STOPANIM:
1168+ 5612 DD 36 06 00      LD (IX+6),0
1169+ 5616 C9               RET
1170+ 5617              .L2:
1171+ 5617 0D               DEC C
1172+ 5618 79               LD A,C
1173+ 5619 CD CB 55         CALL INIT_CURRENT_ANIMATION
1174+ 561C 38 F4            JR C, .STOPANIM
1175+ 561E FD 7E 00         LD A,(IY) ; type of animation item
1176+ 5621 B7               OR A
1177+ 5622 28 44            JR Z,.L4 ; change pattern and/or color
1178+ 5624              .PAT:
1179+ 5624                  ; change pattern definition
1180+ 5624                  ; check if sprite or character
1181+ 5624 DD 7E 07         LD A,(IX+7)
1182+ 5627 B7               OR A
1183+ 5628 20 58            JR NZ,.CHAR
1184+ 562A DD 7E 00         LD A,(IX) ; sprite number
1185+ 562D CD 7C 4D         CALL GETnthSPRATTR
1186+ 5630 23          > INC HL ; skip y and x
1186+ 5631 23          > INC HL
1186+ 5632 23          > INC HL
1186+ 5633 23          > INC HL
1187+ 5634 7E               LD A,(HL); current pattern
1188+ 5635 26 00            LD H,0
1189+ 5637 6F               LD L,A
1190+ 5638 3A E0 F3         LD A,(REG1SAV)
1191+ 563B E6 02            AND 2
1192+ 563D 20 07            JR NZ,.L6
1193+ 563F                  ; 8x8 sprite
1194+ 563F CD 2A 63         CALL HLx8
1195+ 5642 06 08            LD B,8
1196+ 5644 18 05            JR .L5
1197+ 5646              .L6:
1198+ 5646 CD 28 63         CALL HLx32
1199+ 5649 06 20            LD B,32
1200+ 564B              .L5:
1201+ 564B 3A AF FC         LD A,(SCRMOD)
1202+ 564E 3D               DEC A
1203+ 564F 20 06            JR NZ,.L10
1204+ 5651 ED 5B C5 F3      LD DE,(T32PAT)
1205+ 5655 18 04            JR .L7
1206+ 5657              .L10:
1207+ 5657 ED 5B CF F3      LD DE,(GRPPAT)
1208+ 565B              .L7:
1209+ 565B 19               ADD HL,DE
1210+ 565C CD 15 63         CALL SETWRT_LOCAL
1211+ 565F FD 6E 03         LD L,(IY+3)
1212+ 5662 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1213+ 5665 C3 20 63         JP BBYTECOPY
1214+ 5668              .L4:
1215+ 5668                  ; change pattern and color in sprite attributes table
1216+ 5668 DD 7E 00         LD A,(IX) ; sprite number
1217+ 566B CD 7C 4D         CALL GETnthSPRATTR
1218+ 566E 23          > INC HL ; skip y and x
1218+ 566F 23          > INC HL
1218+ 5670 23          > INC HL
1218+ 5671 23          > INC HL
1219+ 5672 FD 7E 03         LD A,(IY+3) ; new pattern
1220+ 5675 77               LD (HL),A
1221+ 5676 23          > INC HL
1221+ 5677 23          > INC HL
1222+ 5678 FD 7E 04         LD A,(IY+4) ; new color
1223+ 567B 77               LD (HL),A
1224+ 567C 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
1225+ 567F 36 01            LD (HL),1
1226+ 5681 C9               RET
1227+ 5682              .CHAR:
1228+ 5682 DD 6E 00         LD L,(IX)
1229+ 5685 3D               DEC A
1230+ 5686 67               LD H,A
1231+ 5687 CD 2A 63         CALL HLx8
1232+ 568A 3A AF FC         LD A,(SCRMOD)
1233+ 568D 3D               DEC A
1234+ 568E 20 06            JR NZ,.L8
1235+ 5690 ED 5B C1 F3      LD DE,(T32CGP)
1236+ 5694 18 04            JR .L9
1237+ 5696              .L8:
1238+ 5696 ED 5B CB F3      LD DE,(GRPCGP)
1239+ 569A              .L9:
1240+ 569A 06 08            LD B,8
1241+ 569C 18 BD            JR .L7
1242+ 569E              ; *******************************************************************************************************
1243+ 569E
# file closed: asm\ANIMATION.asm
 124  569E               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 569E              ; Sprite Group Animate and Move
   2+ 569E
   3+ 569E              ; *******************************************************************************************************
   4+ 569E              ; shared function to process a list of animations
   5+ 569E              ; input B=list size
   6+ 569E              ; input DE=list pointer
   7+ 569E              SGAM_PROCESS_ANIM_LIST:
   8+ 569E 21 B1 56         LD HL,.STEP
   9+ 56A1 22 75 55         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 56A4              .L1:
  11+ 56A4 C5               PUSH BC
  12+ 56A5 1A               LD A,(DE)
  13+ 56A6 13          > INC DE
  13+ 56A7 13          > INC DE
  14+ 56A8 D5               PUSH DE
  15+ 56A9 CD 63 55         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 56AC D1               POP DE
  17+ 56AD C1               POP BC
  18+ 56AE 10 F4            DJNZ .L1
  19+ 56B0 C9           	RET
  20+ 56B1              .STEP:
  21+ 56B1 06 01            LD B,1
  22+ 56B3 C3 AC 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 56B6              ; *******************************************************************************************************
  24+ 56B6
  25+ 56B6              ; *******************************************************************************************************
  26+ 56B6              ; function to handle CALL SGAM basic extension
  27+ 56B6              ; sets position of a group of sprites as described in SPRGRPMOV
  28+ 56B6              ; and manually animate a list of animations
  29+ 56B6              ; _SGAM ( INT x,
  30+ 56B6              ;	      INT y,
  31+ 56B6              ;		  BYTE count,
  32+ 56B6              ;		  INT[2][count] data_ptr,
  33+ 56B6              ;         BYTE item_number,
  34+ 56B6              ;         INT[] sprite_animations )
  35+ 56B6              ; will put ram in page 0 also, page 1 is already there
  36+ 56B6              SGAM:
  37+ 56B6 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
  38+ 56B9 B7           	OR A
  39+ 56BA CA 5C 64     	JP Z,ILLEGAL_FUNCTION
  40+ 56BD              	; opening (
  41+ 56BD CD 3C 64     	CALL CHKCHAR
  42+ 56C0 28           	DB '('
  43+ 56C1              	; get x
  44+ 56C1 DD 21 2F 54  	LD IX, FRMQNT
  45+ 56C5 CD 59 01     	CALL CALBAS
  46+ 56C8 ED 53 4D 61  	LD (BLIT_STRUCT),DE
  47+ 56CC              	; comma
  48+ 56CC CD 3C 64     	CALL CHKCHAR
  49+ 56CF 2C           	DB ','
  50+ 56D0              	; get y
  51+ 56D0 DD 21 2F 54  	LD IX, FRMQNT
  52+ 56D4 CD 59 01     	CALL CALBAS
  53+ 56D7 ED 53 4F 61  	LD (BLIT_STRUCT+2),DE
  54+ 56DB              	; comma
  55+ 56DB CD 3C 64     	CALL CHKCHAR
  56+ 56DE 2C           	DB ','
  57+ 56DF              	; get count
  58+ 56DF DD 21 1C 52  	LD IX, GETBYT
  59+ 56E3 CD 59 01     	CALL CALBAS
  60+ 56E6 B7               OR A
  61+ 56E7 CA 54 64         JP Z,SUBSCRIPT_OUT_OF_RANGE
  62+ 56EA 32 51 61     	LD (BLIT_STRUCT+4),A
  63+ 56ED              	; comma
  64+ 56ED CD 3C 64     	CALL CHKCHAR
  65+ 56F0 2C           	DB ','
  66+ 56F1              	; get sprite group definition array data pointer
  67+ 56F1 3A 51 61         LD A,(BLIT_STRUCT+4)
  68+ 56F4 5F           	LD E,A
  69+ 56F5 16 03        	LD D,3
  70+ 56F7 3E 02        	LD A,2
  71+ 56F9 47           	LD B,A
  72+ 56FA CD 69 64     	CALL GET_BASIC_ARRAY_DATA_POINTER
  73+ 56FD ED 43 52 61  	LD (BLIT_STRUCT+5),BC
  74+ 5701              	; comma
  75+ 5701 CD 3C 64     	CALL CHKCHAR
  76+ 5704 2C           	DB ','
  77+ 5705              	; get sprite animation array size
  78+ 5705 DD 21 1C 52  	LD IX,GETBYT
  79+ 5709 CD 59 01     	CALL CALBAS
  80+ 570C 32 54 61         LD (BLIT_STRUCT+7),A
  81+ 570F B7               OR A
  82+ 5710 CA 54 64         JP Z,SUBSCRIPT_OUT_OF_RANGE
  83+ 5713              	; comma
  84+ 5713 CD 3C 64     	CALL CHKCHAR
  85+ 5716 2C           	DB ','
  86+ 5717                  ; get array pointer
  87+ 5717 3A 54 61         LD A,(BLIT_STRUCT+7)
  88+ 571A 57               LD D,A
  89+ 571B 3E 02            LD A,2
  90+ 571D 06 01            LD B,1
  91+ 571F CD 69 64         CALL GET_BASIC_ARRAY_DATA_POINTER
  92+ 5722 ED 43 55 61      LD (BLIT_STRUCT+8),BC
  93+ 5726              	; ending )
  94+ 5726 CD 3C 64     	CALL CHKCHAR
  95+ 5729 29           	DB ')'
  96+ 572A
  97+ 572A E5               PUSH HL
  98+ 572B F3               DI
  99+ 572C
 100+ 572C              	; enable page 0
 101+ 572C FD 21 33 57  	LD IY, .RET
 102+ 5730 C3 EE 63     	JP ENABLE_PAGE0
 103+ 5733              .RET:
 104+ 5733 D9               EXX
 105+ 5734 ED 5B 4D 61      LD DE,(BLIT_STRUCT) ; initial x
 106+ 5738 ED 4B 4F 61      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 573C D9               EXX
 108+ 573D 2A 52 61         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5740 3A 51 61         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 5743 47               LD B,A
 111+ 5744 CD C2 4F         CALL SPRGRPMOV.UPDATE_LOC
 112+ 5747
 113+ 5747 3A 54 61         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 574A 47               LD B,A
 115+ 574B ED 5B 55 61      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 574F CD 9E 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5752
 118+ 5752 D1               POP DE
 119+ 5753 C1               POP BC
 120+ 5754 CD 65 63         CALL RESTORE_PAGE_INFO
 121+ 5757 FB               EI
 122+ 5758 E1               POP HL
 123+ 5759 C9               RET
 124+ 575A              ; *******************************************************************************************************
 125+ 575A
# file closed: asm\SGAM.asm
 125  575A               ENDIF
 126  575A
 127  575A               IF (RAM_CMDS == 1)
 128  575A               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 575A              ; *******************************************************************************************************
   2+ 575A              ; function to handle CALL MEMCPY basic extension
   3+ 575A              ; _MEMCPY ( INT source,
   4+ 575A              ;			INT destination,
   5+ 575A              ;			INT count,
   6+ 575A              ; will put ram in page 0 also, page 1 is already there
   7+ 575A              MEMCPY:
   8+ 575A              	; opening (
   9+ 575A CD 3C 64     	CALL CHKCHAR
  10+ 575D 28           	DB '('
  11+ 575E              	; get source address
  12+ 575E DD 21 2F 54  	LD IX, FRMQNT
  13+ 5762 CD 59 01     	CALL CALBAS
  14+ 5765 D5           	PUSH DE
  15+ 5766              	; comma
  16+ 5766 CD 3C 64     	CALL CHKCHAR
  17+ 5769 2C           	DB ','
  18+ 576A              	; get destination address
  19+ 576A DD 21 2F 54  	LD IX, FRMQNT
  20+ 576E CD 59 01     	CALL CALBAS
  21+ 5771 D5           	PUSH DE
  22+ 5772              	; comma
  23+ 5772 CD 3C 64     	CALL CHKCHAR
  24+ 5775 2C           	DB ','
  25+ 5776              	; get length
  26+ 5776 DD 21 2F 54  	LD IX, FRMQNT
  27+ 577A CD 59 01     	CALL CALBAS
  28+ 577D D5           	PUSH DE
  29+ 577E              	; ending )
  30+ 577E CD 3C 64     	CALL CHKCHAR
  31+ 5781 29           	DB ')'
  32+ 5782
  33+ 5782              	; save position
  34+ 5782 E5           	PUSH HL
  35+ 5783 DD E1        	POP IX
  36+ 5785
  37+ 5785 C1           	POP BC ; count
  38+ 5786 D1           	POP DE ; destination
  39+ 5787 E1           	POP HL ; source
  40+ 5788 D9           	EXX
  41+ 5789              	; enable page 0
  42+ 5789 FD 21 90 57  	LD IY, .RET
  43+ 578D C3 EE 63     	JP ENABLE_PAGE0
  44+ 5790              .RET:
  45+ 5790 FB           	EI
  46+ 5791 D9           	EXX
  47+ 5792 ED B0        	LDIR
  48+ 5794 D1               POP DE
  49+ 5795 C1               POP BC
  50+ 5796 CD 65 63         CALL RESTORE_PAGE_INFO
  51+ 5799 DD E5        	PUSH IX
  52+ 579B E1           	POP HL
  53+ 579C C9           	RET
  54+ 579D              ; *******************************************************************************************************
  55+ 579D
  56+ 579D              ; *******************************************************************************************************
  57+ 579D              ; function to handle CALL FILRAM basic extension
  58+ 579D              ; FILRAM ( INT start address,
  59+ 579D              ;		   INT count,
  60+ 579D              ;		   BYTE value,
  61+ 579D              ; will put ram in page 0 also, page 1 is already there
  62+ 579D              FILRAM:
  63+ 579D              	; opening (
  64+ 579D CD 3C 64     	CALL CHKCHAR
  65+ 57A0 28           	DB '('
  66+ 57A1              	; get start address
  67+ 57A1 DD 21 2F 54  	LD IX, FRMQNT
  68+ 57A5 CD 59 01     	CALL CALBAS
  69+ 57A8 D5           	PUSH DE
  70+ 57A9              	; comma
  71+ 57A9 CD 3C 64     	CALL CHKCHAR
  72+ 57AC 2C           	DB ','
  73+ 57AD              	; get count
  74+ 57AD DD 21 2F 54  	LD IX, FRMQNT
  75+ 57B1 CD 59 01     	CALL CALBAS
  76+ 57B4 D5           	PUSH DE
  77+ 57B5              	; comma
  78+ 57B5 CD 3C 64     	CALL CHKCHAR
  79+ 57B8 2C           	DB ','
  80+ 57B9              	; get value
  81+ 57B9 DD 21 1C 52  	LD IX, GETBYT
  82+ 57BD CD 59 01     	CALL CALBAS
  83+ 57C0 F5           	PUSH AF
  84+ 57C1              	; ending )
  85+ 57C1 CD 3C 64     	CALL CHKCHAR
  86+ 57C4 29           	DB ')'
  87+ 57C5
  88+ 57C5              	; save position
  89+ 57C5 E5           	PUSH HL
  90+ 57C6 DD E1        	POP IX
  91+ 57C8
  92+ 57C8 D1           	POP DE ; actually AF
  93+ 57C9 C1           	POP BC ; count
  94+ 57CA E1           	POP HL ; start address
  95+ 57CB 78           	LD A, B
  96+ 57CC B7           	OR A
  97+ 57CD 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
  98+ 57CF B1           	OR C
  99+ 57D0 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 100+ 57D2 79           	LD A, C
 101+ 57D3 3D           	DEC A
 102+ 57D4 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 103+ 57D6              	; one byte to fill
 104+ 57D6 72           	LD (HL), D
 105+ 57D7 18 12        	JR .EXIT
 106+ 57D9              .L1:
 107+ 57D9 D9           	EXX
 108+ 57DA              	; enable page 0
 109+ 57DA FD 21 E1 57  	LD IY, .RET
 110+ 57DE C3 EE 63     	JP ENABLE_PAGE0
 111+ 57E1              .RET:
 112+ 57E1 FB           	EI
 113+ 57E2 D9           	EXX
 114+ 57E3 CD EF 57     	CALL .FILLVALUE
 115+ 57E6 D1               POP DE
 116+ 57E7 C1               POP BC
 117+ 57E8 CD 65 63         CALL RESTORE_PAGE_INFO
 118+ 57EB              .EXIT:
 119+ 57EB DD E5        	PUSH IX
 120+ 57ED E1           	POP HL
 121+ 57EE C9           	RET
 122+ 57EF
 123+ 57EF              .FILLVALUE:
 124+ 57EF 72               LD (HL), D
 125+ 57F0 54               LD D, H
 126+ 57F1 5D               LD E, L
 127+ 57F2 13               INC DE
 128+ 57F3 0B               DEC BC
 129+ 57F4 ED B0            LDIR
 130+ 57F6 C9               RET
 131+ 57F7              ; *******************************************************************************************************
 132+ 57F7
# file closed: asm\MEMORY.asm
 129  57F7               ENDIF
 130  57F7
 131  57F7               IF (SOUND_CMDS == 1)
 132  57F7               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 57F7              MUSIC_INIT_STATUS:
   2+ 57F7 00            DB 0
   3+ 57F8              SFX_INIT_STATUS:
   4+ 57F8 00            DB 0
   5+ 57F9              SOUND_ENABLED:
   6+ 57F9 00            DB 0
   7+ 57FA
   8+ 57FA              ; *******************************************************************************************************
   9+ 57FA              ; function to handle CALL SNDPLYINIT basic extension
  10+ 57FA              ; initializes sound player
  11+ 57FA              ; _SNDPLYINIT ( INT music_offset,
  12+ 57FA              ;				INT sfx_offset, can be -1 if no SFX
  13+ 57FA              ; will put ram in page 0 also, page 1 is already there
  14+ 57FA              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 57FA              SNDPLYINIT:
  16+ 57FA              	; opening (
  17+ 57FA CD 3C 64     	CALL CHKCHAR
  18+ 57FD 28           	DB '('
  19+ 57FE              	; get music address
  20+ 57FE DD 21 2F 54  	LD IX, FRMQNT
  21+ 5802 CD 59 01     	CALL CALBAS
  22+ 5805 D5           	PUSH DE
  23+ 5806              	; comma
  24+ 5806 CD 3C 64     	CALL CHKCHAR
  25+ 5809 2C           	DB ','
  26+ 580A              	; get sfx address
  27+ 580A DD 21 2F 54  	LD IX, FRMQNT
  28+ 580E CD 59 01     	CALL CALBAS
  29+ 5811 D5           	PUSH DE
  30+ 5812              	; ending )
  31+ 5812 CD 3C 64     	CALL CHKCHAR
  32+ 5815 29           	DB ')'
  33+ 5816
  34+ 5816                  ; save position in BASIC text
  35+ 5816 44           	LD B, H
  36+ 5817 4D           	LD C, L
  37+ 5818
  38+ 5818              	; pop LDIR parameters and store away for later
  39+ 5818 D1           	POP DE ; sfx address
  40+ 5819 E1           	POP HL ; music address
  41+ 581A C5           	PUSH BC ; basic text location
  42+ 581B D9           	EXX
  43+ 581C FD 21 23 58  	LD IY, .RET
  44+ 5820 C3 EE 63     	JP ENABLE_PAGE0
  45+ 5823              .RET:
  46+ 5823 D9           	EXX
  47+ 5824
  48+ 5824 D5           	PUSH DE
  49+ 5825 AF           	XOR A
  50+ 5826              	; HL = music location
  51+ 5826 CD 62 41     	CALL PLY_AKG_INIT
  52+ 5829 3E 01        	LD A, 1
  53+ 582B 32 F7 57     	LD (MUSIC_INIT_STATUS), A
  54+ 582E
  55+ 582E E1           	POP HL ; SFX
  56+ 582F              	; check if SFX address -1
  57+ 582F 23           	INC HL
  58+ 5830 7D           	LD A, L
  59+ 5831 B4           	OR H
  60+ 5832 28 09        	JR Z,.L1
  61+ 5834 2B           	DEC HL
  62+ 5835 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 5838 3E 01        	LD A, 1
  64+ 583A 32 F8 57     	LD (SFX_INIT_STATUS), A
  65+ 583D              .L1:
  66+ 583D D1               POP DE
  67+ 583E C1               POP BC
  68+ 583F CD 65 63         CALL RESTORE_PAGE_INFO
  69+ 5842
  70+ 5842 E1           	POP HL
  71+ 5843 C9           	RET
  72+ 5844              ; *******************************************************************************************************
  73+ 5844
  74+ 5844              ; *******************************************************************************************************
  75+ 5844              ; function to handle CALL SNDPLYON basic extension
  76+ 5844              ; enables sound player
  77+ 5844              ; _SNDPLYON
  78+ 5844              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 5844              ; if not throws out of data error
  80+ 5844              SNDPLYON:
  81+ 5844 3A F7 57     	LD A, (MUSIC_INIT_STATUS)
  82+ 5847 B7           	OR A
  83+ 5848 20 05        	JR NZ, .L1
  84+ 584A              	; player not initialized, throw error
  85+ 584A 1E 04        	LD E, 04 ; Out of DATA
  86+ 584C C3 62 64     	JP THROW_ERROR
  87+ 584F              .L1:
  88+ 584F 32 F9 57     	LD (SOUND_ENABLED), A
  89+ 5852              	; disable key click
  90+ 5852 AF           	XOR A
  91+ 5853 32 DB F3     	LD (CLIKSW), A
  92+ 5856 C9           	RET
  93+ 5857              ; *******************************************************************************************************
  94+ 5857
  95+ 5857              ; *******************************************************************************************************
  96+ 5857              ; function to handle CALL SNDPLYOFF basic extension
  97+ 5857              ; disables sound player
  98+ 5857              ; _SNDPLYOFF
  99+ 5857              ; sets SOUND_ENABLED variable to 0
 100+ 5857              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 5857              SNDPLYOFF:
 102+ 5857 3A F9 57     	LD A, (SOUND_ENABLED)
 103+ 585A B7           	OR A
 104+ 585B C8           	RET Z ; already stopped
 105+ 585C AF           	XOR A
 106+ 585D 32 F9 57     	LD (SOUND_ENABLED), A
 107+ 5860 E5           	PUSH HL
 108+ 5861 CD 21 42     	CALL PLY_AKG_STOP
 109+ 5864 3A F8 57     	LD A, (SFX_INIT_STATUS)
 110+ 5867 B7           	OR A
 111+ 5868 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 586A AF           	XOR A
 113+ 586B CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 586E 3E 01        	LD A, 1
 115+ 5870 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 5873 3E 02        	LD A, 2
 117+ 5875 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 5878              .EXIT:
 119+ 5878 E1           	POP HL
 120+ 5879 C9           	RET
 121+ 587A              ; *******************************************************************************************************
 122+ 587A
 123+ 587A              ; *******************************************************************************************************
 124+ 587A              ; function to handle CALL SNDSFX basic extension
 125+ 587A              ; plays a sound effect
 126+ 587A              ; _SNDSFX ( BYTE sfx_number, >0
 127+ 587A              ;			BYTE channel, = 0,1 or 2
 128+ 587A              ;			BYTE inverted_volume = 0-16, 0 being full volume
 129+ 587A              ; will put ram in page 0 also, page 1 is already there
 130+ 587A              ; if sound off throws illegal function call
 131+ 587A              ; if sfx not initialized, throws out of data
 132+ 587A              SNDSFX:
 133+ 587A              	; opening (
 134+ 587A CD 3C 64     	CALL CHKCHAR
 135+ 587D 28           	DB '('
 136+ 587E              	; get sfx_number
 137+ 587E DD 21 1C 52  	LD IX, GETBYT
 138+ 5882 CD 59 01     	CALL CALBAS
 139+ 5885 D5           	PUSH DE
 140+ 5886              	; comma
 141+ 5886 CD 3C 64     	CALL CHKCHAR
 142+ 5889 2C           	DB ','
 143+ 588A              	; get sfx address
 144+ 588A DD 21 1C 52  	LD IX, GETBYT
 145+ 588E CD 59 01     	CALL CALBAS
 146+ 5891 D5           	PUSH DE
 147+ 5892              	; comma
 148+ 5892 CD 3C 64     	CALL CHKCHAR
 149+ 5895 2C           	DB ','
 150+ 5896              	; get inverted volume
 151+ 5896 DD 21 1C 52  	LD IX, GETBYT
 152+ 589A CD 59 01     	CALL CALBAS
 153+ 589D D5           	PUSH DE
 154+ 589E              	; ending )
 155+ 589E CD 3C 64     	CALL CHKCHAR
 156+ 58A1 29           	DB ')'
 157+ 58A2
 158+ 58A2 3A F9 57     	LD A, (SOUND_ENABLED)
 159+ 58A5 B7           	OR A
 160+ 58A6 20 05        	JR NZ, .L1
 161+ 58A8              	; sound disabled, throw illegal function call
 162+ 58A8 1E 05        	LD E, 5
 163+ 58AA C3 62 64     	JP THROW_ERROR
 164+ 58AD              .L1:
 165+ 58AD 3A F8 57     	LD A, (SFX_INIT_STATUS)
 166+ 58B0 B7           	OR A
 167+ 58B1 20 05        	JR NZ, .L2
 168+ 58B3              	; sfx data not initialized, throw out of data
 169+ 58B3 1E 04        	LD E, 4
 170+ 58B5 C3 62 64     	JP THROW_ERROR
 171+ 58B8              .L2:
 172+ 58B8              	; pop  parameters and store away for later
 173+ 58B8 D1           	POP DE ; inverted volume
 174+ 58B9 43           	LD B, E
 175+ 58BA D1           	POP DE ; channel
 176+ 58BB 4B           	LD C, E
 177+ 58BC D1           	POP DE
 178+ 58BD 7B           	LD A, E
 179+ 58BE 08           	EX AF, AF'
 180+ 58BF E5           	PUSH HL ; basic text location
 181+ 58C0 D9           	EXX
 182+ 58C1 FD 21 C8 58  	LD IY, .RET
 183+ 58C5 C3 EE 63     	JP ENABLE_PAGE0
 184+ 58C8              .RET:
 185+ 58C8 D9           	EXX
 186+ 58C9 08           	EX AF, AF'
 187+ 58CA CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 188+ 58CD
 189+ 58CD D1               POP DE
 190+ 58CE C1               POP BC
 191+ 58CF CD 65 63         CALL RESTORE_PAGE_INFO
 192+ 58D2
 193+ 58D2 E1           	POP HL
 194+ 58D3 C9           	RET
 195+ 58D4              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
 133  58D4               ENDIF
 134  58D4
 135  58D4               IF (VRAM_CMDS == 1)
 136  58D4               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 58D4              ; *******************************************************************************************************
   2+ 58D4              ; function to handle CALL FILVRM basic extension
   3+ 58D4              ; FILVRM ( INT offset,
   4+ 58D4              ;		   INT count,
   5+ 58D4              ;		   BYTE value,
   6+ 58D4              ;		   BYTE wait_vsync) >0 = true
   7+ 58D4              ; wait_vsync will issue HALT before copying
   8+ 58D4              FILVRM:
   9+ 58D4              	; opening (
  10+ 58D4 CD 3C 64     	CALL CHKCHAR
  11+ 58D7 28           	DB '('
  12+ 58D8              	; get offset address
  13+ 58D8 DD 21 2F 54  	LD IX, FRMQNT
  14+ 58DC CD 59 01     	CALL CALBAS
  15+ 58DF D5           	PUSH DE
  16+ 58E0              	; comma
  17+ 58E0 CD 3C 64     	CALL CHKCHAR
  18+ 58E3 2C           	DB ','
  19+ 58E4              	; get count
  20+ 58E4 DD 21 2F 54  	LD IX, FRMQNT
  21+ 58E8 CD 59 01     	CALL CALBAS
  22+ 58EB D5           	PUSH DE
  23+ 58EC              	; comma
  24+ 58EC CD 3C 64     	CALL CHKCHAR
  25+ 58EF 2C           	DB ','
  26+ 58F0              	; get value
  27+ 58F0 DD 21 1C 52  	LD IX, GETBYT
  28+ 58F4 CD 59 01     	CALL CALBAS
  29+ 58F7 F5           	PUSH AF
  30+ 58F8              	; comma
  31+ 58F8 CD 3C 64     	CALL CHKCHAR
  32+ 58FB 2C           	DB ','
  33+ 58FC              	; get vsync wait
  34+ 58FC DD 21 1C 52  	LD IX, GETBYT
  35+ 5900 CD 59 01     	CALL CALBAS
  36+ 5903 F5           	PUSH AF
  37+ 5904              	; ending )
  38+ 5904 CD 3C 64     	CALL CHKCHAR
  39+ 5907 29           	DB ')'
  40+ 5908
  41+ 5908 FB               EI
  42+ 5909              	; save position
  43+ 5909 E5           	PUSH HL
  44+ 590A DD E1        	POP IX
  45+ 590C
  46+ 590C              	; syntax ok
  47+ 590C              	; wait for vsync if needed
  48+ 590C F1           	POP AF
  49+ 590D B7           	OR A
  50+ 590E 28 01        	JR Z, .L1
  51+ 5910 76           	HALT
  52+ 5911
  53+ 5911              .L1:
  54+ 5911 3E 01        	LD A,1
  55+ 5913 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5916 F1               POP AF ; value
  57+ 5917 C1               POP BC ; count
  58+ 5918 E1               POP HL ; offset
  59+ 5919 CD 56 00         CALL BIOS_FILVRM
  60+ 591C AF           	XOR A
  61+ 591D 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5920
  63+ 5920              .L3:
  64+ 5920 DD E5        	PUSH IX
  65+ 5922 E1           	POP HL
  66+ 5923 C9           	RET
  67+ 5924              ; *******************************************************************************************************
  68+ 5924
  69+ 5924              ; *******************************************************************************************************
  70+ 5924              ; function to handle CALL MEMVRM basic extension
  71+ 5924              ; copies from RAM to VRAM
  72+ 5924              ; _MEMVRM ( INT source,
  73+ 5924              ;			INT destination,
  74+ 5924              ;			INT count,
  75+ 5924              ;			BYTE wait_vsync) >0 = true
  76+ 5924              ; will put ram in page 0 also, page 1 is already there
  77+ 5924              ; wait_vsync will issue HALT before copying
  78+ 5924              MEMVRM:
  79+ 5924              	; opening (
  80+ 5924 CD 3C 64     	CALL CHKCHAR
  81+ 5927 28           	DB '('
  82+ 5928              	; get source address
  83+ 5928 DD 21 2F 54  	LD IX, FRMQNT
  84+ 592C CD 59 01     	CALL CALBAS
  85+ 592F D5           	PUSH DE
  86+ 5930              	; comma
  87+ 5930 CD 3C 64     	CALL CHKCHAR
  88+ 5933 2C           	DB ','
  89+ 5934              	; get destination address
  90+ 5934 DD 21 2F 54  	LD IX, FRMQNT
  91+ 5938 CD 59 01     	CALL CALBAS
  92+ 593B D5           	PUSH DE
  93+ 593C              	; comma
  94+ 593C CD 3C 64     	CALL CHKCHAR
  95+ 593F 2C           	DB ','
  96+ 5940              	; get length
  97+ 5940 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5944 CD 59 01     	CALL CALBAS
  99+ 5947 D5           	PUSH DE
 100+ 5948              	; comma
 101+ 5948 CD 3C 64     	CALL CHKCHAR
 102+ 594B 2C           	DB ','
 103+ 594C              	; get vsync wait
 104+ 594C DD 21 1C 52  	LD IX, GETBYT
 105+ 5950 CD 59 01     	CALL CALBAS
 106+ 5953 F5           	PUSH AF
 107+ 5954              	; ending )
 108+ 5954 CD 3C 64     	CALL CHKCHAR
 109+ 5957 29           	DB ')'
 110+ 5958
 111+ 5958                  ; save position in BASIC text
 112+ 5958 E5           	PUSH HL
 113+ 5959 DD E1        	POP IX
 114+ 595B
 115+ 595B F1           	POP AF ; wait vsync
 116+ 595C B7           	OR A
 117+ 595D 28 03        	JR Z, .L1
 118+ 595F FB               EI
 119+ 5960 76           	HALT
 120+ 5961 F3           	DI
 121+ 5962              .L1:
 122+ 5962              	; pop LDIR parameters and store away for later
 123+ 5962 C1           	POP BC ; count
 124+ 5963 D1           	POP DE ; vram destination
 125+ 5964 E1           	POP HL ; ram source
 126+ 5965 D9           	EXX
 127+ 5966 FD 21 6D 59   	LD IY, .RET
 128+ 596A C3 EE 63     	JP ENABLE_PAGE0
 129+ 596D              .RET:
 130+ 596D FB           	EI
 131+ 596E D9           	EXX
 132+ 596F 3E 01        	LD A,1
 133+ 5971 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 134+ 5974 CD 84 59     	CALL .LDIRVM
 135+ 5977 AF           	XOR A
 136+ 5978 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 137+ 597B D1               POP DE
 138+ 597C C1               POP BC
 139+ 597D CD 65 63         CALL RESTORE_PAGE_INFO
 140+ 5980 DD E5        	PUSH IX
 141+ 5982 E1           	POP HL
 142+ 5983 C9           	RET
 143+ 5984
 144+ 5984              .LDIRVM:
 145+ 5984 EB           	EX DE, HL
 146+ 5985 F3           	DI
 147+ 5986 CD 15 63     	CALL SETWRT_LOCAL
 148+ 5989 FB           	EI
 149+ 598A EB           	EX DE, HL
 150+ 598B 78           	LD A, B
 151+ 598C B7           	OR A
 152+ 598D 28 0D        	JR Z, .L3
 153+ 598F C5           	PUSH BC
 154+ 5990 0E 98        	LD C, #98
 155+ 5992              .L2:
 156+ 5992 50           	LD D, B
 157+ 5993 06 00        	LD B, 0
 158+ 5995 CD 22 63     	CALL BBYTECOPY_NO_C
 159+ 5998 42           	LD B, D
 160+ 5999 10 F7        	DJNZ .L2
 161+ 599B C1           	POP BC
 162+ 599C              .L3:
 163+ 599C 79           	LD A, C
 164+ 599D B7           	OR A
 165+ 599E C8           	RET Z
 166+ 599F 41           	LD B, C
 167+ 59A0 C3 20 63     	JP BBYTECOPY
 168+ 59A3              ; *******************************************************************************************************
 169+ 59A3
 170+ 59A3              ; *******************************************************************************************************
 171+ 59A3              ; function to handle CALL VRMMEM basic extension
 172+ 59A3              ; copies from RAM to VRAM
 173+ 59A3              ; _VRMMEM ( INT source,
 174+ 59A3              ;			INT destination,
 175+ 59A3              ;			INT count
 176+ 59A3              ; will put ram in page 0 also, page 1 is already there
 177+ 59A3              VRMMEM:
 178+ 59A3              	; opening (
 179+ 59A3 CD 3C 64     	CALL CHKCHAR
 180+ 59A6 28           	DB '('
 181+ 59A7              	; get source address
 182+ 59A7 DD 21 2F 54  	LD IX, FRMQNT
 183+ 59AB CD 59 01     	CALL CALBAS
 184+ 59AE D5           	PUSH DE
 185+ 59AF              	; comma
 186+ 59AF CD 3C 64     	CALL CHKCHAR
 187+ 59B2 2C           	DB ','
 188+ 59B3              	; get destination address
 189+ 59B3 DD 21 2F 54  	LD IX, FRMQNT
 190+ 59B7 CD 59 01     	CALL CALBAS
 191+ 59BA D5           	PUSH DE
 192+ 59BB              	; comma
 193+ 59BB CD 3C 64     	CALL CHKCHAR
 194+ 59BE 2C           	DB ','
 195+ 59BF              	; get length
 196+ 59BF DD 21 2F 54  	LD IX, FRMQNT
 197+ 59C3 CD 59 01     	CALL CALBAS
 198+ 59C6 D5           	PUSH DE
 199+ 59C7              	; ending )
 200+ 59C7 CD 3C 64     	CALL CHKCHAR
 201+ 59CA 29           	DB ')'
 202+ 59CB
 203+ 59CB                  ; save position in BASIC text
 204+ 59CB E5           	PUSH HL
 205+ 59CC DD E1        	POP IX
 206+ 59CE
 207+ 59CE C1           	POP BC ; count
 208+ 59CF D1           	POP DE ; destination
 209+ 59D0 E1           	POP HL ; source
 210+ 59D1 D9           	EXX
 211+ 59D2 FD 21 D9 59  	LD IY, .RET
 212+ 59D6 C3 EE 63     	JP ENABLE_PAGE0
 213+ 59D9              .RET:
 214+ 59D9 FB           	EI
 215+ 59DA D9           	EXX
 216+ 59DB 3E 01        	LD A,1
 217+ 59DD 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 218+ 59E0 CD F0 59     	CALL .LDIRMV
 219+ 59E3 AF           	XOR A
 220+ 59E4 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 221+ 59E7 D1               POP DE
 222+ 59E8 C1               POP BC
 223+ 59E9 CD 65 63         CALL RESTORE_PAGE_INFO
 224+ 59EC DD E5        	PUSH IX
 225+ 59EE E1           	POP HL
 226+ 59EF C9           	RET
 227+ 59F0
 228+ 59F0              .LDIRMV:
 229+ 59F0              	; set VRAM address *exactly* as in ROM, otherwise corruption
 230+ 59F0 7D           	LD	A, L
 231+ 59F1 F3           	DI
 232+ 59F2 D3 99        	OUT	(099H), A
 233+ 59F4 7C           	LD	A, H
 234+ 59F5 E6 3F        	AND	03FH
 235+ 59F7 D3 99        	OUT	(099H), A
 236+ 59F9 FB           	EI
 237+ 59FA              	;EX (SP), HL
 238+ 59FA              	;EX (SP), HL
 239+ 59FA              	;NOP
 240+ 59FA              	;NOP
 241+ 59FA              .L4:
 242+ 59FA DB 98            IN A, (#98)
 243+ 59FC 12           	LD (DE), A
 244+ 59FD 13               INC DE
 245+ 59FE 0B               DEC BC
 246+ 59FF 79               LD A, C
 247+ 5A00 B0               OR B
 248+ 5A01 20 F7            JR NZ, .L4
 249+ 5A03 C9               RET
 250+ 5A04              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 137  5A04               ENDIF
 138  5A04
 139  5A04               IF (GENCAL_CMD == 1)
 140  5A04               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5A04              ; *******************************************************************************************************
   2+ 5A04              ; function to handle CALL GENCAL basic extension
   3+ 5A04              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5A04              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5A04              ; output values of registers will also be stored at reg_list_ptr
   6+ 5A04              GENCAL_VAR_SP:
   7+ 5A04 00 00            DW 0
   8+ 5A06              GENCAL_VAR_SP2:
   9+ 5A06 00 00            DW 0
  10+ 5A08              GENCAL:
  11+ 5A08              	; opening (
  12+ 5A08 CD 3C 64     	CALL CHKCHAR
  13+ 5A0B 28           	DB '('
  14+ 5A0C              	; get function address
  15+ 5A0C DD 21 2F 54  	LD IX, FRMQNT
  16+ 5A10 CD 59 01     	CALL CALBAS
  17+ 5A13 D5           	PUSH DE
  18+ 5A14              	; comma
  19+ 5A14 CD 3C 64     	CALL CHKCHAR
  20+ 5A17 2C           	DB ','
  21+ 5A18              	; get pointer to register list
  22+ 5A18 3E 02            LD A,2
  23+ 5A1A 06 01            LD B,1
  24+ 5A1C 11 00 05         LD DE,#0500
  25+ 5A1F CD 69 64         CALL GET_BASIC_ARRAY_DATA_POINTER
  26+ 5A22 C5           	PUSH BC
  27+ 5A23              	; ending )
  28+ 5A23 CD 3C 64     	CALL CHKCHAR
  29+ 5A26 29           	DB ')'
  30+ 5A27
  31+ 5A27              	; save BASIC token position
  32+ 5A27 E5           	PUSH HL
  33+ 5A28 D9               EXX
  34+ 5A29 E1           	POP HL ; HL'=next basic token
  35+ 5A2A D9               EXX
  36+ 5A2B
  37+ 5A2B E1               POP HL ; get pointer to register values
  38+ 5A2C F3           	DI
  39+ 5A2D ED 73 04 5A      LD (GENCAL_VAR_SP), SP
  40+ 5A31 F9               LD SP, HL
  41+ 5A32 F1               POP AF
  42+ 5A33 C1               POP BC
  43+ 5A34 D1               POP DE
  44+ 5A35 E1               POP HL
  45+ 5A36 DD E1            POP IX
  46+ 5A38 FD E1            POP IY
  47+ 5A3A D9               EXX
  48+ 5A3B ED 73 06 5A      LD (GENCAL_VAR_SP2), SP
  49+ 5A3F ED 7B 04 5A      LD SP, (GENCAL_VAR_SP)
  50+ 5A43 FB               EI
  51+ 5A44 D1               POP DE ; get function to call
  52+ 5A45 E5               PUSH HL
  53+ 5A46 CD 61 5A         CALL .EXXDECALL
  54+ 5A49 F3               DI
  55+ 5A4A ED 73 04 5A      LD (GENCAL_VAR_SP), SP
  56+ 5A4E ED 7B 06 5A      LD SP, (GENCAL_VAR_SP2)
  57+ 5A52 FD E5            PUSH IY
  58+ 5A54 DD E5            PUSH IX
  59+ 5A56 E5               PUSH HL
  60+ 5A57 D5               PUSH DE
  61+ 5A58 C5               PUSH BC
  62+ 5A59 F5               PUSH AF
  63+ 5A5A ED 7B 04 5A      LD SP, (GENCAL_VAR_SP)
  64+ 5A5E FB               EI
  65+ 5A5F E1               POP HL
  66+ 5A60 C9           	RET
  67+ 5A61
  68+ 5A61              .EXXDECALL:
  69+ 5A61 D5               PUSH DE
  70+ 5A62 D9               EXX
  71+ 5A63 C9               RET
  72+ 5A64              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 141  5A64               ENDIF
 142  5A64
 143  5A64               IF (BOX_CMDS == 1)
 144  5A64               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5A64              ; *******************************************************************************************************
   2+ 5A64              ; generic function to implement rectangle data copy
   3+ 5A64              ; should be modified to call appropriate function for memory or vram
   4+ 5A64              ; input IX=pointer to following structure
   5+ 5A64              ; +00 source data pointer
   6+ 5A64              ; +02 num bytes in a row
   7+ 5A64              ; +04 number of rows
   8+ 5A64              ; +06 source add-to value till next row
   9+ 5A64              ; +08 destination address
  10+ 5A64              ; +10 destination add-to value till next row
  11+ 5A64              ; modifies AF, BC, DE, HL
  12+ 5A64              RECTANGLE_COPY:
  13+ 5A64 DD 6E 00     	LD L, (IX+0)
  14+ 5A67 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5A6A DD 5E 08     	LD E, (IX+8)
  16+ 5A6D DD 56 09     	LD D, (IX+9) ; destination
  17+ 5A70 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5A73              .L1:
  19+ 5A73 C5           	PUSH BC
  20+ 5A74 E5           		PUSH HL
  21+ 5A75 D5           			PUSH DE
  22+ 5A76 DD 4E 02     				LD C, (IX+2)
  23+ 5A79 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5A7C              .CALL1:
  25+ 5A7C CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5A7F              .CALL2:
  27+ 5A7F CD 00 00     				CALL 0 ; copy data fn
  28+ 5A82 E1           			POP HL
  29+ 5A83 DD 4E 0A     			LD C, (IX+10)
  30+ 5A86 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5A89 09           			ADD HL, BC
  32+ 5A8A EB           			EX DE, HL
  33+ 5A8B E1           		POP HL
  34+ 5A8C DD 4E 06     		LD C, (IX+6)
  35+ 5A8F DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5A92 09           		ADD HL, BC
  37+ 5A93 C1           	POP BC
  38+ 5A94 10 DD        	DJNZ .L1
  39+ 5A96 C9           	RET
  40+ 5A97              ; *******************************************************************************************************
  41+ 5A97
  42+ 5A97              ; *******************************************************************************************************
  43+ 5A97              ; function to handle CALL BOXMEMCPY basic extension
  44+ 5A97              ; copies data with window like boundaries within ram
  45+ 5A97              ; BOXMEMCPY ( INT source data pointer,
  46+ 5A97              ;			  INT source number of bytes in a row,
  47+ 5A97              ;			  INT number of rows,
  48+ 5A97              ;			  INT source add-to value till next row,
  49+ 5A97              ; 			  INT destination pointer,
  50+ 5A97              ;			  INT destination add-to value till next row )
  51+ 5A97              ; request_data_ptr described in RECTANGLE_COPY
  52+ 5A97              ; will put ram in page 0 also, page 1 is already there
  53+ 5A97              BOXMEMCPY:
  54+ 5A97 11 A1 5A     	LD DE,BOXMEMCPY.RET
  55+ 5A9A ED 53 15 5B  	LD (BOXCOMMON.ADDR+2), DE
  56+ 5A9E C3 B4 5A     	JP BOXCOMMON
  57+ 5AA1              .RET:
  58+ 5AA1 FB           	EI
  59+ 5AA2              	; set RAM functions to call
  60+ 5AA2 21 00 00     	LD HL, 0
  61+ 5AA5 22 7C 5A     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  62+ 5AA8 22 7E 5A     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  63+ 5AAB 21 ED B0     	LD HL, #B0ED ; LDIR
  64+ 5AAE 22 80 5A     	LD (RECTANGLE_COPY.CALL1+4), HL
  65+ 5AB1 C3 1A 5B     	JP BOXCOMMON.CALL
  66+ 5AB4              ; *******************************************************************************************************
  67+ 5AB4
  68+ 5AB4              ; *******************************************************************************************************
  69+ 5AB4              ; common parts of BOX commands
  70+ 5AB4              BOXCOMMON:
  71+ 5AB4              	; opening (
  72+ 5AB4 CD 3C 64     	CALL CHKCHAR
  73+ 5AB7 28           	DB '('
  74+ 5AB8              	; get source data pointer
  75+ 5AB8 DD 21 2F 54  	LD IX, FRMQNT
  76+ 5ABC CD 59 01     	CALL CALBAS
  77+ 5ABF ED 53 4D 61  	LD (BLIT_STRUCT+0), DE
  78+ 5AC3              	; comma
  79+ 5AC3 CD 3C 64     	CALL CHKCHAR
  80+ 5AC6 2C           	DB ','
  81+ 5AC7              	; source number of bytes in a row
  82+ 5AC7 DD 21 2F 54  	LD IX, FRMQNT
  83+ 5ACB CD 59 01     	CALL CALBAS
  84+ 5ACE ED 53 4F 61  	LD (BLIT_STRUCT+2), DE
  85+ 5AD2              	; comma
  86+ 5AD2 CD 3C 64     	CALL CHKCHAR
  87+ 5AD5 2C           	DB ','
  88+ 5AD6              	; number of rows
  89+ 5AD6 DD 21 2F 54  	LD IX, FRMQNT
  90+ 5ADA CD 59 01     	CALL CALBAS
  91+ 5ADD ED 53 51 61  	LD (BLIT_STRUCT+4), DE
  92+ 5AE1              	; comma
  93+ 5AE1 CD 3C 64     	CALL CHKCHAR
  94+ 5AE4 2C           	DB ','
  95+ 5AE5              	; source add-to value till next row
  96+ 5AE5 DD 21 2F 54  	LD IX, FRMQNT
  97+ 5AE9 CD 59 01     	CALL CALBAS
  98+ 5AEC ED 53 53 61  	LD (BLIT_STRUCT+6), DE
  99+ 5AF0              	; comma
 100+ 5AF0 CD 3C 64     	CALL CHKCHAR
 101+ 5AF3 2C           	DB ','
 102+ 5AF4              	; destination pointer
 103+ 5AF4 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5AF8 CD 59 01     	CALL CALBAS
 105+ 5AFB ED 53 55 61  	LD (BLIT_STRUCT+8), DE
 106+ 5AFF              	; comma
 107+ 5AFF CD 3C 64     	CALL CHKCHAR
 108+ 5B02 2C           	DB ','
 109+ 5B03              	; destination add-to value till next row
 110+ 5B03 DD 21 2F 54  	LD IX, FRMQNT
 111+ 5B07 CD 59 01     	CALL CALBAS
 112+ 5B0A ED 53 57 61  	LD (BLIT_STRUCT+10), DE
 113+ 5B0E              	; ending )
 114+ 5B0E CD 3C 64     	CALL CHKCHAR
 115+ 5B11 29           	DB ')'
 116+ 5B12
 117+ 5B12 E5           	PUSH HL ; save position in BASIC buffer
 118+ 5B13              .ADDR:
 119+ 5B13 FD 21 00 00  	LD IY, 0
 120+ 5B17 C3 EE 63     	JP ENABLE_PAGE0
 121+ 5B1A              .CALL:
 122+ 5B1A DD 21 4D 61  	LD IX,BLIT_STRUCT
 123+ 5B1E CD 64 5A     	CALL RECTANGLE_COPY
 124+ 5B21 AF           	XOR A
 125+ 5B22 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 126+ 5B25
 127+ 5B25 D1               POP DE
 128+ 5B26 C1               POP BC
 129+ 5B27 CD 65 63         CALL RESTORE_PAGE_INFO
 130+ 5B2A
 131+ 5B2A E1           	POP HL
 132+ 5B2B C9           	RET
 133+ 5B2C              ; *******************************************************************************************************
 134+ 5B2C
 135+ 5B2C              ; *******************************************************************************************************
 136+ 5B2C              ; function to handle CALL BOXMEMVRM basic extension
 137+ 5B2C              ; copies data with window like boundaries from ram to Vram
 138+ 5B2C              ; BOXMEMVRM ( INT source data pointer,
 139+ 5B2C              ;			  INT source number of bytes in a row,
 140+ 5B2C              ;			  INT number of rows,
 141+ 5B2C              ;			  INT source add-to value till next row,
 142+ 5B2C              ; 			  INT destination pointer,
 143+ 5B2C              ;			  INT destination add-to value till next row )
 144+ 5B2C              ; request_data_ptr described in RECTANGLE_COPY
 145+ 5B2C              ; will put ram in page 0 also, page 1 is already there
 146+ 5B2C              BOXMEMVRM:
 147+ 5B2C 11 36 5B     	LD DE,BOXMEMVRM.RET
 148+ 5B2F ED 53 15 5B  	LD (BOXCOMMON.ADDR+2), DE
 149+ 5B33 C3 B4 5A     	JP BOXCOMMON
 150+ 5B36              .RET:
 151+ 5B36 FB           	EI
 152+ 5B37              	; set RAM functions to call
 153+ 5B37 21 51 5B     	LD HL, .SETDEST
 154+ 5B3A 22 7D 5A     	LD (RECTANGLE_COPY.CALL1+1), HL
 155+ 5B3D 21 59 5B     	LD HL, .COPYDATA
 156+ 5B40 22 80 5A     	LD (RECTANGLE_COPY.CALL2+1), HL
 157+ 5B43 3E CD        	LD A, #CD ; CALL
 158+ 5B45 32 7C 5A     	LD (RECTANGLE_COPY.CALL1), A
 159+ 5B48 32 7F 5A     	LD (RECTANGLE_COPY.CALL2), A
 160+ 5B4B              	;LD A,1
 161+ 5B4B 32 5E 61     	LD (VRAM_UPDATE_IN_PROGRESS),A
 162+ 5B4E C3 1A 5B     	JP BOXCOMMON.CALL
 163+ 5B51              .SETDEST:
 164+ 5B51 EB           	EX DE, HL
 165+ 5B52 F3           	DI
 166+ 5B53 CD 15 63     	CALL SETWRT_LOCAL
 167+ 5B56 FB           	EI
 168+ 5B57 EB           	EX DE, HL
 169+ 5B58 C9           	RET
 170+ 5B59              .COPYDATA:
 171+ 5B59 41           	LD B, C
 172+ 5B5A C3 20 63     	JP BBYTECOPY
 173+ 5B5D              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 145  5B5D               ENDIF
 146  5B5D
 147  5B5D               IF (BLIT_CMDS == 1)
 148  5B5D               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5B5D              ; *******************************************************************************************************
   2+ 5B5D              ; function rotates mask and data of several characters and applies to background data
   3+ 5B5D              ; this handles x-shift from 0 to 4
   4+ 5B5D              ; contains self-modifying code that is set-up from external function
   5+ 5B5D              ; input HL=pointer to mask data
   6+ 5B5D              ; input HL'=pointer to character data
   7+ 5B5D              ; input DE=output buffer containing background data
   8+ 5B5D              ; input BC=DE+8
   9+ 5B5D              ; input A=number of characters to process
  10+ 5B5D              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5B5D              SHIFT04:
  12+ 5B5D 08           	EX AF, AF'
  13+ 5B5E 7E           	LD A, (HL) ; get mask
  14+ 5B5F D9           	EXX
  15+ 5B60 57           	LD D, A
  16+ 5B61 1E FF        	LD E, #FF
  17+ 5B63 37           	SCF
  18+ 5B64              .M1:
  19+ 5B64 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5B66 CB 1A        	RR D
  21+ 5B68 CB 1B        	RR E
  22+ 5B6A CB 1A        	RR D
  23+ 5B6C CB 1B        	RR E
  24+ 5B6E CB 1A        	RR D
  25+ 5B70 CB 1B        	RR E
  26+ 5B72 CB 1A        	RR D
  27+ 5B74 CB 1B        	RR E
  28+ 5B76
  29+ 5B76 46           	LD B, (HL) ; get data
  30+ 5B77 0E 00        	LD C, 0
  31+ 5B79              .M2:
  32+ 5B79 18 FE        	JR .M2 ; also self-modifying part
  33+ 5B7B CB 38        	SRL B
  34+ 5B7D CB 19        	RR C
  35+ 5B7F CB 38        	SRL B
  36+ 5B81 CB 19        	RR C
  37+ 5B83 CB 38        	SRL B
  38+ 5B85 CB 19        	RR C
  39+ 5B87 CB 38        	SRL B
  40+ 5B89 CB 19        	RR C
  41+ 5B8B
  42+ 5B8B D9           	EXX
  43+ 5B8C 1A           	LD A, (DE) ; background
  44+ 5B8D D9           	EXX
  45+ 5B8E A2           	AND D
  46+ 5B8F B0           	OR B
  47+ 5B90 D9           	EXX
  48+ 5B91 12           	LD (DE), A
  49+ 5B92
  50+ 5B92 0A           	LD A, (BC)
  51+ 5B93 D9           	EXX
  52+ 5B94 A3           	AND E
  53+ 5B95 B1           	OR C
  54+ 5B96 23           	INC HL
  55+ 5B97 D9           	EXX
  56+ 5B98 02           	LD (BC), A
  57+ 5B99
  58+ 5B99 23           	INC HL
  59+ 5B9A 13           	INC DE
  60+ 5B9B 03           	INC BC
  61+ 5B9C
  62+ 5B9C 08           	EX AF, AF'
  63+ 5B9D 3D           	DEC A
  64+ 5B9E C2 5D 5B     	JP NZ, SHIFT04
  65+ 5BA1 C9           	RET
  66+ 5BA2              ; *******************************************************************************************************
  67+ 5BA2
  68+ 5BA2              ; *******************************************************************************************************
  69+ 5BA2              ; function rotates mask and data of several characters and applies to background data
  70+ 5BA2              ; this handles x-shift from 5 to 8
  71+ 5BA2              ; contains self-modifying code that is set-up from external function
  72+ 5BA2              ; input HL=pointer to mask data
  73+ 5BA2              ; input HL'=pointer to character data
  74+ 5BA2              ; input DE=output buffer containing background data
  75+ 5BA2              ; input BC=DE+8
  76+ 5BA2              ; input A=number of characters to process
  77+ 5BA2              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5BA2              SHIFT58:
  79+ 5BA2 08           	EX AF, AF'
  80+ 5BA3 7E           	LD A, (HL) ; get mask
  81+ 5BA4 D9           	EXX
  82+ 5BA5 57           	LD D, A
  83+ 5BA6 1E FF        	LD E, #FF
  84+ 5BA8 37           	SCF
  85+ 5BA9              .M1:
  86+ 5BA9 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5BAB CB 12        	RL D
  88+ 5BAD CB 13        	RL E
  89+ 5BAF CB 12        	RL D
  90+ 5BB1 CB 13        	RL E
  91+ 5BB3 CB 12        	RL D
  92+ 5BB5 CB 13        	RL E
  93+ 5BB7
  94+ 5BB7 46           	LD B, (HL)
  95+ 5BB8 0E 00        	LD C, 0
  96+ 5BBA              .M2:
  97+ 5BBA 18 FE        	JR .M2 ; also self-modifying part
  98+ 5BBC CB 20        	SLA B
  99+ 5BBE CB 11        	RL C
 100+ 5BC0 CB 20        	SLA B
 101+ 5BC2 CB 11        	RL C
 102+ 5BC4 CB 20        	SLA B
 103+ 5BC6 CB 11        	RL C
 104+ 5BC8
 105+ 5BC8 D9           	EXX
 106+ 5BC9 1A           	LD A, (DE) ; background
 107+ 5BCA D9           	EXX
 108+ 5BCB A3           	AND E
 109+ 5BCC B1           	OR C
 110+ 5BCD D9           	EXX
 111+ 5BCE 12           	LD (DE), A
 112+ 5BCF
 113+ 5BCF 0A           	LD A, (BC)
 114+ 5BD0 D9           	EXX
 115+ 5BD1 A2           	AND D
 116+ 5BD2 B0           	OR B
 117+ 5BD3 23           	INC HL
 118+ 5BD4 D9           	EXX
 119+ 5BD5 02           	LD (BC), A
 120+ 5BD6
 121+ 5BD6 23           	INC HL
 122+ 5BD7 13           	INC DE
 123+ 5BD8 03           	INC BC
 124+ 5BD9
 125+ 5BD9 08           	EX AF, AF'
 126+ 5BDA 3D           	DEC A
 127+ 5BDB C2 A2 5B     	JP NZ, SHIFT58
 128+ 5BDE C9           	RET
 129+ 5BDF              ; *******************************************************************************************************
 130+ 5BDF
 131+ 5BDF              ; *******************************************************************************************************
 132+ 5BDF              ; routine that shifts one row of characters
 133+ 5BDF              ; contains self-modifying code that is set-up from external function
 134+ 5BDF              ; input HL=pointer to mask data
 135+ 5BDF              ; input HL'=pointer to character data
 136+ 5BDF              ; input DE=output buffer containing background data
 137+ 5BDF              ; input A=number of characters to process
 138+ 5BDF              ; input IX=pointer to structure describing input data
 139+ 5BDF              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5BDF              SHIFT_ROW:
 141+ 5BDF F5           	PUSH AF
 142+ 5BE0 ED 53 49 61  		LD (BLIT_TMP1), DE
 143+ 5BE4 E5           		PUSH HL
 144+ 5BE5 CD 28 5C     			CALL .ADDYSHIFT
 145+ 5BE8 E1           		POP HL
 146+ 5BE9 ED 53 4B 61  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5BED              .L1:
 148+ 5BED 3E 08        		LD A, 8
 149+ 5BEF DD 96 02     		SUB (IX+2) ; y shift
 150+ 5BF2              .CALL1:
 151+ 5BF2 CD 00 00     		CALL 0
 152+ 5BF5 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5BF8 B7           		OR A
 154+ 5BF9 28 26        		JR Z, .DONE
 155+ 5BFB ED 5B 49 61  		LD DE, (BLIT_TMP1)
 156+ 5BFF E5           		PUSH HL
 157+ 5C00 CD 36 5C     			CALL .DETONEXTROW
 158+ 5C03 E1           		POP HL
 159+ 5C04              .CALL2:
 160+ 5C04 CD 00 00     		CALL 0
 161+ 5C07 ED 5B 49 61  		LD DE, (BLIT_TMP1)
 162+ 5C0B E5           		PUSH HL
 163+ 5C0C CD 30 5C     			CALL .ADD8
 164+ 5C0F E1           		POP HL
 165+ 5C10 ED 53 49 61  		LD (BLIT_TMP1), DE
 166+ 5C14 ED 5B 4B 61  		LD DE, (BLIT_TMP2)
 167+ 5C18 E5           		PUSH HL
 168+ 5C19 CD 30 5C     			CALL .ADD8
 169+ 5C1C E1           		POP HL
 170+ 5C1D ED 53 4B 61  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5C21              .DONE:
 172+ 5C21 F1           	POP AF
 173+ 5C22 3D           	DEC A
 174+ 5C23 C8           	RET Z
 175+ 5C24 F5           	PUSH AF
 176+ 5C25 C3 ED 5B     	JP .L1
 177+ 5C28              .ADDYSHIFT:
 178+ 5C28 EB           	EX DE, HL
 179+ 5C29 16 00        	LD D, 0
 180+ 5C2B DD 5E 02     	LD E, (IX+2); y shift
 181+ 5C2E 18 0C        	JR .MOVDEBC
 182+ 5C30              .ADD8:
 183+ 5C30 21 08 00     	LD HL, 8
 184+ 5C33 C3 3C 5C     	JP .MOVDEBC
 185+ 5C36              .DETONEXTROW:
 186+ 5C36 DD 6E 06     	LD L, (IX+6)
 187+ 5C39 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5C3C              .MOVDEBC:
 189+ 5C3C 19           	ADD HL, DE
 190+ 5C3D 54           	LD D, H
 191+ 5C3E 5D           	LD E, L
 192+ 5C3F 01 08 00     	LD BC, 8
 193+ 5C42 09           	ADD HL, BC
 194+ 5C43 44           	LD B, H
 195+ 5C44 4D           	LD C, L
 196+ 5C45 C9           	RET
 197+ 5C46              ; *******************************************************************************************************
 198+ 5C46
 199+ 5C46              ; *******************************************************************************************************
 200+ 5C46              ; function rotates mask and character data and applies it to background
 201+ 5C46              ; input IX=pointer to structure describing input data
 202+ 5C46              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5C46              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5C46              ; +4  DW background data start;
 205+ 5C46              ; +6  DW background add to value to next row of background data
 206+ 5C46              ; +8  DW mask data start;
 207+ 5C46              ; +10  DW character data start;
 208+ 5C46              ; +12 DW character&mask add to value to next row of data
 209+ 5C46              ; +14 DW columns (low byte used)
 210+ 5C46              ; +16 DW rows (low byte used)
 211+ 5C46              SHIFT_MERGE_CHARACTER:
 212+ 5C46 DD 7E 00     	LD A, (IX) ; shift
 213+ 5C49 FE 05        	CP 5
 214+ 5C4B 38 25        	JR C, .RIGHT
 215+ 5C4D              	; shifts 5-7, use rotate towards left 1-3
 216+ 5C4D 21 A2 5B     	LD HL, SHIFT58
 217+ 5C50 22 F3 5B     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5C53 22 05 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5C56 D6 05        	SUB 5
 220+ 5C58 28 0D        	JR Z, .L1
 221+ 5C5A 87           	ADD A, A
 222+ 5C5B 87           	ADD A, A
 223+ 5C5C 67           	LD H, A
 224+ 5C5D 2E 18        	LD L, #18 ; JR opcode
 225+ 5C5F 22 A9 5B     	LD (SHIFT58.M1), HL
 226+ 5C62 22 BA 5B     	LD (SHIFT58.M2), HL
 227+ 5C65 18 32        	JR .DO
 228+ 5C67              .L1:
 229+ 5C67 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5C6A 22 A9 5B     	LD (SHIFT58.M1), HL
 231+ 5C6D 22 BA 5B     	LD (SHIFT58.M2), HL
 232+ 5C70 18 27        	JR .DO
 233+ 5C72              .RIGHT:
 234+ 5C72              	; shifts 0-4, rotate towards right
 235+ 5C72 21 5D 5B     	LD HL, SHIFT04
 236+ 5C75 22 F3 5B     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5C78 22 05 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5C7B FE 04        	CP 4
 239+ 5C7D 28 11        	JR Z, .R1
 240+ 5C7F D6 04        	SUB 4
 241+ 5C81 ED 44        	NEG
 242+ 5C83 87           	ADD A, A
 243+ 5C84 87           	ADD A, A
 244+ 5C85 67           	LD H, A
 245+ 5C86 2E 18        	LD L, #18 ; JR opcode
 246+ 5C88 22 64 5B     	LD (SHIFT04.M1), HL
 247+ 5C8B 22 79 5B     	LD (SHIFT04.M2), HL
 248+ 5C8E 18 09        	JR .DO
 249+ 5C90              .R1:
 250+ 5C90 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5C93 22 64 5B     	LD (SHIFT04.M1), HL
 252+ 5C96 22 79 5B     	LD (SHIFT04.M2), HL
 253+ 5C99              .DO:
 254+ 5C99 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5C9C DD 6E 08     	LD L, (IX+8)
 256+ 5C9F DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5CA2 DD 5E 04     	LD E, (IX+4)
 258+ 5CA5 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5CA8 D9           	EXX
 260+ 5CA9 DD 6E 0A     	LD L, (IX+10)
 261+ 5CAC DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5CAF D9           	EXX
 263+ 5CB0              .LOOP:
 264+ 5CB0 C5           	PUSH BC
 265+ 5CB1 E5           		PUSH HL
 266+ 5CB2 D5           			PUSH DE
 267+ 5CB3 D9           				EXX
 268+ 5CB4 E5           				PUSH HL
 269+ 5CB5 D9           					EXX
 270+ 5CB6 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5CB9              .CALL:
 272+ 5CB9 CD DF 5B     					CALL SHIFT_ROW
 273+ 5CBC E1           				POP HL
 274+ 5CBD DD 5E 0C     				LD E, (IX+12)
 275+ 5CC0 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5CC3 19           				ADD HL, DE
 277+ 5CC4 D9           				EXX
 278+ 5CC5 E1           			POP HL
 279+ 5CC6 DD 5E 06     			LD E, (IX+6)
 280+ 5CC9 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5CCC 19           			ADD HL, DE
 282+ 5CCD EB           			EX DE, HL
 283+ 5CCE E1           		POP HL
 284+ 5CCF DD 4E 0C     		LD C, (IX+12)
 285+ 5CD2 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5CD5 09           		ADD HL, BC
 287+ 5CD6 C1           	POP BC
 288+ 5CD7 10 D7        	DJNZ .LOOP
 289+ 5CD9 C9           	RET
 290+ 5CDA              ; *******************************************************************************************************
 291+ 5CDA
 292+ 5CDA               IFNDEF CMDS_WITH_PARAMETERS
 293+ 5CDA ~            ; *******************************************************************************************************
 294+ 5CDA ~            ; function to handle CALL BLIT basic extension
 295+ 5CDA ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 296+ 5CDA ~            ; fuses with background data and applies vertical shift too
 297+ 5CDA ~            ; BLIT ( INT request_data_ptr )
 298+ 5CDA ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
 299+ 5CDA ~            ; will put ram in page 0 also, page 1 is already there
 300+ 5CDA ~            BLIT:
 301+ 5CDA ~            	; opening (
 302+ 5CDA ~            	CALL CHKCHAR
 303+ 5CDA ~            	DB '('
 304+ 5CDA ~            	; get pointer to request struct
 305+ 5CDA ~            	LD IX, FRMQNT
 306+ 5CDA ~            	CALL CALBAS
 307+ 5CDA ~            	PUSH DE
 308+ 5CDA ~            	; ending )
 309+ 5CDA ~            	CALL CHKCHAR
 310+ 5CDA ~            	DB ')'
 311+ 5CDA ~
 312+ 5CDA ~            	POP IX ; pointer to request struct
 313+ 5CDA ~
 314+ 5CDA ~            	PUSH HL ; save position in BASIC buffer
 315+ 5CDA ~
 316+ 5CDA ~            	LD IY, .RET
 317+ 5CDA ~            	JP ENABLE_PAGE0
 318+ 5CDA ~            .RET:
 319+ 5CDA ~            	EI
 320+ 5CDA ~            	CALL SHIFT_MERGE_CHARACTER
 321+ 5CDA ~
 322+ 5CDA ~                POP DE
 323+ 5CDA ~                POP BC
 324+ 5CDA ~                CALL RESTORE_PAGE_INFO
 325+ 5CDA ~
 326+ 5CDA ~            	POP HL
 327+ 5CDA ~            	RET
 328+ 5CDA ~            ; *******************************************************************************************************
 329+ 5CDA               ENDIF
 330+ 5CDA
 331+ 5CDA               IFDEF CMDS_WITH_PARAMETERS
 332+ 5CDA              ; *******************************************************************************************************
 333+ 5CDA              ; function to handle CALL BLIT basic extension
 334+ 5CDA              ; rotates 1-bit character drawing horizontally with mask and character data and
 335+ 5CDA              ; fuses with background data and applies vertical shift too
 336+ 5CDA              ; in form without pointers
 337+ 5CDA              ; BLIT ( INT x,
 338+ 5CDA              ;		 INT y,
 339+ 5CDA              ;		 INT char_data_pointer,
 340+ 5CDA              ;		 INT mask_data_pointer,
 341+ 5CDA              ;		 INT width (in characters),
 342+ 5CDA              ;		 INT height (in characters),
 343+ 5CDA              ;		 INT background_pointer (top left),
 344+ 5CDA              ;		 INT background_width (in characters),
 345+ 5CDA              ;		 INT background_height (in characters))
 346+ 5CDA              ; will put ram in page 0 also, page 1 is already there
 347+ 5CDA              BLIT:
 348+ 5CDA              	; opening (
 349+ 5CDA CD 3C 64     	CALL CHKCHAR
 350+ 5CDD 28           	DB '('
 351+ 5CDE              	; get x coordinate
 352+ 5CDE DD 21 2F 54  	LD IX, FRMQNT
 353+ 5CE2 CD 59 01     	CALL CALBAS
 354+ 5CE5 7B           	LD A, E
 355+ 5CE6 E6 07        	AND 7
 356+ 5CE8 32 4D 61     	LD (BLIT_STRUCT+0), A
 357+ 5CEB CD C8 5D     	CALL .DAdiv8
 358+ 5CEE 32 49 61     	LD (BLIT_TMP+0),A
 359+ 5CF1              	; comma
 360+ 5CF1 CD 3C 64     	CALL CHKCHAR
 361+ 5CF4 2C           	DB ','
 362+ 5CF5              	; get y coordinate
 363+ 5CF5 DD 21 2F 54  	LD IX, FRMQNT
 364+ 5CF9 CD 59 01     	CALL CALBAS
 365+ 5CFC 7B           	LD A, E
 366+ 5CFD E6 07        	AND 7
 367+ 5CFF 32 4F 61     	LD (BLIT_STRUCT+2), A
 368+ 5D02 CD C8 5D     	CALL .DAdiv8
 369+ 5D05 32 4A 61     	LD (BLIT_TMP+1),A
 370+ 5D08              	; comma
 371+ 5D08 CD 3C 64     	CALL CHKCHAR
 372+ 5D0B 2C           	DB ','
 373+ 5D0C              	; get char data pointer
 374+ 5D0C DD 21 2F 54  	LD IX, FRMQNT
 375+ 5D10 CD 59 01     	CALL CALBAS
 376+ 5D13 ED 53 57 61  	LD (BLIT_STRUCT+10), DE
 377+ 5D17              	; comma
 378+ 5D17 CD 3C 64     	CALL CHKCHAR
 379+ 5D1A 2C           	DB ','
 380+ 5D1B              	; get mask data pointer
 381+ 5D1B DD 21 2F 54  	LD IX, FRMQNT
 382+ 5D1F CD 59 01     	CALL CALBAS
 383+ 5D22 ED 53 55 61  	LD (BLIT_STRUCT+8), DE
 384+ 5D26              	; comma
 385+ 5D26 CD 3C 64     	CALL CHKCHAR
 386+ 5D29 2C           	DB ','
 387+ 5D2A              	; get width
 388+ 5D2A DD 21 2F 54  	LD IX, FRMQNT
 389+ 5D2E CD 59 01     	CALL CALBAS
 390+ 5D31 7B           	LD A, E
 391+ 5D32 32 5B 61     	LD (BLIT_STRUCT+14), A
 392+ 5D35              	; comma
 393+ 5D35 CD 3C 64     	CALL CHKCHAR
 394+ 5D38 2C           	DB ','
 395+ 5D39              	; get height
 396+ 5D39 DD 21 2F 54  	LD IX, FRMQNT
 397+ 5D3D CD 59 01     	CALL CALBAS
 398+ 5D40 7B           	LD A, E
 399+ 5D41 32 5D 61     	LD (BLIT_STRUCT+16), A
 400+ 5D44              	; comma
 401+ 5D44 CD 3C 64     	CALL CHKCHAR
 402+ 5D47 2C           	DB ','
 403+ 5D48              	; get background pointer
 404+ 5D48 DD 21 2F 54  	LD IX, FRMQNT
 405+ 5D4C CD 59 01     	CALL CALBAS
 406+ 5D4F ED 53 51 61  	LD (BLIT_STRUCT+4), DE
 407+ 5D53              	; comma
 408+ 5D53 CD 3C 64     	CALL CHKCHAR
 409+ 5D56 2C           	DB ','
 410+ 5D57              	; get background width
 411+ 5D57 DD 21 2F 54  	LD IX, FRMQNT
 412+ 5D5B CD 59 01     	CALL CALBAS
 413+ 5D5E 7B           	LD A, E
 414+ 5D5F 32 4B 61     	LD (BLIT_TMP+2), A
 415+ 5D62              	; comma
 416+ 5D62 CD 3C 64     	CALL CHKCHAR
 417+ 5D65 2C           	DB ','
 418+ 5D66              	; get background height
 419+ 5D66 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5D6A CD 59 01     	CALL CALBAS
 421+ 5D6D 7B           	LD A, E
 422+ 5D6E 32 4C 61     	LD (BLIT_TMP+3), A
 423+ 5D71              	; ending )
 424+ 5D71 CD 3C 64     	CALL CHKCHAR
 425+ 5D74 29           	DB ')'
 426+ 5D75
 427+ 5D75 E5           	PUSH HL ; save position in BASIC buffer
 428+ 5D76
 429+ 5D76              	; calculate char&mask add to value
 430+ 5D76 26 00        	LD H, 0
 431+ 5D78 3A 5B 61     	LD A, (BLIT_STRUCT+14)
 432+ 5D7B 6F           	LD L, A
 433+ 5D7C CD 2A 63     	CALL HLx8
 434+ 5D7F 22 59 61     	LD (BLIT_STRUCT+12), HL
 435+ 5D82              	; calculate background add to value
 436+ 5D82 26 00        	LD H, 0
 437+ 5D84 3A 4B 61     	LD A, (BLIT_TMP+2)
 438+ 5D87 6F           	LD L, A
 439+ 5D88 CD 2A 63     	CALL HLx8
 440+ 5D8B 22 53 61     	LD (BLIT_STRUCT+6), HL
 441+ 5D8E              	; calculate pointer to background location
 442+ 5D8E 21 00 00     	LD HL, 0
 443+ 5D91 3A 4A 61     	LD A,(BLIT_TMP+1)
 444+ 5D94 B7           	OR A
 445+ 5D95 28 08        	JR Z, .L1
 446+ 5D97 47           	LD B,A
 447+ 5D98 ED 5B 53 61  	LD DE,(BLIT_STRUCT+6)
 448+ 5D9C              .L0:
 449+ 5D9C 19           	ADD HL, DE
 450+ 5D9D 10 FD        	DJNZ .L0
 451+ 5D9F              .L1:
 452+ 5D9F EB           	EX DE,HL
 453+ 5DA0 26 00        	LD H,0
 454+ 5DA2 3A 49 61     	LD A,(BLIT_TMP+0)
 455+ 5DA5 6F           	LD L,A
 456+ 5DA6 CD 2A 63     	CALL HLx8
 457+ 5DA9 19           	ADD HL,DE
 458+ 5DAA ED 5B 51 61  	LD DE,(BLIT_STRUCT+4)
 459+ 5DAE 19           	ADD HL,DE
 460+ 5DAF 22 51 61     	LD (BLIT_STRUCT+4),HL
 461+ 5DB2
 462+ 5DB2 FD 21 B9 5D  	LD IY, .RET
 463+ 5DB6 C3 EE 63     	JP ENABLE_PAGE0
 464+ 5DB9              .RET:
 465+ 5DB9 FB           	EI
 466+ 5DBA DD 21 4D 61  	LD IX, BLIT_STRUCT
 467+ 5DBE CD 46 5C     	CALL SHIFT_MERGE_CHARACTER
 468+ 5DC1
 469+ 5DC1 D1               POP DE
 470+ 5DC2 C1               POP BC
 471+ 5DC3 CD 65 63         CALL RESTORE_PAGE_INFO
 472+ 5DC6
 473+ 5DC6 E1           	POP HL
 474+ 5DC7 C9           	RET
 475+ 5DC8              .DAdiv8:
 476+ 5DC8 7B           	LD A,E
 477+ 5DC9 CB 2A        	SRA D
 478+ 5DCB CB 1F            RR  A
 479+ 5DCD CB 2A            SRA D
 480+ 5DCF CB 1F            RR  A
 481+ 5DD1 CB 2A            SRA D
 482+ 5DD3 CB 1F            RR  A
 483+ 5DD5 C9           	RET
 484+ 5DD6              ; *******************************************************************************************************
 485+ 5DD6               ENDIF
# file closed: asm\BLIT.asm
 149  5DD6               ENDIF
 150  5DD6
 151  5DD6               IF (TILE_CMDS == 1)
 152  5DD6               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5DD6              ; *******************************************************************************************************
   2+ 5DD6              ; generic function to implement tiling
   3+ 5DD6              ; should be modified to call appropriate function for memory or vram
   4+ 5DD6              ; input IX=pointer to following structure
   5+ 5DD6              ; +00 tile_data_ptr
   6+ 5DD6              ; +02 tile_rows
   7+ 5DD6              ; +04 tile_columns
   8+ 5DD6              ; +06 destination_address
   9+ 5DD6              ; +08 dest_to_next_row_add_to_value
  10+ 5DD6              ; +10 num_horizontal_tiles
  11+ 5DD6              ; +12 num_vertical_tiles
  12+ 5DD6              ; modifies AF, BC, DE, HL
  13+ 5DD6              TILE:
  14+ 5DD6 DD 6E 06     	LD L, (IX+6)
  15+ 5DD9 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5DDC 22 49 61     	LD (TILETMP1), HL
  17+ 5DDF DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5DE2              .L1:
  19+ 5DE2 C5           	PUSH BC
  20+ 5DE3 DD 6E 00     		LD L, (IX+0)
  21+ 5DE6 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5DE9 22 4B 61     		LD (TILETMP2), HL
  23+ 5DEC DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5DEF              .L2:
  25+ 5DEF C5           		PUSH BC
  26+ 5DF0 CD 00 00     .CALL1:		CALL 0
  27+ 5DF3 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5DF6              .L3:
  29+ 5DF6 C5           			PUSH BC
  30+ 5DF7 2A 4B 61     				LD HL, (TILETMP2)
  31+ 5DFA DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5DFD              .L4:
  33+ 5DFD C5           				PUSH BC
  34+ 5DFE              .CALL2:
  35+ 5DFE CD 00 00     					CALL 0
  36+ 5E01 C1           				POP BC
  37+ 5E02 10 F9        				DJNZ .L4
  38+ 5E04 C1           			POP BC
  39+ 5E05 10 EF        			DJNZ .L3
  40+ 5E07 22 4B 61     			LD (TILETMP2), HL
  41+ 5E0A 2A 49 61     			LD HL, (TILETMP1)
  42+ 5E0D DD 5E 08     			LD E, (IX+8)
  43+ 5E10 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5E13 19           			ADD HL, DE
  45+ 5E14 22 49 61     			LD (TILETMP1), HL
  46+ 5E17 C1           		POP BC
  47+ 5E18 10 D5        		DJNZ .L2
  48+ 5E1A C1           	POP BC
  49+ 5E1B 10 C5        	DJNZ .L1
  50+ 5E1D C9           	RET
  51+ 5E1E              ; *******************************************************************************************************
  52+ 5E1E
  53+ 5E1E               IFNDEF CMDS_WITH_PARAMETERS
  54+ 5E1E ~            ; *******************************************************************************************************
  55+ 5E1E ~            ; function to handle CALL TILERAM basic extension
  56+ 5E1E ~            ; fills memory with tiles
  57+ 5E1E ~            ; TILERAM ( INT request_data_ptr )
  58+ 5E1E ~            ; request_data_ptr described in TILE
  59+ 5E1E ~            ; will put ram in page 0 also, page 1 is already there
  60+ 5E1E ~            TILERAM:
  61+ 5E1E ~            	; opening (
  62+ 5E1E ~            	CALL CHKCHAR
  63+ 5E1E ~            	DB '('
  64+ 5E1E ~            	; get pointer to request struct
  65+ 5E1E ~            	LD IX, FRMQNT
  66+ 5E1E ~            	CALL CALBAS
  67+ 5E1E ~            	PUSH DE
  68+ 5E1E ~            	; ending )
  69+ 5E1E ~            	CALL CHKCHAR
  70+ 5E1E ~            	DB ')'
  71+ 5E1E ~
  72+ 5E1E ~            	POP IX ; pointer to request struct
  73+ 5E1E ~
  74+ 5E1E ~            	PUSH HL ; save position in BASIC buffer
  75+ 5E1E ~
  76+ 5E1E ~            	LD IY, .RET
  77+ 5E1E ~            	JP ENABLE_PAGE0
  78+ 5E1E ~            .RET:
  79+ 5E1E ~            	EI
  80+ 5E1E ~            	; set RAM functions to call
  81+ 5E1E ~            	LD HL, .TILECOPY
  82+ 5E1E ~            	LD (TILE.CALL2+1), HL
  83+ 5E1E ~            	LD HL, .SETDESTROW
  84+ 5E1E ~            	LD (TILE.CALL1+1), HL
  85+ 5E1E ~            	LD A,1
  86+ 5E1E ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 5E1E ~            	CALL TILE
  88+ 5E1E ~            	XOR A
  89+ 5E1E ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 5E1E ~
  91+ 5E1E ~                POP DE
  92+ 5E1E ~                POP BC
  93+ 5E1E ~                CALL RESTORE_PAGE_INFO
  94+ 5E1E ~
  95+ 5E1E ~            	POP HL
  96+ 5E1E ~            	RET
  97+ 5E1E ~            .TILECOPY:
  98+ 5E1E ~            	.8 LDI
  99+ 5E1E ~            	RET
 100+ 5E1E ~            .SETDESTROW:
 101+ 5E1E ~            	LD DE, (TILETMP1)
 102+ 5E1E ~            	RET
 103+ 5E1E ~            ; *******************************************************************************************************
 104+ 5E1E               ENDIF
 105+ 5E1E
 106+ 5E1E               IFDEF CMDS_WITH_PARAMETERS
 107+ 5E1E              ; *******************************************************************************************************
 108+ 5E1E              ; function to handle CALL TILERAM basic extension
 109+ 5E1E              ; fills memory with tiles
 110+ 5E1E              ; TILERAM ( INT tile_data_pointer,
 111+ 5E1E              ;			INT tile_columns,
 112+ 5E1E              ;			INT tile_rows,
 113+ 5E1E              ;			INT destination_pointer,
 114+ 5E1E              ;			INT destination_columns,
 115+ 5E1E              ;			INT destination_rows,
 116+ 5E1E              ;			INT destination_begin_column,
 117+ 5E1E              ;			INT destination_begin_row,
 118+ 5E1E              ;			INT number_of_tiles_horizontally,
 119+ 5E1E              ;			INT	number_of_tiles_vertically )
 120+ 5E1E              ; will put ram in page 0 also, page 1 is already there
 121+ 5E1E              TILERAM:
 122+ 5E1E              	; opening (
 123+ 5E1E CD 3C 64     	CALL CHKCHAR
 124+ 5E21 28           	DB '('
 125+ 5E22              	; get tile data pointer coordinate
 126+ 5E22 DD 21 2F 54  	LD IX, FRMQNT
 127+ 5E26 CD 59 01     	CALL CALBAS
 128+ 5E29 ED 53 4D 61  	LD (BLIT_STRUCT+0), DE
 129+ 5E2D              	; comma
 130+ 5E2D CD 3C 64     	CALL CHKCHAR
 131+ 5E30 2C           	DB ','
 132+ 5E31              	; get tile columns
 133+ 5E31 DD 21 2F 54  	LD IX, FRMQNT
 134+ 5E35 CD 59 01     	CALL CALBAS
 135+ 5E38 ED 53 51 61  	LD (BLIT_STRUCT+4), DE
 136+ 5E3C              	; comma
 137+ 5E3C CD 3C 64     	CALL CHKCHAR
 138+ 5E3F 2C           	DB ','
 139+ 5E40              	; get tile columns
 140+ 5E40 DD 21 2F 54  	LD IX, FRMQNT
 141+ 5E44 CD 59 01     	CALL CALBAS
 142+ 5E47 ED 53 4F 61  	LD (BLIT_STRUCT+2), DE
 143+ 5E4B              	; comma
 144+ 5E4B CD 3C 64     	CALL CHKCHAR
 145+ 5E4E 2C           	DB ','
 146+ 5E4F              	; get destintion pointer
 147+ 5E4F DD 21 2F 54  	LD IX, FRMQNT
 148+ 5E53 CD 59 01     	CALL CALBAS
 149+ 5E56 ED 53 53 61  	LD (BLIT_STRUCT+6), DE
 150+ 5E5A              	; comma
 151+ 5E5A CD 3C 64     	CALL CHKCHAR
 152+ 5E5D 2C           	DB ','
 153+ 5E5E              	; get destination columns
 154+ 5E5E DD 21 2F 54  	LD IX, FRMQNT
 155+ 5E62 CD 59 01     	CALL CALBAS
 156+ 5E65 7B           	LD A, E
 157+ 5E66 32 49 61     	LD (BLIT_TMP+0), A
 158+ 5E69              	; comma
 159+ 5E69 CD 3C 64     	CALL CHKCHAR
 160+ 5E6C 2C           	DB ','
 161+ 5E6D              	; get destination rows
 162+ 5E6D DD 21 2F 54  	LD IX, FRMQNT
 163+ 5E71 CD 59 01     	CALL CALBAS
 164+ 5E74 7B           	LD A, E
 165+ 5E75 32 4A 61     	LD (BLIT_TMP+1), A
 166+ 5E78              	; comma
 167+ 5E78 CD 3C 64     	CALL CHKCHAR
 168+ 5E7B 2C           	DB ','
 169+ 5E7C              	; get destination begin column
 170+ 5E7C DD 21 2F 54  	LD IX, FRMQNT
 171+ 5E80 CD 59 01     	CALL CALBAS
 172+ 5E83 7B           	LD A, E
 173+ 5E84 32 4B 61     	LD (BLIT_TMP+2), A
 174+ 5E87              	; comma
 175+ 5E87 CD 3C 64     	CALL CHKCHAR
 176+ 5E8A 2C           	DB ','
 177+ 5E8B              	; get destination begin row
 178+ 5E8B DD 21 2F 54  	LD IX, FRMQNT
 179+ 5E8F CD 59 01     	CALL CALBAS
 180+ 5E92 7B           	LD A, E
 181+ 5E93 32 4C 61     	LD (BLIT_TMP+3), A
 182+ 5E96              	; comma
 183+ 5E96 CD 3C 64     	CALL CHKCHAR
 184+ 5E99 2C           	DB ','
 185+ 5E9A              	; get number of tiles horizontally
 186+ 5E9A DD 21 2F 54  	LD IX, FRMQNT
 187+ 5E9E CD 59 01     	CALL CALBAS
 188+ 5EA1 ED 53 57 61  	LD (BLIT_STRUCT+10), DE
 189+ 5EA5              	; comma
 190+ 5EA5 CD 3C 64     	CALL CHKCHAR
 191+ 5EA8 2C           	DB ','
 192+ 5EA9              	; get number of tiles vertically
 193+ 5EA9 DD 21 2F 54  	LD IX, FRMQNT
 194+ 5EAD CD 59 01     	CALL CALBAS
 195+ 5EB0 ED 53 59 61  	LD (BLIT_STRUCT+12), DE
 196+ 5EB4              	; ending )
 197+ 5EB4 CD 3C 64     	CALL CHKCHAR
 198+ 5EB7 29           	DB ')'
 199+ 5EB8
 200+ 5EB8 E5           	PUSH HL ; save position in BASIC buffer
 201+ 5EB9
 202+ 5EB9              	; calculate destination add to value
 203+ 5EB9 26 00        	LD H, 0
 204+ 5EBB 3A 49 61     	LD A, (BLIT_TMP+0)
 205+ 5EBE 6F           	LD L, A
 206+ 5EBF CD 2A 63     	CALL HLx8
 207+ 5EC2 22 55 61     	LD (BLIT_STRUCT+8), HL
 208+ 5EC5              	; calculate pointer to background location
 209+ 5EC5 21 00 00     	LD HL, 0
 210+ 5EC8 3A 4C 61     	LD A,(BLIT_TMP+3)
 211+ 5ECB B7           	OR A
 212+ 5ECC 28 08        	JR Z, .L1
 213+ 5ECE 47           	LD B,A
 214+ 5ECF ED 5B 55 61  	LD DE,(BLIT_STRUCT+8)
 215+ 5ED3              .L0:
 216+ 5ED3 19           	ADD HL, DE
 217+ 5ED4 10 FD        	DJNZ .L0
 218+ 5ED6              .L1:
 219+ 5ED6 EB           	EX DE,HL
 220+ 5ED7 26 00        	LD H,0
 221+ 5ED9 3A 4B 61     	LD A,(BLIT_TMP+2)
 222+ 5EDC 6F           	LD L,A
 223+ 5EDD CD 2A 63     	CALL HLx8
 224+ 5EE0 19           	ADD HL,DE
 225+ 5EE1 ED 5B 53 61  	LD DE,(BLIT_STRUCT+6)
 226+ 5EE5 19           	ADD HL,DE
 227+ 5EE6 22 53 61     	LD (BLIT_STRUCT+6),HL
 228+ 5EE9
 229+ 5EE9 FD 21 F0 5E  	LD IY, .RET
 230+ 5EED C3 EE 63     	JP ENABLE_PAGE0
 231+ 5EF0              .RET:
 232+ 5EF0 FB           	EI
 233+ 5EF1              	; set RAM functions to call
 234+ 5EF1 21 0B 5F     	LD HL, .TILECOPY
 235+ 5EF4 22 FF 5D     	LD (TILE.CALL2+1), HL
 236+ 5EF7 21 1C 5F     	LD HL, .SETDESTROW
 237+ 5EFA 22 F1 5D     	LD (TILE.CALL1+1), HL
 238+ 5EFD DD 21 4D 61  	LD IX,BLIT_STRUCT
 239+ 5F01 CD D6 5D     	CALL TILE
 240+ 5F04
 241+ 5F04 D1               POP DE
 242+ 5F05 C1               POP BC
 243+ 5F06 CD 65 63         CALL RESTORE_PAGE_INFO
 244+ 5F09
 245+ 5F09 E1           	POP HL
 246+ 5F0A C9           	RET
 247+ 5F0B              .TILECOPY:
 248+ 5F0B ED A0       > LDI
 248+ 5F0D ED A0       > LDI
 248+ 5F0F ED A0       > LDI
 248+ 5F11 ED A0       > LDI
 248+ 5F13 ED A0       > LDI
 248+ 5F15 ED A0       > LDI
 248+ 5F17 ED A0       > LDI
 248+ 5F19 ED A0       > LDI
 249+ 5F1B C9           	RET
 250+ 5F1C              .SETDESTROW:
 251+ 5F1C ED 5B 49 61  	LD DE, (TILETMP1)
 252+ 5F20 C9           	RET
 253+ 5F21              ; *******************************************************************************************************
 254+ 5F21               ENDIF
 255+ 5F21
 256+ 5F21               IFDEF CMDS_WITH_PARAMETERS
 257+ 5F21              ; *******************************************************************************************************
 258+ 5F21              ; function to handle CALL TILEVRM basic extension
 259+ 5F21              ; fills vram with tiles
 260+ 5F21              ; TILEVRM ( INT tile_data_pointer,
 261+ 5F21              ;			INT tile_columns,
 262+ 5F21              ;			INT tile_rows,
 263+ 5F21              ;			INT destination_begin_column,
 264+ 5F21              ;			INT destination_begin_row,
 265+ 5F21              ;			INT number_of_tiles_horizontally,
 266+ 5F21              ;			INT	number_of_tiles_vertically )
 267+ 5F21              ; will put ram in page 0 also, page 1 is already there
 268+ 5F21              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 5F21              TILEVRM:
 270+ 5F21              	; opening (
 271+ 5F21 CD 3C 64     	CALL CHKCHAR
 272+ 5F24 28           	DB '('
 273+ 5F25              	; get tile data pointer coordinate
 274+ 5F25 DD 21 2F 54  	LD IX, FRMQNT
 275+ 5F29 CD 59 01     	CALL CALBAS
 276+ 5F2C ED 53 4D 61  	LD (BLIT_STRUCT+0), DE
 277+ 5F30              	; comma
 278+ 5F30 CD 3C 64     	CALL CHKCHAR
 279+ 5F33 2C           	DB ','
 280+ 5F34              	; get tile columns
 281+ 5F34 DD 21 2F 54  	LD IX, FRMQNT
 282+ 5F38 CD 59 01     	CALL CALBAS
 283+ 5F3B ED 53 51 61  	LD (BLIT_STRUCT+4), DE
 284+ 5F3F              	; comma
 285+ 5F3F CD 3C 64     	CALL CHKCHAR
 286+ 5F42 2C           	DB ','
 287+ 5F43              	; get tile columns
 288+ 5F43 DD 21 2F 54  	LD IX, FRMQNT
 289+ 5F47 CD 59 01     	CALL CALBAS
 290+ 5F4A ED 53 4F 61  	LD (BLIT_STRUCT+2), DE
 291+ 5F4E              	; comma
 292+ 5F4E CD 3C 64     	CALL CHKCHAR
 293+ 5F51 2C           	DB ','
 294+ 5F52              	; get destination begin column
 295+ 5F52 DD 21 2F 54  	LD IX, FRMQNT
 296+ 5F56 CD 59 01     	CALL CALBAS
 297+ 5F59 7B           	LD A, E
 298+ 5F5A 32 4B 61     	LD (BLIT_TMP+2), A
 299+ 5F5D              	; comma
 300+ 5F5D CD 3C 64     	CALL CHKCHAR
 301+ 5F60 2C           	DB ','
 302+ 5F61              	; get destination begin row
 303+ 5F61 DD 21 2F 54  	LD IX, FRMQNT
 304+ 5F65 CD 59 01     	CALL CALBAS
 305+ 5F68 7B           	LD A, E
 306+ 5F69 32 4C 61     	LD (BLIT_TMP+3), A
 307+ 5F6C              	; comma
 308+ 5F6C CD 3C 64     	CALL CHKCHAR
 309+ 5F6F 2C           	DB ','
 310+ 5F70              	; get number of tiles horizontally
 311+ 5F70 DD 21 2F 54  	LD IX, FRMQNT
 312+ 5F74 CD 59 01     	CALL CALBAS
 313+ 5F77 ED 53 57 61  	LD (BLIT_STRUCT+10), DE
 314+ 5F7B              	; comma
 315+ 5F7B CD 3C 64     	CALL CHKCHAR
 316+ 5F7E 2C           	DB ','
 317+ 5F7F              	; get number of tiles vertically
 318+ 5F7F DD 21 2F 54  	LD IX, FRMQNT
 319+ 5F83 CD 59 01     	CALL CALBAS
 320+ 5F86 ED 53 59 61  	LD (BLIT_STRUCT+12), DE
 321+ 5F8A              	; ending )
 322+ 5F8A CD 3C 64     	CALL CHKCHAR
 323+ 5F8D 29           	DB ')'
 324+ 5F8E
 325+ 5F8E E5           	PUSH HL ; save position in BASIC buffer
 326+ 5F8F
 327+ 5F8F              	; calculate destination add to value
 328+ 5F8F 21 00 01     	LD HL, 256
 329+ 5F92 22 55 61     	LD (BLIT_STRUCT+8), HL
 330+ 5F95              	; calculate pointer to background location
 331+ 5F95 3A 4C 61     	LD A,(BLIT_TMP+3)
 332+ 5F98 67           	LD H,A
 333+ 5F99 2E 00        	LD L,0
 334+ 5F9B EB           	EX DE,HL
 335+ 5F9C 26 00        	LD H,0
 336+ 5F9E 3A 4B 61     	LD A,(BLIT_TMP+2)
 337+ 5FA1 6F           	LD L,A
 338+ 5FA2 CD 2A 63     	CALL HLx8
 339+ 5FA5 19           	ADD HL,DE
 340+ 5FA6 ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 5FAA 19           	ADD HL,DE
 342+ 5FAB 22 53 61     	LD (BLIT_STRUCT+6),HL
 343+ 5FAE
 344+ 5FAE FD 21 B5 5F  	LD IY, .RET
 345+ 5FB2 C3 EE 63     	JP ENABLE_PAGE0
 346+ 5FB5              .RET:
 347+ 5FB5 FB           	EI
 348+ 5FB6              	; set RAM functions to call
 349+ 5FB6 21 D0 5F     	LD HL, .TILECOPY
 350+ 5FB9 22 FF 5D     	LD (TILE.CALL2+1), HL
 351+ 5FBC 21 D6 5F     	LD HL, .SETDESTROW
 352+ 5FBF 22 F1 5D     	LD (TILE.CALL1+1), HL
 353+ 5FC2 DD 21 4D 61  	LD IX,BLIT_STRUCT
 354+ 5FC6 CD D6 5D     	CALL TILE
 355+ 5FC9
 356+ 5FC9 D1               POP DE
 357+ 5FCA C1               POP BC
 358+ 5FCB CD 65 63         CALL RESTORE_PAGE_INFO
 359+ 5FCE
 360+ 5FCE E1           	POP HL
 361+ 5FCF C9           	RET
 362+ 5FD0              .TILECOPY:
 363+ 5FD0 01 98 08     	LD BC, #0898
 364+ 5FD3 C3 22 63     	JP BBYTECOPY_NO_C
 365+ 5FD6              .SETDESTROW:
 366+ 5FD6 2A 49 61     	LD HL, (TILETMP1)
 367+ 5FD9 F3           	DI
 368+ 5FDA CD 15 63     	CALL SETWRT_LOCAL
 369+ 5FDD FB           	EI
 370+ 5FDE C9           	RET
 371+ 5FDF              ; *******************************************************************************************************
 372+ 5FDF               ENDIF
 373+ 5FDF
 374+ 5FDF               IFNDEF CMDS_WITH_PARAMETERS
 375+ 5FDF ~            ; *******************************************************************************************************
 376+ 5FDF ~            ; function to handle CALL TILEVRM basic extension
 377+ 5FDF ~            ; fills vram with tiles
 378+ 5FDF ~            ; TILEVRM ( INT request_data_ptr )
 379+ 5FDF ~            ; request_data_ptr described in TILE
 380+ 5FDF ~            ; will put ram in page 0 also, page 1 is already there
 381+ 5FDF ~            TILEVRM:
 382+ 5FDF ~            	; opening (
 383+ 5FDF ~            	CALL CHKCHAR
 384+ 5FDF ~            	DB '('
 385+ 5FDF ~            	; get pointer to request struct
 386+ 5FDF ~            	LD IX, FRMQNT
 387+ 5FDF ~            	CALL CALBAS
 388+ 5FDF ~            	PUSH DE
 389+ 5FDF ~            	; ending )
 390+ 5FDF ~            	CALL CHKCHAR
 391+ 5FDF ~            	DB ')'
 392+ 5FDF ~
 393+ 5FDF ~            	POP IX ; pointer to request struct
 394+ 5FDF ~
 395+ 5FDF ~            	PUSH HL ; save position in BASIC buffer
 396+ 5FDF ~
 397+ 5FDF ~            	LD IY, .RET
 398+ 5FDF ~            	JP ENABLE_PAGE0
 399+ 5FDF ~            .RET:
 400+ 5FDF ~            	EI
 401+ 5FDF ~            	; set RAM functions to call
 402+ 5FDF ~            	LD HL, .TILECOPY
 403+ 5FDF ~            	LD (TILE.CALL2+1), HL
 404+ 5FDF ~            	LD HL, .SETDESTROW
 405+ 5FDF ~            	LD (TILE.CALL1+1), HL
 406+ 5FDF ~            	CALL TILE
 407+ 5FDF ~
 408+ 5FDF ~                POP DE
 409+ 5FDF ~                POP BC
 410+ 5FDF ~                CALL RESTORE_PAGE_INFO
 411+ 5FDF ~
 412+ 5FDF ~            	POP HL
 413+ 5FDF ~            	RET
 414+ 5FDF ~            .TILECOPY:
 415+ 5FDF ~            	LD BC, #0898
 416+ 5FDF ~            	JP BBYTECOPY_NO_C
 417+ 5FDF ~            .SETDESTROW:
 418+ 5FDF ~            	LD HL, (TILETMP1)
 419+ 5FDF ~            	DI
 420+ 5FDF ~            	CALL SETWRT_LOCAL
 421+ 5FDF ~            	EI
 422+ 5FDF ~            	RET
 423+ 5FDF ~            ; *******************************************************************************************************
 424+ 5FDF               ENDIF
# file closed: asm\TILE.asm
 153  5FDF               ENDIF
 154  5FDF
 155  5FDF               IF (BYTEOPS_CMDS == 1)
 156  5FDF ~             INCLUDE "BYTEOPS.asm"
 157  5FDF               ENDIF
 158  5FDF
 159  5FDF               IF (COLL_CMD == 1)
 160  5FDF               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5FDF              ; ************************************************************************************************
   2+ 5FDF              ; quick test if HL<=DE<=HL+BC
   3+ 5FDF              ; input BC=width, DE=x, HL=min
   4+ 5FDF              ; if not true flag C set
   5+ 5FDF              ; modifies AF
   6+ 5FDF              GENERIC_INNER_CHECK:
   7+ 5FDF E5               PUSH HL
   8+ 5FE0 D5               PUSH DE
   9+ 5FE1 EB               EX DE,HL
  10+ 5FE2 A7               AND A
  11+ 5FE3 ED 52            SBC HL, DE
  12+ 5FE5 FA F3 5F         JP M, .GENERIC_INNER_CHECK_NOT
  13+ 5FE8 A7               AND A
  14+ 5FE9 ED 42            SBC HL, BC
  15+ 5FEB 28 03            JR Z, .L2
  16+ 5FED F2 F3 5F         JP P, .GENERIC_INNER_CHECK_NOT
  17+ 5FF0              .L2:
  18+ 5FF0 A7               AND A
  19+ 5FF1 18 01            JR .EXIT
  20+ 5FF3              .GENERIC_INNER_CHECK_NOT:
  21+ 5FF3 37               SCF
  22+ 5FF4              .EXIT:
  23+ 5FF4 D1               POP DE
  24+ 5FF5 E1               POP HL
  25+ 5FF6 C9               RET
  26+ 5FF7              ; ************************************************************************************************
  27+ 5FF7
  28+ 5FF7              ; ************************************************************************************************
  29+ 5FF7              ; function to check if rectangles are overlapping
  30+ 5FF7              ; input IX=pointer to struct
  31+ 5FF7              ;  +00 active flag
  32+ 5FF7              ;  +02 x coordinate
  33+ 5FF7              ;  +04 y coordinate
  34+ 5FF7              ;  +06 x offset where rectangle begins
  35+ 5FF7              ;  +08 y offset where rectangle begins
  36+ 5FF7              ;  +10 width
  37+ 5FF7              ;  +12 height
  38+ 5FF7              ; input BLIT_STRUCT data
  39+ 5FF7              ;  +00 x coordinate
  40+ 5FF7              ;  +02 y coordinate
  41+ 5FF7              ;  +04 width
  42+ 5FF7              ;  +06 height
  43+ 5FF7              ; returns CF=1 if not overlapping, CF=0 if overlapping
  44+ 5FF7              RECTANGLE_OVERLAP_CHECK:
  45+ 5FF7                  ; first check which rectanlge is higher
  46+ 5FF7 DD 6E 0C         LD L,(IX+12)
  47+ 5FFA DD 66 0D         LD H,(IX+13)
  48+ 5FFD ED 5B 53 61      LD DE,(BLIT_STRUCT+6)
  49+ 6001 A7               AND A
  50+ 6002 ED 52            SBC HL,DE
  51+ 6004 DD 6E 04         LD L,(IX+4)
  52+ 6007 DD 66 05         LD H,(IX+5)
  53+ 600A DD 5E 08         LD E,(IX+8)
  54+ 600D DD 56 09         LD D,(IX+9)
  55+ 6010 FA 30 60         JP M,.L1
  56+ 6013                  ; equally high or IX defined one higher
  57+ 6013                  ; check upper boundary
  58+ 6013 19               ADD HL,DE
  59+ 6014 ED 5B 4F 61      LD DE,(BLIT_STRUCT+2)
  60+ 6018 DD 4E 0C         LD C,(IX+12)
  61+ 601B DD 46 0D         LD B,(IX+13)
  62+ 601E CD DF 5F         CALL GENERIC_INNER_CHECK
  63+ 6021 30 29            JR NC,.INSIDE
  64+ 6023                  ; check lower boundary
  65+ 6023 E5               PUSH HL
  66+ 6024 2A 53 61         LD HL,(BLIT_STRUCT+6)
  67+ 6027 19               ADD HL,DE
  68+ 6028 EB               EX DE,HL
  69+ 6029 E1               POP HL
  70+ 602A CD DF 5F         CALL GENERIC_INNER_CHECK
  71+ 602D 30 1D            JR NC,.INSIDE
  72+ 602F C9               RET ; not overlapping
  73+ 6030              .L1:
  74+ 6030                  ; rectangle defined in BLIT_STRUCT is higher
  75+ 6030 19               ADD HL,DE
  76+ 6031 EB               EX DE,HL
  77+ 6032 2A 4F 61         LD HL,(BLIT_STRUCT+2)
  78+ 6035 ED 4B 53 61      LD BC,(BLIT_STRUCT+6)
  79+ 6039 CD DF 5F         CALL GENERIC_INNER_CHECK
  80+ 603C 30 0E            JR NC,.INSIDE
  81+ 603E E5               PUSH HL
  82+ 603F DD 6E 0C         LD L,(IX+12)
  83+ 6042 DD 66 0D         LD H,(IX+13)
  84+ 6045 19               ADD HL,DE
  85+ 6046 EB               EX DE,HL
  86+ 6047 E1               POP HL
  87+ 6048 CD DF 5F         CALL GENERIC_INNER_CHECK
  88+ 604B D8               RET C
  89+ 604C              .INSIDE:
  90+ 604C                  ; check x coordinate
  91+ 604C                  ; first check which rectangle is wider
  92+ 604C DD 6E 0A         LD L,(IX+10)
  93+ 604F DD 66 0B         LD H,(IX+11)
  94+ 6052 ED 5B 51 61      LD DE,(BLIT_STRUCT+4)
  95+ 6056 A7               AND A
  96+ 6057 ED 52            SBC HL,DE
  97+ 6059 DD 6E 02         LD L,(IX+2)
  98+ 605C DD 66 03         LD H,(IX+3)
  99+ 605F DD 5E 06         LD E,(IX+6)
 100+ 6062 DD 56 07         LD D,(IX+7)
 101+ 6065 FA 81 60         JP M,.L2
 102+ 6068                  ; equally wide or IX defined one wider
 103+ 6068                  ; check left boundary
 104+ 6068 19               ADD HL,DE
 105+ 6069 ED 5B 4D 61      LD DE,(BLIT_STRUCT+0)
 106+ 606D DD 4E 0A         LD C,(IX+10)
 107+ 6070 DD 46 0B         LD B,(IX+11)
 108+ 6073 CD DF 5F         CALL GENERIC_INNER_CHECK
 109+ 6076 D0               RET NC ; overlap
 110+ 6077                  ; check right boundary
 111+ 6077 E5               PUSH HL
 112+ 6078 2A 51 61         LD HL,(BLIT_STRUCT+4)
 113+ 607B 19               ADD HL,DE
 114+ 607C EB               EX DE,HL
 115+ 607D E1               POP HL
 116+ 607E C3 DF 5F         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 117+ 6081              .L2:
 118+ 6081                  ; rectangle defined in BLIT_STRUCT is higher
 119+ 6081 19               ADD HL,DE
 120+ 6082 EB               EX DE,HL
 121+ 6083 2A 4D 61         LD HL,(BLIT_STRUCT+0)
 122+ 6086 ED 4B 51 61      LD BC,(BLIT_STRUCT+4)
 123+ 608A CD DF 5F         CALL GENERIC_INNER_CHECK
 124+ 608D D0               RET NC ; overlap
 125+ 608E E5               PUSH HL
 126+ 608F DD 6E 0A         LD L,(IX+10)
 127+ 6092 DD 66 0B         LD H,(IX+11)
 128+ 6095 19               ADD HL,DE
 129+ 6096 EB               EX DE,HL
 130+ 6097 E1               POP HL
 131+ 6098 C3 DF 5F         JP GENERIC_INNER_CHECK
 132+ 609B              ; ************************************************************************************************
 133+ 609B
 134+ 609B              ; ************************************************************************************************
 135+ 609B              ; function tries to find rectangle overlap and returns an index if found
 136+ 609B              ; input BLIT_STRUCT data
 137+ 609B              ;  +00 x coordinate
 138+ 609B              ;  +02 y coordinate
 139+ 609B              ;  +04 width
 140+ 609B              ;  +06 height
 141+ 609B              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 142+ 609B              ;  +09 pointer to first element
 143+ 609B              ;  +11 pointer to INT result variable
 144+ 609B              ; returns CF=1 if not overlapping
 145+ 609B              ; returns A=list index and CF=0 if overlapping
 146+ 609B              FIND_OVERLAP:
 147+ 609B 3A 55 61         LD A,(BLIT_STRUCT+8)
 148+ 609E 47               LD B,A
 149+ 609F DD 2A 56 61      LD IX,(BLIT_STRUCT+9)
 150+ 60A3              .L1:
 151+ 60A3 C5               PUSH BC
 152+ 60A4 DD 7E 00         LD A,(IX)
 153+ 60A7 DD B6 01         OR (IX+1)
 154+ 60AA 28 0C            JR Z,.NEXT
 155+ 60AC CD F7 5F         CALL RECTANGLE_OVERLAP_CHECK
 156+ 60AF 38 07            JR C,.NEXT
 157+ 60B1                  ; found
 158+ 60B1 C1               POP BC
 159+ 60B2 3A 55 61         LD A,(BLIT_STRUCT+8)
 160+ 60B5 90               SUB B
 161+ 60B6 A7               AND A
 162+ 60B7 C9               RET
 163+ 60B8              .NEXT:
 164+ 60B8 11 0E 00         LD DE,14
 165+ 60BB DD 19            ADD IX,DE
 166+ 60BD C1               POP BC
 167+ 60BE 10 E3            DJNZ .L1
 168+ 60C0 37               SCF
 169+ 60C1 C9               RET
 170+ 60C2              ; ************************************************************************************************
 171+ 60C2
 172+ 60C2              ; ************************************************************************************************
 173+ 60C2              ; function to handle CALL COLL basic extension
 174+ 60C2              ; checks for collision between player and other rectangles
 175+ 60C2              ; COLL ( INT result variable,
 176+ 60C2              ;	     INT player x value,
 177+ 60C2              ;	     INT player y value,
 178+ 60C2              ;	     INT player width,
 179+ 60C2              ;	     INT player height,
 180+ 60C2              ;	     INT number of items in a list,
 181+ 60C2              ;		 INT[6][n] rectangle struct )
 182+ 60C2              ; will fill result variable with index or -1 if no collision
 183+ 60C2              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 184+ 60C2              COLL:
 185+ 60C2              	; opening (
 186+ 60C2 CD 3C 64     	CALL CHKCHAR
 187+ 60C5 28           	DB '('
 188+ 60C6              	; get address of result variable
 189+ 60C6 DD 21 A4 5E  	LD IX, PTRGET
 190+ 60CA CD 59 01     	CALL CALBAS
 191+ 60CD ED 53 58 61  	LD (BLIT_STRUCT+11),DE
 192+ 60D1              	; comma
 193+ 60D1 CD 3C 64     	CALL CHKCHAR
 194+ 60D4 2C           	DB ','
 195+ 60D5              	; get x
 196+ 60D5 DD 21 2F 54  	LD IX, FRMQNT
 197+ 60D9 CD 59 01     	CALL CALBAS
 198+ 60DC ED 53 4D 61  	LD (BLIT_STRUCT+0),DE
 199+ 60E0              	; comma
 200+ 60E0 CD 3C 64     	CALL CHKCHAR
 201+ 60E3 2C           	DB ','
 202+ 60E4              	; get y
 203+ 60E4 DD 21 2F 54  	LD IX, FRMQNT
 204+ 60E8 CD 59 01     	CALL CALBAS
 205+ 60EB ED 53 4F 61  	LD (BLIT_STRUCT+2),DE
 206+ 60EF              	; comma
 207+ 60EF CD 3C 64     	CALL CHKCHAR
 208+ 60F2 2C           	DB ','
 209+ 60F3              	; get width
 210+ 60F3 DD 21 2F 54  	LD IX, FRMQNT
 211+ 60F7 CD 59 01     	CALL CALBAS
 212+ 60FA ED 53 51 61  	LD (BLIT_STRUCT+4),DE
 213+ 60FE              	; comma
 214+ 60FE CD 3C 64     	CALL CHKCHAR
 215+ 6101 2C           	DB ','
 216+ 6102              	; get height
 217+ 6102 DD 21 2F 54  	LD IX, FRMQNT
 218+ 6106 CD 59 01     	CALL CALBAS
 219+ 6109 ED 53 53 61  	LD (BLIT_STRUCT+6),DE
 220+ 610D              	; comma
 221+ 610D CD 3C 64     	CALL CHKCHAR
 222+ 6110 2C           	DB ','
 223+ 6111              	; get number of items in a list
 224+ 6111 DD 21 1C 52  	LD IX, GETBYT
 225+ 6115 CD 59 01     	CALL CALBAS
 226+ 6118 32 55 61     	LD (BLIT_STRUCT+8),A
 227+ 611B              	; comma
 228+ 611B CD 3C 64     	CALL CHKCHAR
 229+ 611E 2C           	DB ','
 230+ 611F              	; get address of rectangle structure array DIM R%(6,n)
 231+ 611F 3A 55 61     	LD A,(BLIT_STRUCT+8)
 232+ 6122 5F               LD E,A
 233+ 6123 3E 02            LD A,2
 234+ 6125 47           	LD B,A
 235+ 6126 16 07        	LD D,7
 236+ 6128 CD 69 64     	CALL GET_BASIC_ARRAY_DATA_POINTER
 237+ 612B ED 43 56 61  	LD (BLIT_STRUCT+9),BC
 238+ 612F              	; ending )
 239+ 612F CD 3C 64     	CALL CHKCHAR
 240+ 6132 29           	DB ')'
 241+ 6133
 242+ 6133 E5               PUSH HL
 243+ 6134 CD 9B 60         CALL FIND_OVERLAP
 244+ 6137 2A 58 61         LD HL,(BLIT_STRUCT+11)
 245+ 613A 38 06            JR C,.NOTFOUND
 246+ 613C 77               LD (HL),A
 247+ 613D 23               INC HL
 248+ 613E 36 00            LD (HL),0
 249+ 6140 E1               POP HL
 250+ 6141 C9               RET
 251+ 6142              .NOTFOUND:
 252+ 6142 36 FF            LD (HL),#FF
 253+ 6144 23               INC HL
 254+ 6145 36 FF            LD (HL),#FF
 255+ 6147 E1               POP HL
 256+ 6148 C9               RET
 257+ 6149              ; ************************************************************************************************
 258+ 6149
# file closed: asm\COLLISION.asm
 161  6149               ENDIF
 162  6149
 163  6149              ; temp variables for BLIT, TILE functions
 164  6149               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 165  6149              BLIT_TMP:
 166  6149              TILETMP1:
 167  6149              BLIT_TMP1:
 168  6149 00 00         DW 0
 169  614B              TILETMP2:
 170  614B              BLIT_TMP2:
 171  614B 00 00         DW 0
 172  614D                IFDEF CMDS_WITH_PARAMETERS
 173  614D              BLIT_STRUCT:
 174  614D 00 00 00...   DS 17
 175  6151                ENDIF
 176  6151               ENDIF
 177  615E
 178  615E               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 179  615E              VRAM_UPDATE_IN_PROGRESS:
 180  615E 00            DB 0
 181  615F               ENDIF
 182  615F
 183  615F              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 184  615F              ; per starting letter, if no commands with this letter, NULL value
 185  615F              CMDS:
 186  615F               IF (ANIM_CMDS == 1)
 187  615F 9E 62        	DW CMDS_A ;
 188  6161               ELSE
 189  6161 ~                DW 0 ; A
 190  6161               ENDIF
 191  6161               IF (BLIT_CMDS + BOX_CMDS > 0)
 192  6161 69 62            DW CMDS_B ; B
 193  6163               ELSE
 194  6163 ~            	DW 0
 195  6163               ENDIF
 196  6163               IF (COLL_CMD == 1)
 197  6163 0D 63        	DW CMDS_C ;
 198  6165               ELSE
 199  6165 ~                DW 0 ; C
 200  6165               ENDIF
 201  6165 00 00            DW 0 ; D
 202  6167 00 00            DW 0 ; E
 203  6169               IF (VRAM_CMDS + RAM_CMDS > 0)
 204  6169 E0 61            DW CMDS_F; F
 205  616B               ELSE
 206  616B ~            	DW 0
 207  616B               ENDIF
 208  616B               IF (GENCAL_CMD > 0)
 209  616B F3 61            DW CMDS_G; G
 210  616D               ELSE
 211  616D ~            	DW 0
 212  616D               ENDIF
 213  616D               IF (BYTEOPS_CMDS == 1)
 214  616D ~                DW CMDS_H; H
 215  616D               ELSE
 216  616D 00 00            DW 0
 217  616F               ENDIF
 218  616F 00 00            DW 0 ; I
 219  6171 00 00            DW 0 ; J
 220  6173 00 00            DW 0 ; K
 221  6175               IF (BYTEOPS_CMDS == 1)
 222  6175 ~                DW CMDS_L; L
 223  6175               ELSE
 224  6175 00 00            DW 0
 225  6177               ENDIF
 226  6177               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 227  6177 93 61            DW CMDS_M ; M
 228  6179               ELSE
 229  6179 ~            	DW 0
 230  6179               ENDIF
 231  6179 00 00            DW 0 ; N
 232  617B 00 00            DW 0 ; O
 233  617D 00 00            DW 0 ; P
 234  617F 00 00            DW 0 ; Q
 235  6181               IF (BYTEOPS_CMDS == 1)
 236  6181 ~                DW CMDS_R; R
 237  6181               ELSE
 238  6181 00 00            DW 0
 239  6183               ENDIF
 240  6183               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 241  6183 07 62            DW CMDS_S ; S
 242  6185               ELSE
 243  6185 ~            	DW 0
 244  6185               ENDIF
 245  6185               IF (TILE_CMDS > 0)
 246  6185 89 62            DW CMDS_T ; T
 247  6187               ELSE
 248  6187 ~            	DW 0
 249  6187               ENDIF
 250  6187 00 00            DW 0 ; U
 251  6189               IF (VRAM_CMDS > 0)
 252  6189 FD 61            DW CMDS_V ; V
 253  618B               ELSE
 254  618B ~            	DW 0
 255  618B               ENDIF
 256  618B               IF (BYTEOPS_CMDS == 1)
 257  618B ~                DW CMDS_W; W
 258  618B               ELSE
 259  618B 00 00            DW 0
 260  618D               ENDIF
 261  618D 00 00            DW 0 ; X
 262  618F 00 00            DW 0 ; Y
 263  6191 00 00            DW 0 ; Z
 264  6193
 265  6193              CMDS_M:
 266  6193               IF (VRAM_CMDS == 1)
 267  6193 4D 45 4D 56      DB "MEMVRM", 0
 267  6197 52 4D 00
 268  619A 24 59            DW MEMVRM
 269  619C               ENDIF
 270  619C               IF (RAM_CMDS == 1)
 271  619C 4D 45 4D 43  	DB "MEMCPY", 0
 271  61A0 50 59 00
 272  61A3 5A 57        	DW MEMCPY
 273  61A5               ENDIF
 274  61A5               IF (ANIM_CMDS == 1)
 275  61A5 4D 41 58 41  	DB "MAXANIMITEMS",0
 275  61A9 4E 49 4D 49
 275  61AD 54 45 4D 53
 275  61B1 00
 276  61B2 1A 50        	DW MAXANIMITEMS
 277  61B4 4D 41 58 41  	DB "MAXANIMDEFS",0
 277  61B8 4E 49 4D 44
 277  61BC 45 46 53 00
 278  61C0 9F 51        	DW MAXANIMDEFS
 279  61C2 4D 41 58 41  	DB "MAXANIMSPRS",0
 279  61C6 4E 49 4D 53
 279  61CA 50 52 53 00
 280  61CE 34 52        	DW MAXANIMSPRS
 281  61D0 4D 41 58 41     DB "MAXAUTOSGAMS",0
 281  61D4 55 54 4F 53
 281  61D8 47 41 4D 53
 281  61DC 00
 282  61DD 7B 53           DW MAXAUTOSGAMS
 283  61DF               ENDIF
 284  61DF               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 285  61DF 00           	DB 0
 286  61E0               ENDIF
 287  61E0              CMDS_F:
 288  61E0               IF (VRAM_CMDS == 1)
 289  61E0 46 49 4C 56      DB "FILVRM", 0
 289  61E4 52 4D 00
 290  61E7 D4 58            DW FILVRM
 291  61E9               ENDIF
 292  61E9               IF (RAM_CMDS == 1)
 293  61E9 46 49 4C 52      DB "FILRAM", 0
 293  61ED 41 4D 00
 294  61F0 9D 57            DW FILRAM
 295  61F2               ENDIF
 296  61F2               IF (VRAM_CMDS + RAM_CMDS > 0)
 297  61F2 00               DB 0
 298  61F3               ENDIF
 299  61F3              CMDS_G:
 300  61F3               IF (GENCAL_CMD == 1)
 301  61F3 47 45 4E 43      DB "GENCAL", 0
 301  61F7 41 4C 00
 302  61FA 08 5A            DW GENCAL
 303  61FC               ENDIF
 304  61FC               IF (GENCAL_CMD > 0)
 305  61FC 00           	DB	0
 306  61FD               ENDIF
 307  61FD              CMDS_V:
 308  61FD               IF (VRAM_CMDS == 1)
 309  61FD 56 52 4D 4D  	DB "VRMMEM", 0
 309  6201 45 4D 00
 310  6204 A3 59        	DW VRMMEM
 311  6206               ENDIF
 312  6206               IF (VRAM_CMDS > 0)
 313  6206 00           	DB 0
 314  6207               ENDIF
 315  6207              CMDS_S:
 316  6207               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 317  6207 53 47 41 4D      DB "SGAM",0
 317  620B 00
 318  620C B6 56            DW SGAM
 319  620E               ENDIF
 320  620E               IF (SPRITE_CMDS == 1)
 321  620E 53 50 52 53   	DB "SPRSET", 0
 321  6212 45 54 00
 322  6215 99 4E        	DW SPRSET
 323  6217 53 50 52 47  	DB "SPRGRPMOV", 0
 323  621B 52 50 4D 4F
 323  621F 56 00
 324  6221 4A 4F        	DW SPRGRPMOV
 325  6223               ENDIF
 326  6223               IF (SOUND_CMDS == 1)
 327  6223 53 4E 44 53  	DB "SNDSFX", 0
 327  6227 46 58 00
 328  622A 7A 58        	DW SNDSFX
 329  622C 53 4E 44 50  	DB "SNDPLYON", 0
 329  6230 4C 59 4F 4E
 329  6234 00
 330  6235 44 58        	DW SNDPLYON
 331  6237 53 4E 44 50  	DB "SNDPLYOFF", 0
 331  623B 4C 59 4F 46
 331  623F 46 00
 332  6241 57 58        	DW SNDPLYOFF
 333  6243 53 4E 44 50  	DB "SNDPLYINI", 0
 333  6247 4C 59 49 4E
 333  624B 49 00
 334  624D FA 57        	DW SNDPLYINIT
 335  624F               ENDIF
 336  624F               IF (SPRITE_CMDS == 1)
 337  624F 53 50 52 45  	DB "SPRENABLE", 0
 337  6253 4E 41 42 4C
 337  6257 45 00
 338  6259 54 4E        	DW SPRENABLE
 339  625B 53 50 52 44  	DB "SPRDISABLE", 0
 339  625F 49 53 41 42
 339  6263 4C 45 00
 340  6266 94 4E        	DW SPRDISABLE
 341  6268               ENDIF
 342  6268               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 343  6268 00           	DB 0
 344  6269               ENDIF
 345  6269              CMDS_B:
 346  6269               IF (BLIT_CMDS == 1)
 347  6269 42 4C 49 54  	DB "BLIT", 0
 347  626D 00
 348  626E DA 5C        	DW BLIT
 349  6270               ENDIF
 350  6270               IF (BOX_CMDS == 1)
 351  6270 42 4F 58 4D  	DB "BOXMEMCPY", 0
 351  6274 45 4D 43 50
 351  6278 59 00
 352  627A 97 5A        	DW BOXMEMCPY
 353  627C 42 4F 58 4D  	DB "BOXMEMVRM", 0
 353  6280 45 4D 56 52
 353  6284 4D 00
 354  6286 2C 5B        	DW BOXMEMVRM
 355  6288               ENDIF
 356  6288               IF (BLIT_CMDS + BOX_CMDS > 0)
 357  6288 00           	DB 0
 358  6289               ENDIF
 359  6289              CMDS_T:
 360  6289               IF (TILE_CMDS == 1)
 361  6289 54 49 4C 45  	DB "TILERAM", 0
 361  628D 52 41 4D 00
 362  6291 1E 5E        	DW TILERAM
 363  6293 54 49 4C 45  	DB "TILEVRM", 0
 363  6297 56 52 4D 00
 364  629B 21 5F        	DW TILEVRM
 365  629D               ENDIF
 366  629D               IF (TILE_CMDS > 0)
 367  629D 00           	DB 0
 368  629E               ENDIF
 369  629E              CMDS_A:
 370  629E               IF (ANIM_CMDS == 1)
 371  629E 41 4E 49 4D     DB "ANIMSTEP",0
 371  62A2 53 54 45 50
 371  62A6 00
 372  62A7 0C 55           DW ANIMSTEP
 373  62A9 41 4E 49 4D  	DB "ANIMSTART",0
 373  62AD 53 54 41 52
 373  62B1 54 00
 374  62B3 11 55        	DW ANIMSTART
 375  62B5 41 4E 49 4D  	DB "ANIMSTOP",0
 375  62B9 53 54 4F 50
 375  62BD 00
 376  62BE 16 55        	DW ANIMSTOP
 377  62C0 41 4E 49 4D  	DB "ANIMITEMPAT",0
 377  62C4 49 54 45 4D
 377  62C8 50 41 54 00
 378  62CC EA 50        	DW ANIMITEMPAT
 379  62CE 41 4E 49 4D  	DB "ANIMITEMPTR",0
 379  62D2 49 54 45 4D
 379  62D6 50 54 52 00
 380  62DA 4B 51        	DW ANIMITEMPTR_CMD
 381  62DC 41 4E 49 4D  	DB "ANIMDEF",0
 381  62E0 44 45 46 00
 382  62E4 E1 51        	DW ANIMDEF
 383  62E6 41 4E 49 4D  	DB "ANIMSPRITE",0
 383  62EA 53 50 52 49
 383  62EE 54 45 00
 384  62F1 8A 52        	DW ANIMSPRITE
 385  62F3 41 4E 49 4D     DB "ANIMCHAR",0
 385  62F7 43 48 41 52
 385  62FB 00
 386  62FC 02 53           DW ANIMCHAR
 387  62FE 41 55 54 4F     DB "AUTOSGAMDEF",0
 387  6302 53 47 41 4D
 387  6306 44 45 46 00
 388  630A D5 53           DW AUTOSGAMDEF
 389  630C 00           	DB 0
 390  630D               ENDIF
 391  630D              CMDS_H:
 392  630D               IF (BYTEOPS_CMDS == 1)
 393  630D ~                DB "HI", 0
 394  630D ~                DW HI
 395  630D               ENDIF
 396  630D               IF (BYTEOPS_CMDS > 0)
 397  630D ~            	DB	0
 398  630D               ENDIF
 399  630D              CMDS_L:
 400  630D               IF (BYTEOPS_CMDS == 1)
 401  630D ~                DB "LO", 0
 402  630D ~                DW LO
 403  630D               ENDIF
 404  630D               IF (BYTEOPS_CMDS > 0)
 405  630D ~            	DB	0
 406  630D               ENDIF
 407  630D              CMDS_W:
 408  630D               IF (BYTEOPS_CMDS == 1)
 409  630D ~                DB "W", 0
 410  630D ~                DW WORD
 411  630D               ENDIF
 412  630D               IF (BYTEOPS_CMDS > 0)
 413  630D ~            	DB	0
 414  630D               ENDIF
 415  630D              CMDS_R:
 416  630D               IF (BYTEOPS_CMDS == 1)
 417  630D ~                DB "RANGE", 0
 418  630D ~                DW RANGE
 419  630D               ENDIF
 420  630D               IF (BYTEOPS_CMDS > 0)
 421  630D ~            	DB	0
 422  630D               ENDIF
 423  630D              CMDS_C:
 424  630D               IF (COLL_CMD == 1)
 425  630D 43 4F 4C 4C      DB "COLL", 0
 425  6311 00
 426  6312 C2 60            DW COLL
 427  6314               ENDIF
 428  6314               IF (COLL_CMD > 0)
 429  6314 00           	DB	0
 430  6315               ENDIF
 431  6315
 432  6315               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 433  6315              ; ****************************************************************************************************
 434  6315              ; function sets VRAM address
 435  6315              ; input HL=address
 436  6315              ; modifies AF
 437  6315              SETWRT_LOCAL:
 438  6315 7D           	LD	A, L
 439  6316 D3 99        	OUT	(099H), A
 440  6318 7C           	LD	A, H
 441  6319 E6 3F        	AND	03FH
 442  631B F6 40        	OR	040H
 443  631D D3 99        	OUT	(099H), A
 444  631F C9           	RET
 445  6320              ; ****************************************************************************************************
 446  6320               ENDIF
 447  6320
 448  6320               IF (VRAM_CMDS + TILE_CMDS > 0)
 449  6320              ; ****************************************************************************************************
 450  6320              ; function copies data from RAM to VRAM
 451  6320              ; input HL=address in RAM
 452  6320              ; input B=count
 453  6320              ; modifies AF, BC, HL
 454  6320              BBYTECOPY:
 455  6320 0E 98        	LD C,#98
 456  6322              BBYTECOPY_NO_C:
 457  6322 ED A3        	OUTI
 458  6324 C2 22 63     	JP	NZ, BBYTECOPY_NO_C
 459  6327 C9           	RET
 460  6328              ; ****************************************************************************************************
 461  6328               ENDIF
 462  6328
 463  6328              ; ****************************************************************************************************
 464  6328              ; function multiplies HL by 32
 465  6328              HLx32:
 466  6328 29           	ADD HL,HL
 467  6329              ; ****************************************************************************************************
 468  6329              ; function multiplies HL by 16
 469  6329              HLx16:
 470  6329 29           	ADD HL,HL
 471  632A              ; ****************************************************************************************************
 472  632A              ; function multiplies HL by 8
 473  632A              HLx8:
 474  632A 29          > ADD HL, HL
 474  632B 29          > ADD HL, HL
 474  632C 29          > ADD HL, HL
 475  632D C9           	RET
 476  632E              ; ****************************************************************************************************
 477  632E
 478  632E              ; ****************************************************************************************************
 479  632E              ; function gets slot and subslot data for specific page
 480  632E              ; input A=page (0, 1 or 2)
 481  632E              ; output B = 0A8H register value
 482  632E              ; output D = 0 is no subslots, 1 if yes
 483  632E              ; output C = 0A8H value when page 3 slot equals to requested page slot
 484  632E              ; output E = subslot value if present
 485  632E              ; modifies AF, BC, DE, HL
 486  632E              GET_PAGE_INFO:
 487  632E 6F               LD L, A
 488  632F C6 C1            ADD A, low (EXPTBL)
 489  6331 32 3B 63         LD (GET_PAGE_INFO_L1+1), A
 490  6334 DB A8            IN A, (0A8H)
 491  6336 47               LD B, A
 492  6337 E6 3F            AND 03FH
 493  6339 4F               LD C, A
 494  633A              GET_PAGE_INFO_L1:
 495  633A 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 496  633D E6 80            AND 080H
 497  633F 28 1B            JR Z, GET_PAGE_INFO_L2
 498  6341                  ; expanded
 499  6341 2D               DEC L
 500  6342 FA 61 63         JP M, GET_PAGE_INFO_L3
 501  6345 2D               DEC L
 502  6346 FA 5F 63         JP M, GET_PAGE_INFO_L4
 503  6349                  ; page 2
 504  6349 07               RLCA
 505  634A 07               RLCA
 506  634B              GET_PAGE_INFO_L5:
 507  634B E6 C0            AND 0C0H
 508  634D B1               OR C
 509  634E D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 510  6350 4F               LD C, A
 511  6351 3A FF FF         LD A, (0FFFFH)
 512  6354 2F               CPL
 513  6355 5F               LD E, A
 514  6356 16 01            LD D, 1
 515  6358 78               LD A, B ; return stack
 516  6359 D3 A8            OUT (0A8H), A
 517  635B C9               RET
 518  635C              GET_PAGE_INFO_L2:
 519  635C                  ; not expanded
 520  635C 16 00            LD D, 0
 521  635E C9               RET
 522  635F              GET_PAGE_INFO_L4:
 523  635F                  ; page 1
 524  635F 0F               RRCA
 525  6360 0F               RRCA
 526  6361              GET_PAGE_INFO_L3:
 527  6361                  ; page 0
 528  6361 0F               RRCA
 529  6362 0F               RRCA
 530  6363 18 E6            JR GET_PAGE_INFO_L5
 531  6365              ; ****************************************************************************************************
 532  6365
 533  6365              ; ****************************************************************************************************
 534  6365              ; function returns original slot and subslot info
 535  6365              ; input B = 0A8H register value
 536  6365              ; input D = 0 is no subslots, 1 if yes
 537  6365              ; input C = 0A8H value when page 3 slot equals to requested page slot
 538  6365              ; input E = subslot value if present
 539  6365              ; modifies AF, disables interrupts
 540  6365              RESTORE_PAGE_INFO:
 541  6365 7A              LD A, D
 542  6366 B7              OR A
 543  6367 28 08           JR Z, RESTORE_PAGE_INFO_L1
 544  6369 79              LD A, C
 545  636A F3           	DI
 546  636B D3 A8           OUT (0A8H), A
 547  636D 7B              LD A, E
 548  636E 32 FF FF        LD (0FFFFH), A
 549  6371              RESTORE_PAGE_INFO_L1:
 550  6371 78              LD A, B
 551  6372 D3 A8           OUT (0A8H), A
 552  6374 C9              RET
 553  6375              ; ****************************************************************************************************
 554  6375
 555  6375              ; *******************************************************************************************************
 556  6375              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 557  6375              ; INPUT:  A = SLOT ID: EXXXSSPP
 558  6375              ; E = EXPANDED FLAG
 559  6375              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 560  6375              ; PP = PRIMARY SLOT NUMBER
 561  6375              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 562  6375              ; CHANGES: AF, BC, DE
 563  6375
 564  6375              LOCAL_ENASLT:
 565  6375 CD 95 63         CALL L0353
 566  6378 FA 82 63         JP M, L0340
 567  637B DB A8            IN A, (0A8H)
 568  637D A1               AND C
 569  637E B0               OR B
 570  637F D3 A8            OUT (0A8H), A
 571  6381 C9               RET
 572  6382              L0340:
 573  6382 E5               PUSH HL
 574  6383 CD BA 63         CALL L0378
 575  6386 4F               LD C, A
 576  6387 06 00            LD B, 0
 577  6389 7D               LD A, L
 578  638A A4               AND H
 579  638B B2               OR D
 580  638C 21 C5 FC         LD HL, 0FCC5H
 581  638F 09               ADD HL, BC
 582  6390 77               LD (HL), A
 583  6391 E1               POP HL
 584  6392 79               LD A, C
 585  6393 18 E0            JR LOCAL_ENASLT
 586  6395              L0353:
 587  6395 F3               DI
 588  6396 F5               PUSH AF
 589  6397 7C               LD A, H
 590  6398 07               RLCA
 591  6399 07               RLCA
 592  639A E6 03            AND 3
 593  639C 5F               LD E, A
 594  639D 3E C0            LD A, 0C0H
 595  639F              L035D:
 596  639F 07               RLCA
 597  63A0 07               RLCA
 598  63A1 1D               DEC E
 599  63A2 F2 9F 63         JP P, L035D
 600  63A5 5F               LD E, A
 601  63A6 2F               CPL
 602  63A7 4F               LD C, A
 603  63A8 F1               POP AF
 604  63A9 F5               PUSH AF
 605  63AA E6 03            AND 3
 606  63AC 3C               INC A
 607  63AD 47               LD B, A
 608  63AE 3E AB            LD A, 0ABH
 609  63B0              L036E:
 610  63B0 C6 55            ADD A, 055H
 611  63B2 10 FC            DJNZ L036E
 612  63B4 57               LD D, A
 613  63B5 A3               AND E
 614  63B6 47               LD B, A
 615  63B7 F1               POP AF
 616  63B8 A7               AND A
 617  63B9 C9               RET
 618  63BA              L0378:
 619  63BA F5               PUSH AF
 620  63BB 7A               LD A, D
 621  63BC E6 C0            AND 0C0H
 622  63BE 4F               LD C, A
 623  63BF F1               POP AF
 624  63C0 F5               PUSH AF
 625  63C1 57               LD D, A
 626  63C2 DB A8            IN A, (0A8H)
 627  63C4 47               LD B, A
 628  63C5 E6 3F            AND 03FH
 629  63C7 B1               OR C
 630  63C8 D3 A8            OUT (0A8H), A
 631  63CA 7A               LD A, D
 632  63CB 0F               RRCA
 633  63CC 0F               RRCA
 634  63CD E6 03            AND 3
 635  63CF 57               LD D, A
 636  63D0 3E AB            LD A, 0ABH
 637  63D2              L0390:
 638  63D2 C6 55            ADD A, 055H
 639  63D4 15               DEC D
 640  63D5 F2 D2 63         JP P, L0390
 641  63D8 A3               AND E
 642  63D9 57               LD D, A
 643  63DA 7B               LD A, E
 644  63DB 2F               CPL
 645  63DC 67               LD H, A
 646  63DD 3A FF FF         LD A, (0FFFFH)
 647  63E0 2F               CPL
 648  63E1 6F               LD L, A
 649  63E2 A4               AND H
 650  63E3 B2               OR D
 651  63E4 32 FF FF         LD (0FFFFH), A
 652  63E7 78               LD A, B
 653  63E8 D3 A8            OUT (0A8H), A
 654  63EA F1               POP AF
 655  63EB E6 03            AND 3
 656  63ED C9               RET
 657  63EE              ; *******************************************************************************************************
 658  63EE
 659  63EE              ; *******************************************************************************************************
 660  63EE              ; some common code to activate page 0 and place values needed to restore original page on stack
 661  63EE              ; input IY=return address
 662  63EE              ENABLE_PAGE0:
 663  63EE AF              XOR A
 664  63EF CD 2E 63        CALL GET_PAGE_INFO
 665  63F2 C5              PUSH BC
 666  63F3 D5              PUSH DE
 667  63F4 3A 41 F3        LD A, (RAMAD0)
 668  63F7 26 00           LD H, 0
 669  63F9 CD 75 63        CALL LOCAL_ENASLT
 670  63FC FD E9        	JP (IY)
 671  63FE              ; *******************************************************************************************************
 672  63FE
 673  63FE              ; General BASIC CALL-instruction handler
 674  63FE              CALLHAND:
 675  63FE FB              EI
 676  63FF E5           	PUSH HL
 677  6400 21 5F 61     	LD	HL, CMDS ; pointer table based on starting letter
 678  6403 3A 89 FD        LD A, (PROCNM)
 679  6406 D6 41           SUB 'A'
 680  6408 87              ADD A, A
 681  6409 16 00           LD D, 0
 682  640B 5F              LD E, A
 683  640C 19              ADD HL, DE
 684  640D 5E              LD E, (HL)
 685  640E 23              INC HL
 686  640F 56              LD D, (HL)
 687  6410 7A              LD A, D
 688  6411 B3              OR E
 689  6412 28 23           JR Z, .CMDNOTRECOGNIZED
 690  6414 EB              EX DE, HL
 691  6415              .CHKCMD:
 692  6415 11 89 FD     	LD	DE, PROCNM
 693  6418              .LOOP:
 694  6418 1A              LD	A,(DE)
 695  6419 BE           	CP	(HL)
 696  641A 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 697  641C 13           	INC	DE
 698  641D 23           	INC	HL
 699  641E A7           	AND	A
 700  641F 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 701  6421 5E           	LD	E,(HL)
 702  6422 23           	INC	HL
 703  6423 56           	LD	D,(HL)
 704  6424 E1           	POP	HL		; routine address
 705  6425 CD 46 64     	CALL	GETPREVCHAR
 706  6428 CD 3A 64     	CALL	.CALLDE		; Call routine
 707  642B A7           	AND	A
 708  642C C9           	RET
 709  642D
 710  642D              .TONEXTCMD:
 711  642D 0E FF        	LD	C,0FFH
 712  642F AF           	XOR	A
 713  6430 ED B1        	CPIR			; Skip to end of instruction name
 714  6432 23           	INC	HL
 715  6433 23           	INC	HL		; Skip address
 716  6434 BE           	CP	(HL)
 717  6435 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 718  6437              .CMDNOTRECOGNIZED:
 719  6437 E1           	POP	HL
 720  6438 37              SCF
 721  6439 C9           	RET
 722  643A
 723  643A              .CALLDE:
 724  643A D5           	PUSH	DE
 725  643B C9           	RET
 726  643C
 727  643C              ;---------------------------
 728  643C
 729  643C              ;GETSTRPNT:
 730  643C              ; OUT:
 731  643C              ; HL = String Address
 732  643C              ; B  = Lenght
 733  643C              ;        LD      HL,(USR)
 734  643C              ;        LD      B,(HL)
 735  643C              ;        INC     HL
 736  643C              ;        LD      E,(HL)
 737  643C              ;        INC     HL
 738  643C              ;        LD      D,(HL)
 739  643C              ;        EX      DE,HL
 740  643C              ;        RET
 741  643C
 742  643C              ;EVALTXTPARAM:
 743  643C              ;	CALL	CHKCHAR
 744  643C              ;	DEFB	"("             ; Check for (
 745  643C              ;	LD	IX,FRMEVL
 746  643C              ;	CALL	CALBAS		; Evaluate expression
 747  643C              ;       LD      A,(VALTYP)
 748  643C              ;        CP      3               ; Text type?
 749  643C              ;        JP      NZ,TYPE_MISMATCH
 750  643C              ;        PUSH	HL
 751  643C              ;        LD	IX,FRESTR         ; Free the temporary string
 752  643C              ;        CALL	CALBAS
 753  643C              ;        POP	HL
 754  643C              ;	CALL	CHKCHAR
 755  643C              ;	DEFB	")"             ; Check for )
 756  643C              ;        RET
 757  643C
 758  643C
 759  643C              CHKCHAR:
 760  643C CD 46 64     	CALL	GETPREVCHAR	; Get previous basic char
 761  643F E3           	EX	(SP),HL
 762  6440 BE           	CP	(HL) 	        ; Check if good char
 763  6441 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 764  6443 23           	INC	HL
 765  6444 E3           	EX	(SP),HL
 766  6445 23           	INC	HL		; Get next basic char
 767  6446
 768  6446              GETPREVCHAR:
 769  6446 2B           	DEC HL
 770  6447 DD 21 66 46  	LD	IX,CHRGTR
 771  644B CD 59 01     	CALL CALBAS
 772  644E FB              EI
 773  644F C9              RET
 774  6450
 775  6450
 776  6450              TYPE_MISMATCH:
 777  6450 1E 0D            LD E, 13 ; Type mismatch
 778  6452 18 0E            JR THROW_ERROR
 779  6454              SUBSCRIPT_OUT_OF_RANGE:
 780  6454 1E 09            LD E,9 ; subscript out of range
 781  6456 18 0A        	JR THROW_ERROR
 782  6458              OVERFLOW:
 783  6458 1E 06        	LD E,6
 784  645A 18 06        	JR THROW_ERROR
 785  645C              ILLEGAL_FUNCTION:
 786  645C 1E 05            LD E, 5 ; illegal function call
 787  645E 18 02            JR THROW_ERROR
 788  6460              SYNTAX_ERROR:
 789  6460 1E 02            LD E, 2 ; Syntax error
 790  6462              THROW_ERROR:
 791  6462 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 792  6466 C3 59 01     	JP	CALBAS
 793  6469
 794  6469              ;---------------------------
 795  6469
 796  6469              ; *******************************************************************************************************
 797  6469              ; helper function to get pointer to BASIC array data
 798  6469              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 799  6469              ; input B=dimensions (1 or 2)
 800  6469              ; input D=minimal first dimension
 801  6469              ; input E=minimal second dimension, if applicable
 802  6469              ; returns BC=pointer to first data element
 803  6469              ; throws BASIC error if invalid type
 804  6469              GET_BASIC_ARRAY_DATA_POINTER:
 805  6469 D5           	PUSH DE
 806  646A C5           	PUSH BC
 807  646B F5           	PUSH AF
 808  646C 3E 01           LD A,1
 809  646E 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 810  6471 DD 21 A4 5E  	LD IX, PTRGET
 811  6475 CD 59 01     	CALL CALBAS
 812  6478 AF              XOR A
 813  6479 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 814  647C 3A 63 F6     	LD A,(VALTYP)
 815  647F D1           	POP DE ; required type
 816  6480 BA           	CP D
 817  6481 C2 50 64     	JP NZ,TYPE_MISMATCH
 818  6484 0A           	LD A,(BC)
 819  6485 03           	INC BC
 820  6486 D1           	POP DE ; required number of dimensions
 821  6487 BA           	CP D
 822  6488 C2 50 64     	JP NZ,TYPE_MISMATCH
 823  648B D1           	POP DE ; required minimal array dimensions
 824  648C 3D           	DEC A
 825  648D 28 07        	JR Z,.ONE_DIMENSION
 826  648F              	; 2-dimension array
 827  648F 0A           	LD A,(BC)
 828  6490 03          > INC BC
 828  6491 03          > INC BC
 829  6492 BB           	CP E
 830  6493 DA 54 64     	JP C,SUBSCRIPT_OUT_OF_RANGE
 831  6496              .ONE_DIMENSION:
 832  6496 0A           	LD A,(BC)
 833  6497 03          > INC BC
 833  6498 03          > INC BC
 834  6499 BA           	CP D
 835  649A DA 54 64     	JP C,SUBSCRIPT_OUT_OF_RANGE
 836  649D C9           	RET
 837  649E              ; *******************************************************************************************************
 838  649E
 839  649E              EXT_END:
 840  649E
# file closed: asm\main.asm
