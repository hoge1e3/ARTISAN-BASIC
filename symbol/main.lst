# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000              JIFFY	EQU #FC9E
  51  4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
  52  4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
  53  4000              PATBAS  EQU #F926 ; current sprite generator table address
  54  4000
  55  4000              ; BASIC error codes
  56  4000              ;01 NEXT without FOR
  57  4000              ;02 Syntax error
  58  4000              ;03 RETURN without GOSUB
  59  4000              ;04 Out of DATA
  60  4000              ;05 Illegal function call
  61  4000              ;06 Overflow
  62  4000              ;07 Out of memory
  63  4000              ;08 Undefined line number
  64  4000              ;09 Subscript out of range
  65  4000              ;10 Redimensioned array
  66  4000              ;11 Division by zero
  67  4000              ;12 Illegal direct
  68  4000              ;13 Type mismatch
  69  4000              ;14 Out of string space
  70  4000              ;15 String too long
  71  4000              ;16 String formula too complex
  72  4000              ;17 Can't CONTINUE
  73  4000              ;18 Undefined user function
  74  4000              ;19 Device I/O error
  75  4000              ;20 Verify error
  76  4000              ;21 No RESUME
  77  4000              ;22 RESUME without error
  78  4000              ;23 Unprintable error
  79  4000              ;24 Missing operand
  80  4000              ;25 Line buffer overflow
  81  4000              ;50 FIELD overflow
  82  4000              ;51 Internal error
  83  4000              ;52 Bad file number
  84  4000              ;53 File not found
  85  4000              ;54 File already open
  86  4000              ;55 Input past end
  87  4000              ;56 Bad file name
  88  4000              ;57 Direct statement in file
  89  4000              ;58 Sequential I/O only
  90  4000              ;59 File not OPEN
  91  4000
  92  4000
  93  4000               ; simulate cartridge with BASIC extension
  94  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  94  4004 BC 56 00 00
  94  4008 00 00 00 00
  94  400C 00 00 00 00
  95  4010
  96  4010              ; this location #4010 stores last location used by basic extension
  97  4010              ; free memory after that point
  98  4010              FREEMEMPTR:
  99  4010 5F 5F         DW EXT_END
 100  4012
 101  4012              ; this location #4012 stores extension version in DAA format
 102  4012              ; first byte is major version and second minor
 103  4012              VERSION:
 104  4012 00 70         DB #00, #70
 105  4014
 106  4014              ; binary included AKG player compiled at #4014
 107  4014               IF (SOUND_CMDS == 1)
 108  4014              	INCBIN "bin/AKG.bin"
 109  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 110  4CF0               ENDIF
 111  4CF0
 112  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 27 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A 7C 4D     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13 2A 9E FC         LD HL,(JIFFY)
  43+ 4D16 23               INC HL
  44+ 4D17 22 9E FC         LD (JIFFY),HL
  45+ 4D1A
  46+ 4D1A FD E1            POP IY
  47+ 4D1C DD E1            POP IX
  48+ 4D1E E1               POP HL
  49+ 4D1F D1               POP DE
  50+ 4D20 C1               POP BC
  51+ 4D21 F1               POP AF
  52+ 4D22 08               EX AF, AF'
  53+ 4D23 D9               EXX
  54+ 4D24 E1               POP HL
  55+ 4D25 D1               POP DE
  56+ 4D26 C1               POP BC
  57+ 4D27               ENDIF
  58+ 4D27
  59+ 4D27              .EXIT:
  60+ 4D27 F1           	POP AF
  61+ 4D28 FB           	EI
  62+ 4D29 ED 4D        	RETI
  63+ 4D2B              ; *******************************************************************************************************
  64+ 4D2B
  65+ 4D2B              ; *******************************************************************************************************
  66+ 4D2B              ; H.TIMI function
  67+ 4D2B              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2B              MBGE_HTIMI:
  69+ 4D2B               EXPORT MBGE_HTIMI
  70+ 4D2B
  71+ 4D2B               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2B
  73+ 4D2B F5           	PUSH AF
  74+ 4D2C
  75+ 4D2C              	; enable page 2
  76+ 4D2C 3E 02            LD A, 2
  77+ 4D2E CD EC 55         CALL GET_PAGE_INFO
  78+ 4D31 C5               PUSH BC
  79+ 4D32 D5               PUSH DE
  80+ 4D33 3A 43 F3         LD A, (RAMAD2)
  81+ 4D36 26 80            LD H, 080H
  82+ 4D38 CD 33 56         CALL LOCAL_ENASLT
  83+ 4D3B              	; enable page 0
  84+ 4D3B AF               XOR A
  85+ 4D3C CD EC 55         CALL GET_PAGE_INFO
  86+ 4D3F C5               PUSH BC
  87+ 4D40 D5               PUSH DE
  88+ 4D41 3A 41 F3         LD A, (RAMAD0)
  89+ 4D44 26 00            LD H, 0
  90+ 4D46 CD 33 56         CALL LOCAL_ENASLT
  91+ 4D49
  92+ 4D49               IF (SPRITE_CMDS == 1)
  93+ 4D49 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4C               ENDIF
  95+ 4D4C
  96+ 4D4C               IF (SOUND_CMDS == 1)
  97+ 4D4C 3A 7C 4D     	LD A, (SOUND_ENABLED)
  98+ 4D4F B7           	OR A
  99+ 4D50 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D53               ENDIF
 101+ 4D53
 102+ 4D53              	; restore page 0
 103+ 4D53 D1               POP DE
 104+ 4D54 C1               POP BC
 105+ 4D55 CD 23 56         CALL RESTORE_PAGE_INFO
 106+ 4D58              	; restore page 2
 107+ 4D58 D1               POP DE
 108+ 4D59 C1               POP BC
 109+ 4D5A CD 23 56         CALL RESTORE_PAGE_INFO
 110+ 4D5D
 111+ 4D5D F1           	POP AF
 112+ 4D5E               ENDIF
 113+ 4D5E C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D61              ; *******************************************************************************************************
 115+ 4D61
 116+ 4D61              ; *******************************************************************************************************
 117+ 4D61              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D61              ; also checks if some VRAM modifying command is running
 119+ 4D61              ; when that checks out calls sprite updates and animation processing
 120+ 4D61              PROCESS_SPRITES_AND_ANIMATIONS:
 121+ 4D61              	; check if initialized
 122+ 4D61 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 123+ 4D64 B7           	OR A
 124+ 4D65 C8           	RET Z
 125+ 4D66              	; check screen mode
 126+ 4D66 3A AF FC     	LD A, (SCRMOD)
 127+ 4D69 3D           	DEC A
 128+ 4D6A 28 02        	JR Z, .L0 ; screen 1
 129+ 4D6C 3D           	DEC A
 130+ 4D6D C0           	RET NZ ; not screen 2
 131+ 4D6E              .L0:
 132+ 4D6E                  ; check if anyone else is working with VRAM
 133+ 4D6E 3A 60 54         LD A,(VRAM_UPDATE_IN_PROGRESS)
 134+ 4D71 B7               OR A
 135+ 4D72 C0               RET NZ
 136+ 4D73
 137+ 4D73 CD 92 4D         CALL SPRATR_UPDATE
 138+ 4D76
 139+ 4D76               IF (ANIM_CMDS == 1)
 140+ 4D76 CD 73 53         CALL PROCESS_ANIMATIONS
 141+ 4D79               ENDIF
 142+ 4D79 C9               RET
 143+ 4D7A              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 113  4D7A
 114  4D7A               IF (SOUND_CMDS == 1)
 115  4D7A              MUSIC_INIT_STATUS:
 116  4D7A 00            DB 0
 117  4D7B              SFX_INIT_STATUS:
 118  4D7B 00            DB 0
 119  4D7C              SOUND_ENABLED:
 120  4D7C 00            DB 0
 121  4D7D               ENDIF
 122  4D7D
 123  4D7D               IF (SPRITE_CMDS == 1)
 124  4D7D               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7D              ; commands and variables related to sprites
   2+ 4D7D
   3+ 4D7D              SPRATR_INIT_STATUS:
   4+ 4D7D 00            DB 0
   5+ 4D7E              SPRATR_UPDATE_FLAG:
   6+ 4D7E 00 00         DW 0
   7+ 4D80              SPRATR_DATA:
   8+ 4D80 00 00         DW 0
   9+ 4D82              SPRFLICKER_ENABLED:
  10+ 4D82 00            DB 0
  11+ 4D83              ; to support sprite flicker
  12+ 4D83              FLICKER:
  13+ 4D83 00            DB 0
  14+ 4D84
  15+ 4D84              ; to temporarily store stack pointer
  16+ 4D84              TMPSP:
  17+ 4D84 00 00         DW 0
  18+ 4D86
  19+ 4D86              ; *******************************************************************************************************
  20+ 4D86              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D86              ; changes HL,DE;
  22+ 4D86              GETnthSPRATTR:
  23+ 4D86 26 00            LD H,0
  24+ 4D88 6F               LD L,A
  25+ 4D89 CD E8 55         CALL HLx8
  26+ 4D8C ED 5B 80 4D      LD DE,(SPRATR_DATA)
  27+ 4D90 19               ADD HL,DE
  28+ 4D91 C9               RET
  29+ 4D92              ; *******************************************************************************************************
  30+ 4D92
  31+ 4D92              ; *******************************************************************************************************
  32+ 4D92              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D92              ; struct {
  34+ 4D92              ; DW y
  35+ 4D92              ; DW x
  36+ 4D92              ; DW pattern (0-63)
  37+ 4D92              ; DW color
  38+ 4D92              ; } [32]
  39+ 4D92              ; will hide sprites whose location is outside of visible area
  40+ 4D92              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D92              ; modifies AF, AF', BC, DE, HL
  42+ 4D92              SPRATR_UPDATE:
  43+ 4D92              	; check if update requested
  44+ 4D92 2A 7E 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D95 7E           	LD A, (HL)
  46+ 4D96 B7           	OR A
  47+ 4D97 C8           	RET Z
  48+ 4D98              .L0:
  49+ 4D98 06 20        	LD B, 32 ; sprite number
  50+ 4D9A 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D9C              	; set VDP address
  52+ 4D9C 2A 28 F9     	LD HL, (ATRBAS)
  53+ 4D9F 3A 82 4D     	LD A, (SPRFLICKER_ENABLED)
  54+ 4DA2 B7           	OR A
  55+ 4DA3 28 03        	JR Z, .L3
  56+ 4DA5 3A 83 4D     	LD A, (FLICKER)
  57+ 4DA8              .L3:
  58+ 4DA8 5F           	LD E, A
  59+ 4DA9 08           	EX AF, AF'
  60+ 4DAA 7B           	LD A, E
  61+ 4DAB 87           	ADD A, A
  62+ 4DAC 87           	ADD A, A
  63+ 4DAD 16 00        	LD D, 0
  64+ 4DAF 5F           	LD E, A
  65+ 4DB0 19           	ADD HL, DE
  66+ 4DB1 CD D5 55     	CALL SETWRT_LOCAL
  67+ 4DB4 ED 73 84 4D  	LD (TMPSP), SP
  68+ 4DB8 ED 7B 80 4D  	LD SP, (SPRATR_DATA)
  69+ 4DBC
  70+ 4DBC              .LOOP:
  71+ 4DBC E1           	POP HL
  72+ 4DBD 24           	INC H
  73+ 4DBE 28 0D        	JR Z, .L1 ; negative number above -256
  74+ 4DC0 25           	DEC H
  75+ 4DC1 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  76+ 4DC3 7D           	LD A, L
  77+ 4DC4 FE C0        	CP 192
  78+ 4DC6 30 10        	JR NC, .OUT3
  79+ 4DC8 3D           	DEC A ; due to VDP rule that top of screen is -1
  80+ 4DC9 57           	LD D, A
  81+ 4DCA C3 F1 4D     	JP .X
  82+ 4DCD              .L1:
  83+ 4DCD 7D           	LD A, L
  84+ 4DCE C6 10        	ADD 16
  85+ 4DD0 FA D8 4D     	JP M, .OUT3 ; below -16
  86+ 4DD3 2D           	DEC L ; due to VDP rule that top of screen is -1
  87+ 4DD4 55           	LD D, L
  88+ 4DD5 C3 F1 4D     	JP .X
  89+ 4DD8              .OUT3:
  90+ 4DD8 E1           	POP HL ; skip x value
  91+ 4DD9              .OUT2:
  92+ 4DD9 E1           	POP HL ; skip pattern
  93+ 4DDA E1           	POP HL ; skip color
  94+ 4DDB 3E D1        	LD A, #D1
  95+ 4DDD ED 79        	OUT (C), A ; sprite hidden
  96+ 4DDF 00          > NOP
  96+ 4DE0 00          > NOP
  96+ 4DE1 00          > NOP
  97+ 4DE2 ED 79        	OUT (C), A ; value unimportant
  98+ 4DE4 00          > NOP
  98+ 4DE5 00          > NOP
  98+ 4DE6 00          > NOP
  99+ 4DE7 ED 79        	OUT (C), A ; value unimportant
 100+ 4DE9 00          > NOP
 100+ 4DEA 00          > NOP
 100+ 4DEB 00          > NOP
 101+ 4DEC ED 79        	OUT (C), A ; value unimportant
 102+ 4DEE C3 1C 4E     	JP .NEXT
 103+ 4DF1              .X:
 104+ 4DF1 E1           	POP HL
 105+ 4DF2 24           	INC H
 106+ 4DF3 28 08        	JR Z, .L2
 107+ 4DF5 25           	DEC H
 108+ 4DF6 20 E1        	JR NZ, .OUT2
 109+ 4DF8 1E 00        	LD E, 0 ; EC bit
 110+ 4DFA C3 06 4E     	JP .XY
 111+ 4DFD              .L2:
 112+ 4DFD 7D           	LD A, L
 113+ 4DFE C6 20        	ADD 32
 114+ 4E00 FA D9 4D     	JP M, .OUT2
 115+ 4E03 6F           	LD L, A
 116+ 4E04 1E 80        	LD E, #80
 117+ 4E06              .XY:
 118+ 4E06 ED 51        	OUT (C), D
 119+ 4E08 3A E0 F3     	LD A, (REG1SAV)
 120+ 4E0B E6 02        	AND 2
 121+ 4E0D ED 69        	OUT (C), L
 122+ 4E0F E1           	POP HL ; pattern
 123+ 4E10 7D           	LD A, L
 124+ 4E11 28 02        	JR Z, .SMALLSPRITES
 125+ 4E13 87           	ADD A, A
 126+ 4E14 87           	ADD A, A ; needs to go at 4x
 127+ 4E15              .SMALLSPRITES:
 128+ 4E15 D3 98        	OUT (#98), A
 129+ 4E17 E1           	POP HL ; color
 130+ 4E18 7D           	LD A, L
 131+ 4E19 B3           	OR E
 132+ 4E1A D3 98        	OUT (#98), A
 133+ 4E1C              .NEXT:
 134+ 4E1C 08           	EX AF, AF'
 135+ 4E1D 3C           	INC A
 136+ 4E1E E6 1F        	AND 31
 137+ 4E20 C2 34 4E     	JP NZ, .NEXT2
 138+ 4E23 08           	EX AF, AF'
 139+ 4E24 2A 28 F9     	LD HL, (ATRBAS)
 140+ 4E27              	; CALL SETWRT_LOCAL not allowed as SP modified
 141+ 4E27 7D           	LD	A, L
 142+ 4E28 D3 99        	OUT	(099H), A
 143+ 4E2A 7C           	LD	A, H
 144+ 4E2B E6 3F        	AND	03FH
 145+ 4E2D F6 40        	OR	040H
 146+ 4E2F D3 99        	OUT	(099H), A
 147+ 4E31 C3 35 4E     	JP .NEXT3
 148+ 4E34              .NEXT2:
 149+ 4E34 08           	EX AF, AF'
 150+ 4E35              .NEXT3:
 151+ 4E35 10 85        	DJNZ .LOOP
 152+ 4E37 08           	EX AF, AF'
 153+ 4E38 3C           	INC A
 154+ 4E39 32 83 4D     	LD (FLICKER), A
 155+ 4E3C
 156+ 4E3C ED 7B 84 4D  	LD SP, (TMPSP)
 157+ 4E40 2A 7E 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 158+ 4E43 36 00        	LD (HL), 0 ; zero out update flag
 159+ 4E45 C9           	RET
 160+ 4E46              ; *******************************************************************************************************
 161+ 4E46
 162+ 4E46              ; *******************************************************************************************************
 163+ 4E46              ; function to handle CALL SPRENABLE basic extension
 164+ 4E46              ; initializes sprites handler
 165+ 4E46              ; _SPRENABLE ( INT sprites_attributes_data,
 166+ 4E46              ;			   INT update_variable_location,
 167+ 4E46              ;			   INT sprite_flicker_enabled )
 168+ 4E46              ; expects both locations to be in range #8000+ or throws an error
 169+ 4E46              ; since these should be BASIC variables
 170+ 4E46              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 171+ 4E46              SPRENABLE:
 172+ 4E46              	; opening (
 173+ 4E46 CD F9 56     	CALL CHKCHAR
 174+ 4E49 28           	DB '('
 175+ 4E4A              	; get address of sprite attribute table DIM SA%(3,31)
 176+ 4E4A DD 21 2F 54  	LD IX, FRMQNT
 177+ 4E4E CD 59 01     	CALL CALBAS
 178+ 4E51 D5           	PUSH DE
 179+ 4E52              	; comma
 180+ 4E52 CD F9 56     	CALL CHKCHAR
 181+ 4E55 2C           	DB ','
 182+ 4E56              	; get address of sprite update flag location
 183+ 4E56 DD 21 2F 54  	LD IX, FRMQNT
 184+ 4E5A CD 59 01     	CALL CALBAS
 185+ 4E5D D5           	PUSH DE
 186+ 4E5E              	; comma
 187+ 4E5E CD F9 56     	CALL CHKCHAR
 188+ 4E61 2C           	DB ','
 189+ 4E62              	; get flicker enabled flag
 190+ 4E62 DD 21 2F 54  	LD IX, FRMQNT
 191+ 4E66 CD 59 01     	CALL CALBAS
 192+ 4E69 D5           	PUSH DE
 193+ 4E6A              	; ending )
 194+ 4E6A CD F9 56     	CALL CHKCHAR
 195+ 4E6D 29           	DB ')'
 196+ 4E6E
 197+ 4E6E D1           	POP DE ; get flicker flag
 198+ 4E6F 7A           	LD A, D
 199+ 4E70 B3           	OR E
 200+ 4E71 32 82 4D     	LD (SPRFLICKER_ENABLED), A
 201+ 4E74
 202+ 4E74 D1           	POP DE ; update variable location
 203+ 4E75 CB 7A        	BIT 7, D ; is address >= &h8000
 204+ 4E77 20 05        	JR NZ, .L1
 205+ 4E79 1E 05        	LD E, 5 ; illegal function call
 206+ 4E7B C3 19 57     	JP THROW_ERROR
 207+ 4E7E              .L1:
 208+ 4E7E ED 53 7E 4D  	LD (SPRATR_UPDATE_FLAG), DE
 209+ 4E82 D1           	POP DE ; address of sprite attribute table
 210+ 4E83 CB 7A        	BIT 7, D ; is address >= &h8000
 211+ 4E85 20 05        	JR NZ, .L2
 212+ 4E87 1E 05        	LD E, 5 ; illegal function call
 213+ 4E89 C3 19 57     	JP THROW_ERROR
 214+ 4E8C              .L2:
 215+ 4E8C ED 53 80 4D  	LD (SPRATR_DATA), DE
 216+ 4E90 3E 01        	LD A, 1
 217+ 4E92 32 7D 4D     	LD (SPRATR_INIT_STATUS), A
 218+ 4E95 C9           	RET
 219+ 4E96              ; *******************************************************************************************************
 220+ 4E96
 221+ 4E96              ; *******************************************************************************************************
 222+ 4E96              ; function to handle CALL SPRDISABLE basic extension
 223+ 4E96              ; disables sprites handling
 224+ 4E96              ; _SPRDISABLE
 225+ 4E96              ; resets variable SPRATR_INIT_STATUS
 226+ 4E96              SPRDISABLE:
 227+ 4E96 AF           	XOR A
 228+ 4E97 32 7D 4D     	LD (SPRATR_INIT_STATUS), A
 229+ 4E9A C9           	RET
 230+ 4E9B              ; *******************************************************************************************************
 231+ 4E9B
 232+ 4E9B              ; *******************************************************************************************************
 233+ 4E9B              ; function to handle CALL SPRSET basic extension
 234+ 4E9B              ; sets position, and optionally pattern and color of sprite
 235+ 4E9B              ; _SPRSET ( BYTE sprite_num , valid 0-31
 236+ 4E9B              ;			INT x,
 237+ 4E9B              ;			INT y,
 238+ 4E9B              ;			INT pattern, valid 0-63, otherwise ignored
 239+ 4E9B              ;			INT color, valid 0-15, otherwise ignored
 240+ 4E9B              SPRSET:
 241+ 4E9B 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 242+ 4E9E B7           	OR A
 243+ 4E9F 20 05        	JR NZ, .L1
 244+ 4EA1 1E 05        	LD E, 5 ; illegal function call
 245+ 4EA3 C3 19 57     	JP THROW_ERROR
 246+ 4EA6              .L1:
 247+ 4EA6              	; opening (
 248+ 4EA6 CD F9 56     	CALL CHKCHAR
 249+ 4EA9 28           	DB '('
 250+ 4EAA              	; get sprite number
 251+ 4EAA DD 21 1C 52  	LD IX, GETBYT
 252+ 4EAE CD 59 01     	CALL CALBAS
 253+ 4EB1 F5           	PUSH AF
 254+ 4EB2              	; comma
 255+ 4EB2 CD F9 56     	CALL CHKCHAR
 256+ 4EB5 2C           	DB ','
 257+ 4EB6              	; get x
 258+ 4EB6 DD 21 2F 54  	LD IX, FRMQNT
 259+ 4EBA CD 59 01     	CALL CALBAS
 260+ 4EBD D5           	PUSH DE
 261+ 4EBE              	; comma
 262+ 4EBE CD F9 56     	CALL CHKCHAR
 263+ 4EC1 2C           	DB ','
 264+ 4EC2              	; get y
 265+ 4EC2 DD 21 2F 54  	LD IX, FRMQNT
 266+ 4EC6 CD 59 01     	CALL CALBAS
 267+ 4EC9 D5           	PUSH DE
 268+ 4ECA              	; comma
 269+ 4ECA CD F9 56     	CALL CHKCHAR
 270+ 4ECD 2C           	DB ','
 271+ 4ECE              	; get pattern
 272+ 4ECE DD 21 2F 54  	LD IX, FRMQNT
 273+ 4ED2 CD 59 01     	CALL CALBAS
 274+ 4ED5 D5           	PUSH DE
 275+ 4ED6              	; comma
 276+ 4ED6 CD F9 56     	CALL CHKCHAR
 277+ 4ED9 2C           	DB ','
 278+ 4EDA              	; get color
 279+ 4EDA DD 21 2F 54  	LD IX, FRMQNT
 280+ 4EDE CD 59 01     	CALL CALBAS
 281+ 4EE1 D5           	PUSH DE
 282+ 4EE2              	; ending )
 283+ 4EE2 CD F9 56     	CALL CHKCHAR
 284+ 4EE5 29           	DB ')'
 285+ 4EE6
 286+ 4EE6                  ; save position in BASIC text
 287+ 4EE6 E5           	PUSH HL
 288+ 4EE7 DD E1        	POP IX
 289+ 4EE9
 290+ 4EE9 C1           	POP BC ; color
 291+ 4EEA D1           	POP DE ; pattern
 292+ 4EEB D9           	EXX
 293+ 4EEC C1           	POP BC ; y
 294+ 4EED D1           	POP DE ; x
 295+ 4EEE F1           	POP AF ; sprite number
 296+ 4EEF FE 20        	CP 32
 297+ 4EF1 38 05        	JR C, .L2
 298+ 4EF3 1E 05        	LD E, 5 ; illegal function call
 299+ 4EF5 C3 19 57     	JP THROW_ERROR
 300+ 4EF8              .L2:
 301+ 4EF8              	; find location in sprite attributes table
 302+ 4EF8 D5           	PUSH DE
 303+ 4EF9 CD 86 4D     	CALL GETnthSPRATTR
 304+ 4EFC D1           	POP DE
 305+ 4EFD              	; set y
 306+ 4EFD 71           	LD (HL), C
 307+ 4EFE 23           	INC HL
 308+ 4EFF 70           	LD (HL), B
 309+ 4F00 23           	INC HL
 310+ 4F01              	; set x
 311+ 4F01 73           	LD (HL), E
 312+ 4F02 23           	INC HL
 313+ 4F03 72           	LD (HL), D
 314+ 4F04 23           	INC HL
 315+ 4F05 E5           	PUSH HL
 316+ 4F06 D9           	EXX
 317+ 4F07 E1           	POP HL
 318+ 4F08              	; check if 0<=pattern<64
 319+ 4F08 7A           	LD A, D
 320+ 4F09 B7           	OR A
 321+ 4F0A 20 0B        	JR NZ, .L3
 322+ 4F0C 7B           	LD A, E
 323+ 4F0D FE 40        	CP 64
 324+ 4F0F 30 06        	JR NC, .L3
 325+ 4F11              	; set pattern
 326+ 4F11              	;ADD A, A
 327+ 4F11              	;ADD A, A
 328+ 4F11              	;ADD A, A
 329+ 4F11 77           	LD (HL), A
 330+ 4F12 23           	INC HL
 331+ 4F13 72           	LD (HL), D
 332+ 4F14 23           	INC HL
 333+ 4F15 18 02        	JR .L4
 334+ 4F17              .L3:
 335+ 4F17              	; skip pattern
 336+ 4F17 23          > INC HL
 336+ 4F18 23          > INC HL
 337+ 4F19              .L4:
 338+ 4F19              	; check if 0<=color<16
 339+ 4F19 78           	LD A, B
 340+ 4F1A B7           	OR A
 341+ 4F1B 20 08        	JR NZ, .L5
 342+ 4F1D 79           	LD A, C
 343+ 4F1E FE 10        	CP 16
 344+ 4F20 30 03        	JR NC, .L5
 345+ 4F22              	; set color
 346+ 4F22 71           	LD (HL), C
 347+ 4F23 23           	INC HL
 348+ 4F24 70           	LD (HL), B
 349+ 4F25
 350+ 4F25              .L5:
 351+ 4F25 DD E5        	PUSH IX
 352+ 4F27 E1           	POP HL
 353+ 4F28 C9           	RET
 354+ 4F29              ; *******************************************************************************************************
 355+ 4F29
 356+ 4F29              ; *******************************************************************************************************
 357+ 4F29              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4F29              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4F29              ; input DE=initial x
 360+ 4F29              ; input BC=initial y
 361+ 4F29              ; input IY=location where delta y,x are located
 362+ 4F29              ; modifies AF, HL, IX
 363+ 4F29              SPRSET_DELTA_POS:
 364+ 4F29 D5           	PUSH DE
 365+ 4F2A CD 86 4D     	CALL GETnthSPRATTR
 366+ 4F2D E5           	PUSH HL
 367+ 4F2E DD E1        	POP IX
 368+ 4F30 D1           	POP DE
 369+ 4F31              	; IX=sprite's y location
 370+ 4F31 FD 6E 00     	LD L, (IY)
 371+ 4F34 FD 66 01     	LD H, (IY+1)
 372+ 4F37 09           	ADD HL, BC
 373+ 4F38 DD 75 00     	LD (IX), L
 374+ 4F3B DD 74 01     	LD (IX+1), H
 375+ 4F3E FD 6E 02     	LD L, (IY+2)
 376+ 4F41 FD 66 03     	LD H, (IY+3)
 377+ 4F44 19           	ADD HL, DE
 378+ 4F45 DD 75 02     	LD (IX+2), L
 379+ 4F48 DD 74 03     	LD (IX+3), H
 380+ 4F4B C9           	RET
 381+ 4F4C              ; *******************************************************************************************************
 382+ 4F4C
 383+ 4F4C              ; *******************************************************************************************************
 384+ 4F4C              ; function to handle CALL SPRGRPMOV basic extension
 385+ 4F4C              ; sets position of a group of sprites described with
 386+ 4F4C              ; { int sprite_num, int delta_y, int delta_x } [count]
 387+ 4F4C              ; _SPRGRPMOV ( INT x,
 388+ 4F4C              ;			   INT y,
 389+ 4F4C              ;			   INT data_ptr,
 390+ 4F4C              ;			   BYTE count,
 391+ 4F4C              ; will put ram in page 0 also, page 1 is already there
 392+ 4F4C              SPRGRPMOV:
 393+ 4F4C 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 394+ 4F4F B7           	OR A
 395+ 4F50 20 05        	JR NZ, .L1
 396+ 4F52 1E 05        	LD E, 5 ; illegal function call
 397+ 4F54 C3 19 57     	JP THROW_ERROR
 398+ 4F57              .L1:
 399+ 4F57              	; opening (
 400+ 4F57 CD F9 56     	CALL CHKCHAR
 401+ 4F5A 28           	DB '('
 402+ 4F5B              	; get x
 403+ 4F5B DD 21 2F 54  	LD IX, FRMQNT
 404+ 4F5F CD 59 01     	CALL CALBAS
 405+ 4F62 D5           	PUSH DE
 406+ 4F63              	; comma
 407+ 4F63 CD F9 56     	CALL CHKCHAR
 408+ 4F66 2C           	DB ','
 409+ 4F67              	; get y
 410+ 4F67 DD 21 2F 54  	LD IX, FRMQNT
 411+ 4F6B CD 59 01     	CALL CALBAS
 412+ 4F6E D5           	PUSH DE
 413+ 4F6F              	; comma
 414+ 4F6F CD F9 56     	CALL CHKCHAR
 415+ 4F72 2C           	DB ','
 416+ 4F73              	; get data pointer
 417+ 4F73 DD 21 2F 54  	LD IX, FRMQNT
 418+ 4F77 CD 59 01     	CALL CALBAS
 419+ 4F7A D5           	PUSH DE
 420+ 4F7B              	; comma
 421+ 4F7B CD F9 56     	CALL CHKCHAR
 422+ 4F7E 2C           	DB ','
 423+ 4F7F              	; get count
 424+ 4F7F DD 21 1C 52  	LD IX, GETBYT
 425+ 4F83 CD 59 01     	CALL CALBAS
 426+ 4F86 F5           	PUSH AF
 427+ 4F87              	; ending )
 428+ 4F87 CD F9 56     	CALL CHKCHAR
 429+ 4F8A 29           	DB ')'
 430+ 4F8B
 431+ 4F8B E5           	PUSH HL
 432+ 4F8C DD E1        	POP IX
 433+ 4F8E
 434+ 4F8E C1           	POP BC ; count
 435+ 4F8F E1           	POP HL ; data pointer
 436+ 4F90 D9           	EXX
 437+ 4F91 C1           	POP BC ; y
 438+ 4F92 D1           	POP DE ; x
 439+ 4F93 D9           	EXX
 440+ 4F94
 441+ 4F94 DD E5        	PUSH IX ; save position in BASIC buffer
 442+ 4F96
 443+ 4F96 C5           	PUSH BC
 444+ 4F97 E5           	PUSH HL
 445+ 4F98 AF               XOR A
 446+ 4F99 CD EC 55         CALL GET_PAGE_INFO
 447+ 4F9C D9           	EXX
 448+ 4F9D E1           	POP HL
 449+ 4F9E F1           	POP AF
 450+ 4F9F D9           	EXX
 451+ 4FA0 C5               PUSH BC
 452+ 4FA1 D5               PUSH DE
 453+ 4FA2 D9           	EXX
 454+ 4FA3 F5           	PUSH AF
 455+ 4FA4 E5           	PUSH HL
 456+ 4FA5 D9           	EXX
 457+ 4FA6 3A 41 F3         LD A, (RAMAD0)
 458+ 4FA9 26 00            LD H, 0
 459+ 4FAB CD 33 56         CALL LOCAL_ENASLT
 460+ 4FAE FB           	EI
 461+ 4FAF E1           	POP HL
 462+ 4FB0 C1           	POP BC
 463+ 4FB1 CD BB 4F     	CALL .UPDATE_LOC
 464+ 4FB4 D1               POP DE
 465+ 4FB5 C1               POP BC
 466+ 4FB6 CD 23 56         CALL RESTORE_PAGE_INFO
 467+ 4FB9 E1           	POP HL
 468+ 4FBA C9           	RET
 469+ 4FBB
 470+ 4FBB              .UPDATE_LOC:
 471+ 4FBB              .L4:
 472+ 4FBB 7E           	LD A, (HL)
 473+ 4FBC 23           	INC HL
 474+ 4FBD 23           	INC HL
 475+ 4FBE E5           	PUSH HL
 476+ 4FBF FD E1        	POP IY
 477+ 4FC1 D9           	EXX
 478+ 4FC2 CD 29 4F     	CALL SPRSET_DELTA_POS
 479+ 4FC5 D9           	EXX
 480+ 4FC6 23          > INC HL
 480+ 4FC7 23          > INC HL
 480+ 4FC8 23          > INC HL
 480+ 4FC9 23          > INC HL
 481+ 4FCA 10 EF        	DJNZ .L4
 482+ 4FCC C9           	RET
 483+ 4FCD              ; *******************************************************************************************************
 484+ 4FCD
# file closed: asm\SPRITES.asm
 125  4FCD               ENDIF
 126  4FCD
 127  4FCD               IF (ANIM_CMDS == 1)
 128  4FCD               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4FCD              ; sprite animation routines
   2+ 4FCD
   3+ 4FCD              ; number of animation items and pointer
   4+ 4FCD              ANIMITEMNUM:
   5+ 4FCD 00            DB 0
   6+ 4FCE              ANIMITEMPTR:
   7+ 4FCE 5F 5F         DW EXT_END
   8+ 4FD0              ; number of animation definitions and pointer
   9+ 4FD0              ANIMDEFNUM:
  10+ 4FD0 00            DB 0
  11+ 4FD1              ANIMDEFPTR:
  12+ 4FD1 5F 5F         DW EXT_END
  13+ 4FD3              ; number of links between sprite and animation definitions
  14+ 4FD3              ANIMSPRNUM:
  15+ 4FD3 00            DB 0
  16+ 4FD4              ANIMSPRPTR:
  17+ 4FD4 5F 5F         DW EXT_END
  18+ 4FD6
  19+ 4FD6              ; ANIMATION ITEM
  20+ 4FD6              ; byte type = [0 - pattern and color change
  21+ 4FD6              ;              1 - pattern definition change ]
  22+ 4FD6              ; word ticks - number of ticks to hold this state
  23+ 4FD6              ; for type = 0
  24+ 4FD6              ;   byte pattern;
  25+ 4FD6              ;   byte color;
  26+ 4FD6              ; for type = 1
  27+ 4FD6              ;   work data_pointer;
  28+ 4FD6              ; total size = 5b
  29+ 4FD6
  30+ 4FD6              ; ANIMATION DEFINITION
  31+ 4FD6              ; byte number of items 1-15
  32+ 4FD6              ; byte[15] anim_item;
  33+ 4FD6              ; total size = 16b
  34+ 4FD6
  35+ 4FD6              ; SPRITE ANIMATION
  36+ 4FD6              ; +00 byte sprite number;
  37+ 4FD6              ; +01 word time;
  38+ 4FD6              ; +03 byte current item;
  39+ 4FD6              ; +04 byte animation definition;
  40+ 4FD6              ; +05 byte cyclic;
  41+ 4FD6              ; +06 byte active;
  42+ 4FD6              ; +07 byte reserved
  43+ 4FD6              ; total size = 8b
  44+ 4FD6
  45+ 4FD6              ; *******************************************************************************************************
  46+ 4FD6              ; helper function HL=A*5
  47+ 4FD6              ; changes HL,DE;
  48+ 4FD6              Ax5:
  49+ 4FD6 26 00            LD H,0
  50+ 4FD8 6F               LD L,A
  51+ 4FD9 54               LD D,H
  52+ 4FDA 5D               LD E,L
  53+ 4FDB 29               ADD HL,HL
  54+ 4FDC 29               ADD HL,HL
  55+ 4FDD 19               ADD HL,DE
  56+ 4FDE C9               RET
  57+ 4FDF              ; *******************************************************************************************************
  58+ 4FDF
  59+ 4FDF              ; *******************************************************************************************************
  60+ 4FDF              ; helper function gets pointer to n-th animation item
  61+ 4FDF              ; changes HL,DE;
  62+ 4FDF              GETnthANIMITEM:
  63+ 4FDF CD D6 4F         CALL Ax5
  64+ 4FE2 ED 5B CE 4F      LD DE,(ANIMITEMPTR)
  65+ 4FE6 19               ADD HL,DE
  66+ 4FE7 C9               RET
  67+ 4FE8              ; *******************************************************************************************************
  68+ 4FE8
  69+ 4FE8              ; *******************************************************************************************************
  70+ 4FE8              ; helper function gets pointer to n-th entry in animation definition
  71+ 4FE8              ; changes HL,DE;
  72+ 4FE8              GETnthANIMDEF:
  73+ 4FE8 26 00            LD H,0
  74+ 4FEA 6F               LD L,A
  75+ 4FEB CD E8 55         CALL HLx8
  76+ 4FEE ED 5B D1 4F      LD DE,(ANIMDEFPTR)
  77+ 4FF2 19               ADD HL,DE
  78+ 4FF3 C9               RET
  79+ 4FF4              ; *******************************************************************************************************
  80+ 4FF4
  81+ 4FF4              ; *******************************************************************************************************
  82+ 4FF4              ; helper function gets pointer to n-th entry in sprite animation
  83+ 4FF4              ; changes HL,DE;
  84+ 4FF4              GETnthSPRANIM:
  85+ 4FF4 26 00            LD H,0
  86+ 4FF6 6F               LD L,A
  87+ 4FF7 CD E7 55         CALL HLx16
  88+ 4FFA ED 5B D4 4F      LD DE,(ANIMSPRPTR)
  89+ 4FFE 19               ADD HL,DE
  90+ 4FFF C9               RET
  91+ 5000              ; *******************************************************************************************************
  92+ 5000
  93+ 5000              ; *******************************************************************************************************
  94+ 5000              ; function to handle CALL MAXANIMITEMS basic extension
  95+ 5000              ; MAXANIMITEMS (BYTE number)
  96+ 5000              ; sets new number and moves memory buffers as needed
  97+ 5000              MAXANIMITEMS:
  98+ 5000              	; opening (
  99+ 5000 CD F9 56     	CALL CHKCHAR
 100+ 5003 28           	DB '('
 101+ 5004              	; get value
 102+ 5004 DD 21 1C 52  	LD IX, GETBYT
 103+ 5008 CD 59 01     	CALL CALBAS
 104+ 500B F5               PUSH AF
 105+ 500C              	; ending )
 106+ 500C CD F9 56     	CALL CHKCHAR
 107+ 500F 29           	DB ')'
 108+ 5010 F1               POP AF
 109+ 5011
 110+ 5011              	; save position
 111+ 5011 E5           	PUSH HL
 112+ 5012              .ENTRY:
 113+ 5012 47               LD B,A
 114+ 5013 3A CD 4F         LD A,(ANIMITEMNUM)
 115+ 5016 90               SUB B
 116+ 5017 28 1F            JR Z, .EXIT; same value as before
 117+ 5019 FD 21 D1 4F      LD IY,ANIMDEFPTR
 118+ 501D FA 3B 50         JP M, .INCREASE
 119+ 5020                  ; new value is lower than previous one
 120+ 5020 CD 53 50         CALL .SIZEDIFF
 121+ 5023 CD 6E 50         CALL .DECREASE_COMMON
 122+ 5026 2A D4 4F         LD HL,(ANIMSPRPTR)
 123+ 5029 AF               XOR A
 124+ 502A ED 42            SBC HL,BC
 125+ 502C 22 D4 4F         LD (ANIMSPRPTR),HL
 126+ 502F              .E1:
 127+ 502F 2A 10 40         LD HL,(FREEMEMPTR)
 128+ 5032 AF               XOR A
 129+ 5033 ED 42            SBC HL,BC
 130+ 5035 22 10 40         LD (FREEMEMPTR),HL
 131+ 5038              .EXIT:
 132+ 5038 FB               EI
 133+ 5039 E1           	POP HL
 134+ 503A C9           	RET
 135+ 503B              .INCREASE:
 136+ 503B ED 44            NEG
 137+ 503D CD 53 50         CALL .SIZEDIFF
 138+ 5040 CD 9A 50         CALL .INCREASE_COMMON
 139+ 5043 2A D4 4F         LD HL,(ANIMSPRPTR)
 140+ 5046 09               ADD HL,BC
 141+ 5047 22 D4 4F         LD (ANIMSPRPTR),HL
 142+ 504A              .E2:
 143+ 504A 2A 10 40         LD HL,(FREEMEMPTR)
 144+ 504D 09               ADD HL,BC
 145+ 504E 22 10 40         LD (FREEMEMPTR),HL
 146+ 5051 18 E5            JR .EXIT
 147+ 5053              .SIZEDIFF:
 148+ 5053 CD D6 4F         CALL Ax5
 149+ 5056 78               LD A,B
 150+ 5057 32 CD 4F         LD (ANIMITEMNUM),A
 151+ 505A 44               LD B,H
 152+ 505B 4D               LD C,L
 153+ 505C C9               RET ; BC=size difference in bytes
 154+ 505D              .SIZETOMOVE:
 155+ 505D D5               PUSH DE
 156+ 505E 2A 10 40         LD HL,(FREEMEMPTR)
 157+ 5061 FD 5E 00         LD E,(IY)
 158+ 5064 FD 56 01         LD D,(IY+1)
 159+ 5067 AF               XOR A
 160+ 5068 ED 52            SBC HL,DE
 161+ 506A 44               LD B,H
 162+ 506B 4D               LD C,L
 163+ 506C D1               POP DE
 164+ 506D C9               RET
 165+ 506E              .DECREASE_COMMON:
 166+ 506E FD 6E 00         LD L,(IY)
 167+ 5071 FD 66 01         LD H,(IY+1)
 168+ 5074 AF               XOR A
 169+ 5075 ED 42            SBC HL,BC
 170+ 5077 EB               EX DE,HL
 171+ 5078 C5               PUSH BC
 172+ 5079 CD 5D 50         CALL .SIZETOMOVE
 173+ 507C F3               DI
 174+ 507D 78               LD A,B
 175+ 507E B1               OR C
 176+ 507F 28 08            JR Z,.L1
 177+ 5081 FD 6E 00         LD L,(IY)
 178+ 5084 FD 66 01         LD H,(IY+1)
 179+ 5087 ED B0            LDIR
 180+ 5089              .L1:
 181+ 5089 C1               POP BC
 182+ 508A FD 6E 00         LD L,(IY)
 183+ 508D FD 66 01         LD H,(IY+1)
 184+ 5090 AF               XOR A
 185+ 5091 ED 42            SBC HL,BC
 186+ 5093 FD 75 00         LD (IY),L
 187+ 5096 FD 74 01         LD (IY+1),H
 188+ 5099 C9               RET
 189+ 509A              .INCREASE_COMMON:
 190+ 509A 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 509D 2B               DEC HL
 192+ 509E AF               XOR A
 193+ 509F ED 42            SBC HL,BC
 194+ 50A1 EB               EX DE,HL
 195+ 50A2 C5               PUSH BC
 196+ 50A3 CD 5D 50         CALL .SIZETOMOVE
 197+ 50A6 F3               DI
 198+ 50A7 78               LD A,B
 199+ 50A8 B1               OR C
 200+ 50A9 28 06            JR Z,.L2
 201+ 50AB 2A 10 40         LD HL,(FREEMEMPTR)
 202+ 50AE 2B               DEC HL
 203+ 50AF ED B8            LDDR
 204+ 50B1              .L2:
 205+ 50B1 C1               POP BC
 206+ 50B2 FD 6E 00         LD L,(IY)
 207+ 50B5 FD 66 01         LD H,(IY+1)
 208+ 50B8 09               ADD HL,BC
 209+ 50B9 FD 75 00         LD (IY),L
 210+ 50BC FD 74 01         LD (IY+1),H
 211+ 50BF C9               RET
 212+ 50C0              ; *******************************************************************************************************
 213+ 50C0
 214+ 50C0              ; *******************************************************************************************************
 215+ 50C0              ; function to handle CALL ANIMITEMPAT basic extension
 216+ 50C0              ; ANIMITEMPAT ( BYTE id,
 217+ 50C0              ;               INT ticks,
 218+ 50C0              ;               BYTE pattern,
 219+ 50C0              ;               BYTE color )
 220+ 50C0              ; fills animation item data, returns an error if out of bounds
 221+ 50C0              ANIMITEMPAT:
 222+ 50C0                  ; opening (
 223+ 50C0 CD F9 56     	CALL CHKCHAR
 224+ 50C3 28           	DB '('
 225+ 50C4              	; get id
 226+ 50C4 DD 21 1C 52  	LD IX, GETBYT
 227+ 50C8 CD 59 01     	CALL CALBAS
 228+ 50CB F5               PUSH AF
 229+ 50CC                  ; check if out of bounds
 230+ 50CC 3C               INC A
 231+ 50CD 4F               LD C,A
 232+ 50CE 3A CD 4F         LD A,(ANIMITEMNUM)
 233+ 50D1 B9               CP C
 234+ 50D2 DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 235+ 50D5              	; comma
 236+ 50D5 CD F9 56     	CALL CHKCHAR
 237+ 50D8 2C           	DB ','
 238+ 50D9              	; get ticks
 239+ 50D9 DD 21 2F 54  	LD IX, FRMQNT
 240+ 50DD CD 59 01     	CALL CALBAS
 241+ 50E0 D5           	PUSH DE
 242+ 50E1              	; comma
 243+ 50E1 CD F9 56     	CALL CHKCHAR
 244+ 50E4 2C           	DB ','
 245+ 50E5              	; get pattern
 246+ 50E5 DD 21 1C 52  	LD IX, GETBYT
 247+ 50E9 CD 59 01     	CALL CALBAS
 248+ 50EC F5               PUSH AF
 249+ 50ED              	; comma
 250+ 50ED CD F9 56     	CALL CHKCHAR
 251+ 50F0 2C           	DB ','
 252+ 50F1              	; get color
 253+ 50F1 DD 21 1C 52  	LD IX, GETBYT
 254+ 50F5 CD 59 01     	CALL CALBAS
 255+ 50F8 F5               PUSH AF
 256+ 50F9              	; ending )
 257+ 50F9 CD F9 56     	CALL CHKCHAR
 258+ 50FC 29           	DB ')'
 259+ 50FD              .ENTRY:
 260+ 50FD E5               PUSH HL
 261+ 50FE DD E1            POP IX
 262+ 5100 D9               EXX
 263+ 5101 C1               POP BC ; color
 264+ 5102 D1               POP DE ; pattern
 265+ 5103 E1               POP HL ; ticks
 266+ 5104 D9               EXX
 267+ 5105 F1               POP AF
 268+ 5106 CD DF 4F         CALL GETnthANIMITEM
 269+ 5109 E5               PUSH HL
 270+ 510A FD E1            POP IY
 271+ 510C D9               EXX
 272+ 510D FD 36 00 00      LD (IY),0 ; type=0
 273+ 5111 FD 75 01         LD (IY+1),L
 274+ 5114 FD 74 02         LD (IY+2),H
 275+ 5117 FD 72 03         LD (IY+3),D
 276+ 511A FD 70 04         LD (IY+4),B
 277+ 511D
 278+ 511D DD E5            PUSH IX
 279+ 511F E1               POP HL
 280+ 5120 C9               RET
 281+ 5121              ; *******************************************************************************************************
 282+ 5121
 283+ 5121              ; *******************************************************************************************************
 284+ 5121              ; function to handle CALL ANIMITEMPTR basic extension
 285+ 5121              ; ANIMITEMPTR ( BYTE id,
 286+ 5121              ;               INT ticks,
 287+ 5121              ;               INT pointer,
 288+ 5121              ; fills animation item data, returns an error if out of bounds
 289+ 5121              ANIMITEMPTR_CMD:
 290+ 5121                  ; opening (
 291+ 5121 CD F9 56     	CALL CHKCHAR
 292+ 5124 28           	DB '('
 293+ 5125              	; get id
 294+ 5125 DD 21 1C 52  	LD IX, GETBYT
 295+ 5129 CD 59 01     	CALL CALBAS
 296+ 512C F5               PUSH AF
 297+ 512D                  ; check if out of bounds
 298+ 512D 3C               INC A
 299+ 512E 4F               LD C,A
 300+ 512F 3A CD 4F         LD A,(ANIMITEMNUM)
 301+ 5132 B9               CP C
 302+ 5133 DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 303+ 5136              	; comma
 304+ 5136 CD F9 56     	CALL CHKCHAR
 305+ 5139 2C           	DB ','
 306+ 513A              	; get ticks
 307+ 513A DD 21 2F 54  	LD IX, FRMQNT
 308+ 513E CD 59 01     	CALL CALBAS
 309+ 5141 D5           	PUSH DE
 310+ 5142              	; comma
 311+ 5142 CD F9 56     	CALL CHKCHAR
 312+ 5145 2C           	DB ','
 313+ 5146              	; get pointer
 314+ 5146 DD 21 2F 54  	LD IX, FRMQNT
 315+ 514A CD 59 01     	CALL CALBAS
 316+ 514D D5           	PUSH DE
 317+ 514E              	; ending )
 318+ 514E CD F9 56     	CALL CHKCHAR
 319+ 5151 29           	DB ')'
 320+ 5152              .ENTRY:
 321+ 5152 E5               PUSH HL
 322+ 5153 DD E1            POP IX
 323+ 5155 D9               EXX
 324+ 5156 D1               POP DE ; pointer
 325+ 5157 E1               POP HL ; ticks
 326+ 5158 D9               EXX
 327+ 5159 F1               POP AF
 328+ 515A CD DF 4F         CALL GETnthANIMITEM
 329+ 515D E5               PUSH HL
 330+ 515E FD E1            POP IY
 331+ 5160 D9               EXX
 332+ 5161 FD 36 00 01      LD (IY),1 ; type=1
 333+ 5165 FD 75 01         LD (IY+1),L
 334+ 5168 FD 74 02         LD (IY+2),H
 335+ 516B FD 73 03         LD (IY+3),E
 336+ 516E FD 72 04         LD (IY+4),D
 337+ 5171
 338+ 5171 DD E5            PUSH IX
 339+ 5173 E1               POP HL
 340+ 5174 C9               RET
 341+ 5175              ; *******************************************************************************************************
 342+ 5175
 343+ 5175              ; *******************************************************************************************************
 344+ 5175              ; function to handle CALL MAXANIMDEFS basic extension
 345+ 5175              ; MAXANIMDEFS (BYTE number)
 346+ 5175              ; sets new number and moves memory buffers as needed
 347+ 5175              MAXANIMDEFS:
 348+ 5175              	; opening (
 349+ 5175 CD F9 56     	CALL CHKCHAR
 350+ 5178 28           	DB '('
 351+ 5179              	; get value
 352+ 5179 DD 21 1C 52  	LD IX, GETBYT
 353+ 517D CD 59 01     	CALL CALBAS
 354+ 5180 F5               PUSH AF
 355+ 5181              	; ending )
 356+ 5181 CD F9 56     	CALL CHKCHAR
 357+ 5184 29           	DB ')'
 358+ 5185 F1               POP AF
 359+ 5186
 360+ 5186              	; save position
 361+ 5186 E5           	PUSH HL
 362+ 5187              .ENTRY:
 363+ 5187 47               LD B,A
 364+ 5188 3A D0 4F         LD A,(ANIMDEFNUM)
 365+ 518B 90               SUB B
 366+ 518C CA 38 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 367+ 518F FD 21 D4 4F      LD IY,ANIMSPRPTR
 368+ 5193 FA 9F 51         JP M, .INCREASE
 369+ 5196                  ; new value is lower than previous one
 370+ 5196 CD AA 51         CALL .SIZEDIFF
 371+ 5199 CD 6E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 372+ 519C C3 2F 50         JP MAXANIMITEMS.E1
 373+ 519F              .INCREASE:
 374+ 519F ED 44            NEG
 375+ 51A1 CD AA 51         CALL .SIZEDIFF
 376+ 51A4 CD 9A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 377+ 51A7 C3 4A 50         JP MAXANIMITEMS.E2
 378+ 51AA              .SIZEDIFF:
 379+ 51AA 26 00            LD H,0
 380+ 51AC 6F               LD L,A
 381+ 51AD CD E7 55         CALL HLx16
 382+ 51B0 78               LD A,B
 383+ 51B1 32 D0 4F         LD (ANIMDEFNUM),A
 384+ 51B4 44               LD B,H
 385+ 51B5 4D               LD C,L
 386+ 51B6 C9               RET ; BC=size difference in bytes
 387+ 51B7              ; *******************************************************************************************************
 388+ 51B7
 389+ 51B7              ; *******************************************************************************************************
 390+ 51B7              ; function to handle CALL ANIMDEF basic extension
 391+ 51B7              ; ANIMITEMPAT ( BYTE id,
 392+ 51B7              ;               BYTE size,
 393+ 51B7              ;               INT[] list )
 394+ 51B7              ; fills animation definition data, returns an error if out of bounds, or invalid type
 395+ 51B7              ANIMDEF:
 396+ 51B7                  ; opening (
 397+ 51B7 CD F9 56     	CALL CHKCHAR
 398+ 51BA 28           	DB '('
 399+ 51BB              	; get id
 400+ 51BB DD 21 1C 52  	LD IX, GETBYT
 401+ 51BF CD 59 01     	CALL CALBAS
 402+ 51C2 F5               PUSH AF
 403+ 51C3                  ; check if out of bounds
 404+ 51C3 3C               INC A
 405+ 51C4 4F               LD C,A
 406+ 51C5 3A D0 4F         LD A,(ANIMDEFNUM)
 407+ 51C8 B9               CP C
 408+ 51C9 DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 409+ 51CC              	; comma
 410+ 51CC CD F9 56     	CALL CHKCHAR
 411+ 51CF 2C           	DB ','
 412+ 51D0              	; get size
 413+ 51D0 DD 21 1C 52  	LD IX, GETBYT
 414+ 51D4 CD 59 01     	CALL CALBAS
 415+ 51D7 FE 10            CP 16
 416+ 51D9 D2 13 57         JP NC, OVERFLOW
 417+ 51DC B7               OR A
 418+ 51DD CA 13 57         JP Z, OVERFLOW
 419+ 51E0 F5           	PUSH AF
 420+ 51E1              	; comma
 421+ 51E1 CD F9 56     	CALL CHKCHAR
 422+ 51E4 2C           	DB ','
 423+ 51E5              	; get pointer to a list of animation items in integer array format
 424+ 51E5 3E 01            LD A,1
 425+ 51E7 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 426+ 51EA DD 21 A4 5E  	LD IX, PTRGET
 427+ 51EE CD 59 01     	CALL CALBAS
 428+ 51F1                  ; contrary to documentation we get a pointer to array dimension in BC
 429+ 51F1                  ; and type in VALTYP
 430+ 51F1 AF               XOR A
 431+ 51F2 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
 432+ 51F5 3A 63 F6         LD A,(VALTYP)
 433+ 51F8 FE 02            CP 2
 434+ 51FA C2 0B 57         JP NZ,TYPE_MISMATCH
 435+ 51FD 0A               LD A,(BC)
 436+ 51FE FE 01            CP 1
 437+ 5200 C2 0B 57         JP NZ,TYPE_MISMATCH
 438+ 5203 03               INC BC
 439+ 5204 0A               LD A,(BC)
 440+ 5205 D1               POP DE
 441+ 5206 D5               PUSH DE
 442+ 5207 3C               INC A
 443+ 5208 BA               CP D
 444+ 5209 DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 445+ 520C 03          > INC BC
 445+ 520D 03          > INC BC
 446+ 520E C5               PUSH BC
 447+ 520F              	; ending )
 448+ 520F CD F9 56     	CALL CHKCHAR
 449+ 5212 29           	DB ')'
 450+ 5213              .ENTRY:
 451+ 5213 E5               PUSH HL
 452+ 5214 DD E1            POP IX
 453+ 5216 D1               POP DE ; pointer to INT array
 454+ 5217 C1               POP BC ; B=item number
 455+ 5218 F1               POP AF ; id
 456+ 5219 D5               PUSH DE
 457+ 521A CD E8 4F         CALL GETnthANIMDEF
 458+ 521D D1               POP DE
 459+ 521E 70               LD (HL),B
 460+ 521F              .L1:
 461+ 521F 23               INC HL
 462+ 5220 1A               LD A,(DE)
 463+ 5221 13          > INC DE
 463+ 5222 13          > INC DE
 464+ 5223 77               LD (HL),A
 465+ 5224 10 F9            DJNZ .L1
 466+ 5226 DD E5            PUSH IX
 467+ 5228 E1               POP HL
 468+ 5229 C9               RET
 469+ 522A              ; *******************************************************************************************************
 470+ 522A
 471+ 522A              ; *******************************************************************************************************
 472+ 522A              ; function to handle CALL MAXANIMSPRS basic extension
 473+ 522A              ; MAXANIMSPRS (BYTE number)
 474+ 522A              ; sets new number and moves memory buffers as needed
 475+ 522A              MAXANIMSPRS:
 476+ 522A              	; opening (
 477+ 522A CD F9 56     	CALL CHKCHAR
 478+ 522D 28           	DB '('
 479+ 522E              	; get value
 480+ 522E DD 21 1C 52  	LD IX, GETBYT
 481+ 5232 CD 59 01     	CALL CALBAS
 482+ 5235 F5               PUSH AF
 483+ 5236              	; ending )
 484+ 5236 CD F9 56     	CALL CHKCHAR
 485+ 5239 29           	DB ')'
 486+ 523A F1               POP AF
 487+ 523B
 488+ 523B              	; save position
 489+ 523B E5           	PUSH HL
 490+ 523C              .ENTRY:
 491+ 523C 47               LD B,A
 492+ 523D 3A D3 4F         LD A,(ANIMSPRNUM)
 493+ 5240 90               SUB B
 494+ 5241 CA 38 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 495+ 5244 FD 21 10 40      LD IY,FREEMEMPTR
 496+ 5248 FA 54 52         JP M, .INCREASE
 497+ 524B                  ; new value is lower than previous one
 498+ 524B CD 73 52         CALL .SIZEDIFF
 499+ 524E CD 6E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 500+ 5251 C3 38 50         JP MAXANIMITEMS.EXIT
 501+ 5254              .INCREASE:
 502+ 5254 ED 44            NEG
 503+ 5256 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 504+ 5257 CD 73 52         CALL .SIZEDIFF
 505+ 525A CD 9A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 506+ 525D AF               XOR A
 507+ 525E ED 42            SBC HL,BC ; location of new stuff
 508+ 5260 F1               POP AF
 509+ 5261 47               LD B,A
 510+ 5262 11 08 00         LD DE,8
 511+ 5265 E5               PUSH HL
 512+ 5266 DD E1            POP IX
 513+ 5268              .L1:
 514+ 5268 DD 36 06 00      LD (IX+6),0
 515+ 526C DD 19            ADD IX,DE
 516+ 526E 10 F8            DJNZ .L1
 517+ 5270 C3 38 50         JP MAXANIMITEMS.EXIT
 518+ 5273              .SIZEDIFF:
 519+ 5273 26 00            LD H,0
 520+ 5275 6F               LD L,A
 521+ 5276 CD E8 55         CALL HLx8
 522+ 5279 78               LD A,B
 523+ 527A 32 D3 4F         LD (ANIMSPRNUM),A
 524+ 527D 44               LD B,H
 525+ 527E 4D               LD C,L
 526+ 527F C9               RET ; BC=size difference in bytes
 527+ 5280              ; *******************************************************************************************************
 528+ 5280
 529+ 5280              ; *******************************************************************************************************
 530+ 5280              ; function to handle CALL ANIMSPRITE basic extension
 531+ 5280              ; ANIMSPRITE ( BYTE id,
 532+ 5280              ;              BYTE sprite_number,
 533+ 5280              ;              BYTE animation_definition_id,
 534+ 5280              ;              BYTE cyclic_flag )
 535+ 5280              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 536+ 5280              ANIMSPRITE:
 537+ 5280                  ; opening (
 538+ 5280 CD F9 56     	CALL CHKCHAR
 539+ 5283 28           	DB '('
 540+ 5284              	; get sprite animation id
 541+ 5284 DD 21 1C 52  	LD IX, GETBYT
 542+ 5288 CD 59 01     	CALL CALBAS
 543+ 528B F5               PUSH AF
 544+ 528C 3C               INC A
 545+ 528D 4F               LD C,A
 546+ 528E 3A D3 4F         LD A,(ANIMSPRNUM)
 547+ 5291 B9               CP C
 548+ 5292 DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 549+ 5295              	; comma
 550+ 5295 CD F9 56     	CALL CHKCHAR
 551+ 5298 2C           	DB ','
 552+ 5299              	; get sprite number
 553+ 5299 DD 21 1C 52  	LD IX, GETBYT
 554+ 529D CD 59 01     	CALL CALBAS
 555+ 52A0 F5               PUSH AF
 556+ 52A1                  ; check if out of bounds
 557+ 52A1 FE 20            CP 32
 558+ 52A3 D2 0F 57         JP NC, SUBSCRIPT_OUT_OF_RANGE
 559+ 52A6              	; comma
 560+ 52A6 CD F9 56     	CALL CHKCHAR
 561+ 52A9 2C           	DB ','
 562+ 52AA              	; get animation definition id
 563+ 52AA DD 21 1C 52  	LD IX, GETBYT
 564+ 52AE CD 59 01     	CALL CALBAS
 565+ 52B1 F5               PUSH AF
 566+ 52B2 3C               INC A
 567+ 52B3 4F               LD C,A
 568+ 52B4 3A D0 4F         LD A,(ANIMDEFNUM)
 569+ 52B7 B9               CP C
 570+ 52B8 DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 571+ 52BB              	; comma
 572+ 52BB CD F9 56     	CALL CHKCHAR
 573+ 52BE 2C           	DB ','
 574+ 52BF              	; get cyclic flag
 575+ 52BF DD 21 1C 52  	LD IX, GETBYT
 576+ 52C3 CD 59 01         CALL CALBAS
 577+ 52C6 F5           	PUSH AF
 578+ 52C7              	; ending )
 579+ 52C7 CD F9 56     	CALL CHKCHAR
 580+ 52CA 29           	DB ')'
 581+ 52CB              .ENTRY:
 582+ 52CB E5               PUSH HL
 583+ 52CC DD E1            POP IX
 584+ 52CE D9               EXX
 585+ 52CF D1               POP DE ; cyclic
 586+ 52D0 C1               POP BC ; animation definition id
 587+ 52D1 E1               POP HL ; sprite number
 588+ 52D2 D9               EXX
 589+ 52D3 F1               POP AF ; sprite animation id
 590+ 52D4 CD F4 4F         CALL GETnthSPRANIM
 591+ 52D7 E5               PUSH HL
 592+ 52D8 FD E1            POP IY
 593+ 52DA D9               EXX
 594+ 52DB FD 74 00         LD (IY),H
 595+ 52DE FD 70 04         LD (IY+4),B
 596+ 52E1 FD 72 05         LD (IY+5),D
 597+ 52E4                  ;LD (IY+6),0
 598+ 52E4 DD E5            PUSH IX
 599+ 52E6 E1               POP HL
 600+ 52E7 C9               RET
 601+ 52E8              ; *******************************************************************************************************
 602+ 52E8
 603+ 52E8              ; *******************************************************************************************************
 604+ 52E8              ; function to handle CALL ANIMSTART basic extension
 605+ 52E8              ; two forms
 606+ 52E8              ; ANIMSTART ( BYTE id )
 607+ 52E8              ; or
 608+ 52E8              ; ANIMSTART ( BYTE item_number,
 609+ 52E8              ;             INT[] sprite_animations )
 610+ 52E8              ; sets active flag to 1
 611+ 52E8              ANIMSTART:
 612+ 52E8 3E 01            LD A,1
 613+ 52EA 18 01            JR ANIMSTARTSTOP_COMMON
 614+ 52EC              ; *******************************************************************************************************
 615+ 52EC              ; *******************************************************************************************************
 616+ 52EC              ; function to handle CALL ANIMSTOP basic extension
 617+ 52EC              ; two forms
 618+ 52EC              ; ANIMSTOP ( BYTE id )
 619+ 52EC              ; or
 620+ 52EC              ; ANIMSTOP ( BYTE item_number,
 621+ 52EC              ;            INT[] sprite_animations )
 622+ 52EC              ; sets active flag to 1
 623+ 52EC              ANIMSTOP:
 624+ 52EC AF               XOR A
 625+ 52ED              ANIMSTARTSTOP_COMMON:
 626+ 52ED 32 6A 53         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
 627+ 52F0              ; *******************************************************************************************************
 628+ 52F0                  ; opening (
 629+ 52F0 CD F9 56     	CALL CHKCHAR
 630+ 52F3 28           	DB '('
 631+ 52F4              	; get sprite animation id or array size
 632+ 52F4 DD 21 1C 52  	LD IX,GETBYT
 633+ 52F8 CD 59 01     	CALL CALBAS
 634+ 52FB F5               PUSH AF
 635+ 52FC                  ; check if comma present
 636+ 52FC CD 03 57         CALL GETPREVCHAR
 637+ 52FF 23               INC HL
 638+ 5300 FE 2C            CP ','
 639+ 5302 28 0C            JR Z,.L1
 640+ 5304 FE 29            CP ')'
 641+ 5306 C2 17 57         JP NZ,SYNTAX_ERROR
 642+ 5309                  ; ok so single argument variant
 643+ 5309 F1               POP AF
 644+ 530A E5               PUSH HL
 645+ 530B CD 56 53         CALL .SETVALUE
 646+ 530E E1               POP HL
 647+ 530F C9               RET
 648+ 5310              .L1:
 649+ 5310                  ; array of items
 650+ 5310              	; get pointer to a list of animation items in integer array format
 651+ 5310 3E 01            LD A,1
 652+ 5312 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 653+ 5315 DD 21 A4 5E  	LD IX, PTRGET
 654+ 5319 CD 59 01     	CALL CALBAS
 655+ 531C                  ; contrary to documentation we get a pointer to array dimension in BC
 656+ 531C                  ; and type in VALTYP
 657+ 531C AF               XOR A
 658+ 531D 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
 659+ 5320 3A 63 F6         LD A,(VALTYP)
 660+ 5323 FE 02            CP 2
 661+ 5325 C2 0B 57         JP NZ,TYPE_MISMATCH
 662+ 5328 0A               LD A,(BC)
 663+ 5329 FE 01            CP 1
 664+ 532B C2 0B 57         JP NZ,TYPE_MISMATCH
 665+ 532E 03               INC BC
 666+ 532F 0A               LD A,(BC)
 667+ 5330 D1               POP DE
 668+ 5331 D5               PUSH DE
 669+ 5332 3C               INC A
 670+ 5333 BA               CP D
 671+ 5334 DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 672+ 5337 03          > INC BC
 672+ 5338 03          > INC BC
 673+ 5339 C5               PUSH BC
 674+ 533A              	; ending )
 675+ 533A CD F9 56     	CALL CHKCHAR
 676+ 533D 29           	DB ')'
 677+ 533E D1               POP DE ; array pointer
 678+ 533F C1               POP BC ; number of items
 679+ 5340 78               LD A,B
 680+ 5341 B7               OR A
 681+ 5342 CA 0F 57         JP Z,SUBSCRIPT_OUT_OF_RANGE
 682+ 5345 E5               PUSH HL
 683+ 5346 F3               DI
 684+ 5347              .L2:
 685+ 5347 C5               PUSH BC
 686+ 5348 1A               LD A,(DE)
 687+ 5349 13          > INC DE
 687+ 534A 13          > INC DE
 688+ 534B D5               PUSH DE
 689+ 534C CD 56 53         CALL .SETVALUE
 690+ 534F D1               POP DE
 691+ 5350 C1               POP BC
 692+ 5351 10 F4            DJNZ .L2
 693+ 5353 FB               EI
 694+ 5354 E1               POP HL
 695+ 5355 C9               RET
 696+ 5356
 697+ 5356              .SETVALUE:
 698+ 5356 47               LD B,A
 699+ 5357 3C               INC A
 700+ 5358 4F               LD C,A
 701+ 5359 3A D3 4F         LD A,(ANIMSPRNUM)
 702+ 535C B9               CP C
 703+ 535D DA 0F 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 704+ 5360 78               LD A,B
 705+ 5361 CD F4 4F         CALL GETnthSPRANIM
 706+ 5364 E5               PUSH HL
 707+ 5365 DD E1            POP IX
 708+ 5367              .VALUE:
 709+ 5367 DD 36 06 01      LD (IX+6),1 ; active flag
 710+ 536B                  ; following stuff is needed to start only, but code sharing
 711+ 536B DD 36 03 00      LD (IX+3),0 ; current item
 712+ 536F CD E1 53         CALL SETUP_ANIM_STEP
 713+ 5372 C9               RET
 714+ 5373              ; *******************************************************************************************************
 715+ 5373
 716+ 5373              ; *******************************************************************************************************
 717+ 5373              ; function processes animations during vblank period
 718+ 5373              PROCESS_ANIMATIONS:
 719+ 5373 3A D3 4F         LD A,(ANIMSPRNUM)
 720+ 5376 B7               OR A
 721+ 5377 C8               RET Z; no animations defined
 722+ 5378 47               LD B,A
 723+ 5379 DD 2A D4 4F      LD IX,(ANIMSPRPTR)
 724+ 537D              .L1:
 725+ 537D C5               PUSH BC
 726+ 537E DD 7E 06         LD A,(IX+6); active
 727+ 5381 B7               OR A
 728+ 5382 28 16            JR Z,.SKIP ; inactive animation
 729+ 5384 DD 6E 01         LD L,(IX+1)
 730+ 5387 DD 66 02         LD H,(IX+2) ; HL=end time
 731+ 538A ED 5B 9E FC      LD DE,(JIFFY)
 732+ 538E AF               XOR A
 733+ 538F ED 52            SBC HL,DE
 734+ 5391 F2 9A 53         JP P,.SKIP ; time until next animation item not yet reached
 735+ 5394 DD 34 03         INC (IX+3) ; current animation item
 736+ 5397 CD E1 53         CALL SETUP_ANIM_STEP
 737+ 539A              .SKIP:
 738+ 539A 11 08 00         LD DE,8
 739+ 539D DD 19            ADD IX,DE
 740+ 539F C1               POP BC
 741+ 53A0 10 DB            DJNZ .L1
 742+ 53A2 C9               RET
 743+ 53A3              ; *******************************************************************************************************
 744+ 53A3
 745+ 53A3              ; *******************************************************************************************************
 746+ 53A3              ; function will setup sprite animation after current item change
 747+ 53A3              ; input A=current animation definition
 748+ 53A3              ; input IX=pointer to sprite animation
 749+ 53A3              ; output IY=pointer to animation item
 750+ 53A3              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
 751+ 53A3              ; basically sets new end time for current animation
 752+ 53A3              INIT_CURRENT_ANIMATION:
 753+ 53A3 CD E8 4F         CALL GETnthANIMDEF
 754+ 53A6 7E               LD A,(HL); number of animation items in the animation definition
 755+ 53A7 DD BE 03         CP (IX+3) ; current animation item
 756+ 53AA 20 0A            JR NZ,.L3 ; last item not reached
 757+ 53AC                  ; last item reached
 758+ 53AC DD 7E 05         LD A,(IX+5) ; cyclic flag
 759+ 53AF B7               OR A
 760+ 53B0 28 2D            JR Z,.ERROR ; non-cyclic animation
 761+ 53B2                  ; cyclic animation, restart
 762+ 53B2 DD 36 03 00      LD (IX+3),0; current item
 763+ 53B6              .L3:
 764+ 53B6                  ; HL = animation definition
 765+ 53B6 23               INC HL ; skip animation definition size field
 766+ 53B7 16 00            LD D,0
 767+ 53B9 DD 5E 03         LD E,(IX+3); current item
 768+ 53BC 19               ADD HL,DE
 769+ 53BD 4E               LD C,(HL) ; current animation item
 770+ 53BE 0C               INC C
 771+ 53BF 3A CD 4F         LD A,(ANIMITEMNUM)
 772+ 53C2 B9               CP C
 773+ 53C3 38 1A            JR C,.ERROR ; invalid animation item, stop animation
 774+ 53C5 0D               DEC C
 775+ 53C6 79               LD A,C
 776+ 53C7 CD DF 4F         CALL GETnthANIMITEM
 777+ 53CA E5               PUSH HL
 778+ 53CB FD E1            POP IY ; IY=animation item
 779+ 53CD 2A 9E FC         LD HL,(JIFFY)
 780+ 53D0 FD 5E 01         LD E,(IY+1)
 781+ 53D3 FD 56 02         LD D,(IY+2) ; duration
 782+ 53D6 19               ADD HL,DE
 783+ 53D7 DD 75 01         LD (IX+1),L
 784+ 53DA DD 74 02         LD (IX+2),H ; end time for current item
 785+ 53DD              .EXIT:
 786+ 53DD AF               XOR A
 787+ 53DE C9               RET
 788+ 53DF              .ERROR:
 789+ 53DF 37               SCF
 790+ 53E0 C9               RET
 791+ 53E1              ; *******************************************************************************************************
 792+ 53E1
 793+ 53E1              ; *******************************************************************************************************
 794+ 53E1              ; function will display currect item and set up expiry time
 795+ 53E1              ; it will also stop the animation if expired
 796+ 53E1              ; sets sprite update flag if any changes in sprite data made
 797+ 53E1              ; input IX=current sprite animation
 798+ 53E1              SETUP_ANIM_STEP:
 799+ 53E1 DD 4E 04         LD C,(IX+4) ; animation definition ID
 800+ 53E4 0C               INC C
 801+ 53E5 3A D0 4F         LD A,(ANIMDEFNUM)
 802+ 53E8 B9               CP C
 803+ 53E9 30 05            JR NC,.L2
 804+ 53EB                  ; given animation item is outside of bounds, deactivate animation
 805+ 53EB              .STOPANIM:
 806+ 53EB DD 36 06 00      LD (IX+6),0
 807+ 53EF C9               RET
 808+ 53F0              .L2:
 809+ 53F0 0D               DEC C
 810+ 53F1 79               LD A,C
 811+ 53F2 CD A3 53         CALL INIT_CURRENT_ANIMATION
 812+ 53F5 38 F4            JR C, .STOPANIM
 813+ 53F7 FD 7E 00         LD A,(IY) ; type of animation item
 814+ 53FA B7               OR A
 815+ 53FB CA 31 54         JP Z,.L4 ; change pattern and/or color
 816+ 53FE                  ; change sprite pattern definition
 817+ 53FE DD 7E 00         LD A,(IX) ; sprite number
 818+ 5401 CD 86 4D         CALL GETnthSPRATTR
 819+ 5404 23          > INC HL ; skip y and x
 819+ 5405 23          > INC HL
 819+ 5406 23          > INC HL
 819+ 5407 23          > INC HL
 820+ 5408 7E               LD A,(HL); current pattern
 821+ 5409 26 00            LD H,0
 822+ 540B 6F               LD L,A
 823+ 540C 3A E0 F3         LD A,(REG1SAV)
 824+ 540F E6 02            AND 2
 825+ 5411 20 07            JR NZ,.L6
 826+ 5413                  ; 8x8 sprite
 827+ 5413 CD E8 55         CALL HLx8
 828+ 5416 06 08            LD B,8
 829+ 5418 18 05            JR .L5
 830+ 541A              .L6:
 831+ 541A CD E6 55         CALL HLx32
 832+ 541D 06 20            LD B,32
 833+ 541F              .L5:
 834+ 541F ED 5B 26 F9      LD DE,(PATBAS)
 835+ 5423 19               ADD HL,DE
 836+ 5424 CD D5 55         CALL SETWRT_LOCAL
 837+ 5427 FD 6E 03         LD L,(IY+3)
 838+ 542A FD 66 04         LD H,(IY+4) ; pointer to sprite patter data
 839+ 542D CD E0 55         CALL BBYTECOPY
 840+ 5430 C9               RET
 841+ 5431              .L4:
 842+ 5431                  ; change pattern and color in sprite attributes table
 843+ 5431 DD 7E 00         LD A,(IX) ; sprite number
 844+ 5434 CD 86 4D         CALL GETnthSPRATTR
 845+ 5437 23          > INC HL ; skip y and x
 845+ 5438 23          > INC HL
 845+ 5439 23          > INC HL
 845+ 543A 23          > INC HL
 846+ 543B FD 7E 03         LD A,(IY+3) ; new pattern
 847+ 543E 77               LD (HL),A
 848+ 543F 23          > INC HL
 848+ 5440 23          > INC HL
 849+ 5441 FD 7E 04         LD A,(IY+4) ; new color
 850+ 5444 77               LD (HL),A
 851+ 5445 2A 7E 4D         LD HL,(SPRATR_UPDATE_FLAG)
 852+ 5448 36 01            LD (HL),1
 853+ 544A C9               RET
 854+ 544B              ; *******************************************************************************************************
 855+ 544B
# file closed: asm\ANIMATION.asm
 129  544B               ENDIF
 130  544B
 131  544B              ; temp variables for BLIT, TILE functions
 132  544B               IF (BLIT_CMDS + TILE_CMDS > 0)
 133  544B              BLIT_TMP:
 134  544B              TILETMP1:
 135  544B              BLIT_TMP1:
 136  544B 00 00         DW 0
 137  544D              TILETMP2:
 138  544D              BLIT_TMP2:
 139  544D 00 00         DW 0
 140  544F                IFDEF CMDS_WITH_PARAMETERS
 141  544F              BLIT_STRUCT:
 142  544F 00 00 00...   DS 17
 143  5453                ENDIF
 144  5453               ENDIF
 145  5460
 146  5460               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS > 0)
 147  5460              VRAM_UPDATE_IN_PROGRESS:
 148  5460 00            DB 0
 149  5461               ENDIF
 150  5461
 151  5461              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 152  5461              ; per starting letter, if no commands with this letter, NULL value
 153  5461              CMDS:
 154  5461               IF (ANIM_CMDS == 1)
 155  5461 8A 55        	DW CMDS_A ;
 156  5463               ELSE
 157  5463 ~                DW 0 ; A
 158  5463               ENDIF
 159  5463               IF (BLIT_CMDS + BOX_CMDS > 0)
 160  5463 55 55            DW CMDS_B ; B
 161  5465               ELSE
 162  5465 ~            	DW 0
 163  5465               ENDIF
 164  5465 00 00            DW 0 ; C
 165  5467 00 00            DW 0 ; D
 166  5469 00 00            DW 0 ; E
 167  546B               IF (VRAM_CMDS + RAM_CMDS > 0)
 168  546B D3 54            DW CMDS_F; F
 169  546D               ELSE
 170  546D ~            	DW 0
 171  546D               ENDIF
 172  546D               IF (GENCAL_CMD > 0)
 173  546D E6 54            DW CMDS_G; G
 174  546F               ELSE
 175  546F ~            	DW 0
 176  546F               ENDIF
 177  546F 00 00            DW 0 ; H
 178  5471 00 00            DW 0 ; I
 179  5473 00 00            DW 0 ; J
 180  5475 00 00            DW 0 ; K
 181  5477 00 00            DW 0 ; L
 182  5479               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 183  5479 95 54            DW CMDS_M ; M
 184  547B               ELSE
 185  547B ~            	DW 0
 186  547B               ENDIF
 187  547B 00 00            DW 0 ; N
 188  547D 00 00            DW 0 ; O
 189  547F 00 00            DW 0 ; P
 190  5481 00 00            DW 0 ; Q
 191  5483 00 00            DW 0 ; R
 192  5485               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 193  5485 FA 54            DW CMDS_S ; S
 194  5487               ELSE
 195  5487 ~            	DW 0
 196  5487               ENDIF
 197  5487               IF (TILE_CMDS > 0)
 198  5487 75 55            DW CMDS_T ; T
 199  5489               ELSE
 200  5489 ~            	DW 0
 201  5489               ENDIF
 202  5489 00 00            DW 0 ; U
 203  548B               IF (VRAM_CMDS > 0)
 204  548B F0 54            DW CMDS_V ; V
 205  548D               ELSE
 206  548D ~            	DW 0
 207  548D               ENDIF
 208  548D 00 00            DW 0 ; W
 209  548F 00 00            DW 0 ; X
 210  5491 00 00            DW 0 ; Y
 211  5493 00 00            DW 0 ; Z
 212  5495
 213  5495              CMDS_M:
 214  5495               IF (VRAM_CMDS == 1)
 215  5495 4D 45 4D 56      DB "MEMVRM", 0
 215  5499 52 4D 00
 216  549C 6A 58            DW MEMVRM
 217  549E               ENDIF
 218  549E               IF (RAM_CMDS == 1)
 219  549E 4D 45 4D 43  	DB "MEMCPY", 0
 219  54A2 50 59 00
 220  54A5 20 57        	DW MEMCPY
 221  54A7               ENDIF
 222  54A7               IF (ANIM_CMDS == 1)
 223  54A7 4D 41 58 41  	DB "MAXANIMITEMS",0
 223  54AB 4E 49 4D 49
 223  54AF 54 45 4D 53
 223  54B3 00
 224  54B4 00 50        	DW MAXANIMITEMS
 225  54B6 4D 41 58 41  	DB "MAXANIMDEFS",0
 225  54BA 4E 49 4D 44
 225  54BE 45 46 53 00
 226  54C2 75 51        	DW MAXANIMDEFS
 227  54C4 4D 41 58 41  	DB "MAXANIMSPRS",0
 227  54C8 4E 49 4D 53
 227  54CC 50 52 53 00
 228  54D0 2A 52        	DW MAXANIMSPRS
 229  54D2               ENDIF
 230  54D2               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 231  54D2 00           	DB 0
 232  54D3               ENDIF
 233  54D3              CMDS_F:
 234  54D3               IF (VRAM_CMDS == 1)
 235  54D3 46 49 4C 56      DB "FILVRM", 0
 235  54D7 52 4D 00
 236  54DA 63 57            DW FILVRM
 237  54DC               ENDIF
 238  54DC               IF (RAM_CMDS == 1)
 239  54DC 46 49 4C 52      DB "FILRAM", 0
 239  54E0 41 4D 00
 240  54E3 B3 57            DW FILRAM
 241  54E5               ENDIF
 242  54E5               IF (VRAM_CMDS + RAM_CMDS > 0)
 243  54E5 00               DB 0
 244  54E6               ENDIF
 245  54E6              CMDS_G:
 246  54E6               IF (GENCAL_CMD == 1)
 247  54E6 47 45 4E 43      DB "GENCAL", 0
 247  54EA 41 4C 00
 248  54ED 11 58            DW GENCAL
 249  54EF               ENDIF
 250  54EF               IF (GENCAL_CMD > 0)
 251  54EF 00           	DB	0
 252  54F0               ENDIF
 253  54F0              CMDS_V:
 254  54F0               IF (VRAM_CMDS == 1)
 255  54F0 56 52 4D 4D  	DB "VRMMEM", 0
 255  54F4 45 4D 00
 256  54F7 EB 58        	DW VRMMEM
 257  54F9               ENDIF
 258  54F9               IF (VRAM_CMDS > 0)
 259  54F9 00           	DB 0
 260  54FA               ENDIF
 261  54FA              CMDS_S:
 262  54FA               IF (SPRITE_CMDS == 1)
 263  54FA 53 50 52 53  	DB "SPRSET", 0
 263  54FE 45 54 00
 264  5501 9B 4E        	DW SPRSET
 265  5503 53 50 52 47  	DB "SPRGRPMOV", 0
 265  5507 52 50 4D 4F
 265  550B 56 00
 266  550D 4C 4F        	DW SPRGRPMOV
 267  550F               ENDIF
 268  550F               IF (SOUND_CMDS == 1)
 269  550F 53 4E 44 53  	DB "SNDSFX", 0
 269  5513 46 58 00
 270  5516 CC 59        	DW SNDSFX
 271  5518 53 4E 44 50  	DB "SNDPLYON", 0
 271  551C 4C 59 4F 4E
 271  5520 00
 272  5521 96 59        	DW SNDPLYON
 273  5523 53 4E 44 50  	DB "SNDPLYOFF", 0
 273  5527 4C 59 4F 46
 273  552B 46 00
 274  552D A9 59        	DW SNDPLYOFF
 275  552F 53 4E 44 50  	DB "SNDPLYINI", 0
 275  5533 4C 59 49 4E
 275  5537 49 00
 276  5539 4C 59        	DW SNDPLYINIT
 277  553B               ENDIF
 278  553B               IF (SPRITE_CMDS == 1)
 279  553B 53 50 52 45  	DB "SPRENABLE", 0
 279  553F 4E 41 42 4C
 279  5543 45 00
 280  5545 46 4E        	DW SPRENABLE
 281  5547 53 50 52 44  	DB "SPRDISABLE", 0
 281  554B 49 53 41 42
 281  554F 4C 45 00
 282  5552 96 4E        	DW SPRDISABLE
 283  5554               ENDIF
 284  5554               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 285  5554 00           	DB 0
 286  5555               ENDIF
 287  5555              CMDS_B:
 288  5555               IF (BLIT_CMDS == 1)
 289  5555 42 4C 49 54  	DB "BLIT", 0
 289  5559 00
 290  555A A3 5B        	DW BLIT
 291  555C               ENDIF
 292  555C               IF (BOX_CMDS == 1)
 293  555C 42 4F 58 4D  	DB "BOXMEMCPY", 0
 293  5560 45 4D 43 50
 293  5564 59 00
 294  5566 DB 5E        	DW BOXMEMCPY
 295  5568 42 4F 58 4D  	DB "BOXMEMVRM", 0
 295  556C 45 4D 56 52
 295  5570 4D 00
 296  5572 0F 5F        	DW BOXMEMVRM
 297  5574               ENDIF
 298  5574               IF (BLIT_CMDS + BOX_CMDS > 0)
 299  5574 00           	DB 0
 300  5575               ENDIF
 301  5575              CMDS_T:
 302  5575               IF (TILE_CMDS == 1)
 303  5575 54 49 4C 45  	DB "TILERAM", 0
 303  5579 52 41 4D 00
 304  557D E7 5C        	DW TILERAM
 305  557F 54 49 4C 45  	DB "TILEVRM", 0
 305  5583 56 52 4D 00
 306  5587 EA 5D        	DW TILEVRM
 307  5589               ENDIF
 308  5589               IF (TILE_CMDS > 0)
 309  5589 00           	DB 0
 310  558A               ENDIF
 311  558A              CMDS_A:
 312  558A               IF (ANIM_CMDS == 1)
 313  558A 41 4E 49 4D  	DB "ANIMSTART",0
 313  558E 53 54 41 52
 313  5592 54 00
 314  5594 E8 52        	DW ANIMSTART
 315  5596 41 4E 49 4D  	DB "ANIMSTOP",0
 315  559A 53 54 4F 50
 315  559E 00
 316  559F EC 52        	DW ANIMSTOP
 317  55A1 41 4E 49 4D  	DB "ANIMITEMPAT",0
 317  55A5 49 54 45 4D
 317  55A9 50 41 54 00
 318  55AD C0 50        	DW ANIMITEMPAT
 319  55AF 41 4E 49 4D  	DB "ANIMITEMPTR",0
 319  55B3 49 54 45 4D
 319  55B7 50 54 52 00
 320  55BB 21 51        	DW ANIMITEMPTR_CMD
 321  55BD 41 4E 49 4D  	DB "ANIMDEF",0
 321  55C1 44 45 46 00
 322  55C5 B7 51        	DW ANIMDEF
 323  55C7 41 4E 49 4D  	DB "ANIMSPRITE",0
 323  55CB 53 50 52 49
 323  55CF 54 45 00
 324  55D2 80 52        	DW ANIMSPRITE
 325  55D4 00           	DB 0
 326  55D5               ENDIF
 327  55D5
 328  55D5               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 329  55D5              ; ****************************************************************************************************
 330  55D5              ; function sets VRAM address
 331  55D5              ; input HL=address
 332  55D5              ; modifies AF
 333  55D5              SETWRT_LOCAL:
 334  55D5 7D           	LD	A, L
 335  55D6 D3 99        	OUT	(099H), A
 336  55D8 7C           	LD	A, H
 337  55D9 E6 3F        	AND	03FH
 338  55DB F6 40        	OR	040H
 339  55DD D3 99        	OUT	(099H), A
 340  55DF C9           	RET
 341  55E0              ; ****************************************************************************************************
 342  55E0               ENDIF
 343  55E0
 344  55E0               IF (VRAM_CMDS + TILE_CMDS > 0)
 345  55E0              ; ****************************************************************************************************
 346  55E0              ; function copies data from RAM to VRAM
 347  55E0              ; input HL=address in RAM
 348  55E0              ; input B=count
 349  55E0              ; modifies AF
 350  55E0              BBYTECOPY:
 351  55E0 ED A3        	OUTI
 352  55E2 C2 E0 55     	JP	NZ, BBYTECOPY
 353  55E5 C9           	RET
 354  55E6              ; ****************************************************************************************************
 355  55E6               ENDIF
 356  55E6
 357  55E6              ; ****************************************************************************************************
 358  55E6              ; function multiplies HL by 32
 359  55E6              HLx32:
 360  55E6 29           	ADD HL,HL
 361  55E7              ; ****************************************************************************************************
 362  55E7              ; function multiplies HL by 16
 363  55E7              HLx16:
 364  55E7 29           	ADD HL,HL
 365  55E8              ; ****************************************************************************************************
 366  55E8              ; function multiplies HL by 8
 367  55E8              HLx8:
 368  55E8 29          > ADD HL, HL
 368  55E9 29          > ADD HL, HL
 368  55EA 29          > ADD HL, HL
 369  55EB C9           	RET
 370  55EC              ; ****************************************************************************************************
 371  55EC
 372  55EC              ; ****************************************************************************************************
 373  55EC              ; function gets slot and subslot data for specific page
 374  55EC              ; input A=page (0, 1 or 2)
 375  55EC              ; output B = 0A8H register value
 376  55EC              ; output D = 0 is no subslots, 1 if yes
 377  55EC              ; output C = 0A8H value when page 3 slot equals to requested page slot
 378  55EC              ; output E = subslot value if present
 379  55EC              ; modifies AF, BC, DE, HL
 380  55EC              GET_PAGE_INFO:
 381  55EC 6F               LD L, A
 382  55ED C6 C1            ADD A, low (EXPTBL)
 383  55EF 32 F9 55         LD (GET_PAGE_INFO_L1+1), A
 384  55F2 DB A8            IN A, (0A8H)
 385  55F4 47               LD B, A
 386  55F5 E6 3F            AND 03FH
 387  55F7 4F               LD C, A
 388  55F8              GET_PAGE_INFO_L1:
 389  55F8 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 390  55FB E6 80            AND 080H
 391  55FD 28 1B            JR Z, GET_PAGE_INFO_L2
 392  55FF                  ; expanded
 393  55FF 2D               DEC L
 394  5600 FA 1F 56         JP M, GET_PAGE_INFO_L3
 395  5603 2D               DEC L
 396  5604 FA 1D 56         JP M, GET_PAGE_INFO_L4
 397  5607                  ; page 2
 398  5607 07               RLCA
 399  5608 07               RLCA
 400  5609              GET_PAGE_INFO_L5:
 401  5609 E6 C0            AND 0C0H
 402  560B B1               OR C
 403  560C D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 404  560E 4F               LD C, A
 405  560F 3A FF FF         LD A, (0FFFFH)
 406  5612 2F               CPL
 407  5613 5F               LD E, A
 408  5614 16 01            LD D, 1
 409  5616 78               LD A, B ; return stack
 410  5617 D3 A8            OUT (0A8H), A
 411  5619 C9               RET
 412  561A              GET_PAGE_INFO_L2:
 413  561A                  ; not expanded
 414  561A 16 00            LD D, 0
 415  561C C9               RET
 416  561D              GET_PAGE_INFO_L4:
 417  561D                  ; page 1
 418  561D 0F               RRCA
 419  561E 0F               RRCA
 420  561F              GET_PAGE_INFO_L3:
 421  561F                  ; page 0
 422  561F 0F               RRCA
 423  5620 0F               RRCA
 424  5621 18 E6            JR GET_PAGE_INFO_L5
 425  5623              ; ****************************************************************************************************
 426  5623
 427  5623              ; ****************************************************************************************************
 428  5623              ; function returns original slot and subslot info
 429  5623              ; input B = 0A8H register value
 430  5623              ; input D = 0 is no subslots, 1 if yes
 431  5623              ; input C = 0A8H value when page 3 slot equals to requested page slot
 432  5623              ; input E = subslot value if present
 433  5623              ; modifies AF, disables interrupts
 434  5623              RESTORE_PAGE_INFO:
 435  5623 7A               LD A, D
 436  5624 B7               OR A
 437  5625 28 08            JR Z, RESTORE_PAGE_INFO_L1
 438  5627 79               LD A, C
 439  5628 F3           	DI
 440  5629 D3 A8            OUT (0A8H), A
 441  562B 7B               LD A, E
 442  562C 32 FF FF         LD (0FFFFH), A
 443  562F              RESTORE_PAGE_INFO_L1:
 444  562F 78               LD A, B
 445  5630 D3 A8            OUT (0A8H), A
 446  5632 C9               RET
 447  5633              ; ****************************************************************************************************
 448  5633
 449  5633              ; *******************************************************************************************************
 450  5633              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 451  5633              ; INPUT:  A = SLOT ID: EXXXSSPP
 452  5633              ; E = EXPANDED FLAG
 453  5633              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 454  5633              ; PP = PRIMARY SLOT NUMBER
 455  5633              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 456  5633              ; CHANGES: AF, BC, DE
 457  5633
 458  5633              LOCAL_ENASLT:
 459  5633 CD 53 56         CALL L0353
 460  5636 FA 40 56         JP M, L0340
 461  5639 DB A8            IN A, (0A8H)
 462  563B A1               AND C
 463  563C B0               OR B
 464  563D D3 A8            OUT (0A8H), A
 465  563F C9               RET
 466  5640              L0340:
 467  5640 E5               PUSH HL
 468  5641 CD 78 56         CALL L0378
 469  5644 4F               LD C, A
 470  5645 06 00            LD B, 0
 471  5647 7D               LD A, L
 472  5648 A4               AND H
 473  5649 B2               OR D
 474  564A 21 C5 FC         LD HL, 0FCC5H
 475  564D 09               ADD HL, BC
 476  564E 77               LD (HL), A
 477  564F E1               POP HL
 478  5650 79               LD A, C
 479  5651 18 E0            JR LOCAL_ENASLT
 480  5653              L0353:
 481  5653 F3               DI
 482  5654 F5               PUSH AF
 483  5655 7C               LD A, H
 484  5656 07               RLCA
 485  5657 07               RLCA
 486  5658 E6 03            AND 3
 487  565A 5F               LD E, A
 488  565B 3E C0            LD A, 0C0H
 489  565D              L035D:
 490  565D 07               RLCA
 491  565E 07               RLCA
 492  565F 1D               DEC E
 493  5660 F2 5D 56         JP P, L035D
 494  5663 5F               LD E, A
 495  5664 2F               CPL
 496  5665 4F               LD C, A
 497  5666 F1               POP AF
 498  5667 F5               PUSH AF
 499  5668 E6 03            AND 3
 500  566A 3C               INC A
 501  566B 47               LD B, A
 502  566C 3E AB            LD A, 0ABH
 503  566E              L036E:
 504  566E C6 55            ADD A, 055H
 505  5670 10 FC            DJNZ L036E
 506  5672 57               LD D, A
 507  5673 A3               AND E
 508  5674 47               LD B, A
 509  5675 F1               POP AF
 510  5676 A7               AND A
 511  5677 C9               RET
 512  5678              L0378:
 513  5678 F5               PUSH AF
 514  5679 7A               LD A, D
 515  567A E6 C0            AND 0C0H
 516  567C 4F               LD C, A
 517  567D F1               POP AF
 518  567E F5               PUSH AF
 519  567F 57               LD D, A
 520  5680 DB A8            IN A, (0A8H)
 521  5682 47               LD B, A
 522  5683 E6 3F            AND 03FH
 523  5685 B1               OR C
 524  5686 D3 A8            OUT (0A8H), A
 525  5688 7A               LD A, D
 526  5689 0F               RRCA
 527  568A 0F               RRCA
 528  568B E6 03            AND 3
 529  568D 57               LD D, A
 530  568E 3E AB            LD A, 0ABH
 531  5690              L0390:
 532  5690 C6 55            ADD A, 055H
 533  5692 15               DEC D
 534  5693 F2 90 56         JP P, L0390
 535  5696 A3               AND E
 536  5697 57               LD D, A
 537  5698 7B               LD A, E
 538  5699 2F               CPL
 539  569A 67               LD H, A
 540  569B 3A FF FF         LD A, (0FFFFH)
 541  569E 2F               CPL
 542  569F 6F               LD L, A
 543  56A0 A4               AND H
 544  56A1 B2               OR D
 545  56A2 32 FF FF         LD (0FFFFH), A
 546  56A5 78               LD A, B
 547  56A6 D3 A8            OUT (0A8H), A
 548  56A8 F1               POP AF
 549  56A9 E6 03            AND 3
 550  56AB C9               RET
 551  56AC              ; *******************************************************************************************************
 552  56AC
 553  56AC              ; *******************************************************************************************************
 554  56AC              ; some common code to activate page 0 and place values needed to restore original page on stack
 555  56AC              ; input IY=return address
 556  56AC              ENABLE_PAGE0:
 557  56AC AF               XOR A
 558  56AD CD EC 55         CALL GET_PAGE_INFO
 559  56B0 C5               PUSH BC
 560  56B1 D5               PUSH DE
 561  56B2 3A 41 F3         LD A, (RAMAD0)
 562  56B5 26 00            LD H, 0
 563  56B7 CD 33 56         CALL LOCAL_ENASLT
 564  56BA FD E9        	JP (IY)
 565  56BC              ; *******************************************************************************************************
 566  56BC
 567  56BC              ; General BASIC CALL-instruction handler
 568  56BC              CALLHAND:
 569  56BC E5           	PUSH HL
 570  56BD 21 61 54     	LD	HL, CMDS ; pointer table based on starting letter
 571  56C0 3A 89 FD         LD A, (PROCNM)
 572  56C3 D6 41            SUB 'A'
 573  56C5 87               ADD A, A
 574  56C6 16 00            LD D, 0
 575  56C8 5F               LD E, A
 576  56C9 19               ADD HL, DE
 577  56CA 5E               LD E, (HL)
 578  56CB 23               INC HL
 579  56CC 56               LD D, (HL)
 580  56CD 7A               LD A, D
 581  56CE B3               OR E
 582  56CF 28 23            JR Z, .CMDNOTRECOGNIZED
 583  56D1 EB               EX DE, HL
 584  56D2              .CHKCMD:
 585  56D2 11 89 FD     	LD	DE, PROCNM
 586  56D5 1A           .LOOP:	LD	A,(DE)
 587  56D6 BE           	CP	(HL)
 588  56D7 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 589  56D9 13           	INC	DE
 590  56DA 23           	INC	HL
 591  56DB A7           	AND	A
 592  56DC 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 593  56DE 5E           	LD	E,(HL)
 594  56DF 23           	INC	HL
 595  56E0 56           	LD	D,(HL)
 596  56E1 E1           	POP	HL		; routine address
 597  56E2 CD 03 57     	CALL	GETPREVCHAR
 598  56E5 CD F7 56     	CALL	.CALLDE		; Call routine
 599  56E8 A7           	AND	A
 600  56E9 C9           	RET
 601  56EA
 602  56EA              .TONEXTCMD:
 603  56EA 0E FF        	LD	C,0FFH
 604  56EC AF           	XOR	A
 605  56ED ED B1        	CPIR			; Skip to end of instruction name
 606  56EF 23           	INC	HL
 607  56F0 23           	INC	HL		; Skip address
 608  56F1 BE           	CP	(HL)
 609  56F2 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 610  56F4              .CMDNOTRECOGNIZED:
 611  56F4 E1           	POP	HL
 612  56F5 37               SCF
 613  56F6 C9           	RET
 614  56F7
 615  56F7              .CALLDE:
 616  56F7 D5           	PUSH	DE
 617  56F8 C9           	RET
 618  56F9
 619  56F9              ;---------------------------
 620  56F9
 621  56F9              ;GETSTRPNT:
 622  56F9              ; OUT:
 623  56F9              ; HL = String Address
 624  56F9              ; B  = Lenght
 625  56F9              ;        LD      HL,(USR)
 626  56F9              ;        LD      B,(HL)
 627  56F9              ;        INC     HL
 628  56F9              ;        LD      E,(HL)
 629  56F9              ;        INC     HL
 630  56F9              ;        LD      D,(HL)
 631  56F9              ;        EX      DE,HL
 632  56F9              ;        RET
 633  56F9
 634  56F9              ;EVALTXTPARAM:
 635  56F9              ;	CALL	CHKCHAR
 636  56F9              ;	DEFB	"("             ; Check for (
 637  56F9              ;	LD	IX,FRMEVL
 638  56F9              ;	CALL	CALBAS		; Evaluate expression
 639  56F9              ;       LD      A,(VALTYP)
 640  56F9              ;        CP      3               ; Text type?
 641  56F9              ;        JP      NZ,TYPE_MISMATCH
 642  56F9              ;        PUSH	HL
 643  56F9              ;        LD	IX,FRESTR         ; Free the temporary string
 644  56F9              ;        CALL	CALBAS
 645  56F9              ;        POP	HL
 646  56F9              ;	CALL	CHKCHAR
 647  56F9              ;	DEFB	")"             ; Check for )
 648  56F9              ;        RET
 649  56F9
 650  56F9
 651  56F9              CHKCHAR:
 652  56F9 CD 03 57     	CALL	GETPREVCHAR	; Get previous basic char
 653  56FC E3           	EX	(SP),HL
 654  56FD BE           	CP	(HL) 	        ; Check if good char
 655  56FE 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 656  5700 23           	INC	HL
 657  5701 E3           	EX	(SP),HL
 658  5702 23           	INC	HL		; Get next basic char
 659  5703
 660  5703              GETPREVCHAR:
 661  5703 2B           	DEC	HL
 662  5704 DD 21 66 46  	LD	IX,CHRGTR
 663  5708 C3 59 01     	JP      CALBAS
 664  570B
 665  570B
 666  570B              TYPE_MISMATCH:
 667  570B 1E 0D            LD E, 13 ; Type mismatch
 668  570D 18 0A            JR THROW_ERROR
 669  570F              SUBSCRIPT_OUT_OF_RANGE:
 670  570F 1E 09            LD E,9 ; subscript out of range
 671  5711 18 06        	JR THROW_ERROR
 672  5713              OVERFLOW:
 673  5713 1E 06        	LD E,6
 674  5715 18 02        	JR THROW_ERROR
 675  5717              SYNTAX_ERROR:
 676  5717 1E 02            LD E, 2 ; Syntax error
 677  5719              THROW_ERROR:
 678  5719 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 679  571D C3 59 01     	JP	CALBAS
 680  5720
 681  5720              ;---------------------------
 682  5720
 683  5720               IF (RAM_CMDS == 1)
 684  5720              ; *******************************************************************************************************
 685  5720              ; function to handle CALL MEMCPY basic extension
 686  5720              ; _MEMCPY ( INT source,
 687  5720              ;			INT destination,
 688  5720              ;			INT count,
 689  5720              ; will put ram in page 0 also, page 1 is already there
 690  5720              MEMCPY:
 691  5720              	; opening (
 692  5720 CD F9 56     	CALL CHKCHAR
 693  5723 28           	DB '('
 694  5724              	; get source address
 695  5724 DD 21 2F 54  	LD IX, FRMQNT
 696  5728 CD 59 01     	CALL CALBAS
 697  572B D5           	PUSH DE
 698  572C              	; comma
 699  572C CD F9 56     	CALL CHKCHAR
 700  572F 2C           	DB ','
 701  5730              	; get destination address
 702  5730 DD 21 2F 54  	LD IX, FRMQNT
 703  5734 CD 59 01     	CALL CALBAS
 704  5737 D5           	PUSH DE
 705  5738              	; comma
 706  5738 CD F9 56     	CALL CHKCHAR
 707  573B 2C           	DB ','
 708  573C              	; get length
 709  573C DD 21 2F 54  	LD IX, FRMQNT
 710  5740 CD 59 01     	CALL CALBAS
 711  5743 D5           	PUSH DE
 712  5744              	; ending )
 713  5744 CD F9 56     	CALL CHKCHAR
 714  5747 29           	DB ')'
 715  5748
 716  5748              	; save position
 717  5748 E5           	PUSH HL
 718  5749 DD E1        	POP IX
 719  574B
 720  574B C1           	POP BC ; count
 721  574C D1           	POP DE ; destination
 722  574D E1           	POP HL ; source
 723  574E D9           	EXX
 724  574F              	; enable page 0
 725  574F FD 21 56 57  	LD IY, .RET
 726  5753 C3 AC 56     	JP ENABLE_PAGE0
 727  5756              .RET:
 728  5756 FB           	EI
 729  5757 D9           	EXX
 730  5758 ED B0        	LDIR
 731  575A D1               POP DE
 732  575B C1               POP BC
 733  575C CD 23 56         CALL RESTORE_PAGE_INFO
 734  575F DD E5        	PUSH IX
 735  5761 E1           	POP HL
 736  5762 C9           	RET
 737  5763              ; *******************************************************************************************************
 738  5763               ENDIF
 739  5763
 740  5763               IF (VRAM_CMDS == 1)
 741  5763              ; *******************************************************************************************************
 742  5763              ; function to handle CALL FILVRM basic extension
 743  5763              ; FILVRM ( INT offset,
 744  5763              ;		   INT count,
 745  5763              ;		   BYTE value,
 746  5763              ;		   BYTE wait_vsync) >0 = true
 747  5763              ; wait_vsync will issue HALT before copying
 748  5763              FILVRM:
 749  5763              	; opening (
 750  5763 CD F9 56     	CALL CHKCHAR
 751  5766 28           	DB '('
 752  5767              	; get offset address
 753  5767 DD 21 2F 54  	LD IX, FRMQNT
 754  576B CD 59 01     	CALL CALBAS
 755  576E D5           	PUSH DE
 756  576F              	; comma
 757  576F CD F9 56     	CALL CHKCHAR
 758  5772 2C           	DB ','
 759  5773              	; get count
 760  5773 DD 21 2F 54  	LD IX, FRMQNT
 761  5777 CD 59 01     	CALL CALBAS
 762  577A D5           	PUSH DE
 763  577B              	; comma
 764  577B CD F9 56     	CALL CHKCHAR
 765  577E 2C           	DB ','
 766  577F              	; get value
 767  577F DD 21 1C 52  	LD IX, GETBYT
 768  5783 CD 59 01     	CALL CALBAS
 769  5786 F5           	PUSH AF
 770  5787              	; comma
 771  5787 CD F9 56     	CALL CHKCHAR
 772  578A 2C           	DB ','
 773  578B              	; get vsync wait
 774  578B DD 21 1C 52  	LD IX, GETBYT
 775  578F CD 59 01     	CALL CALBAS
 776  5792 F5           	PUSH AF
 777  5793              	; ending )
 778  5793 CD F9 56     	CALL CHKCHAR
 779  5796 29           	DB ')'
 780  5797
 781  5797 FB               EI
 782  5798              	; save position
 783  5798 E5           	PUSH HL
 784  5799 DD E1        	POP IX
 785  579B
 786  579B              	; syntax ok
 787  579B              	; wait for vsync if needed
 788  579B F1           	POP AF
 789  579C B7           	OR A
 790  579D 28 01        	JR Z, .L1
 791  579F 76           	HALT
 792  57A0
 793  57A0              .L1:
 794  57A0 F1               POP AF ; value
 795  57A1 C1               POP BC ; count
 796  57A2 E1               POP HL ; offset
 797  57A3 3E 01        	LD A,1
 798  57A5 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
 799  57A8 CD 56 00         CALL BIOS_FILVRM
 800  57AB AF           	XOR A
 801  57AC 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
 802  57AF
 803  57AF              .L3:
 804  57AF DD E5        	PUSH IX
 805  57B1 E1           	POP HL
 806  57B2 C9           	RET
 807  57B3              ; *******************************************************************************************************
 808  57B3               ENDIF
 809  57B3
 810  57B3               IF (RAM_CMDS == 1)
 811  57B3              ; *******************************************************************************************************
 812  57B3              ; function to handle CALL FILRAM basic extension
 813  57B3              ; FILRAM ( INT start address,
 814  57B3              ;		   INT count,
 815  57B3              ;		   BYTE value,
 816  57B3              ; will put ram in page 0 also, page 1 is already there
 817  57B3              FILRAM:
 818  57B3              	; opening (
 819  57B3 CD F9 56     	CALL CHKCHAR
 820  57B6 28           	DB '('
 821  57B7              	; get start address
 822  57B7 DD 21 2F 54  	LD IX, FRMQNT
 823  57BB CD 59 01     	CALL CALBAS
 824  57BE D5           	PUSH DE
 825  57BF              	; comma
 826  57BF CD F9 56     	CALL CHKCHAR
 827  57C2 2C           	DB ','
 828  57C3              	; get count
 829  57C3 DD 21 2F 54  	LD IX, FRMQNT
 830  57C7 CD 59 01     	CALL CALBAS
 831  57CA D5           	PUSH DE
 832  57CB              	; comma
 833  57CB CD F9 56     	CALL CHKCHAR
 834  57CE 2C           	DB ','
 835  57CF              	; get value
 836  57CF DD 21 1C 52  	LD IX, GETBYT
 837  57D3 CD 59 01     	CALL CALBAS
 838  57D6 F5           	PUSH AF
 839  57D7              	; ending )
 840  57D7 CD F9 56     	CALL CHKCHAR
 841  57DA 29           	DB ')'
 842  57DB
 843  57DB              	; save position
 844  57DB E5           	PUSH HL
 845  57DC DD E1        	POP IX
 846  57DE
 847  57DE D1           	POP DE ; actually AF
 848  57DF C1           	POP BC ; count
 849  57E0 E1           	POP HL ; start address
 850  57E1 78           	LD A, B
 851  57E2 B7           	OR A
 852  57E3 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 853  57E5 B1           	OR C
 854  57E6 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 855  57E8 79           	LD A, C
 856  57E9 3D           	DEC A
 857  57EA 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 858  57EC              	; one byte to fill
 859  57EC 72           	LD (HL), D
 860  57ED 18 12        	JR .EXIT
 861  57EF              .L1:
 862  57EF D9           	EXX
 863  57F0              	; enable page 0
 864  57F0 FD 21 F7 57  	LD IY, .RET
 865  57F4 C3 AC 56     	JP ENABLE_PAGE0
 866  57F7              .RET:
 867  57F7 FB           	EI
 868  57F8 D9           	EXX
 869  57F9 CD 05 58     	CALL .FILLVALUE
 870  57FC D1               POP DE
 871  57FD C1               POP BC
 872  57FE CD 23 56         CALL RESTORE_PAGE_INFO
 873  5801              .EXIT:
 874  5801 DD E5        	PUSH IX
 875  5803 E1           	POP HL
 876  5804 C9           	RET
 877  5805
 878  5805              .FILLVALUE:
 879  5805 72               LD (HL), D
 880  5806 54               LD D, H
 881  5807 5D               LD E, L
 882  5808 13               INC DE
 883  5809 0B               DEC BC
 884  580A ED B0            LDIR
 885  580C C9               RET
 886  580D              ; *******************************************************************************************************
 887  580D               ENDIF
 888  580D
 889  580D               IF (GENCAL_CMD == 1)
 890  580D              ; *******************************************************************************************************
 891  580D              ; function to handle CALL GENCAL basic extension
 892  580D              ; GENCAL ( INT fn_addr, = address of the function to call
 893  580D              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 894  580D              ; output values of reristers will also be stored at reg_list_ptr
 895  580D              GENCAL_VAR_SP:
 896  580D 00 00            DW 0
 897  580F              GENCAL_VAR_SP2:
 898  580F 00 00            DW 0
 899  5811              GENCAL:
 900  5811              	; opening (
 901  5811 CD F9 56     	CALL CHKCHAR
 902  5814 28           	DB '('
 903  5815              	; get function address
 904  5815 DD 21 2F 54  	LD IX, FRMQNT
 905  5819 CD 59 01     	CALL CALBAS
 906  581C D5           	PUSH DE
 907  581D              	; comma
 908  581D CD F9 56     	CALL CHKCHAR
 909  5820 2C           	DB ','
 910  5821              	; get pointer to register list
 911  5821 DD 21 2F 54  	LD IX, FRMQNT
 912  5825 CD 59 01     	CALL CALBAS
 913  5828 D5           	PUSH DE
 914  5829              	; ending )
 915  5829 CD F9 56     	CALL CHKCHAR
 916  582C 29           	DB ')'
 917  582D
 918  582D              	; save BASIC token position
 919  582D E5           	PUSH HL
 920  582E D9               EXX
 921  582F E1           	POP HL ; HL'=next basic token
 922  5830 D9               EXX
 923  5831
 924  5831 E1               POP HL ; get pointer to register values
 925  5832 F3           	DI
 926  5833 ED 73 0D 58      LD (GENCAL_VAR_SP), SP
 927  5837 F9               LD SP, HL
 928  5838 F1               POP AF
 929  5839 C1               POP BC
 930  583A D1               POP DE
 931  583B E1               POP HL
 932  583C DD E1            POP IX
 933  583E FD E1            POP IY
 934  5840 D9               EXX
 935  5841 ED 73 0F 58      LD (GENCAL_VAR_SP2), SP
 936  5845 ED 7B 0D 58      LD SP, (GENCAL_VAR_SP)
 937  5849 FB               EI
 938  584A D1               POP DE ; get function to call
 939  584B E5               PUSH HL
 940  584C CD 67 58         CALL .EXXDECALL
 941  584F F3               DI
 942  5850 ED 73 0D 58      LD (GENCAL_VAR_SP), SP
 943  5854 ED 7B 0F 58      LD SP, (GENCAL_VAR_SP2)
 944  5858 FD E5            PUSH IY
 945  585A DD E5            PUSH IX
 946  585C E5               PUSH HL
 947  585D D5               PUSH DE
 948  585E C5               PUSH BC
 949  585F F5               PUSH AF
 950  5860 ED 7B 0D 58      LD SP, (GENCAL_VAR_SP)
 951  5864 FB               EI
 952  5865 E1               POP HL
 953  5866 C9           	RET
 954  5867
 955  5867              .EXXDECALL:
 956  5867 D5               PUSH DE
 957  5868 D9               EXX
 958  5869 C9               RET
 959  586A              ; *******************************************************************************************************
 960  586A               ENDIF
 961  586A
 962  586A               IF (VRAM_CMDS == 1)
 963  586A              ; *******************************************************************************************************
 964  586A              ; function to handle CALL MEMVRM basic extension
 965  586A              ; copies from RAM to VRAM
 966  586A              ; _MEMVRM ( INT source,
 967  586A              ;			INT destination,
 968  586A              ;			INT count,
 969  586A              ;			BYTE wait_vsync) >0 = true
 970  586A              ; will put ram in page 0 also, page 1 is already there
 971  586A              ; wait_vsync will issue HALT before copying
 972  586A              MEMVRM:
 973  586A              	; opening (
 974  586A CD F9 56     	CALL CHKCHAR
 975  586D 28           	DB '('
 976  586E              	; get source address
 977  586E DD 21 2F 54  	LD IX, FRMQNT
 978  5872 CD 59 01     	CALL CALBAS
 979  5875 D5           	PUSH DE
 980  5876              	; comma
 981  5876 CD F9 56     	CALL CHKCHAR
 982  5879 2C           	DB ','
 983  587A              	; get destination address
 984  587A DD 21 2F 54  	LD IX, FRMQNT
 985  587E CD 59 01     	CALL CALBAS
 986  5881 D5           	PUSH DE
 987  5882              	; comma
 988  5882 CD F9 56     	CALL CHKCHAR
 989  5885 2C           	DB ','
 990  5886              	; get length
 991  5886 DD 21 2F 54  	LD IX, FRMQNT
 992  588A CD 59 01     	CALL CALBAS
 993  588D D5           	PUSH DE
 994  588E              	; comma
 995  588E CD F9 56     	CALL CHKCHAR
 996  5891 2C           	DB ','
 997  5892              	; get vsync wait
 998  5892 DD 21 1C 52  	LD IX, GETBYT
 999  5896 CD 59 01     	CALL CALBAS
1000  5899 F5           	PUSH AF
1001  589A              	; ending )
1002  589A CD F9 56     	CALL CHKCHAR
1003  589D 29           	DB ')'
1004  589E
1005  589E                  ; save position in BASIC text
1006  589E E5           	PUSH HL
1007  589F DD E1        	POP IX
1008  58A1
1009  58A1 F1           	POP AF ; wait vsync
1010  58A2 B7           	OR A
1011  58A3 28 03        	JR Z, .L1
1012  58A5 FB               EI
1013  58A6 76           	HALT
1014  58A7 F3           	DI
1015  58A8              .L1:
1016  58A8              	; pop LDIR parameters and store away for later
1017  58A8 C1           	POP BC ; count
1018  58A9 D1           	POP DE ; vram destination
1019  58AA E1           	POP HL ; ram source
1020  58AB D9           	EXX
1021  58AC FD 21 B3 58   	LD IY, .RET
1022  58B0 C3 AC 56     	JP ENABLE_PAGE0
1023  58B3              .RET:
1024  58B3 FB           	EI
1025  58B4 D9           	EXX
1026  58B5 3E 01        	LD A,1
1027  58B7 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1028  58BA CD CA 58     	CALL .LDIRVM
1029  58BD AF           	XOR A
1030  58BE 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1031  58C1 D1               POP DE
1032  58C2 C1               POP BC
1033  58C3 CD 23 56         CALL RESTORE_PAGE_INFO
1034  58C6 DD E5        	PUSH IX
1035  58C8 E1           	POP HL
1036  58C9 C9           	RET
1037  58CA
1038  58CA              .LDIRVM:
1039  58CA EB           	EX DE, HL
1040  58CB F3           	DI
1041  58CC CD D5 55     	CALL SETWRT_LOCAL
1042  58CF FB           	EI
1043  58D0 EB           	EX DE, HL
1044  58D1 78           	LD A, B
1045  58D2 B7           	OR A
1046  58D3 28 0D        	JR Z, .L3
1047  58D5 C5           	PUSH BC
1048  58D6 0E 98        	LD C, #98
1049  58D8              .L2:
1050  58D8 50           	LD D, B
1051  58D9 06 00        	LD B, 0
1052  58DB CD E0 55     	CALL BBYTECOPY
1053  58DE 42           	LD B, D
1054  58DF 10 F7        	DJNZ .L2
1055  58E1 C1           	POP BC
1056  58E2              .L3:
1057  58E2 79           	LD A, C
1058  58E3 B7           	OR A
1059  58E4 C8           	RET Z
1060  58E5 41           	LD B, C
1061  58E6 0E 98        	LD C, #98
1062  58E8 C3 E0 55     	JP BBYTECOPY
1063  58EB              ; *******************************************************************************************************
1064  58EB               ENDIF
1065  58EB
1066  58EB               IF (VRAM_CMDS == 1)
1067  58EB              ; *******************************************************************************************************
1068  58EB              ; function to handle CALL VRMMEM basic extension
1069  58EB              ; copies from RAM to VRAM
1070  58EB              ; _VRMMEM ( INT source,
1071  58EB              ;			INT destination,
1072  58EB              ;			INT count
1073  58EB              ; will put ram in page 0 also, page 1 is already there
1074  58EB              VRMMEM:
1075  58EB              	; opening (
1076  58EB CD F9 56     	CALL CHKCHAR
1077  58EE 28           	DB '('
1078  58EF              	; get source address
1079  58EF DD 21 2F 54  	LD IX, FRMQNT
1080  58F3 CD 59 01     	CALL CALBAS
1081  58F6 D5           	PUSH DE
1082  58F7              	; comma
1083  58F7 CD F9 56     	CALL CHKCHAR
1084  58FA 2C           	DB ','
1085  58FB              	; get destination address
1086  58FB DD 21 2F 54  	LD IX, FRMQNT
1087  58FF CD 59 01     	CALL CALBAS
1088  5902 D5           	PUSH DE
1089  5903              	; comma
1090  5903 CD F9 56     	CALL CHKCHAR
1091  5906 2C           	DB ','
1092  5907              	; get length
1093  5907 DD 21 2F 54  	LD IX, FRMQNT
1094  590B CD 59 01     	CALL CALBAS
1095  590E D5           	PUSH DE
1096  590F              	; ending )
1097  590F CD F9 56     	CALL CHKCHAR
1098  5912 29           	DB ')'
1099  5913
1100  5913                  ; save position in BASIC text
1101  5913 E5           	PUSH HL
1102  5914 DD E1        	POP IX
1103  5916
1104  5916 C1           	POP BC ; count
1105  5917 D1           	POP DE ; destination
1106  5918 E1           	POP HL ; source
1107  5919 D9           	EXX
1108  591A FD 21 21 59  	LD IY, .RET
1109  591E C3 AC 56     	JP ENABLE_PAGE0
1110  5921              .RET:
1111  5921 FB           	EI
1112  5922 D9           	EXX
1113  5923 3E 01        	LD A,1
1114  5925 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1115  5928 CD 38 59     	CALL .LDIRMV
1116  592B AF           	XOR A
1117  592C 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1118  592F D1               POP DE
1119  5930 C1               POP BC
1120  5931 CD 23 56         CALL RESTORE_PAGE_INFO
1121  5934 DD E5        	PUSH IX
1122  5936 E1           	POP HL
1123  5937 C9           	RET
1124  5938
1125  5938              .LDIRMV:
1126  5938              	; set VRAM address *exactly* as in ROM, otherwise corruption
1127  5938 7D           	LD	A, L
1128  5939 F3           	DI
1129  593A D3 99        	OUT	(099H), A
1130  593C 7C           	LD	A, H
1131  593D E6 3F        	AND	03FH
1132  593F D3 99        	OUT	(099H), A
1133  5941 FB           	EI
1134  5942              	;EX (SP), HL
1135  5942              	;EX (SP), HL
1136  5942              	;NOP
1137  5942              	;NOP
1138  5942              .L4:
1139  5942 DB 98            IN A, (#98)
1140  5944 12           	LD (DE), A
1141  5945 13               INC DE
1142  5946 0B               DEC BC
1143  5947 79               LD A, C
1144  5948 B0               OR B
1145  5949 20 F7            JR NZ, .L4
1146  594B C9               RET
1147  594C              ; *******************************************************************************************************
1148  594C               ENDIF
1149  594C
1150  594C               IF (SOUND_CMDS == 1)
1151  594C              ; *******************************************************************************************************
1152  594C              ; function to handle CALL SNDPLYINIT basic extension
1153  594C              ; initializes sound player
1154  594C              ; _SNDPLYINIT ( INT music_offset,
1155  594C              ;				INT sfx_offset, can be -1 if no SFX
1156  594C              ; will put ram in page 0 also, page 1 is already there
1157  594C              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1158  594C              SNDPLYINIT:
1159  594C              	; opening (
1160  594C CD F9 56     	CALL CHKCHAR
1161  594F 28           	DB '('
1162  5950              	; get music address
1163  5950 DD 21 2F 54  	LD IX, FRMQNT
1164  5954 CD 59 01     	CALL CALBAS
1165  5957 D5           	PUSH DE
1166  5958              	; comma
1167  5958 CD F9 56     	CALL CHKCHAR
1168  595B 2C           	DB ','
1169  595C              	; get sfx address
1170  595C DD 21 2F 54  	LD IX, FRMQNT
1171  5960 CD 59 01     	CALL CALBAS
1172  5963 D5           	PUSH DE
1173  5964              	; ending )
1174  5964 CD F9 56     	CALL CHKCHAR
1175  5967 29           	DB ')'
1176  5968
1177  5968                  ; save position in BASIC text
1178  5968 44           	LD B, H
1179  5969 4D           	LD C, L
1180  596A
1181  596A              	; pop LDIR parameters and store away for later
1182  596A D1           	POP DE ; sfx address
1183  596B E1           	POP HL ; music address
1184  596C C5           	PUSH BC ; basic text location
1185  596D D9           	EXX
1186  596E FD 21 75 59  	LD IY, .RET
1187  5972 C3 AC 56     	JP ENABLE_PAGE0
1188  5975              .RET:
1189  5975 D9           	EXX
1190  5976
1191  5976 D5           	PUSH DE
1192  5977 AF           	XOR A
1193  5978              	; HL = music location
1194  5978 CD 62 41     	CALL PLY_AKG_INIT
1195  597B 3E 01        	LD A, 1
1196  597D 32 7A 4D     	LD (MUSIC_INIT_STATUS), A
1197  5980
1198  5980 E1           	POP HL ; SFX
1199  5981              	; check if SFX address -1
1200  5981 23           	INC HL
1201  5982 7D           	LD A, L
1202  5983 B4           	OR H
1203  5984 28 09        	JR Z,.L1
1204  5986 2B           	DEC HL
1205  5987 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1206  598A 3E 01        	LD A, 1
1207  598C 32 7B 4D     	LD (SFX_INIT_STATUS), A
1208  598F              .L1:
1209  598F D1               POP DE
1210  5990 C1               POP BC
1211  5991 CD 23 56         CALL RESTORE_PAGE_INFO
1212  5994
1213  5994 E1           	POP HL
1214  5995 C9           	RET
1215  5996              ; *******************************************************************************************************
1216  5996
1217  5996              ; *******************************************************************************************************
1218  5996              ; function to handle CALL SNDPLYON basic extension
1219  5996              ; enables sound player
1220  5996              ; _SNDPLYON
1221  5996              ; sets SOUND_ENABLED variable to 1 if init call was done
1222  5996              ; if not throws out of data error
1223  5996              SNDPLYON:
1224  5996 3A 7A 4D     	LD A, (MUSIC_INIT_STATUS)
1225  5999 B7           	OR A
1226  599A 20 05        	JR NZ, .L1
1227  599C              	; player not initialized, throw error
1228  599C 1E 04        	LD E, 04 ; Out of DATA
1229  599E C3 19 57     	JP THROW_ERROR
1230  59A1              .L1:
1231  59A1 32 7C 4D     	LD (SOUND_ENABLED), A
1232  59A4              	; disable key click
1233  59A4 AF           	XOR A
1234  59A5 32 DB F3     	LD (CLIKSW), A
1235  59A8 C9           	RET
1236  59A9              ; *******************************************************************************************************
1237  59A9
1238  59A9              ; *******************************************************************************************************
1239  59A9              ; function to handle CALL SNDPLYOFF basic extension
1240  59A9              ; disables sound player
1241  59A9              ; _SNDPLYOFF
1242  59A9              ; sets SOUND_ENABLED variable to 0
1243  59A9              ; calls AKG to stop music and SFX on all channels if initialized
1244  59A9              SNDPLYOFF:
1245  59A9 3A 7C 4D     	LD A, (SOUND_ENABLED)
1246  59AC B7           	OR A
1247  59AD C8           	RET Z ; already stopped
1248  59AE AF           	XOR A
1249  59AF 32 7C 4D     	LD (SOUND_ENABLED), A
1250  59B2 E5           	PUSH HL
1251  59B3 CD 21 42     	CALL PLY_AKG_STOP
1252  59B6 3A 7B 4D     	LD A, (SFX_INIT_STATUS)
1253  59B9 B7           	OR A
1254  59BA 28 0E        	JR Z, .EXIT ; SFX not in use
1255  59BC AF           	XOR A
1256  59BD CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1257  59C0 3E 01        	LD A, 1
1258  59C2 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1259  59C5 3E 02        	LD A, 2
1260  59C7 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1261  59CA              .EXIT:
1262  59CA E1           	POP HL
1263  59CB C9           	RET
1264  59CC              ; *******************************************************************************************************
1265  59CC
1266  59CC              ; *******************************************************************************************************
1267  59CC              ; function to handle CALL SNDSFX basic extension
1268  59CC              ; plays a sound effect
1269  59CC              ; _SNDSFX ( BYTE sfx_number, >0
1270  59CC              ;			BYTE channel, = 0,1 or 2
1271  59CC              ;			BYTE inverted_volume = 0-16, 0 being full volume
1272  59CC              ; will put ram in page 0 also, page 1 is already there
1273  59CC              ; if sound off throws illegal function call
1274  59CC              ; if sfx not initialized, throws out of data
1275  59CC              SNDSFX:
1276  59CC              	; opening (
1277  59CC CD F9 56     	CALL CHKCHAR
1278  59CF 28           	DB '('
1279  59D0              	; get sfx_number
1280  59D0 DD 21 1C 52  	LD IX, GETBYT
1281  59D4 CD 59 01     	CALL CALBAS
1282  59D7 D5           	PUSH DE
1283  59D8              	; comma
1284  59D8 CD F9 56     	CALL CHKCHAR
1285  59DB 2C           	DB ','
1286  59DC              	; get sfx address
1287  59DC DD 21 1C 52  	LD IX, GETBYT
1288  59E0 CD 59 01     	CALL CALBAS
1289  59E3 D5           	PUSH DE
1290  59E4              	; comma
1291  59E4 CD F9 56     	CALL CHKCHAR
1292  59E7 2C           	DB ','
1293  59E8              	; get inverted volume
1294  59E8 DD 21 1C 52  	LD IX, GETBYT
1295  59EC CD 59 01     	CALL CALBAS
1296  59EF D5           	PUSH DE
1297  59F0              	; ending )
1298  59F0 CD F9 56     	CALL CHKCHAR
1299  59F3 29           	DB ')'
1300  59F4
1301  59F4 3A 7C 4D     	LD A, (SOUND_ENABLED)
1302  59F7 B7           	OR A
1303  59F8 20 05        	JR NZ, .L1
1304  59FA              	; sound disabled, throw illegal function call
1305  59FA 1E 05        	LD E, 5
1306  59FC C3 19 57     	JP THROW_ERROR
1307  59FF              .L1:
1308  59FF 3A 7B 4D     	LD A, (SFX_INIT_STATUS)
1309  5A02 B7           	OR A
1310  5A03 20 05        	JR NZ, .L2
1311  5A05              	; sfx data not initialized, throw out of data
1312  5A05 1E 04        	LD E, 4
1313  5A07 C3 19 57     	JP THROW_ERROR
1314  5A0A              .L2:
1315  5A0A              	; pop  parameters and store away for later
1316  5A0A D1           	POP DE ; inverted volume
1317  5A0B 43           	LD B, E
1318  5A0C D1           	POP DE ; channel
1319  5A0D 4B           	LD C, E
1320  5A0E D1           	POP DE
1321  5A0F 7B           	LD A, E
1322  5A10 08           	EX AF, AF'
1323  5A11 E5           	PUSH HL ; basic text location
1324  5A12 D9           	EXX
1325  5A13 FD 21 1A 5A  	LD IY, .RET
1326  5A17 C3 AC 56     	JP ENABLE_PAGE0
1327  5A1A              .RET:
1328  5A1A D9           	EXX
1329  5A1B 08           	EX AF, AF'
1330  5A1C CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1331  5A1F
1332  5A1F D1               POP DE
1333  5A20 C1               POP BC
1334  5A21 CD 23 56         CALL RESTORE_PAGE_INFO
1335  5A24
1336  5A24 E1           	POP HL
1337  5A25 C9           	RET
1338  5A26              ; *******************************************************************************************************
1339  5A26               ENDIF
1340  5A26
1341  5A26               IF (BLIT_CMDS == 1)
1342  5A26              ; *******************************************************************************************************
1343  5A26              ; function rotates mask and data of several characters and applies to background data
1344  5A26              ; this handles x-shift from 0 to 4
1345  5A26              ; contains self-modifying code that is set-up from external function
1346  5A26              ; input HL=pointer to mask data
1347  5A26              ; input HL'=pointer to character data
1348  5A26              ; input DE=output buffer containing background data
1349  5A26              ; input BC=DE+8
1350  5A26              ; input A=number of characters to process
1351  5A26              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1352  5A26              SHIFT04:
1353  5A26 08           	EX AF, AF'
1354  5A27 7E           	LD A, (HL) ; get mask
1355  5A28 D9           	EXX
1356  5A29 57           	LD D, A
1357  5A2A 1E FF        	LD E, #FF
1358  5A2C 37           	SCF
1359  5A2D              .M1:
1360  5A2D 18 FE        	JR .M1 ; this is self-modifying part
1361  5A2F CB 1A        	RR D
1362  5A31 CB 1B        	RR E
1363  5A33 CB 1A        	RR D
1364  5A35 CB 1B        	RR E
1365  5A37 CB 1A        	RR D
1366  5A39 CB 1B        	RR E
1367  5A3B CB 1A        	RR D
1368  5A3D CB 1B        	RR E
1369  5A3F
1370  5A3F 46           	LD B, (HL) ; get data
1371  5A40 0E 00        	LD C, 0
1372  5A42              .M2:
1373  5A42 18 FE        	JR .M2 ; also self-modifying part
1374  5A44 CB 38        	SRL B
1375  5A46 CB 19        	RR C
1376  5A48 CB 38        	SRL B
1377  5A4A CB 19        	RR C
1378  5A4C CB 38        	SRL B
1379  5A4E CB 19        	RR C
1380  5A50 CB 38        	SRL B
1381  5A52 CB 19        	RR C
1382  5A54
1383  5A54 D9           	EXX
1384  5A55 1A           	LD A, (DE) ; background
1385  5A56 D9           	EXX
1386  5A57 A2           	AND D
1387  5A58 B0           	OR B
1388  5A59 D9           	EXX
1389  5A5A 12           	LD (DE), A
1390  5A5B
1391  5A5B 0A           	LD A, (BC)
1392  5A5C D9           	EXX
1393  5A5D A3           	AND E
1394  5A5E B1           	OR C
1395  5A5F 23           	INC HL
1396  5A60 D9           	EXX
1397  5A61 02           	LD (BC), A
1398  5A62
1399  5A62 23           	INC HL
1400  5A63 13           	INC DE
1401  5A64 03           	INC BC
1402  5A65
1403  5A65 08           	EX AF, AF'
1404  5A66 3D           	DEC A
1405  5A67 C2 26 5A     	JP NZ, SHIFT04
1406  5A6A C9           	RET
1407  5A6B              ; *******************************************************************************************************
1408  5A6B
1409  5A6B              ; *******************************************************************************************************
1410  5A6B              ; function rotates mask and data of several characters and applies to background data
1411  5A6B              ; this handles x-shift from 5 to 8
1412  5A6B              ; contains self-modifying code that is set-up from external function
1413  5A6B              ; input HL=pointer to mask data
1414  5A6B              ; input HL'=pointer to character data
1415  5A6B              ; input DE=output buffer containing background data
1416  5A6B              ; input BC=DE+8
1417  5A6B              ; input A=number of characters to process
1418  5A6B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1419  5A6B              SHIFT58:
1420  5A6B 08           	EX AF, AF'
1421  5A6C 7E           	LD A, (HL) ; get mask
1422  5A6D D9           	EXX
1423  5A6E 57           	LD D, A
1424  5A6F 1E FF        	LD E, #FF
1425  5A71 37           	SCF
1426  5A72              .M1:
1427  5A72 18 FE        	JR .M1 ; this is self-modifying part
1428  5A74 CB 12        	RL D
1429  5A76 CB 13        	RL E
1430  5A78 CB 12        	RL D
1431  5A7A CB 13        	RL E
1432  5A7C CB 12        	RL D
1433  5A7E CB 13        	RL E
1434  5A80
1435  5A80 46           	LD B, (HL)
1436  5A81 0E 00        	LD C, 0
1437  5A83              .M2:
1438  5A83 18 FE        	JR .M2 ; also self-modifying part
1439  5A85 CB 20        	SLA B
1440  5A87 CB 11        	RL C
1441  5A89 CB 20        	SLA B
1442  5A8B CB 11        	RL C
1443  5A8D CB 20        	SLA B
1444  5A8F CB 11        	RL C
1445  5A91
1446  5A91 D9           	EXX
1447  5A92 1A           	LD A, (DE) ; background
1448  5A93 D9           	EXX
1449  5A94 A3           	AND E
1450  5A95 B1           	OR C
1451  5A96 D9           	EXX
1452  5A97 12           	LD (DE), A
1453  5A98
1454  5A98 0A           	LD A, (BC)
1455  5A99 D9           	EXX
1456  5A9A A2           	AND D
1457  5A9B B0           	OR B
1458  5A9C 23           	INC HL
1459  5A9D D9           	EXX
1460  5A9E 02           	LD (BC), A
1461  5A9F
1462  5A9F 23           	INC HL
1463  5AA0 13           	INC DE
1464  5AA1 03           	INC BC
1465  5AA2
1466  5AA2 08           	EX AF, AF'
1467  5AA3 3D           	DEC A
1468  5AA4 C2 6B 5A     	JP NZ, SHIFT58
1469  5AA7 C9           	RET
1470  5AA8              ; *******************************************************************************************************
1471  5AA8
1472  5AA8              ; *******************************************************************************************************
1473  5AA8              ; routine that shifts one row of characters
1474  5AA8              ; contains self-modifying code that is set-up from external function
1475  5AA8              ; input HL=pointer to mask data
1476  5AA8              ; input HL'=pointer to character data
1477  5AA8              ; input DE=output buffer containing background data
1478  5AA8              ; input A=number of characters to process
1479  5AA8              ; input IX=pointer to structure describing input data
1480  5AA8              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1481  5AA8              SHIFT_ROW:
1482  5AA8 F5           	PUSH AF
1483  5AA9 ED 53 4B 54  		LD (BLIT_TMP1), DE
1484  5AAD E5           		PUSH HL
1485  5AAE CD F1 5A     			CALL .ADDYSHIFT
1486  5AB1 E1           		POP HL
1487  5AB2 ED 53 4D 54  		LD (BLIT_TMP2), DE ; DE+vertical shift
1488  5AB6              .L1:
1489  5AB6 3E 08        		LD A, 8
1490  5AB8 DD 96 02     		SUB (IX+2) ; y shift
1491  5ABB              .CALL1:
1492  5ABB CD 00 00     		CALL 0
1493  5ABE DD 7E 02     		LD A, (IX+2); y shift
1494  5AC1 B7           		OR A
1495  5AC2 28 26        		JR Z, .DONE
1496  5AC4 ED 5B 4B 54  		LD DE, (BLIT_TMP1)
1497  5AC8 E5           		PUSH HL
1498  5AC9 CD FF 5A     			CALL .DETONEXTROW
1499  5ACC E1           		POP HL
1500  5ACD              .CALL2:
1501  5ACD CD 00 00     		CALL 0
1502  5AD0 ED 5B 4B 54  		LD DE, (BLIT_TMP1)
1503  5AD4 E5           		PUSH HL
1504  5AD5 CD F9 5A     			CALL .ADD8
1505  5AD8 E1           		POP HL
1506  5AD9 ED 53 4B 54  		LD (BLIT_TMP1), DE
1507  5ADD ED 5B 4D 54  		LD DE, (BLIT_TMP2)
1508  5AE1 E5           		PUSH HL
1509  5AE2 CD F9 5A     			CALL .ADD8
1510  5AE5 E1           		POP HL
1511  5AE6 ED 53 4D 54  		LD (BLIT_TMP2), DE ; DE+vertical shift
1512  5AEA              .DONE:
1513  5AEA F1           	POP AF
1514  5AEB 3D           	DEC A
1515  5AEC C8           	RET Z
1516  5AED F5           	PUSH AF
1517  5AEE C3 B6 5A     	JP .L1
1518  5AF1              .ADDYSHIFT:
1519  5AF1 EB           	EX DE, HL
1520  5AF2 16 00        	LD D, 0
1521  5AF4 DD 5E 02     	LD E, (IX+2); y shift
1522  5AF7 18 0C        	JR .MOVDEBC
1523  5AF9              .ADD8:
1524  5AF9 21 08 00     	LD HL, 8
1525  5AFC C3 05 5B     	JP .MOVDEBC
1526  5AFF              .DETONEXTROW:
1527  5AFF DD 6E 06     	LD L, (IX+6)
1528  5B02 DD 66 07     	LD H, (IX+7) ; bkg add to value
1529  5B05              .MOVDEBC:
1530  5B05 19           	ADD HL, DE
1531  5B06 54           	LD D, H
1532  5B07 5D           	LD E, L
1533  5B08 01 08 00     	LD BC, 8
1534  5B0B 09           	ADD HL, BC
1535  5B0C 44           	LD B, H
1536  5B0D 4D           	LD C, L
1537  5B0E C9           	RET
1538  5B0F              ; *******************************************************************************************************
1539  5B0F
1540  5B0F              ; *******************************************************************************************************
1541  5B0F              ; function rotates mask and character data and applies it to background
1542  5B0F              ; input IX=pointer to structure describing input data
1543  5B0F              ; +0  DW horizontal shift count 0-7 (low byte used)
1544  5B0F              ; +2  DW vertical shift count 0-7 (low byte used)
1545  5B0F              ; +4  DW background data start;
1546  5B0F              ; +6  DW background add to value to next row of background data
1547  5B0F              ; +8  DW mask data start;
1548  5B0F              ; +10  DW character data start;
1549  5B0F              ; +12 DW character&mask add to value to next row of data
1550  5B0F              ; +14 DW columns (low byte used)
1551  5B0F              ; +16 DW rows (low byte used)
1552  5B0F              SHIFT_MERGE_CHARACTER:
1553  5B0F DD 7E 00     	LD A, (IX) ; shift
1554  5B12 FE 05        	CP 5
1555  5B14 38 25        	JR C, .RIGHT
1556  5B16              	; shifts 5-7, use rotate towards left 1-3
1557  5B16 21 6B 5A     	LD HL, SHIFT58
1558  5B19 22 BC 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1559  5B1C 22 CE 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1560  5B1F D6 05        	SUB 5
1561  5B21 28 0D        	JR Z, .L1
1562  5B23 87           	ADD A, A
1563  5B24 87           	ADD A, A
1564  5B25 67           	LD H, A
1565  5B26 2E 18        	LD L, #18 ; JR opcode
1566  5B28 22 72 5A     	LD (SHIFT58.M1), HL
1567  5B2B 22 83 5A     	LD (SHIFT58.M2), HL
1568  5B2E 18 32        	JR .DO
1569  5B30              .L1:
1570  5B30 21 00 00     	LD HL, 0 ; 2xNOP opcode
1571  5B33 22 72 5A     	LD (SHIFT58.M1), HL
1572  5B36 22 83 5A     	LD (SHIFT58.M2), HL
1573  5B39 18 27        	JR .DO
1574  5B3B              .RIGHT:
1575  5B3B              	; shifts 0-4, rotate towards right
1576  5B3B 21 26 5A     	LD HL, SHIFT04
1577  5B3E 22 BC 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1578  5B41 22 CE 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1579  5B44 FE 04        	CP 4
1580  5B46 28 11        	JR Z, .R1
1581  5B48 D6 04        	SUB 4
1582  5B4A ED 44        	NEG
1583  5B4C 87           	ADD A, A
1584  5B4D 87           	ADD A, A
1585  5B4E 67           	LD H, A
1586  5B4F 2E 18        	LD L, #18 ; JR opcode
1587  5B51 22 2D 5A     	LD (SHIFT04.M1), HL
1588  5B54 22 42 5A     	LD (SHIFT04.M2), HL
1589  5B57 18 09        	JR .DO
1590  5B59              .R1:
1591  5B59 21 00 00     	LD HL, 0 ; 2xNOP opcode
1592  5B5C 22 2D 5A     	LD (SHIFT04.M1), HL
1593  5B5F 22 42 5A     	LD (SHIFT04.M2), HL
1594  5B62              .DO:
1595  5B62 DD 46 10     	LD B, (IX+16) ; rows
1596  5B65 DD 6E 08     	LD L, (IX+8)
1597  5B68 DD 66 09     	LD H, (IX+9) ; mask data
1598  5B6B DD 5E 04     	LD E, (IX+4)
1599  5B6E DD 56 05     	LD D, (IX+5) ; background data
1600  5B71 D9           	EXX
1601  5B72 DD 6E 0A     	LD L, (IX+10)
1602  5B75 DD 66 0B     	LD H, (IX+11) ; character data
1603  5B78 D9           	EXX
1604  5B79              .LOOP:
1605  5B79 C5           	PUSH BC
1606  5B7A E5           		PUSH HL
1607  5B7B D5           			PUSH DE
1608  5B7C D9           				EXX
1609  5B7D E5           				PUSH HL
1610  5B7E D9           					EXX
1611  5B7F DD 7E 0E     					LD A, (IX+14) ; columns
1612  5B82              .CALL:
1613  5B82 CD A8 5A     					CALL SHIFT_ROW
1614  5B85 E1           				POP HL
1615  5B86 DD 5E 0C     				LD E, (IX+12)
1616  5B89 DD 56 0D     				LD D, (IX+13) ; char data to next row
1617  5B8C 19           				ADD HL, DE
1618  5B8D D9           				EXX
1619  5B8E E1           			POP HL
1620  5B8F DD 5E 06     			LD E, (IX+6)
1621  5B92 DD 56 07     			LD D, (IX+7) ; background to next row
1622  5B95 19           			ADD HL, DE
1623  5B96 EB           			EX DE, HL
1624  5B97 E1           		POP HL
1625  5B98 DD 4E 0C     		LD C, (IX+12)
1626  5B9B DD 46 0D     		LD B, (IX+13) ; char data to next row
1627  5B9E 09           		ADD HL, BC
1628  5B9F C1           	POP BC
1629  5BA0 10 D7        	DJNZ .LOOP
1630  5BA2 C9           	RET
1631  5BA3              ; *******************************************************************************************************
1632  5BA3
1633  5BA3               IFNDEF CMDS_WITH_PARAMETERS
1634  5BA3 ~            ; *******************************************************************************************************
1635  5BA3 ~            ; function to handle CALL BLIT basic extension
1636  5BA3 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1637  5BA3 ~            ; fuses with background data and applies vertical shift too
1638  5BA3 ~            ; BLIT ( INT request_data_ptr )
1639  5BA3 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1640  5BA3 ~            ; will put ram in page 0 also, page 1 is already there
1641  5BA3 ~            BLIT:
1642  5BA3 ~            	; opening (
1643  5BA3 ~            	CALL CHKCHAR
1644  5BA3 ~            	DB '('
1645  5BA3 ~            	; get pointer to request struct
1646  5BA3 ~            	LD IX, FRMQNT
1647  5BA3 ~            	CALL CALBAS
1648  5BA3 ~            	PUSH DE
1649  5BA3 ~            	; ending )
1650  5BA3 ~            	CALL CHKCHAR
1651  5BA3 ~            	DB ')'
1652  5BA3 ~
1653  5BA3 ~            	POP IX ; pointer to request struct
1654  5BA3 ~
1655  5BA3 ~            	PUSH HL ; save position in BASIC buffer
1656  5BA3 ~
1657  5BA3 ~            	LD IY, .RET
1658  5BA3 ~            	JP ENABLE_PAGE0
1659  5BA3 ~            .RET:
1660  5BA3 ~            	EI
1661  5BA3 ~            	CALL SHIFT_MERGE_CHARACTER
1662  5BA3 ~
1663  5BA3 ~                POP DE
1664  5BA3 ~                POP BC
1665  5BA3 ~                CALL RESTORE_PAGE_INFO
1666  5BA3 ~
1667  5BA3 ~            	POP HL
1668  5BA3 ~            	RET
1669  5BA3 ~            ; *******************************************************************************************************
1670  5BA3               ENDIF
1671  5BA3
1672  5BA3               IFDEF CMDS_WITH_PARAMETERS
1673  5BA3              ; *******************************************************************************************************
1674  5BA3              ; function to handle CALL BLIT basic extension
1675  5BA3              ; rotates 1-bit character drawing horizontally with mask and character data and
1676  5BA3              ; fuses with background data and applies vertical shift too
1677  5BA3              ; in form without pointers
1678  5BA3              ; BLIT ( INT x,
1679  5BA3              ;		 INT y,
1680  5BA3              ;		 INT char_data_pointer,
1681  5BA3              ;		 INT mask_data_pointer,
1682  5BA3              ;		 INT width (in characters),
1683  5BA3              ;		 INT height (in characters),
1684  5BA3              ;		 INT background_pointer (top left),
1685  5BA3              ;		 INT background_width (in characters),
1686  5BA3              ;		 INT background_height (in characters))
1687  5BA3              ; will put ram in page 0 also, page 1 is already there
1688  5BA3              BLIT:
1689  5BA3              	; opening (
1690  5BA3 CD F9 56     	CALL CHKCHAR
1691  5BA6 28           	DB '('
1692  5BA7              	; get x coordinate
1693  5BA7 DD 21 2F 54  	LD IX, FRMQNT
1694  5BAB CD 59 01     	CALL CALBAS
1695  5BAE 7B           	LD A, E
1696  5BAF E6 07        	AND 7
1697  5BB1 32 4F 54     	LD (BLIT_STRUCT+0), A
1698  5BB4 CD 91 5C     	CALL .DAdiv8
1699  5BB7 32 4B 54     	LD (BLIT_TMP+0),A
1700  5BBA              	; comma
1701  5BBA CD F9 56     	CALL CHKCHAR
1702  5BBD 2C           	DB ','
1703  5BBE              	; get y coordinate
1704  5BBE DD 21 2F 54  	LD IX, FRMQNT
1705  5BC2 CD 59 01     	CALL CALBAS
1706  5BC5 7B           	LD A, E
1707  5BC6 E6 07        	AND 7
1708  5BC8 32 51 54     	LD (BLIT_STRUCT+2), A
1709  5BCB CD 91 5C     	CALL .DAdiv8
1710  5BCE 32 4C 54     	LD (BLIT_TMP+1),A
1711  5BD1              	; comma
1712  5BD1 CD F9 56     	CALL CHKCHAR
1713  5BD4 2C           	DB ','
1714  5BD5              	; get char data pointer
1715  5BD5 DD 21 2F 54  	LD IX, FRMQNT
1716  5BD9 CD 59 01     	CALL CALBAS
1717  5BDC ED 53 59 54  	LD (BLIT_STRUCT+10), DE
1718  5BE0              	; comma
1719  5BE0 CD F9 56     	CALL CHKCHAR
1720  5BE3 2C           	DB ','
1721  5BE4              	; get mask data pointer
1722  5BE4 DD 21 2F 54  	LD IX, FRMQNT
1723  5BE8 CD 59 01     	CALL CALBAS
1724  5BEB ED 53 57 54  	LD (BLIT_STRUCT+8), DE
1725  5BEF              	; comma
1726  5BEF CD F9 56     	CALL CHKCHAR
1727  5BF2 2C           	DB ','
1728  5BF3              	; get width
1729  5BF3 DD 21 2F 54  	LD IX, FRMQNT
1730  5BF7 CD 59 01     	CALL CALBAS
1731  5BFA 7B           	LD A, E
1732  5BFB 32 5D 54     	LD (BLIT_STRUCT+14), A
1733  5BFE              	; comma
1734  5BFE CD F9 56     	CALL CHKCHAR
1735  5C01 2C           	DB ','
1736  5C02              	; get height
1737  5C02 DD 21 2F 54  	LD IX, FRMQNT
1738  5C06 CD 59 01     	CALL CALBAS
1739  5C09 7B           	LD A, E
1740  5C0A 32 5F 54     	LD (BLIT_STRUCT+16), A
1741  5C0D              	; comma
1742  5C0D CD F9 56     	CALL CHKCHAR
1743  5C10 2C           	DB ','
1744  5C11              	; get background pointer
1745  5C11 DD 21 2F 54  	LD IX, FRMQNT
1746  5C15 CD 59 01     	CALL CALBAS
1747  5C18 ED 53 53 54  	LD (BLIT_STRUCT+4), DE
1748  5C1C              	; comma
1749  5C1C CD F9 56     	CALL CHKCHAR
1750  5C1F 2C           	DB ','
1751  5C20              	; get background width
1752  5C20 DD 21 2F 54  	LD IX, FRMQNT
1753  5C24 CD 59 01     	CALL CALBAS
1754  5C27 7B           	LD A, E
1755  5C28 32 4D 54     	LD (BLIT_TMP+2), A
1756  5C2B              	; comma
1757  5C2B CD F9 56     	CALL CHKCHAR
1758  5C2E 2C           	DB ','
1759  5C2F              	; get background height
1760  5C2F DD 21 2F 54  	LD IX, FRMQNT
1761  5C33 CD 59 01     	CALL CALBAS
1762  5C36 7B           	LD A, E
1763  5C37 32 4E 54     	LD (BLIT_TMP+3), A
1764  5C3A              	; ending )
1765  5C3A CD F9 56     	CALL CHKCHAR
1766  5C3D 29           	DB ')'
1767  5C3E
1768  5C3E E5           	PUSH HL ; save position in BASIC buffer
1769  5C3F
1770  5C3F              	; calculate char&mask add to value
1771  5C3F 26 00        	LD H, 0
1772  5C41 3A 5D 54     	LD A, (BLIT_STRUCT+14)
1773  5C44 6F           	LD L, A
1774  5C45 CD E8 55     	CALL HLx8
1775  5C48 22 5B 54     	LD (BLIT_STRUCT+12), HL
1776  5C4B              	; calculate background add to value
1777  5C4B 26 00        	LD H, 0
1778  5C4D 3A 4D 54     	LD A, (BLIT_TMP+2)
1779  5C50 6F           	LD L, A
1780  5C51 CD E8 55     	CALL HLx8
1781  5C54 22 55 54     	LD (BLIT_STRUCT+6), HL
1782  5C57              	; calculate pointer to background location
1783  5C57 21 00 00     	LD HL, 0
1784  5C5A 3A 4C 54     	LD A,(BLIT_TMP+1)
1785  5C5D B7           	OR A
1786  5C5E 28 08        	JR Z, .L1
1787  5C60 47           	LD B,A
1788  5C61 ED 5B 55 54  	LD DE,(BLIT_STRUCT+6)
1789  5C65              .L0:
1790  5C65 19           	ADD HL, DE
1791  5C66 10 FD        	DJNZ .L0
1792  5C68              .L1:
1793  5C68 EB           	EX DE,HL
1794  5C69 26 00        	LD H,0
1795  5C6B 3A 4B 54     	LD A,(BLIT_TMP+0)
1796  5C6E 6F           	LD L,A
1797  5C6F CD E8 55     	CALL HLx8
1798  5C72 19           	ADD HL,DE
1799  5C73 ED 5B 53 54  	LD DE,(BLIT_STRUCT+4)
1800  5C77 19           	ADD HL,DE
1801  5C78 22 53 54     	LD (BLIT_STRUCT+4),HL
1802  5C7B
1803  5C7B FD 21 82 5C  	LD IY, .RET
1804  5C7F C3 AC 56     	JP ENABLE_PAGE0
1805  5C82              .RET:
1806  5C82 FB           	EI
1807  5C83 DD 21 4F 54  	LD IX, BLIT_STRUCT
1808  5C87 CD 0F 5B     	CALL SHIFT_MERGE_CHARACTER
1809  5C8A
1810  5C8A D1               POP DE
1811  5C8B C1               POP BC
1812  5C8C CD 23 56         CALL RESTORE_PAGE_INFO
1813  5C8F
1814  5C8F E1           	POP HL
1815  5C90 C9           	RET
1816  5C91              .DAdiv8:
1817  5C91 7B           	LD A,E
1818  5C92 CB 2A        	SRA D
1819  5C94 CB 1F            RR  A
1820  5C96 CB 2A            SRA D
1821  5C98 CB 1F            RR  A
1822  5C9A CB 2A            SRA D
1823  5C9C CB 1F            RR  A
1824  5C9E C9           	RET
1825  5C9F              ; *******************************************************************************************************
1826  5C9F               ENDIF
1827  5C9F               ENDIF
1828  5C9F
1829  5C9F               IF (TILE_CMDS == 1)
1830  5C9F              ; *******************************************************************************************************
1831  5C9F              ; generic function to implement tiling
1832  5C9F              ; should be modified to call appropriate function for memory or vram
1833  5C9F              ; input IX=pointer to following structure
1834  5C9F              ; +00 tile_data_ptr
1835  5C9F              ; +02 tile_rows
1836  5C9F              ; +04 tile_columns
1837  5C9F              ; +06 destination_address
1838  5C9F              ; +08 dest_to_next_row_add_to_value
1839  5C9F              ; +10 num_horizontal_tiles
1840  5C9F              ; +12 num_vertical_tiles
1841  5C9F              ; modifies AF, BC, DE, HL
1842  5C9F              TILE:
1843  5C9F DD 6E 06     	LD L, (IX+6)
1844  5CA2 DD 66 07     	LD H, (IX+7) ; destination address
1845  5CA5 22 4B 54     	LD (TILETMP1), HL
1846  5CA8 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1847  5CAB              .L1:
1848  5CAB C5           	PUSH BC
1849  5CAC DD 6E 00     		LD L, (IX+0)
1850  5CAF DD 66 01     		LD H, (IX+1) ; tile address
1851  5CB2 22 4D 54     		LD (TILETMP2), HL
1852  5CB5 DD 46 02     		LD B, (IX+2) ; tile rows
1853  5CB8              .L2:
1854  5CB8 C5           		PUSH BC
1855  5CB9              .CALL1:
1856  5CB9 CD 00 00     			CALL 0
1857  5CBC DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1858  5CBF              .L3:
1859  5CBF C5           			PUSH BC
1860  5CC0 2A 4D 54     				LD HL, (TILETMP2)
1861  5CC3 DD 46 04     				LD B, (IX+4) ; tile columns
1862  5CC6              .L4:
1863  5CC6 C5           				PUSH BC
1864  5CC7              .CALL2:
1865  5CC7 CD 00 00     					CALL 0
1866  5CCA C1           				POP BC
1867  5CCB 10 F9        				DJNZ .L4
1868  5CCD C1           			POP BC
1869  5CCE 10 EF        			DJNZ .L3
1870  5CD0 22 4D 54     			LD (TILETMP2), HL
1871  5CD3 2A 4B 54     			LD HL, (TILETMP1)
1872  5CD6 DD 5E 08     			LD E, (IX+8)
1873  5CD9 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1874  5CDC 19           			ADD HL, DE
1875  5CDD 22 4B 54     			LD (TILETMP1), HL
1876  5CE0 C1           		POP BC
1877  5CE1 10 D5        		DJNZ .L2
1878  5CE3 C1           	POP BC
1879  5CE4 10 C5        	DJNZ .L1
1880  5CE6 C9           	RET
1881  5CE7              ; *******************************************************************************************************
1882  5CE7
1883  5CE7               IFNDEF CMDS_WITH_PARAMETERS
1884  5CE7 ~            ; *******************************************************************************************************
1885  5CE7 ~            ; function to handle CALL TILERAM basic extension
1886  5CE7 ~            ; fills memory with tiles
1887  5CE7 ~            ; TILERAM ( INT request_data_ptr )
1888  5CE7 ~            ; request_data_ptr described in TILE
1889  5CE7 ~            ; will put ram in page 0 also, page 1 is already there
1890  5CE7 ~            TILERAM:
1891  5CE7 ~            	; opening (
1892  5CE7 ~            	CALL CHKCHAR
1893  5CE7 ~            	DB '('
1894  5CE7 ~            	; get pointer to request struct
1895  5CE7 ~            	LD IX, FRMQNT
1896  5CE7 ~            	CALL CALBAS
1897  5CE7 ~            	PUSH DE
1898  5CE7 ~            	; ending )
1899  5CE7 ~            	CALL CHKCHAR
1900  5CE7 ~            	DB ')'
1901  5CE7 ~
1902  5CE7 ~            	POP IX ; pointer to request struct
1903  5CE7 ~
1904  5CE7 ~            	PUSH HL ; save position in BASIC buffer
1905  5CE7 ~
1906  5CE7 ~            	LD IY, .RET
1907  5CE7 ~            	JP ENABLE_PAGE0
1908  5CE7 ~            .RET:
1909  5CE7 ~            	EI
1910  5CE7 ~            	; set RAM functions to call
1911  5CE7 ~            	LD HL, .TILECOPY
1912  5CE7 ~            	LD (TILE.CALL2+1), HL
1913  5CE7 ~            	LD HL, .SETDESTROW
1914  5CE7 ~            	LD (TILE.CALL1+1), HL
1915  5CE7 ~            	LD A,1
1916  5CE7 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1917  5CE7 ~            	CALL TILE
1918  5CE7 ~            	XOR A
1919  5CE7 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1920  5CE7 ~
1921  5CE7 ~                POP DE
1922  5CE7 ~                POP BC
1923  5CE7 ~                CALL RESTORE_PAGE_INFO
1924  5CE7 ~
1925  5CE7 ~            	POP HL
1926  5CE7 ~            	RET
1927  5CE7 ~            .TILECOPY:
1928  5CE7 ~            	.8 LDI
1929  5CE7 ~            	RET
1930  5CE7 ~            .SETDESTROW:
1931  5CE7 ~            	LD DE, (TILETMP1)
1932  5CE7 ~            	RET
1933  5CE7 ~            ; *******************************************************************************************************
1934  5CE7               ENDIF
1935  5CE7
1936  5CE7               IFDEF CMDS_WITH_PARAMETERS
1937  5CE7              ; *******************************************************************************************************
1938  5CE7              ; function to handle CALL TILERAM basic extension
1939  5CE7              ; fills memory with tiles
1940  5CE7              ; TILERAM ( INT tile_data_pointer,
1941  5CE7              ;			INT tile_columns,
1942  5CE7              ;			INT tile_rows,
1943  5CE7              ;			INT destination_pointer,
1944  5CE7              ;			INT destination_columns,
1945  5CE7              ;			INT destination_rows,
1946  5CE7              ;			INT destination_begin_column,
1947  5CE7              ;			INT destination_begin_row,
1948  5CE7              ;			INT number_of_tiles_horizontally,
1949  5CE7              ;			INT	number_of_tiles_vertically )
1950  5CE7              ; will put ram in page 0 also, page 1 is already there
1951  5CE7              TILERAM:
1952  5CE7              	; opening (
1953  5CE7 CD F9 56     	CALL CHKCHAR
1954  5CEA 28           	DB '('
1955  5CEB              	; get tile data pointer coordinate
1956  5CEB DD 21 2F 54  	LD IX, FRMQNT
1957  5CEF CD 59 01     	CALL CALBAS
1958  5CF2 ED 53 4F 54  	LD (BLIT_STRUCT+0), DE
1959  5CF6              	; comma
1960  5CF6 CD F9 56     	CALL CHKCHAR
1961  5CF9 2C           	DB ','
1962  5CFA              	; get tile columns
1963  5CFA DD 21 2F 54  	LD IX, FRMQNT
1964  5CFE CD 59 01     	CALL CALBAS
1965  5D01 ED 53 53 54  	LD (BLIT_STRUCT+4), DE
1966  5D05              	; comma
1967  5D05 CD F9 56     	CALL CHKCHAR
1968  5D08 2C           	DB ','
1969  5D09              	; get tile columns
1970  5D09 DD 21 2F 54  	LD IX, FRMQNT
1971  5D0D CD 59 01     	CALL CALBAS
1972  5D10 ED 53 51 54  	LD (BLIT_STRUCT+2), DE
1973  5D14              	; comma
1974  5D14 CD F9 56     	CALL CHKCHAR
1975  5D17 2C           	DB ','
1976  5D18              	; get destintion pointer
1977  5D18 DD 21 2F 54  	LD IX, FRMQNT
1978  5D1C CD 59 01     	CALL CALBAS
1979  5D1F ED 53 55 54  	LD (BLIT_STRUCT+6), DE
1980  5D23              	; comma
1981  5D23 CD F9 56     	CALL CHKCHAR
1982  5D26 2C           	DB ','
1983  5D27              	; get destination columns
1984  5D27 DD 21 2F 54  	LD IX, FRMQNT
1985  5D2B CD 59 01     	CALL CALBAS
1986  5D2E 7B           	LD A, E
1987  5D2F 32 4B 54     	LD (BLIT_TMP+0), A
1988  5D32              	; comma
1989  5D32 CD F9 56     	CALL CHKCHAR
1990  5D35 2C           	DB ','
1991  5D36              	; get destination rows
1992  5D36 DD 21 2F 54  	LD IX, FRMQNT
1993  5D3A CD 59 01     	CALL CALBAS
1994  5D3D 7B           	LD A, E
1995  5D3E 32 4C 54     	LD (BLIT_TMP+1), A
1996  5D41              	; comma
1997  5D41 CD F9 56     	CALL CHKCHAR
1998  5D44 2C           	DB ','
1999  5D45              	; get destination begin column
2000  5D45 DD 21 2F 54  	LD IX, FRMQNT
2001  5D49 CD 59 01     	CALL CALBAS
2002  5D4C 7B           	LD A, E
2003  5D4D 32 4D 54     	LD (BLIT_TMP+2), A
2004  5D50              	; comma
2005  5D50 CD F9 56     	CALL CHKCHAR
2006  5D53 2C           	DB ','
2007  5D54              	; get destination begin row
2008  5D54 DD 21 2F 54  	LD IX, FRMQNT
2009  5D58 CD 59 01     	CALL CALBAS
2010  5D5B 7B           	LD A, E
2011  5D5C 32 4E 54     	LD (BLIT_TMP+3), A
2012  5D5F              	; comma
2013  5D5F CD F9 56     	CALL CHKCHAR
2014  5D62 2C           	DB ','
2015  5D63              	; get number of tiles horizontally
2016  5D63 DD 21 2F 54  	LD IX, FRMQNT
2017  5D67 CD 59 01     	CALL CALBAS
2018  5D6A ED 53 59 54  	LD (BLIT_STRUCT+10), DE
2019  5D6E              	; comma
2020  5D6E CD F9 56     	CALL CHKCHAR
2021  5D71 2C           	DB ','
2022  5D72              	; get number of tiles vertically
2023  5D72 DD 21 2F 54  	LD IX, FRMQNT
2024  5D76 CD 59 01     	CALL CALBAS
2025  5D79 ED 53 5B 54  	LD (BLIT_STRUCT+12), DE
2026  5D7D              	; ending )
2027  5D7D CD F9 56     	CALL CHKCHAR
2028  5D80 29           	DB ')'
2029  5D81
2030  5D81 E5           	PUSH HL ; save position in BASIC buffer
2031  5D82
2032  5D82              	; calculate destination add to value
2033  5D82 26 00        	LD H, 0
2034  5D84 3A 4B 54     	LD A, (BLIT_TMP+0)
2035  5D87 6F           	LD L, A
2036  5D88 CD E8 55     	CALL HLx8
2037  5D8B 22 57 54     	LD (BLIT_STRUCT+8), HL
2038  5D8E              	; calculate pointer to background location
2039  5D8E 21 00 00     	LD HL, 0
2040  5D91 3A 4E 54     	LD A,(BLIT_TMP+3)
2041  5D94 B7           	OR A
2042  5D95 28 08        	JR Z, .L1
2043  5D97 47           	LD B,A
2044  5D98 ED 5B 57 54  	LD DE,(BLIT_STRUCT+8)
2045  5D9C              .L0:
2046  5D9C 19           	ADD HL, DE
2047  5D9D 10 FD        	DJNZ .L0
2048  5D9F              .L1:
2049  5D9F EB           	EX DE,HL
2050  5DA0 26 00        	LD H,0
2051  5DA2 3A 4D 54     	LD A,(BLIT_TMP+2)
2052  5DA5 6F           	LD L,A
2053  5DA6 CD E8 55     	CALL HLx8
2054  5DA9 19           	ADD HL,DE
2055  5DAA ED 5B 55 54  	LD DE,(BLIT_STRUCT+6)
2056  5DAE 19           	ADD HL,DE
2057  5DAF 22 55 54     	LD (BLIT_STRUCT+6),HL
2058  5DB2
2059  5DB2 FD 21 B9 5D  	LD IY, .RET
2060  5DB6 C3 AC 56     	JP ENABLE_PAGE0
2061  5DB9              .RET:
2062  5DB9 FB           	EI
2063  5DBA              	; set RAM functions to call
2064  5DBA 21 D4 5D     	LD HL, .TILECOPY
2065  5DBD 22 C8 5C     	LD (TILE.CALL2+1), HL
2066  5DC0 21 E5 5D     	LD HL, .SETDESTROW
2067  5DC3 22 BA 5C     	LD (TILE.CALL1+1), HL
2068  5DC6 DD 21 4F 54  	LD IX,BLIT_STRUCT
2069  5DCA CD 9F 5C     	CALL TILE
2070  5DCD
2071  5DCD D1               POP DE
2072  5DCE C1               POP BC
2073  5DCF CD 23 56         CALL RESTORE_PAGE_INFO
2074  5DD2
2075  5DD2 E1           	POP HL
2076  5DD3 C9           	RET
2077  5DD4              .TILECOPY:
2078  5DD4 ED A0       > LDI
2078  5DD6 ED A0       > LDI
2078  5DD8 ED A0       > LDI
2078  5DDA ED A0       > LDI
2078  5DDC ED A0       > LDI
2078  5DDE ED A0       > LDI
2078  5DE0 ED A0       > LDI
2078  5DE2 ED A0       > LDI
2079  5DE4 C9           	RET
2080  5DE5              .SETDESTROW:
2081  5DE5 ED 5B 4B 54  	LD DE, (TILETMP1)
2082  5DE9 C9           	RET
2083  5DEA              ; *******************************************************************************************************
2084  5DEA               ENDIF
2085  5DEA
2086  5DEA               IFDEF CMDS_WITH_PARAMETERS
2087  5DEA              ; *******************************************************************************************************
2088  5DEA              ; function to handle CALL TILEVRM basic extension
2089  5DEA              ; fills vram with tiles
2090  5DEA              ; TILEVRM ( INT tile_data_pointer,
2091  5DEA              ;			INT tile_columns,
2092  5DEA              ;			INT tile_rows,
2093  5DEA              ;			INT destination_begin_column,
2094  5DEA              ;			INT destination_begin_row,
2095  5DEA              ;			INT number_of_tiles_horizontally,
2096  5DEA              ;			INT	number_of_tiles_vertically )
2097  5DEA              ; will put ram in page 0 also, page 1 is already there
2098  5DEA              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2099  5DEA              TILEVRM:
2100  5DEA              	; opening (
2101  5DEA CD F9 56     	CALL CHKCHAR
2102  5DED 28           	DB '('
2103  5DEE              	; get tile data pointer coordinate
2104  5DEE DD 21 2F 54  	LD IX, FRMQNT
2105  5DF2 CD 59 01     	CALL CALBAS
2106  5DF5 ED 53 4F 54  	LD (BLIT_STRUCT+0), DE
2107  5DF9              	; comma
2108  5DF9 CD F9 56     	CALL CHKCHAR
2109  5DFC 2C           	DB ','
2110  5DFD              	; get tile columns
2111  5DFD DD 21 2F 54  	LD IX, FRMQNT
2112  5E01 CD 59 01     	CALL CALBAS
2113  5E04 ED 53 53 54  	LD (BLIT_STRUCT+4), DE
2114  5E08              	; comma
2115  5E08 CD F9 56     	CALL CHKCHAR
2116  5E0B 2C           	DB ','
2117  5E0C              	; get tile columns
2118  5E0C DD 21 2F 54  	LD IX, FRMQNT
2119  5E10 CD 59 01     	CALL CALBAS
2120  5E13 ED 53 51 54  	LD (BLIT_STRUCT+2), DE
2121  5E17              	; comma
2122  5E17 CD F9 56     	CALL CHKCHAR
2123  5E1A 2C           	DB ','
2124  5E1B              	; get destination begin column
2125  5E1B DD 21 2F 54  	LD IX, FRMQNT
2126  5E1F CD 59 01     	CALL CALBAS
2127  5E22 7B           	LD A, E
2128  5E23 32 4D 54     	LD (BLIT_TMP+2), A
2129  5E26              	; comma
2130  5E26 CD F9 56     	CALL CHKCHAR
2131  5E29 2C           	DB ','
2132  5E2A              	; get destination begin row
2133  5E2A DD 21 2F 54  	LD IX, FRMQNT
2134  5E2E CD 59 01     	CALL CALBAS
2135  5E31 7B           	LD A, E
2136  5E32 32 4E 54     	LD (BLIT_TMP+3), A
2137  5E35              	; comma
2138  5E35 CD F9 56     	CALL CHKCHAR
2139  5E38 2C           	DB ','
2140  5E39              	; get number of tiles horizontally
2141  5E39 DD 21 2F 54  	LD IX, FRMQNT
2142  5E3D CD 59 01     	CALL CALBAS
2143  5E40 ED 53 59 54  	LD (BLIT_STRUCT+10), DE
2144  5E44              	; comma
2145  5E44 CD F9 56     	CALL CHKCHAR
2146  5E47 2C           	DB ','
2147  5E48              	; get number of tiles vertically
2148  5E48 DD 21 2F 54  	LD IX, FRMQNT
2149  5E4C CD 59 01     	CALL CALBAS
2150  5E4F ED 53 5B 54  	LD (BLIT_STRUCT+12), DE
2151  5E53              	; ending )
2152  5E53 CD F9 56     	CALL CHKCHAR
2153  5E56 29           	DB ')'
2154  5E57
2155  5E57 E5           	PUSH HL ; save position in BASIC buffer
2156  5E58
2157  5E58              	; calculate destination add to value
2158  5E58 21 00 01     	LD HL, 256
2159  5E5B 22 57 54     	LD (BLIT_STRUCT+8), HL
2160  5E5E              	; calculate pointer to background location
2161  5E5E 3A 4E 54     	LD A,(BLIT_TMP+3)
2162  5E61 67           	LD H,A
2163  5E62 2E 00        	LD L,0
2164  5E64 EB           	EX DE,HL
2165  5E65 26 00        	LD H,0
2166  5E67 3A 4D 54     	LD A,(BLIT_TMP+2)
2167  5E6A 6F           	LD L,A
2168  5E6B CD E8 55     	CALL HLx8
2169  5E6E 19           	ADD HL,DE
2170  5E6F ED 5B CB F3  	LD DE,(GRPCGP)
2171  5E73 19           	ADD HL,DE
2172  5E74 22 55 54     	LD (BLIT_STRUCT+6),HL
2173  5E77
2174  5E77 FD 21 7E 5E  	LD IY, .RET
2175  5E7B C3 AC 56     	JP ENABLE_PAGE0
2176  5E7E              .RET:
2177  5E7E FB           	EI
2178  5E7F              	; set RAM functions to call
2179  5E7F 21 99 5E     	LD HL, .TILECOPY
2180  5E82 22 C8 5C     	LD (TILE.CALL2+1), HL
2181  5E85 21 9F 5E     	LD HL, .SETDESTROW
2182  5E88 22 BA 5C     	LD (TILE.CALL1+1), HL
2183  5E8B DD 21 4F 54  	LD IX,BLIT_STRUCT
2184  5E8F CD 9F 5C     	CALL TILE
2185  5E92
2186  5E92 D1               POP DE
2187  5E93 C1               POP BC
2188  5E94 CD 23 56         CALL RESTORE_PAGE_INFO
2189  5E97
2190  5E97 E1           	POP HL
2191  5E98 C9           	RET
2192  5E99              .TILECOPY:
2193  5E99 01 98 08     	LD BC, #0898
2194  5E9C C3 E0 55     	JP BBYTECOPY
2195  5E9F              .SETDESTROW:
2196  5E9F 2A 4B 54     	LD HL, (TILETMP1)
2197  5EA2 F3           	DI
2198  5EA3 CD D5 55     	CALL SETWRT_LOCAL
2199  5EA6 FB           	EI
2200  5EA7 C9           	RET
2201  5EA8              ; *******************************************************************************************************
2202  5EA8               ENDIF
2203  5EA8
2204  5EA8               IFNDEF CMDS_WITH_PARAMETERS
2205  5EA8 ~            ; *******************************************************************************************************
2206  5EA8 ~            ; function to handle CALL TILEVRM basic extension
2207  5EA8 ~            ; fills vram with tiles
2208  5EA8 ~            ; TILEVRM ( INT request_data_ptr )
2209  5EA8 ~            ; request_data_ptr described in TILE
2210  5EA8 ~            ; will put ram in page 0 also, page 1 is already there
2211  5EA8 ~            TILEVRM:
2212  5EA8 ~            	; opening (
2213  5EA8 ~            	CALL CHKCHAR
2214  5EA8 ~            	DB '('
2215  5EA8 ~            	; get pointer to request struct
2216  5EA8 ~            	LD IX, FRMQNT
2217  5EA8 ~            	CALL CALBAS
2218  5EA8 ~            	PUSH DE
2219  5EA8 ~            	; ending )
2220  5EA8 ~            	CALL CHKCHAR
2221  5EA8 ~            	DB ')'
2222  5EA8 ~
2223  5EA8 ~            	POP IX ; pointer to request struct
2224  5EA8 ~
2225  5EA8 ~            	PUSH HL ; save position in BASIC buffer
2226  5EA8 ~
2227  5EA8 ~            	LD IY, .RET
2228  5EA8 ~            	JP ENABLE_PAGE0
2229  5EA8 ~            .RET:
2230  5EA8 ~            	EI
2231  5EA8 ~            	; set RAM functions to call
2232  5EA8 ~            	LD HL, .TILECOPY
2233  5EA8 ~            	LD (TILE.CALL2+1), HL
2234  5EA8 ~            	LD HL, .SETDESTROW
2235  5EA8 ~            	LD (TILE.CALL1+1), HL
2236  5EA8 ~            	CALL TILE
2237  5EA8 ~
2238  5EA8 ~                POP DE
2239  5EA8 ~                POP BC
2240  5EA8 ~                CALL RESTORE_PAGE_INFO
2241  5EA8 ~
2242  5EA8 ~            	POP HL
2243  5EA8 ~            	RET
2244  5EA8 ~            .TILECOPY:
2245  5EA8 ~            	LD BC, #0898
2246  5EA8 ~            	JP BBYTECOPY
2247  5EA8 ~            .SETDESTROW:
2248  5EA8 ~            	LD HL, (TILETMP1)
2249  5EA8 ~            	DI
2250  5EA8 ~            	CALL SETWRT_LOCAL
2251  5EA8 ~            	EI
2252  5EA8 ~            	RET
2253  5EA8 ~            ; *******************************************************************************************************
2254  5EA8               ENDIF
2255  5EA8               ENDIF
2256  5EA8
2257  5EA8               IF (BOX_CMDS == 1)
2258  5EA8              ; *******************************************************************************************************
2259  5EA8              ; generic function to implement rectangle data copy
2260  5EA8              ; should be modified to call appropriate function for memory or vram
2261  5EA8              ; input IX=pointer to following structure
2262  5EA8              ; +00 source data pointer
2263  5EA8              ; +02 num bytes in a row
2264  5EA8              ; +04 number of rows
2265  5EA8              ; +06 source add-to value till next row
2266  5EA8              ; +08 destination address
2267  5EA8              ; +10 destination add-to value till next row
2268  5EA8              ; modifies AF, BC, DE, HL
2269  5EA8              RECTANGLE_COPY:
2270  5EA8 DD 6E 00     	LD L, (IX+0)
2271  5EAB DD 66 01     	LD H, (IX+1) ; source address
2272  5EAE DD 5E 08     	LD E, (IX+8)
2273  5EB1 DD 56 09     	LD D, (IX+9) ; destination
2274  5EB4 DD 46 04     	LD B, (IX+4) ; row number
2275  5EB7              .L1:
2276  5EB7 C5           	PUSH BC
2277  5EB8 E5           		PUSH HL
2278  5EB9 D5           			PUSH DE
2279  5EBA DD 4E 02     				LD C, (IX+2)
2280  5EBD DD 46 03     				LD B, (IX+3) ; num bytes in a row
2281  5EC0              .CALL1:
2282  5EC0 CD 00 00     				CALL 0 ; set destination address from DE
2283  5EC3              .CALL2:
2284  5EC3 CD 00 00     				CALL 0 ; copy data fn
2285  5EC6 E1           			POP HL
2286  5EC7 DD 4E 0A     			LD C, (IX+10)
2287  5ECA DD 46 0B     			LD B, (IX+11) ; destination add-to
2288  5ECD 09           			ADD HL, BC
2289  5ECE EB           			EX DE, HL
2290  5ECF E1           		POP HL
2291  5ED0 DD 4E 06     		LD C, (IX+6)
2292  5ED3 DD 46 07     		LD B, (IX+7) ; src add-to
2293  5ED6 09           		ADD HL, BC
2294  5ED7 C1           	POP BC
2295  5ED8 10 DD        	DJNZ .L1
2296  5EDA C9           	RET
2297  5EDB              ; *******************************************************************************************************
2298  5EDB
2299  5EDB              ; *******************************************************************************************************
2300  5EDB              ; function to handle CALL BOXMEMCPY basic extension
2301  5EDB              ; copies data with window like boundaries to ram
2302  5EDB              ; BOXMEMCPY ( INT request_data_ptr )
2303  5EDB              ; request_data_ptr described in RECTANGLE_COPY
2304  5EDB              ; will put ram in page 0 also, page 1 is already there
2305  5EDB              BOXMEMCPY:
2306  5EDB              	; opening (
2307  5EDB CD F9 56     	CALL CHKCHAR
2308  5EDE 28           	DB '('
2309  5EDF              	; get pointer to request struct
2310  5EDF DD 21 2F 54  	LD IX, FRMQNT
2311  5EE3 CD 59 01     	CALL CALBAS
2312  5EE6 D5           	PUSH DE
2313  5EE7              	; ending )
2314  5EE7 CD F9 56     	CALL CHKCHAR
2315  5EEA 29           	DB ')'
2316  5EEB
2317  5EEB DD E1        	POP IX ; pointer to request struct
2318  5EED
2319  5EED E5           	PUSH HL ; save position in BASIC buffer
2320  5EEE
2321  5EEE FD 21 F5 5E  	LD IY, .RET
2322  5EF2 C3 AC 56     	JP ENABLE_PAGE0
2323  5EF5              .RET:
2324  5EF5 FB           	EI
2325  5EF6              	; set RAM functions to call
2326  5EF6 21 00 00     	LD HL, 0
2327  5EF9 22 C0 5E     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2328  5EFC 22 C2 5E     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2329  5EFF 21 ED B0     	LD HL, #B0ED ; LDIR
2330  5F02 22 C4 5E     	LD (RECTANGLE_COPY.CALL1+4), HL
2331  5F05 CD A8 5E     	CALL RECTANGLE_COPY
2332  5F08
2333  5F08 D1               POP DE
2334  5F09 C1               POP BC
2335  5F0A CD 23 56         CALL RESTORE_PAGE_INFO
2336  5F0D
2337  5F0D E1           	POP HL
2338  5F0E C9           	RET
2339  5F0F              ; *******************************************************************************************************
2340  5F0F
2341  5F0F              ; *******************************************************************************************************
2342  5F0F              ; function to handle CALL BOXMEMVRM basic extension
2343  5F0F              ; copies data with window like boundaries to ram
2344  5F0F              ; BOXMEMVRM ( INT request_data_ptr )
2345  5F0F              ; request_data_ptr described in RECTANGLE_COPY
2346  5F0F              ; will put ram in page 0 also, page 1 is already there
2347  5F0F              BOXMEMVRM:
2348  5F0F              	; opening (
2349  5F0F CD F9 56     	CALL CHKCHAR
2350  5F12 28           	DB '('
2351  5F13              	; get pointer to request struct
2352  5F13 DD 21 2F 54  	LD IX, FRMQNT
2353  5F17 CD 59 01     	CALL CALBAS
2354  5F1A D5           	PUSH DE
2355  5F1B              	; ending )
2356  5F1B CD F9 56     	CALL CHKCHAR
2357  5F1E 29           	DB ')'
2358  5F1F
2359  5F1F DD E1        	POP IX ; pointer to request struct
2360  5F21
2361  5F21 E5           	PUSH HL ; save position in BASIC buffer
2362  5F22
2363  5F22 FD 21 29 5F  	LD IY, .RET
2364  5F26 C3 AC 56     	JP ENABLE_PAGE0
2365  5F29              .RET:
2366  5F29 FB           	EI
2367  5F2A              	; set RAM functions to call
2368  5F2A 21 51 5F     	LD HL, .SETDEST
2369  5F2D 22 C1 5E     	LD (RECTANGLE_COPY.CALL1+1), HL
2370  5F30 21 59 5F     	LD HL, .COPYDATA
2371  5F33 22 C4 5E     	LD (RECTANGLE_COPY.CALL2+1), HL
2372  5F36 3E CD        	LD A, #CD ; CALL
2373  5F38 32 C0 5E     	LD (RECTANGLE_COPY.CALL1), A
2374  5F3B 32 C3 5E     	LD (RECTANGLE_COPY.CALL2), A
2375  5F3E 3E 01        	LD A,1
2376  5F40 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
2377  5F43 CD A8 5E     	CALL RECTANGLE_COPY
2378  5F46 AF           	XOR A
2379  5F47 32 60 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
2380  5F4A
2381  5F4A D1               POP DE
2382  5F4B C1               POP BC
2383  5F4C CD 23 56         CALL RESTORE_PAGE_INFO
2384  5F4F
2385  5F4F E1           	POP HL
2386  5F50 C9           	RET
2387  5F51              .SETDEST:
2388  5F51 EB           	EX DE, HL
2389  5F52 F3           	DI
2390  5F53 CD D5 55     	CALL SETWRT_LOCAL
2391  5F56 FB           	EI
2392  5F57 EB           	EX DE, HL
2393  5F58 C9           	RET
2394  5F59              .COPYDATA:
2395  5F59 41           	LD B, C
2396  5F5A 0E 98        	LD C, #98
2397  5F5C C3 E0 55     	JP BBYTECOPY
2398  5F5F              ; *******************************************************************************************************
2399  5F5F               ENDIF
2400  5F5F
2401  5F5F              EXT_END:
2402  5F5F
# file closed: asm\main.asm
