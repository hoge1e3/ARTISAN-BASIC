# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000
  51  4000              ; BASIC error codes
  52  4000              ;01 NEXT without FOR
  53  4000              ;02 Syntax error
  54  4000              ;03 RETURN without GOSUB
  55  4000              ;04 Out of DATA
  56  4000              ;05 Illegal function call
  57  4000              ;06 Overflow
  58  4000              ;07 Out of memory
  59  4000              ;08 Undefined line number
  60  4000              ;09 Subscript out of range
  61  4000              ;10 Redimensioned array
  62  4000              ;11 Division by zero
  63  4000              ;12 Illegal direct
  64  4000              ;13 Type mismatch
  65  4000              ;14 Out of string space
  66  4000              ;15 String too long
  67  4000              ;16 String formula too complex
  68  4000              ;17 Can't CONTINUE
  69  4000              ;18 Undefined user function
  70  4000              ;19 Device I/O error
  71  4000              ;20 Verify error
  72  4000              ;21 No RESUME
  73  4000              ;22 RESUME without error
  74  4000              ;23 Unprintable error
  75  4000              ;24 Missing operand
  76  4000              ;25 Line buffer overflow
  77  4000              ;50 FIELD overflow
  78  4000              ;51 Internal error
  79  4000              ;52 Bad file number
  80  4000              ;53 File not found
  81  4000              ;54 File already open
  82  4000              ;55 Input past end
  83  4000              ;56 Bad file name
  84  4000              ;57 Direct statement in file
  85  4000              ;58 Sequential I/O only
  86  4000              ;59 File not OPEN
  87  4000
  88  4000
  89  4000               ; simulate cartridge with BASIC extension
  90  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  90  4004 51 55 00 00
  90  4008 00 00 00 00
  90  400C 00 00 00 00
  91  4010
  92  4010              ; this location #4010 stores last location used by basic extension
  93  4010              ; free memory after that point
  94  4010              FREEMEMPTR:
  95  4010 36 5E         DW EXT_END
  96  4012
  97  4012              ; this location #4012 stores extension version in DAA format
  98  4012              ; first byte is major version and second minor
  99  4012              VERSION:
 100  4012 00 70         DB #00, #70
 101  4014
 102  4014              ; binary included AKG player compiled at #4014
 103  4014               IF (SOUND_CMDS == 1)
 104  4014              	INCBIN "bin/AKG.bin"
 105  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 106  4CF0               ENDIF
 107  4CF0
 108  4CF0              ORIG.HTIMI:
 109  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 109  4CF4 00
 110  4CF5               EXPORT ORIG.HTIMI
 111  4CF5
 112  4CF5               IF (SOUND_CMDS == 1)
 113  4CF5              MUSIC_INIT_STATUS:
 114  4CF5 00            DB 0
 115  4CF6              SFX_INIT_STATUS:
 116  4CF6 00            DB 0
 117  4CF7              SOUND_ENABLED:
 118  4CF7 00            DB 0
 119  4CF8               ENDIF
 120  4CF8
 121  4CF8               IF (SPRITE_CMDS == 1)
 122  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 6A 54     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 8E 55     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 8E 55     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 8E 55     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 8E 55     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 AE 55     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 AE 55     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 AE 55     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 8E 55     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 8E 55     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 8E 55     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 8E 55     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 8E 55     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 8E 55     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 AE 55     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 AE 55     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 8E 55     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 8E 55     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 8E 55     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 8E 55     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 8E 55     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 81 54         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD C8 54         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD B8 54         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 123  4F4D               ENDIF
 124  4F4D
 125  4F4D               IF (ANIM_CMDS == 1)
 126  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E 36 5E         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 36 5E         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 36 5E         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; ANIMATION DEFINITION
  31+ 4F56              ; byte number of items 1-15
  32+ 4F56              ; byte[15] anim_item;
  33+ 4F56              ; total size = 16b
  34+ 4F56
  35+ 4F56              ; SPRITE ANIMATION
  36+ 4F56              ; +00 byte sprite number;
  37+ 4F56              ; +01 word time;
  38+ 4F56              ; +03 byte current item;
  39+ 4F56              ; +04 byte animation definition;
  40+ 4F56              ; +05 byte cyclic;
  41+ 4F56              ; +06 byte active;
  42+ 4F56              ; +07 byte reserved
  43+ 4F56              ; total size = 8b
  44+ 4F56
  45+ 4F56              ; *******************************************************************************************************
  46+ 4F56              ; helper function HL=A*5
  47+ 4F56              ; changes HL,DE;
  48+ 4F56              Ax5:
  49+ 4F56 26 00            LD H,0
  50+ 4F58 6F               LD L,A
  51+ 4F59 54               LD D,H
  52+ 4F5A 5D               LD E,L
  53+ 4F5B 29               ADD HL,HL
  54+ 4F5C 29               ADD HL,HL
  55+ 4F5D 19               ADD HL,DE
  56+ 4F5E C9               RET
  57+ 4F5F              ; *******************************************************************************************************
  58+ 4F5F
  59+ 4F5F              ; *******************************************************************************************************
  60+ 4F5F              ; helper function gets pointer to n-th entry in sprite animation
  61+ 4F5F              ; changes HL,DE;
  62+ 4F5F              GETnthSPRANIM:
  63+ 4F5F 26 00            LD H,0
  64+ 4F61 6F               LD L,A
  65+ 4F62 CD 7C 54         CALL HLx16
  66+ 4F65 ED 5B 54 4F      LD DE,(ANIMSPRPTR)
  67+ 4F69 19               ADD HL,DE
  68+ 4F6A C9               RET
  69+ 4F6B              ; *******************************************************************************************************
  70+ 4F6B
  71+ 4F6B              ; *******************************************************************************************************
  72+ 4F6B              ; function to handle CALL MAXANIMITEMS basic extension
  73+ 4F6B              ; MAXANIMITEMS (BYTE number)
  74+ 4F6B              ; sets new number and moves memory buffers as needed
  75+ 4F6B              MAXANIMITEMS:
  76+ 4F6B              	; opening (
  77+ 4F6B CD 8E 55     	CALL CHKCHAR
  78+ 4F6E 28           	DB '('
  79+ 4F6F              	; get value
  80+ 4F6F DD 21 1C 52  	LD IX, GETBYT
  81+ 4F73 CD 59 01     	CALL CALBAS
  82+ 4F76 F5               PUSH AF
  83+ 4F77              	; ending )
  84+ 4F77 CD 8E 55     	CALL CHKCHAR
  85+ 4F7A 29           	DB ')'
  86+ 4F7B F1               POP AF
  87+ 4F7C
  88+ 4F7C              	; save position
  89+ 4F7C E5           	PUSH HL
  90+ 4F7D              .ENTRY:
  91+ 4F7D 47               LD B,A
  92+ 4F7E 3A 4D 4F         LD A,(ANIMITEMNUM)
  93+ 4F81 90               SUB B
  94+ 4F82 28 1F            JR Z, .EXIT; same value as before
  95+ 4F84 FD 21 51 4F      LD IY,ANIMDEFPTR
  96+ 4F88 FA A6 4F         JP M, .INCREASE
  97+ 4F8B                  ; new value is lower than previous one
  98+ 4F8B CD BE 4F         CALL .SIZEDIFF
  99+ 4F8E CD D9 4F         CALL .DECREASE_COMMON
 100+ 4F91 2A 54 4F         LD HL,(ANIMSPRPTR)
 101+ 4F94 AF               XOR A
 102+ 4F95 ED 42            SBC HL,BC
 103+ 4F97 22 54 4F         LD (ANIMSPRPTR),HL
 104+ 4F9A              .E1:
 105+ 4F9A 2A 10 40         LD HL,(FREEMEMPTR)
 106+ 4F9D AF               XOR A
 107+ 4F9E ED 42            SBC HL,BC
 108+ 4FA0 22 10 40         LD (FREEMEMPTR),HL
 109+ 4FA3              .EXIT:
 110+ 4FA3 FB               EI
 111+ 4FA4 E1           	POP HL
 112+ 4FA5 C9           	RET
 113+ 4FA6              .INCREASE:
 114+ 4FA6 ED 44            NEG
 115+ 4FA8 CD BE 4F         CALL .SIZEDIFF
 116+ 4FAB CD 05 50         CALL .INCREASE_COMMON
 117+ 4FAE 2A 54 4F         LD HL,(ANIMSPRPTR)
 118+ 4FB1 09               ADD HL,BC
 119+ 4FB2 22 54 4F         LD (ANIMSPRPTR),HL
 120+ 4FB5              .E2:
 121+ 4FB5 2A 10 40         LD HL,(FREEMEMPTR)
 122+ 4FB8 09               ADD HL,BC
 123+ 4FB9 22 10 40         LD (FREEMEMPTR),HL
 124+ 4FBC 18 E5            JR .EXIT
 125+ 4FBE              .SIZEDIFF:
 126+ 4FBE CD 56 4F         CALL Ax5
 127+ 4FC1 78               LD A,B
 128+ 4FC2 32 4D 4F         LD (ANIMITEMNUM),A
 129+ 4FC5 44               LD B,H
 130+ 4FC6 4D               LD C,L
 131+ 4FC7 C9               RET ; BC=size difference in bytes
 132+ 4FC8              .SIZETOMOVE:
 133+ 4FC8 D5               PUSH DE
 134+ 4FC9 2A 10 40         LD HL,(FREEMEMPTR)
 135+ 4FCC FD 5E 00         LD E,(IY)
 136+ 4FCF FD 56 01         LD D,(IY+1)
 137+ 4FD2 AF               XOR A
 138+ 4FD3 ED 52            SBC HL,DE
 139+ 4FD5 44               LD B,H
 140+ 4FD6 4D               LD C,L
 141+ 4FD7 D1               POP DE
 142+ 4FD8 C9               RET
 143+ 4FD9              .DECREASE_COMMON:
 144+ 4FD9 FD 6E 00         LD L,(IY)
 145+ 4FDC FD 66 01         LD H,(IY+1)
 146+ 4FDF AF               XOR A
 147+ 4FE0 ED 42            SBC HL,BC
 148+ 4FE2 EB               EX DE,HL
 149+ 4FE3 C5               PUSH BC
 150+ 4FE4 CD C8 4F         CALL .SIZETOMOVE
 151+ 4FE7 F3               DI
 152+ 4FE8 78               LD A,B
 153+ 4FE9 B1               OR C
 154+ 4FEA 28 08            JR Z,.L1
 155+ 4FEC FD 6E 00         LD L,(IY)
 156+ 4FEF FD 66 01         LD H,(IY+1)
 157+ 4FF2 ED B0            LDIR
 158+ 4FF4              .L1:
 159+ 4FF4 C1               POP BC
 160+ 4FF5 FD 6E 00         LD L,(IY)
 161+ 4FF8 FD 66 01         LD H,(IY+1)
 162+ 4FFB AF               XOR A
 163+ 4FFC ED 42            SBC HL,BC
 164+ 4FFE FD 75 00         LD (IY),L
 165+ 5001 FD 74 01         LD (IY+1),H
 166+ 5004 C9               RET
 167+ 5005              .INCREASE_COMMON:
 168+ 5005 2A 10 40         LD HL,(FREEMEMPTR)
 169+ 5008 2B               DEC HL
 170+ 5009 AF               XOR A
 171+ 500A ED 42            SBC HL,BC
 172+ 500C EB               EX DE,HL
 173+ 500D C5               PUSH BC
 174+ 500E CD C8 4F         CALL .SIZETOMOVE
 175+ 5011 F3               DI
 176+ 5012 78               LD A,B
 177+ 5013 B1               OR C
 178+ 5014 28 06            JR Z,.L2
 179+ 5016 2A 10 40         LD HL,(FREEMEMPTR)
 180+ 5019 2B               DEC HL
 181+ 501A ED B8            LDDR
 182+ 501C              .L2:
 183+ 501C C1               POP BC
 184+ 501D FD 6E 00         LD L,(IY)
 185+ 5020 FD 66 01         LD H,(IY+1)
 186+ 5023 09               ADD HL,BC
 187+ 5024 FD 75 00         LD (IY),L
 188+ 5027 FD 74 01         LD (IY+1),H
 189+ 502A C9               RET
 190+ 502B              ; *******************************************************************************************************
 191+ 502B
 192+ 502B              ; *******************************************************************************************************
 193+ 502B              ; function to handle CALL ANIMITEMPAT basic extension
 194+ 502B              ; ANIMITEMPAT ( BYTE id,
 195+ 502B              ;               INT ticks,
 196+ 502B              ;               BYTE pattern,
 197+ 502B              ;               BYTE color )
 198+ 502B              ; fills animation item data, returns an error if out of bounds
 199+ 502B              ANIMITEMPAT:
 200+ 502B                  ; opening (
 201+ 502B CD 8E 55     	CALL CHKCHAR
 202+ 502E 28           	DB '('
 203+ 502F              	; get id
 204+ 502F DD 21 1C 52  	LD IX, GETBYT
 205+ 5033 CD 59 01     	CALL CALBAS
 206+ 5036 F5               PUSH AF
 207+ 5037                  ; check if out of bounds
 208+ 5037 3C               INC A
 209+ 5038 4F               LD C,A
 210+ 5039 3A 4D 4F         LD A,(ANIMITEMNUM)
 211+ 503C B9               CP C
 212+ 503D DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 213+ 5040              	; comma
 214+ 5040 CD 8E 55     	CALL CHKCHAR
 215+ 5043 2C           	DB ','
 216+ 5044              	; get ticks
 217+ 5044 DD 21 2F 54  	LD IX, FRMQNT
 218+ 5048 CD 59 01     	CALL CALBAS
 219+ 504B D5           	PUSH DE
 220+ 504C              	; comma
 221+ 504C CD 8E 55     	CALL CHKCHAR
 222+ 504F 2C           	DB ','
 223+ 5050              	; get pattern
 224+ 5050 DD 21 1C 52  	LD IX, GETBYT
 225+ 5054 CD 59 01     	CALL CALBAS
 226+ 5057 F5               PUSH AF
 227+ 5058              	; comma
 228+ 5058 CD 8E 55     	CALL CHKCHAR
 229+ 505B 2C           	DB ','
 230+ 505C              	; get color
 231+ 505C DD 21 1C 52  	LD IX, GETBYT
 232+ 5060 CD 59 01     	CALL CALBAS
 233+ 5063 F5               PUSH AF
 234+ 5064              	; ending )
 235+ 5064 CD 8E 55     	CALL CHKCHAR
 236+ 5067 29           	DB ')'
 237+ 5068              .ENTRY:
 238+ 5068 E5               PUSH HL
 239+ 5069 DD E1            POP IX
 240+ 506B D9               EXX
 241+ 506C C1               POP BC ; color
 242+ 506D D1               POP DE ; pattern
 243+ 506E E1               POP HL ; ticks
 244+ 506F D9               EXX
 245+ 5070 F1               POP AF
 246+ 5071 CD 56 4F         CALL Ax5
 247+ 5074 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 248+ 5078 19               ADD HL,DE
 249+ 5079 E5               PUSH HL
 250+ 507A FD E1            POP IY
 251+ 507C D9               EXX
 252+ 507D FD 36 00 00      LD (IY),0 ; type=0
 253+ 5081 FD 75 01         LD (IY+1),L
 254+ 5084 FD 74 02         LD (IY+2),H
 255+ 5087 FD 72 03         LD (IY+3),D
 256+ 508A FD 70 04         LD (IY+4),B
 257+ 508D
 258+ 508D DD E5            PUSH IX
 259+ 508F E1               POP HL
 260+ 5090 C9               RET
 261+ 5091              ; *******************************************************************************************************
 262+ 5091
 263+ 5091              ; *******************************************************************************************************
 264+ 5091              ; function to handle CALL ANIMITEMPTR basic extension
 265+ 5091              ; ANIMITEMPTR ( BYTE id,
 266+ 5091              ;               INT ticks,
 267+ 5091              ;               INT pointer,
 268+ 5091              ; fills animation item data, returns an error if out of bounds
 269+ 5091              ANIMITEMPTR_CMD:
 270+ 5091                  ; opening (
 271+ 5091 CD 8E 55     	CALL CHKCHAR
 272+ 5094 28           	DB '('
 273+ 5095              	; get id
 274+ 5095 DD 21 1C 52  	LD IX, GETBYT
 275+ 5099 CD 59 01     	CALL CALBAS
 276+ 509C F5               PUSH AF
 277+ 509D                  ; check if out of bounds
 278+ 509D 3C               INC A
 279+ 509E 4F               LD C,A
 280+ 509F 3A 4D 4F         LD A,(ANIMITEMNUM)
 281+ 50A2 B9               CP C
 282+ 50A3 DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 283+ 50A6              	; comma
 284+ 50A6 CD 8E 55     	CALL CHKCHAR
 285+ 50A9 2C           	DB ','
 286+ 50AA              	; get ticks
 287+ 50AA DD 21 2F 54  	LD IX, FRMQNT
 288+ 50AE CD 59 01     	CALL CALBAS
 289+ 50B1 D5           	PUSH DE
 290+ 50B2              	; comma
 291+ 50B2 CD 8E 55     	CALL CHKCHAR
 292+ 50B5 2C           	DB ','
 293+ 50B6              	; get pointer
 294+ 50B6 DD 21 2F 54  	LD IX, FRMQNT
 295+ 50BA CD 59 01     	CALL CALBAS
 296+ 50BD D5           	PUSH DE
 297+ 50BE              	; ending )
 298+ 50BE CD 8E 55     	CALL CHKCHAR
 299+ 50C1 29           	DB ')'
 300+ 50C2              .ENTRY:
 301+ 50C2 E5               PUSH HL
 302+ 50C3 DD E1            POP IX
 303+ 50C5 D9               EXX
 304+ 50C6 D1               POP DE ; pointer
 305+ 50C7 E1               POP HL ; ticks
 306+ 50C8 D9               EXX
 307+ 50C9 F1               POP AF
 308+ 50CA CD 56 4F         CALL Ax5
 309+ 50CD ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 310+ 50D1 19               ADD HL,DE
 311+ 50D2 E5               PUSH HL
 312+ 50D3 FD E1            POP IY
 313+ 50D5 D9               EXX
 314+ 50D6 FD 36 00 01      LD (IY),1 ; type=1
 315+ 50DA FD 75 01         LD (IY+1),L
 316+ 50DD FD 74 02         LD (IY+2),H
 317+ 50E0 FD 73 03         LD (IY+3),E
 318+ 50E3 FD 72 04         LD (IY+4),D
 319+ 50E6
 320+ 50E6 DD E5            PUSH IX
 321+ 50E8 E1               POP HL
 322+ 50E9 C9               RET
 323+ 50EA              ; *******************************************************************************************************
 324+ 50EA
 325+ 50EA              ; *******************************************************************************************************
 326+ 50EA              ; function to handle CALL MAXANIMDEFS basic extension
 327+ 50EA              ; MAXANIMDEFS (BYTE number)
 328+ 50EA              ; sets new number and moves memory buffers as needed
 329+ 50EA              MAXANIMDEFS:
 330+ 50EA              	; opening (
 331+ 50EA CD 8E 55     	CALL CHKCHAR
 332+ 50ED 28           	DB '('
 333+ 50EE              	; get value
 334+ 50EE DD 21 1C 52  	LD IX, GETBYT
 335+ 50F2 CD 59 01     	CALL CALBAS
 336+ 50F5 F5               PUSH AF
 337+ 50F6              	; ending )
 338+ 50F6 CD 8E 55     	CALL CHKCHAR
 339+ 50F9 29           	DB ')'
 340+ 50FA F1               POP AF
 341+ 50FB
 342+ 50FB              	; save position
 343+ 50FB E5           	PUSH HL
 344+ 50FC              .ENTRY:
 345+ 50FC 47               LD B,A
 346+ 50FD 3A 50 4F         LD A,(ANIMDEFNUM)
 347+ 5100 90               SUB B
 348+ 5101 CA A3 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 349+ 5104 FD 21 54 4F      LD IY,ANIMSPRPTR
 350+ 5108 FA 14 51         JP M, .INCREASE
 351+ 510B                  ; new value is lower than previous one
 352+ 510B CD 1F 51         CALL .SIZEDIFF
 353+ 510E CD D9 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 354+ 5111 C3 9A 4F         JP MAXANIMITEMS.E1
 355+ 5114              .INCREASE:
 356+ 5114 ED 44            NEG
 357+ 5116 CD 1F 51         CALL .SIZEDIFF
 358+ 5119 CD 05 50         CALL MAXANIMITEMS.INCREASE_COMMON
 359+ 511C C3 B5 4F         JP MAXANIMITEMS.E2
 360+ 511F              .SIZEDIFF:
 361+ 511F 26 00            LD H,0
 362+ 5121 6F               LD L,A
 363+ 5122 CD 7C 54         CALL HLx16
 364+ 5125 78               LD A,B
 365+ 5126 32 50 4F         LD (ANIMDEFNUM),A
 366+ 5129 44               LD B,H
 367+ 512A 4D               LD C,L
 368+ 512B C9               RET ; BC=size difference in bytes
 369+ 512C              ; *******************************************************************************************************
 370+ 512C
 371+ 512C              ; *******************************************************************************************************
 372+ 512C              ; function to handle CALL ANIMDEF basic extension
 373+ 512C              ; ANIMITEMPAT ( BYTE id,
 374+ 512C              ;               BYTE size,
 375+ 512C              ;               INT[] list )
 376+ 512C              ; fills animation definition data, returns an error if out of bounds, or invalid type
 377+ 512C              ANIMDEF:
 378+ 512C                  ; opening (
 379+ 512C CD 8E 55     	CALL CHKCHAR
 380+ 512F 28           	DB '('
 381+ 5130              	; get id
 382+ 5130 DD 21 1C 52  	LD IX, GETBYT
 383+ 5134 CD 59 01     	CALL CALBAS
 384+ 5137 F5               PUSH AF
 385+ 5138                  ; check if out of bounds
 386+ 5138 3C               INC A
 387+ 5139 4F               LD C,A
 388+ 513A 3A 50 4F         LD A,(ANIMDEFNUM)
 389+ 513D B9               CP C
 390+ 513E DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 391+ 5141              	; comma
 392+ 5141 CD 8E 55     	CALL CHKCHAR
 393+ 5144 2C           	DB ','
 394+ 5145              	; get size
 395+ 5145 DD 21 1C 52  	LD IX, GETBYT
 396+ 5149 CD 59 01     	CALL CALBAS
 397+ 514C FE 10            CP 16
 398+ 514E D2 A8 55         JP NC, OVERFLOW
 399+ 5151 B7               OR A
 400+ 5152 CA A8 55         JP Z, OVERFLOW
 401+ 5155 F5           	PUSH AF
 402+ 5156              	; comma
 403+ 5156 CD 8E 55     	CALL CHKCHAR
 404+ 5159 2C           	DB ','
 405+ 515A              	; get pointer to a list of animation items in integer array format
 406+ 515A 3E 01            LD A,1
 407+ 515C 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 408+ 515F DD 21 A4 5E  	LD IX, PTRGET
 409+ 5163 CD 59 01     	CALL CALBAS
 410+ 5166                  ; contrary to documentation we get a pointer to array dimension in BC
 411+ 5166                  ; and type in VALTYP
 412+ 5166 3A 63 F6         LD A,(VALTYP)
 413+ 5169 FE 02            CP 2
 414+ 516B C2 A0 55         JP NZ,TYPE_MISMATCH
 415+ 516E 0A               LD A,(BC)
 416+ 516F FE 01            CP 1
 417+ 5171 C2 A0 55         JP NZ,TYPE_MISMATCH
 418+ 5174 03               INC BC
 419+ 5175 0A               LD A,(BC)
 420+ 5176 D1               POP DE
 421+ 5177 D5               PUSH DE
 422+ 5178 3C               INC A
 423+ 5179 BA               CP D
 424+ 517A DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 425+ 517D 03          > INC BC
 425+ 517E 03          > INC BC
 426+ 517F C5               PUSH BC
 427+ 5180              	; ending )
 428+ 5180 CD 8E 55     	CALL CHKCHAR
 429+ 5183 29           	DB ')'
 430+ 5184              .ENTRY:
 431+ 5184 E5               PUSH HL
 432+ 5185 DD E1            POP IX
 433+ 5187 D1               POP DE ; pointer to INT array
 434+ 5188 C1               POP BC ; B=item number
 435+ 5189 F1               POP AF ; id
 436+ 518A 26 00            LD H,0
 437+ 518C 6F               LD L,A
 438+ 518D CD 7C 54         CALL HLx16
 439+ 5190 D5               PUSH DE
 440+ 5191 ED 5B 51 4F      LD DE,(ANIMDEFPTR)
 441+ 5195 19               ADD HL,DE
 442+ 5196 D1               POP DE
 443+ 5197 70               LD (HL),B
 444+ 5198              .L1:
 445+ 5198 23               INC HL
 446+ 5199 1A               LD A,(DE)
 447+ 519A 13          > INC DE
 447+ 519B 13          > INC DE
 448+ 519C 77               LD (HL),A
 449+ 519D 10 F9            DJNZ .L1
 450+ 519F DD E5            PUSH IX
 451+ 51A1 E1               POP HL
 452+ 51A2 C9               RET
 453+ 51A3              ; *******************************************************************************************************
 454+ 51A3
 455+ 51A3              ; *******************************************************************************************************
 456+ 51A3              ; function to handle CALL MAXANIMSPRS basic extension
 457+ 51A3              ; MAXANIMSPRS (BYTE number)
 458+ 51A3              ; sets new number and moves memory buffers as needed
 459+ 51A3              MAXANIMSPRS:
 460+ 51A3              	; opening (
 461+ 51A3 CD 8E 55     	CALL CHKCHAR
 462+ 51A6 28           	DB '('
 463+ 51A7              	; get value
 464+ 51A7 DD 21 1C 52  	LD IX, GETBYT
 465+ 51AB CD 59 01     	CALL CALBAS
 466+ 51AE F5               PUSH AF
 467+ 51AF              	; ending )
 468+ 51AF CD 8E 55     	CALL CHKCHAR
 469+ 51B2 29           	DB ')'
 470+ 51B3 F1               POP AF
 471+ 51B4
 472+ 51B4              	; save position
 473+ 51B4 E5           	PUSH HL
 474+ 51B5              .ENTRY:
 475+ 51B5 47               LD B,A
 476+ 51B6 3A 53 4F         LD A,(ANIMSPRNUM)
 477+ 51B9 90               SUB B
 478+ 51BA CA A3 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 479+ 51BD FD 21 10 40      LD IY,FREEMEMPTR
 480+ 51C1 FA CD 51         JP M, .INCREASE
 481+ 51C4                  ; new value is lower than previous one
 482+ 51C4 CD EC 51         CALL .SIZEDIFF
 483+ 51C7 CD D9 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 484+ 51CA C3 A3 4F         JP MAXANIMITEMS.EXIT
 485+ 51CD              .INCREASE:
 486+ 51CD ED 44            NEG
 487+ 51CF F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 488+ 51D0 CD EC 51         CALL .SIZEDIFF
 489+ 51D3 CD 05 50         CALL MAXANIMITEMS.INCREASE_COMMON
 490+ 51D6 AF               XOR A
 491+ 51D7 ED 42            SBC HL,BC ; location of new stuff
 492+ 51D9 F1               POP AF
 493+ 51DA 47               LD B,A
 494+ 51DB 11 08 00         LD DE,8
 495+ 51DE E5               PUSH HL
 496+ 51DF DD E1            POP IX
 497+ 51E1              .L1:
 498+ 51E1 DD 36 06 00      LD (IX+6),0
 499+ 51E5 DD 19            ADD IX,DE
 500+ 51E7 10 F8            DJNZ .L1
 501+ 51E9 C3 A3 4F         JP MAXANIMITEMS.EXIT
 502+ 51EC              .SIZEDIFF:
 503+ 51EC 26 00            LD H,0
 504+ 51EE 6F               LD L,A
 505+ 51EF CD 7D 54         CALL HLx8
 506+ 51F2 78               LD A,B
 507+ 51F3 32 53 4F         LD (ANIMSPRNUM),A
 508+ 51F6 44               LD B,H
 509+ 51F7 4D               LD C,L
 510+ 51F8 C9               RET ; BC=size difference in bytes
 511+ 51F9              ; *******************************************************************************************************
 512+ 51F9
 513+ 51F9              ; *******************************************************************************************************
 514+ 51F9              ; function to handle CALL ANIMSPRITE basic extension
 515+ 51F9              ; ANIMSPRITE ( BYTE id,
 516+ 51F9              ;              BYTE sprite_number,
 517+ 51F9              ;              BYTE animation_definition_id,
 518+ 51F9              ;              BYTE cyclic_flag )
 519+ 51F9              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 520+ 51F9              ANIMSPRITE:
 521+ 51F9                  ; opening (
 522+ 51F9 CD 8E 55     	CALL CHKCHAR
 523+ 51FC 28           	DB '('
 524+ 51FD              	; get sprite animation id
 525+ 51FD DD 21 1C 52  	LD IX, GETBYT
 526+ 5201 CD 59 01     	CALL CALBAS
 527+ 5204 F5               PUSH AF
 528+ 5205 3C               INC A
 529+ 5206 4F               LD C,A
 530+ 5207 3A 53 4F         LD A,(ANIMSPRNUM)
 531+ 520A B9               CP C
 532+ 520B DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 533+ 520E              	; comma
 534+ 520E CD 8E 55     	CALL CHKCHAR
 535+ 5211 2C           	DB ','
 536+ 5212              	; get sprite number
 537+ 5212 DD 21 1C 52  	LD IX, GETBYT
 538+ 5216 CD 59 01     	CALL CALBAS
 539+ 5219 F5               PUSH AF
 540+ 521A                  ; check if out of bounds
 541+ 521A FE 20            CP 32
 542+ 521C D2 A4 55         JP NC, SUBSCRIPT_OUT_OF_RANGE
 543+ 521F              	; comma
 544+ 521F CD 8E 55     	CALL CHKCHAR
 545+ 5222 2C           	DB ','
 546+ 5223              	; get animation definition id
 547+ 5223 DD 21 1C 52  	LD IX, GETBYT
 548+ 5227 CD 59 01     	CALL CALBAS
 549+ 522A F5               PUSH AF
 550+ 522B 3C               INC A
 551+ 522C 4F               LD C,A
 552+ 522D 3A 50 4F         LD A,(ANIMDEFNUM)
 553+ 5230 B9               CP C
 554+ 5231 DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 555+ 5234              	; comma
 556+ 5234 CD 8E 55     	CALL CHKCHAR
 557+ 5237 2C           	DB ','
 558+ 5238              	; get cyclic flag
 559+ 5238 DD 21 1C 52  	LD IX, GETBYT
 560+ 523C CD 59 01         CALL CALBAS
 561+ 523F F5           	PUSH AF
 562+ 5240              	; ending )
 563+ 5240 CD 8E 55     	CALL CHKCHAR
 564+ 5243 29           	DB ')'
 565+ 5244              .ENTRY:
 566+ 5244 E5               PUSH HL
 567+ 5245 DD E1            POP IX
 568+ 5247 D9               EXX
 569+ 5248 D1               POP DE ; cyclic
 570+ 5249 C1               POP BC ; animation definition id
 571+ 524A E1               POP HL ; sprite number
 572+ 524B D9               EXX
 573+ 524C F1               POP AF ; sprite animation id
 574+ 524D 26 00            LD H,0
 575+ 524F 6F               LD L,A
 576+ 5250 CD 7D 54         CALL HLx8
 577+ 5253 ED 5B 54 4F      LD DE,(ANIMSPRPTR)
 578+ 5257 19               ADD HL,DE
 579+ 5258 E5               PUSH HL
 580+ 5259 FD E1            POP IY
 581+ 525B D9               EXX
 582+ 525C FD 74 00         LD (IY),H
 583+ 525F FD 70 04         LD (IY+4),B
 584+ 5262 FD 72 05         LD (IY+5),D
 585+ 5265                  ;LD (IY+6),0
 586+ 5265 DD E5            PUSH IX
 587+ 5267 E1               POP HL
 588+ 5268 C9               RET
 589+ 5269              ; *******************************************************************************************************
 590+ 5269
 591+ 5269              ; *******************************************************************************************************
 592+ 5269              ; function to handle CALL ANIMSTART basic extension
 593+ 5269              ; two forms
 594+ 5269              ; ANIMSTART ( BYTE id )
 595+ 5269              ; or
 596+ 5269              ; ANIMSTART ( BYTE item_number,
 597+ 5269              ;             INT[] sprite_animations )
 598+ 5269              ; sets active flag to 1
 599+ 5269              ANIMSTART:
 600+ 5269 3E 01            LD A,1
 601+ 526B 18 01            JR ANIMSTARTSTOP_COMMON
 602+ 526D              ; *******************************************************************************************************
 603+ 526D              ; *******************************************************************************************************
 604+ 526D              ; function to handle CALL ANIMSTOP basic extension
 605+ 526D              ; two forms
 606+ 526D              ; ANIMSTOP ( BYTE id )
 607+ 526D              ; or
 608+ 526D              ; ANIMSTOP ( BYTE item_number,
 609+ 526D              ;            INT[] sprite_animations )
 610+ 526D              ; sets active flag to 1
 611+ 526D              ANIMSTOP:
 612+ 526D AF               XOR A
 613+ 526E              ANIMSTARTSTOP_COMMON:
 614+ 526E 32 DF 52         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
 615+ 5271              ; *******************************************************************************************************
 616+ 5271                  ; opening (
 617+ 5271 CD 8E 55     	CALL CHKCHAR
 618+ 5274 28           	DB '('
 619+ 5275              	; get sprite animation id or array size
 620+ 5275 DD 21 1C 52  	LD IX,GETBYT
 621+ 5279 CD 59 01     	CALL CALBAS
 622+ 527C F5               PUSH AF
 623+ 527D                  ; check if comma present
 624+ 527D CD 98 55         CALL GETPREVCHAR
 625+ 5280 FE 2C            CP ','
 626+ 5282 28 0C            JR Z,.L1
 627+ 5284 FE 29            CP ')'
 628+ 5286 C2 AC 55         JP NZ,SYNTAX_ERROR
 629+ 5289                  ; ok so single argument variant
 630+ 5289 F1               POP AF
 631+ 528A E5               PUSH HL
 632+ 528B CD CC 52         CALL .SETVALUE
 633+ 528E E1               POP HL
 634+ 528F C9               RET
 635+ 5290              .L1:
 636+ 5290                  ; array of items
 637+ 5290              	; get pointer to a list of animation items in integer array format
 638+ 5290 3E 01            LD A,1
 639+ 5292 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 640+ 5295 DD 21 A4 5E  	LD IX, PTRGET
 641+ 5299 CD 59 01     	CALL CALBAS
 642+ 529C                  ; contrary to documentation we get a pointer to array dimension in BC
 643+ 529C                  ; and type in VALTYP
 644+ 529C 3A 63 F6         LD A,(VALTYP)
 645+ 529F FE 02            CP 2
 646+ 52A1 C2 A0 55         JP NZ,TYPE_MISMATCH
 647+ 52A4 0A               LD A,(BC)
 648+ 52A5 FE 01            CP 1
 649+ 52A7 C2 A0 55         JP NZ,TYPE_MISMATCH
 650+ 52AA 03               INC BC
 651+ 52AB 0A               LD A,(BC)
 652+ 52AC D1               POP DE
 653+ 52AD D5               PUSH DE
 654+ 52AE 3C               INC A
 655+ 52AF BA               CP D
 656+ 52B0 DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 657+ 52B3 03          > INC BC
 657+ 52B4 03          > INC BC
 658+ 52B5 C5               PUSH BC
 659+ 52B6              	; ending )
 660+ 52B6 CD 8E 55     	CALL CHKCHAR
 661+ 52B9 29           	DB ')'
 662+ 52BA D1               POP DE ; array pointer
 663+ 52BB C1               POP BC ; number of items
 664+ 52BC E5               PUSH HL
 665+ 52BD F3               DI
 666+ 52BE              .L2:
 667+ 52BE C5               PUSH BC
 668+ 52BF 1A               LD A,(DE)
 669+ 52C0 13          > INC DE
 669+ 52C1 13          > INC DE
 670+ 52C2 D5               PUSH DE
 671+ 52C3 CD CC 52         CALL .SETVALUE
 672+ 52C6 D1               POP DE
 673+ 52C7 C1               POP BC
 674+ 52C8 10 F4            DJNZ .L2
 675+ 52CA FB               EI
 676+ 52CB C9               RET
 677+ 52CC
 678+ 52CC              .SETVALUE:
 679+ 52CC 47               LD B,A
 680+ 52CD 3C               INC A
 681+ 52CE 4F               LD C,A
 682+ 52CF 3A 53 4F         LD A,(ANIMSPRNUM)
 683+ 52D2 B9               CP C
 684+ 52D3 DA A4 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 685+ 52D6 CD 5F 4F         CALL GETnthSPRANIM
 686+ 52D9 E5               PUSH HL
 687+ 52DA DD E1            POP IX
 688+ 52DC              .VALUE:
 689+ 52DC DD 36 06 01      LD (IX+6),1
 690+ 52E0 C9               RET
 691+ 52E1              ; *******************************************************************************************************
 692+ 52E1
# file closed: asm\ANIMATION.asm
 127  52E1               ENDIF
 128  52E1
 129  52E1              ; temp variables for BLIT, TILE functions
 130  52E1               IF (BLIT_CMDS + TILE_CMDS > 0)
 131  52E1              BLIT_TMP:
 132  52E1              TILETMP1:
 133  52E1              BLIT_TMP1:
 134  52E1 00 00         DW 0
 135  52E3              TILETMP2:
 136  52E3              BLIT_TMP2:
 137  52E3 00 00         DW 0
 138  52E5                IFDEF CMDS_WITH_PARAMETERS
 139  52E5              BLIT_STRUCT:
 140  52E5 00 00 00...   DS 17
 141  52E9                ENDIF
 142  52E9               ENDIF
 143  52F6
 144  52F6              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 145  52F6              ; per starting letter, if no commands with this letter, NULL value
 146  52F6              CMDS:
 147  52F6               IF (ANIM_CMDS == 1)
 148  52F6 1F 54        	DW CMDS_A ;
 149  52F8               ELSE
 150  52F8 ~                DW 0 ; A
 151  52F8               ENDIF
 152  52F8               IF (BLIT_CMDS + BOX_CMDS > 0)
 153  52F8 EA 53            DW CMDS_B ; B
 154  52FA               ELSE
 155  52FA ~            	DW 0
 156  52FA               ENDIF
 157  52FA 00 00            DW 0 ; C
 158  52FC 00 00            DW 0 ; D
 159  52FE 00 00            DW 0 ; E
 160  5300               IF (VRAM_CMDS + RAM_CMDS > 0)
 161  5300 68 53            DW CMDS_F; F
 162  5302               ELSE
 163  5302 ~            	DW 0
 164  5302               ENDIF
 165  5302               IF (GENCAL_CMD > 0)
 166  5302 7B 53            DW CMDS_G; G
 167  5304               ELSE
 168  5304 ~            	DW 0
 169  5304               ENDIF
 170  5304 00 00            DW 0 ; H
 171  5306 00 00            DW 0 ; I
 172  5308 00 00            DW 0 ; J
 173  530A 00 00            DW 0 ; K
 174  530C 00 00            DW 0 ; L
 175  530E               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 176  530E 2A 53            DW CMDS_M ; M
 177  5310               ELSE
 178  5310 ~            	DW 0
 179  5310               ENDIF
 180  5310 00 00            DW 0 ; N
 181  5312 00 00            DW 0 ; O
 182  5314 00 00            DW 0 ; P
 183  5316 00 00            DW 0 ; Q
 184  5318 00 00            DW 0 ; R
 185  531A               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 186  531A 8F 53            DW CMDS_S ; S
 187  531C               ELSE
 188  531C ~            	DW 0
 189  531C               ENDIF
 190  531C               IF (TILE_CMDS > 0)
 191  531C 0A 54            DW CMDS_T ; T
 192  531E               ELSE
 193  531E ~            	DW 0
 194  531E               ENDIF
 195  531E 00 00            DW 0 ; U
 196  5320               IF (VRAM_CMDS > 0)
 197  5320 85 53            DW CMDS_V ; V
 198  5322               ELSE
 199  5322 ~            	DW 0
 200  5322               ENDIF
 201  5322 00 00            DW 0 ; W
 202  5324 00 00            DW 0 ; X
 203  5326 00 00            DW 0 ; Y
 204  5328 00 00            DW 0 ; Z
 205  532A
 206  532A              CMDS_M:
 207  532A               IF (VRAM_CMDS == 1)
 208  532A 4D 45 4D 56      DB "MEMVRM", 0
 208  532E 52 4D 00
 209  5331 F6 56            DW MEMVRM
 210  5333               ENDIF
 211  5333               IF (RAM_CMDS == 1)
 212  5333 4D 45 4D 43  	DB "MEMCPY", 0
 212  5337 50 59 00
 213  533A B5 55        	DW MEMCPY
 214  533C               ENDIF
 215  533C               IF (ANIM_CMDS == 1)
 216  533C 4D 41 58 41  	DB "MAXANIMITEMS",0
 216  5340 4E 49 4D 49
 216  5344 54 45 4D 53
 216  5348 00
 217  5349 6B 4F        	DW MAXANIMITEMS
 218  534B 4D 41 58 41  	DB "MAXANIMDEFS",0
 218  534F 4E 49 4D 44
 218  5353 45 46 53 00
 219  5357 EA 50        	DW MAXANIMDEFS
 220  5359 4D 41 58 41  	DB "MAXANIMSPRS",0
 220  535D 4E 49 4D 53
 220  5361 50 52 53 00
 221  5365 A3 51        	DW MAXANIMSPRS
 222  5367               ENDIF
 223  5367               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 224  5367 00           	DB 0
 225  5368               ENDIF
 226  5368              CMDS_F:
 227  5368               IF (VRAM_CMDS == 1)
 228  5368 46 49 4C 56      DB "FILVRM", 0
 228  536C 52 4D 00
 229  536F F8 55            DW FILVRM
 230  5371               ENDIF
 231  5371               IF (RAM_CMDS == 1)
 232  5371 46 49 4C 52      DB "FILRAM", 0
 232  5375 41 4D 00
 233  5378 3F 56            DW FILRAM
 234  537A               ENDIF
 235  537A               IF (VRAM_CMDS + RAM_CMDS > 0)
 236  537A 00               DB 0
 237  537B               ENDIF
 238  537B              CMDS_G:
 239  537B               IF (GENCAL_CMD == 1)
 240  537B 47 45 4E 43      DB "GENCAL", 0
 240  537F 41 4C 00
 241  5382 9D 56            DW GENCAL
 242  5384               ENDIF
 243  5384               IF (GENCAL_CMD > 0)
 244  5384 00           	DB	0
 245  5385               ENDIF
 246  5385              CMDS_V:
 247  5385               IF (VRAM_CMDS == 1)
 248  5385 56 52 4D 4D  	DB "VRMMEM", 0
 248  5389 45 4D 00
 249  538C 6E 57        	DW VRMMEM
 250  538E               ENDIF
 251  538E               IF (VRAM_CMDS > 0)
 252  538E 00           	DB 0
 253  538F               ENDIF
 254  538F              CMDS_S:
 255  538F               IF (SPRITE_CMDS == 1)
 256  538F 53 50 52 53  	DB "SPRSET", 0
 256  5393 45 54 00
 257  5396 0E 4E        	DW SPRSET
 258  5398 53 50 52 47  	DB "SPRGRPMOV", 0
 258  539C 52 50 4D 4F
 258  53A0 56 00
 259  53A2 CC 4E        	DW SPRGRPMOV
 260  53A4               ENDIF
 261  53A4               IF (SOUND_CMDS == 1)
 262  53A4 53 4E 44 53  	DB "SNDSFX", 0
 262  53A8 46 58 00
 263  53AB AC 58        	DW SNDSFX
 264  53AD 53 4E 44 50  	DB "SNDPLYON", 0
 264  53B1 4C 59 4F 4E
 264  53B5 00
 265  53B6 76 58        	DW SNDPLYON
 266  53B8 53 4E 44 50  	DB "SNDPLYOFF", 0
 266  53BC 4C 59 4F 46
 266  53C0 46 00
 267  53C2 89 58        	DW SNDPLYOFF
 268  53C4 53 4E 44 50  	DB "SNDPLYINI", 0
 268  53C8 4C 59 49 4E
 268  53CC 49 00
 269  53CE 2C 58        	DW SNDPLYINIT
 270  53D0               ENDIF
 271  53D0               IF (SPRITE_CMDS == 1)
 272  53D0 53 50 52 45  	DB "SPRENABLE", 0
 272  53D4 4E 41 42 4C
 272  53D8 45 00
 273  53DA B9 4D        	DW SPRENABLE
 274  53DC 53 50 52 44  	DB "SPRDISABLE", 0
 274  53E0 49 53 41 42
 274  53E4 4C 45 00
 275  53E7 09 4E        	DW SPRDISABLE
 276  53E9               ENDIF
 277  53E9               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 278  53E9 00           	DB 0
 279  53EA               ENDIF
 280  53EA              CMDS_B:
 281  53EA               IF (BLIT_CMDS == 1)
 282  53EA 42 4C 49 54  	DB "BLIT", 0
 282  53EE 00
 283  53EF 83 5A        	DW BLIT
 284  53F1               ENDIF
 285  53F1               IF (BOX_CMDS == 1)
 286  53F1 42 4F 58 4D  	DB "BOXMEMCPY", 0
 286  53F5 45 4D 43 50
 286  53F9 59 00
 287  53FB BB 5D        	DW BOXMEMCPY
 288  53FD 42 4F 58 4D  	DB "BOXMEMVRM", 0
 288  5401 45 4D 56 52
 288  5405 4D 00
 289  5407 EF 5D        	DW BOXMEMVRM
 290  5409               ENDIF
 291  5409               IF (BLIT_CMDS + BOX_CMDS > 0)
 292  5409 00           	DB 0
 293  540A               ENDIF
 294  540A              CMDS_T:
 295  540A               IF (TILE_CMDS == 1)
 296  540A 54 49 4C 45  	DB "TILERAM", 0
 296  540E 52 41 4D 00
 297  5412 C7 5B        	DW TILERAM
 298  5414 54 49 4C 45  	DB "TILEVRM", 0
 298  5418 56 52 4D 00
 299  541C CA 5C        	DW TILEVRM
 300  541E               ENDIF
 301  541E               IF (TILE_CMDS > 0)
 302  541E 00           	DB 0
 303  541F               ENDIF
 304  541F              CMDS_A:
 305  541F               IF (ANIM_CMDS == 1)
 306  541F 41 4E 49 4D  	DB "ANIMSTART",0
 306  5423 53 54 41 52
 306  5427 54 00
 307  5429 69 52        	DW ANIMSTART
 308  542B 41 4E 49 4D  	DB "ANIMSTOP",0
 308  542F 53 54 4F 50
 308  5433 00
 309  5434 6D 52        	DW ANIMSTOP
 310  5436 41 4E 49 4D  	DB "ANIMITEMPAT",0
 310  543A 49 54 45 4D
 310  543E 50 41 54 00
 311  5442 2B 50        	DW ANIMITEMPAT
 312  5444 41 4E 49 4D  	DB "ANIMITEMPTR",0
 312  5448 49 54 45 4D
 312  544C 50 54 52 00
 313  5450 91 50        	DW ANIMITEMPTR_CMD
 314  5452 41 4E 49 4D  	DB "ANIMDEF",0
 314  5456 44 45 46 00
 315  545A 2C 51        	DW ANIMDEF
 316  545C 41 4E 49 4D  	DB "ANIMSPRITE",0
 316  5460 53 50 52 49
 316  5464 54 45 00
 317  5467 F9 51        	DW ANIMSPRITE
 318  5469 00           	DB 0
 319  546A               ENDIF
 320  546A
 321  546A               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 322  546A              ; ****************************************************************************************************
 323  546A              ; function sets VRAM address
 324  546A              ; input HL=address
 325  546A              ; modifies AF
 326  546A              SETWRT_LOCAL:
 327  546A 7D           	LD	A, L
 328  546B D3 99        	OUT	(099H), A
 329  546D 7C           	LD	A, H
 330  546E E6 3F        	AND	03FH
 331  5470 F6 40        	OR	040H
 332  5472 D3 99        	OUT	(099H), A
 333  5474 C9           	RET
 334  5475              ; ****************************************************************************************************
 335  5475               ENDIF
 336  5475
 337  5475               IF (VRAM_CMDS + TILE_CMDS > 0)
 338  5475              ; ****************************************************************************************************
 339  5475              ; function copies data from RAM to VRAM
 340  5475              ; input HL=address in RAM
 341  5475              ; input B=count
 342  5475              ; modifies AF
 343  5475              BBYTECOPY:
 344  5475 ED A3        	OUTI
 345  5477 C2 75 54     	JP	NZ, BBYTECOPY
 346  547A C9           	RET
 347  547B              ; ****************************************************************************************************
 348  547B               ENDIF
 349  547B
 350  547B              ; ****************************************************************************************************
 351  547B              ; function multiplies HL by 32
 352  547B              HPx32:
 353  547B 29           	ADD HL,HL
 354  547C              ; ****************************************************************************************************
 355  547C              ; function multiplies HL by 16
 356  547C              HLx16:
 357  547C 29           	ADD HL,HL
 358  547D              ; ****************************************************************************************************
 359  547D              ; function multiplies HL by 8
 360  547D              HLx8:
 361  547D 29          > ADD HL, HL
 361  547E 29          > ADD HL, HL
 361  547F 29          > ADD HL, HL
 362  5480 C9           	RET
 363  5481              ; ****************************************************************************************************
 364  5481
 365  5481              ; ****************************************************************************************************
 366  5481              ; function gets slot and subslot data for specific page
 367  5481              ; input A=page (0, 1 or 2)
 368  5481              ; output B = 0A8H register value
 369  5481              ; output D = 0 is no subslots, 1 if yes
 370  5481              ; output C = 0A8H value when page 3 slot equals to requested page slot
 371  5481              ; output E = subslot value if present
 372  5481              ; modifies AF, BC, DE, HL
 373  5481              GET_PAGE_INFO:
 374  5481 6F               LD L, A
 375  5482 C6 C1            ADD A, low (EXPTBL)
 376  5484 32 8E 54         LD (GET_PAGE_INFO_L1+1), A
 377  5487 DB A8            IN A, (0A8H)
 378  5489 47               LD B, A
 379  548A E6 3F            AND 03FH
 380  548C 4F               LD C, A
 381  548D              GET_PAGE_INFO_L1:
 382  548D 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 383  5490 E6 80            AND 080H
 384  5492 28 1B            JR Z, GET_PAGE_INFO_L2
 385  5494                  ; expanded
 386  5494 2D               DEC L
 387  5495 FA B4 54         JP M, GET_PAGE_INFO_L3
 388  5498 2D               DEC L
 389  5499 FA B2 54         JP M, GET_PAGE_INFO_L4
 390  549C                  ; page 2
 391  549C 07               RLCA
 392  549D 07               RLCA
 393  549E              GET_PAGE_INFO_L5:
 394  549E E6 C0            AND 0C0H
 395  54A0 B1               OR C
 396  54A1 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 397  54A3 4F               LD C, A
 398  54A4 3A FF FF         LD A, (0FFFFH)
 399  54A7 2F               CPL
 400  54A8 5F               LD E, A
 401  54A9 16 01            LD D, 1
 402  54AB 78               LD A, B ; return stack
 403  54AC D3 A8            OUT (0A8H), A
 404  54AE C9               RET
 405  54AF              GET_PAGE_INFO_L2:
 406  54AF                  ; not expanded
 407  54AF 16 00            LD D, 0
 408  54B1 C9               RET
 409  54B2              GET_PAGE_INFO_L4:
 410  54B2                  ; page 1
 411  54B2 0F               RRCA
 412  54B3 0F               RRCA
 413  54B4              GET_PAGE_INFO_L3:
 414  54B4                  ; page 0
 415  54B4 0F               RRCA
 416  54B5 0F               RRCA
 417  54B6 18 E6            JR GET_PAGE_INFO_L5
 418  54B8              ; ****************************************************************************************************
 419  54B8
 420  54B8              ; ****************************************************************************************************
 421  54B8              ; function returns original slot and subslot info
 422  54B8              ; input B = 0A8H register value
 423  54B8              ; input D = 0 is no subslots, 1 if yes
 424  54B8              ; input C = 0A8H value when page 3 slot equals to requested page slot
 425  54B8              ; input E = subslot value if present
 426  54B8              ; modifies AF, disables interrupts
 427  54B8              RESTORE_PAGE_INFO:
 428  54B8 7A               LD A, D
 429  54B9 B7               OR A
 430  54BA 28 08            JR Z, RESTORE_PAGE_INFO_L1
 431  54BC 79               LD A, C
 432  54BD F3           	DI
 433  54BE D3 A8            OUT (0A8H), A
 434  54C0 7B               LD A, E
 435  54C1 32 FF FF         LD (0FFFFH), A
 436  54C4              RESTORE_PAGE_INFO_L1:
 437  54C4 78               LD A, B
 438  54C5 D3 A8            OUT (0A8H), A
 439  54C7 C9               RET
 440  54C8              ; ****************************************************************************************************
 441  54C8
 442  54C8              ; *******************************************************************************************************
 443  54C8              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 444  54C8              ; INPUT:  A = SLOT ID: EXXXSSPP
 445  54C8              ; E = EXPANDED FLAG
 446  54C8              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 447  54C8              ; PP = PRIMARY SLOT NUMBER
 448  54C8              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 449  54C8              ; CHANGES: AF, BC, DE
 450  54C8
 451  54C8              LOCAL_ENASLT:
 452  54C8 CD E8 54         CALL L0353
 453  54CB FA D5 54         JP M, L0340
 454  54CE DB A8            IN A, (0A8H)
 455  54D0 A1               AND C
 456  54D1 B0               OR B
 457  54D2 D3 A8            OUT (0A8H), A
 458  54D4 C9               RET
 459  54D5              L0340:
 460  54D5 E5               PUSH HL
 461  54D6 CD 0D 55         CALL L0378
 462  54D9 4F               LD C, A
 463  54DA 06 00            LD B, 0
 464  54DC 7D               LD A, L
 465  54DD A4               AND H
 466  54DE B2               OR D
 467  54DF 21 C5 FC         LD HL, 0FCC5H
 468  54E2 09               ADD HL, BC
 469  54E3 77               LD (HL), A
 470  54E4 E1               POP HL
 471  54E5 79               LD A, C
 472  54E6 18 E0            JR LOCAL_ENASLT
 473  54E8              L0353:
 474  54E8 F3               DI
 475  54E9 F5               PUSH AF
 476  54EA 7C               LD A, H
 477  54EB 07               RLCA
 478  54EC 07               RLCA
 479  54ED E6 03            AND 3
 480  54EF 5F               LD E, A
 481  54F0 3E C0            LD A, 0C0H
 482  54F2              L035D:
 483  54F2 07               RLCA
 484  54F3 07               RLCA
 485  54F4 1D               DEC E
 486  54F5 F2 F2 54         JP P, L035D
 487  54F8 5F               LD E, A
 488  54F9 2F               CPL
 489  54FA 4F               LD C, A
 490  54FB F1               POP AF
 491  54FC F5               PUSH AF
 492  54FD E6 03            AND 3
 493  54FF 3C               INC A
 494  5500 47               LD B, A
 495  5501 3E AB            LD A, 0ABH
 496  5503              L036E:
 497  5503 C6 55            ADD A, 055H
 498  5505 10 FC            DJNZ L036E
 499  5507 57               LD D, A
 500  5508 A3               AND E
 501  5509 47               LD B, A
 502  550A F1               POP AF
 503  550B A7               AND A
 504  550C C9               RET
 505  550D              L0378:
 506  550D F5               PUSH AF
 507  550E 7A               LD A, D
 508  550F E6 C0            AND 0C0H
 509  5511 4F               LD C, A
 510  5512 F1               POP AF
 511  5513 F5               PUSH AF
 512  5514 57               LD D, A
 513  5515 DB A8            IN A, (0A8H)
 514  5517 47               LD B, A
 515  5518 E6 3F            AND 03FH
 516  551A B1               OR C
 517  551B D3 A8            OUT (0A8H), A
 518  551D 7A               LD A, D
 519  551E 0F               RRCA
 520  551F 0F               RRCA
 521  5520 E6 03            AND 3
 522  5522 57               LD D, A
 523  5523 3E AB            LD A, 0ABH
 524  5525              L0390:
 525  5525 C6 55            ADD A, 055H
 526  5527 15               DEC D
 527  5528 F2 25 55         JP P, L0390
 528  552B A3               AND E
 529  552C 57               LD D, A
 530  552D 7B               LD A, E
 531  552E 2F               CPL
 532  552F 67               LD H, A
 533  5530 3A FF FF         LD A, (0FFFFH)
 534  5533 2F               CPL
 535  5534 6F               LD L, A
 536  5535 A4               AND H
 537  5536 B2               OR D
 538  5537 32 FF FF         LD (0FFFFH), A
 539  553A 78               LD A, B
 540  553B D3 A8            OUT (0A8H), A
 541  553D F1               POP AF
 542  553E E6 03            AND 3
 543  5540 C9               RET
 544  5541              ; *******************************************************************************************************
 545  5541
 546  5541              ; *******************************************************************************************************
 547  5541              ; some common code to activate page 0 and place values needed to restore original page on stack
 548  5541              ; input IY=return address
 549  5541              ENABLE_PAGE0:
 550  5541 AF               XOR A
 551  5542 CD 81 54         CALL GET_PAGE_INFO
 552  5545 C5               PUSH BC
 553  5546 D5               PUSH DE
 554  5547 3A 41 F3         LD A, (RAMAD0)
 555  554A 26 00            LD H, 0
 556  554C CD C8 54         CALL LOCAL_ENASLT
 557  554F FD E9        	JP (IY)
 558  5551              ; *******************************************************************************************************
 559  5551
 560  5551              ; General BASIC CALL-instruction handler
 561  5551              CALLHAND:
 562  5551 E5           	PUSH HL
 563  5552 21 F6 52     	LD	HL, CMDS ; pointer table based on starting letter
 564  5555 3A 89 FD         LD A, (PROCNM)
 565  5558 D6 41            SUB 'A'
 566  555A 87               ADD A, A
 567  555B 16 00            LD D, 0
 568  555D 5F               LD E, A
 569  555E 19               ADD HL, DE
 570  555F 5E               LD E, (HL)
 571  5560 23               INC HL
 572  5561 56               LD D, (HL)
 573  5562 7A               LD A, D
 574  5563 B3               OR E
 575  5564 28 23            JR Z, .CMDNOTRECOGNIZED
 576  5566 EB               EX DE, HL
 577  5567              .CHKCMD:
 578  5567 11 89 FD     	LD	DE, PROCNM
 579  556A 1A           .LOOP:	LD	A,(DE)
 580  556B BE           	CP	(HL)
 581  556C 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 582  556E 13           	INC	DE
 583  556F 23           	INC	HL
 584  5570 A7           	AND	A
 585  5571 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 586  5573 5E           	LD	E,(HL)
 587  5574 23           	INC	HL
 588  5575 56           	LD	D,(HL)
 589  5576 E1           	POP	HL		; routine address
 590  5577 CD 98 55     	CALL	GETPREVCHAR
 591  557A CD 8C 55     	CALL	.CALLDE		; Call routine
 592  557D A7           	AND	A
 593  557E C9           	RET
 594  557F
 595  557F              .TONEXTCMD:
 596  557F 0E FF        	LD	C,0FFH
 597  5581 AF           	XOR	A
 598  5582 ED B1        	CPIR			; Skip to end of instruction name
 599  5584 23           	INC	HL
 600  5585 23           	INC	HL		; Skip address
 601  5586 BE           	CP	(HL)
 602  5587 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 603  5589              .CMDNOTRECOGNIZED:
 604  5589 E1           	POP	HL
 605  558A 37               SCF
 606  558B C9           	RET
 607  558C
 608  558C              .CALLDE:
 609  558C D5           	PUSH	DE
 610  558D C9           	RET
 611  558E
 612  558E              ;---------------------------
 613  558E
 614  558E              ;GETSTRPNT:
 615  558E              ; OUT:
 616  558E              ; HL = String Address
 617  558E              ; B  = Lenght
 618  558E              ;        LD      HL,(USR)
 619  558E              ;        LD      B,(HL)
 620  558E              ;        INC     HL
 621  558E              ;        LD      E,(HL)
 622  558E              ;        INC     HL
 623  558E              ;        LD      D,(HL)
 624  558E              ;        EX      DE,HL
 625  558E              ;        RET
 626  558E
 627  558E              ;EVALTXTPARAM:
 628  558E              ;	CALL	CHKCHAR
 629  558E              ;	DEFB	"("             ; Check for (
 630  558E              ;	LD	IX,FRMEVL
 631  558E              ;	CALL	CALBAS		; Evaluate expression
 632  558E              ;       LD      A,(VALTYP)
 633  558E              ;        CP      3               ; Text type?
 634  558E              ;        JP      NZ,TYPE_MISMATCH
 635  558E              ;        PUSH	HL
 636  558E              ;        LD	IX,FRESTR         ; Free the temporary string
 637  558E              ;        CALL	CALBAS
 638  558E              ;        POP	HL
 639  558E              ;	CALL	CHKCHAR
 640  558E              ;	DEFB	")"             ; Check for )
 641  558E              ;        RET
 642  558E
 643  558E
 644  558E              CHKCHAR:
 645  558E CD 98 55     	CALL	GETPREVCHAR	; Get previous basic char
 646  5591 E3           	EX	(SP),HL
 647  5592 BE           	CP	(HL) 	        ; Check if good char
 648  5593 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 649  5595 23           	INC	HL
 650  5596 E3           	EX	(SP),HL
 651  5597 23           	INC	HL		; Get next basic char
 652  5598
 653  5598              GETPREVCHAR:
 654  5598 2B           	DEC	HL
 655  5599 DD 21 66 46  	LD	IX,CHRGTR
 656  559D C3 59 01     	JP      CALBAS
 657  55A0
 658  55A0
 659  55A0              TYPE_MISMATCH:
 660  55A0 1E 0D            LD E, 13 ; Type mismatch
 661  55A2 18 0A            JR THROW_ERROR
 662  55A4              SUBSCRIPT_OUT_OF_RANGE:
 663  55A4 1E 09            LD E,9 ; subscript out of range
 664  55A6 18 06        	JR THROW_ERROR
 665  55A8              OVERFLOW:
 666  55A8 1E 06        	LD E,6
 667  55AA 18 02        	JR THROW_ERROR
 668  55AC              SYNTAX_ERROR:
 669  55AC 1E 02            LD E, 2 ; Syntax error
 670  55AE              THROW_ERROR:
 671  55AE DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 672  55B2 C3 59 01     	JP	CALBAS
 673  55B5
 674  55B5              ;---------------------------
 675  55B5
 676  55B5               IF (RAM_CMDS == 1)
 677  55B5              ; *******************************************************************************************************
 678  55B5              ; function to handle CALL MEMCPY basic extension
 679  55B5              ; _MEMCPY ( INT source,
 680  55B5              ;			INT destination,
 681  55B5              ;			INT count,
 682  55B5              ; will put ram in page 0 also, page 1 is already there
 683  55B5              MEMCPY:
 684  55B5              	; opening (
 685  55B5 CD 8E 55     	CALL CHKCHAR
 686  55B8 28           	DB '('
 687  55B9              	; get source address
 688  55B9 DD 21 2F 54  	LD IX, FRMQNT
 689  55BD CD 59 01     	CALL CALBAS
 690  55C0 D5           	PUSH DE
 691  55C1              	; comma
 692  55C1 CD 8E 55     	CALL CHKCHAR
 693  55C4 2C           	DB ','
 694  55C5              	; get destination address
 695  55C5 DD 21 2F 54  	LD IX, FRMQNT
 696  55C9 CD 59 01     	CALL CALBAS
 697  55CC D5           	PUSH DE
 698  55CD              	; comma
 699  55CD CD 8E 55     	CALL CHKCHAR
 700  55D0 2C           	DB ','
 701  55D1              	; get length
 702  55D1 DD 21 2F 54  	LD IX, FRMQNT
 703  55D5 CD 59 01     	CALL CALBAS
 704  55D8 D5           	PUSH DE
 705  55D9              	; ending )
 706  55D9 CD 8E 55     	CALL CHKCHAR
 707  55DC 29           	DB ')'
 708  55DD
 709  55DD              	; save position
 710  55DD E5           	PUSH HL
 711  55DE DD E1        	POP IX
 712  55E0
 713  55E0 C1           	POP BC ; count
 714  55E1 D1           	POP DE ; destination
 715  55E2 E1           	POP HL ; source
 716  55E3 D9           	EXX
 717  55E4              	; enable page 0
 718  55E4 FD 21 EB 55  	LD IY, .RET
 719  55E8 C3 41 55     	JP ENABLE_PAGE0
 720  55EB              .RET:
 721  55EB FB           	EI
 722  55EC D9           	EXX
 723  55ED ED B0        	LDIR
 724  55EF D1               POP DE
 725  55F0 C1               POP BC
 726  55F1 CD B8 54         CALL RESTORE_PAGE_INFO
 727  55F4 DD E5        	PUSH IX
 728  55F6 E1           	POP HL
 729  55F7 C9           	RET
 730  55F8              ; *******************************************************************************************************
 731  55F8               ENDIF
 732  55F8
 733  55F8               IF (VRAM_CMDS == 1)
 734  55F8              ; *******************************************************************************************************
 735  55F8              ; function to handle CALL FILVRM basic extension
 736  55F8              ; FILVRM ( INT offset,
 737  55F8              ;		   INT count,
 738  55F8              ;		   BYTE value,
 739  55F8              ;		   BYTE wait_vsync) >0 = true
 740  55F8              ; wait_vsync will issue HALT before copying
 741  55F8              FILVRM:
 742  55F8              	; opening (
 743  55F8 CD 8E 55     	CALL CHKCHAR
 744  55FB 28           	DB '('
 745  55FC              	; get offset address
 746  55FC DD 21 2F 54  	LD IX, FRMQNT
 747  5600 CD 59 01     	CALL CALBAS
 748  5603 D5           	PUSH DE
 749  5604              	; comma
 750  5604 CD 8E 55     	CALL CHKCHAR
 751  5607 2C           	DB ','
 752  5608              	; get count
 753  5608 DD 21 2F 54  	LD IX, FRMQNT
 754  560C CD 59 01     	CALL CALBAS
 755  560F D5           	PUSH DE
 756  5610              	; comma
 757  5610 CD 8E 55     	CALL CHKCHAR
 758  5613 2C           	DB ','
 759  5614              	; get value
 760  5614 DD 21 1C 52  	LD IX, GETBYT
 761  5618 CD 59 01     	CALL CALBAS
 762  561B F5           	PUSH AF
 763  561C              	; comma
 764  561C CD 8E 55     	CALL CHKCHAR
 765  561F 2C           	DB ','
 766  5620              	; get vsync wait
 767  5620 DD 21 1C 52  	LD IX, GETBYT
 768  5624 CD 59 01     	CALL CALBAS
 769  5627 F5           	PUSH AF
 770  5628              	; ending )
 771  5628 CD 8E 55     	CALL CHKCHAR
 772  562B 29           	DB ')'
 773  562C
 774  562C FB               EI
 775  562D              	; save position
 776  562D E5           	PUSH HL
 777  562E DD E1        	POP IX
 778  5630
 779  5630              	; syntax ok
 780  5630              	; wait for vsync if needed
 781  5630 F1           	POP AF
 782  5631 B7           	OR A
 783  5632 28 01        	JR Z, .L1
 784  5634 76           	HALT
 785  5635
 786  5635              .L1:
 787  5635 F1               POP AF ; value
 788  5636 C1               POP BC ; count
 789  5637 E1               POP HL ; offset
 790  5638 CD 56 00         CALL BIOS_FILVRM
 791  563B
 792  563B              .L3:
 793  563B DD E5        	PUSH IX
 794  563D E1           	POP HL
 795  563E C9           	RET
 796  563F              ; *******************************************************************************************************
 797  563F               ENDIF
 798  563F
 799  563F               IF (RAM_CMDS == 1)
 800  563F              ; *******************************************************************************************************
 801  563F              ; function to handle CALL FILRAM basic extension
 802  563F              ; FILRAM ( INT start address,
 803  563F              ;		   INT count,
 804  563F              ;		   BYTE value,
 805  563F              ; will put ram in page 0 also, page 1 is already there
 806  563F              FILRAM:
 807  563F              	; opening (
 808  563F CD 8E 55     	CALL CHKCHAR
 809  5642 28           	DB '('
 810  5643              	; get start address
 811  5643 DD 21 2F 54  	LD IX, FRMQNT
 812  5647 CD 59 01     	CALL CALBAS
 813  564A D5           	PUSH DE
 814  564B              	; comma
 815  564B CD 8E 55     	CALL CHKCHAR
 816  564E 2C           	DB ','
 817  564F              	; get count
 818  564F DD 21 2F 54  	LD IX, FRMQNT
 819  5653 CD 59 01     	CALL CALBAS
 820  5656 D5           	PUSH DE
 821  5657              	; comma
 822  5657 CD 8E 55     	CALL CHKCHAR
 823  565A 2C           	DB ','
 824  565B              	; get value
 825  565B DD 21 1C 52  	LD IX, GETBYT
 826  565F CD 59 01     	CALL CALBAS
 827  5662 F5           	PUSH AF
 828  5663              	; ending )
 829  5663 CD 8E 55     	CALL CHKCHAR
 830  5666 29           	DB ')'
 831  5667
 832  5667              	; save position
 833  5667 E5           	PUSH HL
 834  5668 DD E1        	POP IX
 835  566A
 836  566A D1           	POP DE ; actually AF
 837  566B C1           	POP BC ; count
 838  566C E1           	POP HL ; start address
 839  566D 78           	LD A, B
 840  566E B7           	OR A
 841  566F 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 842  5671 B1           	OR C
 843  5672 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 844  5674 79           	LD A, C
 845  5675 3D           	DEC A
 846  5676 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 847  5678              	; one byte to fill
 848  5678 72           	LD (HL), D
 849  5679 18 12        	JR .EXIT
 850  567B              .L1:
 851  567B D9           	EXX
 852  567C              	; enable page 0
 853  567C FD 21 83 56  	LD IY, .RET
 854  5680 C3 41 55     	JP ENABLE_PAGE0
 855  5683              .RET:
 856  5683 FB           	EI
 857  5684 D9           	EXX
 858  5685 CD 91 56     	CALL .FILLVALUE
 859  5688 D1               POP DE
 860  5689 C1               POP BC
 861  568A CD B8 54         CALL RESTORE_PAGE_INFO
 862  568D              .EXIT:
 863  568D DD E5        	PUSH IX
 864  568F E1           	POP HL
 865  5690 C9           	RET
 866  5691
 867  5691              .FILLVALUE:
 868  5691 72               LD (HL), D
 869  5692 54               LD D, H
 870  5693 5D               LD E, L
 871  5694 13               INC DE
 872  5695 0B               DEC BC
 873  5696 ED B0            LDIR
 874  5698 C9               RET
 875  5699              ; *******************************************************************************************************
 876  5699               ENDIF
 877  5699
 878  5699               IF (GENCAL_CMD == 1)
 879  5699              ; *******************************************************************************************************
 880  5699              ; function to handle CALL GENCAL basic extension
 881  5699              ; GENCAL ( INT fn_addr, = address of the function to call
 882  5699              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 883  5699              ; output values of reristers will also be stored at reg_list_ptr
 884  5699              GENCAL_VAR_SP:
 885  5699 00 00            DW 0
 886  569B              GENCAL_VAR_SP2:
 887  569B 00 00            DW 0
 888  569D              GENCAL:
 889  569D              	; opening (
 890  569D CD 8E 55     	CALL CHKCHAR
 891  56A0 28           	DB '('
 892  56A1              	; get function address
 893  56A1 DD 21 2F 54  	LD IX, FRMQNT
 894  56A5 CD 59 01     	CALL CALBAS
 895  56A8 D5           	PUSH DE
 896  56A9              	; comma
 897  56A9 CD 8E 55     	CALL CHKCHAR
 898  56AC 2C           	DB ','
 899  56AD              	; get pointer to register list
 900  56AD DD 21 2F 54  	LD IX, FRMQNT
 901  56B1 CD 59 01     	CALL CALBAS
 902  56B4 D5           	PUSH DE
 903  56B5              	; ending )
 904  56B5 CD 8E 55     	CALL CHKCHAR
 905  56B8 29           	DB ')'
 906  56B9
 907  56B9              	; save BASIC token position
 908  56B9 E5           	PUSH HL
 909  56BA D9               EXX
 910  56BB E1           	POP HL ; HL'=next basic token
 911  56BC D9               EXX
 912  56BD
 913  56BD E1               POP HL ; get pointer to register values
 914  56BE F3           	DI
 915  56BF ED 73 99 56      LD (GENCAL_VAR_SP), SP
 916  56C3 F9               LD SP, HL
 917  56C4 F1               POP AF
 918  56C5 C1               POP BC
 919  56C6 D1               POP DE
 920  56C7 E1               POP HL
 921  56C8 DD E1            POP IX
 922  56CA FD E1            POP IY
 923  56CC D9               EXX
 924  56CD ED 73 9B 56      LD (GENCAL_VAR_SP2), SP
 925  56D1 ED 7B 99 56      LD SP, (GENCAL_VAR_SP)
 926  56D5 FB               EI
 927  56D6 D1               POP DE ; get function to call
 928  56D7 E5               PUSH HL
 929  56D8 CD F3 56         CALL .EXXDECALL
 930  56DB F3               DI
 931  56DC ED 73 99 56      LD (GENCAL_VAR_SP), SP
 932  56E0 ED 7B 9B 56      LD SP, (GENCAL_VAR_SP2)
 933  56E4 FD E5            PUSH IY
 934  56E6 DD E5            PUSH IX
 935  56E8 E5               PUSH HL
 936  56E9 D5               PUSH DE
 937  56EA C5               PUSH BC
 938  56EB F5               PUSH AF
 939  56EC ED 7B 99 56      LD SP, (GENCAL_VAR_SP)
 940  56F0 FB               EI
 941  56F1 E1               POP HL
 942  56F2 C9           	RET
 943  56F3
 944  56F3              .EXXDECALL:
 945  56F3 D5               PUSH DE
 946  56F4 D9               EXX
 947  56F5 C9               RET
 948  56F6              ; *******************************************************************************************************
 949  56F6               ENDIF
 950  56F6
 951  56F6               IF (VRAM_CMDS == 1)
 952  56F6              ; *******************************************************************************************************
 953  56F6              ; function to handle CALL MEMVRM basic extension
 954  56F6              ; copies from RAM to VRAM
 955  56F6              ; _MEMVRM ( INT source,
 956  56F6              ;			INT destination,
 957  56F6              ;			INT count,
 958  56F6              ;			BYTE wait_vsync) >0 = true
 959  56F6              ; will put ram in page 0 also, page 1 is already there
 960  56F6              ; wait_vsync will issue HALT before copying
 961  56F6              MEMVRM:
 962  56F6              	; opening (
 963  56F6 CD 8E 55     	CALL CHKCHAR
 964  56F9 28           	DB '('
 965  56FA              	; get source address
 966  56FA DD 21 2F 54  	LD IX, FRMQNT
 967  56FE CD 59 01     	CALL CALBAS
 968  5701 D5           	PUSH DE
 969  5702              	; comma
 970  5702 CD 8E 55     	CALL CHKCHAR
 971  5705 2C           	DB ','
 972  5706              	; get destination address
 973  5706 DD 21 2F 54  	LD IX, FRMQNT
 974  570A CD 59 01     	CALL CALBAS
 975  570D D5           	PUSH DE
 976  570E              	; comma
 977  570E CD 8E 55     	CALL CHKCHAR
 978  5711 2C           	DB ','
 979  5712              	; get length
 980  5712 DD 21 2F 54  	LD IX, FRMQNT
 981  5716 CD 59 01     	CALL CALBAS
 982  5719 D5           	PUSH DE
 983  571A              	; comma
 984  571A CD 8E 55     	CALL CHKCHAR
 985  571D 2C           	DB ','
 986  571E              	; get vsync wait
 987  571E DD 21 1C 52  	LD IX, GETBYT
 988  5722 CD 59 01     	CALL CALBAS
 989  5725 F5           	PUSH AF
 990  5726              	; ending )
 991  5726 CD 8E 55     	CALL CHKCHAR
 992  5729 29           	DB ')'
 993  572A
 994  572A                  ; save position in BASIC text
 995  572A E5           	PUSH HL
 996  572B DD E1        	POP IX
 997  572D
 998  572D F1           	POP AF ; wait vsync
 999  572E B7           	OR A
1000  572F 28 03        	JR Z, .L1
1001  5731 FB               EI
1002  5732 76           	HALT
1003  5733 F3           	DI
1004  5734              .L1:
1005  5734              	; pop LDIR parameters and store away for later
1006  5734 C1           	POP BC ; count
1007  5735 D1           	POP DE ; vram destination
1008  5736 E1           	POP HL ; ram source
1009  5737 D9           	EXX
1010  5738 FD 21 3F 57   	LD IY, .RET
1011  573C C3 41 55     	JP ENABLE_PAGE0
1012  573F              .RET:
1013  573F FB           	EI
1014  5740 D9           	EXX
1015  5741 CD 4D 57     	CALL .LDIRVM
1016  5744 D1               POP DE
1017  5745 C1               POP BC
1018  5746 CD B8 54         CALL RESTORE_PAGE_INFO
1019  5749 DD E5        	PUSH IX
1020  574B E1           	POP HL
1021  574C C9           	RET
1022  574D
1023  574D              .LDIRVM:
1024  574D EB           	EX DE, HL
1025  574E F3           	DI
1026  574F CD 6A 54     	CALL SETWRT_LOCAL
1027  5752 FB           	EI
1028  5753 EB           	EX DE, HL
1029  5754 78           	LD A, B
1030  5755 B7           	OR A
1031  5756 28 0D        	JR Z, .L3
1032  5758 C5           	PUSH BC
1033  5759 0E 98        	LD C, #98
1034  575B              .L2:
1035  575B 50           	LD D, B
1036  575C 06 00        	LD B, 0
1037  575E CD 75 54     	CALL BBYTECOPY
1038  5761 42           	LD B, D
1039  5762 10 F7        	DJNZ .L2
1040  5764 C1           	POP BC
1041  5765              .L3:
1042  5765 79           	LD A, C
1043  5766 B7           	OR A
1044  5767 C8           	RET Z
1045  5768 41           	LD B, C
1046  5769 0E 98        	LD C, #98
1047  576B C3 75 54     	JP BBYTECOPY
1048  576E              ; *******************************************************************************************************
1049  576E               ENDIF
1050  576E
1051  576E               IF (VRAM_CMDS == 1)
1052  576E              ; *******************************************************************************************************
1053  576E              ; function to handle CALL VRMMEM basic extension
1054  576E              ; copies from RAM to VRAM
1055  576E              ; _VRMMEM ( INT source,
1056  576E              ;			INT destination,
1057  576E              ;			INT count
1058  576E              ; will put ram in page 0 also, page 1 is already there
1059  576E              VRMMEM:
1060  576E              	; opening (
1061  576E CD 8E 55     	CALL CHKCHAR
1062  5771 28           	DB '('
1063  5772              	; get source address
1064  5772 DD 21 2F 54  	LD IX, FRMQNT
1065  5776 CD 59 01     	CALL CALBAS
1066  5779 D5           	PUSH DE
1067  577A              	; comma
1068  577A CD 8E 55     	CALL CHKCHAR
1069  577D 2C           	DB ','
1070  577E              	; get destination address
1071  577E DD 21 2F 54  	LD IX, FRMQNT
1072  5782 CD 59 01     	CALL CALBAS
1073  5785 D5           	PUSH DE
1074  5786              	; comma
1075  5786 CD 8E 55     	CALL CHKCHAR
1076  5789 2C           	DB ','
1077  578A              	; get length
1078  578A DD 21 2F 54  	LD IX, FRMQNT
1079  578E CD 59 01     	CALL CALBAS
1080  5791 D5           	PUSH DE
1081  5792              	; ending )
1082  5792 CD 8E 55     	CALL CHKCHAR
1083  5795 29           	DB ')'
1084  5796
1085  5796                  ; save position in BASIC text
1086  5796 E5           	PUSH HL
1087  5797 DD E1        	POP IX
1088  5799
1089  5799 C1           	POP BC ; count
1090  579A D1           	POP DE ; destination
1091  579B E1           	POP HL ; source
1092  579C D9           	EXX
1093  579D FD 21 A4 57  	LD IY, .RET
1094  57A1 C3 41 55     	JP ENABLE_PAGE0
1095  57A4              .RET:
1096  57A4 FB           	EI
1097  57A5 D9           	EXX
1098  57A6 CD B2 57     	CALL .LDIRMV
1099  57A9 D1               POP DE
1100  57AA C1               POP BC
1101  57AB CD B8 54         CALL RESTORE_PAGE_INFO
1102  57AE DD E5        	PUSH IX
1103  57B0 E1           	POP HL
1104  57B1 C9           	RET
1105  57B2
1106  57B2              .LDIRMV:
1107  57B2              	; set VRAM address *exactly* as in ROM, otherwise corruption
1108  57B2 7D           	LD	A, L
1109  57B3 F3           	DI
1110  57B4 D3 99        	OUT	(099H), A
1111  57B6 7C           	LD	A, H
1112  57B7 E6 3F        	AND	03FH
1113  57B9 D3 99        	OUT	(099H), A
1114  57BB FB           	EI
1115  57BC              	;EX (SP), HL
1116  57BC              	;EX (SP), HL
1117  57BC              	;NOP
1118  57BC              	;NOP
1119  57BC              .L4:
1120  57BC DB 98            IN A, (#98)
1121  57BE 12           	LD (DE), A
1122  57BF 13               INC DE
1123  57C0 0B               DEC BC
1124  57C1 79               LD A, C
1125  57C2 B0               OR B
1126  57C3 20 F7            JR NZ, .L4
1127  57C5 C9               RET
1128  57C6              ; *******************************************************************************************************
1129  57C6               ENDIF
1130  57C6
1131  57C6              ; *******************************************************************************************************
1132  57C6              ; H.TIMI function
1133  57C6              MBGE_HTIMI:
1134  57C6               EXPORT MBGE_HTIMI
1135  57C6 F5           	PUSH AF
1136  57C7
1137  57C7               IF (SPRITE_CMDS == 1)
1138  57C7 CD 01 4D     	CALL SPRATR_UPDATE
1139  57CA               ENDIF
1140  57CA
1141  57CA               IF (SOUND_CMDS == 1)
1142  57CA 3A F7 4C     	LD A, (SOUND_ENABLED)
1143  57CD B7           	OR A
1144  57CE 28 2A        	JR Z, .EXIT
1145  57D0
1146  57D0              	; enable page 2
1147  57D0 3E 02            LD A, 2
1148  57D2 CD 81 54         CALL GET_PAGE_INFO
1149  57D5 C5               PUSH BC
1150  57D6 D5               PUSH DE
1151  57D7 3A 43 F3         LD A, (RAMAD2)
1152  57DA 26 80            LD H, 080H
1153  57DC CD C8 54         CALL LOCAL_ENASLT
1154  57DF              	; enable page 0
1155  57DF AF               XOR A
1156  57E0 CD 81 54         CALL GET_PAGE_INFO
1157  57E3 C5               PUSH BC
1158  57E4 D5               PUSH DE
1159  57E5 3A 41 F3         LD A, (RAMAD0)
1160  57E8 26 00            LD H, 0
1161  57EA CD C8 54         CALL LOCAL_ENASLT
1162  57ED
1163  57ED CD 33 42     	CALL PLY_AKG_PLAY
1164  57F0
1165  57F0              	; restore page 0
1166  57F0 D1               POP DE
1167  57F1 C1               POP BC
1168  57F2 CD B8 54         CALL RESTORE_PAGE_INFO
1169  57F5              	; restore page 2
1170  57F5 D1               POP DE
1171  57F6 C1               POP BC
1172  57F7 CD B8 54         CALL RESTORE_PAGE_INFO
1173  57FA               ENDIF
1174  57FA
1175  57FA              .EXIT:
1176  57FA F1           	POP AF
1177  57FB C3 F0 4C     	JP ORIG.HTIMI
1178  57FE              ; *******************************************************************************************************
1179  57FE
1180  57FE              ; *******************************************************************************************************
1181  57FE              ; interrupt handler when page 0 enabled
1182  57FE              VBLANK:
1183  57FE              	EXPORT VBLANK
1184  57FE
1185  57FE F5               PUSH AF
1186  57FF              	; is VDP originator ?
1187  57FF DB 99        	IN	A, (099H)
1188  5801 A7           	AND	A
1189  5802 F2 28 58     	JP P, .EXIT
1190  5805
1191  5805               IF (SOUND_CMDS == 1)
1192  5805 3A F7 4C     	LD A, (SOUND_ENABLED)
1193  5808 B7           	OR A
1194  5809 28 1D        	JR Z, .EXIT
1195  580B
1196  580B C5               PUSH BC
1197  580C D5               PUSH DE
1198  580D E5               PUSH HL
1199  580E 08               EX AF, AF'
1200  580F D9               EXX
1201  5810 F5               PUSH AF
1202  5811 C5               PUSH BC
1203  5812 D5               PUSH DE
1204  5813 E5               PUSH HL
1205  5814 DD E5            PUSH IX
1206  5816 FD E5            PUSH IY
1207  5818
1208  5818 CD 33 42     	CALL PLY_AKG_PLAY
1209  581B
1210  581B FD E1            POP IY
1211  581D DD E1            POP IX
1212  581F E1               POP HL
1213  5820 D1               POP DE
1214  5821 C1               POP BC
1215  5822 F1               POP AF
1216  5823 08               EX AF, AF'
1217  5824 D9               EXX
1218  5825 E1               POP HL
1219  5826 D1               POP DE
1220  5827 C1               POP BC
1221  5828               ENDIF
1222  5828
1223  5828              .EXIT:
1224  5828 F1           	POP AF
1225  5829 FB           	EI
1226  582A ED 4D        	RETI
1227  582C              ; *******************************************************************************************************
1228  582C
1229  582C               IF (SOUND_CMDS == 1)
1230  582C              ; *******************************************************************************************************
1231  582C              ; function to handle CALL SNDPLYINIT basic extension
1232  582C              ; initializes sound player
1233  582C              ; _SNDPLYINIT ( INT music_offset,
1234  582C              ;				INT sfx_offset, can be -1 if no SFX
1235  582C              ; will put ram in page 0 also, page 1 is already there
1236  582C              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1237  582C              SNDPLYINIT:
1238  582C              	; opening (
1239  582C CD 8E 55     	CALL CHKCHAR
1240  582F 28           	DB '('
1241  5830              	; get music address
1242  5830 DD 21 2F 54  	LD IX, FRMQNT
1243  5834 CD 59 01     	CALL CALBAS
1244  5837 D5           	PUSH DE
1245  5838              	; comma
1246  5838 CD 8E 55     	CALL CHKCHAR
1247  583B 2C           	DB ','
1248  583C              	; get sfx address
1249  583C DD 21 2F 54  	LD IX, FRMQNT
1250  5840 CD 59 01     	CALL CALBAS
1251  5843 D5           	PUSH DE
1252  5844              	; ending )
1253  5844 CD 8E 55     	CALL CHKCHAR
1254  5847 29           	DB ')'
1255  5848
1256  5848                  ; save position in BASIC text
1257  5848 44           	LD B, H
1258  5849 4D           	LD C, L
1259  584A
1260  584A              	; pop LDIR parameters and store away for later
1261  584A D1           	POP DE ; sfx address
1262  584B E1           	POP HL ; music address
1263  584C C5           	PUSH BC ; basic text location
1264  584D D9           	EXX
1265  584E FD 21 55 58  	LD IY, .RET
1266  5852 C3 41 55     	JP ENABLE_PAGE0
1267  5855              .RET:
1268  5855 D9           	EXX
1269  5856
1270  5856 D5           	PUSH DE
1271  5857 AF           	XOR A
1272  5858              	; HL = music location
1273  5858 CD 62 41     	CALL PLY_AKG_INIT
1274  585B 3E 01        	LD A, 1
1275  585D 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1276  5860
1277  5860 E1           	POP HL ; SFX
1278  5861              	; check if SFX address -1
1279  5861 23           	INC HL
1280  5862 7D           	LD A, L
1281  5863 B4           	OR H
1282  5864 28 09        	JR Z,.L1
1283  5866 2B           	DEC HL
1284  5867 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1285  586A 3E 01        	LD A, 1
1286  586C 32 F6 4C     	LD (SFX_INIT_STATUS), A
1287  586F              .L1:
1288  586F D1               POP DE
1289  5870 C1               POP BC
1290  5871 CD B8 54         CALL RESTORE_PAGE_INFO
1291  5874
1292  5874 E1           	POP HL
1293  5875 C9           	RET
1294  5876              ; *******************************************************************************************************
1295  5876
1296  5876              ; *******************************************************************************************************
1297  5876              ; function to handle CALL SNDPLYON basic extension
1298  5876              ; enables sound player
1299  5876              ; _SNDPLYON
1300  5876              ; sets SOUND_ENABLED variable to 1 if init call was done
1301  5876              ; if not throws out of data error
1302  5876              SNDPLYON:
1303  5876 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1304  5879 B7           	OR A
1305  587A 20 05        	JR NZ, .L1
1306  587C              	; player not initialized, throw error
1307  587C 1E 04        	LD E, 04 ; Out of DATA
1308  587E C3 AE 55     	JP THROW_ERROR
1309  5881              .L1:
1310  5881 32 F7 4C     	LD (SOUND_ENABLED), A
1311  5884              	; disable key click
1312  5884 AF           	XOR A
1313  5885 32 DB F3     	LD (CLIKSW), A
1314  5888 C9           	RET
1315  5889              ; *******************************************************************************************************
1316  5889
1317  5889              ; *******************************************************************************************************
1318  5889              ; function to handle CALL SNDPLYOFF basic extension
1319  5889              ; disables sound player
1320  5889              ; _SNDPLYOFF
1321  5889              ; sets SOUND_ENABLED variable to 0
1322  5889              ; calls AKG to stop music and SFX on all channels if initialized
1323  5889              SNDPLYOFF:
1324  5889 3A F7 4C     	LD A, (SOUND_ENABLED)
1325  588C B7           	OR A
1326  588D C8           	RET Z ; already stopped
1327  588E AF           	XOR A
1328  588F 32 F7 4C     	LD (SOUND_ENABLED), A
1329  5892 E5           	PUSH HL
1330  5893 CD 21 42     	CALL PLY_AKG_STOP
1331  5896 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1332  5899 B7           	OR A
1333  589A 28 0E        	JR Z, .EXIT ; SFX not in use
1334  589C AF           	XOR A
1335  589D CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1336  58A0 3E 01        	LD A, 1
1337  58A2 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1338  58A5 3E 02        	LD A, 2
1339  58A7 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1340  58AA              .EXIT:
1341  58AA E1           	POP HL
1342  58AB C9           	RET
1343  58AC              ; *******************************************************************************************************
1344  58AC
1345  58AC              ; *******************************************************************************************************
1346  58AC              ; function to handle CALL SNDSFX basic extension
1347  58AC              ; plays a sound effect
1348  58AC              ; _SNDSFX ( BYTE sfx_number, >0
1349  58AC              ;			BYTE channel, = 0,1 or 2
1350  58AC              ;			BYTE inverted_volume = 0-16, 0 being full volume
1351  58AC              ; will put ram in page 0 also, page 1 is already there
1352  58AC              ; if sound off throws illegal function call
1353  58AC              ; if sfx not initialized, throws out of data
1354  58AC              SNDSFX:
1355  58AC              	; opening (
1356  58AC CD 8E 55     	CALL CHKCHAR
1357  58AF 28           	DB '('
1358  58B0              	; get sfx_number
1359  58B0 DD 21 1C 52  	LD IX, GETBYT
1360  58B4 CD 59 01     	CALL CALBAS
1361  58B7 D5           	PUSH DE
1362  58B8              	; comma
1363  58B8 CD 8E 55     	CALL CHKCHAR
1364  58BB 2C           	DB ','
1365  58BC              	; get sfx address
1366  58BC DD 21 1C 52  	LD IX, GETBYT
1367  58C0 CD 59 01     	CALL CALBAS
1368  58C3 D5           	PUSH DE
1369  58C4              	; comma
1370  58C4 CD 8E 55     	CALL CHKCHAR
1371  58C7 2C           	DB ','
1372  58C8              	; get inverted volume
1373  58C8 DD 21 1C 52  	LD IX, GETBYT
1374  58CC CD 59 01     	CALL CALBAS
1375  58CF D5           	PUSH DE
1376  58D0              	; ending )
1377  58D0 CD 8E 55     	CALL CHKCHAR
1378  58D3 29           	DB ')'
1379  58D4
1380  58D4 3A F7 4C     	LD A, (SOUND_ENABLED)
1381  58D7 B7           	OR A
1382  58D8 20 05        	JR NZ, .L1
1383  58DA              	; sound disabled, throw illegal function call
1384  58DA 1E 05        	LD E, 5
1385  58DC C3 AE 55     	JP THROW_ERROR
1386  58DF              .L1:
1387  58DF 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1388  58E2 B7           	OR A
1389  58E3 20 05        	JR NZ, .L2
1390  58E5              	; sfx data not initialized, throw out of data
1391  58E5 1E 04        	LD E, 4
1392  58E7 C3 AE 55     	JP THROW_ERROR
1393  58EA              .L2:
1394  58EA              	; pop  parameters and store away for later
1395  58EA D1           	POP DE ; inverted volume
1396  58EB 43           	LD B, E
1397  58EC D1           	POP DE ; channel
1398  58ED 4B           	LD C, E
1399  58EE D1           	POP DE
1400  58EF 7B           	LD A, E
1401  58F0 08           	EX AF, AF'
1402  58F1 E5           	PUSH HL ; basic text location
1403  58F2 D9           	EXX
1404  58F3 FD 21 FA 58  	LD IY, .RET
1405  58F7 C3 41 55     	JP ENABLE_PAGE0
1406  58FA              .RET:
1407  58FA D9           	EXX
1408  58FB 08           	EX AF, AF'
1409  58FC CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1410  58FF
1411  58FF D1               POP DE
1412  5900 C1               POP BC
1413  5901 CD B8 54         CALL RESTORE_PAGE_INFO
1414  5904
1415  5904 E1           	POP HL
1416  5905 C9           	RET
1417  5906              ; *******************************************************************************************************
1418  5906               ENDIF
1419  5906
1420  5906               IF (BLIT_CMDS == 1)
1421  5906              ; *******************************************************************************************************
1422  5906              ; function rotates mask and data of several characters and applies to background data
1423  5906              ; this handles x-shift from 0 to 4
1424  5906              ; contains self-modifying code that is set-up from external function
1425  5906              ; input HL=pointer to mask data
1426  5906              ; input HL'=pointer to character data
1427  5906              ; input DE=output buffer containing background data
1428  5906              ; input BC=DE+8
1429  5906              ; input A=number of characters to process
1430  5906              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1431  5906              SHIFT04:
1432  5906 08           	EX AF, AF'
1433  5907 7E           	LD A, (HL) ; get mask
1434  5908 D9           	EXX
1435  5909 57           	LD D, A
1436  590A 1E FF        	LD E, #FF
1437  590C 37           	SCF
1438  590D              .M1:
1439  590D 18 FE        	JR .M1 ; this is self-modifying part
1440  590F CB 1A        	RR D
1441  5911 CB 1B        	RR E
1442  5913 CB 1A        	RR D
1443  5915 CB 1B        	RR E
1444  5917 CB 1A        	RR D
1445  5919 CB 1B        	RR E
1446  591B CB 1A        	RR D
1447  591D CB 1B        	RR E
1448  591F
1449  591F 46           	LD B, (HL) ; get data
1450  5920 0E 00        	LD C, 0
1451  5922              .M2:
1452  5922 18 FE        	JR .M2 ; also self-modifying part
1453  5924 CB 38        	SRL B
1454  5926 CB 19        	RR C
1455  5928 CB 38        	SRL B
1456  592A CB 19        	RR C
1457  592C CB 38        	SRL B
1458  592E CB 19        	RR C
1459  5930 CB 38        	SRL B
1460  5932 CB 19        	RR C
1461  5934
1462  5934 D9           	EXX
1463  5935 1A           	LD A, (DE) ; background
1464  5936 D9           	EXX
1465  5937 A2           	AND D
1466  5938 B0           	OR B
1467  5939 D9           	EXX
1468  593A 12           	LD (DE), A
1469  593B
1470  593B 0A           	LD A, (BC)
1471  593C D9           	EXX
1472  593D A3           	AND E
1473  593E B1           	OR C
1474  593F 23           	INC HL
1475  5940 D9           	EXX
1476  5941 02           	LD (BC), A
1477  5942
1478  5942 23           	INC HL
1479  5943 13           	INC DE
1480  5944 03           	INC BC
1481  5945
1482  5945 08           	EX AF, AF'
1483  5946 3D           	DEC A
1484  5947 C2 06 59     	JP NZ, SHIFT04
1485  594A C9           	RET
1486  594B              ; *******************************************************************************************************
1487  594B
1488  594B              ; *******************************************************************************************************
1489  594B              ; function rotates mask and data of several characters and applies to background data
1490  594B              ; this handles x-shift from 5 to 8
1491  594B              ; contains self-modifying code that is set-up from external function
1492  594B              ; input HL=pointer to mask data
1493  594B              ; input HL'=pointer to character data
1494  594B              ; input DE=output buffer containing background data
1495  594B              ; input BC=DE+8
1496  594B              ; input A=number of characters to process
1497  594B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1498  594B              SHIFT58:
1499  594B 08           	EX AF, AF'
1500  594C 7E           	LD A, (HL) ; get mask
1501  594D D9           	EXX
1502  594E 57           	LD D, A
1503  594F 1E FF        	LD E, #FF
1504  5951 37           	SCF
1505  5952              .M1:
1506  5952 18 FE        	JR .M1 ; this is self-modifying part
1507  5954 CB 12        	RL D
1508  5956 CB 13        	RL E
1509  5958 CB 12        	RL D
1510  595A CB 13        	RL E
1511  595C CB 12        	RL D
1512  595E CB 13        	RL E
1513  5960
1514  5960 46           	LD B, (HL)
1515  5961 0E 00        	LD C, 0
1516  5963              .M2:
1517  5963 18 FE        	JR .M2 ; also self-modifying part
1518  5965 CB 20        	SLA B
1519  5967 CB 11        	RL C
1520  5969 CB 20        	SLA B
1521  596B CB 11        	RL C
1522  596D CB 20        	SLA B
1523  596F CB 11        	RL C
1524  5971
1525  5971 D9           	EXX
1526  5972 1A           	LD A, (DE) ; background
1527  5973 D9           	EXX
1528  5974 A3           	AND E
1529  5975 B1           	OR C
1530  5976 D9           	EXX
1531  5977 12           	LD (DE), A
1532  5978
1533  5978 0A           	LD A, (BC)
1534  5979 D9           	EXX
1535  597A A2           	AND D
1536  597B B0           	OR B
1537  597C 23           	INC HL
1538  597D D9           	EXX
1539  597E 02           	LD (BC), A
1540  597F
1541  597F 23           	INC HL
1542  5980 13           	INC DE
1543  5981 03           	INC BC
1544  5982
1545  5982 08           	EX AF, AF'
1546  5983 3D           	DEC A
1547  5984 C2 4B 59     	JP NZ, SHIFT58
1548  5987 C9           	RET
1549  5988              ; *******************************************************************************************************
1550  5988
1551  5988              ; *******************************************************************************************************
1552  5988              ; routine that shifts one row of characters
1553  5988              ; contains self-modifying code that is set-up from external function
1554  5988              ; input HL=pointer to mask data
1555  5988              ; input HL'=pointer to character data
1556  5988              ; input DE=output buffer containing background data
1557  5988              ; input A=number of characters to process
1558  5988              ; input IX=pointer to structure describing input data
1559  5988              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1560  5988              SHIFT_ROW:
1561  5988 F5           	PUSH AF
1562  5989 ED 53 E1 52  		LD (BLIT_TMP1), DE
1563  598D E5           		PUSH HL
1564  598E CD D1 59     			CALL .ADDYSHIFT
1565  5991 E1           		POP HL
1566  5992 ED 53 E3 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1567  5996              .L1:
1568  5996 3E 08        		LD A, 8
1569  5998 DD 96 02     		SUB (IX+2) ; y shift
1570  599B              .CALL1:
1571  599B CD 00 00     		CALL 0
1572  599E DD 7E 02     		LD A, (IX+2); y shift
1573  59A1 B7           		OR A
1574  59A2 28 26        		JR Z, .DONE
1575  59A4 ED 5B E1 52  		LD DE, (BLIT_TMP1)
1576  59A8 E5           		PUSH HL
1577  59A9 CD DF 59     			CALL .DETONEXTROW
1578  59AC E1           		POP HL
1579  59AD              .CALL2:
1580  59AD CD 00 00     		CALL 0
1581  59B0 ED 5B E1 52  		LD DE, (BLIT_TMP1)
1582  59B4 E5           		PUSH HL
1583  59B5 CD D9 59     			CALL .ADD8
1584  59B8 E1           		POP HL
1585  59B9 ED 53 E1 52  		LD (BLIT_TMP1), DE
1586  59BD ED 5B E3 52  		LD DE, (BLIT_TMP2)
1587  59C1 E5           		PUSH HL
1588  59C2 CD D9 59     			CALL .ADD8
1589  59C5 E1           		POP HL
1590  59C6 ED 53 E3 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1591  59CA              .DONE:
1592  59CA F1           	POP AF
1593  59CB 3D           	DEC A
1594  59CC C8           	RET Z
1595  59CD F5           	PUSH AF
1596  59CE C3 96 59     	JP .L1
1597  59D1              .ADDYSHIFT:
1598  59D1 EB           	EX DE, HL
1599  59D2 16 00        	LD D, 0
1600  59D4 DD 5E 02     	LD E, (IX+2); y shift
1601  59D7 18 0C        	JR .MOVDEBC
1602  59D9              .ADD8:
1603  59D9 21 08 00     	LD HL, 8
1604  59DC C3 E5 59     	JP .MOVDEBC
1605  59DF              .DETONEXTROW:
1606  59DF DD 6E 06     	LD L, (IX+6)
1607  59E2 DD 66 07     	LD H, (IX+7) ; bkg add to value
1608  59E5              .MOVDEBC:
1609  59E5 19           	ADD HL, DE
1610  59E6 54           	LD D, H
1611  59E7 5D           	LD E, L
1612  59E8 01 08 00     	LD BC, 8
1613  59EB 09           	ADD HL, BC
1614  59EC 44           	LD B, H
1615  59ED 4D           	LD C, L
1616  59EE C9           	RET
1617  59EF              ; *******************************************************************************************************
1618  59EF
1619  59EF              ; *******************************************************************************************************
1620  59EF              ; function rotates mask and character data and applies it to background
1621  59EF              ; input IX=pointer to structure describing input data
1622  59EF              ; +0  DW horizontal shift count 0-7 (low byte used)
1623  59EF              ; +2  DW vertical shift count 0-7 (low byte used)
1624  59EF              ; +4  DW background data start;
1625  59EF              ; +6  DW background add to value to next row of background data
1626  59EF              ; +8  DW mask data start;
1627  59EF              ; +10  DW character data start;
1628  59EF              ; +12 DW character&mask add to value to next row of data
1629  59EF              ; +14 DW columns (low byte used)
1630  59EF              ; +16 DW rows (low byte used)
1631  59EF              SHIFT_MERGE_CHARACTER:
1632  59EF DD 7E 00     	LD A, (IX) ; shift
1633  59F2 FE 05        	CP 5
1634  59F4 38 25        	JR C, .RIGHT
1635  59F6              	; shifts 5-7, use rotate towards left 1-3
1636  59F6 21 4B 59     	LD HL, SHIFT58
1637  59F9 22 9C 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1638  59FC 22 AE 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1639  59FF D6 05        	SUB 5
1640  5A01 28 0D        	JR Z, .L1
1641  5A03 87           	ADD A, A
1642  5A04 87           	ADD A, A
1643  5A05 67           	LD H, A
1644  5A06 2E 18        	LD L, #18 ; JR opcode
1645  5A08 22 52 59     	LD (SHIFT58.M1), HL
1646  5A0B 22 63 59     	LD (SHIFT58.M2), HL
1647  5A0E 18 32        	JR .DO
1648  5A10              .L1:
1649  5A10 21 00 00     	LD HL, 0 ; 2xNOP opcode
1650  5A13 22 52 59     	LD (SHIFT58.M1), HL
1651  5A16 22 63 59     	LD (SHIFT58.M2), HL
1652  5A19 18 27        	JR .DO
1653  5A1B              .RIGHT:
1654  5A1B              	; shifts 0-4, rotate towards right
1655  5A1B 21 06 59     	LD HL, SHIFT04
1656  5A1E 22 9C 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1657  5A21 22 AE 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1658  5A24 FE 04        	CP 4
1659  5A26 28 11        	JR Z, .R1
1660  5A28 D6 04        	SUB 4
1661  5A2A ED 44        	NEG
1662  5A2C 87           	ADD A, A
1663  5A2D 87           	ADD A, A
1664  5A2E 67           	LD H, A
1665  5A2F 2E 18        	LD L, #18 ; JR opcode
1666  5A31 22 0D 59     	LD (SHIFT04.M1), HL
1667  5A34 22 22 59     	LD (SHIFT04.M2), HL
1668  5A37 18 09        	JR .DO
1669  5A39              .R1:
1670  5A39 21 00 00     	LD HL, 0 ; 2xNOP opcode
1671  5A3C 22 0D 59     	LD (SHIFT04.M1), HL
1672  5A3F 22 22 59     	LD (SHIFT04.M2), HL
1673  5A42              .DO:
1674  5A42 DD 46 10     	LD B, (IX+16) ; rows
1675  5A45 DD 6E 08     	LD L, (IX+8)
1676  5A48 DD 66 09     	LD H, (IX+9) ; mask data
1677  5A4B DD 5E 04     	LD E, (IX+4)
1678  5A4E DD 56 05     	LD D, (IX+5) ; background data
1679  5A51 D9           	EXX
1680  5A52 DD 6E 0A     	LD L, (IX+10)
1681  5A55 DD 66 0B     	LD H, (IX+11) ; character data
1682  5A58 D9           	EXX
1683  5A59              .LOOP:
1684  5A59 C5           	PUSH BC
1685  5A5A E5           		PUSH HL
1686  5A5B D5           			PUSH DE
1687  5A5C D9           				EXX
1688  5A5D E5           				PUSH HL
1689  5A5E D9           					EXX
1690  5A5F DD 7E 0E     					LD A, (IX+14) ; columns
1691  5A62              .CALL:
1692  5A62 CD 88 59     					CALL SHIFT_ROW
1693  5A65 E1           				POP HL
1694  5A66 DD 5E 0C     				LD E, (IX+12)
1695  5A69 DD 56 0D     				LD D, (IX+13) ; char data to next row
1696  5A6C 19           				ADD HL, DE
1697  5A6D D9           				EXX
1698  5A6E E1           			POP HL
1699  5A6F DD 5E 06     			LD E, (IX+6)
1700  5A72 DD 56 07     			LD D, (IX+7) ; background to next row
1701  5A75 19           			ADD HL, DE
1702  5A76 EB           			EX DE, HL
1703  5A77 E1           		POP HL
1704  5A78 DD 4E 0C     		LD C, (IX+12)
1705  5A7B DD 46 0D     		LD B, (IX+13) ; char data to next row
1706  5A7E 09           		ADD HL, BC
1707  5A7F C1           	POP BC
1708  5A80 10 D7        	DJNZ .LOOP
1709  5A82 C9           	RET
1710  5A83              ; *******************************************************************************************************
1711  5A83
1712  5A83               IFNDEF CMDS_WITH_PARAMETERS
1713  5A83 ~            ; *******************************************************************************************************
1714  5A83 ~            ; function to handle CALL BLIT basic extension
1715  5A83 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1716  5A83 ~            ; fuses with background data and applies vertical shift too
1717  5A83 ~            ; BLIT ( INT request_data_ptr )
1718  5A83 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1719  5A83 ~            ; will put ram in page 0 also, page 1 is already there
1720  5A83 ~            BLIT:
1721  5A83 ~            	; opening (
1722  5A83 ~            	CALL CHKCHAR
1723  5A83 ~            	DB '('
1724  5A83 ~            	; get pointer to request struct
1725  5A83 ~            	LD IX, FRMQNT
1726  5A83 ~            	CALL CALBAS
1727  5A83 ~            	PUSH DE
1728  5A83 ~            	; ending )
1729  5A83 ~            	CALL CHKCHAR
1730  5A83 ~            	DB ')'
1731  5A83 ~
1732  5A83 ~            	POP IX ; pointer to request struct
1733  5A83 ~
1734  5A83 ~            	PUSH HL ; save position in BASIC buffer
1735  5A83 ~
1736  5A83 ~            	LD IY, .RET
1737  5A83 ~            	JP ENABLE_PAGE0
1738  5A83 ~            .RET:
1739  5A83 ~            	EI
1740  5A83 ~            	CALL SHIFT_MERGE_CHARACTER
1741  5A83 ~
1742  5A83 ~                POP DE
1743  5A83 ~                POP BC
1744  5A83 ~                CALL RESTORE_PAGE_INFO
1745  5A83 ~
1746  5A83 ~            	POP HL
1747  5A83 ~            	RET
1748  5A83 ~            ; *******************************************************************************************************
1749  5A83               ENDIF
1750  5A83
1751  5A83               IFDEF CMDS_WITH_PARAMETERS
1752  5A83              ; *******************************************************************************************************
1753  5A83              ; function to handle CALL BLIT basic extension
1754  5A83              ; rotates 1-bit character drawing horizontally with mask and character data and
1755  5A83              ; fuses with background data and applies vertical shift too
1756  5A83              ; in form without pointers
1757  5A83              ; BLIT ( INT x,
1758  5A83              ;		 INT y,
1759  5A83              ;		 INT char_data_pointer,
1760  5A83              ;		 INT mask_data_pointer,
1761  5A83              ;		 INT width (in characters),
1762  5A83              ;		 INT height (in characters),
1763  5A83              ;		 INT background_pointer (top left),
1764  5A83              ;		 INT background_width (in characters),
1765  5A83              ;		 INT background_height (in characters))
1766  5A83              ; will put ram in page 0 also, page 1 is already there
1767  5A83              BLIT:
1768  5A83              	; opening (
1769  5A83 CD 8E 55     	CALL CHKCHAR
1770  5A86 28           	DB '('
1771  5A87              	; get x coordinate
1772  5A87 DD 21 2F 54  	LD IX, FRMQNT
1773  5A8B CD 59 01     	CALL CALBAS
1774  5A8E 7B           	LD A, E
1775  5A8F E6 07        	AND 7
1776  5A91 32 E5 52     	LD (BLIT_STRUCT+0), A
1777  5A94 CD 71 5B     	CALL .DAdiv8
1778  5A97 32 E1 52     	LD (BLIT_TMP+0),A
1779  5A9A              	; comma
1780  5A9A CD 8E 55     	CALL CHKCHAR
1781  5A9D 2C           	DB ','
1782  5A9E              	; get y coordinate
1783  5A9E DD 21 2F 54  	LD IX, FRMQNT
1784  5AA2 CD 59 01     	CALL CALBAS
1785  5AA5 7B           	LD A, E
1786  5AA6 E6 07        	AND 7
1787  5AA8 32 E7 52     	LD (BLIT_STRUCT+2), A
1788  5AAB CD 71 5B     	CALL .DAdiv8
1789  5AAE 32 E2 52     	LD (BLIT_TMP+1),A
1790  5AB1              	; comma
1791  5AB1 CD 8E 55     	CALL CHKCHAR
1792  5AB4 2C           	DB ','
1793  5AB5              	; get char data pointer
1794  5AB5 DD 21 2F 54  	LD IX, FRMQNT
1795  5AB9 CD 59 01     	CALL CALBAS
1796  5ABC ED 53 EF 52  	LD (BLIT_STRUCT+10), DE
1797  5AC0              	; comma
1798  5AC0 CD 8E 55     	CALL CHKCHAR
1799  5AC3 2C           	DB ','
1800  5AC4              	; get mask data pointer
1801  5AC4 DD 21 2F 54  	LD IX, FRMQNT
1802  5AC8 CD 59 01     	CALL CALBAS
1803  5ACB ED 53 ED 52  	LD (BLIT_STRUCT+8), DE
1804  5ACF              	; comma
1805  5ACF CD 8E 55     	CALL CHKCHAR
1806  5AD2 2C           	DB ','
1807  5AD3              	; get width
1808  5AD3 DD 21 2F 54  	LD IX, FRMQNT
1809  5AD7 CD 59 01     	CALL CALBAS
1810  5ADA 7B           	LD A, E
1811  5ADB 32 F3 52     	LD (BLIT_STRUCT+14), A
1812  5ADE              	; comma
1813  5ADE CD 8E 55     	CALL CHKCHAR
1814  5AE1 2C           	DB ','
1815  5AE2              	; get height
1816  5AE2 DD 21 2F 54  	LD IX, FRMQNT
1817  5AE6 CD 59 01     	CALL CALBAS
1818  5AE9 7B           	LD A, E
1819  5AEA 32 F5 52     	LD (BLIT_STRUCT+16), A
1820  5AED              	; comma
1821  5AED CD 8E 55     	CALL CHKCHAR
1822  5AF0 2C           	DB ','
1823  5AF1              	; get background pointer
1824  5AF1 DD 21 2F 54  	LD IX, FRMQNT
1825  5AF5 CD 59 01     	CALL CALBAS
1826  5AF8 ED 53 E9 52  	LD (BLIT_STRUCT+4), DE
1827  5AFC              	; comma
1828  5AFC CD 8E 55     	CALL CHKCHAR
1829  5AFF 2C           	DB ','
1830  5B00              	; get background width
1831  5B00 DD 21 2F 54  	LD IX, FRMQNT
1832  5B04 CD 59 01     	CALL CALBAS
1833  5B07 7B           	LD A, E
1834  5B08 32 E3 52     	LD (BLIT_TMP+2), A
1835  5B0B              	; comma
1836  5B0B CD 8E 55     	CALL CHKCHAR
1837  5B0E 2C           	DB ','
1838  5B0F              	; get background height
1839  5B0F DD 21 2F 54  	LD IX, FRMQNT
1840  5B13 CD 59 01     	CALL CALBAS
1841  5B16 7B           	LD A, E
1842  5B17 32 E4 52     	LD (BLIT_TMP+3), A
1843  5B1A              	; ending )
1844  5B1A CD 8E 55     	CALL CHKCHAR
1845  5B1D 29           	DB ')'
1846  5B1E
1847  5B1E E5           	PUSH HL ; save position in BASIC buffer
1848  5B1F
1849  5B1F              	; calculate char&mask add to value
1850  5B1F 26 00        	LD H, 0
1851  5B21 3A F3 52     	LD A, (BLIT_STRUCT+14)
1852  5B24 6F           	LD L, A
1853  5B25 CD 7D 54     	CALL HLx8
1854  5B28 22 F1 52     	LD (BLIT_STRUCT+12), HL
1855  5B2B              	; calculate background add to value
1856  5B2B 26 00        	LD H, 0
1857  5B2D 3A E3 52     	LD A, (BLIT_TMP+2)
1858  5B30 6F           	LD L, A
1859  5B31 CD 7D 54     	CALL HLx8
1860  5B34 22 EB 52     	LD (BLIT_STRUCT+6), HL
1861  5B37              	; calculate pointer to background location
1862  5B37 21 00 00     	LD HL, 0
1863  5B3A 3A E2 52     	LD A,(BLIT_TMP+1)
1864  5B3D B7           	OR A
1865  5B3E 28 08        	JR Z, .L1
1866  5B40 47           	LD B,A
1867  5B41 ED 5B EB 52  	LD DE,(BLIT_STRUCT+6)
1868  5B45              .L0:
1869  5B45 19           	ADD HL, DE
1870  5B46 10 FD        	DJNZ .L0
1871  5B48              .L1:
1872  5B48 EB           	EX DE,HL
1873  5B49 26 00        	LD H,0
1874  5B4B 3A E1 52     	LD A,(BLIT_TMP+0)
1875  5B4E 6F           	LD L,A
1876  5B4F CD 7D 54     	CALL HLx8
1877  5B52 19           	ADD HL,DE
1878  5B53 ED 5B E9 52  	LD DE,(BLIT_STRUCT+4)
1879  5B57 19           	ADD HL,DE
1880  5B58 22 E9 52     	LD (BLIT_STRUCT+4),HL
1881  5B5B
1882  5B5B FD 21 62 5B  	LD IY, .RET
1883  5B5F C3 41 55     	JP ENABLE_PAGE0
1884  5B62              .RET:
1885  5B62 FB           	EI
1886  5B63 DD 21 E5 52  	LD IX, BLIT_STRUCT
1887  5B67 CD EF 59     	CALL SHIFT_MERGE_CHARACTER
1888  5B6A
1889  5B6A D1               POP DE
1890  5B6B C1               POP BC
1891  5B6C CD B8 54         CALL RESTORE_PAGE_INFO
1892  5B6F
1893  5B6F E1           	POP HL
1894  5B70 C9           	RET
1895  5B71              .DAdiv8:
1896  5B71 7B           	LD A,E
1897  5B72 CB 2A        	SRA D
1898  5B74 CB 1F            RR  A
1899  5B76 CB 2A            SRA D
1900  5B78 CB 1F            RR  A
1901  5B7A CB 2A            SRA D
1902  5B7C CB 1F            RR  A
1903  5B7E C9           	RET
1904  5B7F              ; *******************************************************************************************************
1905  5B7F               ENDIF
1906  5B7F               ENDIF
1907  5B7F
1908  5B7F               IF (TILE_CMDS == 1)
1909  5B7F              ; *******************************************************************************************************
1910  5B7F              ; generic function to implement tiling
1911  5B7F              ; should be modified to call appropriate function for memory or vram
1912  5B7F              ; input IX=pointer to following structure
1913  5B7F              ; +00 tile_data_ptr
1914  5B7F              ; +02 tile_rows
1915  5B7F              ; +04 tile_columns
1916  5B7F              ; +06 destination_address
1917  5B7F              ; +08 dest_to_next_row_add_to_value
1918  5B7F              ; +10 num_horizontal_tiles
1919  5B7F              ; +12 num_vertical_tiles
1920  5B7F              ; modifies AF, BC, DE, HL
1921  5B7F              TILE:
1922  5B7F DD 6E 06     	LD L, (IX+6)
1923  5B82 DD 66 07     	LD H, (IX+7) ; destination address
1924  5B85 22 E1 52     	LD (TILETMP1), HL
1925  5B88 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1926  5B8B              .L1:
1927  5B8B C5           	PUSH BC
1928  5B8C DD 6E 00     		LD L, (IX+0)
1929  5B8F DD 66 01     		LD H, (IX+1) ; tile address
1930  5B92 22 E3 52     		LD (TILETMP2), HL
1931  5B95 DD 46 02     		LD B, (IX+2) ; tile rows
1932  5B98              .L2:
1933  5B98 C5           		PUSH BC
1934  5B99              .CALL1:
1935  5B99 CD 00 00     			CALL 0
1936  5B9C DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1937  5B9F              .L3:
1938  5B9F C5           			PUSH BC
1939  5BA0 2A E3 52     				LD HL, (TILETMP2)
1940  5BA3 DD 46 04     				LD B, (IX+4) ; tile columns
1941  5BA6              .L4:
1942  5BA6 C5           				PUSH BC
1943  5BA7              .CALL2:
1944  5BA7 CD 00 00     					CALL 0
1945  5BAA C1           				POP BC
1946  5BAB 10 F9        				DJNZ .L4
1947  5BAD C1           			POP BC
1948  5BAE 10 EF        			DJNZ .L3
1949  5BB0 22 E3 52     			LD (TILETMP2), HL
1950  5BB3 2A E1 52     			LD HL, (TILETMP1)
1951  5BB6 DD 5E 08     			LD E, (IX+8)
1952  5BB9 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1953  5BBC 19           			ADD HL, DE
1954  5BBD 22 E1 52     			LD (TILETMP1), HL
1955  5BC0 C1           		POP BC
1956  5BC1 10 D5        		DJNZ .L2
1957  5BC3 C1           	POP BC
1958  5BC4 10 C5        	DJNZ .L1
1959  5BC6 C9           	RET
1960  5BC7              ; *******************************************************************************************************
1961  5BC7
1962  5BC7               IFNDEF CMDS_WITH_PARAMETERS
1963  5BC7 ~            ; *******************************************************************************************************
1964  5BC7 ~            ; function to handle CALL TILERAM basic extension
1965  5BC7 ~            ; fills memory with tiles
1966  5BC7 ~            ; TILERAM ( INT request_data_ptr )
1967  5BC7 ~            ; request_data_ptr described in TILE
1968  5BC7 ~            ; will put ram in page 0 also, page 1 is already there
1969  5BC7 ~            TILERAM:
1970  5BC7 ~            	; opening (
1971  5BC7 ~            	CALL CHKCHAR
1972  5BC7 ~            	DB '('
1973  5BC7 ~            	; get pointer to request struct
1974  5BC7 ~            	LD IX, FRMQNT
1975  5BC7 ~            	CALL CALBAS
1976  5BC7 ~            	PUSH DE
1977  5BC7 ~            	; ending )
1978  5BC7 ~            	CALL CHKCHAR
1979  5BC7 ~            	DB ')'
1980  5BC7 ~
1981  5BC7 ~            	POP IX ; pointer to request struct
1982  5BC7 ~
1983  5BC7 ~            	PUSH HL ; save position in BASIC buffer
1984  5BC7 ~
1985  5BC7 ~            	LD IY, .RET
1986  5BC7 ~            	JP ENABLE_PAGE0
1987  5BC7 ~            .RET:
1988  5BC7 ~            	EI
1989  5BC7 ~            	; set RAM functions to call
1990  5BC7 ~            	LD HL, .TILECOPY
1991  5BC7 ~            	LD (TILE.CALL2+1), HL
1992  5BC7 ~            	LD HL, .SETDESTROW
1993  5BC7 ~            	LD (TILE.CALL1+1), HL
1994  5BC7 ~            	CALL TILE
1995  5BC7 ~
1996  5BC7 ~                POP DE
1997  5BC7 ~                POP BC
1998  5BC7 ~                CALL RESTORE_PAGE_INFO
1999  5BC7 ~
2000  5BC7 ~            	POP HL
2001  5BC7 ~            	RET
2002  5BC7 ~            .TILECOPY:
2003  5BC7 ~            	.8 LDI
2004  5BC7 ~            	RET
2005  5BC7 ~            .SETDESTROW:
2006  5BC7 ~            	LD DE, (TILETMP1)
2007  5BC7 ~            	RET
2008  5BC7 ~            ; *******************************************************************************************************
2009  5BC7               ENDIF
2010  5BC7
2011  5BC7               IFDEF CMDS_WITH_PARAMETERS
2012  5BC7              ; *******************************************************************************************************
2013  5BC7              ; function to handle CALL TILERAM basic extension
2014  5BC7              ; fills memory with tiles
2015  5BC7              ; TILERAM ( INT tile_data_pointer,
2016  5BC7              ;			INT tile_columns,
2017  5BC7              ;			INT tile_rows,
2018  5BC7              ;			INT destination_pointer,
2019  5BC7              ;			INT destination_columns,
2020  5BC7              ;			INT destination_rows,
2021  5BC7              ;			INT destination_begin_column,
2022  5BC7              ;			INT destination_begin_row,
2023  5BC7              ;			INT number_of_tiles_horizontally,
2024  5BC7              ;			INT	number_of_tiles_vertically )
2025  5BC7              ; will put ram in page 0 also, page 1 is already there
2026  5BC7              TILERAM:
2027  5BC7              	; opening (
2028  5BC7 CD 8E 55     	CALL CHKCHAR
2029  5BCA 28           	DB '('
2030  5BCB              	; get tile data pointer coordinate
2031  5BCB DD 21 2F 54  	LD IX, FRMQNT
2032  5BCF CD 59 01     	CALL CALBAS
2033  5BD2 ED 53 E5 52  	LD (BLIT_STRUCT+0), DE
2034  5BD6              	; comma
2035  5BD6 CD 8E 55     	CALL CHKCHAR
2036  5BD9 2C           	DB ','
2037  5BDA              	; get tile columns
2038  5BDA DD 21 2F 54  	LD IX, FRMQNT
2039  5BDE CD 59 01     	CALL CALBAS
2040  5BE1 ED 53 E9 52  	LD (BLIT_STRUCT+4), DE
2041  5BE5              	; comma
2042  5BE5 CD 8E 55     	CALL CHKCHAR
2043  5BE8 2C           	DB ','
2044  5BE9              	; get tile columns
2045  5BE9 DD 21 2F 54  	LD IX, FRMQNT
2046  5BED CD 59 01     	CALL CALBAS
2047  5BF0 ED 53 E7 52  	LD (BLIT_STRUCT+2), DE
2048  5BF4              	; comma
2049  5BF4 CD 8E 55     	CALL CHKCHAR
2050  5BF7 2C           	DB ','
2051  5BF8              	; get destintion pointer
2052  5BF8 DD 21 2F 54  	LD IX, FRMQNT
2053  5BFC CD 59 01     	CALL CALBAS
2054  5BFF ED 53 EB 52  	LD (BLIT_STRUCT+6), DE
2055  5C03              	; comma
2056  5C03 CD 8E 55     	CALL CHKCHAR
2057  5C06 2C           	DB ','
2058  5C07              	; get destination columns
2059  5C07 DD 21 2F 54  	LD IX, FRMQNT
2060  5C0B CD 59 01     	CALL CALBAS
2061  5C0E 7B           	LD A, E
2062  5C0F 32 E1 52     	LD (BLIT_TMP+0), A
2063  5C12              	; comma
2064  5C12 CD 8E 55     	CALL CHKCHAR
2065  5C15 2C           	DB ','
2066  5C16              	; get destination rows
2067  5C16 DD 21 2F 54  	LD IX, FRMQNT
2068  5C1A CD 59 01     	CALL CALBAS
2069  5C1D 7B           	LD A, E
2070  5C1E 32 E2 52     	LD (BLIT_TMP+1), A
2071  5C21              	; comma
2072  5C21 CD 8E 55     	CALL CHKCHAR
2073  5C24 2C           	DB ','
2074  5C25              	; get destination begin column
2075  5C25 DD 21 2F 54  	LD IX, FRMQNT
2076  5C29 CD 59 01     	CALL CALBAS
2077  5C2C 7B           	LD A, E
2078  5C2D 32 E3 52     	LD (BLIT_TMP+2), A
2079  5C30              	; comma
2080  5C30 CD 8E 55     	CALL CHKCHAR
2081  5C33 2C           	DB ','
2082  5C34              	; get destination begin row
2083  5C34 DD 21 2F 54  	LD IX, FRMQNT
2084  5C38 CD 59 01     	CALL CALBAS
2085  5C3B 7B           	LD A, E
2086  5C3C 32 E4 52     	LD (BLIT_TMP+3), A
2087  5C3F              	; comma
2088  5C3F CD 8E 55     	CALL CHKCHAR
2089  5C42 2C           	DB ','
2090  5C43              	; get number of tiles horizontally
2091  5C43 DD 21 2F 54  	LD IX, FRMQNT
2092  5C47 CD 59 01     	CALL CALBAS
2093  5C4A ED 53 EF 52  	LD (BLIT_STRUCT+10), DE
2094  5C4E              	; comma
2095  5C4E CD 8E 55     	CALL CHKCHAR
2096  5C51 2C           	DB ','
2097  5C52              	; get number of tiles vertically
2098  5C52 DD 21 2F 54  	LD IX, FRMQNT
2099  5C56 CD 59 01     	CALL CALBAS
2100  5C59 ED 53 F1 52  	LD (BLIT_STRUCT+12), DE
2101  5C5D              	; ending )
2102  5C5D CD 8E 55     	CALL CHKCHAR
2103  5C60 29           	DB ')'
2104  5C61
2105  5C61 E5           	PUSH HL ; save position in BASIC buffer
2106  5C62
2107  5C62              	; calculate destination add to value
2108  5C62 26 00        	LD H, 0
2109  5C64 3A E1 52     	LD A, (BLIT_TMP+0)
2110  5C67 6F           	LD L, A
2111  5C68 CD 7D 54     	CALL HLx8
2112  5C6B 22 ED 52     	LD (BLIT_STRUCT+8), HL
2113  5C6E              	; calculate pointer to background location
2114  5C6E 21 00 00     	LD HL, 0
2115  5C71 3A E4 52     	LD A,(BLIT_TMP+3)
2116  5C74 B7           	OR A
2117  5C75 28 08        	JR Z, .L1
2118  5C77 47           	LD B,A
2119  5C78 ED 5B ED 52  	LD DE,(BLIT_STRUCT+8)
2120  5C7C              .L0:
2121  5C7C 19           	ADD HL, DE
2122  5C7D 10 FD        	DJNZ .L0
2123  5C7F              .L1:
2124  5C7F EB           	EX DE,HL
2125  5C80 26 00        	LD H,0
2126  5C82 3A E3 52     	LD A,(BLIT_TMP+2)
2127  5C85 6F           	LD L,A
2128  5C86 CD 7D 54     	CALL HLx8
2129  5C89 19           	ADD HL,DE
2130  5C8A ED 5B EB 52  	LD DE,(BLIT_STRUCT+6)
2131  5C8E 19           	ADD HL,DE
2132  5C8F 22 EB 52     	LD (BLIT_STRUCT+6),HL
2133  5C92
2134  5C92 FD 21 99 5C  	LD IY, .RET
2135  5C96 C3 41 55     	JP ENABLE_PAGE0
2136  5C99              .RET:
2137  5C99 FB           	EI
2138  5C9A              	; set RAM functions to call
2139  5C9A 21 B4 5C     	LD HL, .TILECOPY
2140  5C9D 22 A8 5B     	LD (TILE.CALL2+1), HL
2141  5CA0 21 C5 5C     	LD HL, .SETDESTROW
2142  5CA3 22 9A 5B     	LD (TILE.CALL1+1), HL
2143  5CA6 DD 21 E5 52  	LD IX,BLIT_STRUCT
2144  5CAA CD 7F 5B     	CALL TILE
2145  5CAD
2146  5CAD D1               POP DE
2147  5CAE C1               POP BC
2148  5CAF CD B8 54         CALL RESTORE_PAGE_INFO
2149  5CB2
2150  5CB2 E1           	POP HL
2151  5CB3 C9           	RET
2152  5CB4              .TILECOPY:
2153  5CB4 ED A0       > LDI
2153  5CB6 ED A0       > LDI
2153  5CB8 ED A0       > LDI
2153  5CBA ED A0       > LDI
2153  5CBC ED A0       > LDI
2153  5CBE ED A0       > LDI
2153  5CC0 ED A0       > LDI
2153  5CC2 ED A0       > LDI
2154  5CC4 C9           	RET
2155  5CC5              .SETDESTROW:
2156  5CC5 ED 5B E1 52  	LD DE, (TILETMP1)
2157  5CC9 C9           	RET
2158  5CCA              ; *******************************************************************************************************
2159  5CCA               ENDIF
2160  5CCA
2161  5CCA               IFDEF CMDS_WITH_PARAMETERS
2162  5CCA              ; *******************************************************************************************************
2163  5CCA              ; function to handle CALL TILEVRM basic extension
2164  5CCA              ; fills vram with tiles
2165  5CCA              ; TILEVRM ( INT tile_data_pointer,
2166  5CCA              ;			INT tile_columns,
2167  5CCA              ;			INT tile_rows,
2168  5CCA              ;			INT destination_begin_column,
2169  5CCA              ;			INT destination_begin_row,
2170  5CCA              ;			INT number_of_tiles_horizontally,
2171  5CCA              ;			INT	number_of_tiles_vertically )
2172  5CCA              ; will put ram in page 0 also, page 1 is already there
2173  5CCA              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2174  5CCA              TILEVRM:
2175  5CCA              	; opening (
2176  5CCA CD 8E 55     	CALL CHKCHAR
2177  5CCD 28           	DB '('
2178  5CCE              	; get tile data pointer coordinate
2179  5CCE DD 21 2F 54  	LD IX, FRMQNT
2180  5CD2 CD 59 01     	CALL CALBAS
2181  5CD5 ED 53 E5 52  	LD (BLIT_STRUCT+0), DE
2182  5CD9              	; comma
2183  5CD9 CD 8E 55     	CALL CHKCHAR
2184  5CDC 2C           	DB ','
2185  5CDD              	; get tile columns
2186  5CDD DD 21 2F 54  	LD IX, FRMQNT
2187  5CE1 CD 59 01     	CALL CALBAS
2188  5CE4 ED 53 E9 52  	LD (BLIT_STRUCT+4), DE
2189  5CE8              	; comma
2190  5CE8 CD 8E 55     	CALL CHKCHAR
2191  5CEB 2C           	DB ','
2192  5CEC              	; get tile columns
2193  5CEC DD 21 2F 54  	LD IX, FRMQNT
2194  5CF0 CD 59 01     	CALL CALBAS
2195  5CF3 ED 53 E7 52  	LD (BLIT_STRUCT+2), DE
2196  5CF7              	; comma
2197  5CF7 CD 8E 55     	CALL CHKCHAR
2198  5CFA 2C           	DB ','
2199  5CFB              	; get destination begin column
2200  5CFB DD 21 2F 54  	LD IX, FRMQNT
2201  5CFF CD 59 01     	CALL CALBAS
2202  5D02 7B           	LD A, E
2203  5D03 32 E3 52     	LD (BLIT_TMP+2), A
2204  5D06              	; comma
2205  5D06 CD 8E 55     	CALL CHKCHAR
2206  5D09 2C           	DB ','
2207  5D0A              	; get destination begin row
2208  5D0A DD 21 2F 54  	LD IX, FRMQNT
2209  5D0E CD 59 01     	CALL CALBAS
2210  5D11 7B           	LD A, E
2211  5D12 32 E4 52     	LD (BLIT_TMP+3), A
2212  5D15              	; comma
2213  5D15 CD 8E 55     	CALL CHKCHAR
2214  5D18 2C           	DB ','
2215  5D19              	; get number of tiles horizontally
2216  5D19 DD 21 2F 54  	LD IX, FRMQNT
2217  5D1D CD 59 01     	CALL CALBAS
2218  5D20 ED 53 EF 52  	LD (BLIT_STRUCT+10), DE
2219  5D24              	; comma
2220  5D24 CD 8E 55     	CALL CHKCHAR
2221  5D27 2C           	DB ','
2222  5D28              	; get number of tiles vertically
2223  5D28 DD 21 2F 54  	LD IX, FRMQNT
2224  5D2C CD 59 01     	CALL CALBAS
2225  5D2F ED 53 F1 52  	LD (BLIT_STRUCT+12), DE
2226  5D33              	; ending )
2227  5D33 CD 8E 55     	CALL CHKCHAR
2228  5D36 29           	DB ')'
2229  5D37
2230  5D37 E5           	PUSH HL ; save position in BASIC buffer
2231  5D38
2232  5D38              	; calculate destination add to value
2233  5D38 21 00 01     	LD HL, 256
2234  5D3B 22 ED 52     	LD (BLIT_STRUCT+8), HL
2235  5D3E              	; calculate pointer to background location
2236  5D3E 3A E4 52     	LD A,(BLIT_TMP+3)
2237  5D41 67           	LD H,A
2238  5D42 2E 00        	LD L,0
2239  5D44 EB           	EX DE,HL
2240  5D45 26 00        	LD H,0
2241  5D47 3A E3 52     	LD A,(BLIT_TMP+2)
2242  5D4A 6F           	LD L,A
2243  5D4B CD 7D 54     	CALL HLx8
2244  5D4E 19           	ADD HL,DE
2245  5D4F ED 5B CB F3  	LD DE,(GRPCGP)
2246  5D53 19           	ADD HL,DE
2247  5D54 22 EB 52     	LD (BLIT_STRUCT+6),HL
2248  5D57
2249  5D57 FD 21 5E 5D  	LD IY, .RET
2250  5D5B C3 41 55     	JP ENABLE_PAGE0
2251  5D5E              .RET:
2252  5D5E FB           	EI
2253  5D5F              	; set RAM functions to call
2254  5D5F 21 79 5D     	LD HL, .TILECOPY
2255  5D62 22 A8 5B     	LD (TILE.CALL2+1), HL
2256  5D65 21 7F 5D     	LD HL, .SETDESTROW
2257  5D68 22 9A 5B     	LD (TILE.CALL1+1), HL
2258  5D6B DD 21 E5 52  	LD IX,BLIT_STRUCT
2259  5D6F CD 7F 5B     	CALL TILE
2260  5D72
2261  5D72 D1               POP DE
2262  5D73 C1               POP BC
2263  5D74 CD B8 54         CALL RESTORE_PAGE_INFO
2264  5D77
2265  5D77 E1           	POP HL
2266  5D78 C9           	RET
2267  5D79              .TILECOPY:
2268  5D79 01 98 08     	LD BC, #0898
2269  5D7C C3 75 54     	JP BBYTECOPY
2270  5D7F              .SETDESTROW:
2271  5D7F 2A E1 52     	LD HL, (TILETMP1)
2272  5D82 F3           	DI
2273  5D83 CD 6A 54     	CALL SETWRT_LOCAL
2274  5D86 FB           	EI
2275  5D87 C9           	RET
2276  5D88              ; *******************************************************************************************************
2277  5D88               ENDIF
2278  5D88
2279  5D88               IFNDEF CMDS_WITH_PARAMETERS
2280  5D88 ~            ; *******************************************************************************************************
2281  5D88 ~            ; function to handle CALL TILEVRM basic extension
2282  5D88 ~            ; fills vram with tiles
2283  5D88 ~            ; TILEVRM ( INT request_data_ptr )
2284  5D88 ~            ; request_data_ptr described in TILE
2285  5D88 ~            ; will put ram in page 0 also, page 1 is already there
2286  5D88 ~            TILEVRM:
2287  5D88 ~            	; opening (
2288  5D88 ~            	CALL CHKCHAR
2289  5D88 ~            	DB '('
2290  5D88 ~            	; get pointer to request struct
2291  5D88 ~            	LD IX, FRMQNT
2292  5D88 ~            	CALL CALBAS
2293  5D88 ~            	PUSH DE
2294  5D88 ~            	; ending )
2295  5D88 ~            	CALL CHKCHAR
2296  5D88 ~            	DB ')'
2297  5D88 ~
2298  5D88 ~            	POP IX ; pointer to request struct
2299  5D88 ~
2300  5D88 ~            	PUSH HL ; save position in BASIC buffer
2301  5D88 ~
2302  5D88 ~            	LD IY, .RET
2303  5D88 ~            	JP ENABLE_PAGE0
2304  5D88 ~            .RET:
2305  5D88 ~            	EI
2306  5D88 ~            	; set RAM functions to call
2307  5D88 ~            	LD HL, .TILECOPY
2308  5D88 ~            	LD (TILE.CALL2+1), HL
2309  5D88 ~            	LD HL, .SETDESTROW
2310  5D88 ~            	LD (TILE.CALL1+1), HL
2311  5D88 ~            	CALL TILE
2312  5D88 ~
2313  5D88 ~                POP DE
2314  5D88 ~                POP BC
2315  5D88 ~                CALL RESTORE_PAGE_INFO
2316  5D88 ~
2317  5D88 ~            	POP HL
2318  5D88 ~            	RET
2319  5D88 ~            .TILECOPY:
2320  5D88 ~            	LD BC, #0898
2321  5D88 ~            	JP BBYTECOPY
2322  5D88 ~            .SETDESTROW:
2323  5D88 ~            	LD HL, (TILETMP1)
2324  5D88 ~            	DI
2325  5D88 ~            	CALL SETWRT_LOCAL
2326  5D88 ~            	EI
2327  5D88 ~            	RET
2328  5D88 ~            ; *******************************************************************************************************
2329  5D88               ENDIF
2330  5D88               ENDIF
2331  5D88
2332  5D88               IF (BOX_CMDS == 1)
2333  5D88              ; *******************************************************************************************************
2334  5D88              ; generic function to implement rectangle data copy
2335  5D88              ; should be modified to call appropriate function for memory or vram
2336  5D88              ; input IX=pointer to following structure
2337  5D88              ; +00 source data pointer
2338  5D88              ; +02 num bytes in a row
2339  5D88              ; +04 number of rows
2340  5D88              ; +06 source add-to value till next row
2341  5D88              ; +08 destination address
2342  5D88              ; +10 destination add-to value till next row
2343  5D88              ; modifies AF, BC, DE, HL
2344  5D88              RECTANGLE_COPY:
2345  5D88 DD 6E 00     	LD L, (IX+0)
2346  5D8B DD 66 01     	LD H, (IX+1) ; source address
2347  5D8E DD 5E 08     	LD E, (IX+8)
2348  5D91 DD 56 09     	LD D, (IX+9) ; destination
2349  5D94 DD 46 04     	LD B, (IX+4) ; row number
2350  5D97              .L1:
2351  5D97 C5           	PUSH BC
2352  5D98 E5           		PUSH HL
2353  5D99 D5           			PUSH DE
2354  5D9A DD 4E 02     				LD C, (IX+2)
2355  5D9D DD 46 03     				LD B, (IX+3) ; num bytes in a row
2356  5DA0              .CALL1:
2357  5DA0 CD 00 00     				CALL 0 ; set destination address from DE
2358  5DA3              .CALL2:
2359  5DA3 CD 00 00     				CALL 0 ; copy data fn
2360  5DA6 E1           			POP HL
2361  5DA7 DD 4E 0A     			LD C, (IX+10)
2362  5DAA DD 46 0B     			LD B, (IX+11) ; destination add-to
2363  5DAD 09           			ADD HL, BC
2364  5DAE EB           			EX DE, HL
2365  5DAF E1           		POP HL
2366  5DB0 DD 4E 06     		LD C, (IX+6)
2367  5DB3 DD 46 07     		LD B, (IX+7) ; src add-to
2368  5DB6 09           		ADD HL, BC
2369  5DB7 C1           	POP BC
2370  5DB8 10 DD        	DJNZ .L1
2371  5DBA C9           	RET
2372  5DBB              ; *******************************************************************************************************
2373  5DBB
2374  5DBB              ; *******************************************************************************************************
2375  5DBB              ; function to handle CALL BOXMEMCPY basic extension
2376  5DBB              ; copies data with window like boundaries to ram
2377  5DBB              ; BOXMEMCPY ( INT request_data_ptr )
2378  5DBB              ; request_data_ptr described in RECTANGLE_COPY
2379  5DBB              ; will put ram in page 0 also, page 1 is already there
2380  5DBB              BOXMEMCPY:
2381  5DBB              	; opening (
2382  5DBB CD 8E 55     	CALL CHKCHAR
2383  5DBE 28           	DB '('
2384  5DBF              	; get pointer to request struct
2385  5DBF DD 21 2F 54  	LD IX, FRMQNT
2386  5DC3 CD 59 01     	CALL CALBAS
2387  5DC6 D5           	PUSH DE
2388  5DC7              	; ending )
2389  5DC7 CD 8E 55     	CALL CHKCHAR
2390  5DCA 29           	DB ')'
2391  5DCB
2392  5DCB DD E1        	POP IX ; pointer to request struct
2393  5DCD
2394  5DCD E5           	PUSH HL ; save position in BASIC buffer
2395  5DCE
2396  5DCE FD 21 D5 5D  	LD IY, .RET
2397  5DD2 C3 41 55     	JP ENABLE_PAGE0
2398  5DD5              .RET:
2399  5DD5 FB           	EI
2400  5DD6              	; set RAM functions to call
2401  5DD6 21 00 00     	LD HL, 0
2402  5DD9 22 A0 5D     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2403  5DDC 22 A2 5D     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2404  5DDF 21 ED B0     	LD HL, #B0ED ; LDIR
2405  5DE2 22 A4 5D     	LD (RECTANGLE_COPY.CALL1+4), HL
2406  5DE5 CD 88 5D     	CALL RECTANGLE_COPY
2407  5DE8
2408  5DE8 D1               POP DE
2409  5DE9 C1               POP BC
2410  5DEA CD B8 54         CALL RESTORE_PAGE_INFO
2411  5DED
2412  5DED E1           	POP HL
2413  5DEE C9           	RET
2414  5DEF              ; *******************************************************************************************************
2415  5DEF
2416  5DEF              ; *******************************************************************************************************
2417  5DEF              ; function to handle CALL BOXMEMVRM basic extension
2418  5DEF              ; copies data with window like boundaries to ram
2419  5DEF              ; BOXMEMVRM ( INT request_data_ptr )
2420  5DEF              ; request_data_ptr described in RECTANGLE_COPY
2421  5DEF              ; will put ram in page 0 also, page 1 is already there
2422  5DEF              BOXMEMVRM:
2423  5DEF              	; opening (
2424  5DEF CD 8E 55     	CALL CHKCHAR
2425  5DF2 28           	DB '('
2426  5DF3              	; get pointer to request struct
2427  5DF3 DD 21 2F 54  	LD IX, FRMQNT
2428  5DF7 CD 59 01     	CALL CALBAS
2429  5DFA D5           	PUSH DE
2430  5DFB              	; ending )
2431  5DFB CD 8E 55     	CALL CHKCHAR
2432  5DFE 29           	DB ')'
2433  5DFF
2434  5DFF DD E1        	POP IX ; pointer to request struct
2435  5E01
2436  5E01 E5           	PUSH HL ; save position in BASIC buffer
2437  5E02
2438  5E02 FD 21 09 5E  	LD IY, .RET
2439  5E06 C3 41 55     	JP ENABLE_PAGE0
2440  5E09              .RET:
2441  5E09 FB           	EI
2442  5E0A              	; set RAM functions to call
2443  5E0A 21 28 5E     	LD HL, .SETDEST
2444  5E0D 22 A1 5D     	LD (RECTANGLE_COPY.CALL1+1), HL
2445  5E10 21 30 5E     	LD HL, .COPYDATA
2446  5E13 22 A4 5D     	LD (RECTANGLE_COPY.CALL2+1), HL
2447  5E16 3E CD        	LD A, #CD ; CALL
2448  5E18 32 A0 5D     	LD (RECTANGLE_COPY.CALL1), A
2449  5E1B 32 A3 5D     	LD (RECTANGLE_COPY.CALL2), A
2450  5E1E CD 88 5D     	CALL RECTANGLE_COPY
2451  5E21
2452  5E21 D1               POP DE
2453  5E22 C1               POP BC
2454  5E23 CD B8 54         CALL RESTORE_PAGE_INFO
2455  5E26
2456  5E26 E1           	POP HL
2457  5E27 C9           	RET
2458  5E28              .SETDEST:
2459  5E28 EB           	EX DE, HL
2460  5E29 F3           	DI
2461  5E2A CD 6A 54     	CALL SETWRT_LOCAL
2462  5E2D FB           	EI
2463  5E2E EB           	EX DE, HL
2464  5E2F C9           	RET
2465  5E30              .COPYDATA:
2466  5E30 41           	LD B, C
2467  5E31 0E 98        	LD C, #98
2468  5E33 C3 75 54     	JP BBYTECOPY
2469  5E36              ; *******************************************************************************************************
2470  5E36               ENDIF
2471  5E36
2472  5E36              EXT_END:
2473  5E36
# file closed: asm\main.asm
