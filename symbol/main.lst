# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000
 14   4000               DEFINE CMDS_WITH_PARAMETERS
 15   4000
 16   4000              CHPUT   EQU     #A2
 17   4000              CALBAS	EQU		#159
 18   4000              ERRHAND EQU     #406F
 19   4000              FRMEVL  EQU     #4C64
 20   4000              FRESTR	EQU		#67D0
 21   4000              ; FRMQNT = formula quantificator
 22   4000              ; input HL=pointer to current program expression
 23   4000              ; output HL=next address
 24   4000              ; output DE=integer datum
 25   4000              FRMQNT	EQU		#542F
 26   4000              ; GETBYT = get byte parameter
 27   4000              ; input HL=pointer to current program expression
 28   4000              ; output HL=next address
 29   4000              ; output A=E=byte read
 30   4000              GETBYT		EQU		#521C
 31   4000              CHRGTR  	EQU     #4666
 32   4000              PTRGET		EQU 	#5EA4
 33   4000              SUBFLG		EQU		#F6A5
 34   4000              SYNCHR		EQU		#558C
 35   4000              VALTYP  	EQU     #F663
 36   4000              USR     	EQU     #F7F8
 37   4000              PROCNM		EQU		#FD89
 38   4000              BIOS_FILVRM EQU     #0056
 39   4000              CLIKSW		EQU		#F3DB
 40   4000              ATRBAS		EQU		#F928
 41   4000              GRPCGP		EQU		#F3CB
 42   4000
 43   4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 44   4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 45   4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 46   4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 47   4000              EXPTBL	EQU #FCC1
 48   4000              SCRMOD	EQU #FCAF ; current screen mode
 49   4000              REG1SAV EQU #F3E0 ; VDP(1)
 50   4000              JIFFY	EQU #FC9E
 51   4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
 52   4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
 53   4000              PATBAS  EQU #F926 ; current sprite generator table address
 54   4000              CGPBAS  EQU #F924 ; current pattern generator table address
 55   4000
 56   4000              ; BASIC error codes
 57   4000              ;01 NEXT without FOR
 58   4000              ;02 Syntax error
 59   4000              ;03 RETURN without GOSUB
 60   4000              ;04 Out of DATA
 61   4000              ;05 Illegal function call
 62   4000              ;06 Overflow
 63   4000              ;07 Out of memory
 64   4000              ;08 Undefined line number
 65   4000              ;09 Subscript out of range
 66   4000              ;10 Redimensioned array
 67   4000              ;11 Division by zero
 68   4000              ;12 Illegal direct
 69   4000              ;13 Type mismatch
 70   4000              ;14 Out of string space
 71   4000              ;15 String too long
 72   4000              ;16 String formula too complex
 73   4000              ;17 Can't CONTINUE
 74   4000              ;18 Undefined user function
 75   4000              ;19 Device I/O error
 76   4000              ;20 Verify error
 77   4000              ;21 No RESUME
 78   4000              ;22 RESUME without error
 79   4000              ;23 Unprintable error
 80   4000              ;24 Missing operand
 81   4000              ;25 Line buffer overflow
 82   4000              ;50 FIELD overflow
 83   4000              ;51 Internal error
 84   4000              ;52 Bad file number
 85   4000              ;53 File not found
 86   4000              ;54 File already open
 87   4000              ;55 Input past end
 88   4000              ;56 Bad file name
 89   4000              ;57 Direct statement in file
 90   4000              ;58 Sequential I/O only
 91   4000              ;59 File not OPEN
 92   4000
 93   4000
 94   4000               ; simulate cartridge with BASIC extension
 95   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 95   4004 82 60 00 00
 95   4008 00 00 00 00
 95   400C 00 00 00 00
 96   4010
 97   4010              ; this location #4010 stores last location used by basic extension
 98   4010              ; free memory after that point
 99   4010              FREEMEMPTR:
100   4010 1F 61         DW EXT_END
101   4012
102   4012              ; this location #4012 stores extension version in DAA format
103   4012              ; first byte is major version and second minor
104   4012              VERSION:
105   4012 00 70         DB #00, #70
106   4014
107   4014              ; binary included AKG player compiled at #4014
108   4014               IF (SOUND_CMDS == 1)
109   4014              	INCBIN "bin/AKG.bin"
110   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
111   4CF0               ENDIF
112   4CF0
113   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A 0C 56     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD B2 5F         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD F9 5F         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD B2 5F         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD F9 5F         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A 0C 56     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD E9 5F         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD E9 5F         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A 07 5E         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD C2 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
114   4D73
115   4D73               IF (SPRITE_CMDS == 1)
116   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD AE 5F         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D95 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D98 B7           	OR A
 55+  4D99 28 03        	JR Z, .L3
 56+  4D9B 3A 79 4D     	LD A, (FLICKER)
 57+  4D9E              .L3:
 58+  4D9E 5F           	LD E, A
 59+  4D9F 08           	EX AF, AF'
 60+  4DA0 7B           	LD A, E
 61+  4DA1 87           	ADD A, A
 62+  4DA2 87           	ADD A, A
 63+  4DA3 16 00        	LD D, 0
 64+  4DA5 5F           	LD E, A
 65+  4DA6 19           	ADD HL, DE
 66+  4DA7 CD 99 5F     	CALL SETWRT_LOCAL
 67+  4DAA ED 73 7A 4D  	LD (TMPSP), SP
 68+  4DAE ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 69+  4DB2
 70+  4DB2              .LOOP:
 71+  4DB2 E1           	POP HL
 72+  4DB3 24           	INC H
 73+  4DB4 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DB6 25           	DEC H
 75+  4DB7 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DB9 7D           	LD A, L
 77+  4DBA FE C0        	CP 192
 78+  4DBC 30 10        	JR NC, .OUT3
 79+  4DBE 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DBF 57           	LD D, A
 81+  4DC0 C3 E7 4D     	JP .X
 82+  4DC3              .L1:
 83+  4DC3 7D           	LD A, L
 84+  4DC4 C6 10        	ADD 16
 85+  4DC6 FA CE 4D     	JP M, .OUT3 ; below -16
 86+  4DC9 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DCA 55           	LD D, L
 88+  4DCB C3 E7 4D     	JP .X
 89+  4DCE              .OUT3:
 90+  4DCE E1           	POP HL ; skip x value
 91+  4DCF              .OUT2:
 92+  4DCF E1           	POP HL ; skip pattern
 93+  4DD0 E1           	POP HL ; skip color
 94+  4DD1 3E D1        	LD A, #D1
 95+  4DD3 ED 79        	OUT (C), A ; sprite hidden
 96+  4DD5 00          > NOP
 96+  4DD6 00          > NOP
 96+  4DD7 00          > NOP
 97+  4DD8 ED 79        	OUT (C), A ; value unimportant
 98+  4DDA 00          > NOP
 98+  4DDB 00          > NOP
 98+  4DDC 00          > NOP
 99+  4DDD ED 79        	OUT (C), A ; value unimportant
100+  4DDF 00          > NOP
100+  4DE0 00          > NOP
100+  4DE1 00          > NOP
101+  4DE2 ED 79        	OUT (C), A ; value unimportant
102+  4DE4 C3 12 4E     	JP .NEXT
103+  4DE7              .X:
104+  4DE7 E1           	POP HL
105+  4DE8 24           	INC H
106+  4DE9 28 08        	JR Z, .L2
107+  4DEB 25           	DEC H
108+  4DEC 20 E1        	JR NZ, .OUT2
109+  4DEE 1E 00        	LD E, 0 ; EC bit
110+  4DF0 C3 FC 4D     	JP .XY
111+  4DF3              .L2:
112+  4DF3 7D           	LD A, L
113+  4DF4 C6 20        	ADD 32
114+  4DF6 FA CF 4D     	JP M, .OUT2
115+  4DF9 6F           	LD L, A
116+  4DFA 1E 80        	LD E, #80
117+  4DFC              .XY:
118+  4DFC ED 51        	OUT (C), D
119+  4DFE 3A E0 F3     	LD A, (REG1SAV)
120+  4E01 E6 02        	AND 2
121+  4E03 ED 69        	OUT (C), L
122+  4E05 E1           	POP HL ; pattern
123+  4E06 7D           	LD A, L
124+  4E07 28 02        	JR Z, .SMALLSPRITES
125+  4E09 87           	ADD A, A
126+  4E0A 87           	ADD A, A ; needs to go at 4x
127+  4E0B              .SMALLSPRITES:
128+  4E0B D3 98        	OUT (#98), A
129+  4E0D E1           	POP HL ; color
130+  4E0E 7D           	LD A, L
131+  4E0F B3           	OR E
132+  4E10 D3 98        	OUT (#98), A
133+  4E12              .NEXT:
134+  4E12 08           	EX AF, AF'
135+  4E13 3C           	INC A
136+  4E14 E6 1F        	AND 31
137+  4E16 C2 2A 4E     	JP NZ, .NEXT2
138+  4E19 08           	EX AF, AF'
139+  4E1A 2A 28 F9     	LD HL, (ATRBAS)
140+  4E1D              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E1D 7D           	LD	A, L
142+  4E1E D3 99        	OUT	(099H), A
143+  4E20 7C           	LD	A, H
144+  4E21 E6 3F        	AND	03FH
145+  4E23 F6 40        	OR	040H
146+  4E25 D3 99        	OUT	(099H), A
147+  4E27 C3 2B 4E     	JP .NEXT3
148+  4E2A              .NEXT2:
149+  4E2A 08           	EX AF, AF'
150+  4E2B              .NEXT3:
151+  4E2B 10 85        	DJNZ .LOOP
152+  4E2D 08           	EX AF, AF'
153+  4E2E 3C           	INC A
154+  4E2F 32 79 4D     	LD (FLICKER), A
155+  4E32
156+  4E32 ED 7B 7A 4D  	LD SP, (TMPSP)
157+  4E36 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E39 36 00        	LD (HL), 0 ; zero out update flag
159+  4E3B C9           	RET
160+  4E3C              ; *******************************************************************************************************
161+  4E3C
162+  4E3C              ; *******************************************************************************************************
163+  4E3C              ; function to handle CALL SPRENABLE basic extension
164+  4E3C              ; initializes sprites handler
165+  4E3C              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E3C              ;			   INT update_variable,
167+  4E3C              ;			   BYTE sprite_flicker_enabled )
168+  4E3C              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E3C              SPRENABLE:
170+  4E3C              	; opening (
171+  4E3C CD BF 60     	CALL CHKCHAR
172+  4E3F 28           	DB '('
173+  4E40              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E40 3E 02        	LD A,2
175+  4E42 06 02        	LD B,2
176+  4E44 11 20 04     	LD DE,#0420
177+  4E47 CD EA 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E4A C5           	PUSH BC
179+  4E4B              	; comma
180+  4E4B CD BF 60     	CALL CHKCHAR
181+  4E4E 2C           	DB ','
182+  4E4F              	; get address of sprite update flag
183+  4E4F DD 21 A4 5E  	LD IX, PTRGET
184+  4E53 CD 59 01     	CALL CALBAS
185+  4E56 D5           	PUSH DE
186+  4E57              	; comma
187+  4E57 CD BF 60     	CALL CHKCHAR
188+  4E5A 2C           	DB ','
189+  4E5B              	; get flicker enabled flag
190+  4E5B DD 21 1C 52  	LD IX, GETBYT
191+  4E5F CD 59 01     	CALL CALBAS
192+  4E62 F5           	PUSH AF
193+  4E63              	; ending )
194+  4E63 CD BF 60     	CALL CHKCHAR
195+  4E66 29           	DB ')'
196+  4E67
197+  4E67 F1           	POP AF ; get flicker flag
198+  4E68 B7           	OR A
199+  4E69 32 78 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E6C
201+  4E6C D1           	POP DE ; update variable location
202+  4E6D ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E71 D1           	POP DE ; address of sprite attribute table
204+  4E72 ED 53 76 4D  	LD (SPRATR_DATA), DE
205+  4E76 3E 01        	LD A, 1
206+  4E78 32 73 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E7B C9           	RET
208+  4E7C              ; *******************************************************************************************************
209+  4E7C
210+  4E7C              ; *******************************************************************************************************
211+  4E7C              ; function to handle CALL SPRDISABLE basic extension
212+  4E7C              ; disables sprites handling
213+  4E7C              ; _SPRDISABLE
214+  4E7C              ; resets variable SPRATR_INIT_STATUS
215+  4E7C              SPRDISABLE:
216+  4E7C AF           	XOR A
217+  4E7D 32 73 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E80 C9           	RET
219+  4E81              ; *******************************************************************************************************
220+  4E81
221+  4E81              ; *******************************************************************************************************
222+  4E81              ; function to handle CALL SPRSET basic extension
223+  4E81              ; sets position, and optionally pattern and color of sprite
224+  4E81              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E81              ;			INT x,
226+  4E81              ;			INT y,
227+  4E81              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E81              ;			INT color, valid 0-15, otherwise ignored
229+  4E81              SPRSET:
230+  4E81 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E84 B7           	OR A
232+  4E85 20 05        	JR NZ, .L1
233+  4E87 1E 05        	LD E, 5 ; illegal function call
234+  4E89 C3 E3 60     	JP THROW_ERROR
235+  4E8C              .L1:
236+  4E8C              	; opening (
237+  4E8C CD BF 60     	CALL CHKCHAR
238+  4E8F 28           	DB '('
239+  4E90              	; get sprite number
240+  4E90 DD 21 1C 52  	LD IX, GETBYT
241+  4E94 CD 59 01     	CALL CALBAS
242+  4E97 F5           	PUSH AF
243+  4E98              	; comma
244+  4E98 CD BF 60     	CALL CHKCHAR
245+  4E9B 2C           	DB ','
246+  4E9C              	; get x
247+  4E9C DD 21 2F 54  	LD IX, FRMQNT
248+  4EA0 CD 59 01     	CALL CALBAS
249+  4EA3 D5           	PUSH DE
250+  4EA4              	; comma
251+  4EA4 CD BF 60     	CALL CHKCHAR
252+  4EA7 2C           	DB ','
253+  4EA8              	; get y
254+  4EA8 DD 21 2F 54  	LD IX, FRMQNT
255+  4EAC CD 59 01     	CALL CALBAS
256+  4EAF D5           	PUSH DE
257+  4EB0              	; comma
258+  4EB0 CD BF 60     	CALL CHKCHAR
259+  4EB3 2C           	DB ','
260+  4EB4              	; get pattern
261+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
262+  4EB8 CD 59 01     	CALL CALBAS
263+  4EBB D5           	PUSH DE
264+  4EBC              	; comma
265+  4EBC CD BF 60     	CALL CHKCHAR
266+  4EBF 2C           	DB ','
267+  4EC0              	; get color
268+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
269+  4EC4 CD 59 01     	CALL CALBAS
270+  4EC7 D5           	PUSH DE
271+  4EC8              	; ending )
272+  4EC8 CD BF 60     	CALL CHKCHAR
273+  4ECB 29           	DB ')'
274+  4ECC
275+  4ECC                  ; save position in BASIC text
276+  4ECC E5           	PUSH HL
277+  4ECD DD E1        	POP IX
278+  4ECF
279+  4ECF C1           	POP BC ; color
280+  4ED0 D1           	POP DE ; pattern
281+  4ED1 D9           	EXX
282+  4ED2 C1           	POP BC ; y
283+  4ED3 D1           	POP DE ; x
284+  4ED4 F1           	POP AF ; sprite number
285+  4ED5 FE 20        	CP 32
286+  4ED7 38 05        	JR C, .L2
287+  4ED9 1E 05        	LD E, 5 ; illegal function call
288+  4EDB C3 E3 60     	JP THROW_ERROR
289+  4EDE              .L2:
290+  4EDE              	; find location in sprite attributes table
291+  4EDE D5           	PUSH DE
292+  4EDF CD 7C 4D     	CALL GETnthSPRATTR
293+  4EE2 D1           	POP DE
294+  4EE3              	; set y
295+  4EE3 71           	LD (HL), C
296+  4EE4 23           	INC HL
297+  4EE5 70           	LD (HL), B
298+  4EE6 23           	INC HL
299+  4EE7              	; set x
300+  4EE7 73           	LD (HL), E
301+  4EE8 23           	INC HL
302+  4EE9 72           	LD (HL), D
303+  4EEA 23           	INC HL
304+  4EEB E5           	PUSH HL
305+  4EEC D9           	EXX
306+  4EED E1           	POP HL
307+  4EEE              	; check if 0<=pattern<64
308+  4EEE 7A           	LD A, D
309+  4EEF B7           	OR A
310+  4EF0 20 0B        	JR NZ, .L3
311+  4EF2 7B           	LD A, E
312+  4EF3 FE 40        	CP 64
313+  4EF5 30 06        	JR NC, .L3
314+  4EF7              	; set pattern
315+  4EF7              	;ADD A, A
316+  4EF7              	;ADD A, A
317+  4EF7              	;ADD A, A
318+  4EF7 77           	LD (HL), A
319+  4EF8 23           	INC HL
320+  4EF9 72           	LD (HL), D
321+  4EFA 23           	INC HL
322+  4EFB 18 02        	JR .L4
323+  4EFD              .L3:
324+  4EFD              	; skip pattern
325+  4EFD 23          > INC HL
325+  4EFE 23          > INC HL
326+  4EFF              .L4:
327+  4EFF              	; check if 0<=color<16
328+  4EFF 78           	LD A, B
329+  4F00 B7           	OR A
330+  4F01 20 08        	JR NZ, .L5
331+  4F03 79           	LD A, C
332+  4F04 FE 10        	CP 16
333+  4F06 30 03        	JR NC, .L5
334+  4F08              	; set color
335+  4F08 71           	LD (HL), C
336+  4F09 23           	INC HL
337+  4F0A 70           	LD (HL), B
338+  4F0B
339+  4F0B              .L5:
340+  4F0B DD E5        	PUSH IX
341+  4F0D E1           	POP HL
342+  4F0E C9           	RET
343+  4F0F              ; *******************************************************************************************************
344+  4F0F
345+  4F0F              ; *******************************************************************************************************
346+  4F0F              ; function sets sprite location based on initial coordinates and offset provided
347+  4F0F              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F0F              ; input DE=initial x
349+  4F0F              ; input BC=initial y
350+  4F0F              ; input IY=location where delta y,x are located
351+  4F0F              ; modifies AF, HL, IX
352+  4F0F              SPRSET_DELTA_POS:
353+  4F0F D5           	PUSH DE
354+  4F10 CD 7C 4D     	CALL GETnthSPRATTR
355+  4F13 E5           	PUSH HL
356+  4F14 DD E1        	POP IX
357+  4F16 D1           	POP DE
358+  4F17              	; IX=sprite's y location
359+  4F17 FD 6E 00     	LD L, (IY)
360+  4F1A FD 66 01     	LD H, (IY+1)
361+  4F1D 09           	ADD HL, BC
362+  4F1E DD 75 00     	LD (IX), L
363+  4F21 DD 74 01     	LD (IX+1), H
364+  4F24 FD 6E 02     	LD L, (IY+2)
365+  4F27 FD 66 03     	LD H, (IY+3)
366+  4F2A 19           	ADD HL, DE
367+  4F2B DD 75 02     	LD (IX+2), L
368+  4F2E DD 74 03     	LD (IX+3), H
369+  4F31 C9           	RET
370+  4F32              ; *******************************************************************************************************
371+  4F32
372+  4F32              ; *******************************************************************************************************
373+  4F32              ; function to handle CALL SPRGRPMOV basic extension
374+  4F32              ; sets position of a group of sprites described with
375+  4F32              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F32              ; _SPRGRPMOV ( INT x,
377+  4F32              ;			   INT y,
378+  4F32              ;			   BYTE count,
379+  4F32              ;			   INT[2][count] data_ptr
380+  4F32              ; will put ram in page 0 also, page 1 is already there
381+  4F32              SPRGRPMOV:
382+  4F32 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F35 B7           	OR A
384+  4F36 CA DD 60     	JP Z,ILLEGAL_FUNCTION
385+  4F39              	; opening (
386+  4F39 CD BF 60     	CALL CHKCHAR
387+  4F3C 28           	DB '('
388+  4F3D              	; get x
389+  4F3D DD 21 2F 54  	LD IX, FRMQNT
390+  4F41 CD 59 01     	CALL CALBAS
391+  4F44 D5           	PUSH DE
392+  4F45              	; comma
393+  4F45 CD BF 60     	CALL CHKCHAR
394+  4F48 2C           	DB ','
395+  4F49              	; get y
396+  4F49 DD 21 2F 54  	LD IX, FRMQNT
397+  4F4D CD 59 01     	CALL CALBAS
398+  4F50 D5           	PUSH DE
399+  4F51              	; comma
400+  4F51 CD BF 60     	CALL CHKCHAR
401+  4F54 2C           	DB ','
402+  4F55              	; get count
403+  4F55 DD 21 1C 52  	LD IX, GETBYT
404+  4F59 CD 59 01     	CALL CALBAS
405+  4F5C F5           	PUSH AF
406+  4F5D              	; comma
407+  4F5D CD BF 60     	CALL CHKCHAR
408+  4F60 2C           	DB ','
409+  4F61              	; get sprite group definition array data pointer
410+  4F61 D1           	POP DE
411+  4F62 D5           	PUSH DE
412+  4F63 5A           	LD E,D
413+  4F64 16 03        	LD D,3
414+  4F66 3E 02        	LD A,2
415+  4F68 47           	LD B,A
416+  4F69 CD EA 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
417+  4F6C C5           	PUSH BC
418+  4F6D              	; ending )
419+  4F6D CD BF 60     	CALL CHKCHAR
420+  4F70 29           	DB ')'
421+  4F71
422+  4F71 E5           	PUSH HL
423+  4F72 DD E1        	POP IX
424+  4F74
425+  4F74 E1           	POP HL ; data pointer
426+  4F75 C1           	POP BC ; count
427+  4F76 D9           	EXX
428+  4F77 C1           	POP BC ; y
429+  4F78 D1           	POP DE ; x
430+  4F79 D9           	EXX
431+  4F7A
432+  4F7A DD E5        	PUSH IX ; save position in BASIC buffer
433+  4F7C
434+  4F7C C5           	PUSH BC
435+  4F7D E5           	PUSH HL
436+  4F7E AF               XOR A
437+  4F7F CD B2 5F         CALL GET_PAGE_INFO
438+  4F82 D9           	EXX
439+  4F83 E1           	POP HL
440+  4F84 F1           	POP AF
441+  4F85 D9           	EXX
442+  4F86 C5               PUSH BC
443+  4F87 D5               PUSH DE
444+  4F88 D9           	EXX
445+  4F89 F5           	PUSH AF
446+  4F8A E5           	PUSH HL
447+  4F8B D9           	EXX
448+  4F8C 3A 41 F3         LD A, (RAMAD0)
449+  4F8F 26 00            LD H, 0
450+  4F91 CD F9 5F         CALL LOCAL_ENASLT
451+  4F94 FB           	EI
452+  4F95 E1           	POP HL
453+  4F96 C1           	POP BC
454+  4F97 3E 01        	LD A,1
455+  4F99 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
456+  4F9C CD AA 4F     	CALL .UPDATE_LOC
457+  4F9F AF           	XOR A
458+  4FA0 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
459+  4FA3 D1               POP DE
460+  4FA4 C1               POP BC
461+  4FA5 CD E9 5F         CALL RESTORE_PAGE_INFO
462+  4FA8 E1           	POP HL
463+  4FA9 C9           	RET
464+  4FAA
465+  4FAA              .UPDATE_LOC:
466+  4FAA 7E           	LD A, (HL)
467+  4FAB 23           	INC HL
468+  4FAC 23           	INC HL
469+  4FAD E5           	PUSH HL
470+  4FAE FD E1        	POP IY
471+  4FB0 D9           	EXX
472+  4FB1 CD 0F 4F     	CALL SPRSET_DELTA_POS
473+  4FB4 D9           	EXX
474+  4FB5 23          > INC HL
474+  4FB6 23          > INC HL
474+  4FB7 23          > INC HL
474+  4FB8 23          > INC HL
475+  4FB9 10 EF        	DJNZ .UPDATE_LOC
476+  4FBB C9           	RET
477+  4FBC              ; *******************************************************************************************************
478+  4FBC
# file closed: asm\SPRITES.asm
117   4FBC               ENDIF
118   4FBC
119   4FBC               IF (ANIM_CMDS == 1)
120   4FBC               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FBC              ; sprite animation routines
  2+  4FBC
  3+  4FBC              ; number of animation items and pointer
  4+  4FBC              ANIMITEMNUM:
  5+  4FBC 00            DB 0
  6+  4FBD              ANIMITEMPTR:
  7+  4FBD 1F 61         DW EXT_END
  8+  4FBF              ; number of animation definitions and pointer
  9+  4FBF              ANIMDEFNUM:
 10+  4FBF 00            DB 0
 11+  4FC0              ANIMDEFPTR:
 12+  4FC0 1F 61         DW EXT_END
 13+  4FC2              ; number of links between sprite and animation definitions
 14+  4FC2              ANIMSPRNUM:
 15+  4FC2 00            DB 0
 16+  4FC3              ANIMSPRPTR:
 17+  4FC3 1F 61         DW EXT_END
 18+  4FC5
 19+  4FC5              ; ANIMATION ITEM
 20+  4FC5              ; byte type = [0 - pattern and color change
 21+  4FC5              ;              1 - pattern definition change ]
 22+  4FC5              ; word ticks - number of ticks to hold this state
 23+  4FC5              ; for type = 0
 24+  4FC5              ;   byte pattern;
 25+  4FC5              ;   byte color;
 26+  4FC5              ; for type = 1
 27+  4FC5              ;   work data_pointer;
 28+  4FC5              ; total size = 5b
 29+  4FC5
 30+  4FC5              ; ANIMATION DEFINITION
 31+  4FC5              ; byte number of items 1-15
 32+  4FC5              ; byte[15] anim_item;
 33+  4FC5              ; total size = 16b
 34+  4FC5
 35+  4FC5              ; SPRITE/CHAR ANIMATION
 36+  4FC5              ; +00 byte sprite/char number;
 37+  4FC5              ; +01 word time;
 38+  4FC5              ; +03 byte current item;
 39+  4FC5              ; +04 byte animation definition;
 40+  4FC5              ; +05 byte cyclic;
 41+  4FC5              ; +06 byte active;
 42+  4FC5              ; +07 byte 0=sprite, 1-3 character bank
 43+  4FC5              ; total size = 8b
 44+  4FC5
 45+  4FC5              ; *******************************************************************************************************
 46+  4FC5              ; helper function HL=A*5
 47+  4FC5              ; changes HL,DE;
 48+  4FC5              Ax5:
 49+  4FC5 26 00            LD H,0
 50+  4FC7 6F               LD L,A
 51+  4FC8 54               LD D,H
 52+  4FC9 5D               LD E,L
 53+  4FCA 29               ADD HL,HL
 54+  4FCB 29               ADD HL,HL
 55+  4FCC 19               ADD HL,DE
 56+  4FCD C9               RET
 57+  4FCE              ; *******************************************************************************************************
 58+  4FCE
 59+  4FCE              ; *******************************************************************************************************
 60+  4FCE              ; helper function gets pointer to n-th animation item
 61+  4FCE              ; changes HL,DE;
 62+  4FCE              GETnthANIMITEM:
 63+  4FCE CD C5 4F         CALL Ax5
 64+  4FD1 ED 5B BD 4F      LD DE,(ANIMITEMPTR)
 65+  4FD5 19               ADD HL,DE
 66+  4FD6 C9               RET
 67+  4FD7              ; *******************************************************************************************************
 68+  4FD7
 69+  4FD7              ; *******************************************************************************************************
 70+  4FD7              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD7              ; changes HL,DE;
 72+  4FD7              GETnthANIMDEF:
 73+  4FD7 26 00            LD H,0
 74+  4FD9 6F               LD L,A
 75+  4FDA CD AD 5F         CALL HLx16
 76+  4FDD ED 5B C0 4F      LD DE,(ANIMDEFPTR)
 77+  4FE1 19               ADD HL,DE
 78+  4FE2 C9               RET
 79+  4FE3              ; *******************************************************************************************************
 80+  4FE3
 81+  4FE3              ; *******************************************************************************************************
 82+  4FE3              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FE3              ; changes HL,DE;
 84+  4FE3              GETnthSPRANIM:
 85+  4FE3 26 00            LD H,0
 86+  4FE5 6F               LD L,A
 87+  4FE6 CD AE 5F         CALL HLx8
 88+  4FE9 ED 5B C3 4F      LD DE,(ANIMSPRPTR)
 89+  4FED 19               ADD HL,DE
 90+  4FEE C9               RET
 91+  4FEF              ; *******************************************************************************************************
 92+  4FEF
 93+  4FEF              ; *******************************************************************************************************
 94+  4FEF              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FEF              ; MAXANIMITEMS (BYTE number)
 96+  4FEF              ; sets new number and moves memory buffers as needed
 97+  4FEF              MAXANIMITEMS:
 98+  4FEF              	; opening (
 99+  4FEF CD BF 60     	CALL CHKCHAR
100+  4FF2 28           	DB '('
101+  4FF3              	; get value
102+  4FF3 DD 21 1C 52  	LD IX, GETBYT
103+  4FF7 CD 59 01     	CALL CALBAS
104+  4FFA F5               PUSH AF
105+  4FFB              	; ending )
106+  4FFB CD BF 60     	CALL CHKCHAR
107+  4FFE 29           	DB ')'
108+  4FFF F1               POP AF
109+  5000
110+  5000              	; save position
111+  5000 E5           	PUSH HL
112+  5001              .ENTRY:
113+  5001 47               LD B,A
114+  5002 3A BC 4F         LD A,(ANIMITEMNUM)
115+  5005 90               SUB B
116+  5006 28 1F            JR Z, .EXIT; same value as before
117+  5008 FD 21 C0 4F      LD IY,ANIMDEFPTR
118+  500C FA 2A 50         JP M, .INCREASE
119+  500F                  ; new value is lower than previous one
120+  500F CD 42 50         CALL .SIZEDIFF
121+  5012 CD 5D 50         CALL .DECREASE_COMMON
122+  5015 2A C3 4F         LD HL,(ANIMSPRPTR)
123+  5018 AF               XOR A
124+  5019 ED 42            SBC HL,BC
125+  501B 22 C3 4F         LD (ANIMSPRPTR),HL
126+  501E              .E1:
127+  501E 2A 10 40         LD HL,(FREEMEMPTR)
128+  5021 AF               XOR A
129+  5022 ED 42            SBC HL,BC
130+  5024 22 10 40         LD (FREEMEMPTR),HL
131+  5027              .EXIT:
132+  5027 FB               EI
133+  5028 E1           	POP HL
134+  5029 C9           	RET
135+  502A              .INCREASE:
136+  502A ED 44            NEG
137+  502C CD 42 50         CALL .SIZEDIFF
138+  502F CD 89 50         CALL .INCREASE_COMMON
139+  5032 2A C3 4F         LD HL,(ANIMSPRPTR)
140+  5035 09               ADD HL,BC
141+  5036 22 C3 4F         LD (ANIMSPRPTR),HL
142+  5039              .E2:
143+  5039 2A 10 40         LD HL,(FREEMEMPTR)
144+  503C 09               ADD HL,BC
145+  503D 22 10 40         LD (FREEMEMPTR),HL
146+  5040 18 E5            JR .EXIT
147+  5042              .SIZEDIFF:
148+  5042 CD C5 4F         CALL Ax5
149+  5045 78               LD A,B
150+  5046 32 BC 4F         LD (ANIMITEMNUM),A
151+  5049 44               LD B,H
152+  504A 4D               LD C,L
153+  504B C9               RET ; BC=size difference in bytes
154+  504C              .SIZETOMOVE:
155+  504C D5               PUSH DE
156+  504D 2A 10 40         LD HL,(FREEMEMPTR)
157+  5050 FD 5E 00         LD E,(IY)
158+  5053 FD 56 01         LD D,(IY+1)
159+  5056 AF               XOR A
160+  5057 ED 52            SBC HL,DE
161+  5059 44               LD B,H
162+  505A 4D               LD C,L
163+  505B D1               POP DE
164+  505C C9               RET
165+  505D              .DECREASE_COMMON:
166+  505D FD 6E 00         LD L,(IY)
167+  5060 FD 66 01         LD H,(IY+1)
168+  5063 AF               XOR A
169+  5064 ED 42            SBC HL,BC
170+  5066 EB               EX DE,HL
171+  5067 C5               PUSH BC
172+  5068 CD 4C 50         CALL .SIZETOMOVE
173+  506B F3               DI
174+  506C 78               LD A,B
175+  506D B1               OR C
176+  506E 28 08            JR Z,.L1
177+  5070 FD 6E 00         LD L,(IY)
178+  5073 FD 66 01         LD H,(IY+1)
179+  5076 ED B0            LDIR
180+  5078              .L1:
181+  5078 C1               POP BC
182+  5079 FD 6E 00         LD L,(IY)
183+  507C FD 66 01         LD H,(IY+1)
184+  507F AF               XOR A
185+  5080 ED 42            SBC HL,BC
186+  5082 FD 75 00         LD (IY),L
187+  5085 FD 74 01         LD (IY+1),H
188+  5088 C9               RET
189+  5089              .INCREASE_COMMON:
190+  5089 2A 10 40         LD HL,(FREEMEMPTR)
191+  508C 2B               DEC HL
192+  508D AF               XOR A
193+  508E ED 42            SBC HL,BC
194+  5090 EB               EX DE,HL
195+  5091 C5               PUSH BC
196+  5092 CD 4C 50         CALL .SIZETOMOVE
197+  5095 F3               DI
198+  5096 78               LD A,B
199+  5097 B1               OR C
200+  5098 28 06            JR Z,.L2
201+  509A 2A 10 40         LD HL,(FREEMEMPTR)
202+  509D 2B               DEC HL
203+  509E ED B8            LDDR
204+  50A0              .L2:
205+  50A0 C1               POP BC
206+  50A1 FD 6E 00         LD L,(IY)
207+  50A4 FD 66 01         LD H,(IY+1)
208+  50A7 09               ADD HL,BC
209+  50A8 FD 75 00         LD (IY),L
210+  50AB FD 74 01         LD (IY+1),H
211+  50AE C9               RET
212+  50AF              ; *******************************************************************************************************
213+  50AF
214+  50AF              ; *******************************************************************************************************
215+  50AF              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AF              ; ANIMITEMPAT ( BYTE id,
217+  50AF              ;               INT ticks,
218+  50AF              ;               BYTE pattern,
219+  50AF              ;               BYTE color )
220+  50AF              ; fills animation item data, returns an error if out of bounds
221+  50AF              ANIMITEMPAT:
222+  50AF                  ; opening (
223+  50AF CD BF 60     	CALL CHKCHAR
224+  50B2 28           	DB '('
225+  50B3              	; get id
226+  50B3 DD 21 1C 52  	LD IX, GETBYT
227+  50B7 CD 59 01     	CALL CALBAS
228+  50BA F5               PUSH AF
229+  50BB                  ; check if out of bounds
230+  50BB 3C               INC A
231+  50BC 4F               LD C,A
232+  50BD 3A BC 4F         LD A,(ANIMITEMNUM)
233+  50C0 B9               CP C
234+  50C1 DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50C4              	; comma
236+  50C4 CD BF 60     	CALL CHKCHAR
237+  50C7 2C           	DB ','
238+  50C8              	; get ticks
239+  50C8 DD 21 2F 54  	LD IX, FRMQNT
240+  50CC CD 59 01     	CALL CALBAS
241+  50CF D5           	PUSH DE
242+  50D0              	; comma
243+  50D0 CD BF 60     	CALL CHKCHAR
244+  50D3 2C           	DB ','
245+  50D4              	; get pattern
246+  50D4 DD 21 1C 52  	LD IX, GETBYT
247+  50D8 CD 59 01     	CALL CALBAS
248+  50DB F5               PUSH AF
249+  50DC              	; comma
250+  50DC CD BF 60     	CALL CHKCHAR
251+  50DF 2C           	DB ','
252+  50E0              	; get color
253+  50E0 DD 21 1C 52  	LD IX, GETBYT
254+  50E4 CD 59 01     	CALL CALBAS
255+  50E7 F5               PUSH AF
256+  50E8              	; ending )
257+  50E8 CD BF 60     	CALL CHKCHAR
258+  50EB 29           	DB ')'
259+  50EC              .ENTRY:
260+  50EC E5               PUSH HL
261+  50ED DD E1            POP IX
262+  50EF D9               EXX
263+  50F0 C1               POP BC ; color
264+  50F1 D1               POP DE ; pattern
265+  50F2 E1               POP HL ; ticks
266+  50F3 D9               EXX
267+  50F4 F1               POP AF
268+  50F5 CD CE 4F         CALL GETnthANIMITEM
269+  50F8 E5               PUSH HL
270+  50F9 FD E1            POP IY
271+  50FB D9               EXX
272+  50FC FD 36 00 00      LD (IY),0 ; type=0
273+  5100 FD 75 01         LD (IY+1),L
274+  5103 FD 74 02         LD (IY+2),H
275+  5106 FD 72 03         LD (IY+3),D
276+  5109 FD 70 04         LD (IY+4),B
277+  510C
278+  510C DD E5            PUSH IX
279+  510E E1               POP HL
280+  510F C9               RET
281+  5110              ; *******************************************************************************************************
282+  5110
283+  5110              ; *******************************************************************************************************
284+  5110              ; function to handle CALL ANIMITEMPTR basic extension
285+  5110              ; ANIMITEMPTR ( BYTE id,
286+  5110              ;               INT ticks,
287+  5110              ;               INT pointer,
288+  5110              ; fills animation item data, returns an error if out of bounds
289+  5110              ANIMITEMPTR_CMD:
290+  5110                  ; opening (
291+  5110 CD BF 60     	CALL CHKCHAR
292+  5113 28           	DB '('
293+  5114              	; get id
294+  5114 DD 21 1C 52  	LD IX, GETBYT
295+  5118 CD 59 01     	CALL CALBAS
296+  511B F5               PUSH AF
297+  511C                  ; check if out of bounds
298+  511C 3C               INC A
299+  511D 4F               LD C,A
300+  511E 3A BC 4F         LD A,(ANIMITEMNUM)
301+  5121 B9               CP C
302+  5122 DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5125              	; comma
304+  5125 CD BF 60     	CALL CHKCHAR
305+  5128 2C           	DB ','
306+  5129              	; get ticks
307+  5129 DD 21 2F 54  	LD IX, FRMQNT
308+  512D CD 59 01     	CALL CALBAS
309+  5130 D5           	PUSH DE
310+  5131              	; comma
311+  5131 CD BF 60     	CALL CHKCHAR
312+  5134 2C           	DB ','
313+  5135              	; get pointer
314+  5135 DD 21 2F 54  	LD IX, FRMQNT
315+  5139 CD 59 01     	CALL CALBAS
316+  513C D5           	PUSH DE
317+  513D              	; ending )
318+  513D CD BF 60     	CALL CHKCHAR
319+  5140 29           	DB ')'
320+  5141              .ENTRY:
321+  5141 E5               PUSH HL
322+  5142 DD E1            POP IX
323+  5144 D9               EXX
324+  5145 D1               POP DE ; pointer
325+  5146 E1               POP HL ; ticks
326+  5147 D9               EXX
327+  5148 F1               POP AF
328+  5149 CD CE 4F         CALL GETnthANIMITEM
329+  514C E5               PUSH HL
330+  514D FD E1            POP IY
331+  514F D9               EXX
332+  5150 FD 36 00 01      LD (IY),1 ; type=1
333+  5154 FD 75 01         LD (IY+1),L
334+  5157 FD 74 02         LD (IY+2),H
335+  515A FD 73 03         LD (IY+3),E
336+  515D FD 72 04         LD (IY+4),D
337+  5160
338+  5160 DD E5            PUSH IX
339+  5162 E1               POP HL
340+  5163 C9               RET
341+  5164              ; *******************************************************************************************************
342+  5164
343+  5164              ; *******************************************************************************************************
344+  5164              ; function to handle CALL MAXANIMDEFS basic extension
345+  5164              ; MAXANIMDEFS (BYTE number)
346+  5164              ; sets new number and moves memory buffers as needed
347+  5164              MAXANIMDEFS:
348+  5164              	; opening (
349+  5164 CD BF 60     	CALL CHKCHAR
350+  5167 28           	DB '('
351+  5168              	; get value
352+  5168 DD 21 1C 52  	LD IX, GETBYT
353+  516C CD 59 01     	CALL CALBAS
354+  516F F5               PUSH AF
355+  5170              	; ending )
356+  5170 CD BF 60     	CALL CHKCHAR
357+  5173 29           	DB ')'
358+  5174 F1               POP AF
359+  5175
360+  5175              	; save position
361+  5175 E5           	PUSH HL
362+  5176              .ENTRY:
363+  5176 47               LD B,A
364+  5177 3A BF 4F         LD A,(ANIMDEFNUM)
365+  517A 90               SUB B
366+  517B CA 27 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  517E FD 21 C3 4F      LD IY,ANIMSPRPTR
368+  5182 FA 8E 51         JP M, .INCREASE
369+  5185                  ; new value is lower than previous one
370+  5185 CD 99 51         CALL .SIZEDIFF
371+  5188 CD 5D 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  518B C3 1E 50         JP MAXANIMITEMS.E1
373+  518E              .INCREASE:
374+  518E ED 44            NEG
375+  5190 CD 99 51         CALL .SIZEDIFF
376+  5193 CD 89 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5196 C3 39 50         JP MAXANIMITEMS.E2
378+  5199              .SIZEDIFF:
379+  5199 26 00            LD H,0
380+  519B 6F               LD L,A
381+  519C CD AD 5F         CALL HLx16
382+  519F 78               LD A,B
383+  51A0 32 BF 4F         LD (ANIMDEFNUM),A
384+  51A3 44               LD B,H
385+  51A4 4D               LD C,L
386+  51A5 C9               RET ; BC=size difference in bytes
387+  51A6              ; *******************************************************************************************************
388+  51A6
389+  51A6              ; *******************************************************************************************************
390+  51A6              ; function to handle CALL ANIMDEF basic extension
391+  51A6              ; ANIMITEMPAT ( BYTE id,
392+  51A6              ;               BYTE size,
393+  51A6              ;               INT[] list )
394+  51A6              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A6              ANIMDEF:
396+  51A6                  ; opening (
397+  51A6 CD BF 60     	CALL CHKCHAR
398+  51A9 28           	DB '('
399+  51AA              	; get id
400+  51AA DD 21 1C 52  	LD IX, GETBYT
401+  51AE CD 59 01     	CALL CALBAS
402+  51B1 F5               PUSH AF
403+  51B2                  ; check if out of bounds
404+  51B2 3C               INC A
405+  51B3 4F               LD C,A
406+  51B4 3A BF 4F         LD A,(ANIMDEFNUM)
407+  51B7 B9               CP C
408+  51B8 DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51BB              	; comma
410+  51BB CD BF 60     	CALL CHKCHAR
411+  51BE 2C           	DB ','
412+  51BF              	; get size
413+  51BF DD 21 1C 52  	LD IX, GETBYT
414+  51C3 CD 59 01     	CALL CALBAS
415+  51C6 FE 10            CP 16
416+  51C8 D2 D9 60         JP NC, OVERFLOW
417+  51CB B7               OR A
418+  51CC CA D9 60         JP Z, OVERFLOW
419+  51CF F5           	PUSH AF
420+  51D0              	; comma
421+  51D0 CD BF 60     	CALL CHKCHAR
422+  51D3 2C           	DB ','
423+  51D4              	; get pointer to a list of animation items in integer array format
424+  51D4                  ; get array pointer
425+  51D4 D1               POP DE
426+  51D5 D5               PUSH DE
427+  51D6 3E 02            LD A,2
428+  51D8 06 01            LD B,1
429+  51DA CD EA 60         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51DD C5               PUSH BC
431+  51DE              	; ending )
432+  51DE CD BF 60     	CALL CHKCHAR
433+  51E1 29           	DB ')'
434+  51E2              .ENTRY:
435+  51E2 E5               PUSH HL
436+  51E3 DD E1            POP IX
437+  51E5 D1               POP DE ; pointer to INT array
438+  51E6 C1               POP BC ; B=item number
439+  51E7 F1               POP AF ; id
440+  51E8 D5               PUSH DE
441+  51E9 CD D7 4F         CALL GETnthANIMDEF
442+  51EC D1               POP DE
443+  51ED 70               LD (HL),B
444+  51EE              .L1:
445+  51EE 23               INC HL
446+  51EF 1A               LD A,(DE)
447+  51F0 13          > INC DE
447+  51F1 13          > INC DE
448+  51F2 77               LD (HL),A
449+  51F3 10 F9            DJNZ .L1
450+  51F5 DD E5            PUSH IX
451+  51F7 E1               POP HL
452+  51F8 C9               RET
453+  51F9              ; *******************************************************************************************************
454+  51F9
455+  51F9              ; *******************************************************************************************************
456+  51F9              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F9              ; MAXANIMSPRS (BYTE number)
458+  51F9              ; sets new number and moves memory buffers as needed
459+  51F9              MAXANIMSPRS:
460+  51F9              	; opening (
461+  51F9 CD BF 60     	CALL CHKCHAR
462+  51FC 28           	DB '('
463+  51FD              	; get value
464+  51FD DD 21 1C 52  	LD IX, GETBYT
465+  5201 CD 59 01     	CALL CALBAS
466+  5204 F5               PUSH AF
467+  5205              	; ending )
468+  5205 CD BF 60     	CALL CHKCHAR
469+  5208 29           	DB ')'
470+  5209 F1               POP AF
471+  520A
472+  520A              	; save position
473+  520A E5           	PUSH HL
474+  520B              .ENTRY:
475+  520B 47               LD B,A
476+  520C 3A C2 4F         LD A,(ANIMSPRNUM)
477+  520F 90               SUB B
478+  5210 CA 27 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  5213 FD 21 10 40      LD IY,FREEMEMPTR
480+  5217 FA 23 52         JP M, .INCREASE
481+  521A                  ; new value is lower than previous one
482+  521A CD 42 52         CALL .SIZEDIFF
483+  521D CD 5D 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  5220 C3 27 50         JP MAXANIMITEMS.EXIT
485+  5223              .INCREASE:
486+  5223 ED 44            NEG
487+  5225 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5226 CD 42 52         CALL .SIZEDIFF
489+  5229 CD 89 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  522C AF               XOR A
491+  522D ED 42            SBC HL,BC ; location of new stuff
492+  522F F1               POP AF
493+  5230 47               LD B,A
494+  5231 11 08 00         LD DE,8
495+  5234 E5               PUSH HL
496+  5235 DD E1            POP IX
497+  5237              .L1:
498+  5237 DD 36 06 00      LD (IX+6),0
499+  523B DD 19            ADD IX,DE
500+  523D 10 F8            DJNZ .L1
501+  523F C3 27 50         JP MAXANIMITEMS.EXIT
502+  5242              .SIZEDIFF:
503+  5242 26 00            LD H,0
504+  5244 6F               LD L,A
505+  5245 CD AE 5F         CALL HLx8
506+  5248 78               LD A,B
507+  5249 32 C2 4F         LD (ANIMSPRNUM),A
508+  524C 44               LD B,H
509+  524D 4D               LD C,L
510+  524E C9               RET ; BC=size difference in bytes
511+  524F              ; *******************************************************************************************************
512+  524F
513+  524F              ; *******************************************************************************************************
514+  524F              ; function to handle CALL ANIMSPRITE basic extension
515+  524F              ; ANIMSPRITE ( BYTE id,
516+  524F              ;              BYTE sprite_number,
517+  524F              ;              BYTE animation_definition_id,
518+  524F              ;              BYTE cyclic_flag )
519+  524F              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524F              ANIMSPRITE:
521+  524F                  ; opening (
522+  524F CD BF 60     	CALL CHKCHAR
523+  5252 28           	DB '('
524+  5253              	; get sprite animation id
525+  5253 DD 21 1C 52  	LD IX, GETBYT
526+  5257 CD 59 01     	CALL CALBAS
527+  525A F5               PUSH AF
528+  525B 3C               INC A
529+  525C 4F               LD C,A
530+  525D 3A C2 4F         LD A,(ANIMSPRNUM)
531+  5260 B9               CP C
532+  5261 DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  5264              	; comma
534+  5264 CD BF 60     	CALL CHKCHAR
535+  5267 2C           	DB ','
536+  5268              	; get sprite number
537+  5268 DD 21 1C 52  	LD IX, GETBYT
538+  526C CD 59 01     	CALL CALBAS
539+  526F F5               PUSH AF
540+  5270                  ; check if out of bounds
541+  5270 FE 20            CP 32
542+  5272 D2 D5 60         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5275              	; comma
544+  5275 CD BF 60     	CALL CHKCHAR
545+  5278 2C           	DB ','
546+  5279              	; get animation definition id
547+  5279 DD 21 1C 52  	LD IX, GETBYT
548+  527D CD 59 01     	CALL CALBAS
549+  5280 F5               PUSH AF
550+  5281 3C               INC A
551+  5282 4F               LD C,A
552+  5283 3A BF 4F         LD A,(ANIMDEFNUM)
553+  5286 B9               CP C
554+  5287 DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  528A              	; comma
556+  528A CD BF 60     	CALL CHKCHAR
557+  528D 2C           	DB ','
558+  528E              	; get cyclic flag
559+  528E DD 21 1C 52  	LD IX, GETBYT
560+  5292 CD 59 01         CALL CALBAS
561+  5295 F5           	PUSH AF
562+  5296              	; ending )
563+  5296 CD BF 60     	CALL CHKCHAR
564+  5299 29           	DB ')'
565+  529A              .ENTRY:
566+  529A E5               PUSH HL
567+  529B DD E1            POP IX
568+  529D D9               EXX
569+  529E D1               POP DE ; cyclic
570+  529F C1               POP BC ; animation definition id
571+  52A0 E1               POP HL ; sprite number
572+  52A1 D9               EXX
573+  52A2 F1               POP AF ; sprite animation id
574+  52A3 CD E3 4F         CALL GETnthSPRANIM
575+  52A6 E5               PUSH HL
576+  52A7 FD E1            POP IY
577+  52A9 D9               EXX
578+  52AA FD 74 00         LD (IY),H
579+  52AD FD 70 04         LD (IY+4),B
580+  52B0 FD 72 05         LD (IY+5),D
581+  52B3                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
582+  52B3                  ; following will do preparation for ANIMSTEP situation
583+  52B3                  ; current item set to above limit and timer to 1
584+  52B3                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
585+  52B3 FD 36 03 FF      LD (IY+3),255
586+  52B7 FD 36 01 01      LD (IY+1),1
587+  52BB FD 36 02 00      LD (IY+2),0
588+  52BF                  ; mark as sprite animation
589+  52BF FD 36 07 00      LD (IY+7),0
590+  52C3 DD E5            PUSH IX
591+  52C5 E1               POP HL
592+  52C6 C9               RET
593+  52C7              ; *******************************************************************************************************
594+  52C7
595+  52C7              ; *******************************************************************************************************
596+  52C7              ; function to handle CALL ANIMCHAR basic extension
597+  52C7              ; ANIMCHAR ( BYTE id,
598+  52C7              ;            INT character number 0-767,
599+  52C7              ;            BYTE animation_definition_id,
600+  52C7              ;            BYTE cyclic_flag )
601+  52C7              ; fills sprite animation data, returns an error if out of bounds, or invalid type
602+  52C7              ANIMCHAR:
603+  52C7                  ; opening (
604+  52C7 CD BF 60     	CALL CHKCHAR
605+  52CA 28           	DB '('
606+  52CB              	; get sprite animation id
607+  52CB DD 21 1C 52  	LD IX, GETBYT
608+  52CF CD 59 01     	CALL CALBAS
609+  52D2 F5               PUSH AF
610+  52D3 3C               INC A
611+  52D4 4F               LD C,A
612+  52D5 3A C2 4F         LD A,(ANIMSPRNUM)
613+  52D8 B9               CP C
614+  52D9 DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
615+  52DC              	; comma
616+  52DC CD BF 60     	CALL CHKCHAR
617+  52DF 2C           	DB ','
618+  52E0              	; get character number
619+  52E0 DD 21 2F 54  	LD IX, FRMQNT
620+  52E4 CD 59 01     	CALL CALBAS
621+  52E7 D5               PUSH DE
622+  52E8                  ; check if out of bounds
623+  52E8 7A               LD A,D
624+  52E9 FE 03            CP 3
625+  52EB D2 D5 60         JP NC, SUBSCRIPT_OUT_OF_RANGE
626+  52EE              	; comma
627+  52EE CD BF 60     	CALL CHKCHAR
628+  52F1 2C           	DB ','
629+  52F2              	; get animation definition id
630+  52F2 DD 21 1C 52  	LD IX, GETBYT
631+  52F6 CD 59 01     	CALL CALBAS
632+  52F9 F5               PUSH AF
633+  52FA 3C               INC A
634+  52FB 4F               LD C,A
635+  52FC 3A BF 4F         LD A,(ANIMDEFNUM)
636+  52FF B9               CP C
637+  5300 DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
638+  5303              	; comma
639+  5303 CD BF 60     	CALL CHKCHAR
640+  5306 2C           	DB ','
641+  5307              	; get cyclic flag
642+  5307 DD 21 1C 52  	LD IX, GETBYT
643+  530B CD 59 01         CALL CALBAS
644+  530E F5           	PUSH AF
645+  530F              	; ending )
646+  530F CD BF 60     	CALL CHKCHAR
647+  5312 29           	DB ')'
648+  5313              .ENTRY:
649+  5313 E5               PUSH HL
650+  5314 DD E1            POP IX
651+  5316 D9               EXX
652+  5317 D1               POP DE ; cyclic
653+  5318 C1               POP BC ; animation definition id
654+  5319 E1               POP HL ; character number
655+  531A D9               EXX
656+  531B F1               POP AF ; sprite animation id
657+  531C CD E3 4F         CALL GETnthSPRANIM
658+  531F E5               PUSH HL
659+  5320 FD E1            POP IY
660+  5322 D9               EXX
661+  5323 FD 75 00         LD (IY),L
662+  5326 24               INC H ; save character bank+1
663+  5327 FD 74 07         LD (IY+7),H
664+  532A FD 70 04         LD (IY+4),B
665+  532D FD 72 05         LD (IY+5),D
666+  5330                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
667+  5330                  ; following will do preparation for ANIMSTEP situation
668+  5330                  ; current item set to above limit and timer to 1
669+  5330                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
670+  5330 FD 36 03 FF      LD (IY+3),255
671+  5334 FD 36 01 01      LD (IY+1),1
672+  5338 FD 36 02 00      LD (IY+2),0
673+  533C DD E5            PUSH IX
674+  533E E1               POP HL
675+  533F C9               RET
676+  5340              ; *******************************************************************************************************
677+  5340
678+  5340              ; *******************************************************************************************************
679+  5340              ; function to handle CALL ANIMSTEP basic extension
680+  5340              ; two forms
681+  5340              ; ANIMSTEP ( BYTE id )
682+  5340              ; or
683+  5340              ; ANIMSTEP ( BYTE item_number,
684+  5340              ;            INT[] sprite_animations )
685+  5340              ; sets active flag to 1
686+  5340              ANIMSTEP:
687+  5340 11 BD 53         LD DE,ANIMSTARTSTOP_COMMON.STEP
688+  5343 18 08            JR ANIMSTARTSTOP_COMMON
689+  5345              ; *******************************************************************************************************
690+  5345              ; *******************************************************************************************************
691+  5345              ; function to handle CALL ANIMSTART basic extension
692+  5345              ; two forms
693+  5345              ; ANIMSTART ( BYTE id )
694+  5345              ; or
695+  5345              ; ANIMSTART ( BYTE item_number,
696+  5345              ;             INT[] sprite_animations )
697+  5345              ; sets active flag to 1
698+  5345              ANIMSTART:
699+  5345 11 AB 53         LD DE,ANIMSTARTSTOP_COMMON.START
700+  5348 18 03            JR ANIMSTARTSTOP_COMMON
701+  534A              ; *******************************************************************************************************
702+  534A              ; *******************************************************************************************************
703+  534A              ; function to handle CALL ANIMSTOP basic extension
704+  534A              ; two forms
705+  534A              ; ANIMSTOP ( BYTE id )
706+  534A              ; or
707+  534A              ; ANIMSTOP ( BYTE item_number,
708+  534A              ;            INT[] sprite_animations )
709+  534A              ; sets active flag to 1
710+  534A              ANIMSTOP:
711+  534A 11 B8 53         LD DE,ANIMSTARTSTOP_COMMON.STOP
712+  534D              ; *******************************************************************************************************
713+  534D              ANIMSTARTSTOP_COMMON:
714+  534D ED 53 A9 53      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
715+  5351                  ; opening (
716+  5351 CD BF 60     	CALL CHKCHAR
717+  5354 28           	DB '('
718+  5355              	; get sprite animation id or array size
719+  5355 DD 21 1C 52  	LD IX,GETBYT
720+  5359 CD 59 01     	CALL CALBAS
721+  535C F5               PUSH AF
722+  535D                  ; check if comma present
723+  535D CD C9 60         CALL GETPREVCHAR
724+  5360 23               INC HL
725+  5361 FE 2C            CP ','
726+  5363 28 0C            JR Z,.L1
727+  5365 FE 29            CP ')'
728+  5367 C2 E1 60         JP NZ,SYNTAX_ERROR
729+  536A                  ; ok so single argument variant
730+  536A F1               POP AF
731+  536B E5               PUSH HL
732+  536C CD 97 53         CALL .SETVALUE
733+  536F E1               POP HL
734+  5370 C9               RET
735+  5371              .L1:
736+  5371                  ; get array pointer
737+  5371 D1               POP DE
738+  5372 D5               PUSH DE
739+  5373 3E 02            LD A,2
740+  5375 06 01            LD B,1
741+  5377 CD EA 60         CALL GET_BASIC_ARRAY_DATA_POINTER
742+  537A C5               PUSH BC
743+  537B              	; ending )
744+  537B CD BF 60     	CALL CHKCHAR
745+  537E 29           	DB ')'
746+  537F D1               POP DE ; array pointer
747+  5380 C1               POP BC ; number of items
748+  5381 78               LD A,B
749+  5382 B7               OR A
750+  5383 CA D5 60         JP Z,SUBSCRIPT_OUT_OF_RANGE
751+  5386 E5               PUSH HL
752+  5387 F3               DI
753+  5388              .L2:
754+  5388 C5               PUSH BC
755+  5389 1A               LD A,(DE)
756+  538A 13          > INC DE
756+  538B 13          > INC DE
757+  538C D5               PUSH DE
758+  538D CD 97 53         CALL .SETVALUE
759+  5390 D1               POP DE
760+  5391 C1               POP BC
761+  5392 10 F4            DJNZ .L2
762+  5394 FB               EI
763+  5395 E1               POP HL
764+  5396 C9               RET
765+  5397
766+  5397              .SETVALUE:
767+  5397 47               LD B,A
768+  5398 3C               INC A
769+  5399 4F               LD C,A
770+  539A 3A C2 4F         LD A,(ANIMSPRNUM)
771+  539D B9               CP C
772+  539E DA D5 60         JP C,SUBSCRIPT_OUT_OF_RANGE
773+  53A1 78               LD A,B
774+  53A2 CD E3 4F         CALL GETnthSPRANIM
775+  53A5 E5               PUSH HL
776+  53A6 DD E1            POP IX
777+  53A8              .FN:
778+  53A8 C3 00 00         JP 0
779+  53AB              .START:
780+  53AB DD 36 06 01      LD (IX+6),1 ; active flag
781+  53AF DD 36 03 00      LD (IX+3),0 ; current item
782+  53B3 06 00            LD B,0 ; setup timer
783+  53B5 C3 3C 54         JP SETUP_ANIM_STEP
784+  53B8              .STOP:
785+  53B8 DD 36 06 00      LD (IX+6),0 ; active flag
786+  53BC C9               RET
787+  53BD              .STEP:
788+  53BD 06 00            LD B,0
789+  53BF C3 E0 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
790+  53C2              ; *******************************************************************************************************
791+  53C2
792+  53C2              ; *******************************************************************************************************
793+  53C2              ; function processes animations during vblank period
794+  53C2              PROCESS_ANIMATIONS:
795+  53C2 3A C2 4F         LD A,(ANIMSPRNUM)
796+  53C5 B7               OR A
797+  53C6 C8               RET Z; no animations defined
798+  53C7 47               LD B,A
799+  53C8 DD 2A C3 4F      LD IX,(ANIMSPRPTR)
800+  53CC              .L1:
801+  53CC C5               PUSH BC
802+  53CD 06 00            LD B,0 ; normal mode, change on timer expiry only
803+  53CF CD DB 53         CALL PROCESS_SINGLE_ANIMATION
804+  53D2 11 08 00         LD DE,8
805+  53D5 DD 19            ADD IX,DE
806+  53D7 C1               POP BC
807+  53D8 10 F2            DJNZ .L1
808+  53DA C9               RET
809+  53DB              ; *******************************************************************************************************
810+  53DB
811+  53DB              ; *******************************************************************************************************
812+  53DB              ; processes single sprite animation
813+  53DB              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
814+  53DB              ; on timer expiry goes to next animation item
815+  53DB              ; input IX=sprite animation pointer
816+  53DB              ; input B=1 force mode, activate animation action regardless of expired timer
817+  53DB              PROCESS_SINGLE_ANIMATION:
818+  53DB DD 7E 06         LD A,(IX+6); active
819+  53DE B7               OR A
820+  53DF C8               RET Z ; inactive animation
821+  53E0              .INACTIVE_TOO:
822+  53E0 DD 6E 01         LD L,(IX+1)
823+  53E3 DD 66 02         LD H,(IX+2) ; HL=end time
824+  53E6 2B               DEC HL
825+  53E7 DD 75 01         LD (IX+1),L
826+  53EA DD 74 02         LD (IX+2),H
827+  53ED 7D               LD A,L
828+  53EE B4               OR H
829+  53EF 28 06            JR Z,.STEP
830+  53F1 05               DEC B
831+  53F2 04               INC B
832+  53F3 C8               RET Z ; not forced mode, return
833+  53F4 C3 3C 54         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
834+  53F7              .STEP:
835+  53F7 06 00            LD B,0; setup timer
836+  53F9 DD 34 03         INC (IX+3) ; current animation item
837+  53FC C3 3C 54         JP SETUP_ANIM_STEP
838+  53FF              ; *******************************************************************************************************
839+  53FF
840+  53FF              ; *******************************************************************************************************
841+  53FF              ; function will setup sprite animation after current item change
842+  53FF              ; input A=current animation definition
843+  53FF              ; input IX=pointer to sprite animation
844+  53FF              ; input B=1 skip timer setup
845+  53FF              ; output IY=pointer to animation item
846+  53FF              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
847+  53FF              ; basically sets new end time for current animation
848+  53FF              INIT_CURRENT_ANIMATION:
849+  53FF CD D7 4F         CALL GETnthANIMDEF
850+  5402 DD 7E 03         LD A,(IX+3) ; current animation item
851+  5405 BE               CP (HL) ; number of animation items in the animation definition
852+  5406 38 0A            JR C,.L3 ; last item not reached
853+  5408                  ; last item reached
854+  5408 DD 7E 05         LD A,(IX+5) ; cyclic flag
855+  540B B7               OR A
856+  540C 28 2C            JR Z,.ERROR ; non-cyclic animation
857+  540E                  ; cyclic animation, restart
858+  540E DD 36 03 00      LD (IX+3),0; current item
859+  5412              .L3:
860+  5412                  ; HL = animation definition
861+  5412 23               INC HL ; skip animation definition size field
862+  5413 16 00            LD D,0
863+  5415 DD 5E 03         LD E,(IX+3); current item
864+  5418 19               ADD HL,DE
865+  5419 4E               LD C,(HL) ; current animation item
866+  541A 0C               INC C
867+  541B 3A BC 4F         LD A,(ANIMITEMNUM)
868+  541E B9               CP C
869+  541F 38 19            JR C,.ERROR ; invalid animation item, stop animation
870+  5421 0D               DEC C
871+  5422 79               LD A,C
872+  5423 CD CE 4F         CALL GETnthANIMITEM
873+  5426 E5               PUSH HL
874+  5427 FD E1            POP IY ; IY=animation item
875+  5429 05               DEC B
876+  542A 28 0C            JR Z,.EXIT
877+  542C FD 5E 01         LD E,(IY+1)
878+  542F FD 56 02         LD D,(IY+2) ; duration
879+  5432 DD 73 01         LD (IX+1),E
880+  5435 DD 72 02         LD (IX+2),D
881+  5438              .EXIT:
882+  5438 AF               XOR A
883+  5439 C9               RET
884+  543A              .ERROR:
885+  543A 37               SCF
886+  543B C9               RET
887+  543C              ; *******************************************************************************************************
888+  543C
889+  543C              ; *******************************************************************************************************
890+  543C              ; function will display currect item and set up expiry time
891+  543C              ; it will also stop the animation if expired
892+  543C              ; sets sprite update flag if any changes in sprite data made
893+  543C              ; input IX=current sprite animation
894+  543C              ; input B=1 skip timer setup
895+  543C              SETUP_ANIM_STEP:
896+  543C DD 4E 04         LD C,(IX+4) ; animation definition ID
897+  543F 0C               INC C
898+  5440 3A BF 4F         LD A,(ANIMDEFNUM)
899+  5443 B9               CP C
900+  5444 30 05            JR NC,.L2
901+  5446                  ; given animation item is outside of bounds, deactivate animation
902+  5446              .STOPANIM:
903+  5446 DD 36 06 00      LD (IX+6),0
904+  544A C9               RET
905+  544B              .L2:
906+  544B 0D               DEC C
907+  544C 79               LD A,C
908+  544D CD FF 53         CALL INIT_CURRENT_ANIMATION
909+  5450 38 F4            JR C, .STOPANIM
910+  5452 FD 7E 00         LD A,(IY) ; type of animation item
911+  5455 B7               OR A
912+  5456 28 38            JR Z,.L4 ; change pattern and/or color
913+  5458              .PAT:
914+  5458                  ; change pattern definition
915+  5458                  ; check if sprite or character
916+  5458 DD 7E 07         LD A,(IX+7)
917+  545B B7               OR A
918+  545C 20 4C            JR NZ,.CHAR
919+  545E DD 7E 00         LD A,(IX) ; sprite number
920+  5461 CD 7C 4D         CALL GETnthSPRATTR
921+  5464 23          > INC HL ; skip y and x
921+  5465 23          > INC HL
921+  5466 23          > INC HL
921+  5467 23          > INC HL
922+  5468 7E               LD A,(HL); current pattern
923+  5469 26 00            LD H,0
924+  546B 6F               LD L,A
925+  546C 3A E0 F3         LD A,(REG1SAV)
926+  546F E6 02            AND 2
927+  5471 20 07            JR NZ,.L6
928+  5473                  ; 8x8 sprite
929+  5473 CD AE 5F         CALL HLx8
930+  5476 06 08            LD B,8
931+  5478 18 05            JR .L5
932+  547A              .L6:
933+  547A CD AC 5F         CALL HLx32
934+  547D 06 20            LD B,32
935+  547F              .L5:
936+  547F ED 5B 26 F9      LD DE,(PATBAS)
937+  5483              .L7:
938+  5483 19               ADD HL,DE
939+  5484 CD 99 5F         CALL SETWRT_LOCAL
940+  5487 FD 6E 03         LD L,(IY+3)
941+  548A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
942+  548D C3 A4 5F         JP BBYTECOPY
943+  5490              .L4:
944+  5490                  ; change pattern and color in sprite attributes table
945+  5490 DD 7E 00         LD A,(IX) ; sprite number
946+  5493 CD 7C 4D         CALL GETnthSPRATTR
947+  5496 23          > INC HL ; skip y and x
947+  5497 23          > INC HL
947+  5498 23          > INC HL
947+  5499 23          > INC HL
948+  549A FD 7E 03         LD A,(IY+3) ; new pattern
949+  549D 77               LD (HL),A
950+  549E 23          > INC HL
950+  549F 23          > INC HL
951+  54A0 FD 7E 04         LD A,(IY+4) ; new color
952+  54A3 77               LD (HL),A
953+  54A4 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
954+  54A7 36 01            LD (HL),1
955+  54A9 C9               RET
956+  54AA              .CHAR:
957+  54AA DD 6E 00         LD L,(IX)
958+  54AD 3D               DEC A
959+  54AE 67               LD H,A
960+  54AF CD AE 5F         CALL HLx8
961+  54B2 ED 5B 24 F9      LD DE,(CGPBAS)
962+  54B6 06 08            LD B,8
963+  54B8 18 C9            JR .L7
964+  54BA              ; *******************************************************************************************************
965+  54BA
# file closed: asm\ANIMATION.asm
121   54BA               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
  1+  54BA              ; Sprite Group Animate and Move
  2+  54BA
  3+  54BA              ; *******************************************************************************************************
  4+  54BA              ; function to handle CALL SGAM basic extension
  5+  54BA              ; sets position of a group of sprites as described in SPRGRPMOV
  6+  54BA              ; and manually animate a list of animations
  7+  54BA              ; _SGAM ( INT x,
  8+  54BA              ;	      INT y,
  9+  54BA              ;		  BYTE count,
 10+  54BA              ;		  INT[2][count] data_ptr,
 11+  54BA              ;         BYTE item_number,
 12+  54BA              ;         INT[] sprite_animations )
 13+  54BA              ; will put ram in page 0 also, page 1 is already there
 14+  54BA              SGAM:
 15+  54BA 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
 16+  54BD B7           	OR A
 17+  54BE CA DD 60     	JP Z,ILLEGAL_FUNCTION
 18+  54C1              	; opening (
 19+  54C1 CD BF 60     	CALL CHKCHAR
 20+  54C4 28           	DB '('
 21+  54C5              	; get x
 22+  54C5 DD 21 2F 54  	LD IX, FRMQNT
 23+  54C9 CD 59 01     	CALL CALBAS
 24+  54CC ED 53 F6 5D  	LD (BLIT_STRUCT),DE
 25+  54D0              	; comma
 26+  54D0 CD BF 60     	CALL CHKCHAR
 27+  54D3 2C           	DB ','
 28+  54D4              	; get y
 29+  54D4 DD 21 2F 54  	LD IX, FRMQNT
 30+  54D8 CD 59 01     	CALL CALBAS
 31+  54DB ED 53 F8 5D  	LD (BLIT_STRUCT+2),DE
 32+  54DF              	; comma
 33+  54DF CD BF 60     	CALL CHKCHAR
 34+  54E2 2C           	DB ','
 35+  54E3              	; get count
 36+  54E3 DD 21 1C 52  	LD IX, GETBYT
 37+  54E7 CD 59 01     	CALL CALBAS
 38+  54EA B7               OR A
 39+  54EB CA D5 60         JP Z,SUBSCRIPT_OUT_OF_RANGE
 40+  54EE 32 FA 5D     	LD (BLIT_STRUCT+4),A
 41+  54F1              	; comma
 42+  54F1 CD BF 60     	CALL CHKCHAR
 43+  54F4 2C           	DB ','
 44+  54F5              	; get sprite group definition array data pointer
 45+  54F5 3A FA 5D         LD A,(BLIT_STRUCT+4)
 46+  54F8 5F           	LD E,A
 47+  54F9 16 03        	LD D,3
 48+  54FB 3E 02        	LD A,2
 49+  54FD 47           	LD B,A
 50+  54FE CD EA 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
 51+  5501 ED 43 FB 5D  	LD (BLIT_STRUCT+5),BC
 52+  5505              	; comma
 53+  5505 CD BF 60     	CALL CHKCHAR
 54+  5508 2C           	DB ','
 55+  5509              	; get sprite animation array size
 56+  5509 DD 21 1C 52  	LD IX,GETBYT
 57+  550D CD 59 01     	CALL CALBAS
 58+  5510 32 FD 5D         LD (BLIT_STRUCT+7),A
 59+  5513 B7               OR A
 60+  5514 CA D5 60         JP Z,SUBSCRIPT_OUT_OF_RANGE
 61+  5517              	; comma
 62+  5517 CD BF 60     	CALL CHKCHAR
 63+  551A 2C           	DB ','
 64+  551B                  ; get array pointer
 65+  551B 3A FD 5D         LD A,(BLIT_STRUCT+7)
 66+  551E 57               LD D,A
 67+  551F 3E 02            LD A,2
 68+  5521 06 01            LD B,1
 69+  5523 CD EA 60         CALL GET_BASIC_ARRAY_DATA_POINTER
 70+  5526 ED 43 FE 5D      LD (BLIT_STRUCT+8),BC
 71+  552A              	; ending )
 72+  552A CD BF 60     	CALL CHKCHAR
 73+  552D 29           	DB ')'
 74+  552E
 75+  552E E5               PUSH HL
 76+  552F F3               DI
 77+  5530
 78+  5530              	; enable page 0
 79+  5530 FD 21 37 55  	LD IY, .RET
 80+  5534 C3 72 60     	JP ENABLE_PAGE0
 81+  5537              .RET:
 82+  5537 D9               EXX
 83+  5538 ED 5B F6 5D      LD DE,(BLIT_STRUCT) ; initial x
 84+  553C ED 4B F8 5D      LD BC,(BLIT_STRUCT+2) ; initial y
 85+  5540 D9               EXX
 86+  5541 2A FB 5D         LD HL,(BLIT_STRUCT+5) ; pointer to data
 87+  5544 3A FA 5D         LD A,(BLIT_STRUCT+4) ; number of entries
 88+  5547 47               LD B,A
 89+  5548 CD AA 4F         CALL SPRGRPMOV.UPDATE_LOC
 90+  554B
 91+  554B 21 BD 53         LD HL,ANIMSTARTSTOP_COMMON.STEP
 92+  554E 22 A9 53         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
 93+  5551 3A FD 5D         LD A,(BLIT_STRUCT+7) ; anim number
 94+  5554 47               LD B,A
 95+  5555 ED 5B FE 5D      LD DE,(BLIT_STRUCT+8) ; anim list
 96+  5559              .L1:
 97+  5559 C5               PUSH BC
 98+  555A 1A               LD A,(DE)
 99+  555B 13          > INC DE
 99+  555C 13          > INC DE
100+  555D D5               PUSH DE
101+  555E CD 97 53         CALL ANIMSTARTSTOP_COMMON.SETVALUE
102+  5561 D1               POP DE
103+  5562 C1               POP BC
104+  5563 10 F4            DJNZ .L1
105+  5565
106+  5565 D1               POP DE
107+  5566 C1               POP BC
108+  5567 CD E9 5F         CALL RESTORE_PAGE_INFO
109+  556A FB               EI
110+  556B E1               POP HL
111+  556C C9               RET
112+  556D              ; *******************************************************************************************************
113+  556D
# file closed: asm\SGAM.asm
122   556D               ENDIF
123   556D
124   556D               IF (RAM_CMDS == 1)
125   556D               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  556D              ; *******************************************************************************************************
  2+  556D              ; function to handle CALL MEMCPY basic extension
  3+  556D              ; _MEMCPY ( INT source,
  4+  556D              ;			INT destination,
  5+  556D              ;			INT count,
  6+  556D              ; will put ram in page 0 also, page 1 is already there
  7+  556D              MEMCPY:
  8+  556D              	; opening (
  9+  556D CD BF 60     	CALL CHKCHAR
 10+  5570 28           	DB '('
 11+  5571              	; get source address
 12+  5571 DD 21 2F 54  	LD IX, FRMQNT
 13+  5575 CD 59 01     	CALL CALBAS
 14+  5578 D5           	PUSH DE
 15+  5579              	; comma
 16+  5579 CD BF 60     	CALL CHKCHAR
 17+  557C 2C           	DB ','
 18+  557D              	; get destination address
 19+  557D DD 21 2F 54  	LD IX, FRMQNT
 20+  5581 CD 59 01     	CALL CALBAS
 21+  5584 D5           	PUSH DE
 22+  5585              	; comma
 23+  5585 CD BF 60     	CALL CHKCHAR
 24+  5588 2C           	DB ','
 25+  5589              	; get length
 26+  5589 DD 21 2F 54  	LD IX, FRMQNT
 27+  558D CD 59 01     	CALL CALBAS
 28+  5590 D5           	PUSH DE
 29+  5591              	; ending )
 30+  5591 CD BF 60     	CALL CHKCHAR
 31+  5594 29           	DB ')'
 32+  5595
 33+  5595              	; save position
 34+  5595 E5           	PUSH HL
 35+  5596 DD E1        	POP IX
 36+  5598
 37+  5598 C1           	POP BC ; count
 38+  5599 D1           	POP DE ; destination
 39+  559A E1           	POP HL ; source
 40+  559B D9           	EXX
 41+  559C              	; enable page 0
 42+  559C FD 21 A3 55  	LD IY, .RET
 43+  55A0 C3 72 60     	JP ENABLE_PAGE0
 44+  55A3              .RET:
 45+  55A3 FB           	EI
 46+  55A4 D9           	EXX
 47+  55A5 ED B0        	LDIR
 48+  55A7 D1               POP DE
 49+  55A8 C1               POP BC
 50+  55A9 CD E9 5F         CALL RESTORE_PAGE_INFO
 51+  55AC DD E5        	PUSH IX
 52+  55AE E1           	POP HL
 53+  55AF C9           	RET
 54+  55B0              ; *******************************************************************************************************
 55+  55B0
 56+  55B0              ; *******************************************************************************************************
 57+  55B0              ; function to handle CALL FILRAM basic extension
 58+  55B0              ; FILRAM ( INT start address,
 59+  55B0              ;		   INT count,
 60+  55B0              ;		   BYTE value,
 61+  55B0              ; will put ram in page 0 also, page 1 is already there
 62+  55B0              FILRAM:
 63+  55B0              	; opening (
 64+  55B0 CD BF 60     	CALL CHKCHAR
 65+  55B3 28           	DB '('
 66+  55B4              	; get start address
 67+  55B4 DD 21 2F 54  	LD IX, FRMQNT
 68+  55B8 CD 59 01     	CALL CALBAS
 69+  55BB D5           	PUSH DE
 70+  55BC              	; comma
 71+  55BC CD BF 60     	CALL CHKCHAR
 72+  55BF 2C           	DB ','
 73+  55C0              	; get count
 74+  55C0 DD 21 2F 54  	LD IX, FRMQNT
 75+  55C4 CD 59 01     	CALL CALBAS
 76+  55C7 D5           	PUSH DE
 77+  55C8              	; comma
 78+  55C8 CD BF 60     	CALL CHKCHAR
 79+  55CB 2C           	DB ','
 80+  55CC              	; get value
 81+  55CC DD 21 1C 52  	LD IX, GETBYT
 82+  55D0 CD 59 01     	CALL CALBAS
 83+  55D3 F5           	PUSH AF
 84+  55D4              	; ending )
 85+  55D4 CD BF 60     	CALL CHKCHAR
 86+  55D7 29           	DB ')'
 87+  55D8
 88+  55D8              	; save position
 89+  55D8 E5           	PUSH HL
 90+  55D9 DD E1        	POP IX
 91+  55DB
 92+  55DB D1           	POP DE ; actually AF
 93+  55DC C1           	POP BC ; count
 94+  55DD E1           	POP HL ; start address
 95+  55DE 78           	LD A, B
 96+  55DF B7           	OR A
 97+  55E0 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  55E2 B1           	OR C
 99+  55E3 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  55E5 79           	LD A, C
101+  55E6 3D           	DEC A
102+  55E7 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  55E9              	; one byte to fill
104+  55E9 72           	LD (HL), D
105+  55EA 18 12        	JR .EXIT
106+  55EC              .L1:
107+  55EC D9           	EXX
108+  55ED              	; enable page 0
109+  55ED FD 21 F4 55  	LD IY, .RET
110+  55F1 C3 72 60     	JP ENABLE_PAGE0
111+  55F4              .RET:
112+  55F4 FB           	EI
113+  55F5 D9           	EXX
114+  55F6 CD 02 56     	CALL .FILLVALUE
115+  55F9 D1               POP DE
116+  55FA C1               POP BC
117+  55FB CD E9 5F         CALL RESTORE_PAGE_INFO
118+  55FE              .EXIT:
119+  55FE DD E5        	PUSH IX
120+  5600 E1           	POP HL
121+  5601 C9           	RET
122+  5602
123+  5602              .FILLVALUE:
124+  5602 72               LD (HL), D
125+  5603 54               LD D, H
126+  5604 5D               LD E, L
127+  5605 13               INC DE
128+  5606 0B               DEC BC
129+  5607 ED B0            LDIR
130+  5609 C9               RET
131+  560A              ; *******************************************************************************************************
132+  560A
# file closed: asm\MEMORY.asm
126   560A               ENDIF
127   560A
128   560A               IF (SOUND_CMDS == 1)
129   560A               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  560A              MUSIC_INIT_STATUS:
  2+  560A 00            DB 0
  3+  560B              SFX_INIT_STATUS:
  4+  560B 00            DB 0
  5+  560C              SOUND_ENABLED:
  6+  560C 00            DB 0
  7+  560D
  8+  560D              ; *******************************************************************************************************
  9+  560D              ; function to handle CALL SNDPLYINIT basic extension
 10+  560D              ; initializes sound player
 11+  560D              ; _SNDPLYINIT ( INT music_offset,
 12+  560D              ;				INT sfx_offset, can be -1 if no SFX
 13+  560D              ; will put ram in page 0 also, page 1 is already there
 14+  560D              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  560D              SNDPLYINIT:
 16+  560D              	; opening (
 17+  560D CD BF 60     	CALL CHKCHAR
 18+  5610 28           	DB '('
 19+  5611              	; get music address
 20+  5611 DD 21 2F 54  	LD IX, FRMQNT
 21+  5615 CD 59 01     	CALL CALBAS
 22+  5618 D5           	PUSH DE
 23+  5619              	; comma
 24+  5619 CD BF 60     	CALL CHKCHAR
 25+  561C 2C           	DB ','
 26+  561D              	; get sfx address
 27+  561D DD 21 2F 54  	LD IX, FRMQNT
 28+  5621 CD 59 01     	CALL CALBAS
 29+  5624 D5           	PUSH DE
 30+  5625              	; ending )
 31+  5625 CD BF 60     	CALL CHKCHAR
 32+  5628 29           	DB ')'
 33+  5629
 34+  5629                  ; save position in BASIC text
 35+  5629 44           	LD B, H
 36+  562A 4D           	LD C, L
 37+  562B
 38+  562B              	; pop LDIR parameters and store away for later
 39+  562B D1           	POP DE ; sfx address
 40+  562C E1           	POP HL ; music address
 41+  562D C5           	PUSH BC ; basic text location
 42+  562E D9           	EXX
 43+  562F FD 21 36 56  	LD IY, .RET
 44+  5633 C3 72 60     	JP ENABLE_PAGE0
 45+  5636              .RET:
 46+  5636 D9           	EXX
 47+  5637
 48+  5637 D5           	PUSH DE
 49+  5638 AF           	XOR A
 50+  5639              	; HL = music location
 51+  5639 CD 62 41     	CALL PLY_AKG_INIT
 52+  563C 3E 01        	LD A, 1
 53+  563E 32 0A 56     	LD (MUSIC_INIT_STATUS), A
 54+  5641
 55+  5641 E1           	POP HL ; SFX
 56+  5642              	; check if SFX address -1
 57+  5642 23           	INC HL
 58+  5643 7D           	LD A, L
 59+  5644 B4           	OR H
 60+  5645 28 09        	JR Z,.L1
 61+  5647 2B           	DEC HL
 62+  5648 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  564B 3E 01        	LD A, 1
 64+  564D 32 0B 56     	LD (SFX_INIT_STATUS), A
 65+  5650              .L1:
 66+  5650 D1               POP DE
 67+  5651 C1               POP BC
 68+  5652 CD E9 5F         CALL RESTORE_PAGE_INFO
 69+  5655
 70+  5655 E1           	POP HL
 71+  5656 C9           	RET
 72+  5657              ; *******************************************************************************************************
 73+  5657
 74+  5657              ; *******************************************************************************************************
 75+  5657              ; function to handle CALL SNDPLYON basic extension
 76+  5657              ; enables sound player
 77+  5657              ; _SNDPLYON
 78+  5657              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  5657              ; if not throws out of data error
 80+  5657              SNDPLYON:
 81+  5657 3A 0A 56     	LD A, (MUSIC_INIT_STATUS)
 82+  565A B7           	OR A
 83+  565B 20 05        	JR NZ, .L1
 84+  565D              	; player not initialized, throw error
 85+  565D 1E 04        	LD E, 04 ; Out of DATA
 86+  565F C3 E3 60     	JP THROW_ERROR
 87+  5662              .L1:
 88+  5662 32 0C 56     	LD (SOUND_ENABLED), A
 89+  5665              	; disable key click
 90+  5665 AF           	XOR A
 91+  5666 32 DB F3     	LD (CLIKSW), A
 92+  5669 C9           	RET
 93+  566A              ; *******************************************************************************************************
 94+  566A
 95+  566A              ; *******************************************************************************************************
 96+  566A              ; function to handle CALL SNDPLYOFF basic extension
 97+  566A              ; disables sound player
 98+  566A              ; _SNDPLYOFF
 99+  566A              ; sets SOUND_ENABLED variable to 0
100+  566A              ; calls AKG to stop music and SFX on all channels if initialized
101+  566A              SNDPLYOFF:
102+  566A 3A 0C 56     	LD A, (SOUND_ENABLED)
103+  566D B7           	OR A
104+  566E C8           	RET Z ; already stopped
105+  566F AF           	XOR A
106+  5670 32 0C 56     	LD (SOUND_ENABLED), A
107+  5673 E5           	PUSH HL
108+  5674 CD 21 42     	CALL PLY_AKG_STOP
109+  5677 3A 0B 56     	LD A, (SFX_INIT_STATUS)
110+  567A B7           	OR A
111+  567B 28 0E        	JR Z, .EXIT ; SFX not in use
112+  567D AF           	XOR A
113+  567E CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  5681 3E 01        	LD A, 1
115+  5683 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  5686 3E 02        	LD A, 2
117+  5688 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  568B              .EXIT:
119+  568B E1           	POP HL
120+  568C C9           	RET
121+  568D              ; *******************************************************************************************************
122+  568D
123+  568D              ; *******************************************************************************************************
124+  568D              ; function to handle CALL SNDSFX basic extension
125+  568D              ; plays a sound effect
126+  568D              ; _SNDSFX ( BYTE sfx_number, >0
127+  568D              ;			BYTE channel, = 0,1 or 2
128+  568D              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  568D              ; will put ram in page 0 also, page 1 is already there
130+  568D              ; if sound off throws illegal function call
131+  568D              ; if sfx not initialized, throws out of data
132+  568D              SNDSFX:
133+  568D              	; opening (
134+  568D CD BF 60     	CALL CHKCHAR
135+  5690 28           	DB '('
136+  5691              	; get sfx_number
137+  5691 DD 21 1C 52  	LD IX, GETBYT
138+  5695 CD 59 01     	CALL CALBAS
139+  5698 D5           	PUSH DE
140+  5699              	; comma
141+  5699 CD BF 60     	CALL CHKCHAR
142+  569C 2C           	DB ','
143+  569D              	; get sfx address
144+  569D DD 21 1C 52  	LD IX, GETBYT
145+  56A1 CD 59 01     	CALL CALBAS
146+  56A4 D5           	PUSH DE
147+  56A5              	; comma
148+  56A5 CD BF 60     	CALL CHKCHAR
149+  56A8 2C           	DB ','
150+  56A9              	; get inverted volume
151+  56A9 DD 21 1C 52  	LD IX, GETBYT
152+  56AD CD 59 01     	CALL CALBAS
153+  56B0 D5           	PUSH DE
154+  56B1              	; ending )
155+  56B1 CD BF 60     	CALL CHKCHAR
156+  56B4 29           	DB ')'
157+  56B5
158+  56B5 3A 0C 56     	LD A, (SOUND_ENABLED)
159+  56B8 B7           	OR A
160+  56B9 20 05        	JR NZ, .L1
161+  56BB              	; sound disabled, throw illegal function call
162+  56BB 1E 05        	LD E, 5
163+  56BD C3 E3 60     	JP THROW_ERROR
164+  56C0              .L1:
165+  56C0 3A 0B 56     	LD A, (SFX_INIT_STATUS)
166+  56C3 B7           	OR A
167+  56C4 20 05        	JR NZ, .L2
168+  56C6              	; sfx data not initialized, throw out of data
169+  56C6 1E 04        	LD E, 4
170+  56C8 C3 E3 60     	JP THROW_ERROR
171+  56CB              .L2:
172+  56CB              	; pop  parameters and store away for later
173+  56CB D1           	POP DE ; inverted volume
174+  56CC 43           	LD B, E
175+  56CD D1           	POP DE ; channel
176+  56CE 4B           	LD C, E
177+  56CF D1           	POP DE
178+  56D0 7B           	LD A, E
179+  56D1 08           	EX AF, AF'
180+  56D2 E5           	PUSH HL ; basic text location
181+  56D3 D9           	EXX
182+  56D4 FD 21 DB 56  	LD IY, .RET
183+  56D8 C3 72 60     	JP ENABLE_PAGE0
184+  56DB              .RET:
185+  56DB D9           	EXX
186+  56DC 08           	EX AF, AF'
187+  56DD CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  56E0
189+  56E0 D1               POP DE
190+  56E1 C1               POP BC
191+  56E2 CD E9 5F         CALL RESTORE_PAGE_INFO
192+  56E5
193+  56E5 E1           	POP HL
194+  56E6 C9           	RET
195+  56E7              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
130   56E7               ENDIF
131   56E7
132   56E7               IF (VRAM_CMDS == 1)
133   56E7               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  56E7              ; *******************************************************************************************************
  2+  56E7              ; function to handle CALL FILVRM basic extension
  3+  56E7              ; FILVRM ( INT offset,
  4+  56E7              ;		   INT count,
  5+  56E7              ;		   BYTE value,
  6+  56E7              ;		   BYTE wait_vsync) >0 = true
  7+  56E7              ; wait_vsync will issue HALT before copying
  8+  56E7              FILVRM:
  9+  56E7              	; opening (
 10+  56E7 CD BF 60     	CALL CHKCHAR
 11+  56EA 28           	DB '('
 12+  56EB              	; get offset address
 13+  56EB DD 21 2F 54  	LD IX, FRMQNT
 14+  56EF CD 59 01     	CALL CALBAS
 15+  56F2 D5           	PUSH DE
 16+  56F3              	; comma
 17+  56F3 CD BF 60     	CALL CHKCHAR
 18+  56F6 2C           	DB ','
 19+  56F7              	; get count
 20+  56F7 DD 21 2F 54  	LD IX, FRMQNT
 21+  56FB CD 59 01     	CALL CALBAS
 22+  56FE D5           	PUSH DE
 23+  56FF              	; comma
 24+  56FF CD BF 60     	CALL CHKCHAR
 25+  5702 2C           	DB ','
 26+  5703              	; get value
 27+  5703 DD 21 1C 52  	LD IX, GETBYT
 28+  5707 CD 59 01     	CALL CALBAS
 29+  570A F5           	PUSH AF
 30+  570B              	; comma
 31+  570B CD BF 60     	CALL CHKCHAR
 32+  570E 2C           	DB ','
 33+  570F              	; get vsync wait
 34+  570F DD 21 1C 52  	LD IX, GETBYT
 35+  5713 CD 59 01     	CALL CALBAS
 36+  5716 F5           	PUSH AF
 37+  5717              	; ending )
 38+  5717 CD BF 60     	CALL CHKCHAR
 39+  571A 29           	DB ')'
 40+  571B
 41+  571B FB               EI
 42+  571C              	; save position
 43+  571C E5           	PUSH HL
 44+  571D DD E1        	POP IX
 45+  571F
 46+  571F              	; syntax ok
 47+  571F              	; wait for vsync if needed
 48+  571F F1           	POP AF
 49+  5720 B7           	OR A
 50+  5721 28 01        	JR Z, .L1
 51+  5723 76           	HALT
 52+  5724
 53+  5724              .L1:
 54+  5724 3E 01        	LD A,1
 55+  5726 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  5729 F1               POP AF ; value
 57+  572A C1               POP BC ; count
 58+  572B E1               POP HL ; offset
 59+  572C CD 56 00         CALL BIOS_FILVRM
 60+  572F AF           	XOR A
 61+  5730 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  5733
 63+  5733              .L3:
 64+  5733 DD E5        	PUSH IX
 65+  5735 E1           	POP HL
 66+  5736 C9           	RET
 67+  5737              ; *******************************************************************************************************
 68+  5737
 69+  5737              ; *******************************************************************************************************
 70+  5737              ; function to handle CALL MEMVRM basic extension
 71+  5737              ; copies from RAM to VRAM
 72+  5737              ; _MEMVRM ( INT source,
 73+  5737              ;			INT destination,
 74+  5737              ;			INT count,
 75+  5737              ;			BYTE wait_vsync) >0 = true
 76+  5737              ; will put ram in page 0 also, page 1 is already there
 77+  5737              ; wait_vsync will issue HALT before copying
 78+  5737              MEMVRM:
 79+  5737              	; opening (
 80+  5737 CD BF 60     	CALL CHKCHAR
 81+  573A 28           	DB '('
 82+  573B              	; get source address
 83+  573B DD 21 2F 54  	LD IX, FRMQNT
 84+  573F CD 59 01     	CALL CALBAS
 85+  5742 D5           	PUSH DE
 86+  5743              	; comma
 87+  5743 CD BF 60     	CALL CHKCHAR
 88+  5746 2C           	DB ','
 89+  5747              	; get destination address
 90+  5747 DD 21 2F 54  	LD IX, FRMQNT
 91+  574B CD 59 01     	CALL CALBAS
 92+  574E D5           	PUSH DE
 93+  574F              	; comma
 94+  574F CD BF 60     	CALL CHKCHAR
 95+  5752 2C           	DB ','
 96+  5753              	; get length
 97+  5753 DD 21 2F 54  	LD IX, FRMQNT
 98+  5757 CD 59 01     	CALL CALBAS
 99+  575A D5           	PUSH DE
100+  575B              	; comma
101+  575B CD BF 60     	CALL CHKCHAR
102+  575E 2C           	DB ','
103+  575F              	; get vsync wait
104+  575F DD 21 1C 52  	LD IX, GETBYT
105+  5763 CD 59 01     	CALL CALBAS
106+  5766 F5           	PUSH AF
107+  5767              	; ending )
108+  5767 CD BF 60     	CALL CHKCHAR
109+  576A 29           	DB ')'
110+  576B
111+  576B                  ; save position in BASIC text
112+  576B E5           	PUSH HL
113+  576C DD E1        	POP IX
114+  576E
115+  576E F1           	POP AF ; wait vsync
116+  576F B7           	OR A
117+  5770 28 03        	JR Z, .L1
118+  5772 FB               EI
119+  5773 76           	HALT
120+  5774 F3           	DI
121+  5775              .L1:
122+  5775              	; pop LDIR parameters and store away for later
123+  5775 C1           	POP BC ; count
124+  5776 D1           	POP DE ; vram destination
125+  5777 E1           	POP HL ; ram source
126+  5778 D9           	EXX
127+  5779 FD 21 80 57   	LD IY, .RET
128+  577D C3 72 60     	JP ENABLE_PAGE0
129+  5780              .RET:
130+  5780 FB           	EI
131+  5781 D9           	EXX
132+  5782 3E 01        	LD A,1
133+  5784 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  5787 CD 97 57     	CALL .LDIRVM
135+  578A AF           	XOR A
136+  578B 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  578E D1               POP DE
138+  578F C1               POP BC
139+  5790 CD E9 5F         CALL RESTORE_PAGE_INFO
140+  5793 DD E5        	PUSH IX
141+  5795 E1           	POP HL
142+  5796 C9           	RET
143+  5797
144+  5797              .LDIRVM:
145+  5797 EB           	EX DE, HL
146+  5798 F3           	DI
147+  5799 CD 99 5F     	CALL SETWRT_LOCAL
148+  579C FB           	EI
149+  579D EB           	EX DE, HL
150+  579E 78           	LD A, B
151+  579F B7           	OR A
152+  57A0 28 0D        	JR Z, .L3
153+  57A2 C5           	PUSH BC
154+  57A3 0E 98        	LD C, #98
155+  57A5              .L2:
156+  57A5 50           	LD D, B
157+  57A6 06 00        	LD B, 0
158+  57A8 CD A6 5F     	CALL BBYTECOPY_NO_C
159+  57AB 42           	LD B, D
160+  57AC 10 F7        	DJNZ .L2
161+  57AE C1           	POP BC
162+  57AF              .L3:
163+  57AF 79           	LD A, C
164+  57B0 B7           	OR A
165+  57B1 C8           	RET Z
166+  57B2 41           	LD B, C
167+  57B3 C3 A4 5F     	JP BBYTECOPY
168+  57B6              ; *******************************************************************************************************
169+  57B6
170+  57B6              ; *******************************************************************************************************
171+  57B6              ; function to handle CALL VRMMEM basic extension
172+  57B6              ; copies from RAM to VRAM
173+  57B6              ; _VRMMEM ( INT source,
174+  57B6              ;			INT destination,
175+  57B6              ;			INT count
176+  57B6              ; will put ram in page 0 also, page 1 is already there
177+  57B6              VRMMEM:
178+  57B6              	; opening (
179+  57B6 CD BF 60     	CALL CHKCHAR
180+  57B9 28           	DB '('
181+  57BA              	; get source address
182+  57BA DD 21 2F 54  	LD IX, FRMQNT
183+  57BE CD 59 01     	CALL CALBAS
184+  57C1 D5           	PUSH DE
185+  57C2              	; comma
186+  57C2 CD BF 60     	CALL CHKCHAR
187+  57C5 2C           	DB ','
188+  57C6              	; get destination address
189+  57C6 DD 21 2F 54  	LD IX, FRMQNT
190+  57CA CD 59 01     	CALL CALBAS
191+  57CD D5           	PUSH DE
192+  57CE              	; comma
193+  57CE CD BF 60     	CALL CHKCHAR
194+  57D1 2C           	DB ','
195+  57D2              	; get length
196+  57D2 DD 21 2F 54  	LD IX, FRMQNT
197+  57D6 CD 59 01     	CALL CALBAS
198+  57D9 D5           	PUSH DE
199+  57DA              	; ending )
200+  57DA CD BF 60     	CALL CHKCHAR
201+  57DD 29           	DB ')'
202+  57DE
203+  57DE                  ; save position in BASIC text
204+  57DE E5           	PUSH HL
205+  57DF DD E1        	POP IX
206+  57E1
207+  57E1 C1           	POP BC ; count
208+  57E2 D1           	POP DE ; destination
209+  57E3 E1           	POP HL ; source
210+  57E4 D9           	EXX
211+  57E5 FD 21 EC 57  	LD IY, .RET
212+  57E9 C3 72 60     	JP ENABLE_PAGE0
213+  57EC              .RET:
214+  57EC FB           	EI
215+  57ED D9           	EXX
216+  57EE 3E 01        	LD A,1
217+  57F0 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  57F3 CD 03 58     	CALL .LDIRMV
219+  57F6 AF           	XOR A
220+  57F7 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  57FA D1               POP DE
222+  57FB C1               POP BC
223+  57FC CD E9 5F         CALL RESTORE_PAGE_INFO
224+  57FF DD E5        	PUSH IX
225+  5801 E1           	POP HL
226+  5802 C9           	RET
227+  5803
228+  5803              .LDIRMV:
229+  5803              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  5803 7D           	LD	A, L
231+  5804 F3           	DI
232+  5805 D3 99        	OUT	(099H), A
233+  5807 7C           	LD	A, H
234+  5808 E6 3F        	AND	03FH
235+  580A D3 99        	OUT	(099H), A
236+  580C FB           	EI
237+  580D              	;EX (SP), HL
238+  580D              	;EX (SP), HL
239+  580D              	;NOP
240+  580D              	;NOP
241+  580D              .L4:
242+  580D DB 98            IN A, (#98)
243+  580F 12           	LD (DE), A
244+  5810 13               INC DE
245+  5811 0B               DEC BC
246+  5812 79               LD A, C
247+  5813 B0               OR B
248+  5814 20 F7            JR NZ, .L4
249+  5816 C9               RET
250+  5817              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
134   5817               ENDIF
135   5817
136   5817               IF (GENCAL_CMD == 1)
137   5817               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  5817              ; *******************************************************************************************************
  2+  5817              ; function to handle CALL GENCAL basic extension
  3+  5817              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  5817              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  5817              ; output values of registers will also be stored at reg_list_ptr
  6+  5817              GENCAL_VAR_SP:
  7+  5817 00 00            DW 0
  8+  5819              GENCAL_VAR_SP2:
  9+  5819 00 00            DW 0
 10+  581B              GENCAL:
 11+  581B              	; opening (
 12+  581B CD BF 60     	CALL CHKCHAR
 13+  581E 28           	DB '('
 14+  581F              	; get function address
 15+  581F DD 21 2F 54  	LD IX, FRMQNT
 16+  5823 CD 59 01     	CALL CALBAS
 17+  5826 D5           	PUSH DE
 18+  5827              	; comma
 19+  5827 CD BF 60     	CALL CHKCHAR
 20+  582A 2C           	DB ','
 21+  582B              	; get pointer to register list
 22+  582B 3E 02            LD A,2
 23+  582D 06 01            LD B,1
 24+  582F 11 00 05         LD DE,#0500
 25+  5832 CD EA 60         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  5835 C5           	PUSH BC
 27+  5836              	; ending )
 28+  5836 CD BF 60     	CALL CHKCHAR
 29+  5839 29           	DB ')'
 30+  583A
 31+  583A              	; save BASIC token position
 32+  583A E5           	PUSH HL
 33+  583B D9               EXX
 34+  583C E1           	POP HL ; HL'=next basic token
 35+  583D D9               EXX
 36+  583E
 37+  583E E1               POP HL ; get pointer to register values
 38+  583F F3           	DI
 39+  5840 ED 73 17 58      LD (GENCAL_VAR_SP), SP
 40+  5844 F9               LD SP, HL
 41+  5845 F1               POP AF
 42+  5846 C1               POP BC
 43+  5847 D1               POP DE
 44+  5848 E1               POP HL
 45+  5849 DD E1            POP IX
 46+  584B FD E1            POP IY
 47+  584D D9               EXX
 48+  584E ED 73 19 58      LD (GENCAL_VAR_SP2), SP
 49+  5852 ED 7B 17 58      LD SP, (GENCAL_VAR_SP)
 50+  5856 FB               EI
 51+  5857 D1               POP DE ; get function to call
 52+  5858 E5               PUSH HL
 53+  5859 CD 74 58         CALL .EXXDECALL
 54+  585C F3               DI
 55+  585D ED 73 17 58      LD (GENCAL_VAR_SP), SP
 56+  5861 ED 7B 19 58      LD SP, (GENCAL_VAR_SP2)
 57+  5865 FD E5            PUSH IY
 58+  5867 DD E5            PUSH IX
 59+  5869 E5               PUSH HL
 60+  586A D5               PUSH DE
 61+  586B C5               PUSH BC
 62+  586C F5               PUSH AF
 63+  586D ED 7B 17 58      LD SP, (GENCAL_VAR_SP)
 64+  5871 FB               EI
 65+  5872 E1               POP HL
 66+  5873 C9           	RET
 67+  5874
 68+  5874              .EXXDECALL:
 69+  5874 D5               PUSH DE
 70+  5875 D9               EXX
 71+  5876 C9               RET
 72+  5877              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
138   5877               ENDIF
139   5877
140   5877               IF (BOX_CMDS == 1)
141   5877               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  5877              ; *******************************************************************************************************
  2+  5877              ; generic function to implement rectangle data copy
  3+  5877              ; should be modified to call appropriate function for memory or vram
  4+  5877              ; input IX=pointer to following structure
  5+  5877              ; +00 source data pointer
  6+  5877              ; +02 num bytes in a row
  7+  5877              ; +04 number of rows
  8+  5877              ; +06 source add-to value till next row
  9+  5877              ; +08 destination address
 10+  5877              ; +10 destination add-to value till next row
 11+  5877              ; modifies AF, BC, DE, HL
 12+  5877              RECTANGLE_COPY:
 13+  5877 DD 6E 00     	LD L, (IX+0)
 14+  587A DD 66 01     	LD H, (IX+1) ; source address
 15+  587D DD 5E 08     	LD E, (IX+8)
 16+  5880 DD 56 09     	LD D, (IX+9) ; destination
 17+  5883 DD 46 04     	LD B, (IX+4) ; row number
 18+  5886              .L1:
 19+  5886 C5           	PUSH BC
 20+  5887 E5           		PUSH HL
 21+  5888 D5           			PUSH DE
 22+  5889 DD 4E 02     				LD C, (IX+2)
 23+  588C DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  588F              .CALL1:
 25+  588F CD 00 00     				CALL 0 ; set destination address from DE
 26+  5892              .CALL2:
 27+  5892 CD 00 00     				CALL 0 ; copy data fn
 28+  5895 E1           			POP HL
 29+  5896 DD 4E 0A     			LD C, (IX+10)
 30+  5899 DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  589C 09           			ADD HL, BC
 32+  589D EB           			EX DE, HL
 33+  589E E1           		POP HL
 34+  589F DD 4E 06     		LD C, (IX+6)
 35+  58A2 DD 46 07     		LD B, (IX+7) ; src add-to
 36+  58A5 09           		ADD HL, BC
 37+  58A6 C1           	POP BC
 38+  58A7 10 DD        	DJNZ .L1
 39+  58A9 C9           	RET
 40+  58AA              ; *******************************************************************************************************
 41+  58AA
 42+  58AA              ; *******************************************************************************************************
 43+  58AA              ; function to handle CALL BOXMEMCPY basic extension
 44+  58AA              ; copies data with window like boundaries within ram
 45+  58AA              ; BOXMEMCPY ( INT source data pointer,
 46+  58AA              ;			  INT source number of bytes in a row,
 47+  58AA              ;			  INT number of rows,
 48+  58AA              ;			  INT source add-to value till next row,
 49+  58AA              ; 			  INT destination pointer,
 50+  58AA              ;			  INT destination add-to value till next row )
 51+  58AA              ; request_data_ptr described in RECTANGLE_COPY
 52+  58AA              ; will put ram in page 0 also, page 1 is already there
 53+  58AA              BOXMEMCPY:
 54+  58AA 11 B4 58     	LD DE,BOXMEMCPY.RET
 55+  58AD ED 53 28 59  	LD (BOXCOMMON.ADDR+2), DE
 56+  58B1 C3 C7 58     	JP BOXCOMMON
 57+  58B4              .RET:
 58+  58B4 FB           	EI
 59+  58B5              	; set RAM functions to call
 60+  58B5 21 00 00     	LD HL, 0
 61+  58B8 22 8F 58     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 62+  58BB 22 91 58     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 63+  58BE 21 ED B0     	LD HL, #B0ED ; LDIR
 64+  58C1 22 93 58     	LD (RECTANGLE_COPY.CALL1+4), HL
 65+  58C4 C3 2D 59     	JP BOXCOMMON.CALL
 66+  58C7              ; *******************************************************************************************************
 67+  58C7
 68+  58C7              ; *******************************************************************************************************
 69+  58C7              ; common parts of BOX commands
 70+  58C7              BOXCOMMON:
 71+  58C7              	; opening (
 72+  58C7 CD BF 60     	CALL CHKCHAR
 73+  58CA 28           	DB '('
 74+  58CB              	; get source data pointer
 75+  58CB DD 21 2F 54  	LD IX, FRMQNT
 76+  58CF CD 59 01     	CALL CALBAS
 77+  58D2 ED 53 F6 5D  	LD (BLIT_STRUCT+0), DE
 78+  58D6              	; comma
 79+  58D6 CD BF 60     	CALL CHKCHAR
 80+  58D9 2C           	DB ','
 81+  58DA              	; source number of bytes in a row
 82+  58DA DD 21 2F 54  	LD IX, FRMQNT
 83+  58DE CD 59 01     	CALL CALBAS
 84+  58E1 ED 53 F8 5D  	LD (BLIT_STRUCT+2), DE
 85+  58E5              	; comma
 86+  58E5 CD BF 60     	CALL CHKCHAR
 87+  58E8 2C           	DB ','
 88+  58E9              	; number of rows
 89+  58E9 DD 21 2F 54  	LD IX, FRMQNT
 90+  58ED CD 59 01     	CALL CALBAS
 91+  58F0 ED 53 FA 5D  	LD (BLIT_STRUCT+4), DE
 92+  58F4              	; comma
 93+  58F4 CD BF 60     	CALL CHKCHAR
 94+  58F7 2C           	DB ','
 95+  58F8              	; source add-to value till next row
 96+  58F8 DD 21 2F 54  	LD IX, FRMQNT
 97+  58FC CD 59 01     	CALL CALBAS
 98+  58FF ED 53 FC 5D  	LD (BLIT_STRUCT+6), DE
 99+  5903              	; comma
100+  5903 CD BF 60     	CALL CHKCHAR
101+  5906 2C           	DB ','
102+  5907              	; destination pointer
103+  5907 DD 21 2F 54  	LD IX, FRMQNT
104+  590B CD 59 01     	CALL CALBAS
105+  590E ED 53 FE 5D  	LD (BLIT_STRUCT+8), DE
106+  5912              	; comma
107+  5912 CD BF 60     	CALL CHKCHAR
108+  5915 2C           	DB ','
109+  5916              	; destination add-to value till next row
110+  5916 DD 21 2F 54  	LD IX, FRMQNT
111+  591A CD 59 01     	CALL CALBAS
112+  591D ED 53 00 5E  	LD (BLIT_STRUCT+10), DE
113+  5921              	; ending )
114+  5921 CD BF 60     	CALL CHKCHAR
115+  5924 29           	DB ')'
116+  5925
117+  5925 E5           	PUSH HL ; save position in BASIC buffer
118+  5926              .ADDR:
119+  5926 FD 21 00 00  	LD IY, 0
120+  592A C3 72 60     	JP ENABLE_PAGE0
121+  592D              .CALL:
122+  592D DD 21 F6 5D  	LD IX,BLIT_STRUCT
123+  5931 CD 77 58     	CALL RECTANGLE_COPY
124+  5934 AF           	XOR A
125+  5935 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
126+  5938
127+  5938 D1               POP DE
128+  5939 C1               POP BC
129+  593A CD E9 5F         CALL RESTORE_PAGE_INFO
130+  593D
131+  593D E1           	POP HL
132+  593E C9           	RET
133+  593F              ; *******************************************************************************************************
134+  593F
135+  593F              ; *******************************************************************************************************
136+  593F              ; function to handle CALL BOXMEMVRM basic extension
137+  593F              ; copies data with window like boundaries from ram to Vram
138+  593F              ; BOXMEMVRM ( INT source data pointer,
139+  593F              ;			  INT source number of bytes in a row,
140+  593F              ;			  INT number of rows,
141+  593F              ;			  INT source add-to value till next row,
142+  593F              ; 			  INT destination pointer,
143+  593F              ;			  INT destination add-to value till next row )
144+  593F              ; request_data_ptr described in RECTANGLE_COPY
145+  593F              ; will put ram in page 0 also, page 1 is already there
146+  593F              BOXMEMVRM:
147+  593F 11 49 59     	LD DE,BOXMEMVRM.RET
148+  5942 ED 53 28 59  	LD (BOXCOMMON.ADDR+2), DE
149+  5946 C3 C7 58     	JP BOXCOMMON
150+  5949              .RET:
151+  5949 FB           	EI
152+  594A              	; set RAM functions to call
153+  594A 21 64 59     	LD HL, .SETDEST
154+  594D 22 90 58     	LD (RECTANGLE_COPY.CALL1+1), HL
155+  5950 21 6C 59     	LD HL, .COPYDATA
156+  5953 22 93 58     	LD (RECTANGLE_COPY.CALL2+1), HL
157+  5956 3E CD        	LD A, #CD ; CALL
158+  5958 32 8F 58     	LD (RECTANGLE_COPY.CALL1), A
159+  595B 32 92 58     	LD (RECTANGLE_COPY.CALL2), A
160+  595E              	;LD A,1
161+  595E 32 07 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
162+  5961 C3 2D 59     	JP BOXCOMMON.CALL
163+  5964              .SETDEST:
164+  5964 EB           	EX DE, HL
165+  5965 F3           	DI
166+  5966 CD 99 5F     	CALL SETWRT_LOCAL
167+  5969 FB           	EI
168+  596A EB           	EX DE, HL
169+  596B C9           	RET
170+  596C              .COPYDATA:
171+  596C 41           	LD B, C
172+  596D C3 A4 5F     	JP BBYTECOPY
173+  5970              ; *******************************************************************************************************
# file closed: asm\BOX.asm
142   5970               ENDIF
143   5970
144   5970               IF (BLIT_CMDS == 1)
145   5970               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  5970              ; *******************************************************************************************************
  2+  5970              ; function rotates mask and data of several characters and applies to background data
  3+  5970              ; this handles x-shift from 0 to 4
  4+  5970              ; contains self-modifying code that is set-up from external function
  5+  5970              ; input HL=pointer to mask data
  6+  5970              ; input HL'=pointer to character data
  7+  5970              ; input DE=output buffer containing background data
  8+  5970              ; input BC=DE+8
  9+  5970              ; input A=number of characters to process
 10+  5970              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  5970              SHIFT04:
 12+  5970 08           	EX AF, AF'
 13+  5971 7E           	LD A, (HL) ; get mask
 14+  5972 D9           	EXX
 15+  5973 57           	LD D, A
 16+  5974 1E FF        	LD E, #FF
 17+  5976 37           	SCF
 18+  5977              .M1:
 19+  5977 18 FE        	JR .M1 ; this is self-modifying part
 20+  5979 CB 1A        	RR D
 21+  597B CB 1B        	RR E
 22+  597D CB 1A        	RR D
 23+  597F CB 1B        	RR E
 24+  5981 CB 1A        	RR D
 25+  5983 CB 1B        	RR E
 26+  5985 CB 1A        	RR D
 27+  5987 CB 1B        	RR E
 28+  5989
 29+  5989 46           	LD B, (HL) ; get data
 30+  598A 0E 00        	LD C, 0
 31+  598C              .M2:
 32+  598C 18 FE        	JR .M2 ; also self-modifying part
 33+  598E CB 38        	SRL B
 34+  5990 CB 19        	RR C
 35+  5992 CB 38        	SRL B
 36+  5994 CB 19        	RR C
 37+  5996 CB 38        	SRL B
 38+  5998 CB 19        	RR C
 39+  599A CB 38        	SRL B
 40+  599C CB 19        	RR C
 41+  599E
 42+  599E D9           	EXX
 43+  599F 1A           	LD A, (DE) ; background
 44+  59A0 D9           	EXX
 45+  59A1 A2           	AND D
 46+  59A2 B0           	OR B
 47+  59A3 D9           	EXX
 48+  59A4 12           	LD (DE), A
 49+  59A5
 50+  59A5 0A           	LD A, (BC)
 51+  59A6 D9           	EXX
 52+  59A7 A3           	AND E
 53+  59A8 B1           	OR C
 54+  59A9 23           	INC HL
 55+  59AA D9           	EXX
 56+  59AB 02           	LD (BC), A
 57+  59AC
 58+  59AC 23           	INC HL
 59+  59AD 13           	INC DE
 60+  59AE 03           	INC BC
 61+  59AF
 62+  59AF 08           	EX AF, AF'
 63+  59B0 3D           	DEC A
 64+  59B1 C2 70 59     	JP NZ, SHIFT04
 65+  59B4 C9           	RET
 66+  59B5              ; *******************************************************************************************************
 67+  59B5
 68+  59B5              ; *******************************************************************************************************
 69+  59B5              ; function rotates mask and data of several characters and applies to background data
 70+  59B5              ; this handles x-shift from 5 to 8
 71+  59B5              ; contains self-modifying code that is set-up from external function
 72+  59B5              ; input HL=pointer to mask data
 73+  59B5              ; input HL'=pointer to character data
 74+  59B5              ; input DE=output buffer containing background data
 75+  59B5              ; input BC=DE+8
 76+  59B5              ; input A=number of characters to process
 77+  59B5              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  59B5              SHIFT58:
 79+  59B5 08           	EX AF, AF'
 80+  59B6 7E           	LD A, (HL) ; get mask
 81+  59B7 D9           	EXX
 82+  59B8 57           	LD D, A
 83+  59B9 1E FF        	LD E, #FF
 84+  59BB 37           	SCF
 85+  59BC              .M1:
 86+  59BC 18 FE        	JR .M1 ; this is self-modifying part
 87+  59BE CB 12        	RL D
 88+  59C0 CB 13        	RL E
 89+  59C2 CB 12        	RL D
 90+  59C4 CB 13        	RL E
 91+  59C6 CB 12        	RL D
 92+  59C8 CB 13        	RL E
 93+  59CA
 94+  59CA 46           	LD B, (HL)
 95+  59CB 0E 00        	LD C, 0
 96+  59CD              .M2:
 97+  59CD 18 FE        	JR .M2 ; also self-modifying part
 98+  59CF CB 20        	SLA B
 99+  59D1 CB 11        	RL C
100+  59D3 CB 20        	SLA B
101+  59D5 CB 11        	RL C
102+  59D7 CB 20        	SLA B
103+  59D9 CB 11        	RL C
104+  59DB
105+  59DB D9           	EXX
106+  59DC 1A           	LD A, (DE) ; background
107+  59DD D9           	EXX
108+  59DE A3           	AND E
109+  59DF B1           	OR C
110+  59E0 D9           	EXX
111+  59E1 12           	LD (DE), A
112+  59E2
113+  59E2 0A           	LD A, (BC)
114+  59E3 D9           	EXX
115+  59E4 A2           	AND D
116+  59E5 B0           	OR B
117+  59E6 23           	INC HL
118+  59E7 D9           	EXX
119+  59E8 02           	LD (BC), A
120+  59E9
121+  59E9 23           	INC HL
122+  59EA 13           	INC DE
123+  59EB 03           	INC BC
124+  59EC
125+  59EC 08           	EX AF, AF'
126+  59ED 3D           	DEC A
127+  59EE C2 B5 59     	JP NZ, SHIFT58
128+  59F1 C9           	RET
129+  59F2              ; *******************************************************************************************************
130+  59F2
131+  59F2              ; *******************************************************************************************************
132+  59F2              ; routine that shifts one row of characters
133+  59F2              ; contains self-modifying code that is set-up from external function
134+  59F2              ; input HL=pointer to mask data
135+  59F2              ; input HL'=pointer to character data
136+  59F2              ; input DE=output buffer containing background data
137+  59F2              ; input A=number of characters to process
138+  59F2              ; input IX=pointer to structure describing input data
139+  59F2              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  59F2              SHIFT_ROW:
141+  59F2 F5           	PUSH AF
142+  59F3 ED 53 F2 5D  		LD (BLIT_TMP1), DE
143+  59F7 E5           		PUSH HL
144+  59F8 CD 3B 5A     			CALL .ADDYSHIFT
145+  59FB E1           		POP HL
146+  59FC ED 53 F4 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  5A00              .L1:
148+  5A00 3E 08        		LD A, 8
149+  5A02 DD 96 02     		SUB (IX+2) ; y shift
150+  5A05              .CALL1:
151+  5A05 CD 00 00     		CALL 0
152+  5A08 DD 7E 02     		LD A, (IX+2); y shift
153+  5A0B B7           		OR A
154+  5A0C 28 26        		JR Z, .DONE
155+  5A0E ED 5B F2 5D  		LD DE, (BLIT_TMP1)
156+  5A12 E5           		PUSH HL
157+  5A13 CD 49 5A     			CALL .DETONEXTROW
158+  5A16 E1           		POP HL
159+  5A17              .CALL2:
160+  5A17 CD 00 00     		CALL 0
161+  5A1A ED 5B F2 5D  		LD DE, (BLIT_TMP1)
162+  5A1E E5           		PUSH HL
163+  5A1F CD 43 5A     			CALL .ADD8
164+  5A22 E1           		POP HL
165+  5A23 ED 53 F2 5D  		LD (BLIT_TMP1), DE
166+  5A27 ED 5B F4 5D  		LD DE, (BLIT_TMP2)
167+  5A2B E5           		PUSH HL
168+  5A2C CD 43 5A     			CALL .ADD8
169+  5A2F E1           		POP HL
170+  5A30 ED 53 F4 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  5A34              .DONE:
172+  5A34 F1           	POP AF
173+  5A35 3D           	DEC A
174+  5A36 C8           	RET Z
175+  5A37 F5           	PUSH AF
176+  5A38 C3 00 5A     	JP .L1
177+  5A3B              .ADDYSHIFT:
178+  5A3B EB           	EX DE, HL
179+  5A3C 16 00        	LD D, 0
180+  5A3E DD 5E 02     	LD E, (IX+2); y shift
181+  5A41 18 0C        	JR .MOVDEBC
182+  5A43              .ADD8:
183+  5A43 21 08 00     	LD HL, 8
184+  5A46 C3 4F 5A     	JP .MOVDEBC
185+  5A49              .DETONEXTROW:
186+  5A49 DD 6E 06     	LD L, (IX+6)
187+  5A4C DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5A4F              .MOVDEBC:
189+  5A4F 19           	ADD HL, DE
190+  5A50 54           	LD D, H
191+  5A51 5D           	LD E, L
192+  5A52 01 08 00     	LD BC, 8
193+  5A55 09           	ADD HL, BC
194+  5A56 44           	LD B, H
195+  5A57 4D           	LD C, L
196+  5A58 C9           	RET
197+  5A59              ; *******************************************************************************************************
198+  5A59
199+  5A59              ; *******************************************************************************************************
200+  5A59              ; function rotates mask and character data and applies it to background
201+  5A59              ; input IX=pointer to structure describing input data
202+  5A59              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  5A59              ; +2  DW vertical shift count 0-7 (low byte used)
204+  5A59              ; +4  DW background data start;
205+  5A59              ; +6  DW background add to value to next row of background data
206+  5A59              ; +8  DW mask data start;
207+  5A59              ; +10  DW character data start;
208+  5A59              ; +12 DW character&mask add to value to next row of data
209+  5A59              ; +14 DW columns (low byte used)
210+  5A59              ; +16 DW rows (low byte used)
211+  5A59              SHIFT_MERGE_CHARACTER:
212+  5A59 DD 7E 00     	LD A, (IX) ; shift
213+  5A5C FE 05        	CP 5
214+  5A5E 38 25        	JR C, .RIGHT
215+  5A60              	; shifts 5-7, use rotate towards left 1-3
216+  5A60 21 B5 59     	LD HL, SHIFT58
217+  5A63 22 06 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  5A66 22 18 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  5A69 D6 05        	SUB 5
220+  5A6B 28 0D        	JR Z, .L1
221+  5A6D 87           	ADD A, A
222+  5A6E 87           	ADD A, A
223+  5A6F 67           	LD H, A
224+  5A70 2E 18        	LD L, #18 ; JR opcode
225+  5A72 22 BC 59     	LD (SHIFT58.M1), HL
226+  5A75 22 CD 59     	LD (SHIFT58.M2), HL
227+  5A78 18 32        	JR .DO
228+  5A7A              .L1:
229+  5A7A 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  5A7D 22 BC 59     	LD (SHIFT58.M1), HL
231+  5A80 22 CD 59     	LD (SHIFT58.M2), HL
232+  5A83 18 27        	JR .DO
233+  5A85              .RIGHT:
234+  5A85              	; shifts 0-4, rotate towards right
235+  5A85 21 70 59     	LD HL, SHIFT04
236+  5A88 22 06 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  5A8B 22 18 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  5A8E FE 04        	CP 4
239+  5A90 28 11        	JR Z, .R1
240+  5A92 D6 04        	SUB 4
241+  5A94 ED 44        	NEG
242+  5A96 87           	ADD A, A
243+  5A97 87           	ADD A, A
244+  5A98 67           	LD H, A
245+  5A99 2E 18        	LD L, #18 ; JR opcode
246+  5A9B 22 77 59     	LD (SHIFT04.M1), HL
247+  5A9E 22 8C 59     	LD (SHIFT04.M2), HL
248+  5AA1 18 09        	JR .DO
249+  5AA3              .R1:
250+  5AA3 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  5AA6 22 77 59     	LD (SHIFT04.M1), HL
252+  5AA9 22 8C 59     	LD (SHIFT04.M2), HL
253+  5AAC              .DO:
254+  5AAC DD 46 10     	LD B, (IX+16) ; rows
255+  5AAF DD 6E 08     	LD L, (IX+8)
256+  5AB2 DD 66 09     	LD H, (IX+9) ; mask data
257+  5AB5 DD 5E 04     	LD E, (IX+4)
258+  5AB8 DD 56 05     	LD D, (IX+5) ; background data
259+  5ABB D9           	EXX
260+  5ABC DD 6E 0A     	LD L, (IX+10)
261+  5ABF DD 66 0B     	LD H, (IX+11) ; character data
262+  5AC2 D9           	EXX
263+  5AC3              .LOOP:
264+  5AC3 C5           	PUSH BC
265+  5AC4 E5           		PUSH HL
266+  5AC5 D5           			PUSH DE
267+  5AC6 D9           				EXX
268+  5AC7 E5           				PUSH HL
269+  5AC8 D9           					EXX
270+  5AC9 DD 7E 0E     					LD A, (IX+14) ; columns
271+  5ACC              .CALL:
272+  5ACC CD F2 59     					CALL SHIFT_ROW
273+  5ACF E1           				POP HL
274+  5AD0 DD 5E 0C     				LD E, (IX+12)
275+  5AD3 DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  5AD6 19           				ADD HL, DE
277+  5AD7 D9           				EXX
278+  5AD8 E1           			POP HL
279+  5AD9 DD 5E 06     			LD E, (IX+6)
280+  5ADC DD 56 07     			LD D, (IX+7) ; background to next row
281+  5ADF 19           			ADD HL, DE
282+  5AE0 EB           			EX DE, HL
283+  5AE1 E1           		POP HL
284+  5AE2 DD 4E 0C     		LD C, (IX+12)
285+  5AE5 DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  5AE8 09           		ADD HL, BC
287+  5AE9 C1           	POP BC
288+  5AEA 10 D7        	DJNZ .LOOP
289+  5AEC C9           	RET
290+  5AED              ; *******************************************************************************************************
291+  5AED
292+  5AED               IFNDEF CMDS_WITH_PARAMETERS
293+  5AED ~            ; *******************************************************************************************************
294+  5AED ~            ; function to handle CALL BLIT basic extension
295+  5AED ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  5AED ~            ; fuses with background data and applies vertical shift too
297+  5AED ~            ; BLIT ( INT request_data_ptr )
298+  5AED ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  5AED ~            ; will put ram in page 0 also, page 1 is already there
300+  5AED ~            BLIT:
301+  5AED ~            	; opening (
302+  5AED ~            	CALL CHKCHAR
303+  5AED ~            	DB '('
304+  5AED ~            	; get pointer to request struct
305+  5AED ~            	LD IX, FRMQNT
306+  5AED ~            	CALL CALBAS
307+  5AED ~            	PUSH DE
308+  5AED ~            	; ending )
309+  5AED ~            	CALL CHKCHAR
310+  5AED ~            	DB ')'
311+  5AED ~
312+  5AED ~            	POP IX ; pointer to request struct
313+  5AED ~
314+  5AED ~            	PUSH HL ; save position in BASIC buffer
315+  5AED ~
316+  5AED ~            	LD IY, .RET
317+  5AED ~            	JP ENABLE_PAGE0
318+  5AED ~            .RET:
319+  5AED ~            	EI
320+  5AED ~            	CALL SHIFT_MERGE_CHARACTER
321+  5AED ~
322+  5AED ~                POP DE
323+  5AED ~                POP BC
324+  5AED ~                CALL RESTORE_PAGE_INFO
325+  5AED ~
326+  5AED ~            	POP HL
327+  5AED ~            	RET
328+  5AED ~            ; *******************************************************************************************************
329+  5AED               ENDIF
330+  5AED
331+  5AED               IFDEF CMDS_WITH_PARAMETERS
332+  5AED              ; *******************************************************************************************************
333+  5AED              ; function to handle CALL BLIT basic extension
334+  5AED              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  5AED              ; fuses with background data and applies vertical shift too
336+  5AED              ; in form without pointers
337+  5AED              ; BLIT ( INT x,
338+  5AED              ;		 INT y,
339+  5AED              ;		 INT char_data_pointer,
340+  5AED              ;		 INT mask_data_pointer,
341+  5AED              ;		 INT width (in characters),
342+  5AED              ;		 INT height (in characters),
343+  5AED              ;		 INT background_pointer (top left),
344+  5AED              ;		 INT background_width (in characters),
345+  5AED              ;		 INT background_height (in characters))
346+  5AED              ; will put ram in page 0 also, page 1 is already there
347+  5AED              BLIT:
348+  5AED              	; opening (
349+  5AED CD BF 60     	CALL CHKCHAR
350+  5AF0 28           	DB '('
351+  5AF1              	; get x coordinate
352+  5AF1 DD 21 2F 54  	LD IX, FRMQNT
353+  5AF5 CD 59 01     	CALL CALBAS
354+  5AF8 7B           	LD A, E
355+  5AF9 E6 07        	AND 7
356+  5AFB 32 F6 5D     	LD (BLIT_STRUCT+0), A
357+  5AFE CD DB 5B     	CALL .DAdiv8
358+  5B01 32 F2 5D     	LD (BLIT_TMP+0),A
359+  5B04              	; comma
360+  5B04 CD BF 60     	CALL CHKCHAR
361+  5B07 2C           	DB ','
362+  5B08              	; get y coordinate
363+  5B08 DD 21 2F 54  	LD IX, FRMQNT
364+  5B0C CD 59 01     	CALL CALBAS
365+  5B0F 7B           	LD A, E
366+  5B10 E6 07        	AND 7
367+  5B12 32 F8 5D     	LD (BLIT_STRUCT+2), A
368+  5B15 CD DB 5B     	CALL .DAdiv8
369+  5B18 32 F3 5D     	LD (BLIT_TMP+1),A
370+  5B1B              	; comma
371+  5B1B CD BF 60     	CALL CHKCHAR
372+  5B1E 2C           	DB ','
373+  5B1F              	; get char data pointer
374+  5B1F DD 21 2F 54  	LD IX, FRMQNT
375+  5B23 CD 59 01     	CALL CALBAS
376+  5B26 ED 53 00 5E  	LD (BLIT_STRUCT+10), DE
377+  5B2A              	; comma
378+  5B2A CD BF 60     	CALL CHKCHAR
379+  5B2D 2C           	DB ','
380+  5B2E              	; get mask data pointer
381+  5B2E DD 21 2F 54  	LD IX, FRMQNT
382+  5B32 CD 59 01     	CALL CALBAS
383+  5B35 ED 53 FE 5D  	LD (BLIT_STRUCT+8), DE
384+  5B39              	; comma
385+  5B39 CD BF 60     	CALL CHKCHAR
386+  5B3C 2C           	DB ','
387+  5B3D              	; get width
388+  5B3D DD 21 2F 54  	LD IX, FRMQNT
389+  5B41 CD 59 01     	CALL CALBAS
390+  5B44 7B           	LD A, E
391+  5B45 32 04 5E     	LD (BLIT_STRUCT+14), A
392+  5B48              	; comma
393+  5B48 CD BF 60     	CALL CHKCHAR
394+  5B4B 2C           	DB ','
395+  5B4C              	; get height
396+  5B4C DD 21 2F 54  	LD IX, FRMQNT
397+  5B50 CD 59 01     	CALL CALBAS
398+  5B53 7B           	LD A, E
399+  5B54 32 06 5E     	LD (BLIT_STRUCT+16), A
400+  5B57              	; comma
401+  5B57 CD BF 60     	CALL CHKCHAR
402+  5B5A 2C           	DB ','
403+  5B5B              	; get background pointer
404+  5B5B DD 21 2F 54  	LD IX, FRMQNT
405+  5B5F CD 59 01     	CALL CALBAS
406+  5B62 ED 53 FA 5D  	LD (BLIT_STRUCT+4), DE
407+  5B66              	; comma
408+  5B66 CD BF 60     	CALL CHKCHAR
409+  5B69 2C           	DB ','
410+  5B6A              	; get background width
411+  5B6A DD 21 2F 54  	LD IX, FRMQNT
412+  5B6E CD 59 01     	CALL CALBAS
413+  5B71 7B           	LD A, E
414+  5B72 32 F4 5D     	LD (BLIT_TMP+2), A
415+  5B75              	; comma
416+  5B75 CD BF 60     	CALL CHKCHAR
417+  5B78 2C           	DB ','
418+  5B79              	; get background height
419+  5B79 DD 21 2F 54  	LD IX, FRMQNT
420+  5B7D CD 59 01     	CALL CALBAS
421+  5B80 7B           	LD A, E
422+  5B81 32 F5 5D     	LD (BLIT_TMP+3), A
423+  5B84              	; ending )
424+  5B84 CD BF 60     	CALL CHKCHAR
425+  5B87 29           	DB ')'
426+  5B88
427+  5B88 E5           	PUSH HL ; save position in BASIC buffer
428+  5B89
429+  5B89              	; calculate char&mask add to value
430+  5B89 26 00        	LD H, 0
431+  5B8B 3A 04 5E     	LD A, (BLIT_STRUCT+14)
432+  5B8E 6F           	LD L, A
433+  5B8F CD AE 5F     	CALL HLx8
434+  5B92 22 02 5E     	LD (BLIT_STRUCT+12), HL
435+  5B95              	; calculate background add to value
436+  5B95 26 00        	LD H, 0
437+  5B97 3A F4 5D     	LD A, (BLIT_TMP+2)
438+  5B9A 6F           	LD L, A
439+  5B9B CD AE 5F     	CALL HLx8
440+  5B9E 22 FC 5D     	LD (BLIT_STRUCT+6), HL
441+  5BA1              	; calculate pointer to background location
442+  5BA1 21 00 00     	LD HL, 0
443+  5BA4 3A F3 5D     	LD A,(BLIT_TMP+1)
444+  5BA7 B7           	OR A
445+  5BA8 28 08        	JR Z, .L1
446+  5BAA 47           	LD B,A
447+  5BAB ED 5B FC 5D  	LD DE,(BLIT_STRUCT+6)
448+  5BAF              .L0:
449+  5BAF 19           	ADD HL, DE
450+  5BB0 10 FD        	DJNZ .L0
451+  5BB2              .L1:
452+  5BB2 EB           	EX DE,HL
453+  5BB3 26 00        	LD H,0
454+  5BB5 3A F2 5D     	LD A,(BLIT_TMP+0)
455+  5BB8 6F           	LD L,A
456+  5BB9 CD AE 5F     	CALL HLx8
457+  5BBC 19           	ADD HL,DE
458+  5BBD ED 5B FA 5D  	LD DE,(BLIT_STRUCT+4)
459+  5BC1 19           	ADD HL,DE
460+  5BC2 22 FA 5D     	LD (BLIT_STRUCT+4),HL
461+  5BC5
462+  5BC5 FD 21 CC 5B  	LD IY, .RET
463+  5BC9 C3 72 60     	JP ENABLE_PAGE0
464+  5BCC              .RET:
465+  5BCC FB           	EI
466+  5BCD DD 21 F6 5D  	LD IX, BLIT_STRUCT
467+  5BD1 CD 59 5A     	CALL SHIFT_MERGE_CHARACTER
468+  5BD4
469+  5BD4 D1               POP DE
470+  5BD5 C1               POP BC
471+  5BD6 CD E9 5F         CALL RESTORE_PAGE_INFO
472+  5BD9
473+  5BD9 E1           	POP HL
474+  5BDA C9           	RET
475+  5BDB              .DAdiv8:
476+  5BDB 7B           	LD A,E
477+  5BDC CB 2A        	SRA D
478+  5BDE CB 1F            RR  A
479+  5BE0 CB 2A            SRA D
480+  5BE2 CB 1F            RR  A
481+  5BE4 CB 2A            SRA D
482+  5BE6 CB 1F            RR  A
483+  5BE8 C9           	RET
484+  5BE9              ; *******************************************************************************************************
485+  5BE9               ENDIF
# file closed: asm\BLIT.asm
146   5BE9               ENDIF
147   5BE9
148   5BE9               IF (TILE_CMDS == 1)
149   5BE9               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5BE9              ; *******************************************************************************************************
  2+  5BE9              ; generic function to implement tiling
  3+  5BE9              ; should be modified to call appropriate function for memory or vram
  4+  5BE9              ; input IX=pointer to following structure
  5+  5BE9              ; +00 tile_data_ptr
  6+  5BE9              ; +02 tile_rows
  7+  5BE9              ; +04 tile_columns
  8+  5BE9              ; +06 destination_address
  9+  5BE9              ; +08 dest_to_next_row_add_to_value
 10+  5BE9              ; +10 num_horizontal_tiles
 11+  5BE9              ; +12 num_vertical_tiles
 12+  5BE9              ; modifies AF, BC, DE, HL
 13+  5BE9              TILE:
 14+  5BE9 DD 6E 06     	LD L, (IX+6)
 15+  5BEC DD 66 07     	LD H, (IX+7) ; destination address
 16+  5BEF 22 F2 5D     	LD (TILETMP1), HL
 17+  5BF2 DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5BF5              .L1:
 19+  5BF5 C5           	PUSH BC
 20+  5BF6 DD 6E 00     		LD L, (IX+0)
 21+  5BF9 DD 66 01     		LD H, (IX+1) ; tile address
 22+  5BFC 22 F4 5D     		LD (TILETMP2), HL
 23+  5BFF DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5C02              .L2:
 25+  5C02 C5           		PUSH BC
 26+  5C03 CD 00 00     .CALL1:		CALL 0
 27+  5C06 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5C09              .L3:
 29+  5C09 C5           			PUSH BC
 30+  5C0A 2A F4 5D     				LD HL, (TILETMP2)
 31+  5C0D DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5C10              .L4:
 33+  5C10 C5           				PUSH BC
 34+  5C11              .CALL2:
 35+  5C11 CD 00 00     					CALL 0
 36+  5C14 C1           				POP BC
 37+  5C15 10 F9        				DJNZ .L4
 38+  5C17 C1           			POP BC
 39+  5C18 10 EF        			DJNZ .L3
 40+  5C1A 22 F4 5D     			LD (TILETMP2), HL
 41+  5C1D 2A F2 5D     			LD HL, (TILETMP1)
 42+  5C20 DD 5E 08     			LD E, (IX+8)
 43+  5C23 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5C26 19           			ADD HL, DE
 45+  5C27 22 F2 5D     			LD (TILETMP1), HL
 46+  5C2A C1           		POP BC
 47+  5C2B 10 D5        		DJNZ .L2
 48+  5C2D C1           	POP BC
 49+  5C2E 10 C5        	DJNZ .L1
 50+  5C30 C9           	RET
 51+  5C31              ; *******************************************************************************************************
 52+  5C31
 53+  5C31               IFNDEF CMDS_WITH_PARAMETERS
 54+  5C31 ~            ; *******************************************************************************************************
 55+  5C31 ~            ; function to handle CALL TILERAM basic extension
 56+  5C31 ~            ; fills memory with tiles
 57+  5C31 ~            ; TILERAM ( INT request_data_ptr )
 58+  5C31 ~            ; request_data_ptr described in TILE
 59+  5C31 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5C31 ~            TILERAM:
 61+  5C31 ~            	; opening (
 62+  5C31 ~            	CALL CHKCHAR
 63+  5C31 ~            	DB '('
 64+  5C31 ~            	; get pointer to request struct
 65+  5C31 ~            	LD IX, FRMQNT
 66+  5C31 ~            	CALL CALBAS
 67+  5C31 ~            	PUSH DE
 68+  5C31 ~            	; ending )
 69+  5C31 ~            	CALL CHKCHAR
 70+  5C31 ~            	DB ')'
 71+  5C31 ~
 72+  5C31 ~            	POP IX ; pointer to request struct
 73+  5C31 ~
 74+  5C31 ~            	PUSH HL ; save position in BASIC buffer
 75+  5C31 ~
 76+  5C31 ~            	LD IY, .RET
 77+  5C31 ~            	JP ENABLE_PAGE0
 78+  5C31 ~            .RET:
 79+  5C31 ~            	EI
 80+  5C31 ~            	; set RAM functions to call
 81+  5C31 ~            	LD HL, .TILECOPY
 82+  5C31 ~            	LD (TILE.CALL2+1), HL
 83+  5C31 ~            	LD HL, .SETDESTROW
 84+  5C31 ~            	LD (TILE.CALL1+1), HL
 85+  5C31 ~            	LD A,1
 86+  5C31 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5C31 ~            	CALL TILE
 88+  5C31 ~            	XOR A
 89+  5C31 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5C31 ~
 91+  5C31 ~                POP DE
 92+  5C31 ~                POP BC
 93+  5C31 ~                CALL RESTORE_PAGE_INFO
 94+  5C31 ~
 95+  5C31 ~            	POP HL
 96+  5C31 ~            	RET
 97+  5C31 ~            .TILECOPY:
 98+  5C31 ~            	.8 LDI
 99+  5C31 ~            	RET
100+  5C31 ~            .SETDESTROW:
101+  5C31 ~            	LD DE, (TILETMP1)
102+  5C31 ~            	RET
103+  5C31 ~            ; *******************************************************************************************************
104+  5C31               ENDIF
105+  5C31
106+  5C31               IFDEF CMDS_WITH_PARAMETERS
107+  5C31              ; *******************************************************************************************************
108+  5C31              ; function to handle CALL TILERAM basic extension
109+  5C31              ; fills memory with tiles
110+  5C31              ; TILERAM ( INT tile_data_pointer,
111+  5C31              ;			INT tile_columns,
112+  5C31              ;			INT tile_rows,
113+  5C31              ;			INT destination_pointer,
114+  5C31              ;			INT destination_columns,
115+  5C31              ;			INT destination_rows,
116+  5C31              ;			INT destination_begin_column,
117+  5C31              ;			INT destination_begin_row,
118+  5C31              ;			INT number_of_tiles_horizontally,
119+  5C31              ;			INT	number_of_tiles_vertically )
120+  5C31              ; will put ram in page 0 also, page 1 is already there
121+  5C31              TILERAM:
122+  5C31              	; opening (
123+  5C31 CD BF 60     	CALL CHKCHAR
124+  5C34 28           	DB '('
125+  5C35              	; get tile data pointer coordinate
126+  5C35 DD 21 2F 54  	LD IX, FRMQNT
127+  5C39 CD 59 01     	CALL CALBAS
128+  5C3C ED 53 F6 5D  	LD (BLIT_STRUCT+0), DE
129+  5C40              	; comma
130+  5C40 CD BF 60     	CALL CHKCHAR
131+  5C43 2C           	DB ','
132+  5C44              	; get tile columns
133+  5C44 DD 21 2F 54  	LD IX, FRMQNT
134+  5C48 CD 59 01     	CALL CALBAS
135+  5C4B ED 53 FA 5D  	LD (BLIT_STRUCT+4), DE
136+  5C4F              	; comma
137+  5C4F CD BF 60     	CALL CHKCHAR
138+  5C52 2C           	DB ','
139+  5C53              	; get tile columns
140+  5C53 DD 21 2F 54  	LD IX, FRMQNT
141+  5C57 CD 59 01     	CALL CALBAS
142+  5C5A ED 53 F8 5D  	LD (BLIT_STRUCT+2), DE
143+  5C5E              	; comma
144+  5C5E CD BF 60     	CALL CHKCHAR
145+  5C61 2C           	DB ','
146+  5C62              	; get destintion pointer
147+  5C62 DD 21 2F 54  	LD IX, FRMQNT
148+  5C66 CD 59 01     	CALL CALBAS
149+  5C69 ED 53 FC 5D  	LD (BLIT_STRUCT+6), DE
150+  5C6D              	; comma
151+  5C6D CD BF 60     	CALL CHKCHAR
152+  5C70 2C           	DB ','
153+  5C71              	; get destination columns
154+  5C71 DD 21 2F 54  	LD IX, FRMQNT
155+  5C75 CD 59 01     	CALL CALBAS
156+  5C78 7B           	LD A, E
157+  5C79 32 F2 5D     	LD (BLIT_TMP+0), A
158+  5C7C              	; comma
159+  5C7C CD BF 60     	CALL CHKCHAR
160+  5C7F 2C           	DB ','
161+  5C80              	; get destination rows
162+  5C80 DD 21 2F 54  	LD IX, FRMQNT
163+  5C84 CD 59 01     	CALL CALBAS
164+  5C87 7B           	LD A, E
165+  5C88 32 F3 5D     	LD (BLIT_TMP+1), A
166+  5C8B              	; comma
167+  5C8B CD BF 60     	CALL CHKCHAR
168+  5C8E 2C           	DB ','
169+  5C8F              	; get destination begin column
170+  5C8F DD 21 2F 54  	LD IX, FRMQNT
171+  5C93 CD 59 01     	CALL CALBAS
172+  5C96 7B           	LD A, E
173+  5C97 32 F4 5D     	LD (BLIT_TMP+2), A
174+  5C9A              	; comma
175+  5C9A CD BF 60     	CALL CHKCHAR
176+  5C9D 2C           	DB ','
177+  5C9E              	; get destination begin row
178+  5C9E DD 21 2F 54  	LD IX, FRMQNT
179+  5CA2 CD 59 01     	CALL CALBAS
180+  5CA5 7B           	LD A, E
181+  5CA6 32 F5 5D     	LD (BLIT_TMP+3), A
182+  5CA9              	; comma
183+  5CA9 CD BF 60     	CALL CHKCHAR
184+  5CAC 2C           	DB ','
185+  5CAD              	; get number of tiles horizontally
186+  5CAD DD 21 2F 54  	LD IX, FRMQNT
187+  5CB1 CD 59 01     	CALL CALBAS
188+  5CB4 ED 53 00 5E  	LD (BLIT_STRUCT+10), DE
189+  5CB8              	; comma
190+  5CB8 CD BF 60     	CALL CHKCHAR
191+  5CBB 2C           	DB ','
192+  5CBC              	; get number of tiles vertically
193+  5CBC DD 21 2F 54  	LD IX, FRMQNT
194+  5CC0 CD 59 01     	CALL CALBAS
195+  5CC3 ED 53 02 5E  	LD (BLIT_STRUCT+12), DE
196+  5CC7              	; ending )
197+  5CC7 CD BF 60     	CALL CHKCHAR
198+  5CCA 29           	DB ')'
199+  5CCB
200+  5CCB E5           	PUSH HL ; save position in BASIC buffer
201+  5CCC
202+  5CCC              	; calculate destination add to value
203+  5CCC 26 00        	LD H, 0
204+  5CCE 3A F2 5D     	LD A, (BLIT_TMP+0)
205+  5CD1 6F           	LD L, A
206+  5CD2 CD AE 5F     	CALL HLx8
207+  5CD5 22 FE 5D     	LD (BLIT_STRUCT+8), HL
208+  5CD8              	; calculate pointer to background location
209+  5CD8 21 00 00     	LD HL, 0
210+  5CDB 3A F5 5D     	LD A,(BLIT_TMP+3)
211+  5CDE B7           	OR A
212+  5CDF 28 08        	JR Z, .L1
213+  5CE1 47           	LD B,A
214+  5CE2 ED 5B FE 5D  	LD DE,(BLIT_STRUCT+8)
215+  5CE6              .L0:
216+  5CE6 19           	ADD HL, DE
217+  5CE7 10 FD        	DJNZ .L0
218+  5CE9              .L1:
219+  5CE9 EB           	EX DE,HL
220+  5CEA 26 00        	LD H,0
221+  5CEC 3A F4 5D     	LD A,(BLIT_TMP+2)
222+  5CEF 6F           	LD L,A
223+  5CF0 CD AE 5F     	CALL HLx8
224+  5CF3 19           	ADD HL,DE
225+  5CF4 ED 5B FC 5D  	LD DE,(BLIT_STRUCT+6)
226+  5CF8 19           	ADD HL,DE
227+  5CF9 22 FC 5D     	LD (BLIT_STRUCT+6),HL
228+  5CFC
229+  5CFC FD 21 03 5D  	LD IY, .RET
230+  5D00 C3 72 60     	JP ENABLE_PAGE0
231+  5D03              .RET:
232+  5D03 FB           	EI
233+  5D04              	; set RAM functions to call
234+  5D04 21 1E 5D     	LD HL, .TILECOPY
235+  5D07 22 12 5C     	LD (TILE.CALL2+1), HL
236+  5D0A 21 2F 5D     	LD HL, .SETDESTROW
237+  5D0D 22 04 5C     	LD (TILE.CALL1+1), HL
238+  5D10 DD 21 F6 5D  	LD IX,BLIT_STRUCT
239+  5D14 CD E9 5B     	CALL TILE
240+  5D17
241+  5D17 D1               POP DE
242+  5D18 C1               POP BC
243+  5D19 CD E9 5F         CALL RESTORE_PAGE_INFO
244+  5D1C
245+  5D1C E1           	POP HL
246+  5D1D C9           	RET
247+  5D1E              .TILECOPY:
248+  5D1E ED A0       > LDI
248+  5D20 ED A0       > LDI
248+  5D22 ED A0       > LDI
248+  5D24 ED A0       > LDI
248+  5D26 ED A0       > LDI
248+  5D28 ED A0       > LDI
248+  5D2A ED A0       > LDI
248+  5D2C ED A0       > LDI
249+  5D2E C9           	RET
250+  5D2F              .SETDESTROW:
251+  5D2F ED 5B F2 5D  	LD DE, (TILETMP1)
252+  5D33 C9           	RET
253+  5D34              ; *******************************************************************************************************
254+  5D34               ENDIF
255+  5D34
256+  5D34               IFDEF CMDS_WITH_PARAMETERS
257+  5D34              ; *******************************************************************************************************
258+  5D34              ; function to handle CALL TILEVRM basic extension
259+  5D34              ; fills vram with tiles
260+  5D34              ; TILEVRM ( INT tile_data_pointer,
261+  5D34              ;			INT tile_columns,
262+  5D34              ;			INT tile_rows,
263+  5D34              ;			INT destination_begin_column,
264+  5D34              ;			INT destination_begin_row,
265+  5D34              ;			INT number_of_tiles_horizontally,
266+  5D34              ;			INT	number_of_tiles_vertically )
267+  5D34              ; will put ram in page 0 also, page 1 is already there
268+  5D34              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5D34              TILEVRM:
270+  5D34              	; opening (
271+  5D34 CD BF 60     	CALL CHKCHAR
272+  5D37 28           	DB '('
273+  5D38              	; get tile data pointer coordinate
274+  5D38 DD 21 2F 54  	LD IX, FRMQNT
275+  5D3C CD 59 01     	CALL CALBAS
276+  5D3F ED 53 F6 5D  	LD (BLIT_STRUCT+0), DE
277+  5D43              	; comma
278+  5D43 CD BF 60     	CALL CHKCHAR
279+  5D46 2C           	DB ','
280+  5D47              	; get tile columns
281+  5D47 DD 21 2F 54  	LD IX, FRMQNT
282+  5D4B CD 59 01     	CALL CALBAS
283+  5D4E ED 53 FA 5D  	LD (BLIT_STRUCT+4), DE
284+  5D52              	; comma
285+  5D52 CD BF 60     	CALL CHKCHAR
286+  5D55 2C           	DB ','
287+  5D56              	; get tile columns
288+  5D56 DD 21 2F 54  	LD IX, FRMQNT
289+  5D5A CD 59 01     	CALL CALBAS
290+  5D5D ED 53 F8 5D  	LD (BLIT_STRUCT+2), DE
291+  5D61              	; comma
292+  5D61 CD BF 60     	CALL CHKCHAR
293+  5D64 2C           	DB ','
294+  5D65              	; get destination begin column
295+  5D65 DD 21 2F 54  	LD IX, FRMQNT
296+  5D69 CD 59 01     	CALL CALBAS
297+  5D6C 7B           	LD A, E
298+  5D6D 32 F4 5D     	LD (BLIT_TMP+2), A
299+  5D70              	; comma
300+  5D70 CD BF 60     	CALL CHKCHAR
301+  5D73 2C           	DB ','
302+  5D74              	; get destination begin row
303+  5D74 DD 21 2F 54  	LD IX, FRMQNT
304+  5D78 CD 59 01     	CALL CALBAS
305+  5D7B 7B           	LD A, E
306+  5D7C 32 F5 5D     	LD (BLIT_TMP+3), A
307+  5D7F              	; comma
308+  5D7F CD BF 60     	CALL CHKCHAR
309+  5D82 2C           	DB ','
310+  5D83              	; get number of tiles horizontally
311+  5D83 DD 21 2F 54  	LD IX, FRMQNT
312+  5D87 CD 59 01     	CALL CALBAS
313+  5D8A ED 53 00 5E  	LD (BLIT_STRUCT+10), DE
314+  5D8E              	; comma
315+  5D8E CD BF 60     	CALL CHKCHAR
316+  5D91 2C           	DB ','
317+  5D92              	; get number of tiles vertically
318+  5D92 DD 21 2F 54  	LD IX, FRMQNT
319+  5D96 CD 59 01     	CALL CALBAS
320+  5D99 ED 53 02 5E  	LD (BLIT_STRUCT+12), DE
321+  5D9D              	; ending )
322+  5D9D CD BF 60     	CALL CHKCHAR
323+  5DA0 29           	DB ')'
324+  5DA1
325+  5DA1 E5           	PUSH HL ; save position in BASIC buffer
326+  5DA2
327+  5DA2              	; calculate destination add to value
328+  5DA2 21 00 01     	LD HL, 256
329+  5DA5 22 FE 5D     	LD (BLIT_STRUCT+8), HL
330+  5DA8              	; calculate pointer to background location
331+  5DA8 3A F5 5D     	LD A,(BLIT_TMP+3)
332+  5DAB 67           	LD H,A
333+  5DAC 2E 00        	LD L,0
334+  5DAE EB           	EX DE,HL
335+  5DAF 26 00        	LD H,0
336+  5DB1 3A F4 5D     	LD A,(BLIT_TMP+2)
337+  5DB4 6F           	LD L,A
338+  5DB5 CD AE 5F     	CALL HLx8
339+  5DB8 19           	ADD HL,DE
340+  5DB9 ED 5B CB F3  	LD DE,(GRPCGP)
341+  5DBD 19           	ADD HL,DE
342+  5DBE 22 FC 5D     	LD (BLIT_STRUCT+6),HL
343+  5DC1
344+  5DC1 FD 21 C8 5D  	LD IY, .RET
345+  5DC5 C3 72 60     	JP ENABLE_PAGE0
346+  5DC8              .RET:
347+  5DC8 FB           	EI
348+  5DC9              	; set RAM functions to call
349+  5DC9 21 E3 5D     	LD HL, .TILECOPY
350+  5DCC 22 12 5C     	LD (TILE.CALL2+1), HL
351+  5DCF 21 E9 5D     	LD HL, .SETDESTROW
352+  5DD2 22 04 5C     	LD (TILE.CALL1+1), HL
353+  5DD5 DD 21 F6 5D  	LD IX,BLIT_STRUCT
354+  5DD9 CD E9 5B     	CALL TILE
355+  5DDC
356+  5DDC D1               POP DE
357+  5DDD C1               POP BC
358+  5DDE CD E9 5F         CALL RESTORE_PAGE_INFO
359+  5DE1
360+  5DE1 E1           	POP HL
361+  5DE2 C9           	RET
362+  5DE3              .TILECOPY:
363+  5DE3 01 98 08     	LD BC, #0898
364+  5DE6 C3 A6 5F     	JP BBYTECOPY_NO_C
365+  5DE9              .SETDESTROW:
366+  5DE9 2A F2 5D     	LD HL, (TILETMP1)
367+  5DEC F3           	DI
368+  5DED CD 99 5F     	CALL SETWRT_LOCAL
369+  5DF0 FB           	EI
370+  5DF1 C9           	RET
371+  5DF2              ; *******************************************************************************************************
372+  5DF2               ENDIF
373+  5DF2
374+  5DF2               IFNDEF CMDS_WITH_PARAMETERS
375+  5DF2 ~            ; *******************************************************************************************************
376+  5DF2 ~            ; function to handle CALL TILEVRM basic extension
377+  5DF2 ~            ; fills vram with tiles
378+  5DF2 ~            ; TILEVRM ( INT request_data_ptr )
379+  5DF2 ~            ; request_data_ptr described in TILE
380+  5DF2 ~            ; will put ram in page 0 also, page 1 is already there
381+  5DF2 ~            TILEVRM:
382+  5DF2 ~            	; opening (
383+  5DF2 ~            	CALL CHKCHAR
384+  5DF2 ~            	DB '('
385+  5DF2 ~            	; get pointer to request struct
386+  5DF2 ~            	LD IX, FRMQNT
387+  5DF2 ~            	CALL CALBAS
388+  5DF2 ~            	PUSH DE
389+  5DF2 ~            	; ending )
390+  5DF2 ~            	CALL CHKCHAR
391+  5DF2 ~            	DB ')'
392+  5DF2 ~
393+  5DF2 ~            	POP IX ; pointer to request struct
394+  5DF2 ~
395+  5DF2 ~            	PUSH HL ; save position in BASIC buffer
396+  5DF2 ~
397+  5DF2 ~            	LD IY, .RET
398+  5DF2 ~            	JP ENABLE_PAGE0
399+  5DF2 ~            .RET:
400+  5DF2 ~            	EI
401+  5DF2 ~            	; set RAM functions to call
402+  5DF2 ~            	LD HL, .TILECOPY
403+  5DF2 ~            	LD (TILE.CALL2+1), HL
404+  5DF2 ~            	LD HL, .SETDESTROW
405+  5DF2 ~            	LD (TILE.CALL1+1), HL
406+  5DF2 ~            	CALL TILE
407+  5DF2 ~
408+  5DF2 ~                POP DE
409+  5DF2 ~                POP BC
410+  5DF2 ~                CALL RESTORE_PAGE_INFO
411+  5DF2 ~
412+  5DF2 ~            	POP HL
413+  5DF2 ~            	RET
414+  5DF2 ~            .TILECOPY:
415+  5DF2 ~            	LD BC, #0898
416+  5DF2 ~            	JP BBYTECOPY_NO_C
417+  5DF2 ~            .SETDESTROW:
418+  5DF2 ~            	LD HL, (TILETMP1)
419+  5DF2 ~            	DI
420+  5DF2 ~            	CALL SETWRT_LOCAL
421+  5DF2 ~            	EI
422+  5DF2 ~            	RET
423+  5DF2 ~            ; *******************************************************************************************************
424+  5DF2               ENDIF
# file closed: asm\TILE.asm
150   5DF2               ENDIF
151   5DF2
152   5DF2              ; temp variables for BLIT, TILE functions
153   5DF2               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
154   5DF2              BLIT_TMP:
155   5DF2              TILETMP1:
156   5DF2              BLIT_TMP1:
157   5DF2 00 00         DW 0
158   5DF4              TILETMP2:
159   5DF4              BLIT_TMP2:
160   5DF4 00 00         DW 0
161   5DF6                IFDEF CMDS_WITH_PARAMETERS
162   5DF6              BLIT_STRUCT:
163   5DF6 00 00 00...   DS 17
164   5DFA                ENDIF
165   5DFA               ENDIF
166   5E07
167   5E07               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
168   5E07              VRAM_UPDATE_IN_PROGRESS:
169   5E07 00            DB 0
170   5E08               ENDIF
171   5E08
172   5E08              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
173   5E08              ; per starting letter, if no commands with this letter, NULL value
174   5E08              CMDS:
175   5E08               IF (ANIM_CMDS == 1)
176   5E08 38 5F        	DW CMDS_A ;
177   5E0A               ELSE
178   5E0A ~                DW 0 ; A
179   5E0A               ENDIF
180   5E0A               IF (BLIT_CMDS + BOX_CMDS > 0)
181   5E0A 03 5F            DW CMDS_B ; B
182   5E0C               ELSE
183   5E0C ~            	DW 0
184   5E0C               ENDIF
185   5E0C 00 00            DW 0 ; C
186   5E0E 00 00            DW 0 ; D
187   5E10 00 00            DW 0 ; E
188   5E12               IF (VRAM_CMDS + RAM_CMDS > 0)
189   5E12 7A 5E            DW CMDS_F; F
190   5E14               ELSE
191   5E14 ~            	DW 0
192   5E14               ENDIF
193   5E14               IF (GENCAL_CMD > 0)
194   5E14 8D 5E            DW CMDS_G; G
195   5E16               ELSE
196   5E16 ~            	DW 0
197   5E16               ENDIF
198   5E16 00 00            DW 0 ; H
199   5E18 00 00            DW 0 ; I
200   5E1A 00 00            DW 0 ; J
201   5E1C 00 00            DW 0 ; K
202   5E1E 00 00            DW 0 ; L
203   5E20               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
204   5E20 3C 5E            DW CMDS_M ; M
205   5E22               ELSE
206   5E22 ~            	DW 0
207   5E22               ENDIF
208   5E22 00 00            DW 0 ; N
209   5E24 00 00            DW 0 ; O
210   5E26 00 00            DW 0 ; P
211   5E28 00 00            DW 0 ; Q
212   5E2A 00 00            DW 0 ; R
213   5E2C               IF (SOUND_CMDS + SPRITE_CMDS > 0)
214   5E2C A1 5E            DW CMDS_S ; S
215   5E2E               ELSE
216   5E2E ~            	DW 0
217   5E2E               ENDIF
218   5E2E               IF (TILE_CMDS > 0)
219   5E2E 23 5F            DW CMDS_T ; T
220   5E30               ELSE
221   5E30 ~            	DW 0
222   5E30               ENDIF
223   5E30 00 00            DW 0 ; U
224   5E32               IF (VRAM_CMDS > 0)
225   5E32 97 5E            DW CMDS_V ; V
226   5E34               ELSE
227   5E34 ~            	DW 0
228   5E34               ENDIF
229   5E34 00 00            DW 0 ; W
230   5E36 00 00            DW 0 ; X
231   5E38 00 00            DW 0 ; Y
232   5E3A 00 00            DW 0 ; Z
233   5E3C
234   5E3C              CMDS_M:
235   5E3C               IF (VRAM_CMDS == 1)
236   5E3C 4D 45 4D 56      DB "MEMVRM", 0
236   5E40 52 4D 00
237   5E43 37 57            DW MEMVRM
238   5E45               ENDIF
239   5E45               IF (RAM_CMDS == 1)
240   5E45 4D 45 4D 43  	DB "MEMCPY", 0
240   5E49 50 59 00
241   5E4C 6D 55        	DW MEMCPY
242   5E4E               ENDIF
243   5E4E               IF (ANIM_CMDS == 1)
244   5E4E 4D 41 58 41  	DB "MAXANIMITEMS",0
244   5E52 4E 49 4D 49
244   5E56 54 45 4D 53
244   5E5A 00
245   5E5B EF 4F        	DW MAXANIMITEMS
246   5E5D 4D 41 58 41  	DB "MAXANIMDEFS",0
246   5E61 4E 49 4D 44
246   5E65 45 46 53 00
247   5E69 64 51        	DW MAXANIMDEFS
248   5E6B 4D 41 58 41  	DB "MAXANIMSPRS",0
248   5E6F 4E 49 4D 53
248   5E73 50 52 53 00
249   5E77 F9 51        	DW MAXANIMSPRS
250   5E79               ENDIF
251   5E79               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
252   5E79 00           	DB 0
253   5E7A               ENDIF
254   5E7A              CMDS_F:
255   5E7A               IF (VRAM_CMDS == 1)
256   5E7A 46 49 4C 56      DB "FILVRM", 0
256   5E7E 52 4D 00
257   5E81 E7 56            DW FILVRM
258   5E83               ENDIF
259   5E83               IF (RAM_CMDS == 1)
260   5E83 46 49 4C 52      DB "FILRAM", 0
260   5E87 41 4D 00
261   5E8A B0 55            DW FILRAM
262   5E8C               ENDIF
263   5E8C               IF (VRAM_CMDS + RAM_CMDS > 0)
264   5E8C 00               DB 0
265   5E8D               ENDIF
266   5E8D              CMDS_G:
267   5E8D               IF (GENCAL_CMD == 1)
268   5E8D 47 45 4E 43      DB "GENCAL", 0
268   5E91 41 4C 00
269   5E94 1B 58            DW GENCAL
270   5E96               ENDIF
271   5E96               IF (GENCAL_CMD > 0)
272   5E96 00           	DB	0
273   5E97               ENDIF
274   5E97              CMDS_V:
275   5E97               IF (VRAM_CMDS == 1)
276   5E97 56 52 4D 4D  	DB "VRMMEM", 0
276   5E9B 45 4D 00
277   5E9E B6 57        	DW VRMMEM
278   5EA0               ENDIF
279   5EA0               IF (VRAM_CMDS > 0)
280   5EA0 00           	DB 0
281   5EA1               ENDIF
282   5EA1              CMDS_S:
283   5EA1               IF (SPRITE_CMDS + ANIM_CMDS > 0)
284   5EA1 53 47 41 4D      DB "SGAM",0
284   5EA5 00
285   5EA6 BA 54            DW SGAM
286   5EA8               ENDIF
287   5EA8               IF (SPRITE_CMDS == 1)
288   5EA8 53 50 52 53   	DB "SPRSET", 0
288   5EAC 45 54 00
289   5EAF 81 4E        	DW SPRSET
290   5EB1 53 50 52 47  	DB "SPRGRPMOV", 0
290   5EB5 52 50 4D 4F
290   5EB9 56 00
291   5EBB 32 4F        	DW SPRGRPMOV
292   5EBD               ENDIF
293   5EBD               IF (SOUND_CMDS == 1)
294   5EBD 53 4E 44 53  	DB "SNDSFX", 0
294   5EC1 46 58 00
295   5EC4 8D 56        	DW SNDSFX
296   5EC6 53 4E 44 50  	DB "SNDPLYON", 0
296   5ECA 4C 59 4F 4E
296   5ECE 00
297   5ECF 57 56        	DW SNDPLYON
298   5ED1 53 4E 44 50  	DB "SNDPLYOFF", 0
298   5ED5 4C 59 4F 46
298   5ED9 46 00
299   5EDB 6A 56        	DW SNDPLYOFF
300   5EDD 53 4E 44 50  	DB "SNDPLYINI", 0
300   5EE1 4C 59 49 4E
300   5EE5 49 00
301   5EE7 0D 56        	DW SNDPLYINIT
302   5EE9               ENDIF
303   5EE9               IF (SPRITE_CMDS == 1)
304   5EE9 53 50 52 45  	DB "SPRENABLE", 0
304   5EED 4E 41 42 4C
304   5EF1 45 00
305   5EF3 3C 4E        	DW SPRENABLE
306   5EF5 53 50 52 44  	DB "SPRDISABLE", 0
306   5EF9 49 53 41 42
306   5EFD 4C 45 00
307   5F00 7C 4E        	DW SPRDISABLE
308   5F02               ENDIF
309   5F02               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
310   5F02 00           	DB 0
311   5F03               ENDIF
312   5F03              CMDS_B:
313   5F03               IF (BLIT_CMDS == 1)
314   5F03 42 4C 49 54  	DB "BLIT", 0
314   5F07 00
315   5F08 ED 5A        	DW BLIT
316   5F0A               ENDIF
317   5F0A               IF (BOX_CMDS == 1)
318   5F0A 42 4F 58 4D  	DB "BOXMEMCPY", 0
318   5F0E 45 4D 43 50
318   5F12 59 00
319   5F14 AA 58        	DW BOXMEMCPY
320   5F16 42 4F 58 4D  	DB "BOXMEMVRM", 0
320   5F1A 45 4D 56 52
320   5F1E 4D 00
321   5F20 3F 59        	DW BOXMEMVRM
322   5F22               ENDIF
323   5F22               IF (BLIT_CMDS + BOX_CMDS > 0)
324   5F22 00           	DB 0
325   5F23               ENDIF
326   5F23              CMDS_T:
327   5F23               IF (TILE_CMDS == 1)
328   5F23 54 49 4C 45  	DB "TILERAM", 0
328   5F27 52 41 4D 00
329   5F2B 31 5C        	DW TILERAM
330   5F2D 54 49 4C 45  	DB "TILEVRM", 0
330   5F31 56 52 4D 00
331   5F35 34 5D        	DW TILEVRM
332   5F37               ENDIF
333   5F37               IF (TILE_CMDS > 0)
334   5F37 00           	DB 0
335   5F38               ENDIF
336   5F38              CMDS_A:
337   5F38               IF (ANIM_CMDS == 1)
338   5F38 41 4E 49 4D      DB "ANIMSTEP",0
338   5F3C 53 54 45 50
338   5F40 00
339   5F41 40 53            DW ANIMSTEP
340   5F43 41 4E 49 4D  	DB "ANIMSTART",0
340   5F47 53 54 41 52
340   5F4B 54 00
341   5F4D 45 53        	DW ANIMSTART
342   5F4F 41 4E 49 4D  	DB "ANIMSTOP",0
342   5F53 53 54 4F 50
342   5F57 00
343   5F58 4A 53        	DW ANIMSTOP
344   5F5A 41 4E 49 4D  	DB "ANIMITEMPAT",0
344   5F5E 49 54 45 4D
344   5F62 50 41 54 00
345   5F66 AF 50        	DW ANIMITEMPAT
346   5F68 41 4E 49 4D  	DB "ANIMITEMPTR",0
346   5F6C 49 54 45 4D
346   5F70 50 54 52 00
347   5F74 10 51        	DW ANIMITEMPTR_CMD
348   5F76 41 4E 49 4D  	DB "ANIMDEF",0
348   5F7A 44 45 46 00
349   5F7E A6 51        	DW ANIMDEF
350   5F80 41 4E 49 4D  	DB "ANIMSPRITE",0
350   5F84 53 50 52 49
350   5F88 54 45 00
351   5F8B 4F 52        	DW ANIMSPRITE
352   5F8D 41 4E 49 4D      DB "ANIMCHAR",0
352   5F91 43 48 41 52
352   5F95 00
353   5F96 C7 52            DW ANIMCHAR
354   5F98 00           	DB 0
355   5F99               ENDIF
356   5F99
357   5F99               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
358   5F99              ; ****************************************************************************************************
359   5F99              ; function sets VRAM address
360   5F99              ; input HL=address
361   5F99              ; modifies AF
362   5F99              SETWRT_LOCAL:
363   5F99 7D           	LD	A, L
364   5F9A D3 99        	OUT	(099H), A
365   5F9C 7C           	LD	A, H
366   5F9D E6 3F        	AND	03FH
367   5F9F F6 40        	OR	040H
368   5FA1 D3 99        	OUT	(099H), A
369   5FA3 C9           	RET
370   5FA4              ; ****************************************************************************************************
371   5FA4               ENDIF
372   5FA4
373   5FA4               IF (VRAM_CMDS + TILE_CMDS > 0)
374   5FA4              ; ****************************************************************************************************
375   5FA4              ; function copies data from RAM to VRAM
376   5FA4              ; input HL=address in RAM
377   5FA4              ; input B=count
378   5FA4              ; modifies AF, BC, HL
379   5FA4              BBYTECOPY:
380   5FA4 0E 98        	LD C,#98
381   5FA6              BBYTECOPY_NO_C:
382   5FA6 ED A3        	OUTI
383   5FA8 C2 A6 5F     	JP	NZ, BBYTECOPY_NO_C
384   5FAB C9           	RET
385   5FAC              ; ****************************************************************************************************
386   5FAC               ENDIF
387   5FAC
388   5FAC              ; ****************************************************************************************************
389   5FAC              ; function multiplies HL by 32
390   5FAC              HLx32:
391   5FAC 29           	ADD HL,HL
392   5FAD              ; ****************************************************************************************************
393   5FAD              ; function multiplies HL by 16
394   5FAD              HLx16:
395   5FAD 29           	ADD HL,HL
396   5FAE              ; ****************************************************************************************************
397   5FAE              ; function multiplies HL by 8
398   5FAE              HLx8:
399   5FAE 29          > ADD HL, HL
399   5FAF 29          > ADD HL, HL
399   5FB0 29          > ADD HL, HL
400   5FB1 C9           	RET
401   5FB2              ; ****************************************************************************************************
402   5FB2
403   5FB2              ; ****************************************************************************************************
404   5FB2              ; function gets slot and subslot data for specific page
405   5FB2              ; input A=page (0, 1 or 2)
406   5FB2              ; output B = 0A8H register value
407   5FB2              ; output D = 0 is no subslots, 1 if yes
408   5FB2              ; output C = 0A8H value when page 3 slot equals to requested page slot
409   5FB2              ; output E = subslot value if present
410   5FB2              ; modifies AF, BC, DE, HL
411   5FB2              GET_PAGE_INFO:
412   5FB2 6F               LD L, A
413   5FB3 C6 C1            ADD A, low (EXPTBL)
414   5FB5 32 BF 5F         LD (GET_PAGE_INFO_L1+1), A
415   5FB8 DB A8            IN A, (0A8H)
416   5FBA 47               LD B, A
417   5FBB E6 3F            AND 03FH
418   5FBD 4F               LD C, A
419   5FBE              GET_PAGE_INFO_L1:
420   5FBE 3A C1 FC         LD A, (EXPTBL) ; modified by code above
421   5FC1 E6 80            AND 080H
422   5FC3 28 1B            JR Z, GET_PAGE_INFO_L2
423   5FC5                  ; expanded
424   5FC5 2D               DEC L
425   5FC6 FA E5 5F         JP M, GET_PAGE_INFO_L3
426   5FC9 2D               DEC L
427   5FCA FA E3 5F         JP M, GET_PAGE_INFO_L4
428   5FCD                  ; page 2
429   5FCD 07               RLCA
430   5FCE 07               RLCA
431   5FCF              GET_PAGE_INFO_L5:
432   5FCF E6 C0            AND 0C0H
433   5FD1 B1               OR C
434   5FD2 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
435   5FD4 4F               LD C, A
436   5FD5 3A FF FF         LD A, (0FFFFH)
437   5FD8 2F               CPL
438   5FD9 5F               LD E, A
439   5FDA 16 01            LD D, 1
440   5FDC 78               LD A, B ; return stack
441   5FDD D3 A8            OUT (0A8H), A
442   5FDF C9               RET
443   5FE0              GET_PAGE_INFO_L2:
444   5FE0                  ; not expanded
445   5FE0 16 00            LD D, 0
446   5FE2 C9               RET
447   5FE3              GET_PAGE_INFO_L4:
448   5FE3                  ; page 1
449   5FE3 0F               RRCA
450   5FE4 0F               RRCA
451   5FE5              GET_PAGE_INFO_L3:
452   5FE5                  ; page 0
453   5FE5 0F               RRCA
454   5FE6 0F               RRCA
455   5FE7 18 E6            JR GET_PAGE_INFO_L5
456   5FE9              ; ****************************************************************************************************
457   5FE9
458   5FE9              ; ****************************************************************************************************
459   5FE9              ; function returns original slot and subslot info
460   5FE9              ; input B = 0A8H register value
461   5FE9              ; input D = 0 is no subslots, 1 if yes
462   5FE9              ; input C = 0A8H value when page 3 slot equals to requested page slot
463   5FE9              ; input E = subslot value if present
464   5FE9              ; modifies AF, disables interrupts
465   5FE9              RESTORE_PAGE_INFO:
466   5FE9 7A               LD A, D
467   5FEA B7               OR A
468   5FEB 28 08            JR Z, RESTORE_PAGE_INFO_L1
469   5FED 79               LD A, C
470   5FEE F3           	DI
471   5FEF D3 A8            OUT (0A8H), A
472   5FF1 7B               LD A, E
473   5FF2 32 FF FF         LD (0FFFFH), A
474   5FF5              RESTORE_PAGE_INFO_L1:
475   5FF5 78               LD A, B
476   5FF6 D3 A8            OUT (0A8H), A
477   5FF8 C9               RET
478   5FF9              ; ****************************************************************************************************
479   5FF9
480   5FF9              ; *******************************************************************************************************
481   5FF9              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
482   5FF9              ; INPUT:  A = SLOT ID: EXXXSSPP
483   5FF9              ; E = EXPANDED FLAG
484   5FF9              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
485   5FF9              ; PP = PRIMARY SLOT NUMBER
486   5FF9              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
487   5FF9              ; CHANGES: AF, BC, DE
488   5FF9
489   5FF9              LOCAL_ENASLT:
490   5FF9 CD 19 60         CALL L0353
491   5FFC FA 06 60         JP M, L0340
492   5FFF DB A8            IN A, (0A8H)
493   6001 A1               AND C
494   6002 B0               OR B
495   6003 D3 A8            OUT (0A8H), A
496   6005 C9               RET
497   6006              L0340:
498   6006 E5               PUSH HL
499   6007 CD 3E 60         CALL L0378
500   600A 4F               LD C, A
501   600B 06 00            LD B, 0
502   600D 7D               LD A, L
503   600E A4               AND H
504   600F B2               OR D
505   6010 21 C5 FC         LD HL, 0FCC5H
506   6013 09               ADD HL, BC
507   6014 77               LD (HL), A
508   6015 E1               POP HL
509   6016 79               LD A, C
510   6017 18 E0            JR LOCAL_ENASLT
511   6019              L0353:
512   6019 F3               DI
513   601A F5               PUSH AF
514   601B 7C               LD A, H
515   601C 07               RLCA
516   601D 07               RLCA
517   601E E6 03            AND 3
518   6020 5F               LD E, A
519   6021 3E C0            LD A, 0C0H
520   6023              L035D:
521   6023 07               RLCA
522   6024 07               RLCA
523   6025 1D               DEC E
524   6026 F2 23 60         JP P, L035D
525   6029 5F               LD E, A
526   602A 2F               CPL
527   602B 4F               LD C, A
528   602C F1               POP AF
529   602D F5               PUSH AF
530   602E E6 03            AND 3
531   6030 3C               INC A
532   6031 47               LD B, A
533   6032 3E AB            LD A, 0ABH
534   6034              L036E:
535   6034 C6 55            ADD A, 055H
536   6036 10 FC            DJNZ L036E
537   6038 57               LD D, A
538   6039 A3               AND E
539   603A 47               LD B, A
540   603B F1               POP AF
541   603C A7               AND A
542   603D C9               RET
543   603E              L0378:
544   603E F5               PUSH AF
545   603F 7A               LD A, D
546   6040 E6 C0            AND 0C0H
547   6042 4F               LD C, A
548   6043 F1               POP AF
549   6044 F5               PUSH AF
550   6045 57               LD D, A
551   6046 DB A8            IN A, (0A8H)
552   6048 47               LD B, A
553   6049 E6 3F            AND 03FH
554   604B B1               OR C
555   604C D3 A8            OUT (0A8H), A
556   604E 7A               LD A, D
557   604F 0F               RRCA
558   6050 0F               RRCA
559   6051 E6 03            AND 3
560   6053 57               LD D, A
561   6054 3E AB            LD A, 0ABH
562   6056              L0390:
563   6056 C6 55            ADD A, 055H
564   6058 15               DEC D
565   6059 F2 56 60         JP P, L0390
566   605C A3               AND E
567   605D 57               LD D, A
568   605E 7B               LD A, E
569   605F 2F               CPL
570   6060 67               LD H, A
571   6061 3A FF FF         LD A, (0FFFFH)
572   6064 2F               CPL
573   6065 6F               LD L, A
574   6066 A4               AND H
575   6067 B2               OR D
576   6068 32 FF FF         LD (0FFFFH), A
577   606B 78               LD A, B
578   606C D3 A8            OUT (0A8H), A
579   606E F1               POP AF
580   606F E6 03            AND 3
581   6071 C9               RET
582   6072              ; *******************************************************************************************************
583   6072
584   6072              ; *******************************************************************************************************
585   6072              ; some common code to activate page 0 and place values needed to restore original page on stack
586   6072              ; input IY=return address
587   6072              ENABLE_PAGE0:
588   6072 AF               XOR A
589   6073 CD B2 5F         CALL GET_PAGE_INFO
590   6076 C5               PUSH BC
591   6077 D5               PUSH DE
592   6078 3A 41 F3         LD A, (RAMAD0)
593   607B 26 00            LD H, 0
594   607D CD F9 5F         CALL LOCAL_ENASLT
595   6080 FD E9        	JP (IY)
596   6082              ; *******************************************************************************************************
597   6082
598   6082              ; General BASIC CALL-instruction handler
599   6082              CALLHAND:
600   6082 E5           	PUSH HL
601   6083 21 08 5E     	LD	HL, CMDS ; pointer table based on starting letter
602   6086 3A 89 FD         LD A, (PROCNM)
603   6089 D6 41            SUB 'A'
604   608B 87               ADD A, A
605   608C 16 00            LD D, 0
606   608E 5F               LD E, A
607   608F 19               ADD HL, DE
608   6090 5E               LD E, (HL)
609   6091 23               INC HL
610   6092 56               LD D, (HL)
611   6093 7A               LD A, D
612   6094 B3               OR E
613   6095 28 23            JR Z, .CMDNOTRECOGNIZED
614   6097 EB               EX DE, HL
615   6098              .CHKCMD:
616   6098 11 89 FD     	LD	DE, PROCNM
617   609B 1A           .LOOP:	LD	A,(DE)
618   609C BE           	CP	(HL)
619   609D 20 11        	JR	NZ,.TONEXTCMD	; Not equal
620   609F 13           	INC	DE
621   60A0 23           	INC	HL
622   60A1 A7           	AND	A
623   60A2 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
624   60A4 5E           	LD	E,(HL)
625   60A5 23           	INC	HL
626   60A6 56           	LD	D,(HL)
627   60A7 E1           	POP	HL		; routine address
628   60A8 CD C9 60     	CALL	GETPREVCHAR
629   60AB CD BD 60     	CALL	.CALLDE		; Call routine
630   60AE A7           	AND	A
631   60AF C9           	RET
632   60B0
633   60B0              .TONEXTCMD:
634   60B0 0E FF        	LD	C,0FFH
635   60B2 AF           	XOR	A
636   60B3 ED B1        	CPIR			; Skip to end of instruction name
637   60B5 23           	INC	HL
638   60B6 23           	INC	HL		; Skip address
639   60B7 BE           	CP	(HL)
640   60B8 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
641   60BA              .CMDNOTRECOGNIZED:
642   60BA E1           	POP	HL
643   60BB 37               SCF
644   60BC C9           	RET
645   60BD
646   60BD              .CALLDE:
647   60BD D5           	PUSH	DE
648   60BE C9           	RET
649   60BF
650   60BF              ;---------------------------
651   60BF
652   60BF              ;GETSTRPNT:
653   60BF              ; OUT:
654   60BF              ; HL = String Address
655   60BF              ; B  = Lenght
656   60BF              ;        LD      HL,(USR)
657   60BF              ;        LD      B,(HL)
658   60BF              ;        INC     HL
659   60BF              ;        LD      E,(HL)
660   60BF              ;        INC     HL
661   60BF              ;        LD      D,(HL)
662   60BF              ;        EX      DE,HL
663   60BF              ;        RET
664   60BF
665   60BF              ;EVALTXTPARAM:
666   60BF              ;	CALL	CHKCHAR
667   60BF              ;	DEFB	"("             ; Check for (
668   60BF              ;	LD	IX,FRMEVL
669   60BF              ;	CALL	CALBAS		; Evaluate expression
670   60BF              ;       LD      A,(VALTYP)
671   60BF              ;        CP      3               ; Text type?
672   60BF              ;        JP      NZ,TYPE_MISMATCH
673   60BF              ;        PUSH	HL
674   60BF              ;        LD	IX,FRESTR         ; Free the temporary string
675   60BF              ;        CALL	CALBAS
676   60BF              ;        POP	HL
677   60BF              ;	CALL	CHKCHAR
678   60BF              ;	DEFB	")"             ; Check for )
679   60BF              ;        RET
680   60BF
681   60BF
682   60BF              CHKCHAR:
683   60BF CD C9 60     	CALL	GETPREVCHAR	; Get previous basic char
684   60C2 E3           	EX	(SP),HL
685   60C3 BE           	CP	(HL) 	        ; Check if good char
686   60C4 20 1B        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
687   60C6 23           	INC	HL
688   60C7 E3           	EX	(SP),HL
689   60C8 23           	INC	HL		; Get next basic char
690   60C9
691   60C9              GETPREVCHAR:
692   60C9 2B           	DEC	HL
693   60CA DD 21 66 46  	LD	IX,CHRGTR
694   60CE C3 59 01     	JP      CALBAS
695   60D1
696   60D1
697   60D1              TYPE_MISMATCH:
698   60D1 1E 0D            LD E, 13 ; Type mismatch
699   60D3 18 0E            JR THROW_ERROR
700   60D5              SUBSCRIPT_OUT_OF_RANGE:
701   60D5 1E 09            LD E,9 ; subscript out of range
702   60D7 18 0A        	JR THROW_ERROR
703   60D9              OVERFLOW:
704   60D9 1E 06        	LD E,6
705   60DB 18 06        	JR THROW_ERROR
706   60DD              ILLEGAL_FUNCTION:
707   60DD 1E 05            LD E, 5 ; illegal function call
708   60DF 18 02            JR THROW_ERROR
709   60E1              SYNTAX_ERROR:
710   60E1 1E 02            LD E, 2 ; Syntax error
711   60E3              THROW_ERROR:
712   60E3 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
713   60E7 C3 59 01     	JP	CALBAS
714   60EA
715   60EA              ;---------------------------
716   60EA
717   60EA              ; *******************************************************************************************************
718   60EA              ; helper function to get pointer to BASIC array data
719   60EA              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
720   60EA              ; input B=dimensions (1 or 2)
721   60EA              ; input D=minimal first dimension
722   60EA              ; input E=minimal second dimension, if applicable
723   60EA              ; returns BC=pointer to first data element
724   60EA              ; throws BASIC error if invalid type
725   60EA              GET_BASIC_ARRAY_DATA_POINTER:
726   60EA D5           	PUSH DE
727   60EB C5           	PUSH BC
728   60EC F5           	PUSH AF
729   60ED 3E 01            LD A,1
730   60EF 32 A5 F6         LD (SUBFLG),A ; search for arrays only
731   60F2 DD 21 A4 5E  	LD IX, PTRGET
732   60F6 CD 59 01     	CALL CALBAS
733   60F9 AF               XOR A
734   60FA 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
735   60FD 3A 63 F6     	LD A,(VALTYP)
736   6100 D1           	POP DE ; required type
737   6101 BA           	CP D
738   6102 C2 D1 60     	JP NZ,TYPE_MISMATCH
739   6105 0A           	LD A,(BC)
740   6106 03           	INC BC
741   6107 D1           	POP DE ; required number of dimensions
742   6108 BA           	CP D
743   6109 C2 D1 60     	JP NZ,TYPE_MISMATCH
744   610C D1           	POP DE ; required minimal array dimensions
745   610D 3D           	DEC A
746   610E 28 07        	JR Z,.ONE_DIMENSION
747   6110              	; 2-dimension array
748   6110 0A           	LD A,(BC)
749   6111 03          > INC BC
749   6112 03          > INC BC
750   6113 BB           	CP E
751   6114 DA D5 60     	JP C,SUBSCRIPT_OUT_OF_RANGE
752   6117              .ONE_DIMENSION:
753   6117 0A           	LD A,(BC)
754   6118 03          > INC BC
754   6119 03          > INC BC
755   611A BA           	CP D
756   611B DA D5 60     	JP C,SUBSCRIPT_OUT_OF_RANGE
757   611E C9           	RET
758   611F              ; *******************************************************************************************************
759   611F
760   611F              EXT_END:
761   611F
# file closed: asm\main.asm
