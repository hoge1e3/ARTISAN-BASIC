# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000              JIFFY	EQU #FC9E
  51  4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
  52  4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
  53  4000
  54  4000              ; BASIC error codes
  55  4000              ;01 NEXT without FOR
  56  4000              ;02 Syntax error
  57  4000              ;03 RETURN without GOSUB
  58  4000              ;04 Out of DATA
  59  4000              ;05 Illegal function call
  60  4000              ;06 Overflow
  61  4000              ;07 Out of memory
  62  4000              ;08 Undefined line number
  63  4000              ;09 Subscript out of range
  64  4000              ;10 Redimensioned array
  65  4000              ;11 Division by zero
  66  4000              ;12 Illegal direct
  67  4000              ;13 Type mismatch
  68  4000              ;14 Out of string space
  69  4000              ;15 String too long
  70  4000              ;16 String formula too complex
  71  4000              ;17 Can't CONTINUE
  72  4000              ;18 Undefined user function
  73  4000              ;19 Device I/O error
  74  4000              ;20 Verify error
  75  4000              ;21 No RESUME
  76  4000              ;22 RESUME without error
  77  4000              ;23 Unprintable error
  78  4000              ;24 Missing operand
  79  4000              ;25 Line buffer overflow
  80  4000              ;50 FIELD overflow
  81  4000              ;51 Internal error
  82  4000              ;52 Bad file number
  83  4000              ;53 File not found
  84  4000              ;54 File already open
  85  4000              ;55 Input past end
  86  4000              ;56 Bad file name
  87  4000              ;57 Direct statement in file
  88  4000              ;58 Sequential I/O only
  89  4000              ;59 File not OPEN
  90  4000
  91  4000
  92  4000               ; simulate cartridge with BASIC extension
  93  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  93  4004 CB 56 00 00
  93  4008 00 00 00 00
  93  400C 00 00 00 00
  94  4010
  95  4010              ; this location #4010 stores last location used by basic extension
  96  4010              ; free memory after that point
  97  4010              FREEMEMPTR:
  98  4010 6E 5F         DW EXT_END
  99  4012
 100  4012              ; this location #4012 stores extension version in DAA format
 101  4012              ; first byte is major version and second minor
 102  4012              VERSION:
 103  4012 00 70         DB #00, #70
 104  4014
 105  4014              ; binary included AKG player compiled at #4014
 106  4014               IF (SOUND_CMDS == 1)
 107  4014              	INCBIN "bin/AKG.bin"
 108  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 109  4CF0               ENDIF
 110  4CF0
 111  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 27 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A 7C 4D     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13 2A 9E FC         LD HL,(JIFFY)
  43+ 4D16 23               INC HL
  44+ 4D17 22 9E FC         LD (JIFFY),HL
  45+ 4D1A
  46+ 4D1A FD E1            POP IY
  47+ 4D1C DD E1            POP IX
  48+ 4D1E E1               POP HL
  49+ 4D1F D1               POP DE
  50+ 4D20 C1               POP BC
  51+ 4D21 F1               POP AF
  52+ 4D22 08               EX AF, AF'
  53+ 4D23 D9               EXX
  54+ 4D24 E1               POP HL
  55+ 4D25 D1               POP DE
  56+ 4D26 C1               POP BC
  57+ 4D27               ENDIF
  58+ 4D27
  59+ 4D27              .EXIT:
  60+ 4D27 F1           	POP AF
  61+ 4D28 FB           	EI
  62+ 4D29 ED 4D        	RETI
  63+ 4D2B              ; *******************************************************************************************************
  64+ 4D2B
  65+ 4D2B              ; *******************************************************************************************************
  66+ 4D2B              ; H.TIMI function
  67+ 4D2B              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2B              MBGE_HTIMI:
  69+ 4D2B               EXPORT MBGE_HTIMI
  70+ 4D2B
  71+ 4D2B               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2B
  73+ 4D2B F5           	PUSH AF
  74+ 4D2C
  75+ 4D2C              	; enable page 2
  76+ 4D2C 3E 02            LD A, 2
  77+ 4D2E CD FB 55         CALL GET_PAGE_INFO
  78+ 4D31 C5               PUSH BC
  79+ 4D32 D5               PUSH DE
  80+ 4D33 3A 43 F3         LD A, (RAMAD2)
  81+ 4D36 26 80            LD H, 080H
  82+ 4D38 CD 42 56         CALL LOCAL_ENASLT
  83+ 4D3B              	; enable page 0
  84+ 4D3B AF               XOR A
  85+ 4D3C CD FB 55         CALL GET_PAGE_INFO
  86+ 4D3F C5               PUSH BC
  87+ 4D40 D5               PUSH DE
  88+ 4D41 3A 41 F3         LD A, (RAMAD0)
  89+ 4D44 26 00            LD H, 0
  90+ 4D46 CD 42 56         CALL LOCAL_ENASLT
  91+ 4D49
  92+ 4D49               IF (SPRITE_CMDS == 1)
  93+ 4D49 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4C               ENDIF
  95+ 4D4C
  96+ 4D4C               IF (SOUND_CMDS == 1)
  97+ 4D4C 3A 7C 4D     	LD A, (SOUND_ENABLED)
  98+ 4D4F B7           	OR A
  99+ 4D50 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D53               ENDIF
 101+ 4D53
 102+ 4D53              	; restore page 0
 103+ 4D53 D1               POP DE
 104+ 4D54 C1               POP BC
 105+ 4D55 CD 32 56         CALL RESTORE_PAGE_INFO
 106+ 4D58              	; restore page 2
 107+ 4D58 D1               POP DE
 108+ 4D59 C1               POP BC
 109+ 4D5A CD 32 56         CALL RESTORE_PAGE_INFO
 110+ 4D5D
 111+ 4D5D F1           	POP AF
 112+ 4D5E               ENDIF
 113+ 4D5E C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D61              ; *******************************************************************************************************
 115+ 4D61
 116+ 4D61              ; *******************************************************************************************************
 117+ 4D61              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D61              ; also checks if some VRAM modifying command is running
 119+ 4D61              ; when that checks out calls sprite updates and animation processing
 120+ 4D61              PROCESS_SPRITES_AND_ANIMATIONS:
 121+ 4D61              	; check if initialized
 122+ 4D61 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 123+ 4D64 B7           	OR A
 124+ 4D65 C8           	RET Z
 125+ 4D66              	; check screen mode
 126+ 4D66 3A AF FC     	LD A, (SCRMOD)
 127+ 4D69 3D           	DEC A
 128+ 4D6A 28 02        	JR Z, .L0 ; screen 1
 129+ 4D6C 3D           	DEC A
 130+ 4D6D C0           	RET NZ ; not screen 2
 131+ 4D6E              .L0:
 132+ 4D6E                  ; check if anyone else is working with VRAM
 133+ 4D6E 3A 6F 54         LD A,(VRAM_UPDATE_IN_PROGRESS)
 134+ 4D71 B7               OR A
 135+ 4D72 C0               RET NZ
 136+ 4D73
 137+ 4D73 CD 92 4D         CALL SPRATR_UPDATE
 138+ 4D76
 139+ 4D76               IF (ANIM_CMDS == 1)
 140+ 4D76 CD 76 53         CALL PROCESS_ANIMATIONS
 141+ 4D79               ENDIF
 142+ 4D79 C9               RET
 143+ 4D7A              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 112  4D7A
 113  4D7A               IF (SOUND_CMDS == 1)
 114  4D7A              MUSIC_INIT_STATUS:
 115  4D7A 00            DB 0
 116  4D7B              SFX_INIT_STATUS:
 117  4D7B 00            DB 0
 118  4D7C              SOUND_ENABLED:
 119  4D7C 00            DB 0
 120  4D7D               ENDIF
 121  4D7D
 122  4D7D               IF (SPRITE_CMDS == 1)
 123  4D7D               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7D              ; commands and variables related to sprites
   2+ 4D7D
   3+ 4D7D              SPRATR_INIT_STATUS:
   4+ 4D7D 00            DB 0
   5+ 4D7E              SPRATR_UPDATE_FLAG:
   6+ 4D7E 00 00         DW 0
   7+ 4D80              SPRATR_DATA:
   8+ 4D80 00 00         DW 0
   9+ 4D82              SPRFLICKER_ENABLED:
  10+ 4D82 00            DB 0
  11+ 4D83              ; to support sprite flicker
  12+ 4D83              FLICKER:
  13+ 4D83 00            DB 0
  14+ 4D84
  15+ 4D84              ; to temporarily store stack pointer
  16+ 4D84              TMPSP:
  17+ 4D84 00 00         DW 0
  18+ 4D86
  19+ 4D86              ; *******************************************************************************************************
  20+ 4D86              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D86              ; changes HL,DE;
  22+ 4D86              GETnthSPRATTR:
  23+ 4D86 26 00            LD H,0
  24+ 4D88 6F               LD L,A
  25+ 4D89 CD F7 55         CALL HLx8
  26+ 4D8C ED 5B 80 4D      LD DE,(SPRATR_DATA)
  27+ 4D90 19               ADD HL,DE
  28+ 4D91 C9               RET
  29+ 4D92              ; *******************************************************************************************************
  30+ 4D92
  31+ 4D92              ; *******************************************************************************************************
  32+ 4D92              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D92              ; struct {
  34+ 4D92              ; DW y
  35+ 4D92              ; DW x
  36+ 4D92              ; DW pattern (0-63)
  37+ 4D92              ; DW color
  38+ 4D92              ; } [32]
  39+ 4D92              ; will hide sprites whose location is outside of visible area
  40+ 4D92              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D92              ; modifies AF, AF', BC, DE, HL
  42+ 4D92              SPRATR_UPDATE:
  43+ 4D92              	; check if update requested
  44+ 4D92 2A 7E 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D95 7E           	LD A, (HL)
  46+ 4D96 B7           	OR A
  47+ 4D97 C8           	RET Z
  48+ 4D98              .L0:
  49+ 4D98 06 20        	LD B, 32 ; sprite number
  50+ 4D9A 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D9C              	; set VDP address
  52+ 4D9C 2A 28 F9     	LD HL, (ATRBAS)
  53+ 4D9F 3A 82 4D     	LD A, (SPRFLICKER_ENABLED)
  54+ 4DA2 B7           	OR A
  55+ 4DA3 28 03        	JR Z, .L3
  56+ 4DA5 3A 83 4D     	LD A, (FLICKER)
  57+ 4DA8              .L3:
  58+ 4DA8 5F           	LD E, A
  59+ 4DA9 08           	EX AF, AF'
  60+ 4DAA 7B           	LD A, E
  61+ 4DAB 87           	ADD A, A
  62+ 4DAC 87           	ADD A, A
  63+ 4DAD 16 00        	LD D, 0
  64+ 4DAF 5F           	LD E, A
  65+ 4DB0 19           	ADD HL, DE
  66+ 4DB1 CD E4 55     	CALL SETWRT_LOCAL
  67+ 4DB4 ED 73 84 4D  	LD (TMPSP), SP
  68+ 4DB8 ED 7B 80 4D  	LD SP, (SPRATR_DATA)
  69+ 4DBC
  70+ 4DBC              .LOOP:
  71+ 4DBC E1           	POP HL
  72+ 4DBD 24           	INC H
  73+ 4DBE 28 0D        	JR Z, .L1 ; negative number above -256
  74+ 4DC0 25           	DEC H
  75+ 4DC1 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  76+ 4DC3 7D           	LD A, L
  77+ 4DC4 FE C0        	CP 192
  78+ 4DC6 30 10        	JR NC, .OUT3
  79+ 4DC8 3D           	DEC A ; due to VDP rule that top of screen is -1
  80+ 4DC9 57           	LD D, A
  81+ 4DCA C3 F1 4D     	JP .X
  82+ 4DCD              .L1:
  83+ 4DCD 7D           	LD A, L
  84+ 4DCE C6 10        	ADD 16
  85+ 4DD0 FA D8 4D     	JP M, .OUT3 ; below -16
  86+ 4DD3 2D           	DEC L ; due to VDP rule that top of screen is -1
  87+ 4DD4 55           	LD D, L
  88+ 4DD5 C3 F1 4D     	JP .X
  89+ 4DD8              .OUT3:
  90+ 4DD8 E1           	POP HL ; skip x value
  91+ 4DD9              .OUT2:
  92+ 4DD9 E1           	POP HL ; skip pattern
  93+ 4DDA E1           	POP HL ; skip color
  94+ 4DDB 3E D1        	LD A, #D1
  95+ 4DDD ED 79        	OUT (C), A ; sprite hidden
  96+ 4DDF 00          > NOP
  96+ 4DE0 00          > NOP
  96+ 4DE1 00          > NOP
  97+ 4DE2 ED 79        	OUT (C), A ; value unimportant
  98+ 4DE4 00          > NOP
  98+ 4DE5 00          > NOP
  98+ 4DE6 00          > NOP
  99+ 4DE7 ED 79        	OUT (C), A ; value unimportant
 100+ 4DE9 00          > NOP
 100+ 4DEA 00          > NOP
 100+ 4DEB 00          > NOP
 101+ 4DEC ED 79        	OUT (C), A ; value unimportant
 102+ 4DEE C3 1C 4E     	JP .NEXT
 103+ 4DF1              .X:
 104+ 4DF1 E1           	POP HL
 105+ 4DF2 24           	INC H
 106+ 4DF3 28 08        	JR Z, .L2
 107+ 4DF5 25           	DEC H
 108+ 4DF6 20 E1        	JR NZ, .OUT2
 109+ 4DF8 1E 00        	LD E, 0 ; EC bit
 110+ 4DFA C3 06 4E     	JP .XY
 111+ 4DFD              .L2:
 112+ 4DFD 7D           	LD A, L
 113+ 4DFE C6 20        	ADD 32
 114+ 4E00 FA D9 4D     	JP M, .OUT2
 115+ 4E03 6F           	LD L, A
 116+ 4E04 1E 80        	LD E, #80
 117+ 4E06              .XY:
 118+ 4E06 ED 51        	OUT (C), D
 119+ 4E08 3A E0 F3     	LD A, (REG1SAV)
 120+ 4E0B E6 02        	AND 2
 121+ 4E0D ED 69        	OUT (C), L
 122+ 4E0F E1           	POP HL ; pattern
 123+ 4E10 7D           	LD A, L
 124+ 4E11 28 02        	JR Z, .SMALLSPRITES
 125+ 4E13 87           	ADD A, A
 126+ 4E14 87           	ADD A, A ; needs to go at 4x
 127+ 4E15              .SMALLSPRITES:
 128+ 4E15 D3 98        	OUT (#98), A
 129+ 4E17 E1           	POP HL ; color
 130+ 4E18 7D           	LD A, L
 131+ 4E19 B3           	OR E
 132+ 4E1A D3 98        	OUT (#98), A
 133+ 4E1C              .NEXT:
 134+ 4E1C 08           	EX AF, AF'
 135+ 4E1D 3C           	INC A
 136+ 4E1E E6 1F        	AND 31
 137+ 4E20 C2 34 4E     	JP NZ, .NEXT2
 138+ 4E23 08           	EX AF, AF'
 139+ 4E24 2A 28 F9     	LD HL, (ATRBAS)
 140+ 4E27              	; CALL SETWRT_LOCAL not allowed as SP modified
 141+ 4E27 7D           	LD	A, L
 142+ 4E28 D3 99        	OUT	(099H), A
 143+ 4E2A 7C           	LD	A, H
 144+ 4E2B E6 3F        	AND	03FH
 145+ 4E2D F6 40        	OR	040H
 146+ 4E2F D3 99        	OUT	(099H), A
 147+ 4E31 C3 35 4E     	JP .NEXT3
 148+ 4E34              .NEXT2:
 149+ 4E34 08           	EX AF, AF'
 150+ 4E35              .NEXT3:
 151+ 4E35 10 85        	DJNZ .LOOP
 152+ 4E37 08           	EX AF, AF'
 153+ 4E38 3C           	INC A
 154+ 4E39 32 83 4D     	LD (FLICKER), A
 155+ 4E3C
 156+ 4E3C ED 7B 84 4D  	LD SP, (TMPSP)
 157+ 4E40 2A 7E 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 158+ 4E43 36 00        	LD (HL), 0 ; zero out update flag
 159+ 4E45 C9           	RET
 160+ 4E46              ; *******************************************************************************************************
 161+ 4E46
 162+ 4E46              ; *******************************************************************************************************
 163+ 4E46              ; function to handle CALL SPRENABLE basic extension
 164+ 4E46              ; initializes sprites handler
 165+ 4E46              ; _SPRENABLE ( INT sprites_attributes_data,
 166+ 4E46              ;			   INT update_variable_location,
 167+ 4E46              ;			   INT sprite_flicker_enabled )
 168+ 4E46              ; expects both locations to be in range #8000+ or throws an error
 169+ 4E46              ; since these should be BASIC variables
 170+ 4E46              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 171+ 4E46              SPRENABLE:
 172+ 4E46              	; opening (
 173+ 4E46 CD 08 57     	CALL CHKCHAR
 174+ 4E49 28           	DB '('
 175+ 4E4A              	; get address of sprite attribute table DIM SA%(3,31)
 176+ 4E4A DD 21 2F 54  	LD IX, FRMQNT
 177+ 4E4E CD 59 01     	CALL CALBAS
 178+ 4E51 D5           	PUSH DE
 179+ 4E52              	; comma
 180+ 4E52 CD 08 57     	CALL CHKCHAR
 181+ 4E55 2C           	DB ','
 182+ 4E56              	; get address of sprite update flag location
 183+ 4E56 DD 21 2F 54  	LD IX, FRMQNT
 184+ 4E5A CD 59 01     	CALL CALBAS
 185+ 4E5D D5           	PUSH DE
 186+ 4E5E              	; comma
 187+ 4E5E CD 08 57     	CALL CHKCHAR
 188+ 4E61 2C           	DB ','
 189+ 4E62              	; get flicker enabled flag
 190+ 4E62 DD 21 2F 54  	LD IX, FRMQNT
 191+ 4E66 CD 59 01     	CALL CALBAS
 192+ 4E69 D5           	PUSH DE
 193+ 4E6A              	; ending )
 194+ 4E6A CD 08 57     	CALL CHKCHAR
 195+ 4E6D 29           	DB ')'
 196+ 4E6E
 197+ 4E6E D1           	POP DE ; get flicker flag
 198+ 4E6F 7A           	LD A, D
 199+ 4E70 B3           	OR E
 200+ 4E71 32 82 4D     	LD (SPRFLICKER_ENABLED), A
 201+ 4E74
 202+ 4E74 D1           	POP DE ; update variable location
 203+ 4E75 CB 7A        	BIT 7, D ; is address >= &h8000
 204+ 4E77 20 05        	JR NZ, .L1
 205+ 4E79 1E 05        	LD E, 5 ; illegal function call
 206+ 4E7B C3 28 57     	JP THROW_ERROR
 207+ 4E7E              .L1:
 208+ 4E7E ED 53 7E 4D  	LD (SPRATR_UPDATE_FLAG), DE
 209+ 4E82 D1           	POP DE ; address of sprite attribute table
 210+ 4E83 CB 7A        	BIT 7, D ; is address >= &h8000
 211+ 4E85 20 05        	JR NZ, .L2
 212+ 4E87 1E 05        	LD E, 5 ; illegal function call
 213+ 4E89 C3 28 57     	JP THROW_ERROR
 214+ 4E8C              .L2:
 215+ 4E8C ED 53 80 4D  	LD (SPRATR_DATA), DE
 216+ 4E90 3E 01        	LD A, 1
 217+ 4E92 32 7D 4D     	LD (SPRATR_INIT_STATUS), A
 218+ 4E95 C9           	RET
 219+ 4E96              ; *******************************************************************************************************
 220+ 4E96
 221+ 4E96              ; *******************************************************************************************************
 222+ 4E96              ; function to handle CALL SPRDISABLE basic extension
 223+ 4E96              ; disables sprites handling
 224+ 4E96              ; _SPRDISABLE
 225+ 4E96              ; resets variable SPRATR_INIT_STATUS
 226+ 4E96              SPRDISABLE:
 227+ 4E96 AF           	XOR A
 228+ 4E97 32 7D 4D     	LD (SPRATR_INIT_STATUS), A
 229+ 4E9A C9           	RET
 230+ 4E9B              ; *******************************************************************************************************
 231+ 4E9B
 232+ 4E9B              ; *******************************************************************************************************
 233+ 4E9B              ; function to handle CALL SPRSET basic extension
 234+ 4E9B              ; sets position, and optionally pattern and color of sprite
 235+ 4E9B              ; _SPRSET ( BYTE sprite_num , valid 0-31
 236+ 4E9B              ;			INT x,
 237+ 4E9B              ;			INT y,
 238+ 4E9B              ;			INT pattern, valid 0-63, otherwise ignored
 239+ 4E9B              ;			INT color, valid 0-15, otherwise ignored
 240+ 4E9B              SPRSET:
 241+ 4E9B 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 242+ 4E9E B7           	OR A
 243+ 4E9F 20 05        	JR NZ, .L1
 244+ 4EA1 1E 05        	LD E, 5 ; illegal function call
 245+ 4EA3 C3 28 57     	JP THROW_ERROR
 246+ 4EA6              .L1:
 247+ 4EA6              	; opening (
 248+ 4EA6 CD 08 57     	CALL CHKCHAR
 249+ 4EA9 28           	DB '('
 250+ 4EAA              	; get sprite number
 251+ 4EAA DD 21 1C 52  	LD IX, GETBYT
 252+ 4EAE CD 59 01     	CALL CALBAS
 253+ 4EB1 F5           	PUSH AF
 254+ 4EB2              	; comma
 255+ 4EB2 CD 08 57     	CALL CHKCHAR
 256+ 4EB5 2C           	DB ','
 257+ 4EB6              	; get x
 258+ 4EB6 DD 21 2F 54  	LD IX, FRMQNT
 259+ 4EBA CD 59 01     	CALL CALBAS
 260+ 4EBD D5           	PUSH DE
 261+ 4EBE              	; comma
 262+ 4EBE CD 08 57     	CALL CHKCHAR
 263+ 4EC1 2C           	DB ','
 264+ 4EC2              	; get y
 265+ 4EC2 DD 21 2F 54  	LD IX, FRMQNT
 266+ 4EC6 CD 59 01     	CALL CALBAS
 267+ 4EC9 D5           	PUSH DE
 268+ 4ECA              	; comma
 269+ 4ECA CD 08 57     	CALL CHKCHAR
 270+ 4ECD 2C           	DB ','
 271+ 4ECE              	; get pattern
 272+ 4ECE DD 21 2F 54  	LD IX, FRMQNT
 273+ 4ED2 CD 59 01     	CALL CALBAS
 274+ 4ED5 D5           	PUSH DE
 275+ 4ED6              	; comma
 276+ 4ED6 CD 08 57     	CALL CHKCHAR
 277+ 4ED9 2C           	DB ','
 278+ 4EDA              	; get color
 279+ 4EDA DD 21 2F 54  	LD IX, FRMQNT
 280+ 4EDE CD 59 01     	CALL CALBAS
 281+ 4EE1 D5           	PUSH DE
 282+ 4EE2              	; ending )
 283+ 4EE2 CD 08 57     	CALL CHKCHAR
 284+ 4EE5 29           	DB ')'
 285+ 4EE6
 286+ 4EE6                  ; save position in BASIC text
 287+ 4EE6 E5           	PUSH HL
 288+ 4EE7 DD E1        	POP IX
 289+ 4EE9
 290+ 4EE9 C1           	POP BC ; color
 291+ 4EEA D1           	POP DE ; pattern
 292+ 4EEB D9           	EXX
 293+ 4EEC C1           	POP BC ; y
 294+ 4EED D1           	POP DE ; x
 295+ 4EEE F1           	POP AF ; sprite number
 296+ 4EEF FE 20        	CP 32
 297+ 4EF1 38 05        	JR C, .L2
 298+ 4EF3 1E 05        	LD E, 5 ; illegal function call
 299+ 4EF5 C3 28 57     	JP THROW_ERROR
 300+ 4EF8              .L2:
 301+ 4EF8              	; find location in sprite attributes table
 302+ 4EF8 D5           	PUSH DE
 303+ 4EF9 CD 86 4D     	CALL GETnthSPRATTR
 304+ 4EFC D1           	POP DE
 305+ 4EFD              	; set y
 306+ 4EFD 71           	LD (HL), C
 307+ 4EFE 23           	INC HL
 308+ 4EFF 70           	LD (HL), B
 309+ 4F00 23           	INC HL
 310+ 4F01              	; set x
 311+ 4F01 73           	LD (HL), E
 312+ 4F02 23           	INC HL
 313+ 4F03 72           	LD (HL), D
 314+ 4F04 23           	INC HL
 315+ 4F05 E5           	PUSH HL
 316+ 4F06 D9           	EXX
 317+ 4F07 E1           	POP HL
 318+ 4F08              	; check if 0<=pattern<64
 319+ 4F08 7A           	LD A, D
 320+ 4F09 B7           	OR A
 321+ 4F0A 20 0B        	JR NZ, .L3
 322+ 4F0C 7B           	LD A, E
 323+ 4F0D FE 40        	CP 64
 324+ 4F0F 30 06        	JR NC, .L3
 325+ 4F11              	; set pattern
 326+ 4F11              	;ADD A, A
 327+ 4F11              	;ADD A, A
 328+ 4F11              	;ADD A, A
 329+ 4F11 77           	LD (HL), A
 330+ 4F12 23           	INC HL
 331+ 4F13 72           	LD (HL), D
 332+ 4F14 23           	INC HL
 333+ 4F15 18 02        	JR .L4
 334+ 4F17              .L3:
 335+ 4F17              	; skip pattern
 336+ 4F17 23          > INC HL
 336+ 4F18 23          > INC HL
 337+ 4F19              .L4:
 338+ 4F19              	; check if 0<=color<16
 339+ 4F19 78           	LD A, B
 340+ 4F1A B7           	OR A
 341+ 4F1B 20 08        	JR NZ, .L5
 342+ 4F1D 79           	LD A, C
 343+ 4F1E FE 10        	CP 16
 344+ 4F20 30 03        	JR NC, .L5
 345+ 4F22              	; set color
 346+ 4F22 71           	LD (HL), C
 347+ 4F23 23           	INC HL
 348+ 4F24 70           	LD (HL), B
 349+ 4F25
 350+ 4F25              .L5:
 351+ 4F25 DD E5        	PUSH IX
 352+ 4F27 E1           	POP HL
 353+ 4F28 C9           	RET
 354+ 4F29              ; *******************************************************************************************************
 355+ 4F29
 356+ 4F29              ; *******************************************************************************************************
 357+ 4F29              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4F29              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4F29              ; input DE=initial x
 360+ 4F29              ; input BC=initial y
 361+ 4F29              ; input IY=location where delta y,x are located
 362+ 4F29              ; modifies AF, HL, IX
 363+ 4F29              SPRSET_DELTA_POS:
 364+ 4F29 D5           	PUSH DE
 365+ 4F2A CD 86 4D     	CALL GETnthSPRATTR
 366+ 4F2D E5           	PUSH HL
 367+ 4F2E DD E1        	POP IX
 368+ 4F30 D1           	POP DE
 369+ 4F31              	; IX=sprite's y location
 370+ 4F31 FD 6E 00     	LD L, (IY)
 371+ 4F34 FD 66 01     	LD H, (IY+1)
 372+ 4F37 09           	ADD HL, BC
 373+ 4F38 DD 75 00     	LD (IX), L
 374+ 4F3B DD 74 01     	LD (IX+1), H
 375+ 4F3E FD 6E 02     	LD L, (IY+2)
 376+ 4F41 FD 66 03     	LD H, (IY+3)
 377+ 4F44 19           	ADD HL, DE
 378+ 4F45 DD 75 02     	LD (IX+2), L
 379+ 4F48 DD 74 03     	LD (IX+3), H
 380+ 4F4B C9           	RET
 381+ 4F4C              ; *******************************************************************************************************
 382+ 4F4C
 383+ 4F4C              ; *******************************************************************************************************
 384+ 4F4C              ; function to handle CALL SPRGRPMOV basic extension
 385+ 4F4C              ; sets position of a group of sprites described with
 386+ 4F4C              ; { int sprite_num, int delta_y, int delta_x } [count]
 387+ 4F4C              ; _SPRGRPMOV ( INT x,
 388+ 4F4C              ;			   INT y,
 389+ 4F4C              ;			   INT data_ptr,
 390+ 4F4C              ;			   BYTE count,
 391+ 4F4C              ; will put ram in page 0 also, page 1 is already there
 392+ 4F4C              SPRGRPMOV:
 393+ 4F4C 3A 7D 4D     	LD A, (SPRATR_INIT_STATUS)
 394+ 4F4F B7           	OR A
 395+ 4F50 20 05        	JR NZ, .L1
 396+ 4F52 1E 05        	LD E, 5 ; illegal function call
 397+ 4F54 C3 28 57     	JP THROW_ERROR
 398+ 4F57              .L1:
 399+ 4F57              	; opening (
 400+ 4F57 CD 08 57     	CALL CHKCHAR
 401+ 4F5A 28           	DB '('
 402+ 4F5B              	; get x
 403+ 4F5B DD 21 2F 54  	LD IX, FRMQNT
 404+ 4F5F CD 59 01     	CALL CALBAS
 405+ 4F62 D5           	PUSH DE
 406+ 4F63              	; comma
 407+ 4F63 CD 08 57     	CALL CHKCHAR
 408+ 4F66 2C           	DB ','
 409+ 4F67              	; get y
 410+ 4F67 DD 21 2F 54  	LD IX, FRMQNT
 411+ 4F6B CD 59 01     	CALL CALBAS
 412+ 4F6E D5           	PUSH DE
 413+ 4F6F              	; comma
 414+ 4F6F CD 08 57     	CALL CHKCHAR
 415+ 4F72 2C           	DB ','
 416+ 4F73              	; get data pointer
 417+ 4F73 DD 21 2F 54  	LD IX, FRMQNT
 418+ 4F77 CD 59 01     	CALL CALBAS
 419+ 4F7A D5           	PUSH DE
 420+ 4F7B              	; comma
 421+ 4F7B CD 08 57     	CALL CHKCHAR
 422+ 4F7E 2C           	DB ','
 423+ 4F7F              	; get count
 424+ 4F7F DD 21 1C 52  	LD IX, GETBYT
 425+ 4F83 CD 59 01     	CALL CALBAS
 426+ 4F86 F5           	PUSH AF
 427+ 4F87              	; ending )
 428+ 4F87 CD 08 57     	CALL CHKCHAR
 429+ 4F8A 29           	DB ')'
 430+ 4F8B
 431+ 4F8B E5           	PUSH HL
 432+ 4F8C DD E1        	POP IX
 433+ 4F8E
 434+ 4F8E C1           	POP BC ; count
 435+ 4F8F E1           	POP HL ; data pointer
 436+ 4F90 D9           	EXX
 437+ 4F91 C1           	POP BC ; y
 438+ 4F92 D1           	POP DE ; x
 439+ 4F93 D9           	EXX
 440+ 4F94
 441+ 4F94 DD E5        	PUSH IX ; save position in BASIC buffer
 442+ 4F96
 443+ 4F96 C5           	PUSH BC
 444+ 4F97 E5           	PUSH HL
 445+ 4F98 AF               XOR A
 446+ 4F99 CD FB 55         CALL GET_PAGE_INFO
 447+ 4F9C D9           	EXX
 448+ 4F9D E1           	POP HL
 449+ 4F9E F1           	POP AF
 450+ 4F9F D9           	EXX
 451+ 4FA0 C5               PUSH BC
 452+ 4FA1 D5               PUSH DE
 453+ 4FA2 D9           	EXX
 454+ 4FA3 F5           	PUSH AF
 455+ 4FA4 E5           	PUSH HL
 456+ 4FA5 D9           	EXX
 457+ 4FA6 3A 41 F3         LD A, (RAMAD0)
 458+ 4FA9 26 00            LD H, 0
 459+ 4FAB CD 42 56         CALL LOCAL_ENASLT
 460+ 4FAE FB           	EI
 461+ 4FAF E1           	POP HL
 462+ 4FB0 C1           	POP BC
 463+ 4FB1 CD BB 4F     	CALL .UPDATE_LOC
 464+ 4FB4 D1               POP DE
 465+ 4FB5 C1               POP BC
 466+ 4FB6 CD 32 56         CALL RESTORE_PAGE_INFO
 467+ 4FB9 E1           	POP HL
 468+ 4FBA C9           	RET
 469+ 4FBB
 470+ 4FBB              .UPDATE_LOC:
 471+ 4FBB              .L4:
 472+ 4FBB 7E           	LD A, (HL)
 473+ 4FBC 23           	INC HL
 474+ 4FBD 23           	INC HL
 475+ 4FBE E5           	PUSH HL
 476+ 4FBF FD E1        	POP IY
 477+ 4FC1 D9           	EXX
 478+ 4FC2 CD 29 4F     	CALL SPRSET_DELTA_POS
 479+ 4FC5 D9           	EXX
 480+ 4FC6 23          > INC HL
 480+ 4FC7 23          > INC HL
 480+ 4FC8 23          > INC HL
 480+ 4FC9 23          > INC HL
 481+ 4FCA 10 EF        	DJNZ .L4
 482+ 4FCC C9           	RET
 483+ 4FCD              ; *******************************************************************************************************
 484+ 4FCD
# file closed: asm\SPRITES.asm
 124  4FCD               ENDIF
 125  4FCD
 126  4FCD               IF (ANIM_CMDS == 1)
 127  4FCD               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4FCD              ; sprite animation routines
   2+ 4FCD
   3+ 4FCD              ; number of animation items and pointer
   4+ 4FCD              ANIMITEMNUM:
   5+ 4FCD 00            DB 0
   6+ 4FCE              ANIMITEMPTR:
   7+ 4FCE 6E 5F         DW EXT_END
   8+ 4FD0              ; number of animation definitions and pointer
   9+ 4FD0              ANIMDEFNUM:
  10+ 4FD0 00            DB 0
  11+ 4FD1              ANIMDEFPTR:
  12+ 4FD1 6E 5F         DW EXT_END
  13+ 4FD3              ; number of links between sprite and animation definitions
  14+ 4FD3              ANIMSPRNUM:
  15+ 4FD3 00            DB 0
  16+ 4FD4              ANIMSPRPTR:
  17+ 4FD4 6E 5F         DW EXT_END
  18+ 4FD6
  19+ 4FD6              ; ANIMATION ITEM
  20+ 4FD6              ; byte type = [0 - pattern and color change
  21+ 4FD6              ;              1 - pattern definition change ]
  22+ 4FD6              ; word ticks - number of ticks to hold this state
  23+ 4FD6              ; for type = 0
  24+ 4FD6              ;   byte pattern;
  25+ 4FD6              ;   byte color;
  26+ 4FD6              ; for type = 1
  27+ 4FD6              ;   work data_pointer;
  28+ 4FD6              ; total size = 5b
  29+ 4FD6
  30+ 4FD6              ; ANIMATION DEFINITION
  31+ 4FD6              ; byte number of items 1-15
  32+ 4FD6              ; byte[15] anim_item;
  33+ 4FD6              ; total size = 16b
  34+ 4FD6
  35+ 4FD6              ; SPRITE ANIMATION
  36+ 4FD6              ; +00 byte sprite number;
  37+ 4FD6              ; +01 word time;
  38+ 4FD6              ; +03 byte current item;
  39+ 4FD6              ; +04 byte animation definition;
  40+ 4FD6              ; +05 byte cyclic;
  41+ 4FD6              ; +06 byte active;
  42+ 4FD6              ; +07 byte reserved
  43+ 4FD6              ; total size = 8b
  44+ 4FD6
  45+ 4FD6              ; *******************************************************************************************************
  46+ 4FD6              ; helper function HL=A*5
  47+ 4FD6              ; changes HL,DE;
  48+ 4FD6              Ax5:
  49+ 4FD6 26 00            LD H,0
  50+ 4FD8 6F               LD L,A
  51+ 4FD9 54               LD D,H
  52+ 4FDA 5D               LD E,L
  53+ 4FDB 29               ADD HL,HL
  54+ 4FDC 29               ADD HL,HL
  55+ 4FDD 19               ADD HL,DE
  56+ 4FDE C9               RET
  57+ 4FDF              ; *******************************************************************************************************
  58+ 4FDF
  59+ 4FDF              ; *******************************************************************************************************
  60+ 4FDF              ; helper function gets pointer to n-th animation item
  61+ 4FDF              ; changes HL,DE;
  62+ 4FDF              GETnthANIMITEM:
  63+ 4FDF CD D6 4F         CALL Ax5
  64+ 4FE2 ED 5B CE 4F      LD DE,(ANIMITEMPTR)
  65+ 4FE6 19               ADD HL,DE
  66+ 4FE7 C9               RET
  67+ 4FE8              ; *******************************************************************************************************
  68+ 4FE8
  69+ 4FE8              ; *******************************************************************************************************
  70+ 4FE8              ; helper function gets pointer to n-th entry in animation definition
  71+ 4FE8              ; changes HL,DE;
  72+ 4FE8              GETnthANIMDEF:
  73+ 4FE8 26 00            LD H,0
  74+ 4FEA 6F               LD L,A
  75+ 4FEB CD F7 55         CALL HLx8
  76+ 4FEE ED 5B D1 4F      LD DE,(ANIMDEFPTR)
  77+ 4FF2 19               ADD HL,DE
  78+ 4FF3 C9               RET
  79+ 4FF4              ; *******************************************************************************************************
  80+ 4FF4
  81+ 4FF4              ; *******************************************************************************************************
  82+ 4FF4              ; helper function gets pointer to n-th entry in sprite animation
  83+ 4FF4              ; changes HL,DE;
  84+ 4FF4              GETnthSPRANIM:
  85+ 4FF4 26 00            LD H,0
  86+ 4FF6 6F               LD L,A
  87+ 4FF7 CD F6 55         CALL HLx16
  88+ 4FFA ED 5B D4 4F      LD DE,(ANIMSPRPTR)
  89+ 4FFE 19               ADD HL,DE
  90+ 4FFF C9               RET
  91+ 5000              ; *******************************************************************************************************
  92+ 5000
  93+ 5000              ; *******************************************************************************************************
  94+ 5000              ; function to handle CALL MAXANIMITEMS basic extension
  95+ 5000              ; MAXANIMITEMS (BYTE number)
  96+ 5000              ; sets new number and moves memory buffers as needed
  97+ 5000              MAXANIMITEMS:
  98+ 5000              	; opening (
  99+ 5000 CD 08 57     	CALL CHKCHAR
 100+ 5003 28           	DB '('
 101+ 5004              	; get value
 102+ 5004 DD 21 1C 52  	LD IX, GETBYT
 103+ 5008 CD 59 01     	CALL CALBAS
 104+ 500B F5               PUSH AF
 105+ 500C              	; ending )
 106+ 500C CD 08 57     	CALL CHKCHAR
 107+ 500F 29           	DB ')'
 108+ 5010 F1               POP AF
 109+ 5011
 110+ 5011              	; save position
 111+ 5011 E5           	PUSH HL
 112+ 5012              .ENTRY:
 113+ 5012 47               LD B,A
 114+ 5013 3A CD 4F         LD A,(ANIMITEMNUM)
 115+ 5016 90               SUB B
 116+ 5017 28 1F            JR Z, .EXIT; same value as before
 117+ 5019 FD 21 D1 4F      LD IY,ANIMDEFPTR
 118+ 501D FA 3B 50         JP M, .INCREASE
 119+ 5020                  ; new value is lower than previous one
 120+ 5020 CD 53 50         CALL .SIZEDIFF
 121+ 5023 CD 6E 50         CALL .DECREASE_COMMON
 122+ 5026 2A D4 4F         LD HL,(ANIMSPRPTR)
 123+ 5029 AF               XOR A
 124+ 502A ED 42            SBC HL,BC
 125+ 502C 22 D4 4F         LD (ANIMSPRPTR),HL
 126+ 502F              .E1:
 127+ 502F 2A 10 40         LD HL,(FREEMEMPTR)
 128+ 5032 AF               XOR A
 129+ 5033 ED 42            SBC HL,BC
 130+ 5035 22 10 40         LD (FREEMEMPTR),HL
 131+ 5038              .EXIT:
 132+ 5038 FB               EI
 133+ 5039 E1           	POP HL
 134+ 503A C9           	RET
 135+ 503B              .INCREASE:
 136+ 503B ED 44            NEG
 137+ 503D CD 53 50         CALL .SIZEDIFF
 138+ 5040 CD 9A 50         CALL .INCREASE_COMMON
 139+ 5043 2A D4 4F         LD HL,(ANIMSPRPTR)
 140+ 5046 09               ADD HL,BC
 141+ 5047 22 D4 4F         LD (ANIMSPRPTR),HL
 142+ 504A              .E2:
 143+ 504A 2A 10 40         LD HL,(FREEMEMPTR)
 144+ 504D 09               ADD HL,BC
 145+ 504E 22 10 40         LD (FREEMEMPTR),HL
 146+ 5051 18 E5            JR .EXIT
 147+ 5053              .SIZEDIFF:
 148+ 5053 CD D6 4F         CALL Ax5
 149+ 5056 78               LD A,B
 150+ 5057 32 CD 4F         LD (ANIMITEMNUM),A
 151+ 505A 44               LD B,H
 152+ 505B 4D               LD C,L
 153+ 505C C9               RET ; BC=size difference in bytes
 154+ 505D              .SIZETOMOVE:
 155+ 505D D5               PUSH DE
 156+ 505E 2A 10 40         LD HL,(FREEMEMPTR)
 157+ 5061 FD 5E 00         LD E,(IY)
 158+ 5064 FD 56 01         LD D,(IY+1)
 159+ 5067 AF               XOR A
 160+ 5068 ED 52            SBC HL,DE
 161+ 506A 44               LD B,H
 162+ 506B 4D               LD C,L
 163+ 506C D1               POP DE
 164+ 506D C9               RET
 165+ 506E              .DECREASE_COMMON:
 166+ 506E FD 6E 00         LD L,(IY)
 167+ 5071 FD 66 01         LD H,(IY+1)
 168+ 5074 AF               XOR A
 169+ 5075 ED 42            SBC HL,BC
 170+ 5077 EB               EX DE,HL
 171+ 5078 C5               PUSH BC
 172+ 5079 CD 5D 50         CALL .SIZETOMOVE
 173+ 507C F3               DI
 174+ 507D 78               LD A,B
 175+ 507E B1               OR C
 176+ 507F 28 08            JR Z,.L1
 177+ 5081 FD 6E 00         LD L,(IY)
 178+ 5084 FD 66 01         LD H,(IY+1)
 179+ 5087 ED B0            LDIR
 180+ 5089              .L1:
 181+ 5089 C1               POP BC
 182+ 508A FD 6E 00         LD L,(IY)
 183+ 508D FD 66 01         LD H,(IY+1)
 184+ 5090 AF               XOR A
 185+ 5091 ED 42            SBC HL,BC
 186+ 5093 FD 75 00         LD (IY),L
 187+ 5096 FD 74 01         LD (IY+1),H
 188+ 5099 C9               RET
 189+ 509A              .INCREASE_COMMON:
 190+ 509A 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 509D 2B               DEC HL
 192+ 509E AF               XOR A
 193+ 509F ED 42            SBC HL,BC
 194+ 50A1 EB               EX DE,HL
 195+ 50A2 C5               PUSH BC
 196+ 50A3 CD 5D 50         CALL .SIZETOMOVE
 197+ 50A6 F3               DI
 198+ 50A7 78               LD A,B
 199+ 50A8 B1               OR C
 200+ 50A9 28 06            JR Z,.L2
 201+ 50AB 2A 10 40         LD HL,(FREEMEMPTR)
 202+ 50AE 2B               DEC HL
 203+ 50AF ED B8            LDDR
 204+ 50B1              .L2:
 205+ 50B1 C1               POP BC
 206+ 50B2 FD 6E 00         LD L,(IY)
 207+ 50B5 FD 66 01         LD H,(IY+1)
 208+ 50B8 09               ADD HL,BC
 209+ 50B9 FD 75 00         LD (IY),L
 210+ 50BC FD 74 01         LD (IY+1),H
 211+ 50BF C9               RET
 212+ 50C0              ; *******************************************************************************************************
 213+ 50C0
 214+ 50C0              ; *******************************************************************************************************
 215+ 50C0              ; function to handle CALL ANIMITEMPAT basic extension
 216+ 50C0              ; ANIMITEMPAT ( BYTE id,
 217+ 50C0              ;               INT ticks,
 218+ 50C0              ;               BYTE pattern,
 219+ 50C0              ;               BYTE color )
 220+ 50C0              ; fills animation item data, returns an error if out of bounds
 221+ 50C0              ANIMITEMPAT:
 222+ 50C0                  ; opening (
 223+ 50C0 CD 08 57     	CALL CHKCHAR
 224+ 50C3 28           	DB '('
 225+ 50C4              	; get id
 226+ 50C4 DD 21 1C 52  	LD IX, GETBYT
 227+ 50C8 CD 59 01     	CALL CALBAS
 228+ 50CB F5               PUSH AF
 229+ 50CC                  ; check if out of bounds
 230+ 50CC 3C               INC A
 231+ 50CD 4F               LD C,A
 232+ 50CE 3A CD 4F         LD A,(ANIMITEMNUM)
 233+ 50D1 B9               CP C
 234+ 50D2 DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 235+ 50D5              	; comma
 236+ 50D5 CD 08 57     	CALL CHKCHAR
 237+ 50D8 2C           	DB ','
 238+ 50D9              	; get ticks
 239+ 50D9 DD 21 2F 54  	LD IX, FRMQNT
 240+ 50DD CD 59 01     	CALL CALBAS
 241+ 50E0 D5           	PUSH DE
 242+ 50E1              	; comma
 243+ 50E1 CD 08 57     	CALL CHKCHAR
 244+ 50E4 2C           	DB ','
 245+ 50E5              	; get pattern
 246+ 50E5 DD 21 1C 52  	LD IX, GETBYT
 247+ 50E9 CD 59 01     	CALL CALBAS
 248+ 50EC F5               PUSH AF
 249+ 50ED              	; comma
 250+ 50ED CD 08 57     	CALL CHKCHAR
 251+ 50F0 2C           	DB ','
 252+ 50F1              	; get color
 253+ 50F1 DD 21 1C 52  	LD IX, GETBYT
 254+ 50F5 CD 59 01     	CALL CALBAS
 255+ 50F8 F5               PUSH AF
 256+ 50F9              	; ending )
 257+ 50F9 CD 08 57     	CALL CHKCHAR
 258+ 50FC 29           	DB ')'
 259+ 50FD              .ENTRY:
 260+ 50FD E5               PUSH HL
 261+ 50FE DD E1            POP IX
 262+ 5100 D9               EXX
 263+ 5101 C1               POP BC ; color
 264+ 5102 D1               POP DE ; pattern
 265+ 5103 E1               POP HL ; ticks
 266+ 5104 D9               EXX
 267+ 5105 F1               POP AF
 268+ 5106 CD DF 4F         CALL GETnthANIMITEM
 269+ 5109 E5               PUSH HL
 270+ 510A FD E1            POP IY
 271+ 510C D9               EXX
 272+ 510D FD 36 00 00      LD (IY),0 ; type=0
 273+ 5111 FD 75 01         LD (IY+1),L
 274+ 5114 FD 74 02         LD (IY+2),H
 275+ 5117 FD 72 03         LD (IY+3),D
 276+ 511A FD 70 04         LD (IY+4),B
 277+ 511D
 278+ 511D DD E5            PUSH IX
 279+ 511F E1               POP HL
 280+ 5120 C9               RET
 281+ 5121              ; *******************************************************************************************************
 282+ 5121
 283+ 5121              ; *******************************************************************************************************
 284+ 5121              ; function to handle CALL ANIMITEMPTR basic extension
 285+ 5121              ; ANIMITEMPTR ( BYTE id,
 286+ 5121              ;               INT ticks,
 287+ 5121              ;               INT pointer,
 288+ 5121              ; fills animation item data, returns an error if out of bounds
 289+ 5121              ANIMITEMPTR_CMD:
 290+ 5121                  ; opening (
 291+ 5121 CD 08 57     	CALL CHKCHAR
 292+ 5124 28           	DB '('
 293+ 5125              	; get id
 294+ 5125 DD 21 1C 52  	LD IX, GETBYT
 295+ 5129 CD 59 01     	CALL CALBAS
 296+ 512C F5               PUSH AF
 297+ 512D                  ; check if out of bounds
 298+ 512D 3C               INC A
 299+ 512E 4F               LD C,A
 300+ 512F 3A CD 4F         LD A,(ANIMITEMNUM)
 301+ 5132 B9               CP C
 302+ 5133 DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 303+ 5136              	; comma
 304+ 5136 CD 08 57     	CALL CHKCHAR
 305+ 5139 2C           	DB ','
 306+ 513A              	; get ticks
 307+ 513A DD 21 2F 54  	LD IX, FRMQNT
 308+ 513E CD 59 01     	CALL CALBAS
 309+ 5141 D5           	PUSH DE
 310+ 5142              	; comma
 311+ 5142 CD 08 57     	CALL CHKCHAR
 312+ 5145 2C           	DB ','
 313+ 5146              	; get pointer
 314+ 5146 DD 21 2F 54  	LD IX, FRMQNT
 315+ 514A CD 59 01     	CALL CALBAS
 316+ 514D D5           	PUSH DE
 317+ 514E              	; ending )
 318+ 514E CD 08 57     	CALL CHKCHAR
 319+ 5151 29           	DB ')'
 320+ 5152              .ENTRY:
 321+ 5152 E5               PUSH HL
 322+ 5153 DD E1            POP IX
 323+ 5155 D9               EXX
 324+ 5156 D1               POP DE ; pointer
 325+ 5157 E1               POP HL ; ticks
 326+ 5158 D9               EXX
 327+ 5159 F1               POP AF
 328+ 515A CD DF 4F         CALL GETnthANIMITEM
 329+ 515D E5               PUSH HL
 330+ 515E FD E1            POP IY
 331+ 5160 D9               EXX
 332+ 5161 FD 36 00 01      LD (IY),1 ; type=1
 333+ 5165 FD 75 01         LD (IY+1),L
 334+ 5168 FD 74 02         LD (IY+2),H
 335+ 516B FD 73 03         LD (IY+3),E
 336+ 516E FD 72 04         LD (IY+4),D
 337+ 5171
 338+ 5171 DD E5            PUSH IX
 339+ 5173 E1               POP HL
 340+ 5174 C9               RET
 341+ 5175              ; *******************************************************************************************************
 342+ 5175
 343+ 5175              ; *******************************************************************************************************
 344+ 5175              ; function to handle CALL MAXANIMDEFS basic extension
 345+ 5175              ; MAXANIMDEFS (BYTE number)
 346+ 5175              ; sets new number and moves memory buffers as needed
 347+ 5175              MAXANIMDEFS:
 348+ 5175              	; opening (
 349+ 5175 CD 08 57     	CALL CHKCHAR
 350+ 5178 28           	DB '('
 351+ 5179              	; get value
 352+ 5179 DD 21 1C 52  	LD IX, GETBYT
 353+ 517D CD 59 01     	CALL CALBAS
 354+ 5180 F5               PUSH AF
 355+ 5181              	; ending )
 356+ 5181 CD 08 57     	CALL CHKCHAR
 357+ 5184 29           	DB ')'
 358+ 5185 F1               POP AF
 359+ 5186
 360+ 5186              	; save position
 361+ 5186 E5           	PUSH HL
 362+ 5187              .ENTRY:
 363+ 5187 47               LD B,A
 364+ 5188 3A D0 4F         LD A,(ANIMDEFNUM)
 365+ 518B 90               SUB B
 366+ 518C CA 38 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 367+ 518F FD 21 D4 4F      LD IY,ANIMSPRPTR
 368+ 5193 FA 9F 51         JP M, .INCREASE
 369+ 5196                  ; new value is lower than previous one
 370+ 5196 CD AA 51         CALL .SIZEDIFF
 371+ 5199 CD 6E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 372+ 519C C3 2F 50         JP MAXANIMITEMS.E1
 373+ 519F              .INCREASE:
 374+ 519F ED 44            NEG
 375+ 51A1 CD AA 51         CALL .SIZEDIFF
 376+ 51A4 CD 9A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 377+ 51A7 C3 4A 50         JP MAXANIMITEMS.E2
 378+ 51AA              .SIZEDIFF:
 379+ 51AA 26 00            LD H,0
 380+ 51AC 6F               LD L,A
 381+ 51AD CD F6 55         CALL HLx16
 382+ 51B0 78               LD A,B
 383+ 51B1 32 D0 4F         LD (ANIMDEFNUM),A
 384+ 51B4 44               LD B,H
 385+ 51B5 4D               LD C,L
 386+ 51B6 C9               RET ; BC=size difference in bytes
 387+ 51B7              ; *******************************************************************************************************
 388+ 51B7
 389+ 51B7              ; *******************************************************************************************************
 390+ 51B7              ; function to handle CALL ANIMDEF basic extension
 391+ 51B7              ; ANIMITEMPAT ( BYTE id,
 392+ 51B7              ;               BYTE size,
 393+ 51B7              ;               INT[] list )
 394+ 51B7              ; fills animation definition data, returns an error if out of bounds, or invalid type
 395+ 51B7              ANIMDEF:
 396+ 51B7                  ; opening (
 397+ 51B7 CD 08 57     	CALL CHKCHAR
 398+ 51BA 28           	DB '('
 399+ 51BB              	; get id
 400+ 51BB DD 21 1C 52  	LD IX, GETBYT
 401+ 51BF CD 59 01     	CALL CALBAS
 402+ 51C2 F5               PUSH AF
 403+ 51C3                  ; check if out of bounds
 404+ 51C3 3C               INC A
 405+ 51C4 4F               LD C,A
 406+ 51C5 3A D0 4F         LD A,(ANIMDEFNUM)
 407+ 51C8 B9               CP C
 408+ 51C9 DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 409+ 51CC              	; comma
 410+ 51CC CD 08 57     	CALL CHKCHAR
 411+ 51CF 2C           	DB ','
 412+ 51D0              	; get size
 413+ 51D0 DD 21 1C 52  	LD IX, GETBYT
 414+ 51D4 CD 59 01     	CALL CALBAS
 415+ 51D7 FE 10            CP 16
 416+ 51D9 D2 22 57         JP NC, OVERFLOW
 417+ 51DC B7               OR A
 418+ 51DD CA 22 57         JP Z, OVERFLOW
 419+ 51E0 F5           	PUSH AF
 420+ 51E1              	; comma
 421+ 51E1 CD 08 57     	CALL CHKCHAR
 422+ 51E4 2C           	DB ','
 423+ 51E5              	; get pointer to a list of animation items in integer array format
 424+ 51E5 3E 01            LD A,1
 425+ 51E7 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 426+ 51EA DD 21 A4 5E  	LD IX, PTRGET
 427+ 51EE CD 59 01     	CALL CALBAS
 428+ 51F1                  ; contrary to documentation we get a pointer to array dimension in BC
 429+ 51F1                  ; and type in VALTYP
 430+ 51F1 AF               XOR A
 431+ 51F2 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
 432+ 51F5 3A 63 F6         LD A,(VALTYP)
 433+ 51F8 FE 02            CP 2
 434+ 51FA C2 1A 57         JP NZ,TYPE_MISMATCH
 435+ 51FD 0A               LD A,(BC)
 436+ 51FE FE 01            CP 1
 437+ 5200 C2 1A 57         JP NZ,TYPE_MISMATCH
 438+ 5203 03               INC BC
 439+ 5204 0A               LD A,(BC)
 440+ 5205 D1               POP DE
 441+ 5206 D5               PUSH DE
 442+ 5207 3C               INC A
 443+ 5208 BA               CP D
 444+ 5209 DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 445+ 520C 03          > INC BC
 445+ 520D 03          > INC BC
 446+ 520E C5               PUSH BC
 447+ 520F              	; ending )
 448+ 520F CD 08 57     	CALL CHKCHAR
 449+ 5212 29           	DB ')'
 450+ 5213              .ENTRY:
 451+ 5213 E5               PUSH HL
 452+ 5214 DD E1            POP IX
 453+ 5216 D1               POP DE ; pointer to INT array
 454+ 5217 C1               POP BC ; B=item number
 455+ 5218 F1               POP AF ; id
 456+ 5219 D5               PUSH DE
 457+ 521A CD E8 4F         CALL GETnthANIMDEF
 458+ 521D D1               POP DE
 459+ 521E 70               LD (HL),B
 460+ 521F              .L1:
 461+ 521F 23               INC HL
 462+ 5220 1A               LD A,(DE)
 463+ 5221 13          > INC DE
 463+ 5222 13          > INC DE
 464+ 5223 77               LD (HL),A
 465+ 5224 10 F9            DJNZ .L1
 466+ 5226 DD E5            PUSH IX
 467+ 5228 E1               POP HL
 468+ 5229 C9               RET
 469+ 522A              ; *******************************************************************************************************
 470+ 522A
 471+ 522A              ; *******************************************************************************************************
 472+ 522A              ; function to handle CALL MAXANIMSPRS basic extension
 473+ 522A              ; MAXANIMSPRS (BYTE number)
 474+ 522A              ; sets new number and moves memory buffers as needed
 475+ 522A              MAXANIMSPRS:
 476+ 522A              	; opening (
 477+ 522A CD 08 57     	CALL CHKCHAR
 478+ 522D 28           	DB '('
 479+ 522E              	; get value
 480+ 522E DD 21 1C 52  	LD IX, GETBYT
 481+ 5232 CD 59 01     	CALL CALBAS
 482+ 5235 F5               PUSH AF
 483+ 5236              	; ending )
 484+ 5236 CD 08 57     	CALL CHKCHAR
 485+ 5239 29           	DB ')'
 486+ 523A F1               POP AF
 487+ 523B
 488+ 523B              	; save position
 489+ 523B E5           	PUSH HL
 490+ 523C              .ENTRY:
 491+ 523C 47               LD B,A
 492+ 523D 3A D3 4F         LD A,(ANIMSPRNUM)
 493+ 5240 90               SUB B
 494+ 5241 CA 38 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 495+ 5244 FD 21 10 40      LD IY,FREEMEMPTR
 496+ 5248 FA 54 52         JP M, .INCREASE
 497+ 524B                  ; new value is lower than previous one
 498+ 524B CD 73 52         CALL .SIZEDIFF
 499+ 524E CD 6E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 500+ 5251 C3 38 50         JP MAXANIMITEMS.EXIT
 501+ 5254              .INCREASE:
 502+ 5254 ED 44            NEG
 503+ 5256 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 504+ 5257 CD 73 52         CALL .SIZEDIFF
 505+ 525A CD 9A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 506+ 525D AF               XOR A
 507+ 525E ED 42            SBC HL,BC ; location of new stuff
 508+ 5260 F1               POP AF
 509+ 5261 47               LD B,A
 510+ 5262 11 08 00         LD DE,8
 511+ 5265 E5               PUSH HL
 512+ 5266 DD E1            POP IX
 513+ 5268              .L1:
 514+ 5268 DD 36 06 00      LD (IX+6),0
 515+ 526C DD 19            ADD IX,DE
 516+ 526E 10 F8            DJNZ .L1
 517+ 5270 C3 38 50         JP MAXANIMITEMS.EXIT
 518+ 5273              .SIZEDIFF:
 519+ 5273 26 00            LD H,0
 520+ 5275 6F               LD L,A
 521+ 5276 CD F7 55         CALL HLx8
 522+ 5279 78               LD A,B
 523+ 527A 32 D3 4F         LD (ANIMSPRNUM),A
 524+ 527D 44               LD B,H
 525+ 527E 4D               LD C,L
 526+ 527F C9               RET ; BC=size difference in bytes
 527+ 5280              ; *******************************************************************************************************
 528+ 5280
 529+ 5280              ; *******************************************************************************************************
 530+ 5280              ; function to handle CALL ANIMSPRITE basic extension
 531+ 5280              ; ANIMSPRITE ( BYTE id,
 532+ 5280              ;              BYTE sprite_number,
 533+ 5280              ;              BYTE animation_definition_id,
 534+ 5280              ;              BYTE cyclic_flag )
 535+ 5280              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 536+ 5280              ANIMSPRITE:
 537+ 5280                  ; opening (
 538+ 5280 CD 08 57     	CALL CHKCHAR
 539+ 5283 28           	DB '('
 540+ 5284              	; get sprite animation id
 541+ 5284 DD 21 1C 52  	LD IX, GETBYT
 542+ 5288 CD 59 01     	CALL CALBAS
 543+ 528B F5               PUSH AF
 544+ 528C 3C               INC A
 545+ 528D 4F               LD C,A
 546+ 528E 3A D3 4F         LD A,(ANIMSPRNUM)
 547+ 5291 B9               CP C
 548+ 5292 DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 549+ 5295              	; comma
 550+ 5295 CD 08 57     	CALL CHKCHAR
 551+ 5298 2C           	DB ','
 552+ 5299              	; get sprite number
 553+ 5299 DD 21 1C 52  	LD IX, GETBYT
 554+ 529D CD 59 01     	CALL CALBAS
 555+ 52A0 F5               PUSH AF
 556+ 52A1                  ; check if out of bounds
 557+ 52A1 FE 20            CP 32
 558+ 52A3 D2 1E 57         JP NC, SUBSCRIPT_OUT_OF_RANGE
 559+ 52A6              	; comma
 560+ 52A6 CD 08 57     	CALL CHKCHAR
 561+ 52A9 2C           	DB ','
 562+ 52AA              	; get animation definition id
 563+ 52AA DD 21 1C 52  	LD IX, GETBYT
 564+ 52AE CD 59 01     	CALL CALBAS
 565+ 52B1 F5               PUSH AF
 566+ 52B2 3C               INC A
 567+ 52B3 4F               LD C,A
 568+ 52B4 3A D0 4F         LD A,(ANIMDEFNUM)
 569+ 52B7 B9               CP C
 570+ 52B8 DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 571+ 52BB              	; comma
 572+ 52BB CD 08 57     	CALL CHKCHAR
 573+ 52BE 2C           	DB ','
 574+ 52BF              	; get cyclic flag
 575+ 52BF DD 21 1C 52  	LD IX, GETBYT
 576+ 52C3 CD 59 01         CALL CALBAS
 577+ 52C6 F5           	PUSH AF
 578+ 52C7              	; ending )
 579+ 52C7 CD 08 57     	CALL CHKCHAR
 580+ 52CA 29           	DB ')'
 581+ 52CB              .ENTRY:
 582+ 52CB E5               PUSH HL
 583+ 52CC DD E1            POP IX
 584+ 52CE D9               EXX
 585+ 52CF D1               POP DE ; cyclic
 586+ 52D0 C1               POP BC ; animation definition id
 587+ 52D1 E1               POP HL ; sprite number
 588+ 52D2 D9               EXX
 589+ 52D3 F1               POP AF ; sprite animation id
 590+ 52D4 CD F4 4F         CALL GETnthSPRANIM
 591+ 52D7 E5               PUSH HL
 592+ 52D8 FD E1            POP IY
 593+ 52DA D9               EXX
 594+ 52DB FD 74 00         LD (IY),H
 595+ 52DE FD 70 04         LD (IY+4),B
 596+ 52E1 FD 72 05         LD (IY+5),D
 597+ 52E4                  ;LD (IY+6),0
 598+ 52E4 DD E5            PUSH IX
 599+ 52E6 E1               POP HL
 600+ 52E7 C9               RET
 601+ 52E8              ; *******************************************************************************************************
 602+ 52E8
 603+ 52E8              ; *******************************************************************************************************
 604+ 52E8              ; function to handle CALL ANIMSTART basic extension
 605+ 52E8              ; two forms
 606+ 52E8              ; ANIMSTART ( BYTE id )
 607+ 52E8              ; or
 608+ 52E8              ; ANIMSTART ( BYTE item_number,
 609+ 52E8              ;             INT[] sprite_animations )
 610+ 52E8              ; sets active flag to 1
 611+ 52E8              ANIMSTART:
 612+ 52E8 3E 01            LD A,1
 613+ 52EA 18 01            JR ANIMSTARTSTOP_COMMON
 614+ 52EC              ; *******************************************************************************************************
 615+ 52EC              ; *******************************************************************************************************
 616+ 52EC              ; function to handle CALL ANIMSTOP basic extension
 617+ 52EC              ; two forms
 618+ 52EC              ; ANIMSTOP ( BYTE id )
 619+ 52EC              ; or
 620+ 52EC              ; ANIMSTOP ( BYTE item_number,
 621+ 52EC              ;            INT[] sprite_animations )
 622+ 52EC              ; sets active flag to 1
 623+ 52EC              ANIMSTOP:
 624+ 52EC AF               XOR A
 625+ 52ED              ANIMSTARTSTOP_COMMON:
 626+ 52ED 32 6A 53         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
 627+ 52F0              ; *******************************************************************************************************
 628+ 52F0                  ; opening (
 629+ 52F0 CD 08 57     	CALL CHKCHAR
 630+ 52F3 28           	DB '('
 631+ 52F4              	; get sprite animation id or array size
 632+ 52F4 DD 21 1C 52  	LD IX,GETBYT
 633+ 52F8 CD 59 01     	CALL CALBAS
 634+ 52FB F5               PUSH AF
 635+ 52FC                  ; check if comma present
 636+ 52FC CD 12 57         CALL GETPREVCHAR
 637+ 52FF 23               INC HL
 638+ 5300 FE 2C            CP ','
 639+ 5302 28 0C            JR Z,.L1
 640+ 5304 FE 29            CP ')'
 641+ 5306 C2 26 57         JP NZ,SYNTAX_ERROR
 642+ 5309                  ; ok so single argument variant
 643+ 5309 F1               POP AF
 644+ 530A E5               PUSH HL
 645+ 530B CD 56 53         CALL .SETVALUE
 646+ 530E E1               POP HL
 647+ 530F C9               RET
 648+ 5310              .L1:
 649+ 5310                  ; array of items
 650+ 5310              	; get pointer to a list of animation items in integer array format
 651+ 5310 3E 01            LD A,1
 652+ 5312 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 653+ 5315 DD 21 A4 5E  	LD IX, PTRGET
 654+ 5319 CD 59 01     	CALL CALBAS
 655+ 531C                  ; contrary to documentation we get a pointer to array dimension in BC
 656+ 531C                  ; and type in VALTYP
 657+ 531C AF               XOR A
 658+ 531D 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
 659+ 5320 3A 63 F6         LD A,(VALTYP)
 660+ 5323 FE 02            CP 2
 661+ 5325 C2 1A 57         JP NZ,TYPE_MISMATCH
 662+ 5328 0A               LD A,(BC)
 663+ 5329 FE 01            CP 1
 664+ 532B C2 1A 57         JP NZ,TYPE_MISMATCH
 665+ 532E 03               INC BC
 666+ 532F 0A               LD A,(BC)
 667+ 5330 D1               POP DE
 668+ 5331 D5               PUSH DE
 669+ 5332 3C               INC A
 670+ 5333 BA               CP D
 671+ 5334 DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 672+ 5337 03          > INC BC
 672+ 5338 03          > INC BC
 673+ 5339 C5               PUSH BC
 674+ 533A              	; ending )
 675+ 533A CD 08 57     	CALL CHKCHAR
 676+ 533D 29           	DB ')'
 677+ 533E D1               POP DE ; array pointer
 678+ 533F C1               POP BC ; number of items
 679+ 5340 78               LD A,B
 680+ 5341 B7               OR A
 681+ 5342 CA 1E 57         JP Z,SUBSCRIPT_OUT_OF_RANGE
 682+ 5345 E5               PUSH HL
 683+ 5346 F3               DI
 684+ 5347              .L2:
 685+ 5347 C5               PUSH BC
 686+ 5348 1A               LD A,(DE)
 687+ 5349 13          > INC DE
 687+ 534A 13          > INC DE
 688+ 534B D5               PUSH DE
 689+ 534C CD 56 53         CALL .SETVALUE
 690+ 534F D1               POP DE
 691+ 5350 C1               POP BC
 692+ 5351 10 F4            DJNZ .L2
 693+ 5353 FB               EI
 694+ 5354 E1               POP HL
 695+ 5355 C9               RET
 696+ 5356
 697+ 5356              .SETVALUE:
 698+ 5356 47               LD B,A
 699+ 5357 3C               INC A
 700+ 5358 4F               LD C,A
 701+ 5359 3A D3 4F         LD A,(ANIMSPRNUM)
 702+ 535C B9               CP C
 703+ 535D DA 1E 57         JP C,SUBSCRIPT_OUT_OF_RANGE
 704+ 5360 78               LD A,B
 705+ 5361 CD F4 4F         CALL GETnthSPRANIM
 706+ 5364 E5               PUSH HL
 707+ 5365 DD E1            POP IX
 708+ 5367              .VALUE:
 709+ 5367 DD 36 06 01      LD (IX+6),1 ; active flag
 710+ 536B                  ; following stuff is needed to start only, but code sharing
 711+ 536B AF               XOR A
 712+ 536C DD 77 03         LD (IX+3),A ; current item
 713+ 536F DD 7E 04         LD A,(IX+4) ; animation definition ID
 714+ 5372 CD 1C 54         CALL INIT_CURRENT_ANIMATION
 715+ 5375 C9               RET
 716+ 5376              ; *******************************************************************************************************
 717+ 5376
 718+ 5376              ; *******************************************************************************************************
 719+ 5376              ; function processes animations during vblank period
 720+ 5376              PROCESS_ANIMATIONS:
 721+ 5376 3A D3 4F         LD A,(ANIMSPRNUM)
 722+ 5379 B7               OR A
 723+ 537A C8               RET Z; no animations defined
 724+ 537B 47               LD B,A
 725+ 537C DD 2A D4 4F      LD IX,(ANIMSPRPTR)
 726+ 5380              .L1:
 727+ 5380 C5               PUSH BC
 728+ 5381 DD 7E 06         LD A,(IX+6); active
 729+ 5384 B7               OR A
 730+ 5385 CA F8 53         JP Z,.SKIP ; inactive animation
 731+ 5388 DD 6E 01         LD L,(IX+1)
 732+ 538B DD 66 02         LD H,(IX+2) ; HL=end time
 733+ 538E ED 5B 9E FC      LD DE,(JIFFY)
 734+ 5392 AF               XOR A
 735+ 5393 ED 52            SBC HL,DE
 736+ 5395 F2 F8 53         JP P,.SKIP ; time until next animation item not yet reached
 737+ 5398 DD 34 03         INC (IX+3) ; current animation item
 738+ 539B DD 4E 04         LD C,(IX+4) ; animation definition ID
 739+ 539E 0C               INC C
 740+ 539F 3A D0 4F         LD A,(ANIMDEFNUM)
 741+ 53A2 B9               CP C
 742+ 53A3 30 07            JR NC,.L2
 743+ 53A5                  ; given animation item is outside of bounds, deactivate animation
 744+ 53A5              .STOPANIM:
 745+ 53A5 DD 36 06 00      LD (IX+6),0
 746+ 53A9 C3 F8 53         JP .SKIP
 747+ 53AC              .L2:
 748+ 53AC 0D               DEC C
 749+ 53AD 79               LD A,C
 750+ 53AE CD 1C 54         CALL INIT_CURRENT_ANIMATION
 751+ 53B1 38 F2            JR C, .STOPANIM
 752+ 53B3 FD 7E 00         LD A,(IY) ; type of animation item
 753+ 53B6 B7               OR A
 754+ 53B7 CA 01 54         JP Z,.L4 ; change pattern and/or color
 755+ 53BA                  ; change sprite pattern definition
 756+ 53BA DD 7E 00         LD A,(IX) ; sprite number
 757+ 53BD CD 86 4D         CALL GETnthSPRATTR
 758+ 53C0 23          > INC HL ; skip y and x
 758+ 53C1 23          > INC HL
 758+ 53C2 23          > INC HL
 758+ 53C3 23          > INC HL
 759+ 53C4 7E               LD A,(HL); current pattern
 760+ 53C5 26 00            LD H,0
 761+ 53C7 6F               LD L,A
 762+ 53C8 3A E0 F3         LD A,(REG1SAV)
 763+ 53CB E6 02            AND 2
 764+ 53CD 20 07            JR NZ,.L6
 765+ 53CF                  ; 8x8 sprite
 766+ 53CF CD F7 55         CALL HLx8
 767+ 53D2 06 08            LD B,8
 768+ 53D4 18 05            JR .L5
 769+ 53D6              .L6:
 770+ 53D6 CD F5 55         CALL HLx32
 771+ 53D9 06 20            LD B,32
 772+ 53DB              .L5:
 773+ 53DB 3A AF FC     	LD A, (SCRMOD)
 774+ 53DE 3D           	DEC A
 775+ 53DF 28 06        	JR Z, .L7 ; screen 1
 776+ 53E1                  ; screen 2
 777+ 53E1 ED 5B CF F3      LD DE,(GRPPAT)
 778+ 53E5 18 04            JR .L8
 779+ 53E7              .L7:
 780+ 53E7 ED 5B C5 F3      LD DE,(T32PAT)
 781+ 53EB              .L8:
 782+ 53EB 19               ADD HL,DE
 783+ 53EC CD E4 55         CALL SETWRT_LOCAL
 784+ 53EF FD 6E 03         LD L,(IY+3)
 785+ 53F2 FD 66 04         LD H,(IY+4) ; pointer to sprite patter data
 786+ 53F5 CD EF 55         CALL BBYTECOPY
 787+ 53F8              .SKIP:
 788+ 53F8 11 08 00         LD DE,8
 789+ 53FB DD 19            ADD IX,DE
 790+ 53FD C1               POP BC
 791+ 53FE 10 80            DJNZ .L1
 792+ 5400 C9               RET
 793+ 5401              .L4:
 794+ 5401                  ; change pattern and color in sprite attributes table
 795+ 5401 DD 7E 00         LD A,(IX) ; sprite number
 796+ 5404 CD 86 4D         CALL GETnthSPRATTR
 797+ 5407 23          > INC HL ; skip y and x
 797+ 5408 23          > INC HL
 797+ 5409 23          > INC HL
 797+ 540A 23          > INC HL
 798+ 540B FD 7E 03         LD A,(IY+3) ; new pattern
 799+ 540E 77               LD (HL),A
 800+ 540F 23          > INC HL
 800+ 5410 23          > INC HL
 801+ 5411 FD 7E 04         LD A,(IY+4) ; new color
 802+ 5414 77               LD (HL),A
 803+ 5415 2A 7E 4D         LD HL,(SPRATR_UPDATE_FLAG)
 804+ 5418 36 01            LD (HL),1
 805+ 541A 18 DC            JR .SKIP
 806+ 541C              ; *******************************************************************************************************
 807+ 541C
 808+ 541C              ; *******************************************************************************************************
 809+ 541C              ; function will setup sprite animation after current item change
 810+ 541C              ; input A=current animation
 811+ 541C              ; input IX=pointer to sprite animation
 812+ 541C              ; output IY=pointer to animation item
 813+ 541C              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
 814+ 541C              ; basically sets new end time for current animation
 815+ 541C              INIT_CURRENT_ANIMATION:
 816+ 541C CD E8 4F         CALL GETnthANIMDEF
 817+ 541F 7E               LD A,(HL); number of animation items in the animation definition
 818+ 5420 DD BE 03         CP (IX+3) ; current animation item
 819+ 5423 20 0A            JR NZ,.L3 ; last item not reached
 820+ 5425                  ; last item reached
 821+ 5425 DD 7E 05         LD A,(IX+5) ; cyclic flag
 822+ 5428 B7               OR A
 823+ 5429 28 2D            JR Z,.ERROR ; non-cyclic animation
 824+ 542B                  ; cyclic animation, restart
 825+ 542B DD 36 03 00      LD (IX+3),0; current item
 826+ 542F              .L3:
 827+ 542F                  ; HL = animation definition
 828+ 542F 23               INC HL ; skip animation definition size field
 829+ 5430 16 00            LD D,0
 830+ 5432 DD 5E 03         LD E,(IX+3); current item
 831+ 5435 19               ADD HL,DE
 832+ 5436 4E               LD C,(HL) ; current animation item
 833+ 5437 0C               INC C
 834+ 5438 3A CD 4F         LD A,(ANIMITEMNUM)
 835+ 543B B9               CP C
 836+ 543C 38 1A            JR C,.ERROR ; invalid animation item, stop animation
 837+ 543E 0D               DEC C
 838+ 543F 79               LD A,C
 839+ 5440 CD DF 4F         CALL GETnthANIMITEM
 840+ 5443 E5               PUSH HL
 841+ 5444 FD E1            POP IY ; IY=animation item
 842+ 5446 2A 9E FC         LD HL,(JIFFY)
 843+ 5449 FD 5E 01         LD E,(IY+1)
 844+ 544C FD 56 02         LD D,(IY+2) ; duration
 845+ 544F 19               ADD HL,DE
 846+ 5450 DD 75 01         LD (IX+1),L
 847+ 5453 DD 74 02         LD (IX+2),H ; end time for current item
 848+ 5456              .EXIT:
 849+ 5456 AF               XOR A
 850+ 5457 C9               RET
 851+ 5458              .ERROR:
 852+ 5458 37               SCF
 853+ 5459 C9               RET
 854+ 545A              ; *******************************************************************************************************
# file closed: asm\ANIMATION.asm
 128  545A               ENDIF
 129  545A
 130  545A              ; temp variables for BLIT, TILE functions
 131  545A               IF (BLIT_CMDS + TILE_CMDS > 0)
 132  545A              BLIT_TMP:
 133  545A              TILETMP1:
 134  545A              BLIT_TMP1:
 135  545A 00 00         DW 0
 136  545C              TILETMP2:
 137  545C              BLIT_TMP2:
 138  545C 00 00         DW 0
 139  545E                IFDEF CMDS_WITH_PARAMETERS
 140  545E              BLIT_STRUCT:
 141  545E 00 00 00...   DS 17
 142  5462                ENDIF
 143  5462               ENDIF
 144  546F
 145  546F               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS > 0)
 146  546F              VRAM_UPDATE_IN_PROGRESS:
 147  546F 00            DB 0
 148  5470               ENDIF
 149  5470
 150  5470              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 151  5470              ; per starting letter, if no commands with this letter, NULL value
 152  5470              CMDS:
 153  5470               IF (ANIM_CMDS == 1)
 154  5470 99 55        	DW CMDS_A ;
 155  5472               ELSE
 156  5472 ~                DW 0 ; A
 157  5472               ENDIF
 158  5472               IF (BLIT_CMDS + BOX_CMDS > 0)
 159  5472 64 55            DW CMDS_B ; B
 160  5474               ELSE
 161  5474 ~            	DW 0
 162  5474               ENDIF
 163  5474 00 00            DW 0 ; C
 164  5476 00 00            DW 0 ; D
 165  5478 00 00            DW 0 ; E
 166  547A               IF (VRAM_CMDS + RAM_CMDS > 0)
 167  547A E2 54            DW CMDS_F; F
 168  547C               ELSE
 169  547C ~            	DW 0
 170  547C               ENDIF
 171  547C               IF (GENCAL_CMD > 0)
 172  547C F5 54            DW CMDS_G; G
 173  547E               ELSE
 174  547E ~            	DW 0
 175  547E               ENDIF
 176  547E 00 00            DW 0 ; H
 177  5480 00 00            DW 0 ; I
 178  5482 00 00            DW 0 ; J
 179  5484 00 00            DW 0 ; K
 180  5486 00 00            DW 0 ; L
 181  5488               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 182  5488 A4 54            DW CMDS_M ; M
 183  548A               ELSE
 184  548A ~            	DW 0
 185  548A               ENDIF
 186  548A 00 00            DW 0 ; N
 187  548C 00 00            DW 0 ; O
 188  548E 00 00            DW 0 ; P
 189  5490 00 00            DW 0 ; Q
 190  5492 00 00            DW 0 ; R
 191  5494               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 192  5494 09 55            DW CMDS_S ; S
 193  5496               ELSE
 194  5496 ~            	DW 0
 195  5496               ENDIF
 196  5496               IF (TILE_CMDS > 0)
 197  5496 84 55            DW CMDS_T ; T
 198  5498               ELSE
 199  5498 ~            	DW 0
 200  5498               ENDIF
 201  5498 00 00            DW 0 ; U
 202  549A               IF (VRAM_CMDS > 0)
 203  549A FF 54            DW CMDS_V ; V
 204  549C               ELSE
 205  549C ~            	DW 0
 206  549C               ENDIF
 207  549C 00 00            DW 0 ; W
 208  549E 00 00            DW 0 ; X
 209  54A0 00 00            DW 0 ; Y
 210  54A2 00 00            DW 0 ; Z
 211  54A4
 212  54A4              CMDS_M:
 213  54A4               IF (VRAM_CMDS == 1)
 214  54A4 4D 45 4D 56      DB "MEMVRM", 0
 214  54A8 52 4D 00
 215  54AB 79 58            DW MEMVRM
 216  54AD               ENDIF
 217  54AD               IF (RAM_CMDS == 1)
 218  54AD 4D 45 4D 43  	DB "MEMCPY", 0
 218  54B1 50 59 00
 219  54B4 2F 57        	DW MEMCPY
 220  54B6               ENDIF
 221  54B6               IF (ANIM_CMDS == 1)
 222  54B6 4D 41 58 41  	DB "MAXANIMITEMS",0
 222  54BA 4E 49 4D 49
 222  54BE 54 45 4D 53
 222  54C2 00
 223  54C3 00 50        	DW MAXANIMITEMS
 224  54C5 4D 41 58 41  	DB "MAXANIMDEFS",0
 224  54C9 4E 49 4D 44
 224  54CD 45 46 53 00
 225  54D1 75 51        	DW MAXANIMDEFS
 226  54D3 4D 41 58 41  	DB "MAXANIMSPRS",0
 226  54D7 4E 49 4D 53
 226  54DB 50 52 53 00
 227  54DF 2A 52        	DW MAXANIMSPRS
 228  54E1               ENDIF
 229  54E1               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 230  54E1 00           	DB 0
 231  54E2               ENDIF
 232  54E2              CMDS_F:
 233  54E2               IF (VRAM_CMDS == 1)
 234  54E2 46 49 4C 56      DB "FILVRM", 0
 234  54E6 52 4D 00
 235  54E9 72 57            DW FILVRM
 236  54EB               ENDIF
 237  54EB               IF (RAM_CMDS == 1)
 238  54EB 46 49 4C 52      DB "FILRAM", 0
 238  54EF 41 4D 00
 239  54F2 C2 57            DW FILRAM
 240  54F4               ENDIF
 241  54F4               IF (VRAM_CMDS + RAM_CMDS > 0)
 242  54F4 00               DB 0
 243  54F5               ENDIF
 244  54F5              CMDS_G:
 245  54F5               IF (GENCAL_CMD == 1)
 246  54F5 47 45 4E 43      DB "GENCAL", 0
 246  54F9 41 4C 00
 247  54FC 20 58            DW GENCAL
 248  54FE               ENDIF
 249  54FE               IF (GENCAL_CMD > 0)
 250  54FE 00           	DB	0
 251  54FF               ENDIF
 252  54FF              CMDS_V:
 253  54FF               IF (VRAM_CMDS == 1)
 254  54FF 56 52 4D 4D  	DB "VRMMEM", 0
 254  5503 45 4D 00
 255  5506 FA 58        	DW VRMMEM
 256  5508               ENDIF
 257  5508               IF (VRAM_CMDS > 0)
 258  5508 00           	DB 0
 259  5509               ENDIF
 260  5509              CMDS_S:
 261  5509               IF (SPRITE_CMDS == 1)
 262  5509 53 50 52 53  	DB "SPRSET", 0
 262  550D 45 54 00
 263  5510 9B 4E        	DW SPRSET
 264  5512 53 50 52 47  	DB "SPRGRPMOV", 0
 264  5516 52 50 4D 4F
 264  551A 56 00
 265  551C 4C 4F        	DW SPRGRPMOV
 266  551E               ENDIF
 267  551E               IF (SOUND_CMDS == 1)
 268  551E 53 4E 44 53  	DB "SNDSFX", 0
 268  5522 46 58 00
 269  5525 DB 59        	DW SNDSFX
 270  5527 53 4E 44 50  	DB "SNDPLYON", 0
 270  552B 4C 59 4F 4E
 270  552F 00
 271  5530 A5 59        	DW SNDPLYON
 272  5532 53 4E 44 50  	DB "SNDPLYOFF", 0
 272  5536 4C 59 4F 46
 272  553A 46 00
 273  553C B8 59        	DW SNDPLYOFF
 274  553E 53 4E 44 50  	DB "SNDPLYINI", 0
 274  5542 4C 59 49 4E
 274  5546 49 00
 275  5548 5B 59        	DW SNDPLYINIT
 276  554A               ENDIF
 277  554A               IF (SPRITE_CMDS == 1)
 278  554A 53 50 52 45  	DB "SPRENABLE", 0
 278  554E 4E 41 42 4C
 278  5552 45 00
 279  5554 46 4E        	DW SPRENABLE
 280  5556 53 50 52 44  	DB "SPRDISABLE", 0
 280  555A 49 53 41 42
 280  555E 4C 45 00
 281  5561 96 4E        	DW SPRDISABLE
 282  5563               ENDIF
 283  5563               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 284  5563 00           	DB 0
 285  5564               ENDIF
 286  5564              CMDS_B:
 287  5564               IF (BLIT_CMDS == 1)
 288  5564 42 4C 49 54  	DB "BLIT", 0
 288  5568 00
 289  5569 B2 5B        	DW BLIT
 290  556B               ENDIF
 291  556B               IF (BOX_CMDS == 1)
 292  556B 42 4F 58 4D  	DB "BOXMEMCPY", 0
 292  556F 45 4D 43 50
 292  5573 59 00
 293  5575 EA 5E        	DW BOXMEMCPY
 294  5577 42 4F 58 4D  	DB "BOXMEMVRM", 0
 294  557B 45 4D 56 52
 294  557F 4D 00
 295  5581 1E 5F        	DW BOXMEMVRM
 296  5583               ENDIF
 297  5583               IF (BLIT_CMDS + BOX_CMDS > 0)
 298  5583 00           	DB 0
 299  5584               ENDIF
 300  5584              CMDS_T:
 301  5584               IF (TILE_CMDS == 1)
 302  5584 54 49 4C 45  	DB "TILERAM", 0
 302  5588 52 41 4D 00
 303  558C F6 5C        	DW TILERAM
 304  558E 54 49 4C 45  	DB "TILEVRM", 0
 304  5592 56 52 4D 00
 305  5596 F9 5D        	DW TILEVRM
 306  5598               ENDIF
 307  5598               IF (TILE_CMDS > 0)
 308  5598 00           	DB 0
 309  5599               ENDIF
 310  5599              CMDS_A:
 311  5599               IF (ANIM_CMDS == 1)
 312  5599 41 4E 49 4D  	DB "ANIMSTART",0
 312  559D 53 54 41 52
 312  55A1 54 00
 313  55A3 E8 52        	DW ANIMSTART
 314  55A5 41 4E 49 4D  	DB "ANIMSTOP",0
 314  55A9 53 54 4F 50
 314  55AD 00
 315  55AE EC 52        	DW ANIMSTOP
 316  55B0 41 4E 49 4D  	DB "ANIMITEMPAT",0
 316  55B4 49 54 45 4D
 316  55B8 50 41 54 00
 317  55BC C0 50        	DW ANIMITEMPAT
 318  55BE 41 4E 49 4D  	DB "ANIMITEMPTR",0
 318  55C2 49 54 45 4D
 318  55C6 50 54 52 00
 319  55CA 21 51        	DW ANIMITEMPTR_CMD
 320  55CC 41 4E 49 4D  	DB "ANIMDEF",0
 320  55D0 44 45 46 00
 321  55D4 B7 51        	DW ANIMDEF
 322  55D6 41 4E 49 4D  	DB "ANIMSPRITE",0
 322  55DA 53 50 52 49
 322  55DE 54 45 00
 323  55E1 80 52        	DW ANIMSPRITE
 324  55E3 00           	DB 0
 325  55E4               ENDIF
 326  55E4
 327  55E4               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 328  55E4              ; ****************************************************************************************************
 329  55E4              ; function sets VRAM address
 330  55E4              ; input HL=address
 331  55E4              ; modifies AF
 332  55E4              SETWRT_LOCAL:
 333  55E4 7D           	LD	A, L
 334  55E5 D3 99        	OUT	(099H), A
 335  55E7 7C           	LD	A, H
 336  55E8 E6 3F        	AND	03FH
 337  55EA F6 40        	OR	040H
 338  55EC D3 99        	OUT	(099H), A
 339  55EE C9           	RET
 340  55EF              ; ****************************************************************************************************
 341  55EF               ENDIF
 342  55EF
 343  55EF               IF (VRAM_CMDS + TILE_CMDS > 0)
 344  55EF              ; ****************************************************************************************************
 345  55EF              ; function copies data from RAM to VRAM
 346  55EF              ; input HL=address in RAM
 347  55EF              ; input B=count
 348  55EF              ; modifies AF
 349  55EF              BBYTECOPY:
 350  55EF ED A3        	OUTI
 351  55F1 C2 EF 55     	JP	NZ, BBYTECOPY
 352  55F4 C9           	RET
 353  55F5              ; ****************************************************************************************************
 354  55F5               ENDIF
 355  55F5
 356  55F5              ; ****************************************************************************************************
 357  55F5              ; function multiplies HL by 32
 358  55F5              HLx32:
 359  55F5 29           	ADD HL,HL
 360  55F6              ; ****************************************************************************************************
 361  55F6              ; function multiplies HL by 16
 362  55F6              HLx16:
 363  55F6 29           	ADD HL,HL
 364  55F7              ; ****************************************************************************************************
 365  55F7              ; function multiplies HL by 8
 366  55F7              HLx8:
 367  55F7 29          > ADD HL, HL
 367  55F8 29          > ADD HL, HL
 367  55F9 29          > ADD HL, HL
 368  55FA C9           	RET
 369  55FB              ; ****************************************************************************************************
 370  55FB
 371  55FB              ; ****************************************************************************************************
 372  55FB              ; function gets slot and subslot data for specific page
 373  55FB              ; input A=page (0, 1 or 2)
 374  55FB              ; output B = 0A8H register value
 375  55FB              ; output D = 0 is no subslots, 1 if yes
 376  55FB              ; output C = 0A8H value when page 3 slot equals to requested page slot
 377  55FB              ; output E = subslot value if present
 378  55FB              ; modifies AF, BC, DE, HL
 379  55FB              GET_PAGE_INFO:
 380  55FB 6F               LD L, A
 381  55FC C6 C1            ADD A, low (EXPTBL)
 382  55FE 32 08 56         LD (GET_PAGE_INFO_L1+1), A
 383  5601 DB A8            IN A, (0A8H)
 384  5603 47               LD B, A
 385  5604 E6 3F            AND 03FH
 386  5606 4F               LD C, A
 387  5607              GET_PAGE_INFO_L1:
 388  5607 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 389  560A E6 80            AND 080H
 390  560C 28 1B            JR Z, GET_PAGE_INFO_L2
 391  560E                  ; expanded
 392  560E 2D               DEC L
 393  560F FA 2E 56         JP M, GET_PAGE_INFO_L3
 394  5612 2D               DEC L
 395  5613 FA 2C 56         JP M, GET_PAGE_INFO_L4
 396  5616                  ; page 2
 397  5616 07               RLCA
 398  5617 07               RLCA
 399  5618              GET_PAGE_INFO_L5:
 400  5618 E6 C0            AND 0C0H
 401  561A B1               OR C
 402  561B D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 403  561D 4F               LD C, A
 404  561E 3A FF FF         LD A, (0FFFFH)
 405  5621 2F               CPL
 406  5622 5F               LD E, A
 407  5623 16 01            LD D, 1
 408  5625 78               LD A, B ; return stack
 409  5626 D3 A8            OUT (0A8H), A
 410  5628 C9               RET
 411  5629              GET_PAGE_INFO_L2:
 412  5629                  ; not expanded
 413  5629 16 00            LD D, 0
 414  562B C9               RET
 415  562C              GET_PAGE_INFO_L4:
 416  562C                  ; page 1
 417  562C 0F               RRCA
 418  562D 0F               RRCA
 419  562E              GET_PAGE_INFO_L3:
 420  562E                  ; page 0
 421  562E 0F               RRCA
 422  562F 0F               RRCA
 423  5630 18 E6            JR GET_PAGE_INFO_L5
 424  5632              ; ****************************************************************************************************
 425  5632
 426  5632              ; ****************************************************************************************************
 427  5632              ; function returns original slot and subslot info
 428  5632              ; input B = 0A8H register value
 429  5632              ; input D = 0 is no subslots, 1 if yes
 430  5632              ; input C = 0A8H value when page 3 slot equals to requested page slot
 431  5632              ; input E = subslot value if present
 432  5632              ; modifies AF, disables interrupts
 433  5632              RESTORE_PAGE_INFO:
 434  5632 7A               LD A, D
 435  5633 B7               OR A
 436  5634 28 08            JR Z, RESTORE_PAGE_INFO_L1
 437  5636 79               LD A, C
 438  5637 F3           	DI
 439  5638 D3 A8            OUT (0A8H), A
 440  563A 7B               LD A, E
 441  563B 32 FF FF         LD (0FFFFH), A
 442  563E              RESTORE_PAGE_INFO_L1:
 443  563E 78               LD A, B
 444  563F D3 A8            OUT (0A8H), A
 445  5641 C9               RET
 446  5642              ; ****************************************************************************************************
 447  5642
 448  5642              ; *******************************************************************************************************
 449  5642              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 450  5642              ; INPUT:  A = SLOT ID: EXXXSSPP
 451  5642              ; E = EXPANDED FLAG
 452  5642              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 453  5642              ; PP = PRIMARY SLOT NUMBER
 454  5642              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 455  5642              ; CHANGES: AF, BC, DE
 456  5642
 457  5642              LOCAL_ENASLT:
 458  5642 CD 62 56         CALL L0353
 459  5645 FA 4F 56         JP M, L0340
 460  5648 DB A8            IN A, (0A8H)
 461  564A A1               AND C
 462  564B B0               OR B
 463  564C D3 A8            OUT (0A8H), A
 464  564E C9               RET
 465  564F              L0340:
 466  564F E5               PUSH HL
 467  5650 CD 87 56         CALL L0378
 468  5653 4F               LD C, A
 469  5654 06 00            LD B, 0
 470  5656 7D               LD A, L
 471  5657 A4               AND H
 472  5658 B2               OR D
 473  5659 21 C5 FC         LD HL, 0FCC5H
 474  565C 09               ADD HL, BC
 475  565D 77               LD (HL), A
 476  565E E1               POP HL
 477  565F 79               LD A, C
 478  5660 18 E0            JR LOCAL_ENASLT
 479  5662              L0353:
 480  5662 F3               DI
 481  5663 F5               PUSH AF
 482  5664 7C               LD A, H
 483  5665 07               RLCA
 484  5666 07               RLCA
 485  5667 E6 03            AND 3
 486  5669 5F               LD E, A
 487  566A 3E C0            LD A, 0C0H
 488  566C              L035D:
 489  566C 07               RLCA
 490  566D 07               RLCA
 491  566E 1D               DEC E
 492  566F F2 6C 56         JP P, L035D
 493  5672 5F               LD E, A
 494  5673 2F               CPL
 495  5674 4F               LD C, A
 496  5675 F1               POP AF
 497  5676 F5               PUSH AF
 498  5677 E6 03            AND 3
 499  5679 3C               INC A
 500  567A 47               LD B, A
 501  567B 3E AB            LD A, 0ABH
 502  567D              L036E:
 503  567D C6 55            ADD A, 055H
 504  567F 10 FC            DJNZ L036E
 505  5681 57               LD D, A
 506  5682 A3               AND E
 507  5683 47               LD B, A
 508  5684 F1               POP AF
 509  5685 A7               AND A
 510  5686 C9               RET
 511  5687              L0378:
 512  5687 F5               PUSH AF
 513  5688 7A               LD A, D
 514  5689 E6 C0            AND 0C0H
 515  568B 4F               LD C, A
 516  568C F1               POP AF
 517  568D F5               PUSH AF
 518  568E 57               LD D, A
 519  568F DB A8            IN A, (0A8H)
 520  5691 47               LD B, A
 521  5692 E6 3F            AND 03FH
 522  5694 B1               OR C
 523  5695 D3 A8            OUT (0A8H), A
 524  5697 7A               LD A, D
 525  5698 0F               RRCA
 526  5699 0F               RRCA
 527  569A E6 03            AND 3
 528  569C 57               LD D, A
 529  569D 3E AB            LD A, 0ABH
 530  569F              L0390:
 531  569F C6 55            ADD A, 055H
 532  56A1 15               DEC D
 533  56A2 F2 9F 56         JP P, L0390
 534  56A5 A3               AND E
 535  56A6 57               LD D, A
 536  56A7 7B               LD A, E
 537  56A8 2F               CPL
 538  56A9 67               LD H, A
 539  56AA 3A FF FF         LD A, (0FFFFH)
 540  56AD 2F               CPL
 541  56AE 6F               LD L, A
 542  56AF A4               AND H
 543  56B0 B2               OR D
 544  56B1 32 FF FF         LD (0FFFFH), A
 545  56B4 78               LD A, B
 546  56B5 D3 A8            OUT (0A8H), A
 547  56B7 F1               POP AF
 548  56B8 E6 03            AND 3
 549  56BA C9               RET
 550  56BB              ; *******************************************************************************************************
 551  56BB
 552  56BB              ; *******************************************************************************************************
 553  56BB              ; some common code to activate page 0 and place values needed to restore original page on stack
 554  56BB              ; input IY=return address
 555  56BB              ENABLE_PAGE0:
 556  56BB AF               XOR A
 557  56BC CD FB 55         CALL GET_PAGE_INFO
 558  56BF C5               PUSH BC
 559  56C0 D5               PUSH DE
 560  56C1 3A 41 F3         LD A, (RAMAD0)
 561  56C4 26 00            LD H, 0
 562  56C6 CD 42 56         CALL LOCAL_ENASLT
 563  56C9 FD E9        	JP (IY)
 564  56CB              ; *******************************************************************************************************
 565  56CB
 566  56CB              ; General BASIC CALL-instruction handler
 567  56CB              CALLHAND:
 568  56CB E5           	PUSH HL
 569  56CC 21 70 54     	LD	HL, CMDS ; pointer table based on starting letter
 570  56CF 3A 89 FD         LD A, (PROCNM)
 571  56D2 D6 41            SUB 'A'
 572  56D4 87               ADD A, A
 573  56D5 16 00            LD D, 0
 574  56D7 5F               LD E, A
 575  56D8 19               ADD HL, DE
 576  56D9 5E               LD E, (HL)
 577  56DA 23               INC HL
 578  56DB 56               LD D, (HL)
 579  56DC 7A               LD A, D
 580  56DD B3               OR E
 581  56DE 28 23            JR Z, .CMDNOTRECOGNIZED
 582  56E0 EB               EX DE, HL
 583  56E1              .CHKCMD:
 584  56E1 11 89 FD     	LD	DE, PROCNM
 585  56E4 1A           .LOOP:	LD	A,(DE)
 586  56E5 BE           	CP	(HL)
 587  56E6 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 588  56E8 13           	INC	DE
 589  56E9 23           	INC	HL
 590  56EA A7           	AND	A
 591  56EB 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 592  56ED 5E           	LD	E,(HL)
 593  56EE 23           	INC	HL
 594  56EF 56           	LD	D,(HL)
 595  56F0 E1           	POP	HL		; routine address
 596  56F1 CD 12 57     	CALL	GETPREVCHAR
 597  56F4 CD 06 57     	CALL	.CALLDE		; Call routine
 598  56F7 A7           	AND	A
 599  56F8 C9           	RET
 600  56F9
 601  56F9              .TONEXTCMD:
 602  56F9 0E FF        	LD	C,0FFH
 603  56FB AF           	XOR	A
 604  56FC ED B1        	CPIR			; Skip to end of instruction name
 605  56FE 23           	INC	HL
 606  56FF 23           	INC	HL		; Skip address
 607  5700 BE           	CP	(HL)
 608  5701 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 609  5703              .CMDNOTRECOGNIZED:
 610  5703 E1           	POP	HL
 611  5704 37               SCF
 612  5705 C9           	RET
 613  5706
 614  5706              .CALLDE:
 615  5706 D5           	PUSH	DE
 616  5707 C9           	RET
 617  5708
 618  5708              ;---------------------------
 619  5708
 620  5708              ;GETSTRPNT:
 621  5708              ; OUT:
 622  5708              ; HL = String Address
 623  5708              ; B  = Lenght
 624  5708              ;        LD      HL,(USR)
 625  5708              ;        LD      B,(HL)
 626  5708              ;        INC     HL
 627  5708              ;        LD      E,(HL)
 628  5708              ;        INC     HL
 629  5708              ;        LD      D,(HL)
 630  5708              ;        EX      DE,HL
 631  5708              ;        RET
 632  5708
 633  5708              ;EVALTXTPARAM:
 634  5708              ;	CALL	CHKCHAR
 635  5708              ;	DEFB	"("             ; Check for (
 636  5708              ;	LD	IX,FRMEVL
 637  5708              ;	CALL	CALBAS		; Evaluate expression
 638  5708              ;       LD      A,(VALTYP)
 639  5708              ;        CP      3               ; Text type?
 640  5708              ;        JP      NZ,TYPE_MISMATCH
 641  5708              ;        PUSH	HL
 642  5708              ;        LD	IX,FRESTR         ; Free the temporary string
 643  5708              ;        CALL	CALBAS
 644  5708              ;        POP	HL
 645  5708              ;	CALL	CHKCHAR
 646  5708              ;	DEFB	")"             ; Check for )
 647  5708              ;        RET
 648  5708
 649  5708
 650  5708              CHKCHAR:
 651  5708 CD 12 57     	CALL	GETPREVCHAR	; Get previous basic char
 652  570B E3           	EX	(SP),HL
 653  570C BE           	CP	(HL) 	        ; Check if good char
 654  570D 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 655  570F 23           	INC	HL
 656  5710 E3           	EX	(SP),HL
 657  5711 23           	INC	HL		; Get next basic char
 658  5712
 659  5712              GETPREVCHAR:
 660  5712 2B           	DEC	HL
 661  5713 DD 21 66 46  	LD	IX,CHRGTR
 662  5717 C3 59 01     	JP      CALBAS
 663  571A
 664  571A
 665  571A              TYPE_MISMATCH:
 666  571A 1E 0D            LD E, 13 ; Type mismatch
 667  571C 18 0A            JR THROW_ERROR
 668  571E              SUBSCRIPT_OUT_OF_RANGE:
 669  571E 1E 09            LD E,9 ; subscript out of range
 670  5720 18 06        	JR THROW_ERROR
 671  5722              OVERFLOW:
 672  5722 1E 06        	LD E,6
 673  5724 18 02        	JR THROW_ERROR
 674  5726              SYNTAX_ERROR:
 675  5726 1E 02            LD E, 2 ; Syntax error
 676  5728              THROW_ERROR:
 677  5728 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 678  572C C3 59 01     	JP	CALBAS
 679  572F
 680  572F              ;---------------------------
 681  572F
 682  572F               IF (RAM_CMDS == 1)
 683  572F              ; *******************************************************************************************************
 684  572F              ; function to handle CALL MEMCPY basic extension
 685  572F              ; _MEMCPY ( INT source,
 686  572F              ;			INT destination,
 687  572F              ;			INT count,
 688  572F              ; will put ram in page 0 also, page 1 is already there
 689  572F              MEMCPY:
 690  572F              	; opening (
 691  572F CD 08 57     	CALL CHKCHAR
 692  5732 28           	DB '('
 693  5733              	; get source address
 694  5733 DD 21 2F 54  	LD IX, FRMQNT
 695  5737 CD 59 01     	CALL CALBAS
 696  573A D5           	PUSH DE
 697  573B              	; comma
 698  573B CD 08 57     	CALL CHKCHAR
 699  573E 2C           	DB ','
 700  573F              	; get destination address
 701  573F DD 21 2F 54  	LD IX, FRMQNT
 702  5743 CD 59 01     	CALL CALBAS
 703  5746 D5           	PUSH DE
 704  5747              	; comma
 705  5747 CD 08 57     	CALL CHKCHAR
 706  574A 2C           	DB ','
 707  574B              	; get length
 708  574B DD 21 2F 54  	LD IX, FRMQNT
 709  574F CD 59 01     	CALL CALBAS
 710  5752 D5           	PUSH DE
 711  5753              	; ending )
 712  5753 CD 08 57     	CALL CHKCHAR
 713  5756 29           	DB ')'
 714  5757
 715  5757              	; save position
 716  5757 E5           	PUSH HL
 717  5758 DD E1        	POP IX
 718  575A
 719  575A C1           	POP BC ; count
 720  575B D1           	POP DE ; destination
 721  575C E1           	POP HL ; source
 722  575D D9           	EXX
 723  575E              	; enable page 0
 724  575E FD 21 65 57  	LD IY, .RET
 725  5762 C3 BB 56     	JP ENABLE_PAGE0
 726  5765              .RET:
 727  5765 FB           	EI
 728  5766 D9           	EXX
 729  5767 ED B0        	LDIR
 730  5769 D1               POP DE
 731  576A C1               POP BC
 732  576B CD 32 56         CALL RESTORE_PAGE_INFO
 733  576E DD E5        	PUSH IX
 734  5770 E1           	POP HL
 735  5771 C9           	RET
 736  5772              ; *******************************************************************************************************
 737  5772               ENDIF
 738  5772
 739  5772               IF (VRAM_CMDS == 1)
 740  5772              ; *******************************************************************************************************
 741  5772              ; function to handle CALL FILVRM basic extension
 742  5772              ; FILVRM ( INT offset,
 743  5772              ;		   INT count,
 744  5772              ;		   BYTE value,
 745  5772              ;		   BYTE wait_vsync) >0 = true
 746  5772              ; wait_vsync will issue HALT before copying
 747  5772              FILVRM:
 748  5772              	; opening (
 749  5772 CD 08 57     	CALL CHKCHAR
 750  5775 28           	DB '('
 751  5776              	; get offset address
 752  5776 DD 21 2F 54  	LD IX, FRMQNT
 753  577A CD 59 01     	CALL CALBAS
 754  577D D5           	PUSH DE
 755  577E              	; comma
 756  577E CD 08 57     	CALL CHKCHAR
 757  5781 2C           	DB ','
 758  5782              	; get count
 759  5782 DD 21 2F 54  	LD IX, FRMQNT
 760  5786 CD 59 01     	CALL CALBAS
 761  5789 D5           	PUSH DE
 762  578A              	; comma
 763  578A CD 08 57     	CALL CHKCHAR
 764  578D 2C           	DB ','
 765  578E              	; get value
 766  578E DD 21 1C 52  	LD IX, GETBYT
 767  5792 CD 59 01     	CALL CALBAS
 768  5795 F5           	PUSH AF
 769  5796              	; comma
 770  5796 CD 08 57     	CALL CHKCHAR
 771  5799 2C           	DB ','
 772  579A              	; get vsync wait
 773  579A DD 21 1C 52  	LD IX, GETBYT
 774  579E CD 59 01     	CALL CALBAS
 775  57A1 F5           	PUSH AF
 776  57A2              	; ending )
 777  57A2 CD 08 57     	CALL CHKCHAR
 778  57A5 29           	DB ')'
 779  57A6
 780  57A6 FB               EI
 781  57A7              	; save position
 782  57A7 E5           	PUSH HL
 783  57A8 DD E1        	POP IX
 784  57AA
 785  57AA              	; syntax ok
 786  57AA              	; wait for vsync if needed
 787  57AA F1           	POP AF
 788  57AB B7           	OR A
 789  57AC 28 01        	JR Z, .L1
 790  57AE 76           	HALT
 791  57AF
 792  57AF              .L1:
 793  57AF F1               POP AF ; value
 794  57B0 C1               POP BC ; count
 795  57B1 E1               POP HL ; offset
 796  57B2 3E 01        	LD A,1
 797  57B4 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
 798  57B7 CD 56 00         CALL BIOS_FILVRM
 799  57BA AF           	XOR A
 800  57BB 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
 801  57BE
 802  57BE              .L3:
 803  57BE DD E5        	PUSH IX
 804  57C0 E1           	POP HL
 805  57C1 C9           	RET
 806  57C2              ; *******************************************************************************************************
 807  57C2               ENDIF
 808  57C2
 809  57C2               IF (RAM_CMDS == 1)
 810  57C2              ; *******************************************************************************************************
 811  57C2              ; function to handle CALL FILRAM basic extension
 812  57C2              ; FILRAM ( INT start address,
 813  57C2              ;		   INT count,
 814  57C2              ;		   BYTE value,
 815  57C2              ; will put ram in page 0 also, page 1 is already there
 816  57C2              FILRAM:
 817  57C2              	; opening (
 818  57C2 CD 08 57     	CALL CHKCHAR
 819  57C5 28           	DB '('
 820  57C6              	; get start address
 821  57C6 DD 21 2F 54  	LD IX, FRMQNT
 822  57CA CD 59 01     	CALL CALBAS
 823  57CD D5           	PUSH DE
 824  57CE              	; comma
 825  57CE CD 08 57     	CALL CHKCHAR
 826  57D1 2C           	DB ','
 827  57D2              	; get count
 828  57D2 DD 21 2F 54  	LD IX, FRMQNT
 829  57D6 CD 59 01     	CALL CALBAS
 830  57D9 D5           	PUSH DE
 831  57DA              	; comma
 832  57DA CD 08 57     	CALL CHKCHAR
 833  57DD 2C           	DB ','
 834  57DE              	; get value
 835  57DE DD 21 1C 52  	LD IX, GETBYT
 836  57E2 CD 59 01     	CALL CALBAS
 837  57E5 F5           	PUSH AF
 838  57E6              	; ending )
 839  57E6 CD 08 57     	CALL CHKCHAR
 840  57E9 29           	DB ')'
 841  57EA
 842  57EA              	; save position
 843  57EA E5           	PUSH HL
 844  57EB DD E1        	POP IX
 845  57ED
 846  57ED D1           	POP DE ; actually AF
 847  57EE C1           	POP BC ; count
 848  57EF E1           	POP HL ; start address
 849  57F0 78           	LD A, B
 850  57F1 B7           	OR A
 851  57F2 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 852  57F4 B1           	OR C
 853  57F5 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 854  57F7 79           	LD A, C
 855  57F8 3D           	DEC A
 856  57F9 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 857  57FB              	; one byte to fill
 858  57FB 72           	LD (HL), D
 859  57FC 18 12        	JR .EXIT
 860  57FE              .L1:
 861  57FE D9           	EXX
 862  57FF              	; enable page 0
 863  57FF FD 21 06 58  	LD IY, .RET
 864  5803 C3 BB 56     	JP ENABLE_PAGE0
 865  5806              .RET:
 866  5806 FB           	EI
 867  5807 D9           	EXX
 868  5808 CD 14 58     	CALL .FILLVALUE
 869  580B D1               POP DE
 870  580C C1               POP BC
 871  580D CD 32 56         CALL RESTORE_PAGE_INFO
 872  5810              .EXIT:
 873  5810 DD E5        	PUSH IX
 874  5812 E1           	POP HL
 875  5813 C9           	RET
 876  5814
 877  5814              .FILLVALUE:
 878  5814 72               LD (HL), D
 879  5815 54               LD D, H
 880  5816 5D               LD E, L
 881  5817 13               INC DE
 882  5818 0B               DEC BC
 883  5819 ED B0            LDIR
 884  581B C9               RET
 885  581C              ; *******************************************************************************************************
 886  581C               ENDIF
 887  581C
 888  581C               IF (GENCAL_CMD == 1)
 889  581C              ; *******************************************************************************************************
 890  581C              ; function to handle CALL GENCAL basic extension
 891  581C              ; GENCAL ( INT fn_addr, = address of the function to call
 892  581C              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 893  581C              ; output values of reristers will also be stored at reg_list_ptr
 894  581C              GENCAL_VAR_SP:
 895  581C 00 00            DW 0
 896  581E              GENCAL_VAR_SP2:
 897  581E 00 00            DW 0
 898  5820              GENCAL:
 899  5820              	; opening (
 900  5820 CD 08 57     	CALL CHKCHAR
 901  5823 28           	DB '('
 902  5824              	; get function address
 903  5824 DD 21 2F 54  	LD IX, FRMQNT
 904  5828 CD 59 01     	CALL CALBAS
 905  582B D5           	PUSH DE
 906  582C              	; comma
 907  582C CD 08 57     	CALL CHKCHAR
 908  582F 2C           	DB ','
 909  5830              	; get pointer to register list
 910  5830 DD 21 2F 54  	LD IX, FRMQNT
 911  5834 CD 59 01     	CALL CALBAS
 912  5837 D5           	PUSH DE
 913  5838              	; ending )
 914  5838 CD 08 57     	CALL CHKCHAR
 915  583B 29           	DB ')'
 916  583C
 917  583C              	; save BASIC token position
 918  583C E5           	PUSH HL
 919  583D D9               EXX
 920  583E E1           	POP HL ; HL'=next basic token
 921  583F D9               EXX
 922  5840
 923  5840 E1               POP HL ; get pointer to register values
 924  5841 F3           	DI
 925  5842 ED 73 1C 58      LD (GENCAL_VAR_SP), SP
 926  5846 F9               LD SP, HL
 927  5847 F1               POP AF
 928  5848 C1               POP BC
 929  5849 D1               POP DE
 930  584A E1               POP HL
 931  584B DD E1            POP IX
 932  584D FD E1            POP IY
 933  584F D9               EXX
 934  5850 ED 73 1E 58      LD (GENCAL_VAR_SP2), SP
 935  5854 ED 7B 1C 58      LD SP, (GENCAL_VAR_SP)
 936  5858 FB               EI
 937  5859 D1               POP DE ; get function to call
 938  585A E5               PUSH HL
 939  585B CD 76 58         CALL .EXXDECALL
 940  585E F3               DI
 941  585F ED 73 1C 58      LD (GENCAL_VAR_SP), SP
 942  5863 ED 7B 1E 58      LD SP, (GENCAL_VAR_SP2)
 943  5867 FD E5            PUSH IY
 944  5869 DD E5            PUSH IX
 945  586B E5               PUSH HL
 946  586C D5               PUSH DE
 947  586D C5               PUSH BC
 948  586E F5               PUSH AF
 949  586F ED 7B 1C 58      LD SP, (GENCAL_VAR_SP)
 950  5873 FB               EI
 951  5874 E1               POP HL
 952  5875 C9           	RET
 953  5876
 954  5876              .EXXDECALL:
 955  5876 D5               PUSH DE
 956  5877 D9               EXX
 957  5878 C9               RET
 958  5879              ; *******************************************************************************************************
 959  5879               ENDIF
 960  5879
 961  5879               IF (VRAM_CMDS == 1)
 962  5879              ; *******************************************************************************************************
 963  5879              ; function to handle CALL MEMVRM basic extension
 964  5879              ; copies from RAM to VRAM
 965  5879              ; _MEMVRM ( INT source,
 966  5879              ;			INT destination,
 967  5879              ;			INT count,
 968  5879              ;			BYTE wait_vsync) >0 = true
 969  5879              ; will put ram in page 0 also, page 1 is already there
 970  5879              ; wait_vsync will issue HALT before copying
 971  5879              MEMVRM:
 972  5879              	; opening (
 973  5879 CD 08 57     	CALL CHKCHAR
 974  587C 28           	DB '('
 975  587D              	; get source address
 976  587D DD 21 2F 54  	LD IX, FRMQNT
 977  5881 CD 59 01     	CALL CALBAS
 978  5884 D5           	PUSH DE
 979  5885              	; comma
 980  5885 CD 08 57     	CALL CHKCHAR
 981  5888 2C           	DB ','
 982  5889              	; get destination address
 983  5889 DD 21 2F 54  	LD IX, FRMQNT
 984  588D CD 59 01     	CALL CALBAS
 985  5890 D5           	PUSH DE
 986  5891              	; comma
 987  5891 CD 08 57     	CALL CHKCHAR
 988  5894 2C           	DB ','
 989  5895              	; get length
 990  5895 DD 21 2F 54  	LD IX, FRMQNT
 991  5899 CD 59 01     	CALL CALBAS
 992  589C D5           	PUSH DE
 993  589D              	; comma
 994  589D CD 08 57     	CALL CHKCHAR
 995  58A0 2C           	DB ','
 996  58A1              	; get vsync wait
 997  58A1 DD 21 1C 52  	LD IX, GETBYT
 998  58A5 CD 59 01     	CALL CALBAS
 999  58A8 F5           	PUSH AF
1000  58A9              	; ending )
1001  58A9 CD 08 57     	CALL CHKCHAR
1002  58AC 29           	DB ')'
1003  58AD
1004  58AD                  ; save position in BASIC text
1005  58AD E5           	PUSH HL
1006  58AE DD E1        	POP IX
1007  58B0
1008  58B0 F1           	POP AF ; wait vsync
1009  58B1 B7           	OR A
1010  58B2 28 03        	JR Z, .L1
1011  58B4 FB               EI
1012  58B5 76           	HALT
1013  58B6 F3           	DI
1014  58B7              .L1:
1015  58B7              	; pop LDIR parameters and store away for later
1016  58B7 C1           	POP BC ; count
1017  58B8 D1           	POP DE ; vram destination
1018  58B9 E1           	POP HL ; ram source
1019  58BA D9           	EXX
1020  58BB FD 21 C2 58   	LD IY, .RET
1021  58BF C3 BB 56     	JP ENABLE_PAGE0
1022  58C2              .RET:
1023  58C2 FB           	EI
1024  58C3 D9           	EXX
1025  58C4 3E 01        	LD A,1
1026  58C6 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1027  58C9 CD D9 58     	CALL .LDIRVM
1028  58CC AF           	XOR A
1029  58CD 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1030  58D0 D1               POP DE
1031  58D1 C1               POP BC
1032  58D2 CD 32 56         CALL RESTORE_PAGE_INFO
1033  58D5 DD E5        	PUSH IX
1034  58D7 E1           	POP HL
1035  58D8 C9           	RET
1036  58D9
1037  58D9              .LDIRVM:
1038  58D9 EB           	EX DE, HL
1039  58DA F3           	DI
1040  58DB CD E4 55     	CALL SETWRT_LOCAL
1041  58DE FB           	EI
1042  58DF EB           	EX DE, HL
1043  58E0 78           	LD A, B
1044  58E1 B7           	OR A
1045  58E2 28 0D        	JR Z, .L3
1046  58E4 C5           	PUSH BC
1047  58E5 0E 98        	LD C, #98
1048  58E7              .L2:
1049  58E7 50           	LD D, B
1050  58E8 06 00        	LD B, 0
1051  58EA CD EF 55     	CALL BBYTECOPY
1052  58ED 42           	LD B, D
1053  58EE 10 F7        	DJNZ .L2
1054  58F0 C1           	POP BC
1055  58F1              .L3:
1056  58F1 79           	LD A, C
1057  58F2 B7           	OR A
1058  58F3 C8           	RET Z
1059  58F4 41           	LD B, C
1060  58F5 0E 98        	LD C, #98
1061  58F7 C3 EF 55     	JP BBYTECOPY
1062  58FA              ; *******************************************************************************************************
1063  58FA               ENDIF
1064  58FA
1065  58FA               IF (VRAM_CMDS == 1)
1066  58FA              ; *******************************************************************************************************
1067  58FA              ; function to handle CALL VRMMEM basic extension
1068  58FA              ; copies from RAM to VRAM
1069  58FA              ; _VRMMEM ( INT source,
1070  58FA              ;			INT destination,
1071  58FA              ;			INT count
1072  58FA              ; will put ram in page 0 also, page 1 is already there
1073  58FA              VRMMEM:
1074  58FA              	; opening (
1075  58FA CD 08 57     	CALL CHKCHAR
1076  58FD 28           	DB '('
1077  58FE              	; get source address
1078  58FE DD 21 2F 54  	LD IX, FRMQNT
1079  5902 CD 59 01     	CALL CALBAS
1080  5905 D5           	PUSH DE
1081  5906              	; comma
1082  5906 CD 08 57     	CALL CHKCHAR
1083  5909 2C           	DB ','
1084  590A              	; get destination address
1085  590A DD 21 2F 54  	LD IX, FRMQNT
1086  590E CD 59 01     	CALL CALBAS
1087  5911 D5           	PUSH DE
1088  5912              	; comma
1089  5912 CD 08 57     	CALL CHKCHAR
1090  5915 2C           	DB ','
1091  5916              	; get length
1092  5916 DD 21 2F 54  	LD IX, FRMQNT
1093  591A CD 59 01     	CALL CALBAS
1094  591D D5           	PUSH DE
1095  591E              	; ending )
1096  591E CD 08 57     	CALL CHKCHAR
1097  5921 29           	DB ')'
1098  5922
1099  5922                  ; save position in BASIC text
1100  5922 E5           	PUSH HL
1101  5923 DD E1        	POP IX
1102  5925
1103  5925 C1           	POP BC ; count
1104  5926 D1           	POP DE ; destination
1105  5927 E1           	POP HL ; source
1106  5928 D9           	EXX
1107  5929 FD 21 30 59  	LD IY, .RET
1108  592D C3 BB 56     	JP ENABLE_PAGE0
1109  5930              .RET:
1110  5930 FB           	EI
1111  5931 D9           	EXX
1112  5932 3E 01        	LD A,1
1113  5934 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1114  5937 CD 47 59     	CALL .LDIRMV
1115  593A AF           	XOR A
1116  593B 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
1117  593E D1               POP DE
1118  593F C1               POP BC
1119  5940 CD 32 56         CALL RESTORE_PAGE_INFO
1120  5943 DD E5        	PUSH IX
1121  5945 E1           	POP HL
1122  5946 C9           	RET
1123  5947
1124  5947              .LDIRMV:
1125  5947              	; set VRAM address *exactly* as in ROM, otherwise corruption
1126  5947 7D           	LD	A, L
1127  5948 F3           	DI
1128  5949 D3 99        	OUT	(099H), A
1129  594B 7C           	LD	A, H
1130  594C E6 3F        	AND	03FH
1131  594E D3 99        	OUT	(099H), A
1132  5950 FB           	EI
1133  5951              	;EX (SP), HL
1134  5951              	;EX (SP), HL
1135  5951              	;NOP
1136  5951              	;NOP
1137  5951              .L4:
1138  5951 DB 98            IN A, (#98)
1139  5953 12           	LD (DE), A
1140  5954 13               INC DE
1141  5955 0B               DEC BC
1142  5956 79               LD A, C
1143  5957 B0               OR B
1144  5958 20 F7            JR NZ, .L4
1145  595A C9               RET
1146  595B              ; *******************************************************************************************************
1147  595B               ENDIF
1148  595B
1149  595B               IF (SOUND_CMDS == 1)
1150  595B              ; *******************************************************************************************************
1151  595B              ; function to handle CALL SNDPLYINIT basic extension
1152  595B              ; initializes sound player
1153  595B              ; _SNDPLYINIT ( INT music_offset,
1154  595B              ;				INT sfx_offset, can be -1 if no SFX
1155  595B              ; will put ram in page 0 also, page 1 is already there
1156  595B              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1157  595B              SNDPLYINIT:
1158  595B              	; opening (
1159  595B CD 08 57     	CALL CHKCHAR
1160  595E 28           	DB '('
1161  595F              	; get music address
1162  595F DD 21 2F 54  	LD IX, FRMQNT
1163  5963 CD 59 01     	CALL CALBAS
1164  5966 D5           	PUSH DE
1165  5967              	; comma
1166  5967 CD 08 57     	CALL CHKCHAR
1167  596A 2C           	DB ','
1168  596B              	; get sfx address
1169  596B DD 21 2F 54  	LD IX, FRMQNT
1170  596F CD 59 01     	CALL CALBAS
1171  5972 D5           	PUSH DE
1172  5973              	; ending )
1173  5973 CD 08 57     	CALL CHKCHAR
1174  5976 29           	DB ')'
1175  5977
1176  5977                  ; save position in BASIC text
1177  5977 44           	LD B, H
1178  5978 4D           	LD C, L
1179  5979
1180  5979              	; pop LDIR parameters and store away for later
1181  5979 D1           	POP DE ; sfx address
1182  597A E1           	POP HL ; music address
1183  597B C5           	PUSH BC ; basic text location
1184  597C D9           	EXX
1185  597D FD 21 84 59  	LD IY, .RET
1186  5981 C3 BB 56     	JP ENABLE_PAGE0
1187  5984              .RET:
1188  5984 D9           	EXX
1189  5985
1190  5985 D5           	PUSH DE
1191  5986 AF           	XOR A
1192  5987              	; HL = music location
1193  5987 CD 62 41     	CALL PLY_AKG_INIT
1194  598A 3E 01        	LD A, 1
1195  598C 32 7A 4D     	LD (MUSIC_INIT_STATUS), A
1196  598F
1197  598F E1           	POP HL ; SFX
1198  5990              	; check if SFX address -1
1199  5990 23           	INC HL
1200  5991 7D           	LD A, L
1201  5992 B4           	OR H
1202  5993 28 09        	JR Z,.L1
1203  5995 2B           	DEC HL
1204  5996 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1205  5999 3E 01        	LD A, 1
1206  599B 32 7B 4D     	LD (SFX_INIT_STATUS), A
1207  599E              .L1:
1208  599E D1               POP DE
1209  599F C1               POP BC
1210  59A0 CD 32 56         CALL RESTORE_PAGE_INFO
1211  59A3
1212  59A3 E1           	POP HL
1213  59A4 C9           	RET
1214  59A5              ; *******************************************************************************************************
1215  59A5
1216  59A5              ; *******************************************************************************************************
1217  59A5              ; function to handle CALL SNDPLYON basic extension
1218  59A5              ; enables sound player
1219  59A5              ; _SNDPLYON
1220  59A5              ; sets SOUND_ENABLED variable to 1 if init call was done
1221  59A5              ; if not throws out of data error
1222  59A5              SNDPLYON:
1223  59A5 3A 7A 4D     	LD A, (MUSIC_INIT_STATUS)
1224  59A8 B7           	OR A
1225  59A9 20 05        	JR NZ, .L1
1226  59AB              	; player not initialized, throw error
1227  59AB 1E 04        	LD E, 04 ; Out of DATA
1228  59AD C3 28 57     	JP THROW_ERROR
1229  59B0              .L1:
1230  59B0 32 7C 4D     	LD (SOUND_ENABLED), A
1231  59B3              	; disable key click
1232  59B3 AF           	XOR A
1233  59B4 32 DB F3     	LD (CLIKSW), A
1234  59B7 C9           	RET
1235  59B8              ; *******************************************************************************************************
1236  59B8
1237  59B8              ; *******************************************************************************************************
1238  59B8              ; function to handle CALL SNDPLYOFF basic extension
1239  59B8              ; disables sound player
1240  59B8              ; _SNDPLYOFF
1241  59B8              ; sets SOUND_ENABLED variable to 0
1242  59B8              ; calls AKG to stop music and SFX on all channels if initialized
1243  59B8              SNDPLYOFF:
1244  59B8 3A 7C 4D     	LD A, (SOUND_ENABLED)
1245  59BB B7           	OR A
1246  59BC C8           	RET Z ; already stopped
1247  59BD AF           	XOR A
1248  59BE 32 7C 4D     	LD (SOUND_ENABLED), A
1249  59C1 E5           	PUSH HL
1250  59C2 CD 21 42     	CALL PLY_AKG_STOP
1251  59C5 3A 7B 4D     	LD A, (SFX_INIT_STATUS)
1252  59C8 B7           	OR A
1253  59C9 28 0E        	JR Z, .EXIT ; SFX not in use
1254  59CB AF           	XOR A
1255  59CC CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1256  59CF 3E 01        	LD A, 1
1257  59D1 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1258  59D4 3E 02        	LD A, 2
1259  59D6 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1260  59D9              .EXIT:
1261  59D9 E1           	POP HL
1262  59DA C9           	RET
1263  59DB              ; *******************************************************************************************************
1264  59DB
1265  59DB              ; *******************************************************************************************************
1266  59DB              ; function to handle CALL SNDSFX basic extension
1267  59DB              ; plays a sound effect
1268  59DB              ; _SNDSFX ( BYTE sfx_number, >0
1269  59DB              ;			BYTE channel, = 0,1 or 2
1270  59DB              ;			BYTE inverted_volume = 0-16, 0 being full volume
1271  59DB              ; will put ram in page 0 also, page 1 is already there
1272  59DB              ; if sound off throws illegal function call
1273  59DB              ; if sfx not initialized, throws out of data
1274  59DB              SNDSFX:
1275  59DB              	; opening (
1276  59DB CD 08 57     	CALL CHKCHAR
1277  59DE 28           	DB '('
1278  59DF              	; get sfx_number
1279  59DF DD 21 1C 52  	LD IX, GETBYT
1280  59E3 CD 59 01     	CALL CALBAS
1281  59E6 D5           	PUSH DE
1282  59E7              	; comma
1283  59E7 CD 08 57     	CALL CHKCHAR
1284  59EA 2C           	DB ','
1285  59EB              	; get sfx address
1286  59EB DD 21 1C 52  	LD IX, GETBYT
1287  59EF CD 59 01     	CALL CALBAS
1288  59F2 D5           	PUSH DE
1289  59F3              	; comma
1290  59F3 CD 08 57     	CALL CHKCHAR
1291  59F6 2C           	DB ','
1292  59F7              	; get inverted volume
1293  59F7 DD 21 1C 52  	LD IX, GETBYT
1294  59FB CD 59 01     	CALL CALBAS
1295  59FE D5           	PUSH DE
1296  59FF              	; ending )
1297  59FF CD 08 57     	CALL CHKCHAR
1298  5A02 29           	DB ')'
1299  5A03
1300  5A03 3A 7C 4D     	LD A, (SOUND_ENABLED)
1301  5A06 B7           	OR A
1302  5A07 20 05        	JR NZ, .L1
1303  5A09              	; sound disabled, throw illegal function call
1304  5A09 1E 05        	LD E, 5
1305  5A0B C3 28 57     	JP THROW_ERROR
1306  5A0E              .L1:
1307  5A0E 3A 7B 4D     	LD A, (SFX_INIT_STATUS)
1308  5A11 B7           	OR A
1309  5A12 20 05        	JR NZ, .L2
1310  5A14              	; sfx data not initialized, throw out of data
1311  5A14 1E 04        	LD E, 4
1312  5A16 C3 28 57     	JP THROW_ERROR
1313  5A19              .L2:
1314  5A19              	; pop  parameters and store away for later
1315  5A19 D1           	POP DE ; inverted volume
1316  5A1A 43           	LD B, E
1317  5A1B D1           	POP DE ; channel
1318  5A1C 4B           	LD C, E
1319  5A1D D1           	POP DE
1320  5A1E 7B           	LD A, E
1321  5A1F 08           	EX AF, AF'
1322  5A20 E5           	PUSH HL ; basic text location
1323  5A21 D9           	EXX
1324  5A22 FD 21 29 5A  	LD IY, .RET
1325  5A26 C3 BB 56     	JP ENABLE_PAGE0
1326  5A29              .RET:
1327  5A29 D9           	EXX
1328  5A2A 08           	EX AF, AF'
1329  5A2B CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1330  5A2E
1331  5A2E D1               POP DE
1332  5A2F C1               POP BC
1333  5A30 CD 32 56         CALL RESTORE_PAGE_INFO
1334  5A33
1335  5A33 E1           	POP HL
1336  5A34 C9           	RET
1337  5A35              ; *******************************************************************************************************
1338  5A35               ENDIF
1339  5A35
1340  5A35               IF (BLIT_CMDS == 1)
1341  5A35              ; *******************************************************************************************************
1342  5A35              ; function rotates mask and data of several characters and applies to background data
1343  5A35              ; this handles x-shift from 0 to 4
1344  5A35              ; contains self-modifying code that is set-up from external function
1345  5A35              ; input HL=pointer to mask data
1346  5A35              ; input HL'=pointer to character data
1347  5A35              ; input DE=output buffer containing background data
1348  5A35              ; input BC=DE+8
1349  5A35              ; input A=number of characters to process
1350  5A35              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1351  5A35              SHIFT04:
1352  5A35 08           	EX AF, AF'
1353  5A36 7E           	LD A, (HL) ; get mask
1354  5A37 D9           	EXX
1355  5A38 57           	LD D, A
1356  5A39 1E FF        	LD E, #FF
1357  5A3B 37           	SCF
1358  5A3C              .M1:
1359  5A3C 18 FE        	JR .M1 ; this is self-modifying part
1360  5A3E CB 1A        	RR D
1361  5A40 CB 1B        	RR E
1362  5A42 CB 1A        	RR D
1363  5A44 CB 1B        	RR E
1364  5A46 CB 1A        	RR D
1365  5A48 CB 1B        	RR E
1366  5A4A CB 1A        	RR D
1367  5A4C CB 1B        	RR E
1368  5A4E
1369  5A4E 46           	LD B, (HL) ; get data
1370  5A4F 0E 00        	LD C, 0
1371  5A51              .M2:
1372  5A51 18 FE        	JR .M2 ; also self-modifying part
1373  5A53 CB 38        	SRL B
1374  5A55 CB 19        	RR C
1375  5A57 CB 38        	SRL B
1376  5A59 CB 19        	RR C
1377  5A5B CB 38        	SRL B
1378  5A5D CB 19        	RR C
1379  5A5F CB 38        	SRL B
1380  5A61 CB 19        	RR C
1381  5A63
1382  5A63 D9           	EXX
1383  5A64 1A           	LD A, (DE) ; background
1384  5A65 D9           	EXX
1385  5A66 A2           	AND D
1386  5A67 B0           	OR B
1387  5A68 D9           	EXX
1388  5A69 12           	LD (DE), A
1389  5A6A
1390  5A6A 0A           	LD A, (BC)
1391  5A6B D9           	EXX
1392  5A6C A3           	AND E
1393  5A6D B1           	OR C
1394  5A6E 23           	INC HL
1395  5A6F D9           	EXX
1396  5A70 02           	LD (BC), A
1397  5A71
1398  5A71 23           	INC HL
1399  5A72 13           	INC DE
1400  5A73 03           	INC BC
1401  5A74
1402  5A74 08           	EX AF, AF'
1403  5A75 3D           	DEC A
1404  5A76 C2 35 5A     	JP NZ, SHIFT04
1405  5A79 C9           	RET
1406  5A7A              ; *******************************************************************************************************
1407  5A7A
1408  5A7A              ; *******************************************************************************************************
1409  5A7A              ; function rotates mask and data of several characters and applies to background data
1410  5A7A              ; this handles x-shift from 5 to 8
1411  5A7A              ; contains self-modifying code that is set-up from external function
1412  5A7A              ; input HL=pointer to mask data
1413  5A7A              ; input HL'=pointer to character data
1414  5A7A              ; input DE=output buffer containing background data
1415  5A7A              ; input BC=DE+8
1416  5A7A              ; input A=number of characters to process
1417  5A7A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1418  5A7A              SHIFT58:
1419  5A7A 08           	EX AF, AF'
1420  5A7B 7E           	LD A, (HL) ; get mask
1421  5A7C D9           	EXX
1422  5A7D 57           	LD D, A
1423  5A7E 1E FF        	LD E, #FF
1424  5A80 37           	SCF
1425  5A81              .M1:
1426  5A81 18 FE        	JR .M1 ; this is self-modifying part
1427  5A83 CB 12        	RL D
1428  5A85 CB 13        	RL E
1429  5A87 CB 12        	RL D
1430  5A89 CB 13        	RL E
1431  5A8B CB 12        	RL D
1432  5A8D CB 13        	RL E
1433  5A8F
1434  5A8F 46           	LD B, (HL)
1435  5A90 0E 00        	LD C, 0
1436  5A92              .M2:
1437  5A92 18 FE        	JR .M2 ; also self-modifying part
1438  5A94 CB 20        	SLA B
1439  5A96 CB 11        	RL C
1440  5A98 CB 20        	SLA B
1441  5A9A CB 11        	RL C
1442  5A9C CB 20        	SLA B
1443  5A9E CB 11        	RL C
1444  5AA0
1445  5AA0 D9           	EXX
1446  5AA1 1A           	LD A, (DE) ; background
1447  5AA2 D9           	EXX
1448  5AA3 A3           	AND E
1449  5AA4 B1           	OR C
1450  5AA5 D9           	EXX
1451  5AA6 12           	LD (DE), A
1452  5AA7
1453  5AA7 0A           	LD A, (BC)
1454  5AA8 D9           	EXX
1455  5AA9 A2           	AND D
1456  5AAA B0           	OR B
1457  5AAB 23           	INC HL
1458  5AAC D9           	EXX
1459  5AAD 02           	LD (BC), A
1460  5AAE
1461  5AAE 23           	INC HL
1462  5AAF 13           	INC DE
1463  5AB0 03           	INC BC
1464  5AB1
1465  5AB1 08           	EX AF, AF'
1466  5AB2 3D           	DEC A
1467  5AB3 C2 7A 5A     	JP NZ, SHIFT58
1468  5AB6 C9           	RET
1469  5AB7              ; *******************************************************************************************************
1470  5AB7
1471  5AB7              ; *******************************************************************************************************
1472  5AB7              ; routine that shifts one row of characters
1473  5AB7              ; contains self-modifying code that is set-up from external function
1474  5AB7              ; input HL=pointer to mask data
1475  5AB7              ; input HL'=pointer to character data
1476  5AB7              ; input DE=output buffer containing background data
1477  5AB7              ; input A=number of characters to process
1478  5AB7              ; input IX=pointer to structure describing input data
1479  5AB7              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1480  5AB7              SHIFT_ROW:
1481  5AB7 F5           	PUSH AF
1482  5AB8 ED 53 5A 54  		LD (BLIT_TMP1), DE
1483  5ABC E5           		PUSH HL
1484  5ABD CD 00 5B     			CALL .ADDYSHIFT
1485  5AC0 E1           		POP HL
1486  5AC1 ED 53 5C 54  		LD (BLIT_TMP2), DE ; DE+vertical shift
1487  5AC5              .L1:
1488  5AC5 3E 08        		LD A, 8
1489  5AC7 DD 96 02     		SUB (IX+2) ; y shift
1490  5ACA              .CALL1:
1491  5ACA CD 00 00     		CALL 0
1492  5ACD DD 7E 02     		LD A, (IX+2); y shift
1493  5AD0 B7           		OR A
1494  5AD1 28 26        		JR Z, .DONE
1495  5AD3 ED 5B 5A 54  		LD DE, (BLIT_TMP1)
1496  5AD7 E5           		PUSH HL
1497  5AD8 CD 0E 5B     			CALL .DETONEXTROW
1498  5ADB E1           		POP HL
1499  5ADC              .CALL2:
1500  5ADC CD 00 00     		CALL 0
1501  5ADF ED 5B 5A 54  		LD DE, (BLIT_TMP1)
1502  5AE3 E5           		PUSH HL
1503  5AE4 CD 08 5B     			CALL .ADD8
1504  5AE7 E1           		POP HL
1505  5AE8 ED 53 5A 54  		LD (BLIT_TMP1), DE
1506  5AEC ED 5B 5C 54  		LD DE, (BLIT_TMP2)
1507  5AF0 E5           		PUSH HL
1508  5AF1 CD 08 5B     			CALL .ADD8
1509  5AF4 E1           		POP HL
1510  5AF5 ED 53 5C 54  		LD (BLIT_TMP2), DE ; DE+vertical shift
1511  5AF9              .DONE:
1512  5AF9 F1           	POP AF
1513  5AFA 3D           	DEC A
1514  5AFB C8           	RET Z
1515  5AFC F5           	PUSH AF
1516  5AFD C3 C5 5A     	JP .L1
1517  5B00              .ADDYSHIFT:
1518  5B00 EB           	EX DE, HL
1519  5B01 16 00        	LD D, 0
1520  5B03 DD 5E 02     	LD E, (IX+2); y shift
1521  5B06 18 0C        	JR .MOVDEBC
1522  5B08              .ADD8:
1523  5B08 21 08 00     	LD HL, 8
1524  5B0B C3 14 5B     	JP .MOVDEBC
1525  5B0E              .DETONEXTROW:
1526  5B0E DD 6E 06     	LD L, (IX+6)
1527  5B11 DD 66 07     	LD H, (IX+7) ; bkg add to value
1528  5B14              .MOVDEBC:
1529  5B14 19           	ADD HL, DE
1530  5B15 54           	LD D, H
1531  5B16 5D           	LD E, L
1532  5B17 01 08 00     	LD BC, 8
1533  5B1A 09           	ADD HL, BC
1534  5B1B 44           	LD B, H
1535  5B1C 4D           	LD C, L
1536  5B1D C9           	RET
1537  5B1E              ; *******************************************************************************************************
1538  5B1E
1539  5B1E              ; *******************************************************************************************************
1540  5B1E              ; function rotates mask and character data and applies it to background
1541  5B1E              ; input IX=pointer to structure describing input data
1542  5B1E              ; +0  DW horizontal shift count 0-7 (low byte used)
1543  5B1E              ; +2  DW vertical shift count 0-7 (low byte used)
1544  5B1E              ; +4  DW background data start;
1545  5B1E              ; +6  DW background add to value to next row of background data
1546  5B1E              ; +8  DW mask data start;
1547  5B1E              ; +10  DW character data start;
1548  5B1E              ; +12 DW character&mask add to value to next row of data
1549  5B1E              ; +14 DW columns (low byte used)
1550  5B1E              ; +16 DW rows (low byte used)
1551  5B1E              SHIFT_MERGE_CHARACTER:
1552  5B1E DD 7E 00     	LD A, (IX) ; shift
1553  5B21 FE 05        	CP 5
1554  5B23 38 25        	JR C, .RIGHT
1555  5B25              	; shifts 5-7, use rotate towards left 1-3
1556  5B25 21 7A 5A     	LD HL, SHIFT58
1557  5B28 22 CB 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1558  5B2B 22 DD 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1559  5B2E D6 05        	SUB 5
1560  5B30 28 0D        	JR Z, .L1
1561  5B32 87           	ADD A, A
1562  5B33 87           	ADD A, A
1563  5B34 67           	LD H, A
1564  5B35 2E 18        	LD L, #18 ; JR opcode
1565  5B37 22 81 5A     	LD (SHIFT58.M1), HL
1566  5B3A 22 92 5A     	LD (SHIFT58.M2), HL
1567  5B3D 18 32        	JR .DO
1568  5B3F              .L1:
1569  5B3F 21 00 00     	LD HL, 0 ; 2xNOP opcode
1570  5B42 22 81 5A     	LD (SHIFT58.M1), HL
1571  5B45 22 92 5A     	LD (SHIFT58.M2), HL
1572  5B48 18 27        	JR .DO
1573  5B4A              .RIGHT:
1574  5B4A              	; shifts 0-4, rotate towards right
1575  5B4A 21 35 5A     	LD HL, SHIFT04
1576  5B4D 22 CB 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1577  5B50 22 DD 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1578  5B53 FE 04        	CP 4
1579  5B55 28 11        	JR Z, .R1
1580  5B57 D6 04        	SUB 4
1581  5B59 ED 44        	NEG
1582  5B5B 87           	ADD A, A
1583  5B5C 87           	ADD A, A
1584  5B5D 67           	LD H, A
1585  5B5E 2E 18        	LD L, #18 ; JR opcode
1586  5B60 22 3C 5A     	LD (SHIFT04.M1), HL
1587  5B63 22 51 5A     	LD (SHIFT04.M2), HL
1588  5B66 18 09        	JR .DO
1589  5B68              .R1:
1590  5B68 21 00 00     	LD HL, 0 ; 2xNOP opcode
1591  5B6B 22 3C 5A     	LD (SHIFT04.M1), HL
1592  5B6E 22 51 5A     	LD (SHIFT04.M2), HL
1593  5B71              .DO:
1594  5B71 DD 46 10     	LD B, (IX+16) ; rows
1595  5B74 DD 6E 08     	LD L, (IX+8)
1596  5B77 DD 66 09     	LD H, (IX+9) ; mask data
1597  5B7A DD 5E 04     	LD E, (IX+4)
1598  5B7D DD 56 05     	LD D, (IX+5) ; background data
1599  5B80 D9           	EXX
1600  5B81 DD 6E 0A     	LD L, (IX+10)
1601  5B84 DD 66 0B     	LD H, (IX+11) ; character data
1602  5B87 D9           	EXX
1603  5B88              .LOOP:
1604  5B88 C5           	PUSH BC
1605  5B89 E5           		PUSH HL
1606  5B8A D5           			PUSH DE
1607  5B8B D9           				EXX
1608  5B8C E5           				PUSH HL
1609  5B8D D9           					EXX
1610  5B8E DD 7E 0E     					LD A, (IX+14) ; columns
1611  5B91              .CALL:
1612  5B91 CD B7 5A     					CALL SHIFT_ROW
1613  5B94 E1           				POP HL
1614  5B95 DD 5E 0C     				LD E, (IX+12)
1615  5B98 DD 56 0D     				LD D, (IX+13) ; char data to next row
1616  5B9B 19           				ADD HL, DE
1617  5B9C D9           				EXX
1618  5B9D E1           			POP HL
1619  5B9E DD 5E 06     			LD E, (IX+6)
1620  5BA1 DD 56 07     			LD D, (IX+7) ; background to next row
1621  5BA4 19           			ADD HL, DE
1622  5BA5 EB           			EX DE, HL
1623  5BA6 E1           		POP HL
1624  5BA7 DD 4E 0C     		LD C, (IX+12)
1625  5BAA DD 46 0D     		LD B, (IX+13) ; char data to next row
1626  5BAD 09           		ADD HL, BC
1627  5BAE C1           	POP BC
1628  5BAF 10 D7        	DJNZ .LOOP
1629  5BB1 C9           	RET
1630  5BB2              ; *******************************************************************************************************
1631  5BB2
1632  5BB2               IFNDEF CMDS_WITH_PARAMETERS
1633  5BB2 ~            ; *******************************************************************************************************
1634  5BB2 ~            ; function to handle CALL BLIT basic extension
1635  5BB2 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1636  5BB2 ~            ; fuses with background data and applies vertical shift too
1637  5BB2 ~            ; BLIT ( INT request_data_ptr )
1638  5BB2 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1639  5BB2 ~            ; will put ram in page 0 also, page 1 is already there
1640  5BB2 ~            BLIT:
1641  5BB2 ~            	; opening (
1642  5BB2 ~            	CALL CHKCHAR
1643  5BB2 ~            	DB '('
1644  5BB2 ~            	; get pointer to request struct
1645  5BB2 ~            	LD IX, FRMQNT
1646  5BB2 ~            	CALL CALBAS
1647  5BB2 ~            	PUSH DE
1648  5BB2 ~            	; ending )
1649  5BB2 ~            	CALL CHKCHAR
1650  5BB2 ~            	DB ')'
1651  5BB2 ~
1652  5BB2 ~            	POP IX ; pointer to request struct
1653  5BB2 ~
1654  5BB2 ~            	PUSH HL ; save position in BASIC buffer
1655  5BB2 ~
1656  5BB2 ~            	LD IY, .RET
1657  5BB2 ~            	JP ENABLE_PAGE0
1658  5BB2 ~            .RET:
1659  5BB2 ~            	EI
1660  5BB2 ~            	CALL SHIFT_MERGE_CHARACTER
1661  5BB2 ~
1662  5BB2 ~                POP DE
1663  5BB2 ~                POP BC
1664  5BB2 ~                CALL RESTORE_PAGE_INFO
1665  5BB2 ~
1666  5BB2 ~            	POP HL
1667  5BB2 ~            	RET
1668  5BB2 ~            ; *******************************************************************************************************
1669  5BB2               ENDIF
1670  5BB2
1671  5BB2               IFDEF CMDS_WITH_PARAMETERS
1672  5BB2              ; *******************************************************************************************************
1673  5BB2              ; function to handle CALL BLIT basic extension
1674  5BB2              ; rotates 1-bit character drawing horizontally with mask and character data and
1675  5BB2              ; fuses with background data and applies vertical shift too
1676  5BB2              ; in form without pointers
1677  5BB2              ; BLIT ( INT x,
1678  5BB2              ;		 INT y,
1679  5BB2              ;		 INT char_data_pointer,
1680  5BB2              ;		 INT mask_data_pointer,
1681  5BB2              ;		 INT width (in characters),
1682  5BB2              ;		 INT height (in characters),
1683  5BB2              ;		 INT background_pointer (top left),
1684  5BB2              ;		 INT background_width (in characters),
1685  5BB2              ;		 INT background_height (in characters))
1686  5BB2              ; will put ram in page 0 also, page 1 is already there
1687  5BB2              BLIT:
1688  5BB2              	; opening (
1689  5BB2 CD 08 57     	CALL CHKCHAR
1690  5BB5 28           	DB '('
1691  5BB6              	; get x coordinate
1692  5BB6 DD 21 2F 54  	LD IX, FRMQNT
1693  5BBA CD 59 01     	CALL CALBAS
1694  5BBD 7B           	LD A, E
1695  5BBE E6 07        	AND 7
1696  5BC0 32 5E 54     	LD (BLIT_STRUCT+0), A
1697  5BC3 CD A0 5C     	CALL .DAdiv8
1698  5BC6 32 5A 54     	LD (BLIT_TMP+0),A
1699  5BC9              	; comma
1700  5BC9 CD 08 57     	CALL CHKCHAR
1701  5BCC 2C           	DB ','
1702  5BCD              	; get y coordinate
1703  5BCD DD 21 2F 54  	LD IX, FRMQNT
1704  5BD1 CD 59 01     	CALL CALBAS
1705  5BD4 7B           	LD A, E
1706  5BD5 E6 07        	AND 7
1707  5BD7 32 60 54     	LD (BLIT_STRUCT+2), A
1708  5BDA CD A0 5C     	CALL .DAdiv8
1709  5BDD 32 5B 54     	LD (BLIT_TMP+1),A
1710  5BE0              	; comma
1711  5BE0 CD 08 57     	CALL CHKCHAR
1712  5BE3 2C           	DB ','
1713  5BE4              	; get char data pointer
1714  5BE4 DD 21 2F 54  	LD IX, FRMQNT
1715  5BE8 CD 59 01     	CALL CALBAS
1716  5BEB ED 53 68 54  	LD (BLIT_STRUCT+10), DE
1717  5BEF              	; comma
1718  5BEF CD 08 57     	CALL CHKCHAR
1719  5BF2 2C           	DB ','
1720  5BF3              	; get mask data pointer
1721  5BF3 DD 21 2F 54  	LD IX, FRMQNT
1722  5BF7 CD 59 01     	CALL CALBAS
1723  5BFA ED 53 66 54  	LD (BLIT_STRUCT+8), DE
1724  5BFE              	; comma
1725  5BFE CD 08 57     	CALL CHKCHAR
1726  5C01 2C           	DB ','
1727  5C02              	; get width
1728  5C02 DD 21 2F 54  	LD IX, FRMQNT
1729  5C06 CD 59 01     	CALL CALBAS
1730  5C09 7B           	LD A, E
1731  5C0A 32 6C 54     	LD (BLIT_STRUCT+14), A
1732  5C0D              	; comma
1733  5C0D CD 08 57     	CALL CHKCHAR
1734  5C10 2C           	DB ','
1735  5C11              	; get height
1736  5C11 DD 21 2F 54  	LD IX, FRMQNT
1737  5C15 CD 59 01     	CALL CALBAS
1738  5C18 7B           	LD A, E
1739  5C19 32 6E 54     	LD (BLIT_STRUCT+16), A
1740  5C1C              	; comma
1741  5C1C CD 08 57     	CALL CHKCHAR
1742  5C1F 2C           	DB ','
1743  5C20              	; get background pointer
1744  5C20 DD 21 2F 54  	LD IX, FRMQNT
1745  5C24 CD 59 01     	CALL CALBAS
1746  5C27 ED 53 62 54  	LD (BLIT_STRUCT+4), DE
1747  5C2B              	; comma
1748  5C2B CD 08 57     	CALL CHKCHAR
1749  5C2E 2C           	DB ','
1750  5C2F              	; get background width
1751  5C2F DD 21 2F 54  	LD IX, FRMQNT
1752  5C33 CD 59 01     	CALL CALBAS
1753  5C36 7B           	LD A, E
1754  5C37 32 5C 54     	LD (BLIT_TMP+2), A
1755  5C3A              	; comma
1756  5C3A CD 08 57     	CALL CHKCHAR
1757  5C3D 2C           	DB ','
1758  5C3E              	; get background height
1759  5C3E DD 21 2F 54  	LD IX, FRMQNT
1760  5C42 CD 59 01     	CALL CALBAS
1761  5C45 7B           	LD A, E
1762  5C46 32 5D 54     	LD (BLIT_TMP+3), A
1763  5C49              	; ending )
1764  5C49 CD 08 57     	CALL CHKCHAR
1765  5C4C 29           	DB ')'
1766  5C4D
1767  5C4D E5           	PUSH HL ; save position in BASIC buffer
1768  5C4E
1769  5C4E              	; calculate char&mask add to value
1770  5C4E 26 00        	LD H, 0
1771  5C50 3A 6C 54     	LD A, (BLIT_STRUCT+14)
1772  5C53 6F           	LD L, A
1773  5C54 CD F7 55     	CALL HLx8
1774  5C57 22 6A 54     	LD (BLIT_STRUCT+12), HL
1775  5C5A              	; calculate background add to value
1776  5C5A 26 00        	LD H, 0
1777  5C5C 3A 5C 54     	LD A, (BLIT_TMP+2)
1778  5C5F 6F           	LD L, A
1779  5C60 CD F7 55     	CALL HLx8
1780  5C63 22 64 54     	LD (BLIT_STRUCT+6), HL
1781  5C66              	; calculate pointer to background location
1782  5C66 21 00 00     	LD HL, 0
1783  5C69 3A 5B 54     	LD A,(BLIT_TMP+1)
1784  5C6C B7           	OR A
1785  5C6D 28 08        	JR Z, .L1
1786  5C6F 47           	LD B,A
1787  5C70 ED 5B 64 54  	LD DE,(BLIT_STRUCT+6)
1788  5C74              .L0:
1789  5C74 19           	ADD HL, DE
1790  5C75 10 FD        	DJNZ .L0
1791  5C77              .L1:
1792  5C77 EB           	EX DE,HL
1793  5C78 26 00        	LD H,0
1794  5C7A 3A 5A 54     	LD A,(BLIT_TMP+0)
1795  5C7D 6F           	LD L,A
1796  5C7E CD F7 55     	CALL HLx8
1797  5C81 19           	ADD HL,DE
1798  5C82 ED 5B 62 54  	LD DE,(BLIT_STRUCT+4)
1799  5C86 19           	ADD HL,DE
1800  5C87 22 62 54     	LD (BLIT_STRUCT+4),HL
1801  5C8A
1802  5C8A FD 21 91 5C  	LD IY, .RET
1803  5C8E C3 BB 56     	JP ENABLE_PAGE0
1804  5C91              .RET:
1805  5C91 FB           	EI
1806  5C92 DD 21 5E 54  	LD IX, BLIT_STRUCT
1807  5C96 CD 1E 5B     	CALL SHIFT_MERGE_CHARACTER
1808  5C99
1809  5C99 D1               POP DE
1810  5C9A C1               POP BC
1811  5C9B CD 32 56         CALL RESTORE_PAGE_INFO
1812  5C9E
1813  5C9E E1           	POP HL
1814  5C9F C9           	RET
1815  5CA0              .DAdiv8:
1816  5CA0 7B           	LD A,E
1817  5CA1 CB 2A        	SRA D
1818  5CA3 CB 1F            RR  A
1819  5CA5 CB 2A            SRA D
1820  5CA7 CB 1F            RR  A
1821  5CA9 CB 2A            SRA D
1822  5CAB CB 1F            RR  A
1823  5CAD C9           	RET
1824  5CAE              ; *******************************************************************************************************
1825  5CAE               ENDIF
1826  5CAE               ENDIF
1827  5CAE
1828  5CAE               IF (TILE_CMDS == 1)
1829  5CAE              ; *******************************************************************************************************
1830  5CAE              ; generic function to implement tiling
1831  5CAE              ; should be modified to call appropriate function for memory or vram
1832  5CAE              ; input IX=pointer to following structure
1833  5CAE              ; +00 tile_data_ptr
1834  5CAE              ; +02 tile_rows
1835  5CAE              ; +04 tile_columns
1836  5CAE              ; +06 destination_address
1837  5CAE              ; +08 dest_to_next_row_add_to_value
1838  5CAE              ; +10 num_horizontal_tiles
1839  5CAE              ; +12 num_vertical_tiles
1840  5CAE              ; modifies AF, BC, DE, HL
1841  5CAE              TILE:
1842  5CAE DD 6E 06     	LD L, (IX+6)
1843  5CB1 DD 66 07     	LD H, (IX+7) ; destination address
1844  5CB4 22 5A 54     	LD (TILETMP1), HL
1845  5CB7 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1846  5CBA              .L1:
1847  5CBA C5           	PUSH BC
1848  5CBB DD 6E 00     		LD L, (IX+0)
1849  5CBE DD 66 01     		LD H, (IX+1) ; tile address
1850  5CC1 22 5C 54     		LD (TILETMP2), HL
1851  5CC4 DD 46 02     		LD B, (IX+2) ; tile rows
1852  5CC7              .L2:
1853  5CC7 C5           		PUSH BC
1854  5CC8              .CALL1:
1855  5CC8 CD 00 00     			CALL 0
1856  5CCB DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1857  5CCE              .L3:
1858  5CCE C5           			PUSH BC
1859  5CCF 2A 5C 54     				LD HL, (TILETMP2)
1860  5CD2 DD 46 04     				LD B, (IX+4) ; tile columns
1861  5CD5              .L4:
1862  5CD5 C5           				PUSH BC
1863  5CD6              .CALL2:
1864  5CD6 CD 00 00     					CALL 0
1865  5CD9 C1           				POP BC
1866  5CDA 10 F9        				DJNZ .L4
1867  5CDC C1           			POP BC
1868  5CDD 10 EF        			DJNZ .L3
1869  5CDF 22 5C 54     			LD (TILETMP2), HL
1870  5CE2 2A 5A 54     			LD HL, (TILETMP1)
1871  5CE5 DD 5E 08     			LD E, (IX+8)
1872  5CE8 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1873  5CEB 19           			ADD HL, DE
1874  5CEC 22 5A 54     			LD (TILETMP1), HL
1875  5CEF C1           		POP BC
1876  5CF0 10 D5        		DJNZ .L2
1877  5CF2 C1           	POP BC
1878  5CF3 10 C5        	DJNZ .L1
1879  5CF5 C9           	RET
1880  5CF6              ; *******************************************************************************************************
1881  5CF6
1882  5CF6               IFNDEF CMDS_WITH_PARAMETERS
1883  5CF6 ~            ; *******************************************************************************************************
1884  5CF6 ~            ; function to handle CALL TILERAM basic extension
1885  5CF6 ~            ; fills memory with tiles
1886  5CF6 ~            ; TILERAM ( INT request_data_ptr )
1887  5CF6 ~            ; request_data_ptr described in TILE
1888  5CF6 ~            ; will put ram in page 0 also, page 1 is already there
1889  5CF6 ~            TILERAM:
1890  5CF6 ~            	; opening (
1891  5CF6 ~            	CALL CHKCHAR
1892  5CF6 ~            	DB '('
1893  5CF6 ~            	; get pointer to request struct
1894  5CF6 ~            	LD IX, FRMQNT
1895  5CF6 ~            	CALL CALBAS
1896  5CF6 ~            	PUSH DE
1897  5CF6 ~            	; ending )
1898  5CF6 ~            	CALL CHKCHAR
1899  5CF6 ~            	DB ')'
1900  5CF6 ~
1901  5CF6 ~            	POP IX ; pointer to request struct
1902  5CF6 ~
1903  5CF6 ~            	PUSH HL ; save position in BASIC buffer
1904  5CF6 ~
1905  5CF6 ~            	LD IY, .RET
1906  5CF6 ~            	JP ENABLE_PAGE0
1907  5CF6 ~            .RET:
1908  5CF6 ~            	EI
1909  5CF6 ~            	; set RAM functions to call
1910  5CF6 ~            	LD HL, .TILECOPY
1911  5CF6 ~            	LD (TILE.CALL2+1), HL
1912  5CF6 ~            	LD HL, .SETDESTROW
1913  5CF6 ~            	LD (TILE.CALL1+1), HL
1914  5CF6 ~            	LD A,1
1915  5CF6 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1916  5CF6 ~            	CALL TILE
1917  5CF6 ~            	XOR A
1918  5CF6 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1919  5CF6 ~
1920  5CF6 ~                POP DE
1921  5CF6 ~                POP BC
1922  5CF6 ~                CALL RESTORE_PAGE_INFO
1923  5CF6 ~
1924  5CF6 ~            	POP HL
1925  5CF6 ~            	RET
1926  5CF6 ~            .TILECOPY:
1927  5CF6 ~            	.8 LDI
1928  5CF6 ~            	RET
1929  5CF6 ~            .SETDESTROW:
1930  5CF6 ~            	LD DE, (TILETMP1)
1931  5CF6 ~            	RET
1932  5CF6 ~            ; *******************************************************************************************************
1933  5CF6               ENDIF
1934  5CF6
1935  5CF6               IFDEF CMDS_WITH_PARAMETERS
1936  5CF6              ; *******************************************************************************************************
1937  5CF6              ; function to handle CALL TILERAM basic extension
1938  5CF6              ; fills memory with tiles
1939  5CF6              ; TILERAM ( INT tile_data_pointer,
1940  5CF6              ;			INT tile_columns,
1941  5CF6              ;			INT tile_rows,
1942  5CF6              ;			INT destination_pointer,
1943  5CF6              ;			INT destination_columns,
1944  5CF6              ;			INT destination_rows,
1945  5CF6              ;			INT destination_begin_column,
1946  5CF6              ;			INT destination_begin_row,
1947  5CF6              ;			INT number_of_tiles_horizontally,
1948  5CF6              ;			INT	number_of_tiles_vertically )
1949  5CF6              ; will put ram in page 0 also, page 1 is already there
1950  5CF6              TILERAM:
1951  5CF6              	; opening (
1952  5CF6 CD 08 57     	CALL CHKCHAR
1953  5CF9 28           	DB '('
1954  5CFA              	; get tile data pointer coordinate
1955  5CFA DD 21 2F 54  	LD IX, FRMQNT
1956  5CFE CD 59 01     	CALL CALBAS
1957  5D01 ED 53 5E 54  	LD (BLIT_STRUCT+0), DE
1958  5D05              	; comma
1959  5D05 CD 08 57     	CALL CHKCHAR
1960  5D08 2C           	DB ','
1961  5D09              	; get tile columns
1962  5D09 DD 21 2F 54  	LD IX, FRMQNT
1963  5D0D CD 59 01     	CALL CALBAS
1964  5D10 ED 53 62 54  	LD (BLIT_STRUCT+4), DE
1965  5D14              	; comma
1966  5D14 CD 08 57     	CALL CHKCHAR
1967  5D17 2C           	DB ','
1968  5D18              	; get tile columns
1969  5D18 DD 21 2F 54  	LD IX, FRMQNT
1970  5D1C CD 59 01     	CALL CALBAS
1971  5D1F ED 53 60 54  	LD (BLIT_STRUCT+2), DE
1972  5D23              	; comma
1973  5D23 CD 08 57     	CALL CHKCHAR
1974  5D26 2C           	DB ','
1975  5D27              	; get destintion pointer
1976  5D27 DD 21 2F 54  	LD IX, FRMQNT
1977  5D2B CD 59 01     	CALL CALBAS
1978  5D2E ED 53 64 54  	LD (BLIT_STRUCT+6), DE
1979  5D32              	; comma
1980  5D32 CD 08 57     	CALL CHKCHAR
1981  5D35 2C           	DB ','
1982  5D36              	; get destination columns
1983  5D36 DD 21 2F 54  	LD IX, FRMQNT
1984  5D3A CD 59 01     	CALL CALBAS
1985  5D3D 7B           	LD A, E
1986  5D3E 32 5A 54     	LD (BLIT_TMP+0), A
1987  5D41              	; comma
1988  5D41 CD 08 57     	CALL CHKCHAR
1989  5D44 2C           	DB ','
1990  5D45              	; get destination rows
1991  5D45 DD 21 2F 54  	LD IX, FRMQNT
1992  5D49 CD 59 01     	CALL CALBAS
1993  5D4C 7B           	LD A, E
1994  5D4D 32 5B 54     	LD (BLIT_TMP+1), A
1995  5D50              	; comma
1996  5D50 CD 08 57     	CALL CHKCHAR
1997  5D53 2C           	DB ','
1998  5D54              	; get destination begin column
1999  5D54 DD 21 2F 54  	LD IX, FRMQNT
2000  5D58 CD 59 01     	CALL CALBAS
2001  5D5B 7B           	LD A, E
2002  5D5C 32 5C 54     	LD (BLIT_TMP+2), A
2003  5D5F              	; comma
2004  5D5F CD 08 57     	CALL CHKCHAR
2005  5D62 2C           	DB ','
2006  5D63              	; get destination begin row
2007  5D63 DD 21 2F 54  	LD IX, FRMQNT
2008  5D67 CD 59 01     	CALL CALBAS
2009  5D6A 7B           	LD A, E
2010  5D6B 32 5D 54     	LD (BLIT_TMP+3), A
2011  5D6E              	; comma
2012  5D6E CD 08 57     	CALL CHKCHAR
2013  5D71 2C           	DB ','
2014  5D72              	; get number of tiles horizontally
2015  5D72 DD 21 2F 54  	LD IX, FRMQNT
2016  5D76 CD 59 01     	CALL CALBAS
2017  5D79 ED 53 68 54  	LD (BLIT_STRUCT+10), DE
2018  5D7D              	; comma
2019  5D7D CD 08 57     	CALL CHKCHAR
2020  5D80 2C           	DB ','
2021  5D81              	; get number of tiles vertically
2022  5D81 DD 21 2F 54  	LD IX, FRMQNT
2023  5D85 CD 59 01     	CALL CALBAS
2024  5D88 ED 53 6A 54  	LD (BLIT_STRUCT+12), DE
2025  5D8C              	; ending )
2026  5D8C CD 08 57     	CALL CHKCHAR
2027  5D8F 29           	DB ')'
2028  5D90
2029  5D90 E5           	PUSH HL ; save position in BASIC buffer
2030  5D91
2031  5D91              	; calculate destination add to value
2032  5D91 26 00        	LD H, 0
2033  5D93 3A 5A 54     	LD A, (BLIT_TMP+0)
2034  5D96 6F           	LD L, A
2035  5D97 CD F7 55     	CALL HLx8
2036  5D9A 22 66 54     	LD (BLIT_STRUCT+8), HL
2037  5D9D              	; calculate pointer to background location
2038  5D9D 21 00 00     	LD HL, 0
2039  5DA0 3A 5D 54     	LD A,(BLIT_TMP+3)
2040  5DA3 B7           	OR A
2041  5DA4 28 08        	JR Z, .L1
2042  5DA6 47           	LD B,A
2043  5DA7 ED 5B 66 54  	LD DE,(BLIT_STRUCT+8)
2044  5DAB              .L0:
2045  5DAB 19           	ADD HL, DE
2046  5DAC 10 FD        	DJNZ .L0
2047  5DAE              .L1:
2048  5DAE EB           	EX DE,HL
2049  5DAF 26 00        	LD H,0
2050  5DB1 3A 5C 54     	LD A,(BLIT_TMP+2)
2051  5DB4 6F           	LD L,A
2052  5DB5 CD F7 55     	CALL HLx8
2053  5DB8 19           	ADD HL,DE
2054  5DB9 ED 5B 64 54  	LD DE,(BLIT_STRUCT+6)
2055  5DBD 19           	ADD HL,DE
2056  5DBE 22 64 54     	LD (BLIT_STRUCT+6),HL
2057  5DC1
2058  5DC1 FD 21 C8 5D  	LD IY, .RET
2059  5DC5 C3 BB 56     	JP ENABLE_PAGE0
2060  5DC8              .RET:
2061  5DC8 FB           	EI
2062  5DC9              	; set RAM functions to call
2063  5DC9 21 E3 5D     	LD HL, .TILECOPY
2064  5DCC 22 D7 5C     	LD (TILE.CALL2+1), HL
2065  5DCF 21 F4 5D     	LD HL, .SETDESTROW
2066  5DD2 22 C9 5C     	LD (TILE.CALL1+1), HL
2067  5DD5 DD 21 5E 54  	LD IX,BLIT_STRUCT
2068  5DD9 CD AE 5C     	CALL TILE
2069  5DDC
2070  5DDC D1               POP DE
2071  5DDD C1               POP BC
2072  5DDE CD 32 56         CALL RESTORE_PAGE_INFO
2073  5DE1
2074  5DE1 E1           	POP HL
2075  5DE2 C9           	RET
2076  5DE3              .TILECOPY:
2077  5DE3 ED A0       > LDI
2077  5DE5 ED A0       > LDI
2077  5DE7 ED A0       > LDI
2077  5DE9 ED A0       > LDI
2077  5DEB ED A0       > LDI
2077  5DED ED A0       > LDI
2077  5DEF ED A0       > LDI
2077  5DF1 ED A0       > LDI
2078  5DF3 C9           	RET
2079  5DF4              .SETDESTROW:
2080  5DF4 ED 5B 5A 54  	LD DE, (TILETMP1)
2081  5DF8 C9           	RET
2082  5DF9              ; *******************************************************************************************************
2083  5DF9               ENDIF
2084  5DF9
2085  5DF9               IFDEF CMDS_WITH_PARAMETERS
2086  5DF9              ; *******************************************************************************************************
2087  5DF9              ; function to handle CALL TILEVRM basic extension
2088  5DF9              ; fills vram with tiles
2089  5DF9              ; TILEVRM ( INT tile_data_pointer,
2090  5DF9              ;			INT tile_columns,
2091  5DF9              ;			INT tile_rows,
2092  5DF9              ;			INT destination_begin_column,
2093  5DF9              ;			INT destination_begin_row,
2094  5DF9              ;			INT number_of_tiles_horizontally,
2095  5DF9              ;			INT	number_of_tiles_vertically )
2096  5DF9              ; will put ram in page 0 also, page 1 is already there
2097  5DF9              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2098  5DF9              TILEVRM:
2099  5DF9              	; opening (
2100  5DF9 CD 08 57     	CALL CHKCHAR
2101  5DFC 28           	DB '('
2102  5DFD              	; get tile data pointer coordinate
2103  5DFD DD 21 2F 54  	LD IX, FRMQNT
2104  5E01 CD 59 01     	CALL CALBAS
2105  5E04 ED 53 5E 54  	LD (BLIT_STRUCT+0), DE
2106  5E08              	; comma
2107  5E08 CD 08 57     	CALL CHKCHAR
2108  5E0B 2C           	DB ','
2109  5E0C              	; get tile columns
2110  5E0C DD 21 2F 54  	LD IX, FRMQNT
2111  5E10 CD 59 01     	CALL CALBAS
2112  5E13 ED 53 62 54  	LD (BLIT_STRUCT+4), DE
2113  5E17              	; comma
2114  5E17 CD 08 57     	CALL CHKCHAR
2115  5E1A 2C           	DB ','
2116  5E1B              	; get tile columns
2117  5E1B DD 21 2F 54  	LD IX, FRMQNT
2118  5E1F CD 59 01     	CALL CALBAS
2119  5E22 ED 53 60 54  	LD (BLIT_STRUCT+2), DE
2120  5E26              	; comma
2121  5E26 CD 08 57     	CALL CHKCHAR
2122  5E29 2C           	DB ','
2123  5E2A              	; get destination begin column
2124  5E2A DD 21 2F 54  	LD IX, FRMQNT
2125  5E2E CD 59 01     	CALL CALBAS
2126  5E31 7B           	LD A, E
2127  5E32 32 5C 54     	LD (BLIT_TMP+2), A
2128  5E35              	; comma
2129  5E35 CD 08 57     	CALL CHKCHAR
2130  5E38 2C           	DB ','
2131  5E39              	; get destination begin row
2132  5E39 DD 21 2F 54  	LD IX, FRMQNT
2133  5E3D CD 59 01     	CALL CALBAS
2134  5E40 7B           	LD A, E
2135  5E41 32 5D 54     	LD (BLIT_TMP+3), A
2136  5E44              	; comma
2137  5E44 CD 08 57     	CALL CHKCHAR
2138  5E47 2C           	DB ','
2139  5E48              	; get number of tiles horizontally
2140  5E48 DD 21 2F 54  	LD IX, FRMQNT
2141  5E4C CD 59 01     	CALL CALBAS
2142  5E4F ED 53 68 54  	LD (BLIT_STRUCT+10), DE
2143  5E53              	; comma
2144  5E53 CD 08 57     	CALL CHKCHAR
2145  5E56 2C           	DB ','
2146  5E57              	; get number of tiles vertically
2147  5E57 DD 21 2F 54  	LD IX, FRMQNT
2148  5E5B CD 59 01     	CALL CALBAS
2149  5E5E ED 53 6A 54  	LD (BLIT_STRUCT+12), DE
2150  5E62              	; ending )
2151  5E62 CD 08 57     	CALL CHKCHAR
2152  5E65 29           	DB ')'
2153  5E66
2154  5E66 E5           	PUSH HL ; save position in BASIC buffer
2155  5E67
2156  5E67              	; calculate destination add to value
2157  5E67 21 00 01     	LD HL, 256
2158  5E6A 22 66 54     	LD (BLIT_STRUCT+8), HL
2159  5E6D              	; calculate pointer to background location
2160  5E6D 3A 5D 54     	LD A,(BLIT_TMP+3)
2161  5E70 67           	LD H,A
2162  5E71 2E 00        	LD L,0
2163  5E73 EB           	EX DE,HL
2164  5E74 26 00        	LD H,0
2165  5E76 3A 5C 54     	LD A,(BLIT_TMP+2)
2166  5E79 6F           	LD L,A
2167  5E7A CD F7 55     	CALL HLx8
2168  5E7D 19           	ADD HL,DE
2169  5E7E ED 5B CB F3  	LD DE,(GRPCGP)
2170  5E82 19           	ADD HL,DE
2171  5E83 22 64 54     	LD (BLIT_STRUCT+6),HL
2172  5E86
2173  5E86 FD 21 8D 5E  	LD IY, .RET
2174  5E8A C3 BB 56     	JP ENABLE_PAGE0
2175  5E8D              .RET:
2176  5E8D FB           	EI
2177  5E8E              	; set RAM functions to call
2178  5E8E 21 A8 5E     	LD HL, .TILECOPY
2179  5E91 22 D7 5C     	LD (TILE.CALL2+1), HL
2180  5E94 21 AE 5E     	LD HL, .SETDESTROW
2181  5E97 22 C9 5C     	LD (TILE.CALL1+1), HL
2182  5E9A DD 21 5E 54  	LD IX,BLIT_STRUCT
2183  5E9E CD AE 5C     	CALL TILE
2184  5EA1
2185  5EA1 D1               POP DE
2186  5EA2 C1               POP BC
2187  5EA3 CD 32 56         CALL RESTORE_PAGE_INFO
2188  5EA6
2189  5EA6 E1           	POP HL
2190  5EA7 C9           	RET
2191  5EA8              .TILECOPY:
2192  5EA8 01 98 08     	LD BC, #0898
2193  5EAB C3 EF 55     	JP BBYTECOPY
2194  5EAE              .SETDESTROW:
2195  5EAE 2A 5A 54     	LD HL, (TILETMP1)
2196  5EB1 F3           	DI
2197  5EB2 CD E4 55     	CALL SETWRT_LOCAL
2198  5EB5 FB           	EI
2199  5EB6 C9           	RET
2200  5EB7              ; *******************************************************************************************************
2201  5EB7               ENDIF
2202  5EB7
2203  5EB7               IFNDEF CMDS_WITH_PARAMETERS
2204  5EB7 ~            ; *******************************************************************************************************
2205  5EB7 ~            ; function to handle CALL TILEVRM basic extension
2206  5EB7 ~            ; fills vram with tiles
2207  5EB7 ~            ; TILEVRM ( INT request_data_ptr )
2208  5EB7 ~            ; request_data_ptr described in TILE
2209  5EB7 ~            ; will put ram in page 0 also, page 1 is already there
2210  5EB7 ~            TILEVRM:
2211  5EB7 ~            	; opening (
2212  5EB7 ~            	CALL CHKCHAR
2213  5EB7 ~            	DB '('
2214  5EB7 ~            	; get pointer to request struct
2215  5EB7 ~            	LD IX, FRMQNT
2216  5EB7 ~            	CALL CALBAS
2217  5EB7 ~            	PUSH DE
2218  5EB7 ~            	; ending )
2219  5EB7 ~            	CALL CHKCHAR
2220  5EB7 ~            	DB ')'
2221  5EB7 ~
2222  5EB7 ~            	POP IX ; pointer to request struct
2223  5EB7 ~
2224  5EB7 ~            	PUSH HL ; save position in BASIC buffer
2225  5EB7 ~
2226  5EB7 ~            	LD IY, .RET
2227  5EB7 ~            	JP ENABLE_PAGE0
2228  5EB7 ~            .RET:
2229  5EB7 ~            	EI
2230  5EB7 ~            	; set RAM functions to call
2231  5EB7 ~            	LD HL, .TILECOPY
2232  5EB7 ~            	LD (TILE.CALL2+1), HL
2233  5EB7 ~            	LD HL, .SETDESTROW
2234  5EB7 ~            	LD (TILE.CALL1+1), HL
2235  5EB7 ~            	CALL TILE
2236  5EB7 ~
2237  5EB7 ~                POP DE
2238  5EB7 ~                POP BC
2239  5EB7 ~                CALL RESTORE_PAGE_INFO
2240  5EB7 ~
2241  5EB7 ~            	POP HL
2242  5EB7 ~            	RET
2243  5EB7 ~            .TILECOPY:
2244  5EB7 ~            	LD BC, #0898
2245  5EB7 ~            	JP BBYTECOPY
2246  5EB7 ~            .SETDESTROW:
2247  5EB7 ~            	LD HL, (TILETMP1)
2248  5EB7 ~            	DI
2249  5EB7 ~            	CALL SETWRT_LOCAL
2250  5EB7 ~            	EI
2251  5EB7 ~            	RET
2252  5EB7 ~            ; *******************************************************************************************************
2253  5EB7               ENDIF
2254  5EB7               ENDIF
2255  5EB7
2256  5EB7               IF (BOX_CMDS == 1)
2257  5EB7              ; *******************************************************************************************************
2258  5EB7              ; generic function to implement rectangle data copy
2259  5EB7              ; should be modified to call appropriate function for memory or vram
2260  5EB7              ; input IX=pointer to following structure
2261  5EB7              ; +00 source data pointer
2262  5EB7              ; +02 num bytes in a row
2263  5EB7              ; +04 number of rows
2264  5EB7              ; +06 source add-to value till next row
2265  5EB7              ; +08 destination address
2266  5EB7              ; +10 destination add-to value till next row
2267  5EB7              ; modifies AF, BC, DE, HL
2268  5EB7              RECTANGLE_COPY:
2269  5EB7 DD 6E 00     	LD L, (IX+0)
2270  5EBA DD 66 01     	LD H, (IX+1) ; source address
2271  5EBD DD 5E 08     	LD E, (IX+8)
2272  5EC0 DD 56 09     	LD D, (IX+9) ; destination
2273  5EC3 DD 46 04     	LD B, (IX+4) ; row number
2274  5EC6              .L1:
2275  5EC6 C5           	PUSH BC
2276  5EC7 E5           		PUSH HL
2277  5EC8 D5           			PUSH DE
2278  5EC9 DD 4E 02     				LD C, (IX+2)
2279  5ECC DD 46 03     				LD B, (IX+3) ; num bytes in a row
2280  5ECF              .CALL1:
2281  5ECF CD 00 00     				CALL 0 ; set destination address from DE
2282  5ED2              .CALL2:
2283  5ED2 CD 00 00     				CALL 0 ; copy data fn
2284  5ED5 E1           			POP HL
2285  5ED6 DD 4E 0A     			LD C, (IX+10)
2286  5ED9 DD 46 0B     			LD B, (IX+11) ; destination add-to
2287  5EDC 09           			ADD HL, BC
2288  5EDD EB           			EX DE, HL
2289  5EDE E1           		POP HL
2290  5EDF DD 4E 06     		LD C, (IX+6)
2291  5EE2 DD 46 07     		LD B, (IX+7) ; src add-to
2292  5EE5 09           		ADD HL, BC
2293  5EE6 C1           	POP BC
2294  5EE7 10 DD        	DJNZ .L1
2295  5EE9 C9           	RET
2296  5EEA              ; *******************************************************************************************************
2297  5EEA
2298  5EEA              ; *******************************************************************************************************
2299  5EEA              ; function to handle CALL BOXMEMCPY basic extension
2300  5EEA              ; copies data with window like boundaries to ram
2301  5EEA              ; BOXMEMCPY ( INT request_data_ptr )
2302  5EEA              ; request_data_ptr described in RECTANGLE_COPY
2303  5EEA              ; will put ram in page 0 also, page 1 is already there
2304  5EEA              BOXMEMCPY:
2305  5EEA              	; opening (
2306  5EEA CD 08 57     	CALL CHKCHAR
2307  5EED 28           	DB '('
2308  5EEE              	; get pointer to request struct
2309  5EEE DD 21 2F 54  	LD IX, FRMQNT
2310  5EF2 CD 59 01     	CALL CALBAS
2311  5EF5 D5           	PUSH DE
2312  5EF6              	; ending )
2313  5EF6 CD 08 57     	CALL CHKCHAR
2314  5EF9 29           	DB ')'
2315  5EFA
2316  5EFA DD E1        	POP IX ; pointer to request struct
2317  5EFC
2318  5EFC E5           	PUSH HL ; save position in BASIC buffer
2319  5EFD
2320  5EFD FD 21 04 5F  	LD IY, .RET
2321  5F01 C3 BB 56     	JP ENABLE_PAGE0
2322  5F04              .RET:
2323  5F04 FB           	EI
2324  5F05              	; set RAM functions to call
2325  5F05 21 00 00     	LD HL, 0
2326  5F08 22 CF 5E     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2327  5F0B 22 D1 5E     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2328  5F0E 21 ED B0     	LD HL, #B0ED ; LDIR
2329  5F11 22 D3 5E     	LD (RECTANGLE_COPY.CALL1+4), HL
2330  5F14 CD B7 5E     	CALL RECTANGLE_COPY
2331  5F17
2332  5F17 D1               POP DE
2333  5F18 C1               POP BC
2334  5F19 CD 32 56         CALL RESTORE_PAGE_INFO
2335  5F1C
2336  5F1C E1           	POP HL
2337  5F1D C9           	RET
2338  5F1E              ; *******************************************************************************************************
2339  5F1E
2340  5F1E              ; *******************************************************************************************************
2341  5F1E              ; function to handle CALL BOXMEMVRM basic extension
2342  5F1E              ; copies data with window like boundaries to ram
2343  5F1E              ; BOXMEMVRM ( INT request_data_ptr )
2344  5F1E              ; request_data_ptr described in RECTANGLE_COPY
2345  5F1E              ; will put ram in page 0 also, page 1 is already there
2346  5F1E              BOXMEMVRM:
2347  5F1E              	; opening (
2348  5F1E CD 08 57     	CALL CHKCHAR
2349  5F21 28           	DB '('
2350  5F22              	; get pointer to request struct
2351  5F22 DD 21 2F 54  	LD IX, FRMQNT
2352  5F26 CD 59 01     	CALL CALBAS
2353  5F29 D5           	PUSH DE
2354  5F2A              	; ending )
2355  5F2A CD 08 57     	CALL CHKCHAR
2356  5F2D 29           	DB ')'
2357  5F2E
2358  5F2E DD E1        	POP IX ; pointer to request struct
2359  5F30
2360  5F30 E5           	PUSH HL ; save position in BASIC buffer
2361  5F31
2362  5F31 FD 21 38 5F  	LD IY, .RET
2363  5F35 C3 BB 56     	JP ENABLE_PAGE0
2364  5F38              .RET:
2365  5F38 FB           	EI
2366  5F39              	; set RAM functions to call
2367  5F39 21 60 5F     	LD HL, .SETDEST
2368  5F3C 22 D0 5E     	LD (RECTANGLE_COPY.CALL1+1), HL
2369  5F3F 21 68 5F     	LD HL, .COPYDATA
2370  5F42 22 D3 5E     	LD (RECTANGLE_COPY.CALL2+1), HL
2371  5F45 3E CD        	LD A, #CD ; CALL
2372  5F47 32 CF 5E     	LD (RECTANGLE_COPY.CALL1), A
2373  5F4A 32 D2 5E     	LD (RECTANGLE_COPY.CALL2), A
2374  5F4D 3E 01        	LD A,1
2375  5F4F 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
2376  5F52 CD B7 5E     	CALL RECTANGLE_COPY
2377  5F55 AF           	XOR A
2378  5F56 32 6F 54     	LD (VRAM_UPDATE_IN_PROGRESS),A
2379  5F59
2380  5F59 D1               POP DE
2381  5F5A C1               POP BC
2382  5F5B CD 32 56         CALL RESTORE_PAGE_INFO
2383  5F5E
2384  5F5E E1           	POP HL
2385  5F5F C9           	RET
2386  5F60              .SETDEST:
2387  5F60 EB           	EX DE, HL
2388  5F61 F3           	DI
2389  5F62 CD E4 55     	CALL SETWRT_LOCAL
2390  5F65 FB           	EI
2391  5F66 EB           	EX DE, HL
2392  5F67 C9           	RET
2393  5F68              .COPYDATA:
2394  5F68 41           	LD B, C
2395  5F69 0E 98        	LD C, #98
2396  5F6B C3 EF 55     	JP BBYTECOPY
2397  5F6E              ; *******************************************************************************************************
2398  5F6E               ENDIF
2399  5F6E
2400  5F6E              EXT_END:
2401  5F6E
# file closed: asm\main.asm
