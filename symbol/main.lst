# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000
 14   4000               DEFINE CMDS_WITH_PARAMETERS
 15   4000
 16   4000              CHPUT   EQU     #A2
 17   4000              CALBAS	EQU		#159
 18   4000              ERRHAND EQU     #406F
 19   4000              FRMEVL  EQU     #4C64
 20   4000              FRESTR	EQU		#67D0
 21   4000              ; FRMQNT = formula quantificator
 22   4000              ; input HL=pointer to current program expression
 23   4000              ; output HL=next address
 24   4000              ; output DE=integer datum
 25   4000              FRMQNT	EQU		#542F
 26   4000              ; GETBYT = get byte parameter
 27   4000              ; input HL=pointer to current program expression
 28   4000              ; output HL=next address
 29   4000              ; output A=E=byte read
 30   4000              GETBYT		EQU		#521C
 31   4000              CHRGTR  	EQU     #4666
 32   4000              PTRGET		EQU 	#5EA4
 33   4000              SUBFLG		EQU		#F6A5
 34   4000              SYNCHR		EQU		#558C
 35   4000              VALTYP  	EQU     #F663
 36   4000              USR     	EQU     #F7F8
 37   4000              PROCNM		EQU		#FD89
 38   4000              BIOS_FILVRM EQU     #0056
 39   4000              CLIKSW		EQU		#F3DB
 40   4000              ATRBAS		EQU		#F928
 41   4000              GRPCGP		EQU		#F3CB
 42   4000
 43   4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 44   4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 45   4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 46   4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 47   4000              EXPTBL	EQU #FCC1
 48   4000              SCRMOD	EQU #FCAF ; current screen mode
 49   4000              REG1SAV EQU #F3E0 ; VDP(1)
 50   4000              JIFFY	EQU #FC9E
 51   4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
 52   4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
 53   4000              PATBAS  EQU #F926 ; current sprite generator table address
 54   4000
 55   4000              ; BASIC error codes
 56   4000              ;01 NEXT without FOR
 57   4000              ;02 Syntax error
 58   4000              ;03 RETURN without GOSUB
 59   4000              ;04 Out of DATA
 60   4000              ;05 Illegal function call
 61   4000              ;06 Overflow
 62   4000              ;07 Out of memory
 63   4000              ;08 Undefined line number
 64   4000              ;09 Subscript out of range
 65   4000              ;10 Redimensioned array
 66   4000              ;11 Division by zero
 67   4000              ;12 Illegal direct
 68   4000              ;13 Type mismatch
 69   4000              ;14 Out of string space
 70   4000              ;15 String too long
 71   4000              ;16 String formula too complex
 72   4000              ;17 Can't CONTINUE
 73   4000              ;18 Undefined user function
 74   4000              ;19 Device I/O error
 75   4000              ;20 Verify error
 76   4000              ;21 No RESUME
 77   4000              ;22 RESUME without error
 78   4000              ;23 Unprintable error
 79   4000              ;24 Missing operand
 80   4000              ;25 Line buffer overflow
 81   4000              ;50 FIELD overflow
 82   4000              ;51 Internal error
 83   4000              ;52 Bad file number
 84   4000              ;53 File not found
 85   4000              ;54 File already open
 86   4000              ;55 Input past end
 87   4000              ;56 Bad file name
 88   4000              ;57 Direct statement in file
 89   4000              ;58 Sequential I/O only
 90   4000              ;59 File not OPEN
 91   4000
 92   4000
 93   4000               ; simulate cartridge with BASIC extension
 94   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 94   4004 A7 5E 00 00
 94   4008 00 00 00 00
 94   400C 00 00 00 00
 95   4010
 96   4010              ; this location #4010 stores last location used by basic extension
 97   4010              ; free memory after that point
 98   4010              FREEMEMPTR:
 99   4010 40 5F         DW EXT_END
100   4012
101   4012              ; this location #4012 stores extension version in DAA format
102   4012              ; first byte is major version and second minor
103   4012              VERSION:
104   4012 00 70         DB #00, #70
105   4014
106   4014              ; binary included AKG player compiled at #4014
107   4014               IF (SOUND_CMDS == 1)
108   4014              	INCBIN "bin/AKG.bin"
109   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
110   4CF0               ENDIF
111   4CF0
112   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A 94 54     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD D7 5D         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD 1E 5E         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD D7 5D         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD 1E 5E         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A 94 54     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD 0E 5E         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD 0E 5E         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A 49 5C         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD 21 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
113   4D73
114   4D73               IF (SPRITE_CMDS == 1)
115   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD D3 5D         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D95 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D98 B7           	OR A
 55+  4D99 28 03        	JR Z, .L3
 56+  4D9B 3A 79 4D     	LD A, (FLICKER)
 57+  4D9E              .L3:
 58+  4D9E 5F           	LD E, A
 59+  4D9F 08           	EX AF, AF'
 60+  4DA0 7B           	LD A, E
 61+  4DA1 87           	ADD A, A
 62+  4DA2 87           	ADD A, A
 63+  4DA3 16 00        	LD D, 0
 64+  4DA5 5F           	LD E, A
 65+  4DA6 19           	ADD HL, DE
 66+  4DA7 CD BE 5D     	CALL SETWRT_LOCAL
 67+  4DAA ED 73 7A 4D  	LD (TMPSP), SP
 68+  4DAE ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 69+  4DB2
 70+  4DB2              .LOOP:
 71+  4DB2 E1           	POP HL
 72+  4DB3 24           	INC H
 73+  4DB4 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DB6 25           	DEC H
 75+  4DB7 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DB9 7D           	LD A, L
 77+  4DBA FE C0        	CP 192
 78+  4DBC 30 10        	JR NC, .OUT3
 79+  4DBE 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DBF 57           	LD D, A
 81+  4DC0 C3 E7 4D     	JP .X
 82+  4DC3              .L1:
 83+  4DC3 7D           	LD A, L
 84+  4DC4 C6 10        	ADD 16
 85+  4DC6 FA CE 4D     	JP M, .OUT3 ; below -16
 86+  4DC9 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DCA 55           	LD D, L
 88+  4DCB C3 E7 4D     	JP .X
 89+  4DCE              .OUT3:
 90+  4DCE E1           	POP HL ; skip x value
 91+  4DCF              .OUT2:
 92+  4DCF E1           	POP HL ; skip pattern
 93+  4DD0 E1           	POP HL ; skip color
 94+  4DD1 3E D1        	LD A, #D1
 95+  4DD3 ED 79        	OUT (C), A ; sprite hidden
 96+  4DD5 00          > NOP
 96+  4DD6 00          > NOP
 96+  4DD7 00          > NOP
 97+  4DD8 ED 79        	OUT (C), A ; value unimportant
 98+  4DDA 00          > NOP
 98+  4DDB 00          > NOP
 98+  4DDC 00          > NOP
 99+  4DDD ED 79        	OUT (C), A ; value unimportant
100+  4DDF 00          > NOP
100+  4DE0 00          > NOP
100+  4DE1 00          > NOP
101+  4DE2 ED 79        	OUT (C), A ; value unimportant
102+  4DE4 C3 12 4E     	JP .NEXT
103+  4DE7              .X:
104+  4DE7 E1           	POP HL
105+  4DE8 24           	INC H
106+  4DE9 28 08        	JR Z, .L2
107+  4DEB 25           	DEC H
108+  4DEC 20 E1        	JR NZ, .OUT2
109+  4DEE 1E 00        	LD E, 0 ; EC bit
110+  4DF0 C3 FC 4D     	JP .XY
111+  4DF3              .L2:
112+  4DF3 7D           	LD A, L
113+  4DF4 C6 20        	ADD 32
114+  4DF6 FA CF 4D     	JP M, .OUT2
115+  4DF9 6F           	LD L, A
116+  4DFA 1E 80        	LD E, #80
117+  4DFC              .XY:
118+  4DFC ED 51        	OUT (C), D
119+  4DFE 3A E0 F3     	LD A, (REG1SAV)
120+  4E01 E6 02        	AND 2
121+  4E03 ED 69        	OUT (C), L
122+  4E05 E1           	POP HL ; pattern
123+  4E06 7D           	LD A, L
124+  4E07 28 02        	JR Z, .SMALLSPRITES
125+  4E09 87           	ADD A, A
126+  4E0A 87           	ADD A, A ; needs to go at 4x
127+  4E0B              .SMALLSPRITES:
128+  4E0B D3 98        	OUT (#98), A
129+  4E0D E1           	POP HL ; color
130+  4E0E 7D           	LD A, L
131+  4E0F B3           	OR E
132+  4E10 D3 98        	OUT (#98), A
133+  4E12              .NEXT:
134+  4E12 08           	EX AF, AF'
135+  4E13 3C           	INC A
136+  4E14 E6 1F        	AND 31
137+  4E16 C2 2A 4E     	JP NZ, .NEXT2
138+  4E19 08           	EX AF, AF'
139+  4E1A 2A 28 F9     	LD HL, (ATRBAS)
140+  4E1D              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E1D 7D           	LD	A, L
142+  4E1E D3 99        	OUT	(099H), A
143+  4E20 7C           	LD	A, H
144+  4E21 E6 3F        	AND	03FH
145+  4E23 F6 40        	OR	040H
146+  4E25 D3 99        	OUT	(099H), A
147+  4E27 C3 2B 4E     	JP .NEXT3
148+  4E2A              .NEXT2:
149+  4E2A 08           	EX AF, AF'
150+  4E2B              .NEXT3:
151+  4E2B 10 85        	DJNZ .LOOP
152+  4E2D 08           	EX AF, AF'
153+  4E2E 3C           	INC A
154+  4E2F 32 79 4D     	LD (FLICKER), A
155+  4E32
156+  4E32 ED 7B 7A 4D  	LD SP, (TMPSP)
157+  4E36 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E39 36 00        	LD (HL), 0 ; zero out update flag
159+  4E3B C9           	RET
160+  4E3C              ; *******************************************************************************************************
161+  4E3C
162+  4E3C              ; *******************************************************************************************************
163+  4E3C              ; function to handle CALL SPRENABLE basic extension
164+  4E3C              ; initializes sprites handler
165+  4E3C              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E3C              ;			   INT update_variable,
167+  4E3C              ;			   BYTE sprite_flicker_enabled )
168+  4E3C              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E3C              SPRENABLE:
170+  4E3C              	; opening (
171+  4E3C CD E4 5E     	CALL CHKCHAR
172+  4E3F 28           	DB '('
173+  4E40              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E40 3E 02        	LD A,2
175+  4E42 06 02        	LD B,2
176+  4E44 11 20 04     	LD DE,#0420
177+  4E47 CD 0B 5F     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E4A C5           	PUSH BC
179+  4E4B              	; comma
180+  4E4B CD E4 5E     	CALL CHKCHAR
181+  4E4E 2C           	DB ','
182+  4E4F              	; get address of sprite update flag
183+  4E4F DD 21 A4 5E  	LD IX, PTRGET
184+  4E53 CD 59 01     	CALL CALBAS
185+  4E56 D5           	PUSH DE
186+  4E57              	; comma
187+  4E57 CD E4 5E     	CALL CHKCHAR
188+  4E5A 2C           	DB ','
189+  4E5B              	; get flicker enabled flag
190+  4E5B DD 21 1C 52  	LD IX, GETBYT
191+  4E5F CD 59 01     	CALL CALBAS
192+  4E62 F5           	PUSH AF
193+  4E63              	; ending )
194+  4E63 CD E4 5E     	CALL CHKCHAR
195+  4E66 29           	DB ')'
196+  4E67
197+  4E67 F1           	POP AF ; get flicker flag
198+  4E68 B7           	OR A
199+  4E69 32 78 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E6C
201+  4E6C D1           	POP DE ; update variable location
202+  4E6D ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E71 D1           	POP DE ; address of sprite attribute table
204+  4E72 ED 53 76 4D  	LD (SPRATR_DATA), DE
205+  4E76 3E 01        	LD A, 1
206+  4E78 32 73 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E7B C9           	RET
208+  4E7C              ; *******************************************************************************************************
209+  4E7C
210+  4E7C              ; *******************************************************************************************************
211+  4E7C              ; function to handle CALL SPRDISABLE basic extension
212+  4E7C              ; disables sprites handling
213+  4E7C              ; _SPRDISABLE
214+  4E7C              ; resets variable SPRATR_INIT_STATUS
215+  4E7C              SPRDISABLE:
216+  4E7C AF           	XOR A
217+  4E7D 32 73 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E80 C9           	RET
219+  4E81              ; *******************************************************************************************************
220+  4E81
221+  4E81              ; *******************************************************************************************************
222+  4E81              ; function to handle CALL SPRSET basic extension
223+  4E81              ; sets position, and optionally pattern and color of sprite
224+  4E81              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E81              ;			INT x,
226+  4E81              ;			INT y,
227+  4E81              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E81              ;			INT color, valid 0-15, otherwise ignored
229+  4E81              SPRSET:
230+  4E81 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E84 B7           	OR A
232+  4E85 20 05        	JR NZ, .L1
233+  4E87 1E 05        	LD E, 5 ; illegal function call
234+  4E89 C3 04 5F     	JP THROW_ERROR
235+  4E8C              .L1:
236+  4E8C              	; opening (
237+  4E8C CD E4 5E     	CALL CHKCHAR
238+  4E8F 28           	DB '('
239+  4E90              	; get sprite number
240+  4E90 DD 21 1C 52  	LD IX, GETBYT
241+  4E94 CD 59 01     	CALL CALBAS
242+  4E97 F5           	PUSH AF
243+  4E98              	; comma
244+  4E98 CD E4 5E     	CALL CHKCHAR
245+  4E9B 2C           	DB ','
246+  4E9C              	; get x
247+  4E9C DD 21 2F 54  	LD IX, FRMQNT
248+  4EA0 CD 59 01     	CALL CALBAS
249+  4EA3 D5           	PUSH DE
250+  4EA4              	; comma
251+  4EA4 CD E4 5E     	CALL CHKCHAR
252+  4EA7 2C           	DB ','
253+  4EA8              	; get y
254+  4EA8 DD 21 2F 54  	LD IX, FRMQNT
255+  4EAC CD 59 01     	CALL CALBAS
256+  4EAF D5           	PUSH DE
257+  4EB0              	; comma
258+  4EB0 CD E4 5E     	CALL CHKCHAR
259+  4EB3 2C           	DB ','
260+  4EB4              	; get pattern
261+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
262+  4EB8 CD 59 01     	CALL CALBAS
263+  4EBB D5           	PUSH DE
264+  4EBC              	; comma
265+  4EBC CD E4 5E     	CALL CHKCHAR
266+  4EBF 2C           	DB ','
267+  4EC0              	; get color
268+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
269+  4EC4 CD 59 01     	CALL CALBAS
270+  4EC7 D5           	PUSH DE
271+  4EC8              	; ending )
272+  4EC8 CD E4 5E     	CALL CHKCHAR
273+  4ECB 29           	DB ')'
274+  4ECC
275+  4ECC                  ; save position in BASIC text
276+  4ECC E5           	PUSH HL
277+  4ECD DD E1        	POP IX
278+  4ECF
279+  4ECF C1           	POP BC ; color
280+  4ED0 D1           	POP DE ; pattern
281+  4ED1 D9           	EXX
282+  4ED2 C1           	POP BC ; y
283+  4ED3 D1           	POP DE ; x
284+  4ED4 F1           	POP AF ; sprite number
285+  4ED5 FE 20        	CP 32
286+  4ED7 38 05        	JR C, .L2
287+  4ED9 1E 05        	LD E, 5 ; illegal function call
288+  4EDB C3 04 5F     	JP THROW_ERROR
289+  4EDE              .L2:
290+  4EDE              	; find location in sprite attributes table
291+  4EDE D5           	PUSH DE
292+  4EDF CD 7C 4D     	CALL GETnthSPRATTR
293+  4EE2 D1           	POP DE
294+  4EE3              	; set y
295+  4EE3 71           	LD (HL), C
296+  4EE4 23           	INC HL
297+  4EE5 70           	LD (HL), B
298+  4EE6 23           	INC HL
299+  4EE7              	; set x
300+  4EE7 73           	LD (HL), E
301+  4EE8 23           	INC HL
302+  4EE9 72           	LD (HL), D
303+  4EEA 23           	INC HL
304+  4EEB E5           	PUSH HL
305+  4EEC D9           	EXX
306+  4EED E1           	POP HL
307+  4EEE              	; check if 0<=pattern<64
308+  4EEE 7A           	LD A, D
309+  4EEF B7           	OR A
310+  4EF0 20 0B        	JR NZ, .L3
311+  4EF2 7B           	LD A, E
312+  4EF3 FE 40        	CP 64
313+  4EF5 30 06        	JR NC, .L3
314+  4EF7              	; set pattern
315+  4EF7              	;ADD A, A
316+  4EF7              	;ADD A, A
317+  4EF7              	;ADD A, A
318+  4EF7 77           	LD (HL), A
319+  4EF8 23           	INC HL
320+  4EF9 72           	LD (HL), D
321+  4EFA 23           	INC HL
322+  4EFB 18 02        	JR .L4
323+  4EFD              .L3:
324+  4EFD              	; skip pattern
325+  4EFD 23          > INC HL
325+  4EFE 23          > INC HL
326+  4EFF              .L4:
327+  4EFF              	; check if 0<=color<16
328+  4EFF 78           	LD A, B
329+  4F00 B7           	OR A
330+  4F01 20 08        	JR NZ, .L5
331+  4F03 79           	LD A, C
332+  4F04 FE 10        	CP 16
333+  4F06 30 03        	JR NC, .L5
334+  4F08              	; set color
335+  4F08 71           	LD (HL), C
336+  4F09 23           	INC HL
337+  4F0A 70           	LD (HL), B
338+  4F0B
339+  4F0B              .L5:
340+  4F0B DD E5        	PUSH IX
341+  4F0D E1           	POP HL
342+  4F0E C9           	RET
343+  4F0F              ; *******************************************************************************************************
344+  4F0F
345+  4F0F              ; *******************************************************************************************************
346+  4F0F              ; function sets sprite location based on initial coordinates and offset provided
347+  4F0F              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F0F              ; input DE=initial x
349+  4F0F              ; input BC=initial y
350+  4F0F              ; input IY=location where delta y,x are located
351+  4F0F              ; modifies AF, HL, IX
352+  4F0F              SPRSET_DELTA_POS:
353+  4F0F D5           	PUSH DE
354+  4F10 CD 7C 4D     	CALL GETnthSPRATTR
355+  4F13 E5           	PUSH HL
356+  4F14 DD E1        	POP IX
357+  4F16 D1           	POP DE
358+  4F17              	; IX=sprite's y location
359+  4F17 FD 6E 00     	LD L, (IY)
360+  4F1A FD 66 01     	LD H, (IY+1)
361+  4F1D 09           	ADD HL, BC
362+  4F1E DD 75 00     	LD (IX), L
363+  4F21 DD 74 01     	LD (IX+1), H
364+  4F24 FD 6E 02     	LD L, (IY+2)
365+  4F27 FD 66 03     	LD H, (IY+3)
366+  4F2A 19           	ADD HL, DE
367+  4F2B DD 75 02     	LD (IX+2), L
368+  4F2E DD 74 03     	LD (IX+3), H
369+  4F31 C9           	RET
370+  4F32              ; *******************************************************************************************************
371+  4F32
372+  4F32              ; *******************************************************************************************************
373+  4F32              ; function to handle CALL SPRGRPMOV basic extension
374+  4F32              ; sets position of a group of sprites described with
375+  4F32              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F32              ; _SPRGRPMOV ( INT x,
377+  4F32              ;			   INT y,
378+  4F32              ;			   BYTE count,
379+  4F32              ;			   INT[2][count] data_ptr
380+  4F32              ; will put ram in page 0 also, page 1 is already there
381+  4F32              SPRGRPMOV:
382+  4F32 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F35 B7           	OR A
384+  4F36 20 05        	JR NZ, .L1
385+  4F38 1E 05        	LD E, 5 ; illegal function call
386+  4F3A C3 04 5F     	JP THROW_ERROR
387+  4F3D              .L1:
388+  4F3D              	; opening (
389+  4F3D CD E4 5E     	CALL CHKCHAR
390+  4F40 28           	DB '('
391+  4F41              	; get x
392+  4F41 DD 21 2F 54  	LD IX, FRMQNT
393+  4F45 CD 59 01     	CALL CALBAS
394+  4F48 D5           	PUSH DE
395+  4F49              	; comma
396+  4F49 CD E4 5E     	CALL CHKCHAR
397+  4F4C 2C           	DB ','
398+  4F4D              	; get y
399+  4F4D DD 21 2F 54  	LD IX, FRMQNT
400+  4F51 CD 59 01     	CALL CALBAS
401+  4F54 D5           	PUSH DE
402+  4F55              	; comma
403+  4F55 CD E4 5E     	CALL CHKCHAR
404+  4F58 2C           	DB ','
405+  4F59              	; get count
406+  4F59 DD 21 1C 52  	LD IX, GETBYT
407+  4F5D CD 59 01     	CALL CALBAS
408+  4F60 F5           	PUSH AF
409+  4F61              	; comma
410+  4F61 CD E4 5E     	CALL CHKCHAR
411+  4F64 2C           	DB ','
412+  4F65              	; get sprite group definition array data pointer
413+  4F65 D1           	POP DE
414+  4F66 D5           	PUSH DE
415+  4F67 5A           	LD E,D
416+  4F68 16 03        	LD D,3
417+  4F6A 3E 02        	LD A,2
418+  4F6C 47           	LD B,A
419+  4F6D CD 0B 5F     	CALL GET_BASIC_ARRAY_DATA_POINTER
420+  4F70 C5           	PUSH BC
421+  4F71              	; ending )
422+  4F71 CD E4 5E     	CALL CHKCHAR
423+  4F74 29           	DB ')'
424+  4F75
425+  4F75 E5           	PUSH HL
426+  4F76 DD E1        	POP IX
427+  4F78
428+  4F78 E1           	POP HL ; data pointer
429+  4F79 C1           	POP BC ; count
430+  4F7A D9           	EXX
431+  4F7B C1           	POP BC ; y
432+  4F7C D1           	POP DE ; x
433+  4F7D D9           	EXX
434+  4F7E
435+  4F7E DD E5        	PUSH IX ; save position in BASIC buffer
436+  4F80
437+  4F80 C5           	PUSH BC
438+  4F81 E5           	PUSH HL
439+  4F82 AF               XOR A
440+  4F83 CD D7 5D         CALL GET_PAGE_INFO
441+  4F86 D9           	EXX
442+  4F87 E1           	POP HL
443+  4F88 F1           	POP AF
444+  4F89 D9           	EXX
445+  4F8A C5               PUSH BC
446+  4F8B D5               PUSH DE
447+  4F8C D9           	EXX
448+  4F8D F5           	PUSH AF
449+  4F8E E5           	PUSH HL
450+  4F8F D9           	EXX
451+  4F90 3A 41 F3         LD A, (RAMAD0)
452+  4F93 26 00            LD H, 0
453+  4F95 CD 1E 5E         CALL LOCAL_ENASLT
454+  4F98 FB           	EI
455+  4F99 E1           	POP HL
456+  4F9A C1           	POP BC
457+  4F9B CD A5 4F     	CALL .UPDATE_LOC
458+  4F9E D1               POP DE
459+  4F9F C1               POP BC
460+  4FA0 CD 0E 5E         CALL RESTORE_PAGE_INFO
461+  4FA3 E1           	POP HL
462+  4FA4 C9           	RET
463+  4FA5
464+  4FA5              .UPDATE_LOC:
465+  4FA5              .L4:
466+  4FA5 7E           	LD A, (HL)
467+  4FA6 23           	INC HL
468+  4FA7 23           	INC HL
469+  4FA8 E5           	PUSH HL
470+  4FA9 FD E1        	POP IY
471+  4FAB D9           	EXX
472+  4FAC CD 0F 4F     	CALL SPRSET_DELTA_POS
473+  4FAF D9           	EXX
474+  4FB0 23          > INC HL
474+  4FB1 23          > INC HL
474+  4FB2 23          > INC HL
474+  4FB3 23          > INC HL
475+  4FB4 10 EF        	DJNZ .L4
476+  4FB6 C9           	RET
477+  4FB7              ; *******************************************************************************************************
478+  4FB7
# file closed: asm\SPRITES.asm
116   4FB7               ENDIF
117   4FB7
118   4FB7               IF (ANIM_CMDS == 1)
119   4FB7               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FB7              ; sprite animation routines
  2+  4FB7
  3+  4FB7              ; number of animation items and pointer
  4+  4FB7              ANIMITEMNUM:
  5+  4FB7 00            DB 0
  6+  4FB8              ANIMITEMPTR:
  7+  4FB8 40 5F         DW EXT_END
  8+  4FBA              ; number of animation definitions and pointer
  9+  4FBA              ANIMDEFNUM:
 10+  4FBA 00            DB 0
 11+  4FBB              ANIMDEFPTR:
 12+  4FBB 40 5F         DW EXT_END
 13+  4FBD              ; number of links between sprite and animation definitions
 14+  4FBD              ANIMSPRNUM:
 15+  4FBD 00            DB 0
 16+  4FBE              ANIMSPRPTR:
 17+  4FBE 40 5F         DW EXT_END
 18+  4FC0
 19+  4FC0              ; ANIMATION ITEM
 20+  4FC0              ; byte type = [0 - pattern and color change
 21+  4FC0              ;              1 - pattern definition change ]
 22+  4FC0              ; word ticks - number of ticks to hold this state
 23+  4FC0              ; for type = 0
 24+  4FC0              ;   byte pattern;
 25+  4FC0              ;   byte color;
 26+  4FC0              ; for type = 1
 27+  4FC0              ;   work data_pointer;
 28+  4FC0              ; total size = 5b
 29+  4FC0
 30+  4FC0              ; ANIMATION DEFINITION
 31+  4FC0              ; byte number of items 1-15
 32+  4FC0              ; byte[15] anim_item;
 33+  4FC0              ; total size = 16b
 34+  4FC0
 35+  4FC0              ; SPRITE ANIMATION
 36+  4FC0              ; +00 byte sprite number;
 37+  4FC0              ; +01 word time;
 38+  4FC0              ; +03 byte current item;
 39+  4FC0              ; +04 byte animation definition;
 40+  4FC0              ; +05 byte cyclic;
 41+  4FC0              ; +06 byte active;
 42+  4FC0              ; +07 byte reserved
 43+  4FC0              ; total size = 8b
 44+  4FC0
 45+  4FC0              ; *******************************************************************************************************
 46+  4FC0              ; helper function HL=A*5
 47+  4FC0              ; changes HL,DE;
 48+  4FC0              Ax5:
 49+  4FC0 26 00            LD H,0
 50+  4FC2 6F               LD L,A
 51+  4FC3 54               LD D,H
 52+  4FC4 5D               LD E,L
 53+  4FC5 29               ADD HL,HL
 54+  4FC6 29               ADD HL,HL
 55+  4FC7 19               ADD HL,DE
 56+  4FC8 C9               RET
 57+  4FC9              ; *******************************************************************************************************
 58+  4FC9
 59+  4FC9              ; *******************************************************************************************************
 60+  4FC9              ; helper function gets pointer to n-th animation item
 61+  4FC9              ; changes HL,DE;
 62+  4FC9              GETnthANIMITEM:
 63+  4FC9 CD C0 4F         CALL Ax5
 64+  4FCC ED 5B B8 4F      LD DE,(ANIMITEMPTR)
 65+  4FD0 19               ADD HL,DE
 66+  4FD1 C9               RET
 67+  4FD2              ; *******************************************************************************************************
 68+  4FD2
 69+  4FD2              ; *******************************************************************************************************
 70+  4FD2              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD2              ; changes HL,DE;
 72+  4FD2              GETnthANIMDEF:
 73+  4FD2 26 00            LD H,0
 74+  4FD4 6F               LD L,A
 75+  4FD5 CD D3 5D         CALL HLx8
 76+  4FD8 ED 5B BB 4F      LD DE,(ANIMDEFPTR)
 77+  4FDC 19               ADD HL,DE
 78+  4FDD C9               RET
 79+  4FDE              ; *******************************************************************************************************
 80+  4FDE
 81+  4FDE              ; *******************************************************************************************************
 82+  4FDE              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FDE              ; changes HL,DE;
 84+  4FDE              GETnthSPRANIM:
 85+  4FDE 26 00            LD H,0
 86+  4FE0 6F               LD L,A
 87+  4FE1 CD D2 5D         CALL HLx16
 88+  4FE4 ED 5B BE 4F      LD DE,(ANIMSPRPTR)
 89+  4FE8 19               ADD HL,DE
 90+  4FE9 C9               RET
 91+  4FEA              ; *******************************************************************************************************
 92+  4FEA
 93+  4FEA              ; *******************************************************************************************************
 94+  4FEA              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FEA              ; MAXANIMITEMS (BYTE number)
 96+  4FEA              ; sets new number and moves memory buffers as needed
 97+  4FEA              MAXANIMITEMS:
 98+  4FEA              	; opening (
 99+  4FEA CD E4 5E     	CALL CHKCHAR
100+  4FED 28           	DB '('
101+  4FEE              	; get value
102+  4FEE DD 21 1C 52  	LD IX, GETBYT
103+  4FF2 CD 59 01     	CALL CALBAS
104+  4FF5 F5               PUSH AF
105+  4FF6              	; ending )
106+  4FF6 CD E4 5E     	CALL CHKCHAR
107+  4FF9 29           	DB ')'
108+  4FFA F1               POP AF
109+  4FFB
110+  4FFB              	; save position
111+  4FFB E5           	PUSH HL
112+  4FFC              .ENTRY:
113+  4FFC 47               LD B,A
114+  4FFD 3A B7 4F         LD A,(ANIMITEMNUM)
115+  5000 90               SUB B
116+  5001 28 1F            JR Z, .EXIT; same value as before
117+  5003 FD 21 BB 4F      LD IY,ANIMDEFPTR
118+  5007 FA 25 50         JP M, .INCREASE
119+  500A                  ; new value is lower than previous one
120+  500A CD 3D 50         CALL .SIZEDIFF
121+  500D CD 58 50         CALL .DECREASE_COMMON
122+  5010 2A BE 4F         LD HL,(ANIMSPRPTR)
123+  5013 AF               XOR A
124+  5014 ED 42            SBC HL,BC
125+  5016 22 BE 4F         LD (ANIMSPRPTR),HL
126+  5019              .E1:
127+  5019 2A 10 40         LD HL,(FREEMEMPTR)
128+  501C AF               XOR A
129+  501D ED 42            SBC HL,BC
130+  501F 22 10 40         LD (FREEMEMPTR),HL
131+  5022              .EXIT:
132+  5022 FB               EI
133+  5023 E1           	POP HL
134+  5024 C9           	RET
135+  5025              .INCREASE:
136+  5025 ED 44            NEG
137+  5027 CD 3D 50         CALL .SIZEDIFF
138+  502A CD 84 50         CALL .INCREASE_COMMON
139+  502D 2A BE 4F         LD HL,(ANIMSPRPTR)
140+  5030 09               ADD HL,BC
141+  5031 22 BE 4F         LD (ANIMSPRPTR),HL
142+  5034              .E2:
143+  5034 2A 10 40         LD HL,(FREEMEMPTR)
144+  5037 09               ADD HL,BC
145+  5038 22 10 40         LD (FREEMEMPTR),HL
146+  503B 18 E5            JR .EXIT
147+  503D              .SIZEDIFF:
148+  503D CD C0 4F         CALL Ax5
149+  5040 78               LD A,B
150+  5041 32 B7 4F         LD (ANIMITEMNUM),A
151+  5044 44               LD B,H
152+  5045 4D               LD C,L
153+  5046 C9               RET ; BC=size difference in bytes
154+  5047              .SIZETOMOVE:
155+  5047 D5               PUSH DE
156+  5048 2A 10 40         LD HL,(FREEMEMPTR)
157+  504B FD 5E 00         LD E,(IY)
158+  504E FD 56 01         LD D,(IY+1)
159+  5051 AF               XOR A
160+  5052 ED 52            SBC HL,DE
161+  5054 44               LD B,H
162+  5055 4D               LD C,L
163+  5056 D1               POP DE
164+  5057 C9               RET
165+  5058              .DECREASE_COMMON:
166+  5058 FD 6E 00         LD L,(IY)
167+  505B FD 66 01         LD H,(IY+1)
168+  505E AF               XOR A
169+  505F ED 42            SBC HL,BC
170+  5061 EB               EX DE,HL
171+  5062 C5               PUSH BC
172+  5063 CD 47 50         CALL .SIZETOMOVE
173+  5066 F3               DI
174+  5067 78               LD A,B
175+  5068 B1               OR C
176+  5069 28 08            JR Z,.L1
177+  506B FD 6E 00         LD L,(IY)
178+  506E FD 66 01         LD H,(IY+1)
179+  5071 ED B0            LDIR
180+  5073              .L1:
181+  5073 C1               POP BC
182+  5074 FD 6E 00         LD L,(IY)
183+  5077 FD 66 01         LD H,(IY+1)
184+  507A AF               XOR A
185+  507B ED 42            SBC HL,BC
186+  507D FD 75 00         LD (IY),L
187+  5080 FD 74 01         LD (IY+1),H
188+  5083 C9               RET
189+  5084              .INCREASE_COMMON:
190+  5084 2A 10 40         LD HL,(FREEMEMPTR)
191+  5087 2B               DEC HL
192+  5088 AF               XOR A
193+  5089 ED 42            SBC HL,BC
194+  508B EB               EX DE,HL
195+  508C C5               PUSH BC
196+  508D CD 47 50         CALL .SIZETOMOVE
197+  5090 F3               DI
198+  5091 78               LD A,B
199+  5092 B1               OR C
200+  5093 28 06            JR Z,.L2
201+  5095 2A 10 40         LD HL,(FREEMEMPTR)
202+  5098 2B               DEC HL
203+  5099 ED B8            LDDR
204+  509B              .L2:
205+  509B C1               POP BC
206+  509C FD 6E 00         LD L,(IY)
207+  509F FD 66 01         LD H,(IY+1)
208+  50A2 09               ADD HL,BC
209+  50A3 FD 75 00         LD (IY),L
210+  50A6 FD 74 01         LD (IY+1),H
211+  50A9 C9               RET
212+  50AA              ; *******************************************************************************************************
213+  50AA
214+  50AA              ; *******************************************************************************************************
215+  50AA              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AA              ; ANIMITEMPAT ( BYTE id,
217+  50AA              ;               INT ticks,
218+  50AA              ;               BYTE pattern,
219+  50AA              ;               BYTE color )
220+  50AA              ; fills animation item data, returns an error if out of bounds
221+  50AA              ANIMITEMPAT:
222+  50AA                  ; opening (
223+  50AA CD E4 5E     	CALL CHKCHAR
224+  50AD 28           	DB '('
225+  50AE              	; get id
226+  50AE DD 21 1C 52  	LD IX, GETBYT
227+  50B2 CD 59 01     	CALL CALBAS
228+  50B5 F5               PUSH AF
229+  50B6                  ; check if out of bounds
230+  50B6 3C               INC A
231+  50B7 4F               LD C,A
232+  50B8 3A B7 4F         LD A,(ANIMITEMNUM)
233+  50BB B9               CP C
234+  50BC DA FA 5E         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50BF              	; comma
236+  50BF CD E4 5E     	CALL CHKCHAR
237+  50C2 2C           	DB ','
238+  50C3              	; get ticks
239+  50C3 DD 21 2F 54  	LD IX, FRMQNT
240+  50C7 CD 59 01     	CALL CALBAS
241+  50CA D5           	PUSH DE
242+  50CB              	; comma
243+  50CB CD E4 5E     	CALL CHKCHAR
244+  50CE 2C           	DB ','
245+  50CF              	; get pattern
246+  50CF DD 21 1C 52  	LD IX, GETBYT
247+  50D3 CD 59 01     	CALL CALBAS
248+  50D6 F5               PUSH AF
249+  50D7              	; comma
250+  50D7 CD E4 5E     	CALL CHKCHAR
251+  50DA 2C           	DB ','
252+  50DB              	; get color
253+  50DB DD 21 1C 52  	LD IX, GETBYT
254+  50DF CD 59 01     	CALL CALBAS
255+  50E2 F5               PUSH AF
256+  50E3              	; ending )
257+  50E3 CD E4 5E     	CALL CHKCHAR
258+  50E6 29           	DB ')'
259+  50E7              .ENTRY:
260+  50E7 E5               PUSH HL
261+  50E8 DD E1            POP IX
262+  50EA D9               EXX
263+  50EB C1               POP BC ; color
264+  50EC D1               POP DE ; pattern
265+  50ED E1               POP HL ; ticks
266+  50EE D9               EXX
267+  50EF F1               POP AF
268+  50F0 CD C9 4F         CALL GETnthANIMITEM
269+  50F3 E5               PUSH HL
270+  50F4 FD E1            POP IY
271+  50F6 D9               EXX
272+  50F7 FD 36 00 00      LD (IY),0 ; type=0
273+  50FB FD 75 01         LD (IY+1),L
274+  50FE FD 74 02         LD (IY+2),H
275+  5101 FD 72 03         LD (IY+3),D
276+  5104 FD 70 04         LD (IY+4),B
277+  5107
278+  5107 DD E5            PUSH IX
279+  5109 E1               POP HL
280+  510A C9               RET
281+  510B              ; *******************************************************************************************************
282+  510B
283+  510B              ; *******************************************************************************************************
284+  510B              ; function to handle CALL ANIMITEMPTR basic extension
285+  510B              ; ANIMITEMPTR ( BYTE id,
286+  510B              ;               INT ticks,
287+  510B              ;               INT pointer,
288+  510B              ; fills animation item data, returns an error if out of bounds
289+  510B              ANIMITEMPTR_CMD:
290+  510B                  ; opening (
291+  510B CD E4 5E     	CALL CHKCHAR
292+  510E 28           	DB '('
293+  510F              	; get id
294+  510F DD 21 1C 52  	LD IX, GETBYT
295+  5113 CD 59 01     	CALL CALBAS
296+  5116 F5               PUSH AF
297+  5117                  ; check if out of bounds
298+  5117 3C               INC A
299+  5118 4F               LD C,A
300+  5119 3A B7 4F         LD A,(ANIMITEMNUM)
301+  511C B9               CP C
302+  511D DA FA 5E         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5120              	; comma
304+  5120 CD E4 5E     	CALL CHKCHAR
305+  5123 2C           	DB ','
306+  5124              	; get ticks
307+  5124 DD 21 2F 54  	LD IX, FRMQNT
308+  5128 CD 59 01     	CALL CALBAS
309+  512B D5           	PUSH DE
310+  512C              	; comma
311+  512C CD E4 5E     	CALL CHKCHAR
312+  512F 2C           	DB ','
313+  5130              	; get pointer
314+  5130 DD 21 2F 54  	LD IX, FRMQNT
315+  5134 CD 59 01     	CALL CALBAS
316+  5137 D5           	PUSH DE
317+  5138              	; ending )
318+  5138 CD E4 5E     	CALL CHKCHAR
319+  513B 29           	DB ')'
320+  513C              .ENTRY:
321+  513C E5               PUSH HL
322+  513D DD E1            POP IX
323+  513F D9               EXX
324+  5140 D1               POP DE ; pointer
325+  5141 E1               POP HL ; ticks
326+  5142 D9               EXX
327+  5143 F1               POP AF
328+  5144 CD C9 4F         CALL GETnthANIMITEM
329+  5147 E5               PUSH HL
330+  5148 FD E1            POP IY
331+  514A D9               EXX
332+  514B FD 36 00 01      LD (IY),1 ; type=1
333+  514F FD 75 01         LD (IY+1),L
334+  5152 FD 74 02         LD (IY+2),H
335+  5155 FD 73 03         LD (IY+3),E
336+  5158 FD 72 04         LD (IY+4),D
337+  515B
338+  515B DD E5            PUSH IX
339+  515D E1               POP HL
340+  515E C9               RET
341+  515F              ; *******************************************************************************************************
342+  515F
343+  515F              ; *******************************************************************************************************
344+  515F              ; function to handle CALL MAXANIMDEFS basic extension
345+  515F              ; MAXANIMDEFS (BYTE number)
346+  515F              ; sets new number and moves memory buffers as needed
347+  515F              MAXANIMDEFS:
348+  515F              	; opening (
349+  515F CD E4 5E     	CALL CHKCHAR
350+  5162 28           	DB '('
351+  5163              	; get value
352+  5163 DD 21 1C 52  	LD IX, GETBYT
353+  5167 CD 59 01     	CALL CALBAS
354+  516A F5               PUSH AF
355+  516B              	; ending )
356+  516B CD E4 5E     	CALL CHKCHAR
357+  516E 29           	DB ')'
358+  516F F1               POP AF
359+  5170
360+  5170              	; save position
361+  5170 E5           	PUSH HL
362+  5171              .ENTRY:
363+  5171 47               LD B,A
364+  5172 3A BA 4F         LD A,(ANIMDEFNUM)
365+  5175 90               SUB B
366+  5176 CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  5179 FD 21 BE 4F      LD IY,ANIMSPRPTR
368+  517D FA 89 51         JP M, .INCREASE
369+  5180                  ; new value is lower than previous one
370+  5180 CD 94 51         CALL .SIZEDIFF
371+  5183 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  5186 C3 19 50         JP MAXANIMITEMS.E1
373+  5189              .INCREASE:
374+  5189 ED 44            NEG
375+  518B CD 94 51         CALL .SIZEDIFF
376+  518E CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5191 C3 34 50         JP MAXANIMITEMS.E2
378+  5194              .SIZEDIFF:
379+  5194 26 00            LD H,0
380+  5196 6F               LD L,A
381+  5197 CD D2 5D         CALL HLx16
382+  519A 78               LD A,B
383+  519B 32 BA 4F         LD (ANIMDEFNUM),A
384+  519E 44               LD B,H
385+  519F 4D               LD C,L
386+  51A0 C9               RET ; BC=size difference in bytes
387+  51A1              ; *******************************************************************************************************
388+  51A1
389+  51A1              ; *******************************************************************************************************
390+  51A1              ; function to handle CALL ANIMDEF basic extension
391+  51A1              ; ANIMITEMPAT ( BYTE id,
392+  51A1              ;               BYTE size,
393+  51A1              ;               INT[] list )
394+  51A1              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A1              ANIMDEF:
396+  51A1                  ; opening (
397+  51A1 CD E4 5E     	CALL CHKCHAR
398+  51A4 28           	DB '('
399+  51A5              	; get id
400+  51A5 DD 21 1C 52  	LD IX, GETBYT
401+  51A9 CD 59 01     	CALL CALBAS
402+  51AC F5               PUSH AF
403+  51AD                  ; check if out of bounds
404+  51AD 3C               INC A
405+  51AE 4F               LD C,A
406+  51AF 3A BA 4F         LD A,(ANIMDEFNUM)
407+  51B2 B9               CP C
408+  51B3 DA FA 5E         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51B6              	; comma
410+  51B6 CD E4 5E     	CALL CHKCHAR
411+  51B9 2C           	DB ','
412+  51BA              	; get size
413+  51BA DD 21 1C 52  	LD IX, GETBYT
414+  51BE CD 59 01     	CALL CALBAS
415+  51C1 FE 10            CP 16
416+  51C3 D2 FE 5E         JP NC, OVERFLOW
417+  51C6 B7               OR A
418+  51C7 CA FE 5E         JP Z, OVERFLOW
419+  51CA F5           	PUSH AF
420+  51CB              	; comma
421+  51CB CD E4 5E     	CALL CHKCHAR
422+  51CE 2C           	DB ','
423+  51CF              	; get pointer to a list of animation items in integer array format
424+  51CF                  ; get array pointer
425+  51CF D1               POP DE
426+  51D0 D5               PUSH DE
427+  51D1 3E 02            LD A,2
428+  51D3 06 01            LD B,1
429+  51D5 CD 0B 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51D8 C5               PUSH BC
431+  51D9              	; ending )
432+  51D9 CD E4 5E     	CALL CHKCHAR
433+  51DC 29           	DB ')'
434+  51DD              .ENTRY:
435+  51DD E5               PUSH HL
436+  51DE DD E1            POP IX
437+  51E0 D1               POP DE ; pointer to INT array
438+  51E1 C1               POP BC ; B=item number
439+  51E2 F1               POP AF ; id
440+  51E3 D5               PUSH DE
441+  51E4 CD D2 4F         CALL GETnthANIMDEF
442+  51E7 D1               POP DE
443+  51E8 70               LD (HL),B
444+  51E9              .L1:
445+  51E9 23               INC HL
446+  51EA 1A               LD A,(DE)
447+  51EB 13          > INC DE
447+  51EC 13          > INC DE
448+  51ED 77               LD (HL),A
449+  51EE 10 F9            DJNZ .L1
450+  51F0 DD E5            PUSH IX
451+  51F2 E1               POP HL
452+  51F3 C9               RET
453+  51F4              ; *******************************************************************************************************
454+  51F4
455+  51F4              ; *******************************************************************************************************
456+  51F4              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F4              ; MAXANIMSPRS (BYTE number)
458+  51F4              ; sets new number and moves memory buffers as needed
459+  51F4              MAXANIMSPRS:
460+  51F4              	; opening (
461+  51F4 CD E4 5E     	CALL CHKCHAR
462+  51F7 28           	DB '('
463+  51F8              	; get value
464+  51F8 DD 21 1C 52  	LD IX, GETBYT
465+  51FC CD 59 01     	CALL CALBAS
466+  51FF F5               PUSH AF
467+  5200              	; ending )
468+  5200 CD E4 5E     	CALL CHKCHAR
469+  5203 29           	DB ')'
470+  5204 F1               POP AF
471+  5205
472+  5205              	; save position
473+  5205 E5           	PUSH HL
474+  5206              .ENTRY:
475+  5206 47               LD B,A
476+  5207 3A BD 4F         LD A,(ANIMSPRNUM)
477+  520A 90               SUB B
478+  520B CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  520E FD 21 10 40      LD IY,FREEMEMPTR
480+  5212 FA 1E 52         JP M, .INCREASE
481+  5215                  ; new value is lower than previous one
482+  5215 CD 3D 52         CALL .SIZEDIFF
483+  5218 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  521B C3 22 50         JP MAXANIMITEMS.EXIT
485+  521E              .INCREASE:
486+  521E ED 44            NEG
487+  5220 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5221 CD 3D 52         CALL .SIZEDIFF
489+  5224 CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  5227 AF               XOR A
491+  5228 ED 42            SBC HL,BC ; location of new stuff
492+  522A F1               POP AF
493+  522B 47               LD B,A
494+  522C 11 08 00         LD DE,8
495+  522F E5               PUSH HL
496+  5230 DD E1            POP IX
497+  5232              .L1:
498+  5232 DD 36 06 00      LD (IX+6),0
499+  5236 DD 19            ADD IX,DE
500+  5238 10 F8            DJNZ .L1
501+  523A C3 22 50         JP MAXANIMITEMS.EXIT
502+  523D              .SIZEDIFF:
503+  523D 26 00            LD H,0
504+  523F 6F               LD L,A
505+  5240 CD D3 5D         CALL HLx8
506+  5243 78               LD A,B
507+  5244 32 BD 4F         LD (ANIMSPRNUM),A
508+  5247 44               LD B,H
509+  5248 4D               LD C,L
510+  5249 C9               RET ; BC=size difference in bytes
511+  524A              ; *******************************************************************************************************
512+  524A
513+  524A              ; *******************************************************************************************************
514+  524A              ; function to handle CALL ANIMSPRITE basic extension
515+  524A              ; ANIMSPRITE ( BYTE id,
516+  524A              ;              BYTE sprite_number,
517+  524A              ;              BYTE animation_definition_id,
518+  524A              ;              BYTE cyclic_flag )
519+  524A              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524A              ANIMSPRITE:
521+  524A                  ; opening (
522+  524A CD E4 5E     	CALL CHKCHAR
523+  524D 28           	DB '('
524+  524E              	; get sprite animation id
525+  524E DD 21 1C 52  	LD IX, GETBYT
526+  5252 CD 59 01     	CALL CALBAS
527+  5255 F5               PUSH AF
528+  5256 3C               INC A
529+  5257 4F               LD C,A
530+  5258 3A BD 4F         LD A,(ANIMSPRNUM)
531+  525B B9               CP C
532+  525C DA FA 5E         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  525F              	; comma
534+  525F CD E4 5E     	CALL CHKCHAR
535+  5262 2C           	DB ','
536+  5263              	; get sprite number
537+  5263 DD 21 1C 52  	LD IX, GETBYT
538+  5267 CD 59 01     	CALL CALBAS
539+  526A F5               PUSH AF
540+  526B                  ; check if out of bounds
541+  526B FE 20            CP 32
542+  526D D2 FA 5E         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5270              	; comma
544+  5270 CD E4 5E     	CALL CHKCHAR
545+  5273 2C           	DB ','
546+  5274              	; get animation definition id
547+  5274 DD 21 1C 52  	LD IX, GETBYT
548+  5278 CD 59 01     	CALL CALBAS
549+  527B F5               PUSH AF
550+  527C 3C               INC A
551+  527D 4F               LD C,A
552+  527E 3A BA 4F         LD A,(ANIMDEFNUM)
553+  5281 B9               CP C
554+  5282 DA FA 5E         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  5285              	; comma
556+  5285 CD E4 5E     	CALL CHKCHAR
557+  5288 2C           	DB ','
558+  5289              	; get cyclic flag
559+  5289 DD 21 1C 52  	LD IX, GETBYT
560+  528D CD 59 01         CALL CALBAS
561+  5290 F5           	PUSH AF
562+  5291              	; ending )
563+  5291 CD E4 5E     	CALL CHKCHAR
564+  5294 29           	DB ')'
565+  5295              .ENTRY:
566+  5295 E5               PUSH HL
567+  5296 DD E1            POP IX
568+  5298 D9               EXX
569+  5299 D1               POP DE ; cyclic
570+  529A C1               POP BC ; animation definition id
571+  529B E1               POP HL ; sprite number
572+  529C D9               EXX
573+  529D F1               POP AF ; sprite animation id
574+  529E CD DE 4F         CALL GETnthSPRANIM
575+  52A1 E5               PUSH HL
576+  52A2 FD E1            POP IY
577+  52A4 D9               EXX
578+  52A5 FD 74 00         LD (IY),H
579+  52A8 FD 70 04         LD (IY+4),B
580+  52AB FD 72 05         LD (IY+5),D
581+  52AE                  ;LD (IY+6),0
582+  52AE DD E5            PUSH IX
583+  52B0 E1               POP HL
584+  52B1 C9               RET
585+  52B2              ; *******************************************************************************************************
586+  52B2
587+  52B2              ; *******************************************************************************************************
588+  52B2              ; function to handle CALL ANIMSTART basic extension
589+  52B2              ; two forms
590+  52B2              ; ANIMSTART ( BYTE id )
591+  52B2              ; or
592+  52B2              ; ANIMSTART ( BYTE item_number,
593+  52B2              ;             INT[] sprite_animations )
594+  52B2              ; sets active flag to 1
595+  52B2              ANIMSTART:
596+  52B2 3E 01            LD A,1
597+  52B4 18 01            JR ANIMSTARTSTOP_COMMON
598+  52B6              ; *******************************************************************************************************
599+  52B6              ; *******************************************************************************************************
600+  52B6              ; function to handle CALL ANIMSTOP basic extension
601+  52B6              ; two forms
602+  52B6              ; ANIMSTOP ( BYTE id )
603+  52B6              ; or
604+  52B6              ; ANIMSTOP ( BYTE item_number,
605+  52B6              ;            INT[] sprite_animations )
606+  52B6              ; sets active flag to 1
607+  52B6              ANIMSTOP:
608+  52B6 AF               XOR A
609+  52B7              ANIMSTARTSTOP_COMMON:
610+  52B7 32 14 53         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
611+  52BA              ; *******************************************************************************************************
612+  52BA                  ; opening (
613+  52BA CD E4 5E     	CALL CHKCHAR
614+  52BD 28           	DB '('
615+  52BE              	; get sprite animation id or array size
616+  52BE DD 21 1C 52  	LD IX,GETBYT
617+  52C2 CD 59 01     	CALL CALBAS
618+  52C5 F5               PUSH AF
619+  52C6                  ; check if comma present
620+  52C6 CD EE 5E         CALL GETPREVCHAR
621+  52C9 23               INC HL
622+  52CA FE 2C            CP ','
623+  52CC 28 0C            JR Z,.L1
624+  52CE FE 29            CP ')'
625+  52D0 C2 02 5F         JP NZ,SYNTAX_ERROR
626+  52D3                  ; ok so single argument variant
627+  52D3 F1               POP AF
628+  52D4 E5               PUSH HL
629+  52D5 CD 00 53         CALL .SETVALUE
630+  52D8 E1               POP HL
631+  52D9 C9               RET
632+  52DA              .L1:
633+  52DA                  ; get array pointer
634+  52DA D1               POP DE
635+  52DB D5               PUSH DE
636+  52DC 3E 02            LD A,2
637+  52DE 06 01            LD B,1
638+  52E0 CD 0B 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
639+  52E3 C5               PUSH BC
640+  52E4              	; ending )
641+  52E4 CD E4 5E     	CALL CHKCHAR
642+  52E7 29           	DB ')'
643+  52E8 D1               POP DE ; array pointer
644+  52E9 C1               POP BC ; number of items
645+  52EA 78               LD A,B
646+  52EB B7               OR A
647+  52EC CA FA 5E         JP Z,SUBSCRIPT_OUT_OF_RANGE
648+  52EF E5               PUSH HL
649+  52F0 F3               DI
650+  52F1              .L2:
651+  52F1 C5               PUSH BC
652+  52F2 1A               LD A,(DE)
653+  52F3 13          > INC DE
653+  52F4 13          > INC DE
654+  52F5 D5               PUSH DE
655+  52F6 CD 00 53         CALL .SETVALUE
656+  52F9 D1               POP DE
657+  52FA C1               POP BC
658+  52FB 10 F4            DJNZ .L2
659+  52FD FB               EI
660+  52FE E1               POP HL
661+  52FF C9               RET
662+  5300
663+  5300              .SETVALUE:
664+  5300 47               LD B,A
665+  5301 3C               INC A
666+  5302 4F               LD C,A
667+  5303 3A BD 4F         LD A,(ANIMSPRNUM)
668+  5306 B9               CP C
669+  5307 DA FA 5E         JP C,SUBSCRIPT_OUT_OF_RANGE
670+  530A 78               LD A,B
671+  530B CD DE 4F         CALL GETnthSPRANIM
672+  530E E5               PUSH HL
673+  530F DD E1            POP IX
674+  5311              .VALUE:
675+  5311 DD 36 06 01      LD (IX+6),1 ; active flag
676+  5315 3A 14 53         LD A,(.VALUE+3)
677+  5318 B7               OR A
678+  5319 C8               RET Z
679+  531A DD 36 03 00      LD (IX+3),0 ; current item
680+  531E C3 8C 53         JP SETUP_ANIM_STEP
681+  5321              ; *******************************************************************************************************
682+  5321
683+  5321              ; *******************************************************************************************************
684+  5321              ; function processes animations during vblank period
685+  5321              PROCESS_ANIMATIONS:
686+  5321 3A BD 4F         LD A,(ANIMSPRNUM)
687+  5324 B7               OR A
688+  5325 C8               RET Z; no animations defined
689+  5326 47               LD B,A
690+  5327 DD 2A BE 4F      LD IX,(ANIMSPRPTR)
691+  532B              .L1:
692+  532B C5               PUSH BC
693+  532C DD 7E 06         LD A,(IX+6); active
694+  532F B7               OR A
695+  5330 28 17            JR Z,.SKIP ; inactive animation
696+  5332 DD 6E 01         LD L,(IX+1)
697+  5335 DD 66 02         LD H,(IX+2) ; HL=end time
698+  5338                  ;LD DE,(JIFFY)
699+  5338                  ;XOR A
700+  5338                  ;SBC HL,DE
701+  5338                  ;JP P,.SKIP ; time until next animation item not yet reached
702+  5338 2B               DEC HL
703+  5339 DD 75 01         LD (IX+1),L
704+  533C DD 74 02         LD (IX+2),H
705+  533F 7D               LD A,L
706+  5340 B4               OR H
707+  5341 20 06            JR NZ,.SKIP
708+  5343 DD 34 03         INC (IX+3) ; current animation item
709+  5346 CD 8C 53         CALL SETUP_ANIM_STEP
710+  5349              .SKIP:
711+  5349 11 08 00         LD DE,8
712+  534C DD 19            ADD IX,DE
713+  534E C1               POP BC
714+  534F 10 DA            DJNZ .L1
715+  5351 C9               RET
716+  5352              ; *******************************************************************************************************
717+  5352
718+  5352              ; *******************************************************************************************************
719+  5352              ; function will setup sprite animation after current item change
720+  5352              ; input A=current animation definition
721+  5352              ; input IX=pointer to sprite animation
722+  5352              ; output IY=pointer to animation item
723+  5352              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
724+  5352              ; basically sets new end time for current animation
725+  5352              INIT_CURRENT_ANIMATION:
726+  5352 CD D2 4F         CALL GETnthANIMDEF
727+  5355 7E               LD A,(HL); number of animation items in the animation definition
728+  5356 DD BE 03         CP (IX+3) ; current animation item
729+  5359 20 0A            JR NZ,.L3 ; last item not reached
730+  535B                  ; last item reached
731+  535B DD 7E 05         LD A,(IX+5) ; cyclic flag
732+  535E B7               OR A
733+  535F 28 29            JR Z,.ERROR ; non-cyclic animation
734+  5361                  ; cyclic animation, restart
735+  5361 DD 36 03 00      LD (IX+3),0; current item
736+  5365              .L3:
737+  5365                  ; HL = animation definition
738+  5365 23               INC HL ; skip animation definition size field
739+  5366 16 00            LD D,0
740+  5368 DD 5E 03         LD E,(IX+3); current item
741+  536B 19               ADD HL,DE
742+  536C 4E               LD C,(HL) ; current animation item
743+  536D 0C               INC C
744+  536E 3A B7 4F         LD A,(ANIMITEMNUM)
745+  5371 B9               CP C
746+  5372 38 16            JR C,.ERROR ; invalid animation item, stop animation
747+  5374 0D               DEC C
748+  5375 79               LD A,C
749+  5376 CD C9 4F         CALL GETnthANIMITEM
750+  5379 E5               PUSH HL
751+  537A FD E1            POP IY ; IY=animation item
752+  537C                  ;LD HL,(JIFFY)
753+  537C FD 5E 01         LD E,(IY+1)
754+  537F FD 56 02         LD D,(IY+2) ; duration
755+  5382                  ;ADD HL,DE
756+  5382                  ;LD (IX+1),L
757+  5382                  ;LD (IX+2),H ; end time for current item
758+  5382 DD 73 01         LD (IX+1),E
759+  5385 DD 72 02         LD (IX+2),D
760+  5388              .EXIT:
761+  5388 AF               XOR A
762+  5389 C9               RET
763+  538A              .ERROR:
764+  538A 37               SCF
765+  538B C9               RET
766+  538C              ; *******************************************************************************************************
767+  538C
768+  538C              ; *******************************************************************************************************
769+  538C              ; function will display currect item and set up expiry time
770+  538C              ; it will also stop the animation if expired
771+  538C              ; sets sprite update flag if any changes in sprite data made
772+  538C              ; input IX=current sprite animation
773+  538C              SETUP_ANIM_STEP:
774+  538C DD 4E 04         LD C,(IX+4) ; animation definition ID
775+  538F 0C               INC C
776+  5390 3A BA 4F         LD A,(ANIMDEFNUM)
777+  5393 B9               CP C
778+  5394 30 05            JR NC,.L2
779+  5396                  ; given animation item is outside of bounds, deactivate animation
780+  5396              .STOPANIM:
781+  5396 DD 36 06 00      LD (IX+6),0
782+  539A C9               RET
783+  539B              .L2:
784+  539B 0D               DEC C
785+  539C 79               LD A,C
786+  539D CD 52 53         CALL INIT_CURRENT_ANIMATION
787+  53A0 38 F4            JR C, .STOPANIM
788+  53A2 FD 7E 00         LD A,(IY) ; type of animation item
789+  53A5 B7               OR A
790+  53A6 CA DB 53         JP Z,.L4 ; change pattern and/or color
791+  53A9              .PAT:
792+  53A9                  ; change sprite pattern definition
793+  53A9 DD 7E 00         LD A,(IX) ; sprite number
794+  53AC CD 7C 4D         CALL GETnthSPRATTR
795+  53AF 23          > INC HL ; skip y and x
795+  53B0 23          > INC HL
795+  53B1 23          > INC HL
795+  53B2 23          > INC HL
796+  53B3 7E               LD A,(HL); current pattern
797+  53B4 26 00            LD H,0
798+  53B6 6F               LD L,A
799+  53B7 3A E0 F3         LD A,(REG1SAV)
800+  53BA E6 02            AND 2
801+  53BC 20 07            JR NZ,.L6
802+  53BE                  ; 8x8 sprite
803+  53BE CD D3 5D         CALL HLx8
804+  53C1 06 08            LD B,8
805+  53C3 18 05            JR .L5
806+  53C5              .L6:
807+  53C5 CD D1 5D         CALL HLx32
808+  53C8 06 20            LD B,32
809+  53CA              .L5:
810+  53CA ED 5B 26 F9      LD DE,(PATBAS)
811+  53CE 19               ADD HL,DE
812+  53CF CD BE 5D         CALL SETWRT_LOCAL
813+  53D2 FD 6E 03         LD L,(IY+3)
814+  53D5 FD 66 04         LD H,(IY+4) ; pointer to sprite patter data
815+  53D8 C3 C9 5D         JP BBYTECOPY
816+  53DB              .L4:
817+  53DB                  ; change pattern and color in sprite attributes table
818+  53DB DD 7E 00         LD A,(IX) ; sprite number
819+  53DE CD 7C 4D         CALL GETnthSPRATTR
820+  53E1 23          > INC HL ; skip y and x
820+  53E2 23          > INC HL
820+  53E3 23          > INC HL
820+  53E4 23          > INC HL
821+  53E5 FD 7E 03         LD A,(IY+3) ; new pattern
822+  53E8 77               LD (HL),A
823+  53E9 23          > INC HL
823+  53EA 23          > INC HL
824+  53EB FD 7E 04         LD A,(IY+4) ; new color
825+  53EE 77               LD (HL),A
826+  53EF 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
827+  53F2 36 01            LD (HL),1
828+  53F4 C9               RET
829+  53F5              ; *******************************************************************************************************
830+  53F5
# file closed: asm\ANIMATION.asm
120   53F5               ENDIF
121   53F5
122   53F5               IF (RAM_CMDS == 1)
123   53F5               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  53F5              ; *******************************************************************************************************
  2+  53F5              ; function to handle CALL MEMCPY basic extension
  3+  53F5              ; _MEMCPY ( INT source,
  4+  53F5              ;			INT destination,
  5+  53F5              ;			INT count,
  6+  53F5              ; will put ram in page 0 also, page 1 is already there
  7+  53F5              MEMCPY:
  8+  53F5              	; opening (
  9+  53F5 CD E4 5E     	CALL CHKCHAR
 10+  53F8 28           	DB '('
 11+  53F9              	; get source address
 12+  53F9 DD 21 2F 54  	LD IX, FRMQNT
 13+  53FD CD 59 01     	CALL CALBAS
 14+  5400 D5           	PUSH DE
 15+  5401              	; comma
 16+  5401 CD E4 5E     	CALL CHKCHAR
 17+  5404 2C           	DB ','
 18+  5405              	; get destination address
 19+  5405 DD 21 2F 54  	LD IX, FRMQNT
 20+  5409 CD 59 01     	CALL CALBAS
 21+  540C D5           	PUSH DE
 22+  540D              	; comma
 23+  540D CD E4 5E     	CALL CHKCHAR
 24+  5410 2C           	DB ','
 25+  5411              	; get length
 26+  5411 DD 21 2F 54  	LD IX, FRMQNT
 27+  5415 CD 59 01     	CALL CALBAS
 28+  5418 D5           	PUSH DE
 29+  5419              	; ending )
 30+  5419 CD E4 5E     	CALL CHKCHAR
 31+  541C 29           	DB ')'
 32+  541D
 33+  541D              	; save position
 34+  541D E5           	PUSH HL
 35+  541E DD E1        	POP IX
 36+  5420
 37+  5420 C1           	POP BC ; count
 38+  5421 D1           	POP DE ; destination
 39+  5422 E1           	POP HL ; source
 40+  5423 D9           	EXX
 41+  5424              	; enable page 0
 42+  5424 FD 21 2B 54  	LD IY, .RET
 43+  5428 C3 97 5E     	JP ENABLE_PAGE0
 44+  542B              .RET:
 45+  542B FB           	EI
 46+  542C D9           	EXX
 47+  542D ED B0        	LDIR
 48+  542F D1               POP DE
 49+  5430 C1               POP BC
 50+  5431 CD 0E 5E         CALL RESTORE_PAGE_INFO
 51+  5434 DD E5        	PUSH IX
 52+  5436 E1           	POP HL
 53+  5437 C9           	RET
 54+  5438              ; *******************************************************************************************************
 55+  5438
 56+  5438              ; *******************************************************************************************************
 57+  5438              ; function to handle CALL FILRAM basic extension
 58+  5438              ; FILRAM ( INT start address,
 59+  5438              ;		   INT count,
 60+  5438              ;		   BYTE value,
 61+  5438              ; will put ram in page 0 also, page 1 is already there
 62+  5438              FILRAM:
 63+  5438              	; opening (
 64+  5438 CD E4 5E     	CALL CHKCHAR
 65+  543B 28           	DB '('
 66+  543C              	; get start address
 67+  543C DD 21 2F 54  	LD IX, FRMQNT
 68+  5440 CD 59 01     	CALL CALBAS
 69+  5443 D5           	PUSH DE
 70+  5444              	; comma
 71+  5444 CD E4 5E     	CALL CHKCHAR
 72+  5447 2C           	DB ','
 73+  5448              	; get count
 74+  5448 DD 21 2F 54  	LD IX, FRMQNT
 75+  544C CD 59 01     	CALL CALBAS
 76+  544F D5           	PUSH DE
 77+  5450              	; comma
 78+  5450 CD E4 5E     	CALL CHKCHAR
 79+  5453 2C           	DB ','
 80+  5454              	; get value
 81+  5454 DD 21 1C 52  	LD IX, GETBYT
 82+  5458 CD 59 01     	CALL CALBAS
 83+  545B F5           	PUSH AF
 84+  545C              	; ending )
 85+  545C CD E4 5E     	CALL CHKCHAR
 86+  545F 29           	DB ')'
 87+  5460
 88+  5460              	; save position
 89+  5460 E5           	PUSH HL
 90+  5461 DD E1        	POP IX
 91+  5463
 92+  5463 D1           	POP DE ; actually AF
 93+  5464 C1           	POP BC ; count
 94+  5465 E1           	POP HL ; start address
 95+  5466 78           	LD A, B
 96+  5467 B7           	OR A
 97+  5468 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  546A B1           	OR C
 99+  546B 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  546D 79           	LD A, C
101+  546E 3D           	DEC A
102+  546F 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  5471              	; one byte to fill
104+  5471 72           	LD (HL), D
105+  5472 18 12        	JR .EXIT
106+  5474              .L1:
107+  5474 D9           	EXX
108+  5475              	; enable page 0
109+  5475 FD 21 7C 54  	LD IY, .RET
110+  5479 C3 97 5E     	JP ENABLE_PAGE0
111+  547C              .RET:
112+  547C FB           	EI
113+  547D D9           	EXX
114+  547E CD 8A 54     	CALL .FILLVALUE
115+  5481 D1               POP DE
116+  5482 C1               POP BC
117+  5483 CD 0E 5E         CALL RESTORE_PAGE_INFO
118+  5486              .EXIT:
119+  5486 DD E5        	PUSH IX
120+  5488 E1           	POP HL
121+  5489 C9           	RET
122+  548A
123+  548A              .FILLVALUE:
124+  548A 72               LD (HL), D
125+  548B 54               LD D, H
126+  548C 5D               LD E, L
127+  548D 13               INC DE
128+  548E 0B               DEC BC
129+  548F ED B0            LDIR
130+  5491 C9               RET
131+  5492              ; *******************************************************************************************************
132+  5492
# file closed: asm\MEMORY.asm
124   5492               ENDIF
125   5492
126   5492               IF (SOUND_CMDS == 1)
127   5492               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  5492              MUSIC_INIT_STATUS:
  2+  5492 00            DB 0
  3+  5493              SFX_INIT_STATUS:
  4+  5493 00            DB 0
  5+  5494              SOUND_ENABLED:
  6+  5494 00            DB 0
  7+  5495
  8+  5495              ; *******************************************************************************************************
  9+  5495              ; function to handle CALL SNDPLYINIT basic extension
 10+  5495              ; initializes sound player
 11+  5495              ; _SNDPLYINIT ( INT music_offset,
 12+  5495              ;				INT sfx_offset, can be -1 if no SFX
 13+  5495              ; will put ram in page 0 also, page 1 is already there
 14+  5495              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  5495              SNDPLYINIT:
 16+  5495              	; opening (
 17+  5495 CD E4 5E     	CALL CHKCHAR
 18+  5498 28           	DB '('
 19+  5499              	; get music address
 20+  5499 DD 21 2F 54  	LD IX, FRMQNT
 21+  549D CD 59 01     	CALL CALBAS
 22+  54A0 D5           	PUSH DE
 23+  54A1              	; comma
 24+  54A1 CD E4 5E     	CALL CHKCHAR
 25+  54A4 2C           	DB ','
 26+  54A5              	; get sfx address
 27+  54A5 DD 21 2F 54  	LD IX, FRMQNT
 28+  54A9 CD 59 01     	CALL CALBAS
 29+  54AC D5           	PUSH DE
 30+  54AD              	; ending )
 31+  54AD CD E4 5E     	CALL CHKCHAR
 32+  54B0 29           	DB ')'
 33+  54B1
 34+  54B1                  ; save position in BASIC text
 35+  54B1 44           	LD B, H
 36+  54B2 4D           	LD C, L
 37+  54B3
 38+  54B3              	; pop LDIR parameters and store away for later
 39+  54B3 D1           	POP DE ; sfx address
 40+  54B4 E1           	POP HL ; music address
 41+  54B5 C5           	PUSH BC ; basic text location
 42+  54B6 D9           	EXX
 43+  54B7 FD 21 BE 54  	LD IY, .RET
 44+  54BB C3 97 5E     	JP ENABLE_PAGE0
 45+  54BE              .RET:
 46+  54BE D9           	EXX
 47+  54BF
 48+  54BF D5           	PUSH DE
 49+  54C0 AF           	XOR A
 50+  54C1              	; HL = music location
 51+  54C1 CD 62 41     	CALL PLY_AKG_INIT
 52+  54C4 3E 01        	LD A, 1
 53+  54C6 32 92 54     	LD (MUSIC_INIT_STATUS), A
 54+  54C9
 55+  54C9 E1           	POP HL ; SFX
 56+  54CA              	; check if SFX address -1
 57+  54CA 23           	INC HL
 58+  54CB 7D           	LD A, L
 59+  54CC B4           	OR H
 60+  54CD 28 09        	JR Z,.L1
 61+  54CF 2B           	DEC HL
 62+  54D0 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  54D3 3E 01        	LD A, 1
 64+  54D5 32 93 54     	LD (SFX_INIT_STATUS), A
 65+  54D8              .L1:
 66+  54D8 D1               POP DE
 67+  54D9 C1               POP BC
 68+  54DA CD 0E 5E         CALL RESTORE_PAGE_INFO
 69+  54DD
 70+  54DD E1           	POP HL
 71+  54DE C9           	RET
 72+  54DF              ; *******************************************************************************************************
 73+  54DF
 74+  54DF              ; *******************************************************************************************************
 75+  54DF              ; function to handle CALL SNDPLYON basic extension
 76+  54DF              ; enables sound player
 77+  54DF              ; _SNDPLYON
 78+  54DF              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  54DF              ; if not throws out of data error
 80+  54DF              SNDPLYON:
 81+  54DF 3A 92 54     	LD A, (MUSIC_INIT_STATUS)
 82+  54E2 B7           	OR A
 83+  54E3 20 05        	JR NZ, .L1
 84+  54E5              	; player not initialized, throw error
 85+  54E5 1E 04        	LD E, 04 ; Out of DATA
 86+  54E7 C3 04 5F     	JP THROW_ERROR
 87+  54EA              .L1:
 88+  54EA 32 94 54     	LD (SOUND_ENABLED), A
 89+  54ED              	; disable key click
 90+  54ED AF           	XOR A
 91+  54EE 32 DB F3     	LD (CLIKSW), A
 92+  54F1 C9           	RET
 93+  54F2              ; *******************************************************************************************************
 94+  54F2
 95+  54F2              ; *******************************************************************************************************
 96+  54F2              ; function to handle CALL SNDPLYOFF basic extension
 97+  54F2              ; disables sound player
 98+  54F2              ; _SNDPLYOFF
 99+  54F2              ; sets SOUND_ENABLED variable to 0
100+  54F2              ; calls AKG to stop music and SFX on all channels if initialized
101+  54F2              SNDPLYOFF:
102+  54F2 3A 94 54     	LD A, (SOUND_ENABLED)
103+  54F5 B7           	OR A
104+  54F6 C8           	RET Z ; already stopped
105+  54F7 AF           	XOR A
106+  54F8 32 94 54     	LD (SOUND_ENABLED), A
107+  54FB E5           	PUSH HL
108+  54FC CD 21 42     	CALL PLY_AKG_STOP
109+  54FF 3A 93 54     	LD A, (SFX_INIT_STATUS)
110+  5502 B7           	OR A
111+  5503 28 0E        	JR Z, .EXIT ; SFX not in use
112+  5505 AF           	XOR A
113+  5506 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  5509 3E 01        	LD A, 1
115+  550B CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  550E 3E 02        	LD A, 2
117+  5510 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  5513              .EXIT:
119+  5513 E1           	POP HL
120+  5514 C9           	RET
121+  5515              ; *******************************************************************************************************
122+  5515
123+  5515              ; *******************************************************************************************************
124+  5515              ; function to handle CALL SNDSFX basic extension
125+  5515              ; plays a sound effect
126+  5515              ; _SNDSFX ( BYTE sfx_number, >0
127+  5515              ;			BYTE channel, = 0,1 or 2
128+  5515              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  5515              ; will put ram in page 0 also, page 1 is already there
130+  5515              ; if sound off throws illegal function call
131+  5515              ; if sfx not initialized, throws out of data
132+  5515              SNDSFX:
133+  5515              	; opening (
134+  5515 CD E4 5E     	CALL CHKCHAR
135+  5518 28           	DB '('
136+  5519              	; get sfx_number
137+  5519 DD 21 1C 52  	LD IX, GETBYT
138+  551D CD 59 01     	CALL CALBAS
139+  5520 D5           	PUSH DE
140+  5521              	; comma
141+  5521 CD E4 5E     	CALL CHKCHAR
142+  5524 2C           	DB ','
143+  5525              	; get sfx address
144+  5525 DD 21 1C 52  	LD IX, GETBYT
145+  5529 CD 59 01     	CALL CALBAS
146+  552C D5           	PUSH DE
147+  552D              	; comma
148+  552D CD E4 5E     	CALL CHKCHAR
149+  5530 2C           	DB ','
150+  5531              	; get inverted volume
151+  5531 DD 21 1C 52  	LD IX, GETBYT
152+  5535 CD 59 01     	CALL CALBAS
153+  5538 D5           	PUSH DE
154+  5539              	; ending )
155+  5539 CD E4 5E     	CALL CHKCHAR
156+  553C 29           	DB ')'
157+  553D
158+  553D 3A 94 54     	LD A, (SOUND_ENABLED)
159+  5540 B7           	OR A
160+  5541 20 05        	JR NZ, .L1
161+  5543              	; sound disabled, throw illegal function call
162+  5543 1E 05        	LD E, 5
163+  5545 C3 04 5F     	JP THROW_ERROR
164+  5548              .L1:
165+  5548 3A 93 54     	LD A, (SFX_INIT_STATUS)
166+  554B B7           	OR A
167+  554C 20 05        	JR NZ, .L2
168+  554E              	; sfx data not initialized, throw out of data
169+  554E 1E 04        	LD E, 4
170+  5550 C3 04 5F     	JP THROW_ERROR
171+  5553              .L2:
172+  5553              	; pop  parameters and store away for later
173+  5553 D1           	POP DE ; inverted volume
174+  5554 43           	LD B, E
175+  5555 D1           	POP DE ; channel
176+  5556 4B           	LD C, E
177+  5557 D1           	POP DE
178+  5558 7B           	LD A, E
179+  5559 08           	EX AF, AF'
180+  555A E5           	PUSH HL ; basic text location
181+  555B D9           	EXX
182+  555C FD 21 63 55  	LD IY, .RET
183+  5560 C3 97 5E     	JP ENABLE_PAGE0
184+  5563              .RET:
185+  5563 D9           	EXX
186+  5564 08           	EX AF, AF'
187+  5565 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  5568
189+  5568 D1               POP DE
190+  5569 C1               POP BC
191+  556A CD 0E 5E         CALL RESTORE_PAGE_INFO
192+  556D
193+  556D E1           	POP HL
194+  556E C9           	RET
195+  556F              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
128   556F               ENDIF
129   556F
130   556F               IF (VRAM_CMDS == 1)
131   556F               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  556F              ; *******************************************************************************************************
  2+  556F              ; function to handle CALL FILVRM basic extension
  3+  556F              ; FILVRM ( INT offset,
  4+  556F              ;		   INT count,
  5+  556F              ;		   BYTE value,
  6+  556F              ;		   BYTE wait_vsync) >0 = true
  7+  556F              ; wait_vsync will issue HALT before copying
  8+  556F              FILVRM:
  9+  556F              	; opening (
 10+  556F CD E4 5E     	CALL CHKCHAR
 11+  5572 28           	DB '('
 12+  5573              	; get offset address
 13+  5573 DD 21 2F 54  	LD IX, FRMQNT
 14+  5577 CD 59 01     	CALL CALBAS
 15+  557A D5           	PUSH DE
 16+  557B              	; comma
 17+  557B CD E4 5E     	CALL CHKCHAR
 18+  557E 2C           	DB ','
 19+  557F              	; get count
 20+  557F DD 21 2F 54  	LD IX, FRMQNT
 21+  5583 CD 59 01     	CALL CALBAS
 22+  5586 D5           	PUSH DE
 23+  5587              	; comma
 24+  5587 CD E4 5E     	CALL CHKCHAR
 25+  558A 2C           	DB ','
 26+  558B              	; get value
 27+  558B DD 21 1C 52  	LD IX, GETBYT
 28+  558F CD 59 01     	CALL CALBAS
 29+  5592 F5           	PUSH AF
 30+  5593              	; comma
 31+  5593 CD E4 5E     	CALL CHKCHAR
 32+  5596 2C           	DB ','
 33+  5597              	; get vsync wait
 34+  5597 DD 21 1C 52  	LD IX, GETBYT
 35+  559B CD 59 01     	CALL CALBAS
 36+  559E F5           	PUSH AF
 37+  559F              	; ending )
 38+  559F CD E4 5E     	CALL CHKCHAR
 39+  55A2 29           	DB ')'
 40+  55A3
 41+  55A3 FB               EI
 42+  55A4              	; save position
 43+  55A4 E5           	PUSH HL
 44+  55A5 DD E1        	POP IX
 45+  55A7
 46+  55A7              	; syntax ok
 47+  55A7              	; wait for vsync if needed
 48+  55A7 F1           	POP AF
 49+  55A8 B7           	OR A
 50+  55A9 28 01        	JR Z, .L1
 51+  55AB 76           	HALT
 52+  55AC
 53+  55AC              .L1:
 54+  55AC 3E 01        	LD A,1
 55+  55AE 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  55B1 F1               POP AF ; value
 57+  55B2 C1               POP BC ; count
 58+  55B3 E1               POP HL ; offset
 59+  55B4 CD 56 00         CALL BIOS_FILVRM
 60+  55B7 AF           	XOR A
 61+  55B8 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  55BB
 63+  55BB              .L3:
 64+  55BB DD E5        	PUSH IX
 65+  55BD E1           	POP HL
 66+  55BE C9           	RET
 67+  55BF              ; *******************************************************************************************************
 68+  55BF
 69+  55BF              ; *******************************************************************************************************
 70+  55BF              ; function to handle CALL MEMVRM basic extension
 71+  55BF              ; copies from RAM to VRAM
 72+  55BF              ; _MEMVRM ( INT source,
 73+  55BF              ;			INT destination,
 74+  55BF              ;			INT count,
 75+  55BF              ;			BYTE wait_vsync) >0 = true
 76+  55BF              ; will put ram in page 0 also, page 1 is already there
 77+  55BF              ; wait_vsync will issue HALT before copying
 78+  55BF              MEMVRM:
 79+  55BF              	; opening (
 80+  55BF CD E4 5E     	CALL CHKCHAR
 81+  55C2 28           	DB '('
 82+  55C3              	; get source address
 83+  55C3 DD 21 2F 54  	LD IX, FRMQNT
 84+  55C7 CD 59 01     	CALL CALBAS
 85+  55CA D5           	PUSH DE
 86+  55CB              	; comma
 87+  55CB CD E4 5E     	CALL CHKCHAR
 88+  55CE 2C           	DB ','
 89+  55CF              	; get destination address
 90+  55CF DD 21 2F 54  	LD IX, FRMQNT
 91+  55D3 CD 59 01     	CALL CALBAS
 92+  55D6 D5           	PUSH DE
 93+  55D7              	; comma
 94+  55D7 CD E4 5E     	CALL CHKCHAR
 95+  55DA 2C           	DB ','
 96+  55DB              	; get length
 97+  55DB DD 21 2F 54  	LD IX, FRMQNT
 98+  55DF CD 59 01     	CALL CALBAS
 99+  55E2 D5           	PUSH DE
100+  55E3              	; comma
101+  55E3 CD E4 5E     	CALL CHKCHAR
102+  55E6 2C           	DB ','
103+  55E7              	; get vsync wait
104+  55E7 DD 21 1C 52  	LD IX, GETBYT
105+  55EB CD 59 01     	CALL CALBAS
106+  55EE F5           	PUSH AF
107+  55EF              	; ending )
108+  55EF CD E4 5E     	CALL CHKCHAR
109+  55F2 29           	DB ')'
110+  55F3
111+  55F3                  ; save position in BASIC text
112+  55F3 E5           	PUSH HL
113+  55F4 DD E1        	POP IX
114+  55F6
115+  55F6 F1           	POP AF ; wait vsync
116+  55F7 B7           	OR A
117+  55F8 28 03        	JR Z, .L1
118+  55FA FB               EI
119+  55FB 76           	HALT
120+  55FC F3           	DI
121+  55FD              .L1:
122+  55FD              	; pop LDIR parameters and store away for later
123+  55FD C1           	POP BC ; count
124+  55FE D1           	POP DE ; vram destination
125+  55FF E1           	POP HL ; ram source
126+  5600 D9           	EXX
127+  5601 FD 21 08 56   	LD IY, .RET
128+  5605 C3 97 5E     	JP ENABLE_PAGE0
129+  5608              .RET:
130+  5608 FB           	EI
131+  5609 D9           	EXX
132+  560A 3E 01        	LD A,1
133+  560C 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  560F CD 1F 56     	CALL .LDIRVM
135+  5612 AF           	XOR A
136+  5613 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  5616 D1               POP DE
138+  5617 C1               POP BC
139+  5618 CD 0E 5E         CALL RESTORE_PAGE_INFO
140+  561B DD E5        	PUSH IX
141+  561D E1           	POP HL
142+  561E C9           	RET
143+  561F
144+  561F              .LDIRVM:
145+  561F EB           	EX DE, HL
146+  5620 F3           	DI
147+  5621 CD BE 5D     	CALL SETWRT_LOCAL
148+  5624 FB           	EI
149+  5625 EB           	EX DE, HL
150+  5626 78           	LD A, B
151+  5627 B7           	OR A
152+  5628 28 0D        	JR Z, .L3
153+  562A C5           	PUSH BC
154+  562B 0E 98        	LD C, #98
155+  562D              .L2:
156+  562D 50           	LD D, B
157+  562E 06 00        	LD B, 0
158+  5630 CD CB 5D     	CALL BBYTECOPY_NO_C
159+  5633 42           	LD B, D
160+  5634 10 F7        	DJNZ .L2
161+  5636 C1           	POP BC
162+  5637              .L3:
163+  5637 79           	LD A, C
164+  5638 B7           	OR A
165+  5639 C8           	RET Z
166+  563A 41           	LD B, C
167+  563B C3 C9 5D     	JP BBYTECOPY
168+  563E              ; *******************************************************************************************************
169+  563E
170+  563E              ; *******************************************************************************************************
171+  563E              ; function to handle CALL VRMMEM basic extension
172+  563E              ; copies from RAM to VRAM
173+  563E              ; _VRMMEM ( INT source,
174+  563E              ;			INT destination,
175+  563E              ;			INT count
176+  563E              ; will put ram in page 0 also, page 1 is already there
177+  563E              VRMMEM:
178+  563E              	; opening (
179+  563E CD E4 5E     	CALL CHKCHAR
180+  5641 28           	DB '('
181+  5642              	; get source address
182+  5642 DD 21 2F 54  	LD IX, FRMQNT
183+  5646 CD 59 01     	CALL CALBAS
184+  5649 D5           	PUSH DE
185+  564A              	; comma
186+  564A CD E4 5E     	CALL CHKCHAR
187+  564D 2C           	DB ','
188+  564E              	; get destination address
189+  564E DD 21 2F 54  	LD IX, FRMQNT
190+  5652 CD 59 01     	CALL CALBAS
191+  5655 D5           	PUSH DE
192+  5656              	; comma
193+  5656 CD E4 5E     	CALL CHKCHAR
194+  5659 2C           	DB ','
195+  565A              	; get length
196+  565A DD 21 2F 54  	LD IX, FRMQNT
197+  565E CD 59 01     	CALL CALBAS
198+  5661 D5           	PUSH DE
199+  5662              	; ending )
200+  5662 CD E4 5E     	CALL CHKCHAR
201+  5665 29           	DB ')'
202+  5666
203+  5666                  ; save position in BASIC text
204+  5666 E5           	PUSH HL
205+  5667 DD E1        	POP IX
206+  5669
207+  5669 C1           	POP BC ; count
208+  566A D1           	POP DE ; destination
209+  566B E1           	POP HL ; source
210+  566C D9           	EXX
211+  566D FD 21 74 56  	LD IY, .RET
212+  5671 C3 97 5E     	JP ENABLE_PAGE0
213+  5674              .RET:
214+  5674 FB           	EI
215+  5675 D9           	EXX
216+  5676 3E 01        	LD A,1
217+  5678 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  567B CD 8B 56     	CALL .LDIRMV
219+  567E AF           	XOR A
220+  567F 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  5682 D1               POP DE
222+  5683 C1               POP BC
223+  5684 CD 0E 5E         CALL RESTORE_PAGE_INFO
224+  5687 DD E5        	PUSH IX
225+  5689 E1           	POP HL
226+  568A C9           	RET
227+  568B
228+  568B              .LDIRMV:
229+  568B              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  568B 7D           	LD	A, L
231+  568C F3           	DI
232+  568D D3 99        	OUT	(099H), A
233+  568F 7C           	LD	A, H
234+  5690 E6 3F        	AND	03FH
235+  5692 D3 99        	OUT	(099H), A
236+  5694 FB           	EI
237+  5695              	;EX (SP), HL
238+  5695              	;EX (SP), HL
239+  5695              	;NOP
240+  5695              	;NOP
241+  5695              .L4:
242+  5695 DB 98            IN A, (#98)
243+  5697 12           	LD (DE), A
244+  5698 13               INC DE
245+  5699 0B               DEC BC
246+  569A 79               LD A, C
247+  569B B0               OR B
248+  569C 20 F7            JR NZ, .L4
249+  569E C9               RET
250+  569F              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
132   569F               ENDIF
133   569F
134   569F               IF (GENCAL_CMD == 1)
135   569F               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  569F              ; *******************************************************************************************************
  2+  569F              ; function to handle CALL GENCAL basic extension
  3+  569F              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  569F              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  569F              ; output values of registers will also be stored at reg_list_ptr
  6+  569F              GENCAL_VAR_SP:
  7+  569F 00 00            DW 0
  8+  56A1              GENCAL_VAR_SP2:
  9+  56A1 00 00            DW 0
 10+  56A3              GENCAL:
 11+  56A3              	; opening (
 12+  56A3 CD E4 5E     	CALL CHKCHAR
 13+  56A6 28           	DB '('
 14+  56A7              	; get function address
 15+  56A7 DD 21 2F 54  	LD IX, FRMQNT
 16+  56AB CD 59 01     	CALL CALBAS
 17+  56AE D5           	PUSH DE
 18+  56AF              	; comma
 19+  56AF CD E4 5E     	CALL CHKCHAR
 20+  56B2 2C           	DB ','
 21+  56B3              	; get pointer to register list
 22+  56B3 3E 02            LD A,2
 23+  56B5 06 01            LD B,1
 24+  56B7 11 00 05         LD DE,#0500
 25+  56BA CD 0B 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  56BD C5           	PUSH BC
 27+  56BE              	; ending )
 28+  56BE CD E4 5E     	CALL CHKCHAR
 29+  56C1 29           	DB ')'
 30+  56C2
 31+  56C2              	; save BASIC token position
 32+  56C2 E5           	PUSH HL
 33+  56C3 D9               EXX
 34+  56C4 E1           	POP HL ; HL'=next basic token
 35+  56C5 D9               EXX
 36+  56C6
 37+  56C6 E1               POP HL ; get pointer to register values
 38+  56C7 F3           	DI
 39+  56C8 ED 73 9F 56      LD (GENCAL_VAR_SP), SP
 40+  56CC F9               LD SP, HL
 41+  56CD F1               POP AF
 42+  56CE C1               POP BC
 43+  56CF D1               POP DE
 44+  56D0 E1               POP HL
 45+  56D1 DD E1            POP IX
 46+  56D3 FD E1            POP IY
 47+  56D5 D9               EXX
 48+  56D6 ED 73 A1 56      LD (GENCAL_VAR_SP2), SP
 49+  56DA ED 7B 9F 56      LD SP, (GENCAL_VAR_SP)
 50+  56DE FB               EI
 51+  56DF D1               POP DE ; get function to call
 52+  56E0 E5               PUSH HL
 53+  56E1 CD FC 56         CALL .EXXDECALL
 54+  56E4 F3               DI
 55+  56E5 ED 73 9F 56      LD (GENCAL_VAR_SP), SP
 56+  56E9 ED 7B A1 56      LD SP, (GENCAL_VAR_SP2)
 57+  56ED FD E5            PUSH IY
 58+  56EF DD E5            PUSH IX
 59+  56F1 E5               PUSH HL
 60+  56F2 D5               PUSH DE
 61+  56F3 C5               PUSH BC
 62+  56F4 F5               PUSH AF
 63+  56F5 ED 7B 9F 56      LD SP, (GENCAL_VAR_SP)
 64+  56F9 FB               EI
 65+  56FA E1               POP HL
 66+  56FB C9           	RET
 67+  56FC
 68+  56FC              .EXXDECALL:
 69+  56FC D5               PUSH DE
 70+  56FD D9               EXX
 71+  56FE C9               RET
 72+  56FF              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
136   56FF               ENDIF
137   56FF
138   56FF               IF (BOX_CMDS == 1)
139   56FF               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  56FF              ; *******************************************************************************************************
  2+  56FF              ; generic function to implement rectangle data copy
  3+  56FF              ; should be modified to call appropriate function for memory or vram
  4+  56FF              ; input IX=pointer to following structure
  5+  56FF              ; +00 source data pointer
  6+  56FF              ; +02 num bytes in a row
  7+  56FF              ; +04 number of rows
  8+  56FF              ; +06 source add-to value till next row
  9+  56FF              ; +08 destination address
 10+  56FF              ; +10 destination add-to value till next row
 11+  56FF              ; modifies AF, BC, DE, HL
 12+  56FF              RECTANGLE_COPY:
 13+  56FF DD 6E 00     	LD L, (IX+0)
 14+  5702 DD 66 01     	LD H, (IX+1) ; source address
 15+  5705 DD 5E 08     	LD E, (IX+8)
 16+  5708 DD 56 09     	LD D, (IX+9) ; destination
 17+  570B DD 46 04     	LD B, (IX+4) ; row number
 18+  570E              .L1:
 19+  570E C5           	PUSH BC
 20+  570F E5           		PUSH HL
 21+  5710 D5           			PUSH DE
 22+  5711 DD 4E 02     				LD C, (IX+2)
 23+  5714 DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  5717              .CALL1:
 25+  5717 CD 00 00     				CALL 0 ; set destination address from DE
 26+  571A              .CALL2:
 27+  571A CD 00 00     				CALL 0 ; copy data fn
 28+  571D E1           			POP HL
 29+  571E DD 4E 0A     			LD C, (IX+10)
 30+  5721 DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  5724 09           			ADD HL, BC
 32+  5725 EB           			EX DE, HL
 33+  5726 E1           		POP HL
 34+  5727 DD 4E 06     		LD C, (IX+6)
 35+  572A DD 46 07     		LD B, (IX+7) ; src add-to
 36+  572D 09           		ADD HL, BC
 37+  572E C1           	POP BC
 38+  572F 10 DD        	DJNZ .L1
 39+  5731 C9           	RET
 40+  5732              ; *******************************************************************************************************
 41+  5732
 42+  5732              ; *******************************************************************************************************
 43+  5732              ; function to handle CALL BOXMEMCPY basic extension
 44+  5732              ; copies data with window like boundaries to ram
 45+  5732              ; BOXMEMCPY ( INT request_data_ptr )
 46+  5732              ; request_data_ptr described in RECTANGLE_COPY
 47+  5732              ; will put ram in page 0 also, page 1 is already there
 48+  5732              BOXMEMCPY:
 49+  5732              	; opening (
 50+  5732 CD E4 5E     	CALL CHKCHAR
 51+  5735 28           	DB '('
 52+  5736              	; get pointer to request struct
 53+  5736 DD 21 2F 54  	LD IX, FRMQNT
 54+  573A CD 59 01     	CALL CALBAS
 55+  573D D5           	PUSH DE
 56+  573E              	; ending )
 57+  573E CD E4 5E     	CALL CHKCHAR
 58+  5741 29           	DB ')'
 59+  5742
 60+  5742 DD E1        	POP IX ; pointer to request struct
 61+  5744
 62+  5744 E5           	PUSH HL ; save position in BASIC buffer
 63+  5745
 64+  5745 FD 21 4C 57  	LD IY, .RET
 65+  5749 C3 97 5E     	JP ENABLE_PAGE0
 66+  574C              .RET:
 67+  574C FB           	EI
 68+  574D              	; set RAM functions to call
 69+  574D 21 00 00     	LD HL, 0
 70+  5750 22 17 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 71+  5753 22 19 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 72+  5756 21 ED B0     	LD HL, #B0ED ; LDIR
 73+  5759 22 1B 57     	LD (RECTANGLE_COPY.CALL1+4), HL
 74+  575C CD FF 56     	CALL RECTANGLE_COPY
 75+  575F
 76+  575F D1               POP DE
 77+  5760 C1               POP BC
 78+  5761 CD 0E 5E         CALL RESTORE_PAGE_INFO
 79+  5764
 80+  5764 E1           	POP HL
 81+  5765 C9           	RET
 82+  5766              ; *******************************************************************************************************
 83+  5766
 84+  5766              ; *******************************************************************************************************
 85+  5766              ; function to handle CALL BOXMEMVRM basic extension
 86+  5766              ; copies data with window like boundaries to Vram
 87+  5766              ; BOXMEMVRM ( INT request_data_ptr )
 88+  5766              ; request_data_ptr described in RECTANGLE_COPY
 89+  5766              ; will put ram in page 0 also, page 1 is already there
 90+  5766              BOXMEMVRM:
 91+  5766              	; opening (
 92+  5766 CD E4 5E     	CALL CHKCHAR
 93+  5769 28           	DB '('
 94+  576A              	; get pointer to request struct
 95+  576A DD 21 2F 54  	LD IX, FRMQNT
 96+  576E CD 59 01     	CALL CALBAS
 97+  5771 D5           	PUSH DE
 98+  5772              	; ending )
 99+  5772 CD E4 5E     	CALL CHKCHAR
100+  5775 29           	DB ')'
101+  5776
102+  5776 DD E1        	POP IX ; pointer to request struct
103+  5778
104+  5778 E5           	PUSH HL ; save position in BASIC buffer
105+  5779
106+  5779 FD 21 80 57  	LD IY, .RET
107+  577D C3 97 5E     	JP ENABLE_PAGE0
108+  5780              .RET:
109+  5780 FB           	EI
110+  5781              	; set RAM functions to call
111+  5781 21 A6 57     	LD HL, .SETDEST
112+  5784 22 18 57     	LD (RECTANGLE_COPY.CALL1+1), HL
113+  5787 21 AE 57     	LD HL, .COPYDATA
114+  578A 22 1B 57     	LD (RECTANGLE_COPY.CALL2+1), HL
115+  578D 3E CD        	LD A, #CD ; CALL
116+  578F 32 17 57     	LD (RECTANGLE_COPY.CALL1), A
117+  5792 32 1A 57     	LD (RECTANGLE_COPY.CALL2), A
118+  5795              	;LD A,1
119+  5795 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
120+  5798 CD FF 56     	CALL RECTANGLE_COPY
121+  579B AF           	XOR A
122+  579C 32 49 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
123+  579F
124+  579F D1               POP DE
125+  57A0 C1               POP BC
126+  57A1 CD 0E 5E         CALL RESTORE_PAGE_INFO
127+  57A4
128+  57A4 E1           	POP HL
129+  57A5 C9           	RET
130+  57A6              .SETDEST:
131+  57A6 EB           	EX DE, HL
132+  57A7 F3           	DI
133+  57A8 CD BE 5D     	CALL SETWRT_LOCAL
134+  57AB FB           	EI
135+  57AC EB           	EX DE, HL
136+  57AD C9           	RET
137+  57AE              .COPYDATA:
138+  57AE 41           	LD B, C
139+  57AF C3 C9 5D     	JP BBYTECOPY
140+  57B2              ; *******************************************************************************************************
# file closed: asm\BOX.asm
140   57B2               ENDIF
141   57B2
142   57B2               IF (BLIT_CMDS == 1)
143   57B2               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  57B2              ; *******************************************************************************************************
  2+  57B2              ; function rotates mask and data of several characters and applies to background data
  3+  57B2              ; this handles x-shift from 0 to 4
  4+  57B2              ; contains self-modifying code that is set-up from external function
  5+  57B2              ; input HL=pointer to mask data
  6+  57B2              ; input HL'=pointer to character data
  7+  57B2              ; input DE=output buffer containing background data
  8+  57B2              ; input BC=DE+8
  9+  57B2              ; input A=number of characters to process
 10+  57B2              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  57B2              SHIFT04:
 12+  57B2 08           	EX AF, AF'
 13+  57B3 7E           	LD A, (HL) ; get mask
 14+  57B4 D9           	EXX
 15+  57B5 57           	LD D, A
 16+  57B6 1E FF        	LD E, #FF
 17+  57B8 37           	SCF
 18+  57B9              .M1:
 19+  57B9 18 FE        	JR .M1 ; this is self-modifying part
 20+  57BB CB 1A        	RR D
 21+  57BD CB 1B        	RR E
 22+  57BF CB 1A        	RR D
 23+  57C1 CB 1B        	RR E
 24+  57C3 CB 1A        	RR D
 25+  57C5 CB 1B        	RR E
 26+  57C7 CB 1A        	RR D
 27+  57C9 CB 1B        	RR E
 28+  57CB
 29+  57CB 46           	LD B, (HL) ; get data
 30+  57CC 0E 00        	LD C, 0
 31+  57CE              .M2:
 32+  57CE 18 FE        	JR .M2 ; also self-modifying part
 33+  57D0 CB 38        	SRL B
 34+  57D2 CB 19        	RR C
 35+  57D4 CB 38        	SRL B
 36+  57D6 CB 19        	RR C
 37+  57D8 CB 38        	SRL B
 38+  57DA CB 19        	RR C
 39+  57DC CB 38        	SRL B
 40+  57DE CB 19        	RR C
 41+  57E0
 42+  57E0 D9           	EXX
 43+  57E1 1A           	LD A, (DE) ; background
 44+  57E2 D9           	EXX
 45+  57E3 A2           	AND D
 46+  57E4 B0           	OR B
 47+  57E5 D9           	EXX
 48+  57E6 12           	LD (DE), A
 49+  57E7
 50+  57E7 0A           	LD A, (BC)
 51+  57E8 D9           	EXX
 52+  57E9 A3           	AND E
 53+  57EA B1           	OR C
 54+  57EB 23           	INC HL
 55+  57EC D9           	EXX
 56+  57ED 02           	LD (BC), A
 57+  57EE
 58+  57EE 23           	INC HL
 59+  57EF 13           	INC DE
 60+  57F0 03           	INC BC
 61+  57F1
 62+  57F1 08           	EX AF, AF'
 63+  57F2 3D           	DEC A
 64+  57F3 C2 B2 57     	JP NZ, SHIFT04
 65+  57F6 C9           	RET
 66+  57F7              ; *******************************************************************************************************
 67+  57F7
 68+  57F7              ; *******************************************************************************************************
 69+  57F7              ; function rotates mask and data of several characters and applies to background data
 70+  57F7              ; this handles x-shift from 5 to 8
 71+  57F7              ; contains self-modifying code that is set-up from external function
 72+  57F7              ; input HL=pointer to mask data
 73+  57F7              ; input HL'=pointer to character data
 74+  57F7              ; input DE=output buffer containing background data
 75+  57F7              ; input BC=DE+8
 76+  57F7              ; input A=number of characters to process
 77+  57F7              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  57F7              SHIFT58:
 79+  57F7 08           	EX AF, AF'
 80+  57F8 7E           	LD A, (HL) ; get mask
 81+  57F9 D9           	EXX
 82+  57FA 57           	LD D, A
 83+  57FB 1E FF        	LD E, #FF
 84+  57FD 37           	SCF
 85+  57FE              .M1:
 86+  57FE 18 FE        	JR .M1 ; this is self-modifying part
 87+  5800 CB 12        	RL D
 88+  5802 CB 13        	RL E
 89+  5804 CB 12        	RL D
 90+  5806 CB 13        	RL E
 91+  5808 CB 12        	RL D
 92+  580A CB 13        	RL E
 93+  580C
 94+  580C 46           	LD B, (HL)
 95+  580D 0E 00        	LD C, 0
 96+  580F              .M2:
 97+  580F 18 FE        	JR .M2 ; also self-modifying part
 98+  5811 CB 20        	SLA B
 99+  5813 CB 11        	RL C
100+  5815 CB 20        	SLA B
101+  5817 CB 11        	RL C
102+  5819 CB 20        	SLA B
103+  581B CB 11        	RL C
104+  581D
105+  581D D9           	EXX
106+  581E 1A           	LD A, (DE) ; background
107+  581F D9           	EXX
108+  5820 A3           	AND E
109+  5821 B1           	OR C
110+  5822 D9           	EXX
111+  5823 12           	LD (DE), A
112+  5824
113+  5824 0A           	LD A, (BC)
114+  5825 D9           	EXX
115+  5826 A2           	AND D
116+  5827 B0           	OR B
117+  5828 23           	INC HL
118+  5829 D9           	EXX
119+  582A 02           	LD (BC), A
120+  582B
121+  582B 23           	INC HL
122+  582C 13           	INC DE
123+  582D 03           	INC BC
124+  582E
125+  582E 08           	EX AF, AF'
126+  582F 3D           	DEC A
127+  5830 C2 F7 57     	JP NZ, SHIFT58
128+  5833 C9           	RET
129+  5834              ; *******************************************************************************************************
130+  5834
131+  5834              ; *******************************************************************************************************
132+  5834              ; routine that shifts one row of characters
133+  5834              ; contains self-modifying code that is set-up from external function
134+  5834              ; input HL=pointer to mask data
135+  5834              ; input HL'=pointer to character data
136+  5834              ; input DE=output buffer containing background data
137+  5834              ; input A=number of characters to process
138+  5834              ; input IX=pointer to structure describing input data
139+  5834              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  5834              SHIFT_ROW:
141+  5834 F5           	PUSH AF
142+  5835 ED 53 34 5C  		LD (BLIT_TMP1), DE
143+  5839 E5           		PUSH HL
144+  583A CD 7D 58     			CALL .ADDYSHIFT
145+  583D E1           		POP HL
146+  583E ED 53 36 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  5842              .L1:
148+  5842 3E 08        		LD A, 8
149+  5844 DD 96 02     		SUB (IX+2) ; y shift
150+  5847              .CALL1:
151+  5847 CD 00 00     		CALL 0
152+  584A DD 7E 02     		LD A, (IX+2); y shift
153+  584D B7           		OR A
154+  584E 28 26        		JR Z, .DONE
155+  5850 ED 5B 34 5C  		LD DE, (BLIT_TMP1)
156+  5854 E5           		PUSH HL
157+  5855 CD 8B 58     			CALL .DETONEXTROW
158+  5858 E1           		POP HL
159+  5859              .CALL2:
160+  5859 CD 00 00     		CALL 0
161+  585C ED 5B 34 5C  		LD DE, (BLIT_TMP1)
162+  5860 E5           		PUSH HL
163+  5861 CD 85 58     			CALL .ADD8
164+  5864 E1           		POP HL
165+  5865 ED 53 34 5C  		LD (BLIT_TMP1), DE
166+  5869 ED 5B 36 5C  		LD DE, (BLIT_TMP2)
167+  586D E5           		PUSH HL
168+  586E CD 85 58     			CALL .ADD8
169+  5871 E1           		POP HL
170+  5872 ED 53 36 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  5876              .DONE:
172+  5876 F1           	POP AF
173+  5877 3D           	DEC A
174+  5878 C8           	RET Z
175+  5879 F5           	PUSH AF
176+  587A C3 42 58     	JP .L1
177+  587D              .ADDYSHIFT:
178+  587D EB           	EX DE, HL
179+  587E 16 00        	LD D, 0
180+  5880 DD 5E 02     	LD E, (IX+2); y shift
181+  5883 18 0C        	JR .MOVDEBC
182+  5885              .ADD8:
183+  5885 21 08 00     	LD HL, 8
184+  5888 C3 91 58     	JP .MOVDEBC
185+  588B              .DETONEXTROW:
186+  588B DD 6E 06     	LD L, (IX+6)
187+  588E DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5891              .MOVDEBC:
189+  5891 19           	ADD HL, DE
190+  5892 54           	LD D, H
191+  5893 5D           	LD E, L
192+  5894 01 08 00     	LD BC, 8
193+  5897 09           	ADD HL, BC
194+  5898 44           	LD B, H
195+  5899 4D           	LD C, L
196+  589A C9           	RET
197+  589B              ; *******************************************************************************************************
198+  589B
199+  589B              ; *******************************************************************************************************
200+  589B              ; function rotates mask and character data and applies it to background
201+  589B              ; input IX=pointer to structure describing input data
202+  589B              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  589B              ; +2  DW vertical shift count 0-7 (low byte used)
204+  589B              ; +4  DW background data start;
205+  589B              ; +6  DW background add to value to next row of background data
206+  589B              ; +8  DW mask data start;
207+  589B              ; +10  DW character data start;
208+  589B              ; +12 DW character&mask add to value to next row of data
209+  589B              ; +14 DW columns (low byte used)
210+  589B              ; +16 DW rows (low byte used)
211+  589B              SHIFT_MERGE_CHARACTER:
212+  589B DD 7E 00     	LD A, (IX) ; shift
213+  589E FE 05        	CP 5
214+  58A0 38 25        	JR C, .RIGHT
215+  58A2              	; shifts 5-7, use rotate towards left 1-3
216+  58A2 21 F7 57     	LD HL, SHIFT58
217+  58A5 22 48 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  58A8 22 5A 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  58AB D6 05        	SUB 5
220+  58AD 28 0D        	JR Z, .L1
221+  58AF 87           	ADD A, A
222+  58B0 87           	ADD A, A
223+  58B1 67           	LD H, A
224+  58B2 2E 18        	LD L, #18 ; JR opcode
225+  58B4 22 FE 57     	LD (SHIFT58.M1), HL
226+  58B7 22 0F 58     	LD (SHIFT58.M2), HL
227+  58BA 18 32        	JR .DO
228+  58BC              .L1:
229+  58BC 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  58BF 22 FE 57     	LD (SHIFT58.M1), HL
231+  58C2 22 0F 58     	LD (SHIFT58.M2), HL
232+  58C5 18 27        	JR .DO
233+  58C7              .RIGHT:
234+  58C7              	; shifts 0-4, rotate towards right
235+  58C7 21 B2 57     	LD HL, SHIFT04
236+  58CA 22 48 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  58CD 22 5A 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  58D0 FE 04        	CP 4
239+  58D2 28 11        	JR Z, .R1
240+  58D4 D6 04        	SUB 4
241+  58D6 ED 44        	NEG
242+  58D8 87           	ADD A, A
243+  58D9 87           	ADD A, A
244+  58DA 67           	LD H, A
245+  58DB 2E 18        	LD L, #18 ; JR opcode
246+  58DD 22 B9 57     	LD (SHIFT04.M1), HL
247+  58E0 22 CE 57     	LD (SHIFT04.M2), HL
248+  58E3 18 09        	JR .DO
249+  58E5              .R1:
250+  58E5 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  58E8 22 B9 57     	LD (SHIFT04.M1), HL
252+  58EB 22 CE 57     	LD (SHIFT04.M2), HL
253+  58EE              .DO:
254+  58EE DD 46 10     	LD B, (IX+16) ; rows
255+  58F1 DD 6E 08     	LD L, (IX+8)
256+  58F4 DD 66 09     	LD H, (IX+9) ; mask data
257+  58F7 DD 5E 04     	LD E, (IX+4)
258+  58FA DD 56 05     	LD D, (IX+5) ; background data
259+  58FD D9           	EXX
260+  58FE DD 6E 0A     	LD L, (IX+10)
261+  5901 DD 66 0B     	LD H, (IX+11) ; character data
262+  5904 D9           	EXX
263+  5905              .LOOP:
264+  5905 C5           	PUSH BC
265+  5906 E5           		PUSH HL
266+  5907 D5           			PUSH DE
267+  5908 D9           				EXX
268+  5909 E5           				PUSH HL
269+  590A D9           					EXX
270+  590B DD 7E 0E     					LD A, (IX+14) ; columns
271+  590E              .CALL:
272+  590E CD 34 58     					CALL SHIFT_ROW
273+  5911 E1           				POP HL
274+  5912 DD 5E 0C     				LD E, (IX+12)
275+  5915 DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  5918 19           				ADD HL, DE
277+  5919 D9           				EXX
278+  591A E1           			POP HL
279+  591B DD 5E 06     			LD E, (IX+6)
280+  591E DD 56 07     			LD D, (IX+7) ; background to next row
281+  5921 19           			ADD HL, DE
282+  5922 EB           			EX DE, HL
283+  5923 E1           		POP HL
284+  5924 DD 4E 0C     		LD C, (IX+12)
285+  5927 DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  592A 09           		ADD HL, BC
287+  592B C1           	POP BC
288+  592C 10 D7        	DJNZ .LOOP
289+  592E C9           	RET
290+  592F              ; *******************************************************************************************************
291+  592F
292+  592F               IFNDEF CMDS_WITH_PARAMETERS
293+  592F ~            ; *******************************************************************************************************
294+  592F ~            ; function to handle CALL BLIT basic extension
295+  592F ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  592F ~            ; fuses with background data and applies vertical shift too
297+  592F ~            ; BLIT ( INT request_data_ptr )
298+  592F ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  592F ~            ; will put ram in page 0 also, page 1 is already there
300+  592F ~            BLIT:
301+  592F ~            	; opening (
302+  592F ~            	CALL CHKCHAR
303+  592F ~            	DB '('
304+  592F ~            	; get pointer to request struct
305+  592F ~            	LD IX, FRMQNT
306+  592F ~            	CALL CALBAS
307+  592F ~            	PUSH DE
308+  592F ~            	; ending )
309+  592F ~            	CALL CHKCHAR
310+  592F ~            	DB ')'
311+  592F ~
312+  592F ~            	POP IX ; pointer to request struct
313+  592F ~
314+  592F ~            	PUSH HL ; save position in BASIC buffer
315+  592F ~
316+  592F ~            	LD IY, .RET
317+  592F ~            	JP ENABLE_PAGE0
318+  592F ~            .RET:
319+  592F ~            	EI
320+  592F ~            	CALL SHIFT_MERGE_CHARACTER
321+  592F ~
322+  592F ~                POP DE
323+  592F ~                POP BC
324+  592F ~                CALL RESTORE_PAGE_INFO
325+  592F ~
326+  592F ~            	POP HL
327+  592F ~            	RET
328+  592F ~            ; *******************************************************************************************************
329+  592F               ENDIF
330+  592F
331+  592F               IFDEF CMDS_WITH_PARAMETERS
332+  592F              ; *******************************************************************************************************
333+  592F              ; function to handle CALL BLIT basic extension
334+  592F              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  592F              ; fuses with background data and applies vertical shift too
336+  592F              ; in form without pointers
337+  592F              ; BLIT ( INT x,
338+  592F              ;		 INT y,
339+  592F              ;		 INT char_data_pointer,
340+  592F              ;		 INT mask_data_pointer,
341+  592F              ;		 INT width (in characters),
342+  592F              ;		 INT height (in characters),
343+  592F              ;		 INT background_pointer (top left),
344+  592F              ;		 INT background_width (in characters),
345+  592F              ;		 INT background_height (in characters))
346+  592F              ; will put ram in page 0 also, page 1 is already there
347+  592F              BLIT:
348+  592F              	; opening (
349+  592F CD E4 5E     	CALL CHKCHAR
350+  5932 28           	DB '('
351+  5933              	; get x coordinate
352+  5933 DD 21 2F 54  	LD IX, FRMQNT
353+  5937 CD 59 01     	CALL CALBAS
354+  593A 7B           	LD A, E
355+  593B E6 07        	AND 7
356+  593D 32 38 5C     	LD (BLIT_STRUCT+0), A
357+  5940 CD 1D 5A     	CALL .DAdiv8
358+  5943 32 34 5C     	LD (BLIT_TMP+0),A
359+  5946              	; comma
360+  5946 CD E4 5E     	CALL CHKCHAR
361+  5949 2C           	DB ','
362+  594A              	; get y coordinate
363+  594A DD 21 2F 54  	LD IX, FRMQNT
364+  594E CD 59 01     	CALL CALBAS
365+  5951 7B           	LD A, E
366+  5952 E6 07        	AND 7
367+  5954 32 3A 5C     	LD (BLIT_STRUCT+2), A
368+  5957 CD 1D 5A     	CALL .DAdiv8
369+  595A 32 35 5C     	LD (BLIT_TMP+1),A
370+  595D              	; comma
371+  595D CD E4 5E     	CALL CHKCHAR
372+  5960 2C           	DB ','
373+  5961              	; get char data pointer
374+  5961 DD 21 2F 54  	LD IX, FRMQNT
375+  5965 CD 59 01     	CALL CALBAS
376+  5968 ED 53 42 5C  	LD (BLIT_STRUCT+10), DE
377+  596C              	; comma
378+  596C CD E4 5E     	CALL CHKCHAR
379+  596F 2C           	DB ','
380+  5970              	; get mask data pointer
381+  5970 DD 21 2F 54  	LD IX, FRMQNT
382+  5974 CD 59 01     	CALL CALBAS
383+  5977 ED 53 40 5C  	LD (BLIT_STRUCT+8), DE
384+  597B              	; comma
385+  597B CD E4 5E     	CALL CHKCHAR
386+  597E 2C           	DB ','
387+  597F              	; get width
388+  597F DD 21 2F 54  	LD IX, FRMQNT
389+  5983 CD 59 01     	CALL CALBAS
390+  5986 7B           	LD A, E
391+  5987 32 46 5C     	LD (BLIT_STRUCT+14), A
392+  598A              	; comma
393+  598A CD E4 5E     	CALL CHKCHAR
394+  598D 2C           	DB ','
395+  598E              	; get height
396+  598E DD 21 2F 54  	LD IX, FRMQNT
397+  5992 CD 59 01     	CALL CALBAS
398+  5995 7B           	LD A, E
399+  5996 32 48 5C     	LD (BLIT_STRUCT+16), A
400+  5999              	; comma
401+  5999 CD E4 5E     	CALL CHKCHAR
402+  599C 2C           	DB ','
403+  599D              	; get background pointer
404+  599D DD 21 2F 54  	LD IX, FRMQNT
405+  59A1 CD 59 01     	CALL CALBAS
406+  59A4 ED 53 3C 5C  	LD (BLIT_STRUCT+4), DE
407+  59A8              	; comma
408+  59A8 CD E4 5E     	CALL CHKCHAR
409+  59AB 2C           	DB ','
410+  59AC              	; get background width
411+  59AC DD 21 2F 54  	LD IX, FRMQNT
412+  59B0 CD 59 01     	CALL CALBAS
413+  59B3 7B           	LD A, E
414+  59B4 32 36 5C     	LD (BLIT_TMP+2), A
415+  59B7              	; comma
416+  59B7 CD E4 5E     	CALL CHKCHAR
417+  59BA 2C           	DB ','
418+  59BB              	; get background height
419+  59BB DD 21 2F 54  	LD IX, FRMQNT
420+  59BF CD 59 01     	CALL CALBAS
421+  59C2 7B           	LD A, E
422+  59C3 32 37 5C     	LD (BLIT_TMP+3), A
423+  59C6              	; ending )
424+  59C6 CD E4 5E     	CALL CHKCHAR
425+  59C9 29           	DB ')'
426+  59CA
427+  59CA E5           	PUSH HL ; save position in BASIC buffer
428+  59CB
429+  59CB              	; calculate char&mask add to value
430+  59CB 26 00        	LD H, 0
431+  59CD 3A 46 5C     	LD A, (BLIT_STRUCT+14)
432+  59D0 6F           	LD L, A
433+  59D1 CD D3 5D     	CALL HLx8
434+  59D4 22 44 5C     	LD (BLIT_STRUCT+12), HL
435+  59D7              	; calculate background add to value
436+  59D7 26 00        	LD H, 0
437+  59D9 3A 36 5C     	LD A, (BLIT_TMP+2)
438+  59DC 6F           	LD L, A
439+  59DD CD D3 5D     	CALL HLx8
440+  59E0 22 3E 5C     	LD (BLIT_STRUCT+6), HL
441+  59E3              	; calculate pointer to background location
442+  59E3 21 00 00     	LD HL, 0
443+  59E6 3A 35 5C     	LD A,(BLIT_TMP+1)
444+  59E9 B7           	OR A
445+  59EA 28 08        	JR Z, .L1
446+  59EC 47           	LD B,A
447+  59ED ED 5B 3E 5C  	LD DE,(BLIT_STRUCT+6)
448+  59F1              .L0:
449+  59F1 19           	ADD HL, DE
450+  59F2 10 FD        	DJNZ .L0
451+  59F4              .L1:
452+  59F4 EB           	EX DE,HL
453+  59F5 26 00        	LD H,0
454+  59F7 3A 34 5C     	LD A,(BLIT_TMP+0)
455+  59FA 6F           	LD L,A
456+  59FB CD D3 5D     	CALL HLx8
457+  59FE 19           	ADD HL,DE
458+  59FF ED 5B 3C 5C  	LD DE,(BLIT_STRUCT+4)
459+  5A03 19           	ADD HL,DE
460+  5A04 22 3C 5C     	LD (BLIT_STRUCT+4),HL
461+  5A07
462+  5A07 FD 21 0E 5A  	LD IY, .RET
463+  5A0B C3 97 5E     	JP ENABLE_PAGE0
464+  5A0E              .RET:
465+  5A0E FB           	EI
466+  5A0F DD 21 38 5C  	LD IX, BLIT_STRUCT
467+  5A13 CD 9B 58     	CALL SHIFT_MERGE_CHARACTER
468+  5A16
469+  5A16 D1               POP DE
470+  5A17 C1               POP BC
471+  5A18 CD 0E 5E         CALL RESTORE_PAGE_INFO
472+  5A1B
473+  5A1B E1           	POP HL
474+  5A1C C9           	RET
475+  5A1D              .DAdiv8:
476+  5A1D 7B           	LD A,E
477+  5A1E CB 2A        	SRA D
478+  5A20 CB 1F            RR  A
479+  5A22 CB 2A            SRA D
480+  5A24 CB 1F            RR  A
481+  5A26 CB 2A            SRA D
482+  5A28 CB 1F            RR  A
483+  5A2A C9           	RET
484+  5A2B              ; *******************************************************************************************************
485+  5A2B               ENDIF
# file closed: asm\BLIT.asm
144   5A2B               ENDIF
145   5A2B
146   5A2B               IF (TILE_CMDS == 1)
147   5A2B               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5A2B              ; *******************************************************************************************************
  2+  5A2B              ; generic function to implement tiling
  3+  5A2B              ; should be modified to call appropriate function for memory or vram
  4+  5A2B              ; input IX=pointer to following structure
  5+  5A2B              ; +00 tile_data_ptr
  6+  5A2B              ; +02 tile_rows
  7+  5A2B              ; +04 tile_columns
  8+  5A2B              ; +06 destination_address
  9+  5A2B              ; +08 dest_to_next_row_add_to_value
 10+  5A2B              ; +10 num_horizontal_tiles
 11+  5A2B              ; +12 num_vertical_tiles
 12+  5A2B              ; modifies AF, BC, DE, HL
 13+  5A2B              TILE:
 14+  5A2B DD 6E 06     	LD L, (IX+6)
 15+  5A2E DD 66 07     	LD H, (IX+7) ; destination address
 16+  5A31 22 34 5C     	LD (TILETMP1), HL
 17+  5A34 DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5A37              .L1:
 19+  5A37 C5           	PUSH BC
 20+  5A38 DD 6E 00     		LD L, (IX+0)
 21+  5A3B DD 66 01     		LD H, (IX+1) ; tile address
 22+  5A3E 22 36 5C     		LD (TILETMP2), HL
 23+  5A41 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5A44              .L2:
 25+  5A44 C5           		PUSH BC
 26+  5A45 CD 00 00     .CALL1:		CALL 0
 27+  5A48 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5A4B              .L3:
 29+  5A4B C5           			PUSH BC
 30+  5A4C 2A 36 5C     				LD HL, (TILETMP2)
 31+  5A4F DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5A52              .L4:
 33+  5A52 C5           				PUSH BC
 34+  5A53              .CALL2:
 35+  5A53 CD 00 00     					CALL 0
 36+  5A56 C1           				POP BC
 37+  5A57 10 F9        				DJNZ .L4
 38+  5A59 C1           			POP BC
 39+  5A5A 10 EF        			DJNZ .L3
 40+  5A5C 22 36 5C     			LD (TILETMP2), HL
 41+  5A5F 2A 34 5C     			LD HL, (TILETMP1)
 42+  5A62 DD 5E 08     			LD E, (IX+8)
 43+  5A65 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5A68 19           			ADD HL, DE
 45+  5A69 22 34 5C     			LD (TILETMP1), HL
 46+  5A6C C1           		POP BC
 47+  5A6D 10 D5        		DJNZ .L2
 48+  5A6F C1           	POP BC
 49+  5A70 10 C5        	DJNZ .L1
 50+  5A72 C9           	RET
 51+  5A73              ; *******************************************************************************************************
 52+  5A73
 53+  5A73               IFNDEF CMDS_WITH_PARAMETERS
 54+  5A73 ~            ; *******************************************************************************************************
 55+  5A73 ~            ; function to handle CALL TILERAM basic extension
 56+  5A73 ~            ; fills memory with tiles
 57+  5A73 ~            ; TILERAM ( INT request_data_ptr )
 58+  5A73 ~            ; request_data_ptr described in TILE
 59+  5A73 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5A73 ~            TILERAM:
 61+  5A73 ~            	; opening (
 62+  5A73 ~            	CALL CHKCHAR
 63+  5A73 ~            	DB '('
 64+  5A73 ~            	; get pointer to request struct
 65+  5A73 ~            	LD IX, FRMQNT
 66+  5A73 ~            	CALL CALBAS
 67+  5A73 ~            	PUSH DE
 68+  5A73 ~            	; ending )
 69+  5A73 ~            	CALL CHKCHAR
 70+  5A73 ~            	DB ')'
 71+  5A73 ~
 72+  5A73 ~            	POP IX ; pointer to request struct
 73+  5A73 ~
 74+  5A73 ~            	PUSH HL ; save position in BASIC buffer
 75+  5A73 ~
 76+  5A73 ~            	LD IY, .RET
 77+  5A73 ~            	JP ENABLE_PAGE0
 78+  5A73 ~            .RET:
 79+  5A73 ~            	EI
 80+  5A73 ~            	; set RAM functions to call
 81+  5A73 ~            	LD HL, .TILECOPY
 82+  5A73 ~            	LD (TILE.CALL2+1), HL
 83+  5A73 ~            	LD HL, .SETDESTROW
 84+  5A73 ~            	LD (TILE.CALL1+1), HL
 85+  5A73 ~            	LD A,1
 86+  5A73 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5A73 ~            	CALL TILE
 88+  5A73 ~            	XOR A
 89+  5A73 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5A73 ~
 91+  5A73 ~                POP DE
 92+  5A73 ~                POP BC
 93+  5A73 ~                CALL RESTORE_PAGE_INFO
 94+  5A73 ~
 95+  5A73 ~            	POP HL
 96+  5A73 ~            	RET
 97+  5A73 ~            .TILECOPY:
 98+  5A73 ~            	.8 LDI
 99+  5A73 ~            	RET
100+  5A73 ~            .SETDESTROW:
101+  5A73 ~            	LD DE, (TILETMP1)
102+  5A73 ~            	RET
103+  5A73 ~            ; *******************************************************************************************************
104+  5A73               ENDIF
105+  5A73
106+  5A73               IFDEF CMDS_WITH_PARAMETERS
107+  5A73              ; *******************************************************************************************************
108+  5A73              ; function to handle CALL TILERAM basic extension
109+  5A73              ; fills memory with tiles
110+  5A73              ; TILERAM ( INT tile_data_pointer,
111+  5A73              ;			INT tile_columns,
112+  5A73              ;			INT tile_rows,
113+  5A73              ;			INT destination_pointer,
114+  5A73              ;			INT destination_columns,
115+  5A73              ;			INT destination_rows,
116+  5A73              ;			INT destination_begin_column,
117+  5A73              ;			INT destination_begin_row,
118+  5A73              ;			INT number_of_tiles_horizontally,
119+  5A73              ;			INT	number_of_tiles_vertically )
120+  5A73              ; will put ram in page 0 also, page 1 is already there
121+  5A73              TILERAM:
122+  5A73              	; opening (
123+  5A73 CD E4 5E     	CALL CHKCHAR
124+  5A76 28           	DB '('
125+  5A77              	; get tile data pointer coordinate
126+  5A77 DD 21 2F 54  	LD IX, FRMQNT
127+  5A7B CD 59 01     	CALL CALBAS
128+  5A7E ED 53 38 5C  	LD (BLIT_STRUCT+0), DE
129+  5A82              	; comma
130+  5A82 CD E4 5E     	CALL CHKCHAR
131+  5A85 2C           	DB ','
132+  5A86              	; get tile columns
133+  5A86 DD 21 2F 54  	LD IX, FRMQNT
134+  5A8A CD 59 01     	CALL CALBAS
135+  5A8D ED 53 3C 5C  	LD (BLIT_STRUCT+4), DE
136+  5A91              	; comma
137+  5A91 CD E4 5E     	CALL CHKCHAR
138+  5A94 2C           	DB ','
139+  5A95              	; get tile columns
140+  5A95 DD 21 2F 54  	LD IX, FRMQNT
141+  5A99 CD 59 01     	CALL CALBAS
142+  5A9C ED 53 3A 5C  	LD (BLIT_STRUCT+2), DE
143+  5AA0              	; comma
144+  5AA0 CD E4 5E     	CALL CHKCHAR
145+  5AA3 2C           	DB ','
146+  5AA4              	; get destintion pointer
147+  5AA4 DD 21 2F 54  	LD IX, FRMQNT
148+  5AA8 CD 59 01     	CALL CALBAS
149+  5AAB ED 53 3E 5C  	LD (BLIT_STRUCT+6), DE
150+  5AAF              	; comma
151+  5AAF CD E4 5E     	CALL CHKCHAR
152+  5AB2 2C           	DB ','
153+  5AB3              	; get destination columns
154+  5AB3 DD 21 2F 54  	LD IX, FRMQNT
155+  5AB7 CD 59 01     	CALL CALBAS
156+  5ABA 7B           	LD A, E
157+  5ABB 32 34 5C     	LD (BLIT_TMP+0), A
158+  5ABE              	; comma
159+  5ABE CD E4 5E     	CALL CHKCHAR
160+  5AC1 2C           	DB ','
161+  5AC2              	; get destination rows
162+  5AC2 DD 21 2F 54  	LD IX, FRMQNT
163+  5AC6 CD 59 01     	CALL CALBAS
164+  5AC9 7B           	LD A, E
165+  5ACA 32 35 5C     	LD (BLIT_TMP+1), A
166+  5ACD              	; comma
167+  5ACD CD E4 5E     	CALL CHKCHAR
168+  5AD0 2C           	DB ','
169+  5AD1              	; get destination begin column
170+  5AD1 DD 21 2F 54  	LD IX, FRMQNT
171+  5AD5 CD 59 01     	CALL CALBAS
172+  5AD8 7B           	LD A, E
173+  5AD9 32 36 5C     	LD (BLIT_TMP+2), A
174+  5ADC              	; comma
175+  5ADC CD E4 5E     	CALL CHKCHAR
176+  5ADF 2C           	DB ','
177+  5AE0              	; get destination begin row
178+  5AE0 DD 21 2F 54  	LD IX, FRMQNT
179+  5AE4 CD 59 01     	CALL CALBAS
180+  5AE7 7B           	LD A, E
181+  5AE8 32 37 5C     	LD (BLIT_TMP+3), A
182+  5AEB              	; comma
183+  5AEB CD E4 5E     	CALL CHKCHAR
184+  5AEE 2C           	DB ','
185+  5AEF              	; get number of tiles horizontally
186+  5AEF DD 21 2F 54  	LD IX, FRMQNT
187+  5AF3 CD 59 01     	CALL CALBAS
188+  5AF6 ED 53 42 5C  	LD (BLIT_STRUCT+10), DE
189+  5AFA              	; comma
190+  5AFA CD E4 5E     	CALL CHKCHAR
191+  5AFD 2C           	DB ','
192+  5AFE              	; get number of tiles vertically
193+  5AFE DD 21 2F 54  	LD IX, FRMQNT
194+  5B02 CD 59 01     	CALL CALBAS
195+  5B05 ED 53 44 5C  	LD (BLIT_STRUCT+12), DE
196+  5B09              	; ending )
197+  5B09 CD E4 5E     	CALL CHKCHAR
198+  5B0C 29           	DB ')'
199+  5B0D
200+  5B0D E5           	PUSH HL ; save position in BASIC buffer
201+  5B0E
202+  5B0E              	; calculate destination add to value
203+  5B0E 26 00        	LD H, 0
204+  5B10 3A 34 5C     	LD A, (BLIT_TMP+0)
205+  5B13 6F           	LD L, A
206+  5B14 CD D3 5D     	CALL HLx8
207+  5B17 22 40 5C     	LD (BLIT_STRUCT+8), HL
208+  5B1A              	; calculate pointer to background location
209+  5B1A 21 00 00     	LD HL, 0
210+  5B1D 3A 37 5C     	LD A,(BLIT_TMP+3)
211+  5B20 B7           	OR A
212+  5B21 28 08        	JR Z, .L1
213+  5B23 47           	LD B,A
214+  5B24 ED 5B 40 5C  	LD DE,(BLIT_STRUCT+8)
215+  5B28              .L0:
216+  5B28 19           	ADD HL, DE
217+  5B29 10 FD        	DJNZ .L0
218+  5B2B              .L1:
219+  5B2B EB           	EX DE,HL
220+  5B2C 26 00        	LD H,0
221+  5B2E 3A 36 5C     	LD A,(BLIT_TMP+2)
222+  5B31 6F           	LD L,A
223+  5B32 CD D3 5D     	CALL HLx8
224+  5B35 19           	ADD HL,DE
225+  5B36 ED 5B 3E 5C  	LD DE,(BLIT_STRUCT+6)
226+  5B3A 19           	ADD HL,DE
227+  5B3B 22 3E 5C     	LD (BLIT_STRUCT+6),HL
228+  5B3E
229+  5B3E FD 21 45 5B  	LD IY, .RET
230+  5B42 C3 97 5E     	JP ENABLE_PAGE0
231+  5B45              .RET:
232+  5B45 FB           	EI
233+  5B46              	; set RAM functions to call
234+  5B46 21 60 5B     	LD HL, .TILECOPY
235+  5B49 22 54 5A     	LD (TILE.CALL2+1), HL
236+  5B4C 21 71 5B     	LD HL, .SETDESTROW
237+  5B4F 22 46 5A     	LD (TILE.CALL1+1), HL
238+  5B52 DD 21 38 5C  	LD IX,BLIT_STRUCT
239+  5B56 CD 2B 5A     	CALL TILE
240+  5B59
241+  5B59 D1               POP DE
242+  5B5A C1               POP BC
243+  5B5B CD 0E 5E         CALL RESTORE_PAGE_INFO
244+  5B5E
245+  5B5E E1           	POP HL
246+  5B5F C9           	RET
247+  5B60              .TILECOPY:
248+  5B60 ED A0       > LDI
248+  5B62 ED A0       > LDI
248+  5B64 ED A0       > LDI
248+  5B66 ED A0       > LDI
248+  5B68 ED A0       > LDI
248+  5B6A ED A0       > LDI
248+  5B6C ED A0       > LDI
248+  5B6E ED A0       > LDI
249+  5B70 C9           	RET
250+  5B71              .SETDESTROW:
251+  5B71 ED 5B 34 5C  	LD DE, (TILETMP1)
252+  5B75 C9           	RET
253+  5B76              ; *******************************************************************************************************
254+  5B76               ENDIF
255+  5B76
256+  5B76               IFDEF CMDS_WITH_PARAMETERS
257+  5B76              ; *******************************************************************************************************
258+  5B76              ; function to handle CALL TILEVRM basic extension
259+  5B76              ; fills vram with tiles
260+  5B76              ; TILEVRM ( INT tile_data_pointer,
261+  5B76              ;			INT tile_columns,
262+  5B76              ;			INT tile_rows,
263+  5B76              ;			INT destination_begin_column,
264+  5B76              ;			INT destination_begin_row,
265+  5B76              ;			INT number_of_tiles_horizontally,
266+  5B76              ;			INT	number_of_tiles_vertically )
267+  5B76              ; will put ram in page 0 also, page 1 is already there
268+  5B76              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5B76              TILEVRM:
270+  5B76              	; opening (
271+  5B76 CD E4 5E     	CALL CHKCHAR
272+  5B79 28           	DB '('
273+  5B7A              	; get tile data pointer coordinate
274+  5B7A DD 21 2F 54  	LD IX, FRMQNT
275+  5B7E CD 59 01     	CALL CALBAS
276+  5B81 ED 53 38 5C  	LD (BLIT_STRUCT+0), DE
277+  5B85              	; comma
278+  5B85 CD E4 5E     	CALL CHKCHAR
279+  5B88 2C           	DB ','
280+  5B89              	; get tile columns
281+  5B89 DD 21 2F 54  	LD IX, FRMQNT
282+  5B8D CD 59 01     	CALL CALBAS
283+  5B90 ED 53 3C 5C  	LD (BLIT_STRUCT+4), DE
284+  5B94              	; comma
285+  5B94 CD E4 5E     	CALL CHKCHAR
286+  5B97 2C           	DB ','
287+  5B98              	; get tile columns
288+  5B98 DD 21 2F 54  	LD IX, FRMQNT
289+  5B9C CD 59 01     	CALL CALBAS
290+  5B9F ED 53 3A 5C  	LD (BLIT_STRUCT+2), DE
291+  5BA3              	; comma
292+  5BA3 CD E4 5E     	CALL CHKCHAR
293+  5BA6 2C           	DB ','
294+  5BA7              	; get destination begin column
295+  5BA7 DD 21 2F 54  	LD IX, FRMQNT
296+  5BAB CD 59 01     	CALL CALBAS
297+  5BAE 7B           	LD A, E
298+  5BAF 32 36 5C     	LD (BLIT_TMP+2), A
299+  5BB2              	; comma
300+  5BB2 CD E4 5E     	CALL CHKCHAR
301+  5BB5 2C           	DB ','
302+  5BB6              	; get destination begin row
303+  5BB6 DD 21 2F 54  	LD IX, FRMQNT
304+  5BBA CD 59 01     	CALL CALBAS
305+  5BBD 7B           	LD A, E
306+  5BBE 32 37 5C     	LD (BLIT_TMP+3), A
307+  5BC1              	; comma
308+  5BC1 CD E4 5E     	CALL CHKCHAR
309+  5BC4 2C           	DB ','
310+  5BC5              	; get number of tiles horizontally
311+  5BC5 DD 21 2F 54  	LD IX, FRMQNT
312+  5BC9 CD 59 01     	CALL CALBAS
313+  5BCC ED 53 42 5C  	LD (BLIT_STRUCT+10), DE
314+  5BD0              	; comma
315+  5BD0 CD E4 5E     	CALL CHKCHAR
316+  5BD3 2C           	DB ','
317+  5BD4              	; get number of tiles vertically
318+  5BD4 DD 21 2F 54  	LD IX, FRMQNT
319+  5BD8 CD 59 01     	CALL CALBAS
320+  5BDB ED 53 44 5C  	LD (BLIT_STRUCT+12), DE
321+  5BDF              	; ending )
322+  5BDF CD E4 5E     	CALL CHKCHAR
323+  5BE2 29           	DB ')'
324+  5BE3
325+  5BE3 E5           	PUSH HL ; save position in BASIC buffer
326+  5BE4
327+  5BE4              	; calculate destination add to value
328+  5BE4 21 00 01     	LD HL, 256
329+  5BE7 22 40 5C     	LD (BLIT_STRUCT+8), HL
330+  5BEA              	; calculate pointer to background location
331+  5BEA 3A 37 5C     	LD A,(BLIT_TMP+3)
332+  5BED 67           	LD H,A
333+  5BEE 2E 00        	LD L,0
334+  5BF0 EB           	EX DE,HL
335+  5BF1 26 00        	LD H,0
336+  5BF3 3A 36 5C     	LD A,(BLIT_TMP+2)
337+  5BF6 6F           	LD L,A
338+  5BF7 CD D3 5D     	CALL HLx8
339+  5BFA 19           	ADD HL,DE
340+  5BFB ED 5B CB F3  	LD DE,(GRPCGP)
341+  5BFF 19           	ADD HL,DE
342+  5C00 22 3E 5C     	LD (BLIT_STRUCT+6),HL
343+  5C03
344+  5C03 FD 21 0A 5C  	LD IY, .RET
345+  5C07 C3 97 5E     	JP ENABLE_PAGE0
346+  5C0A              .RET:
347+  5C0A FB           	EI
348+  5C0B              	; set RAM functions to call
349+  5C0B 21 25 5C     	LD HL, .TILECOPY
350+  5C0E 22 54 5A     	LD (TILE.CALL2+1), HL
351+  5C11 21 2B 5C     	LD HL, .SETDESTROW
352+  5C14 22 46 5A     	LD (TILE.CALL1+1), HL
353+  5C17 DD 21 38 5C  	LD IX,BLIT_STRUCT
354+  5C1B CD 2B 5A     	CALL TILE
355+  5C1E
356+  5C1E D1               POP DE
357+  5C1F C1               POP BC
358+  5C20 CD 0E 5E         CALL RESTORE_PAGE_INFO
359+  5C23
360+  5C23 E1           	POP HL
361+  5C24 C9           	RET
362+  5C25              .TILECOPY:
363+  5C25 01 98 08     	LD BC, #0898
364+  5C28 C3 CB 5D     	JP BBYTECOPY_NO_C
365+  5C2B              .SETDESTROW:
366+  5C2B 2A 34 5C     	LD HL, (TILETMP1)
367+  5C2E F3           	DI
368+  5C2F CD BE 5D     	CALL SETWRT_LOCAL
369+  5C32 FB           	EI
370+  5C33 C9           	RET
371+  5C34              ; *******************************************************************************************************
372+  5C34               ENDIF
373+  5C34
374+  5C34               IFNDEF CMDS_WITH_PARAMETERS
375+  5C34 ~            ; *******************************************************************************************************
376+  5C34 ~            ; function to handle CALL TILEVRM basic extension
377+  5C34 ~            ; fills vram with tiles
378+  5C34 ~            ; TILEVRM ( INT request_data_ptr )
379+  5C34 ~            ; request_data_ptr described in TILE
380+  5C34 ~            ; will put ram in page 0 also, page 1 is already there
381+  5C34 ~            TILEVRM:
382+  5C34 ~            	; opening (
383+  5C34 ~            	CALL CHKCHAR
384+  5C34 ~            	DB '('
385+  5C34 ~            	; get pointer to request struct
386+  5C34 ~            	LD IX, FRMQNT
387+  5C34 ~            	CALL CALBAS
388+  5C34 ~            	PUSH DE
389+  5C34 ~            	; ending )
390+  5C34 ~            	CALL CHKCHAR
391+  5C34 ~            	DB ')'
392+  5C34 ~
393+  5C34 ~            	POP IX ; pointer to request struct
394+  5C34 ~
395+  5C34 ~            	PUSH HL ; save position in BASIC buffer
396+  5C34 ~
397+  5C34 ~            	LD IY, .RET
398+  5C34 ~            	JP ENABLE_PAGE0
399+  5C34 ~            .RET:
400+  5C34 ~            	EI
401+  5C34 ~            	; set RAM functions to call
402+  5C34 ~            	LD HL, .TILECOPY
403+  5C34 ~            	LD (TILE.CALL2+1), HL
404+  5C34 ~            	LD HL, .SETDESTROW
405+  5C34 ~            	LD (TILE.CALL1+1), HL
406+  5C34 ~            	CALL TILE
407+  5C34 ~
408+  5C34 ~                POP DE
409+  5C34 ~                POP BC
410+  5C34 ~                CALL RESTORE_PAGE_INFO
411+  5C34 ~
412+  5C34 ~            	POP HL
413+  5C34 ~            	RET
414+  5C34 ~            .TILECOPY:
415+  5C34 ~            	LD BC, #0898
416+  5C34 ~            	JP BBYTECOPY_NO_C
417+  5C34 ~            .SETDESTROW:
418+  5C34 ~            	LD HL, (TILETMP1)
419+  5C34 ~            	DI
420+  5C34 ~            	CALL SETWRT_LOCAL
421+  5C34 ~            	EI
422+  5C34 ~            	RET
423+  5C34 ~            ; *******************************************************************************************************
424+  5C34               ENDIF
# file closed: asm\TILE.asm
148   5C34               ENDIF
149   5C34
150   5C34              ; temp variables for BLIT, TILE functions
151   5C34               IF (BLIT_CMDS + TILE_CMDS > 0)
152   5C34              BLIT_TMP:
153   5C34              TILETMP1:
154   5C34              BLIT_TMP1:
155   5C34 00 00         DW 0
156   5C36              TILETMP2:
157   5C36              BLIT_TMP2:
158   5C36 00 00         DW 0
159   5C38                IFDEF CMDS_WITH_PARAMETERS
160   5C38              BLIT_STRUCT:
161   5C38 00 00 00...   DS 17
162   5C3C                ENDIF
163   5C3C               ENDIF
164   5C49
165   5C49               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS > 0)
166   5C49              VRAM_UPDATE_IN_PROGRESS:
167   5C49 00            DB 0
168   5C4A               ENDIF
169   5C4A
170   5C4A              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
171   5C4A              ; per starting letter, if no commands with this letter, NULL value
172   5C4A              CMDS:
173   5C4A               IF (ANIM_CMDS == 1)
174   5C4A 73 5D        	DW CMDS_A ;
175   5C4C               ELSE
176   5C4C ~                DW 0 ; A
177   5C4C               ENDIF
178   5C4C               IF (BLIT_CMDS + BOX_CMDS > 0)
179   5C4C 3E 5D            DW CMDS_B ; B
180   5C4E               ELSE
181   5C4E ~            	DW 0
182   5C4E               ENDIF
183   5C4E 00 00            DW 0 ; C
184   5C50 00 00            DW 0 ; D
185   5C52 00 00            DW 0 ; E
186   5C54               IF (VRAM_CMDS + RAM_CMDS > 0)
187   5C54 BC 5C            DW CMDS_F; F
188   5C56               ELSE
189   5C56 ~            	DW 0
190   5C56               ENDIF
191   5C56               IF (GENCAL_CMD > 0)
192   5C56 CF 5C            DW CMDS_G; G
193   5C58               ELSE
194   5C58 ~            	DW 0
195   5C58               ENDIF
196   5C58 00 00            DW 0 ; H
197   5C5A 00 00            DW 0 ; I
198   5C5C 00 00            DW 0 ; J
199   5C5E 00 00            DW 0 ; K
200   5C60 00 00            DW 0 ; L
201   5C62               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
202   5C62 7E 5C            DW CMDS_M ; M
203   5C64               ELSE
204   5C64 ~            	DW 0
205   5C64               ENDIF
206   5C64 00 00            DW 0 ; N
207   5C66 00 00            DW 0 ; O
208   5C68 00 00            DW 0 ; P
209   5C6A 00 00            DW 0 ; Q
210   5C6C 00 00            DW 0 ; R
211   5C6E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
212   5C6E E3 5C            DW CMDS_S ; S
213   5C70               ELSE
214   5C70 ~            	DW 0
215   5C70               ENDIF
216   5C70               IF (TILE_CMDS > 0)
217   5C70 5E 5D            DW CMDS_T ; T
218   5C72               ELSE
219   5C72 ~            	DW 0
220   5C72               ENDIF
221   5C72 00 00            DW 0 ; U
222   5C74               IF (VRAM_CMDS > 0)
223   5C74 D9 5C            DW CMDS_V ; V
224   5C76               ELSE
225   5C76 ~            	DW 0
226   5C76               ENDIF
227   5C76 00 00            DW 0 ; W
228   5C78 00 00            DW 0 ; X
229   5C7A 00 00            DW 0 ; Y
230   5C7C 00 00            DW 0 ; Z
231   5C7E
232   5C7E              CMDS_M:
233   5C7E               IF (VRAM_CMDS == 1)
234   5C7E 4D 45 4D 56      DB "MEMVRM", 0
234   5C82 52 4D 00
235   5C85 BF 55            DW MEMVRM
236   5C87               ENDIF
237   5C87               IF (RAM_CMDS == 1)
238   5C87 4D 45 4D 43  	DB "MEMCPY", 0
238   5C8B 50 59 00
239   5C8E F5 53        	DW MEMCPY
240   5C90               ENDIF
241   5C90               IF (ANIM_CMDS == 1)
242   5C90 4D 41 58 41  	DB "MAXANIMITEMS",0
242   5C94 4E 49 4D 49
242   5C98 54 45 4D 53
242   5C9C 00
243   5C9D EA 4F        	DW MAXANIMITEMS
244   5C9F 4D 41 58 41  	DB "MAXANIMDEFS",0
244   5CA3 4E 49 4D 44
244   5CA7 45 46 53 00
245   5CAB 5F 51        	DW MAXANIMDEFS
246   5CAD 4D 41 58 41  	DB "MAXANIMSPRS",0
246   5CB1 4E 49 4D 53
246   5CB5 50 52 53 00
247   5CB9 F4 51        	DW MAXANIMSPRS
248   5CBB               ENDIF
249   5CBB               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
250   5CBB 00           	DB 0
251   5CBC               ENDIF
252   5CBC              CMDS_F:
253   5CBC               IF (VRAM_CMDS == 1)
254   5CBC 46 49 4C 56      DB "FILVRM", 0
254   5CC0 52 4D 00
255   5CC3 6F 55            DW FILVRM
256   5CC5               ENDIF
257   5CC5               IF (RAM_CMDS == 1)
258   5CC5 46 49 4C 52      DB "FILRAM", 0
258   5CC9 41 4D 00
259   5CCC 38 54            DW FILRAM
260   5CCE               ENDIF
261   5CCE               IF (VRAM_CMDS + RAM_CMDS > 0)
262   5CCE 00               DB 0
263   5CCF               ENDIF
264   5CCF              CMDS_G:
265   5CCF               IF (GENCAL_CMD == 1)
266   5CCF 47 45 4E 43      DB "GENCAL", 0
266   5CD3 41 4C 00
267   5CD6 A3 56            DW GENCAL
268   5CD8               ENDIF
269   5CD8               IF (GENCAL_CMD > 0)
270   5CD8 00           	DB	0
271   5CD9               ENDIF
272   5CD9              CMDS_V:
273   5CD9               IF (VRAM_CMDS == 1)
274   5CD9 56 52 4D 4D  	DB "VRMMEM", 0
274   5CDD 45 4D 00
275   5CE0 3E 56        	DW VRMMEM
276   5CE2               ENDIF
277   5CE2               IF (VRAM_CMDS > 0)
278   5CE2 00           	DB 0
279   5CE3               ENDIF
280   5CE3              CMDS_S:
281   5CE3               IF (SPRITE_CMDS == 1)
282   5CE3 53 50 52 53  	DB "SPRSET", 0
282   5CE7 45 54 00
283   5CEA 81 4E        	DW SPRSET
284   5CEC 53 50 52 47  	DB "SPRGRPMOV", 0
284   5CF0 52 50 4D 4F
284   5CF4 56 00
285   5CF6 32 4F        	DW SPRGRPMOV
286   5CF8               ENDIF
287   5CF8               IF (SOUND_CMDS == 1)
288   5CF8 53 4E 44 53  	DB "SNDSFX", 0
288   5CFC 46 58 00
289   5CFF 15 55        	DW SNDSFX
290   5D01 53 4E 44 50  	DB "SNDPLYON", 0
290   5D05 4C 59 4F 4E
290   5D09 00
291   5D0A DF 54        	DW SNDPLYON
292   5D0C 53 4E 44 50  	DB "SNDPLYOFF", 0
292   5D10 4C 59 4F 46
292   5D14 46 00
293   5D16 F2 54        	DW SNDPLYOFF
294   5D18 53 4E 44 50  	DB "SNDPLYINI", 0
294   5D1C 4C 59 49 4E
294   5D20 49 00
295   5D22 95 54        	DW SNDPLYINIT
296   5D24               ENDIF
297   5D24               IF (SPRITE_CMDS == 1)
298   5D24 53 50 52 45  	DB "SPRENABLE", 0
298   5D28 4E 41 42 4C
298   5D2C 45 00
299   5D2E 3C 4E        	DW SPRENABLE
300   5D30 53 50 52 44  	DB "SPRDISABLE", 0
300   5D34 49 53 41 42
300   5D38 4C 45 00
301   5D3B 7C 4E        	DW SPRDISABLE
302   5D3D               ENDIF
303   5D3D               IF (SOUND_CMDS + SPRITE_CMDS > 0)
304   5D3D 00           	DB 0
305   5D3E               ENDIF
306   5D3E              CMDS_B:
307   5D3E               IF (BLIT_CMDS == 1)
308   5D3E 42 4C 49 54  	DB "BLIT", 0
308   5D42 00
309   5D43 2F 59        	DW BLIT
310   5D45               ENDIF
311   5D45               IF (BOX_CMDS == 1)
312   5D45 42 4F 58 4D  	DB "BOXMEMCPY", 0
312   5D49 45 4D 43 50
312   5D4D 59 00
313   5D4F 32 57        	DW BOXMEMCPY
314   5D51 42 4F 58 4D  	DB "BOXMEMVRM", 0
314   5D55 45 4D 56 52
314   5D59 4D 00
315   5D5B 66 57        	DW BOXMEMVRM
316   5D5D               ENDIF
317   5D5D               IF (BLIT_CMDS + BOX_CMDS > 0)
318   5D5D 00           	DB 0
319   5D5E               ENDIF
320   5D5E              CMDS_T:
321   5D5E               IF (TILE_CMDS == 1)
322   5D5E 54 49 4C 45  	DB "TILERAM", 0
322   5D62 52 41 4D 00
323   5D66 73 5A        	DW TILERAM
324   5D68 54 49 4C 45  	DB "TILEVRM", 0
324   5D6C 56 52 4D 00
325   5D70 76 5B        	DW TILEVRM
326   5D72               ENDIF
327   5D72               IF (TILE_CMDS > 0)
328   5D72 00           	DB 0
329   5D73               ENDIF
330   5D73              CMDS_A:
331   5D73               IF (ANIM_CMDS == 1)
332   5D73 41 4E 49 4D  	DB "ANIMSTART",0
332   5D77 53 54 41 52
332   5D7B 54 00
333   5D7D B2 52        	DW ANIMSTART
334   5D7F 41 4E 49 4D  	DB "ANIMSTOP",0
334   5D83 53 54 4F 50
334   5D87 00
335   5D88 B6 52        	DW ANIMSTOP
336   5D8A 41 4E 49 4D  	DB "ANIMITEMPAT",0
336   5D8E 49 54 45 4D
336   5D92 50 41 54 00
337   5D96 AA 50        	DW ANIMITEMPAT
338   5D98 41 4E 49 4D  	DB "ANIMITEMPTR",0
338   5D9C 49 54 45 4D
338   5DA0 50 54 52 00
339   5DA4 0B 51        	DW ANIMITEMPTR_CMD
340   5DA6 41 4E 49 4D  	DB "ANIMDEF",0
340   5DAA 44 45 46 00
341   5DAE A1 51        	DW ANIMDEF
342   5DB0 41 4E 49 4D  	DB "ANIMSPRITE",0
342   5DB4 53 50 52 49
342   5DB8 54 45 00
343   5DBB 4A 52        	DW ANIMSPRITE
344   5DBD 00           	DB 0
345   5DBE               ENDIF
346   5DBE
347   5DBE               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
348   5DBE              ; ****************************************************************************************************
349   5DBE              ; function sets VRAM address
350   5DBE              ; input HL=address
351   5DBE              ; modifies AF
352   5DBE              SETWRT_LOCAL:
353   5DBE 7D           	LD	A, L
354   5DBF D3 99        	OUT	(099H), A
355   5DC1 7C           	LD	A, H
356   5DC2 E6 3F        	AND	03FH
357   5DC4 F6 40        	OR	040H
358   5DC6 D3 99        	OUT	(099H), A
359   5DC8 C9           	RET
360   5DC9              ; ****************************************************************************************************
361   5DC9               ENDIF
362   5DC9
363   5DC9               IF (VRAM_CMDS + TILE_CMDS > 0)
364   5DC9              ; ****************************************************************************************************
365   5DC9              ; function copies data from RAM to VRAM
366   5DC9              ; input HL=address in RAM
367   5DC9              ; input B=count
368   5DC9              ; modifies AF, BC, HL
369   5DC9              BBYTECOPY:
370   5DC9 0E 98        	LD C,#98
371   5DCB              BBYTECOPY_NO_C:
372   5DCB ED A3        	OUTI
373   5DCD C2 CB 5D     	JP	NZ, BBYTECOPY_NO_C
374   5DD0 C9           	RET
375   5DD1              ; ****************************************************************************************************
376   5DD1               ENDIF
377   5DD1
378   5DD1              ; ****************************************************************************************************
379   5DD1              ; function multiplies HL by 32
380   5DD1              HLx32:
381   5DD1 29           	ADD HL,HL
382   5DD2              ; ****************************************************************************************************
383   5DD2              ; function multiplies HL by 16
384   5DD2              HLx16:
385   5DD2 29           	ADD HL,HL
386   5DD3              ; ****************************************************************************************************
387   5DD3              ; function multiplies HL by 8
388   5DD3              HLx8:
389   5DD3 29          > ADD HL, HL
389   5DD4 29          > ADD HL, HL
389   5DD5 29          > ADD HL, HL
390   5DD6 C9           	RET
391   5DD7              ; ****************************************************************************************************
392   5DD7
393   5DD7              ; ****************************************************************************************************
394   5DD7              ; function gets slot and subslot data for specific page
395   5DD7              ; input A=page (0, 1 or 2)
396   5DD7              ; output B = 0A8H register value
397   5DD7              ; output D = 0 is no subslots, 1 if yes
398   5DD7              ; output C = 0A8H value when page 3 slot equals to requested page slot
399   5DD7              ; output E = subslot value if present
400   5DD7              ; modifies AF, BC, DE, HL
401   5DD7              GET_PAGE_INFO:
402   5DD7 6F               LD L, A
403   5DD8 C6 C1            ADD A, low (EXPTBL)
404   5DDA 32 E4 5D         LD (GET_PAGE_INFO_L1+1), A
405   5DDD DB A8            IN A, (0A8H)
406   5DDF 47               LD B, A
407   5DE0 E6 3F            AND 03FH
408   5DE2 4F               LD C, A
409   5DE3              GET_PAGE_INFO_L1:
410   5DE3 3A C1 FC         LD A, (EXPTBL) ; modified by code above
411   5DE6 E6 80            AND 080H
412   5DE8 28 1B            JR Z, GET_PAGE_INFO_L2
413   5DEA                  ; expanded
414   5DEA 2D               DEC L
415   5DEB FA 0A 5E         JP M, GET_PAGE_INFO_L3
416   5DEE 2D               DEC L
417   5DEF FA 08 5E         JP M, GET_PAGE_INFO_L4
418   5DF2                  ; page 2
419   5DF2 07               RLCA
420   5DF3 07               RLCA
421   5DF4              GET_PAGE_INFO_L5:
422   5DF4 E6 C0            AND 0C0H
423   5DF6 B1               OR C
424   5DF7 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
425   5DF9 4F               LD C, A
426   5DFA 3A FF FF         LD A, (0FFFFH)
427   5DFD 2F               CPL
428   5DFE 5F               LD E, A
429   5DFF 16 01            LD D, 1
430   5E01 78               LD A, B ; return stack
431   5E02 D3 A8            OUT (0A8H), A
432   5E04 C9               RET
433   5E05              GET_PAGE_INFO_L2:
434   5E05                  ; not expanded
435   5E05 16 00            LD D, 0
436   5E07 C9               RET
437   5E08              GET_PAGE_INFO_L4:
438   5E08                  ; page 1
439   5E08 0F               RRCA
440   5E09 0F               RRCA
441   5E0A              GET_PAGE_INFO_L3:
442   5E0A                  ; page 0
443   5E0A 0F               RRCA
444   5E0B 0F               RRCA
445   5E0C 18 E6            JR GET_PAGE_INFO_L5
446   5E0E              ; ****************************************************************************************************
447   5E0E
448   5E0E              ; ****************************************************************************************************
449   5E0E              ; function returns original slot and subslot info
450   5E0E              ; input B = 0A8H register value
451   5E0E              ; input D = 0 is no subslots, 1 if yes
452   5E0E              ; input C = 0A8H value when page 3 slot equals to requested page slot
453   5E0E              ; input E = subslot value if present
454   5E0E              ; modifies AF, disables interrupts
455   5E0E              RESTORE_PAGE_INFO:
456   5E0E 7A               LD A, D
457   5E0F B7               OR A
458   5E10 28 08            JR Z, RESTORE_PAGE_INFO_L1
459   5E12 79               LD A, C
460   5E13 F3           	DI
461   5E14 D3 A8            OUT (0A8H), A
462   5E16 7B               LD A, E
463   5E17 32 FF FF         LD (0FFFFH), A
464   5E1A              RESTORE_PAGE_INFO_L1:
465   5E1A 78               LD A, B
466   5E1B D3 A8            OUT (0A8H), A
467   5E1D C9               RET
468   5E1E              ; ****************************************************************************************************
469   5E1E
470   5E1E              ; *******************************************************************************************************
471   5E1E              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
472   5E1E              ; INPUT:  A = SLOT ID: EXXXSSPP
473   5E1E              ; E = EXPANDED FLAG
474   5E1E              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
475   5E1E              ; PP = PRIMARY SLOT NUMBER
476   5E1E              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
477   5E1E              ; CHANGES: AF, BC, DE
478   5E1E
479   5E1E              LOCAL_ENASLT:
480   5E1E CD 3E 5E         CALL L0353
481   5E21 FA 2B 5E         JP M, L0340
482   5E24 DB A8            IN A, (0A8H)
483   5E26 A1               AND C
484   5E27 B0               OR B
485   5E28 D3 A8            OUT (0A8H), A
486   5E2A C9               RET
487   5E2B              L0340:
488   5E2B E5               PUSH HL
489   5E2C CD 63 5E         CALL L0378
490   5E2F 4F               LD C, A
491   5E30 06 00            LD B, 0
492   5E32 7D               LD A, L
493   5E33 A4               AND H
494   5E34 B2               OR D
495   5E35 21 C5 FC         LD HL, 0FCC5H
496   5E38 09               ADD HL, BC
497   5E39 77               LD (HL), A
498   5E3A E1               POP HL
499   5E3B 79               LD A, C
500   5E3C 18 E0            JR LOCAL_ENASLT
501   5E3E              L0353:
502   5E3E F3               DI
503   5E3F F5               PUSH AF
504   5E40 7C               LD A, H
505   5E41 07               RLCA
506   5E42 07               RLCA
507   5E43 E6 03            AND 3
508   5E45 5F               LD E, A
509   5E46 3E C0            LD A, 0C0H
510   5E48              L035D:
511   5E48 07               RLCA
512   5E49 07               RLCA
513   5E4A 1D               DEC E
514   5E4B F2 48 5E         JP P, L035D
515   5E4E 5F               LD E, A
516   5E4F 2F               CPL
517   5E50 4F               LD C, A
518   5E51 F1               POP AF
519   5E52 F5               PUSH AF
520   5E53 E6 03            AND 3
521   5E55 3C               INC A
522   5E56 47               LD B, A
523   5E57 3E AB            LD A, 0ABH
524   5E59              L036E:
525   5E59 C6 55            ADD A, 055H
526   5E5B 10 FC            DJNZ L036E
527   5E5D 57               LD D, A
528   5E5E A3               AND E
529   5E5F 47               LD B, A
530   5E60 F1               POP AF
531   5E61 A7               AND A
532   5E62 C9               RET
533   5E63              L0378:
534   5E63 F5               PUSH AF
535   5E64 7A               LD A, D
536   5E65 E6 C0            AND 0C0H
537   5E67 4F               LD C, A
538   5E68 F1               POP AF
539   5E69 F5               PUSH AF
540   5E6A 57               LD D, A
541   5E6B DB A8            IN A, (0A8H)
542   5E6D 47               LD B, A
543   5E6E E6 3F            AND 03FH
544   5E70 B1               OR C
545   5E71 D3 A8            OUT (0A8H), A
546   5E73 7A               LD A, D
547   5E74 0F               RRCA
548   5E75 0F               RRCA
549   5E76 E6 03            AND 3
550   5E78 57               LD D, A
551   5E79 3E AB            LD A, 0ABH
552   5E7B              L0390:
553   5E7B C6 55            ADD A, 055H
554   5E7D 15               DEC D
555   5E7E F2 7B 5E         JP P, L0390
556   5E81 A3               AND E
557   5E82 57               LD D, A
558   5E83 7B               LD A, E
559   5E84 2F               CPL
560   5E85 67               LD H, A
561   5E86 3A FF FF         LD A, (0FFFFH)
562   5E89 2F               CPL
563   5E8A 6F               LD L, A
564   5E8B A4               AND H
565   5E8C B2               OR D
566   5E8D 32 FF FF         LD (0FFFFH), A
567   5E90 78               LD A, B
568   5E91 D3 A8            OUT (0A8H), A
569   5E93 F1               POP AF
570   5E94 E6 03            AND 3
571   5E96 C9               RET
572   5E97              ; *******************************************************************************************************
573   5E97
574   5E97              ; *******************************************************************************************************
575   5E97              ; some common code to activate page 0 and place values needed to restore original page on stack
576   5E97              ; input IY=return address
577   5E97              ENABLE_PAGE0:
578   5E97 AF               XOR A
579   5E98 CD D7 5D         CALL GET_PAGE_INFO
580   5E9B C5               PUSH BC
581   5E9C D5               PUSH DE
582   5E9D 3A 41 F3         LD A, (RAMAD0)
583   5EA0 26 00            LD H, 0
584   5EA2 CD 1E 5E         CALL LOCAL_ENASLT
585   5EA5 FD E9        	JP (IY)
586   5EA7              ; *******************************************************************************************************
587   5EA7
588   5EA7              ; General BASIC CALL-instruction handler
589   5EA7              CALLHAND:
590   5EA7 E5           	PUSH HL
591   5EA8 21 4A 5C     	LD	HL, CMDS ; pointer table based on starting letter
592   5EAB 3A 89 FD         LD A, (PROCNM)
593   5EAE D6 41            SUB 'A'
594   5EB0 87               ADD A, A
595   5EB1 16 00            LD D, 0
596   5EB3 5F               LD E, A
597   5EB4 19               ADD HL, DE
598   5EB5 5E               LD E, (HL)
599   5EB6 23               INC HL
600   5EB7 56               LD D, (HL)
601   5EB8 7A               LD A, D
602   5EB9 B3               OR E
603   5EBA 28 23            JR Z, .CMDNOTRECOGNIZED
604   5EBC EB               EX DE, HL
605   5EBD              .CHKCMD:
606   5EBD 11 89 FD     	LD	DE, PROCNM
607   5EC0 1A           .LOOP:	LD	A,(DE)
608   5EC1 BE           	CP	(HL)
609   5EC2 20 11        	JR	NZ,.TONEXTCMD	; Not equal
610   5EC4 13           	INC	DE
611   5EC5 23           	INC	HL
612   5EC6 A7           	AND	A
613   5EC7 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
614   5EC9 5E           	LD	E,(HL)
615   5ECA 23           	INC	HL
616   5ECB 56           	LD	D,(HL)
617   5ECC E1           	POP	HL		; routine address
618   5ECD CD EE 5E     	CALL	GETPREVCHAR
619   5ED0 CD E2 5E     	CALL	.CALLDE		; Call routine
620   5ED3 A7           	AND	A
621   5ED4 C9           	RET
622   5ED5
623   5ED5              .TONEXTCMD:
624   5ED5 0E FF        	LD	C,0FFH
625   5ED7 AF           	XOR	A
626   5ED8 ED B1        	CPIR			; Skip to end of instruction name
627   5EDA 23           	INC	HL
628   5EDB 23           	INC	HL		; Skip address
629   5EDC BE           	CP	(HL)
630   5EDD 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
631   5EDF              .CMDNOTRECOGNIZED:
632   5EDF E1           	POP	HL
633   5EE0 37               SCF
634   5EE1 C9           	RET
635   5EE2
636   5EE2              .CALLDE:
637   5EE2 D5           	PUSH	DE
638   5EE3 C9           	RET
639   5EE4
640   5EE4              ;---------------------------
641   5EE4
642   5EE4              ;GETSTRPNT:
643   5EE4              ; OUT:
644   5EE4              ; HL = String Address
645   5EE4              ; B  = Lenght
646   5EE4              ;        LD      HL,(USR)
647   5EE4              ;        LD      B,(HL)
648   5EE4              ;        INC     HL
649   5EE4              ;        LD      E,(HL)
650   5EE4              ;        INC     HL
651   5EE4              ;        LD      D,(HL)
652   5EE4              ;        EX      DE,HL
653   5EE4              ;        RET
654   5EE4
655   5EE4              ;EVALTXTPARAM:
656   5EE4              ;	CALL	CHKCHAR
657   5EE4              ;	DEFB	"("             ; Check for (
658   5EE4              ;	LD	IX,FRMEVL
659   5EE4              ;	CALL	CALBAS		; Evaluate expression
660   5EE4              ;       LD      A,(VALTYP)
661   5EE4              ;        CP      3               ; Text type?
662   5EE4              ;        JP      NZ,TYPE_MISMATCH
663   5EE4              ;        PUSH	HL
664   5EE4              ;        LD	IX,FRESTR         ; Free the temporary string
665   5EE4              ;        CALL	CALBAS
666   5EE4              ;        POP	HL
667   5EE4              ;	CALL	CHKCHAR
668   5EE4              ;	DEFB	")"             ; Check for )
669   5EE4              ;        RET
670   5EE4
671   5EE4
672   5EE4              CHKCHAR:
673   5EE4 CD EE 5E     	CALL	GETPREVCHAR	; Get previous basic char
674   5EE7 E3           	EX	(SP),HL
675   5EE8 BE           	CP	(HL) 	        ; Check if good char
676   5EE9 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
677   5EEB 23           	INC	HL
678   5EEC E3           	EX	(SP),HL
679   5EED 23           	INC	HL		; Get next basic char
680   5EEE
681   5EEE              GETPREVCHAR:
682   5EEE 2B           	DEC	HL
683   5EEF DD 21 66 46  	LD	IX,CHRGTR
684   5EF3 C3 59 01     	JP      CALBAS
685   5EF6
686   5EF6
687   5EF6              TYPE_MISMATCH:
688   5EF6 1E 0D            LD E, 13 ; Type mismatch
689   5EF8 18 0A            JR THROW_ERROR
690   5EFA              SUBSCRIPT_OUT_OF_RANGE:
691   5EFA 1E 09            LD E,9 ; subscript out of range
692   5EFC 18 06        	JR THROW_ERROR
693   5EFE              OVERFLOW:
694   5EFE 1E 06        	LD E,6
695   5F00 18 02        	JR THROW_ERROR
696   5F02              SYNTAX_ERROR:
697   5F02 1E 02            LD E, 2 ; Syntax error
698   5F04              THROW_ERROR:
699   5F04 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
700   5F08 C3 59 01     	JP	CALBAS
701   5F0B
702   5F0B              ;---------------------------
703   5F0B
704   5F0B              ; *******************************************************************************************************
705   5F0B              ; helper function to get pointer to BASIC array data
706   5F0B              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
707   5F0B              ; input B=dimensions (1 or 2)
708   5F0B              ; input D=minimal first dimension
709   5F0B              ; input E=minimal second dimension, if applicable
710   5F0B              ; returns BC=pointer to first data element
711   5F0B              ; throws BASIC error if invalid type
712   5F0B              GET_BASIC_ARRAY_DATA_POINTER:
713   5F0B D5           	PUSH DE
714   5F0C C5           	PUSH BC
715   5F0D F5           	PUSH AF
716   5F0E 3E 01            LD A,1
717   5F10 32 A5 F6         LD (SUBFLG),A ; search for arrays only
718   5F13 DD 21 A4 5E  	LD IX, PTRGET
719   5F17 CD 59 01     	CALL CALBAS
720   5F1A AF               XOR A
721   5F1B 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
722   5F1E 3A 63 F6     	LD A,(VALTYP)
723   5F21 D1           	POP DE ; required type
724   5F22 BA           	CP D
725   5F23 C2 F6 5E     	JP NZ,TYPE_MISMATCH
726   5F26 0A           	LD A,(BC)
727   5F27 03           	INC BC
728   5F28 D1           	POP DE ; required number of dimensions
729   5F29 BA           	CP D
730   5F2A C2 F6 5E     	JP NZ,TYPE_MISMATCH
731   5F2D D1           	POP DE ; required minimal array dimensions
732   5F2E 3D           	DEC A
733   5F2F 28 07        	JR Z,.ONE_DIMENSION
734   5F31              	; 2-dimension array
735   5F31 0A           	LD A,(BC)
736   5F32 03          > INC BC
736   5F33 03          > INC BC
737   5F34 BB           	CP E
738   5F35 DA FA 5E     	JP C,SUBSCRIPT_OUT_OF_RANGE
739   5F38              .ONE_DIMENSION:
740   5F38 0A           	LD A,(BC)
741   5F39 03          > INC BC
741   5F3A 03          > INC BC
742   5F3B BA           	CP D
743   5F3C DA FA 5E     	JP C,SUBSCRIPT_OUT_OF_RANGE
744   5F3F C9           	RET
745   5F40              ; *******************************************************************************************************
746   5F40
747   5F40              EXT_END:
748   5F40
# file closed: asm\main.asm
