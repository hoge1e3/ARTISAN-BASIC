# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000
  51  4000              ; BASIC error codes
  52  4000              ;01 NEXT without FOR
  53  4000              ;02 Syntax error
  54  4000              ;03 RETURN without GOSUB
  55  4000              ;04 Out of DATA
  56  4000              ;05 Illegal function call
  57  4000              ;06 Overflow
  58  4000              ;07 Out of memory
  59  4000              ;08 Undefined line number
  60  4000              ;09 Subscript out of range
  61  4000              ;10 Redimensioned array
  62  4000              ;11 Division by zero
  63  4000              ;12 Illegal direct
  64  4000              ;13 Type mismatch
  65  4000              ;14 Out of string space
  66  4000              ;15 String too long
  67  4000              ;16 String formula too complex
  68  4000              ;17 Can't CONTINUE
  69  4000              ;18 Undefined user function
  70  4000              ;19 Device I/O error
  71  4000              ;20 Verify error
  72  4000              ;21 No RESUME
  73  4000              ;22 RESUME without error
  74  4000              ;23 Unprintable error
  75  4000              ;24 Missing operand
  76  4000              ;25 Line buffer overflow
  77  4000              ;50 FIELD overflow
  78  4000              ;51 Internal error
  79  4000              ;52 Bad file number
  80  4000              ;53 File not found
  81  4000              ;54 File already open
  82  4000              ;55 Input past end
  83  4000              ;56 Bad file name
  84  4000              ;57 Direct statement in file
  85  4000              ;58 Sequential I/O only
  86  4000              ;59 File not OPEN
  87  4000
  88  4000
  89  4000               ; simulate cartridge with BASIC extension
  90  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  90  4004 DC 53 00 00
  90  4008 00 00 00 00
  90  400C 00 00 00 00
  91  4010
  92  4010              ; this location #4010 stores last location used by basic extension
  93  4010              ; free memory after that point
  94  4010              FREEMEMPTR:
  95  4010 C1 5C         DW EXT_END
  96  4012
  97  4012              ; this location #4012 stores extension version in DAA format
  98  4012              ; first byte is major version and second minor
  99  4012              VERSION:
 100  4012 00 70         DB #00, #70
 101  4014
 102  4014              ; binary included AKG player compiled at #4014
 103  4014               IF (SOUND_CMDS == 1)
 104  4014              	INCBIN "bin/AKG.bin"
 105  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 106  4CF0               ENDIF
 107  4CF0
 108  4CF0              ORIG.HTIMI:
 109  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 109  4CF4 00
 110  4CF5               EXPORT ORIG.HTIMI
 111  4CF5
 112  4CF5               IF (SOUND_CMDS == 1)
 113  4CF5              MUSIC_INIT_STATUS:
 114  4CF5 00            DB 0
 115  4CF6              SFX_INIT_STATUS:
 116  4CF6 00            DB 0
 117  4CF7              SOUND_ENABLED:
 118  4CF7 00            DB 0
 119  4CF8               ENDIF
 120  4CF8
 121  4CF8               IF (SPRITE_CMDS == 1)
 122  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD F6 52     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 19 54     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 19 54     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 19 54     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 19 54     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 39 54     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 39 54     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 39 54     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 19 54     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 19 54     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 19 54     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 19 54     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 19 54     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 19 54     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 39 54     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 39 54     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 19 54     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 19 54     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 19 54     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 19 54     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 19 54     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 0C 53         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD 53 53         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD 43 53         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 123  4F4D               ENDIF
 124  4F4D
 125  4F4D               IF (ANIM_CMDS == 1)
 126  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E C1 5C         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 C1 5C         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 C1 5C         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; ANIMATION DEFINITION
  31+ 4F56              ; byte number of items 1-15
  32+ 4F56              ; byte[15] anim_item;
  33+ 4F56
  34+ 4F56              ; *******************************************************************************************************
  35+ 4F56              ; helper function HL=A*5
  36+ 4F56              ; changes HL,DE;
  37+ 4F56              Ax5:
  38+ 4F56 26 00            LD H,0
  39+ 4F58 6F               LD L,A
  40+ 4F59 54               LD D,H
  41+ 4F5A 5D               LD E,L
  42+ 4F5B 29               ADD HL,HL
  43+ 4F5C 29               ADD HL,HL
  44+ 4F5D 19               ADD HL,DE
  45+ 4F5E C9               RET
  46+ 4F5F              ; *******************************************************************************************************
  47+ 4F5F
  48+ 4F5F              ; *******************************************************************************************************
  49+ 4F5F              ; function to handle CALL MAXANIMITEMS basic extension
  50+ 4F5F              ; MAXANIMITEMS (BYTE number)
  51+ 4F5F              ; sets new number and moves memory buffers as needed
  52+ 4F5F              MAXANIMITEMS:
  53+ 4F5F              	; opening (
  54+ 4F5F CD 19 54     	CALL CHKCHAR
  55+ 4F62 28           	DB '('
  56+ 4F63              	; get value
  57+ 4F63 DD 21 1C 52  	LD IX, GETBYT
  58+ 4F67 CD 59 01     	CALL CALBAS
  59+ 4F6A F5               PUSH AF
  60+ 4F6B              	; ending )
  61+ 4F6B CD 19 54     	CALL CHKCHAR
  62+ 4F6E 29           	DB ')'
  63+ 4F6F F1               POP AF
  64+ 4F70
  65+ 4F70              	; save position
  66+ 4F70 E5           	PUSH HL
  67+ 4F71              .ENTRY:
  68+ 4F71 47               LD B,A
  69+ 4F72 3A 4D 4F         LD A,(ANIMITEMNUM)
  70+ 4F75 90               SUB B
  71+ 4F76 28 23            JR Z, .EXIT; same value as before
  72+ 4F78 DD 21 4E 4F      LD IX,ANIMITEMPTR
  73+ 4F7C FD 21 51 4F      LD IY,ANIMDEFPTR
  74+ 4F80 FA 9E 4F         JP M, .INCREASE
  75+ 4F83                  ; new value is lower than previous one
  76+ 4F83 CD B6 4F         CALL .SIZEDIFF
  77+ 4F86 CD D1 4F         CALL .DECREASE_COMMON
  78+ 4F89 2A 54 4F         LD HL,(ANIMSPRPTR)
  79+ 4F8C AF               XOR A
  80+ 4F8D ED 42            SBC HL,BC
  81+ 4F8F 22 54 4F         LD (ANIMSPRPTR),HL
  82+ 4F92              .E1:
  83+ 4F92 2A 10 40         LD HL,(FREEMEMPTR)
  84+ 4F95 AF               XOR A
  85+ 4F96 ED 42            SBC HL,BC
  86+ 4F98 22 10 40         LD (FREEMEMPTR),HL
  87+ 4F9B              .EXIT:
  88+ 4F9B FB               EI
  89+ 4F9C E1           	POP HL
  90+ 4F9D C9           	RET
  91+ 4F9E              .INCREASE:
  92+ 4F9E ED 44            NEG
  93+ 4FA0 CD B6 4F         CALL .SIZEDIFF
  94+ 4FA3 CD FD 4F         CALL .INCREASE_COMMON
  95+ 4FA6 2A 54 4F         LD HL,(ANIMSPRPTR)
  96+ 4FA9 09               ADD HL,BC
  97+ 4FAA 22 54 4F         LD (ANIMSPRPTR),HL
  98+ 4FAD              .E2:
  99+ 4FAD 2A 10 40         LD HL,(FREEMEMPTR)
 100+ 4FB0 09               ADD HL,BC
 101+ 4FB1 22 10 40         LD (FREEMEMPTR),HL
 102+ 4FB4 18 E5            JR .EXIT
 103+ 4FB6              .SIZEDIFF:
 104+ 4FB6 CD 56 4F         CALL Ax5
 105+ 4FB9 78               LD A,B
 106+ 4FBA 32 4D 4F         LD (ANIMITEMNUM),A
 107+ 4FBD 44               LD B,H
 108+ 4FBE 4D               LD C,L
 109+ 4FBF C9               RET ; BC=size difference in bytes
 110+ 4FC0              .SIZETOMOVE:
 111+ 4FC0 D5               PUSH DE
 112+ 4FC1 2A 10 40         LD HL,(FREEMEMPTR)
 113+ 4FC4 FD 5E 00         LD E,(IY)
 114+ 4FC7 FD 56 01         LD D,(IY+1)
 115+ 4FCA AF               XOR A
 116+ 4FCB ED 52            SBC HL,DE
 117+ 4FCD 44               LD B,H
 118+ 4FCE 4D               LD C,L
 119+ 4FCF D1               POP DE
 120+ 4FD0 C9               RET
 121+ 4FD1              .DECREASE_COMMON:
 122+ 4FD1 FD 6E 00         LD L,(IY)
 123+ 4FD4 FD 66 01         LD H,(IY+1)
 124+ 4FD7 AF               XOR A
 125+ 4FD8 ED 42            SBC HL,BC
 126+ 4FDA EB               EX DE,HL
 127+ 4FDB C5               PUSH BC
 128+ 4FDC CD C0 4F         CALL .SIZETOMOVE
 129+ 4FDF F3               DI
 130+ 4FE0 78               LD A,B
 131+ 4FE1 B1               OR C
 132+ 4FE2 28 08            JR Z,.L1
 133+ 4FE4 FD 6E 00         LD L,(IY)
 134+ 4FE7 FD 66 01         LD H,(IY+1)
 135+ 4FEA                  ;LD (IX),E
 136+ 4FEA                  ;LD (IX+1),D
 137+ 4FEA ED B0            LDIR
 138+ 4FEC              .L1:
 139+ 4FEC C1               POP BC
 140+ 4FED FD 6E 00         LD L,(IY)
 141+ 4FF0 FD 66 01         LD H,(IY+1)
 142+ 4FF3 AF               XOR A
 143+ 4FF4 ED 42            SBC HL,BC
 144+ 4FF6 FD 75 00         LD (IY),L
 145+ 4FF9 FD 74 01         LD (IY+1),H
 146+ 4FFC C9               RET
 147+ 4FFD              .INCREASE_COMMON:
 148+ 4FFD 2A 10 40         LD HL,(FREEMEMPTR)
 149+ 5000 2B               DEC HL
 150+ 5001 AF               XOR A
 151+ 5002 ED 42            SBC HL,BC
 152+ 5004 EB               EX DE,HL
 153+ 5005 C5               PUSH BC
 154+ 5006 CD C0 4F         CALL .SIZETOMOVE
 155+ 5009 F3               DI
 156+ 500A 78               LD A,B
 157+ 500B B1               OR C
 158+ 500C 28 06            JR Z,.L2
 159+ 500E 2A 10 40         LD HL,(FREEMEMPTR)
 160+ 5011 2B               DEC HL
 161+ 5012 ED B8            LDDR
 162+ 5014              .L2:
 163+ 5014 C1               POP BC
 164+ 5015 FD 6E 00         LD L,(IY)
 165+ 5018 FD 66 01         LD H,(IY+1)
 166+ 501B 09               ADD HL,BC
 167+ 501C FD 75 00         LD (IY),L
 168+ 501F FD 74 01         LD (IY+1),H
 169+ 5022 C9               RET
 170+ 5023              ; *******************************************************************************************************
 171+ 5023
 172+ 5023              ; *******************************************************************************************************
 173+ 5023              ; function to handle CALL ANIMITEMPAT basic extension
 174+ 5023              ; ANIMITEMPAT ( BYTE id,
 175+ 5023              ;               INT ticks,
 176+ 5023              ;               BYTE pattern,
 177+ 5023              ;               BYTE color )
 178+ 5023              ; fills animation item data, returns an error if out of bounds
 179+ 5023              ANIMITEMPAT:
 180+ 5023                  ; opening (
 181+ 5023 CD 19 54     	CALL CHKCHAR
 182+ 5026 28           	DB '('
 183+ 5027              	; get id
 184+ 5027 DD 21 1C 52  	LD IX, GETBYT
 185+ 502B CD 59 01     	CALL CALBAS
 186+ 502E F5               PUSH AF
 187+ 502F                  ; check if out of bounds
 188+ 502F 3C               INC A
 189+ 5030 4F               LD C,A
 190+ 5031 3A 4D 4F         LD A,(ANIMITEMNUM)
 191+ 5034 B9               CP C
 192+ 5035 DA 2F 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 193+ 5038              	; comma
 194+ 5038 CD 19 54     	CALL CHKCHAR
 195+ 503B 2C           	DB ','
 196+ 503C              	; get ticks
 197+ 503C DD 21 2F 54  	LD IX, FRMQNT
 198+ 5040 CD 59 01     	CALL CALBAS
 199+ 5043 D5           	PUSH DE
 200+ 5044              	; comma
 201+ 5044 CD 19 54     	CALL CHKCHAR
 202+ 5047 2C           	DB ','
 203+ 5048              	; get pattern
 204+ 5048 DD 21 1C 52  	LD IX, GETBYT
 205+ 504C CD 59 01     	CALL CALBAS
 206+ 504F F5               PUSH AF
 207+ 5050              	; comma
 208+ 5050 CD 19 54     	CALL CHKCHAR
 209+ 5053 2C           	DB ','
 210+ 5054              	; get color
 211+ 5054 DD 21 1C 52  	LD IX, GETBYT
 212+ 5058 CD 59 01     	CALL CALBAS
 213+ 505B F5               PUSH AF
 214+ 505C              	; ending )
 215+ 505C CD 19 54     	CALL CHKCHAR
 216+ 505F 29           	DB ')'
 217+ 5060              .ENTRY:
 218+ 5060 E5               PUSH HL
 219+ 5061 DD E1            POP IX
 220+ 5063 D9               EXX
 221+ 5064 C1               POP BC ; color
 222+ 5065 D1               POP DE ; pattern
 223+ 5066 E1               POP HL ; ticks
 224+ 5067 D9               EXX
 225+ 5068 F1               POP AF
 226+ 5069 CD 56 4F         CALL Ax5
 227+ 506C ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 228+ 5070 19               ADD HL,DE
 229+ 5071 E5               PUSH HL
 230+ 5072 FD E1            POP IY
 231+ 5074 D9               EXX
 232+ 5075 FD 36 00 00      LD (IY),0 ; type=0
 233+ 5079 FD 75 01         LD (IY+1),L
 234+ 507C FD 74 02         LD (IY+2),H
 235+ 507F FD 72 03         LD (IY+3),D
 236+ 5082 FD 70 04         LD (IY+4),B
 237+ 5085
 238+ 5085 DD E5            PUSH IX
 239+ 5087 E1               POP HL
 240+ 5088 C9               RET
 241+ 5089              ; *******************************************************************************************************
 242+ 5089
 243+ 5089              ; *******************************************************************************************************
 244+ 5089              ; function to handle CALL ANIMITEMPTR basic extension
 245+ 5089              ; ANIMITEMPTR ( BYTE id,
 246+ 5089              ;               INT ticks,
 247+ 5089              ;               INT pointer,
 248+ 5089              ; fills animation item data, returns an error if out of bounds
 249+ 5089              ANIMITEMPTR_CMD:
 250+ 5089                  ; opening (
 251+ 5089 CD 19 54     	CALL CHKCHAR
 252+ 508C 28           	DB '('
 253+ 508D              	; get id
 254+ 508D DD 21 1C 52  	LD IX, GETBYT
 255+ 5091 CD 59 01     	CALL CALBAS
 256+ 5094 F5               PUSH AF
 257+ 5095                  ; check if out of bounds
 258+ 5095 3C               INC A
 259+ 5096 4F               LD C,A
 260+ 5097 3A 4D 4F         LD A,(ANIMITEMNUM)
 261+ 509A B9               CP C
 262+ 509B DA 2F 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 263+ 509E              	; comma
 264+ 509E CD 19 54     	CALL CHKCHAR
 265+ 50A1 2C           	DB ','
 266+ 50A2              	; get ticks
 267+ 50A2 DD 21 2F 54  	LD IX, FRMQNT
 268+ 50A6 CD 59 01     	CALL CALBAS
 269+ 50A9 D5           	PUSH DE
 270+ 50AA              	; comma
 271+ 50AA CD 19 54     	CALL CHKCHAR
 272+ 50AD 2C           	DB ','
 273+ 50AE              	; get pointer
 274+ 50AE DD 21 2F 54  	LD IX, FRMQNT
 275+ 50B2 CD 59 01     	CALL CALBAS
 276+ 50B5 D5           	PUSH DE
 277+ 50B6              	; ending )
 278+ 50B6 CD 19 54     	CALL CHKCHAR
 279+ 50B9 29           	DB ')'
 280+ 50BA              .ENTRY:
 281+ 50BA E5               PUSH HL
 282+ 50BB DD E1            POP IX
 283+ 50BD D9               EXX
 284+ 50BE D1               POP DE ; pointer
 285+ 50BF E1               POP HL ; ticks
 286+ 50C0 D9               EXX
 287+ 50C1 F1               POP AF
 288+ 50C2 CD 56 4F         CALL Ax5
 289+ 50C5 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 290+ 50C9 19               ADD HL,DE
 291+ 50CA E5               PUSH HL
 292+ 50CB FD E1            POP IY
 293+ 50CD D9               EXX
 294+ 50CE FD 36 00 01      LD (IY),1 ; type=1
 295+ 50D2 FD 75 01         LD (IY+1),L
 296+ 50D5 FD 74 02         LD (IY+2),H
 297+ 50D8 FD 73 03         LD (IY+3),E
 298+ 50DB FD 72 04         LD (IY+4),D
 299+ 50DE
 300+ 50DE DD E5            PUSH IX
 301+ 50E0 E1               POP HL
 302+ 50E1 C9               RET
 303+ 50E2              ; *******************************************************************************************************
 304+ 50E2
 305+ 50E2              ; *******************************************************************************************************
 306+ 50E2              ; function to handle CALL MAXANIMDEFS basic extension
 307+ 50E2              ; MAXANIMDEFS (BYTE number)
 308+ 50E2              ; sets new number and moves memory buffers as needed
 309+ 50E2              MAXANIMDEFS:
 310+ 50E2              	; opening (
 311+ 50E2 CD 19 54     	CALL CHKCHAR
 312+ 50E5 28           	DB '('
 313+ 50E6              	; get value
 314+ 50E6 DD 21 1C 52  	LD IX, GETBYT
 315+ 50EA CD 59 01     	CALL CALBAS
 316+ 50ED F5               PUSH AF
 317+ 50EE              	; ending )
 318+ 50EE CD 19 54     	CALL CHKCHAR
 319+ 50F1 29           	DB ')'
 320+ 50F2 F1               POP AF
 321+ 50F3
 322+ 50F3              	; save position
 323+ 50F3 E5           	PUSH HL
 324+ 50F4              .ENTRY:
 325+ 50F4 47               LD B,A
 326+ 50F5 3A 50 4F         LD A,(ANIMDEFNUM)
 327+ 50F8 90               SUB B
 328+ 50F9 CA 9B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 329+ 50FC DD 21 51 4F      LD IX,ANIMDEFPTR
 330+ 5100 FD 21 54 4F      LD IY,ANIMSPRPTR
 331+ 5104 FA 10 51         JP M, .INCREASE
 332+ 5107                  ; new value is lower than previous one
 333+ 5107 CD 1B 51         CALL .SIZEDIFF
 334+ 510A CD D1 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 335+ 510D C3 92 4F         JP MAXANIMITEMS.E1
 336+ 5110              .INCREASE:
 337+ 5110 ED 44            NEG
 338+ 5112 CD 1B 51         CALL .SIZEDIFF
 339+ 5115 CD FD 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 340+ 5118 C3 AD 4F         JP MAXANIMITEMS.E2
 341+ 511B              .SIZEDIFF:
 342+ 511B 26 00            LD H,0
 343+ 511D 6F               LD L,A
 344+ 511E CD 07 53         CALL HLx16
 345+ 5121 78               LD A,B
 346+ 5122 32 50 4F         LD (ANIMDEFNUM),A
 347+ 5125 44               LD B,H
 348+ 5126 4D               LD C,L
 349+ 5127 C9               RET ; BC=size difference in bytes
 350+ 5128              ; *******************************************************************************************************
 351+ 5128
 352+ 5128              ; *******************************************************************************************************
 353+ 5128              ; function to handle CALL ANIMDEF basic extension
 354+ 5128              ; ANIMITEMPAT ( BYTE id,
 355+ 5128              ;               BYTE size,
 356+ 5128              ;               INT[] list )
 357+ 5128              ; fills animation definition data, returns an error if out of bounds, or invalid type
 358+ 5128              ANIMDEF:
 359+ 5128                  ; opening (
 360+ 5128 CD 19 54     	CALL CHKCHAR
 361+ 512B 28           	DB '('
 362+ 512C              	; get id
 363+ 512C DD 21 1C 52  	LD IX, GETBYT
 364+ 5130 CD 59 01     	CALL CALBAS
 365+ 5133 F5               PUSH AF
 366+ 5134                  ; check if out of bounds
 367+ 5134 3C               INC A
 368+ 5135 4F               LD C,A
 369+ 5136 3A 50 4F         LD A,(ANIMDEFNUM)
 370+ 5139 B9               CP C
 371+ 513A DA 2F 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 372+ 513D              	; comma
 373+ 513D CD 19 54     	CALL CHKCHAR
 374+ 5140 2C           	DB ','
 375+ 5141              	; get size
 376+ 5141 DD 21 1C 52  	LD IX, GETBYT
 377+ 5145 CD 59 01     	CALL CALBAS
 378+ 5148 FE 10            CP 16
 379+ 514A D2 33 54         JP NC, OVERFLOW
 380+ 514D B7               OR A
 381+ 514E CA 33 54         JP Z, OVERFLOW
 382+ 5151 F5           	PUSH AF
 383+ 5152              	; comma
 384+ 5152 CD 19 54     	CALL CHKCHAR
 385+ 5155 2C           	DB ','
 386+ 5156              	; get pointer to a list of animation items in integer array format
 387+ 5156 3E 01            LD A,1
 388+ 5158 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 389+ 515B DD 21 A4 5E  	LD IX, PTRGET
 390+ 515F CD 59 01     	CALL CALBAS
 391+ 5162                  ; contrary to documentation we get a pointer to array dimension in BC
 392+ 5162                  ; and type in VALTYP
 393+ 5162 3A 63 F6         LD A,(VALTYP)
 394+ 5165 FE 02            CP 2
 395+ 5167 C2 2B 54         JP NZ,TYPE_MISMATCH
 396+ 516A 0A               LD A,(BC)
 397+ 516B FE 01            CP 1
 398+ 516D C2 2B 54         JP NZ,TYPE_MISMATCH
 399+ 5170 03               INC BC
 400+ 5171 0A               LD A,(BC)
 401+ 5172 D1               POP DE
 402+ 5173 D5               PUSH DE
 403+ 5174 3C               INC A
 404+ 5175 BA               CP D
 405+ 5176 DA 2F 54         JP C,SUBSCRIPT_OUT_OF_RANGE
 406+ 5179 03          > INC BC
 406+ 517A 03          > INC BC
 407+ 517B C5               PUSH BC
 408+ 517C              	; ending )
 409+ 517C CD 19 54     	CALL CHKCHAR
 410+ 517F 29           	DB ')'
 411+ 5180              .ENTRY:
 412+ 5180 E5               PUSH HL
 413+ 5181 DD E1            POP IX
 414+ 5183 D1               POP DE ; pointer to INT array
 415+ 5184 C1               POP BC ; B=item number
 416+ 5185 F1               POP AF ; id
 417+ 5186 26 00            LD H,0
 418+ 5188 6F               LD L,A
 419+ 5189 CD 07 53         CALL HLx16
 420+ 518C D5               PUSH DE
 421+ 518D ED 5B 51 4F      LD DE,(ANIMDEFPTR)
 422+ 5191 19               ADD HL,DE
 423+ 5192 D1               POP DE
 424+ 5193 70               LD (HL),B
 425+ 5194              .L1:
 426+ 5194 23               INC HL
 427+ 5195 1A               LD A,(DE)
 428+ 5196 13          > INC DE
 428+ 5197 13          > INC DE
 429+ 5198 77               LD (HL),A
 430+ 5199 10 F9            DJNZ .L1
 431+ 519B DD E5            PUSH IX
 432+ 519D E1               POP HL
 433+ 519E C9               RET
 434+ 519F              ; *******************************************************************************************************
 435+ 519F
# file closed: asm\ANIMATION.asm
 127  519F               ENDIF
 128  519F
 129  519F              ; temp variables for BLIT, TILE functions
 130  519F               IF (BLIT_CMDS + TILE_CMDS > 0)
 131  519F              BLIT_TMP:
 132  519F              TILETMP1:
 133  519F              BLIT_TMP1:
 134  519F 00 00         DW 0
 135  51A1              TILETMP2:
 136  51A1              BLIT_TMP2:
 137  51A1 00 00         DW 0
 138  51A3                IFDEF CMDS_WITH_PARAMETERS
 139  51A3              BLIT_STRUCT:
 140  51A3 00 00 00...   DS 17
 141  51A7                ENDIF
 142  51A7               ENDIF
 143  51B4
 144  51B4              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 145  51B4              ; per starting letter, if no commands with this letter, NULL value
 146  51B4              CMDS:
 147  51B4               IF (ANIM_CMDS == 1)
 148  51B4 CF 52        	DW CMDS_A ;
 149  51B6               ELSE
 150  51B6 ~                DW 0 ; A
 151  51B6               ENDIF
 152  51B6               IF (BLIT_CMDS + BOX_CMDS > 0)
 153  51B6 9A 52            DW CMDS_B ; B
 154  51B8               ELSE
 155  51B8 ~            	DW 0
 156  51B8               ENDIF
 157  51B8 00 00            DW 0 ; C
 158  51BA 00 00            DW 0 ; D
 159  51BC 00 00            DW 0 ; E
 160  51BE               IF (VRAM_CMDS + RAM_CMDS > 0)
 161  51BE 18 52            DW CMDS_F; F
 162  51C0               ELSE
 163  51C0 ~            	DW 0
 164  51C0               ENDIF
 165  51C0               IF (GENCAL_CMD > 0)
 166  51C0 2B 52            DW CMDS_G; G
 167  51C2               ELSE
 168  51C2 ~            	DW 0
 169  51C2               ENDIF
 170  51C2 00 00            DW 0 ; H
 171  51C4 00 00            DW 0 ; I
 172  51C6 00 00            DW 0 ; J
 173  51C8 00 00            DW 0 ; K
 174  51CA 00 00            DW 0 ; L
 175  51CC               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 176  51CC E8 51            DW CMDS_M ; M
 177  51CE               ELSE
 178  51CE ~            	DW 0
 179  51CE               ENDIF
 180  51CE 00 00            DW 0 ; N
 181  51D0 00 00            DW 0 ; O
 182  51D2 00 00            DW 0 ; P
 183  51D4 00 00            DW 0 ; Q
 184  51D6 00 00            DW 0 ; R
 185  51D8               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 186  51D8 3F 52            DW CMDS_S ; S
 187  51DA               ELSE
 188  51DA ~            	DW 0
 189  51DA               ENDIF
 190  51DA               IF (TILE_CMDS > 0)
 191  51DA BA 52            DW CMDS_T ; T
 192  51DC               ELSE
 193  51DC ~            	DW 0
 194  51DC               ENDIF
 195  51DC 00 00            DW 0 ; U
 196  51DE               IF (VRAM_CMDS > 0)
 197  51DE 35 52            DW CMDS_V ; V
 198  51E0               ELSE
 199  51E0 ~            	DW 0
 200  51E0               ENDIF
 201  51E0 00 00            DW 0 ; W
 202  51E2 00 00            DW 0 ; X
 203  51E4 00 00            DW 0 ; Y
 204  51E6 00 00            DW 0 ; Z
 205  51E8
 206  51E8              CMDS_M:
 207  51E8               IF (VRAM_CMDS == 1)
 208  51E8 4D 45 4D 56      DB "MEMVRM", 0
 208  51EC 52 4D 00
 209  51EF 81 55            DW MEMVRM
 210  51F1               ENDIF
 211  51F1               IF (RAM_CMDS == 1)
 212  51F1 4D 45 4D 43  	DB "MEMCPY", 0
 212  51F5 50 59 00
 213  51F8 40 54        	DW MEMCPY
 214  51FA               ENDIF
 215  51FA               IF (ANIM_CMDS == 1)
 216  51FA 4D 41 58 41  	DB "MAXANIMITEMS",0
 216  51FE 4E 49 4D 49
 216  5202 54 45 4D 53
 216  5206 00
 217  5207 5F 4F        	DW MAXANIMITEMS
 218  5209 4D 41 58 41  	DB "MAXANIMDEFS",0
 218  520D 4E 49 4D 44
 218  5211 45 46 53 00
 219  5215 E2 50        	DW MAXANIMDEFS
 220  5217               ENDIF
 221  5217               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 222  5217 00           	DB 0
 223  5218               ENDIF
 224  5218              CMDS_F:
 225  5218               IF (VRAM_CMDS == 1)
 226  5218 46 49 4C 56      DB "FILVRM", 0
 226  521C 52 4D 00
 227  521F 83 54            DW FILVRM
 228  5221               ENDIF
 229  5221               IF (RAM_CMDS == 1)
 230  5221 46 49 4C 52      DB "FILRAM", 0
 230  5225 41 4D 00
 231  5228 CA 54            DW FILRAM
 232  522A               ENDIF
 233  522A               IF (VRAM_CMDS + RAM_CMDS > 0)
 234  522A 00               DB 0
 235  522B               ENDIF
 236  522B              CMDS_G:
 237  522B               IF (GENCAL_CMD == 1)
 238  522B 47 45 4E 43      DB "GENCAL", 0
 238  522F 41 4C 00
 239  5232 28 55            DW GENCAL
 240  5234               ENDIF
 241  5234               IF (GENCAL_CMD > 0)
 242  5234 00           	DB	0
 243  5235               ENDIF
 244  5235              CMDS_V:
 245  5235               IF (VRAM_CMDS == 1)
 246  5235 56 52 4D 4D  	DB "VRMMEM", 0
 246  5239 45 4D 00
 247  523C F9 55        	DW VRMMEM
 248  523E               ENDIF
 249  523E               IF (VRAM_CMDS > 0)
 250  523E 00           	DB 0
 251  523F               ENDIF
 252  523F              CMDS_S:
 253  523F               IF (SPRITE_CMDS == 1)
 254  523F 53 50 52 53  	DB "SPRSET", 0
 254  5243 45 54 00
 255  5246 0E 4E        	DW SPRSET
 256  5248 53 50 52 47  	DB "SPRGRPMOV", 0
 256  524C 52 50 4D 4F
 256  5250 56 00
 257  5252 CC 4E        	DW SPRGRPMOV
 258  5254               ENDIF
 259  5254               IF (SOUND_CMDS == 1)
 260  5254 53 4E 44 53  	DB "SNDSFX", 0
 260  5258 46 58 00
 261  525B 37 57        	DW SNDSFX
 262  525D 53 4E 44 50  	DB "SNDPLYON", 0
 262  5261 4C 59 4F 4E
 262  5265 00
 263  5266 01 57        	DW SNDPLYON
 264  5268 53 4E 44 50  	DB "SNDPLYOFF", 0
 264  526C 4C 59 4F 46
 264  5270 46 00
 265  5272 14 57        	DW SNDPLYOFF
 266  5274 53 4E 44 50  	DB "SNDPLYINI", 0
 266  5278 4C 59 49 4E
 266  527C 49 00
 267  527E B7 56        	DW SNDPLYINIT
 268  5280               ENDIF
 269  5280               IF (SPRITE_CMDS == 1)
 270  5280 53 50 52 45  	DB "SPRENABLE", 0
 270  5284 4E 41 42 4C
 270  5288 45 00
 271  528A B9 4D        	DW SPRENABLE
 272  528C 53 50 52 44  	DB "SPRDISABLE", 0
 272  5290 49 53 41 42
 272  5294 4C 45 00
 273  5297 09 4E        	DW SPRDISABLE
 274  5299               ENDIF
 275  5299               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 276  5299 00           	DB 0
 277  529A               ENDIF
 278  529A              CMDS_B:
 279  529A               IF (BLIT_CMDS == 1)
 280  529A 42 4C 49 54  	DB "BLIT", 0
 280  529E 00
 281  529F 0E 59        	DW BLIT
 282  52A1               ENDIF
 283  52A1               IF (BOX_CMDS == 1)
 284  52A1 42 4F 58 4D  	DB "BOXMEMCPY", 0
 284  52A5 45 4D 43 50
 284  52A9 59 00
 285  52AB 46 5C        	DW BOXMEMCPY
 286  52AD 42 4F 58 4D  	DB "BOXMEMVRM", 0
 286  52B1 45 4D 56 52
 286  52B5 4D 00
 287  52B7 7A 5C        	DW BOXMEMVRM
 288  52B9               ENDIF
 289  52B9               IF (BLIT_CMDS + BOX_CMDS > 0)
 290  52B9 00           	DB 0
 291  52BA               ENDIF
 292  52BA              CMDS_T:
 293  52BA               IF (TILE_CMDS == 1)
 294  52BA 54 49 4C 45  	DB "TILERAM", 0
 294  52BE 52 41 4D 00
 295  52C2 52 5A        	DW TILERAM
 296  52C4 54 49 4C 45  	DB "TILEVRM", 0
 296  52C8 56 52 4D 00
 297  52CC 55 5B        	DW TILEVRM
 298  52CE               ENDIF
 299  52CE               IF (TILE_CMDS > 0)
 300  52CE 00           	DB 0
 301  52CF               ENDIF
 302  52CF              CMDS_A:
 303  52CF               IF (ANIM_CMDS == 1)
 304  52CF 41 4E 49 4D  	DB "ANIMITEMPAT",0
 304  52D3 49 54 45 4D
 304  52D7 50 41 54 00
 305  52DB 23 50        	DW ANIMITEMPAT
 306  52DD 41 4E 49 4D  	DB "ANIMITEMPTR",0
 306  52E1 49 54 45 4D
 306  52E5 50 54 52 00
 307  52E9 89 50        	DW ANIMITEMPTR_CMD
 308  52EB 41 4E 49 4D  	DB "ANIMDEF",0
 308  52EF 44 45 46 00
 309  52F3 28 51        	DW ANIMDEF
 310  52F5 00           	DB 0
 311  52F6               ENDIF
 312  52F6
 313  52F6               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 314  52F6              ; ****************************************************************************************************
 315  52F6              ; function sets VRAM address
 316  52F6              ; input HL=address
 317  52F6              ; modifies AF
 318  52F6              SETWRT_LOCAL:
 319  52F6 7D           	LD	A, L
 320  52F7 D3 99        	OUT	(099H), A
 321  52F9 7C           	LD	A, H
 322  52FA E6 3F        	AND	03FH
 323  52FC F6 40        	OR	040H
 324  52FE D3 99        	OUT	(099H), A
 325  5300 C9           	RET
 326  5301              ; ****************************************************************************************************
 327  5301               ENDIF
 328  5301
 329  5301               IF (VRAM_CMDS + TILE_CMDS > 0)
 330  5301              ; ****************************************************************************************************
 331  5301              ; function copies data from RAM to VRAM
 332  5301              ; input HL=address in RAM
 333  5301              ; input B=count
 334  5301              ; modifies AF
 335  5301              BBYTECOPY:
 336  5301 ED A3        	OUTI
 337  5303 C2 01 53     	JP	NZ, BBYTECOPY
 338  5306 C9           	RET
 339  5307              ; ****************************************************************************************************
 340  5307               ENDIF
 341  5307
 342  5307              ; ****************************************************************************************************
 343  5307              ; function multiplies HL by 16
 344  5307              HLx16:
 345  5307 29           	ADD HL,HL
 346  5308              ; ****************************************************************************************************
 347  5308              ; function multiplies HL by 8
 348  5308              HLx8:
 349  5308 29          > ADD HL, HL
 349  5309 29          > ADD HL, HL
 349  530A 29          > ADD HL, HL
 350  530B C9           	RET
 351  530C              ; ****************************************************************************************************
 352  530C
 353  530C              ; ****************************************************************************************************
 354  530C              ; function gets slot and subslot data for specific page
 355  530C              ; input A=page (0, 1 or 2)
 356  530C              ; output B = 0A8H register value
 357  530C              ; output D = 0 is no subslots, 1 if yes
 358  530C              ; output C = 0A8H value when page 3 slot equals to requested page slot
 359  530C              ; output E = subslot value if present
 360  530C              ; modifies AF, BC, DE, HL
 361  530C              GET_PAGE_INFO:
 362  530C 6F               LD L, A
 363  530D C6 C1            ADD A, low (EXPTBL)
 364  530F 32 19 53         LD (GET_PAGE_INFO_L1+1), A
 365  5312 DB A8            IN A, (0A8H)
 366  5314 47               LD B, A
 367  5315 E6 3F            AND 03FH
 368  5317 4F               LD C, A
 369  5318              GET_PAGE_INFO_L1:
 370  5318 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 371  531B E6 80            AND 080H
 372  531D 28 1B            JR Z, GET_PAGE_INFO_L2
 373  531F                  ; expanded
 374  531F 2D               DEC L
 375  5320 FA 3F 53         JP M, GET_PAGE_INFO_L3
 376  5323 2D               DEC L
 377  5324 FA 3D 53         JP M, GET_PAGE_INFO_L4
 378  5327                  ; page 2
 379  5327 07               RLCA
 380  5328 07               RLCA
 381  5329              GET_PAGE_INFO_L5:
 382  5329 E6 C0            AND 0C0H
 383  532B B1               OR C
 384  532C D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 385  532E 4F               LD C, A
 386  532F 3A FF FF         LD A, (0FFFFH)
 387  5332 2F               CPL
 388  5333 5F               LD E, A
 389  5334 16 01            LD D, 1
 390  5336 78               LD A, B ; return stack
 391  5337 D3 A8            OUT (0A8H), A
 392  5339 C9               RET
 393  533A              GET_PAGE_INFO_L2:
 394  533A                  ; not expanded
 395  533A 16 00            LD D, 0
 396  533C C9               RET
 397  533D              GET_PAGE_INFO_L4:
 398  533D                  ; page 1
 399  533D 0F               RRCA
 400  533E 0F               RRCA
 401  533F              GET_PAGE_INFO_L3:
 402  533F                  ; page 0
 403  533F 0F               RRCA
 404  5340 0F               RRCA
 405  5341 18 E6            JR GET_PAGE_INFO_L5
 406  5343              ; ****************************************************************************************************
 407  5343
 408  5343              ; ****************************************************************************************************
 409  5343              ; function returns original slot and subslot info
 410  5343              ; input B = 0A8H register value
 411  5343              ; input D = 0 is no subslots, 1 if yes
 412  5343              ; input C = 0A8H value when page 3 slot equals to requested page slot
 413  5343              ; input E = subslot value if present
 414  5343              ; modifies AF, disables interrupts
 415  5343              RESTORE_PAGE_INFO:
 416  5343 7A               LD A, D
 417  5344 B7               OR A
 418  5345 28 08            JR Z, RESTORE_PAGE_INFO_L1
 419  5347 79               LD A, C
 420  5348 F3           	DI
 421  5349 D3 A8            OUT (0A8H), A
 422  534B 7B               LD A, E
 423  534C 32 FF FF         LD (0FFFFH), A
 424  534F              RESTORE_PAGE_INFO_L1:
 425  534F 78               LD A, B
 426  5350 D3 A8            OUT (0A8H), A
 427  5352 C9               RET
 428  5353              ; ****************************************************************************************************
 429  5353
 430  5353              ; *******************************************************************************************************
 431  5353              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 432  5353              ; INPUT:  A = SLOT ID: EXXXSSPP
 433  5353              ; E = EXPANDED FLAG
 434  5353              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 435  5353              ; PP = PRIMARY SLOT NUMBER
 436  5353              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 437  5353              ; CHANGES: AF, BC, DE
 438  5353
 439  5353              LOCAL_ENASLT:
 440  5353 CD 73 53         CALL L0353
 441  5356 FA 60 53         JP M, L0340
 442  5359 DB A8            IN A, (0A8H)
 443  535B A1               AND C
 444  535C B0               OR B
 445  535D D3 A8            OUT (0A8H), A
 446  535F C9               RET
 447  5360              L0340:
 448  5360 E5               PUSH HL
 449  5361 CD 98 53         CALL L0378
 450  5364 4F               LD C, A
 451  5365 06 00            LD B, 0
 452  5367 7D               LD A, L
 453  5368 A4               AND H
 454  5369 B2               OR D
 455  536A 21 C5 FC         LD HL, 0FCC5H
 456  536D 09               ADD HL, BC
 457  536E 77               LD (HL), A
 458  536F E1               POP HL
 459  5370 79               LD A, C
 460  5371 18 E0            JR LOCAL_ENASLT
 461  5373              L0353:
 462  5373 F3               DI
 463  5374 F5               PUSH AF
 464  5375 7C               LD A, H
 465  5376 07               RLCA
 466  5377 07               RLCA
 467  5378 E6 03            AND 3
 468  537A 5F               LD E, A
 469  537B 3E C0            LD A, 0C0H
 470  537D              L035D:
 471  537D 07               RLCA
 472  537E 07               RLCA
 473  537F 1D               DEC E
 474  5380 F2 7D 53         JP P, L035D
 475  5383 5F               LD E, A
 476  5384 2F               CPL
 477  5385 4F               LD C, A
 478  5386 F1               POP AF
 479  5387 F5               PUSH AF
 480  5388 E6 03            AND 3
 481  538A 3C               INC A
 482  538B 47               LD B, A
 483  538C 3E AB            LD A, 0ABH
 484  538E              L036E:
 485  538E C6 55            ADD A, 055H
 486  5390 10 FC            DJNZ L036E
 487  5392 57               LD D, A
 488  5393 A3               AND E
 489  5394 47               LD B, A
 490  5395 F1               POP AF
 491  5396 A7               AND A
 492  5397 C9               RET
 493  5398              L0378:
 494  5398 F5               PUSH AF
 495  5399 7A               LD A, D
 496  539A E6 C0            AND 0C0H
 497  539C 4F               LD C, A
 498  539D F1               POP AF
 499  539E F5               PUSH AF
 500  539F 57               LD D, A
 501  53A0 DB A8            IN A, (0A8H)
 502  53A2 47               LD B, A
 503  53A3 E6 3F            AND 03FH
 504  53A5 B1               OR C
 505  53A6 D3 A8            OUT (0A8H), A
 506  53A8 7A               LD A, D
 507  53A9 0F               RRCA
 508  53AA 0F               RRCA
 509  53AB E6 03            AND 3
 510  53AD 57               LD D, A
 511  53AE 3E AB            LD A, 0ABH
 512  53B0              L0390:
 513  53B0 C6 55            ADD A, 055H
 514  53B2 15               DEC D
 515  53B3 F2 B0 53         JP P, L0390
 516  53B6 A3               AND E
 517  53B7 57               LD D, A
 518  53B8 7B               LD A, E
 519  53B9 2F               CPL
 520  53BA 67               LD H, A
 521  53BB 3A FF FF         LD A, (0FFFFH)
 522  53BE 2F               CPL
 523  53BF 6F               LD L, A
 524  53C0 A4               AND H
 525  53C1 B2               OR D
 526  53C2 32 FF FF         LD (0FFFFH), A
 527  53C5 78               LD A, B
 528  53C6 D3 A8            OUT (0A8H), A
 529  53C8 F1               POP AF
 530  53C9 E6 03            AND 3
 531  53CB C9               RET
 532  53CC              ; *******************************************************************************************************
 533  53CC
 534  53CC              ; *******************************************************************************************************
 535  53CC              ; some common code to activate page 0 and place values needed to restore original page on stack
 536  53CC              ; input IY=return address
 537  53CC              ENABLE_PAGE0:
 538  53CC AF               XOR A
 539  53CD CD 0C 53         CALL GET_PAGE_INFO
 540  53D0 C5               PUSH BC
 541  53D1 D5               PUSH DE
 542  53D2 3A 41 F3         LD A, (RAMAD0)
 543  53D5 26 00            LD H, 0
 544  53D7 CD 53 53         CALL LOCAL_ENASLT
 545  53DA FD E9        	JP (IY)
 546  53DC              ; *******************************************************************************************************
 547  53DC
 548  53DC              ; General BASIC CALL-instruction handler
 549  53DC              CALLHAND:
 550  53DC E5           	PUSH HL
 551  53DD 21 B4 51     	LD	HL, CMDS ; pointer table based on starting letter
 552  53E0 3A 89 FD         LD A, (PROCNM)
 553  53E3 D6 41            SUB 'A'
 554  53E5 87               ADD A, A
 555  53E6 16 00            LD D, 0
 556  53E8 5F               LD E, A
 557  53E9 19               ADD HL, DE
 558  53EA 5E               LD E, (HL)
 559  53EB 23               INC HL
 560  53EC 56               LD D, (HL)
 561  53ED 7A               LD A, D
 562  53EE B3               OR E
 563  53EF 28 23            JR Z, .CMDNOTRECOGNIZED
 564  53F1 EB               EX DE, HL
 565  53F2              .CHKCMD:
 566  53F2 11 89 FD     	LD	DE, PROCNM
 567  53F5 1A           .LOOP:	LD	A,(DE)
 568  53F6 BE           	CP	(HL)
 569  53F7 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 570  53F9 13           	INC	DE
 571  53FA 23           	INC	HL
 572  53FB A7           	AND	A
 573  53FC 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 574  53FE 5E           	LD	E,(HL)
 575  53FF 23           	INC	HL
 576  5400 56           	LD	D,(HL)
 577  5401 E1           	POP	HL		; routine address
 578  5402 CD 23 54     	CALL	GETPREVCHAR
 579  5405 CD 17 54     	CALL	.CALLDE		; Call routine
 580  5408 A7           	AND	A
 581  5409 C9           	RET
 582  540A
 583  540A              .TONEXTCMD:
 584  540A 0E FF        	LD	C,0FFH
 585  540C AF           	XOR	A
 586  540D ED B1        	CPIR			; Skip to end of instruction name
 587  540F 23           	INC	HL
 588  5410 23           	INC	HL		; Skip address
 589  5411 BE           	CP	(HL)
 590  5412 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 591  5414              .CMDNOTRECOGNIZED:
 592  5414 E1           	POP	HL
 593  5415 37               SCF
 594  5416 C9           	RET
 595  5417
 596  5417              .CALLDE:
 597  5417 D5           	PUSH	DE
 598  5418 C9           	RET
 599  5419
 600  5419              ;---------------------------
 601  5419
 602  5419              ;GETSTRPNT:
 603  5419              ; OUT:
 604  5419              ; HL = String Address
 605  5419              ; B  = Lenght
 606  5419              ;        LD      HL,(USR)
 607  5419              ;        LD      B,(HL)
 608  5419              ;        INC     HL
 609  5419              ;        LD      E,(HL)
 610  5419              ;        INC     HL
 611  5419              ;        LD      D,(HL)
 612  5419              ;        EX      DE,HL
 613  5419              ;        RET
 614  5419
 615  5419              ;EVALTXTPARAM:
 616  5419              ;	CALL	CHKCHAR
 617  5419              ;	DEFB	"("             ; Check for (
 618  5419              ;	LD	IX,FRMEVL
 619  5419              ;	CALL	CALBAS		; Evaluate expression
 620  5419              ;       LD      A,(VALTYP)
 621  5419              ;        CP      3               ; Text type?
 622  5419              ;        JP      NZ,TYPE_MISMATCH
 623  5419              ;        PUSH	HL
 624  5419              ;        LD	IX,FRESTR         ; Free the temporary string
 625  5419              ;        CALL	CALBAS
 626  5419              ;        POP	HL
 627  5419              ;	CALL	CHKCHAR
 628  5419              ;	DEFB	")"             ; Check for )
 629  5419              ;        RET
 630  5419
 631  5419
 632  5419              CHKCHAR:
 633  5419 CD 23 54     	CALL	GETPREVCHAR	; Get previous basic char
 634  541C E3           	EX	(SP),HL
 635  541D BE           	CP	(HL) 	        ; Check if good char
 636  541E 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 637  5420 23           	INC	HL
 638  5421 E3           	EX	(SP),HL
 639  5422 23           	INC	HL		; Get next basic char
 640  5423
 641  5423              GETPREVCHAR:
 642  5423 2B           	DEC	HL
 643  5424 DD 21 66 46  	LD	IX,CHRGTR
 644  5428 C3 59 01     	JP      CALBAS
 645  542B
 646  542B
 647  542B              TYPE_MISMATCH:
 648  542B 1E 0D            LD E, 13 ; Type mismatch
 649  542D 18 0A            JR THROW_ERROR
 650  542F              SUBSCRIPT_OUT_OF_RANGE:
 651  542F 1E 09            LD E,9 ; subscript out of range
 652  5431 18 06        	JR THROW_ERROR
 653  5433              OVERFLOW:
 654  5433 1E 06        	LD E,6
 655  5435 18 02        	JR THROW_ERROR
 656  5437              SYNTAX_ERROR:
 657  5437 1E 02            LD E, 2 ; Syntax error
 658  5439              THROW_ERROR:
 659  5439 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 660  543D C3 59 01     	JP	CALBAS
 661  5440
 662  5440              ;---------------------------
 663  5440
 664  5440               IF (RAM_CMDS == 1)
 665  5440              ; *******************************************************************************************************
 666  5440              ; function to handle CALL MEMCPY basic extension
 667  5440              ; _MEMCPY ( INT source,
 668  5440              ;			INT destination,
 669  5440              ;			INT count,
 670  5440              ; will put ram in page 0 also, page 1 is already there
 671  5440              MEMCPY:
 672  5440              	; opening (
 673  5440 CD 19 54     	CALL CHKCHAR
 674  5443 28           	DB '('
 675  5444              	; get source address
 676  5444 DD 21 2F 54  	LD IX, FRMQNT
 677  5448 CD 59 01     	CALL CALBAS
 678  544B D5           	PUSH DE
 679  544C              	; comma
 680  544C CD 19 54     	CALL CHKCHAR
 681  544F 2C           	DB ','
 682  5450              	; get destination address
 683  5450 DD 21 2F 54  	LD IX, FRMQNT
 684  5454 CD 59 01     	CALL CALBAS
 685  5457 D5           	PUSH DE
 686  5458              	; comma
 687  5458 CD 19 54     	CALL CHKCHAR
 688  545B 2C           	DB ','
 689  545C              	; get length
 690  545C DD 21 2F 54  	LD IX, FRMQNT
 691  5460 CD 59 01     	CALL CALBAS
 692  5463 D5           	PUSH DE
 693  5464              	; ending )
 694  5464 CD 19 54     	CALL CHKCHAR
 695  5467 29           	DB ')'
 696  5468
 697  5468              	; save position
 698  5468 E5           	PUSH HL
 699  5469 DD E1        	POP IX
 700  546B
 701  546B C1           	POP BC ; count
 702  546C D1           	POP DE ; destination
 703  546D E1           	POP HL ; source
 704  546E D9           	EXX
 705  546F              	; enable page 0
 706  546F FD 21 76 54  	LD IY, .RET
 707  5473 C3 CC 53     	JP ENABLE_PAGE0
 708  5476              .RET:
 709  5476 FB           	EI
 710  5477 D9           	EXX
 711  5478 ED B0        	LDIR
 712  547A D1               POP DE
 713  547B C1               POP BC
 714  547C CD 43 53         CALL RESTORE_PAGE_INFO
 715  547F DD E5        	PUSH IX
 716  5481 E1           	POP HL
 717  5482 C9           	RET
 718  5483              ; *******************************************************************************************************
 719  5483               ENDIF
 720  5483
 721  5483               IF (VRAM_CMDS == 1)
 722  5483              ; *******************************************************************************************************
 723  5483              ; function to handle CALL FILVRM basic extension
 724  5483              ; FILVRM ( INT offset,
 725  5483              ;		   INT count,
 726  5483              ;		   BYTE value,
 727  5483              ;		   BYTE wait_vsync) >0 = true
 728  5483              ; wait_vsync will issue HALT before copying
 729  5483              FILVRM:
 730  5483              	; opening (
 731  5483 CD 19 54     	CALL CHKCHAR
 732  5486 28           	DB '('
 733  5487              	; get offset address
 734  5487 DD 21 2F 54  	LD IX, FRMQNT
 735  548B CD 59 01     	CALL CALBAS
 736  548E D5           	PUSH DE
 737  548F              	; comma
 738  548F CD 19 54     	CALL CHKCHAR
 739  5492 2C           	DB ','
 740  5493              	; get count
 741  5493 DD 21 2F 54  	LD IX, FRMQNT
 742  5497 CD 59 01     	CALL CALBAS
 743  549A D5           	PUSH DE
 744  549B              	; comma
 745  549B CD 19 54     	CALL CHKCHAR
 746  549E 2C           	DB ','
 747  549F              	; get value
 748  549F DD 21 1C 52  	LD IX, GETBYT
 749  54A3 CD 59 01     	CALL CALBAS
 750  54A6 F5           	PUSH AF
 751  54A7              	; comma
 752  54A7 CD 19 54     	CALL CHKCHAR
 753  54AA 2C           	DB ','
 754  54AB              	; get vsync wait
 755  54AB DD 21 1C 52  	LD IX, GETBYT
 756  54AF CD 59 01     	CALL CALBAS
 757  54B2 F5           	PUSH AF
 758  54B3              	; ending )
 759  54B3 CD 19 54     	CALL CHKCHAR
 760  54B6 29           	DB ')'
 761  54B7
 762  54B7 FB               EI
 763  54B8              	; save position
 764  54B8 E5           	PUSH HL
 765  54B9 DD E1        	POP IX
 766  54BB
 767  54BB              	; syntax ok
 768  54BB              	; wait for vsync if needed
 769  54BB F1           	POP AF
 770  54BC B7           	OR A
 771  54BD 28 01        	JR Z, .L1
 772  54BF 76           	HALT
 773  54C0
 774  54C0              .L1:
 775  54C0 F1               POP AF ; value
 776  54C1 C1               POP BC ; count
 777  54C2 E1               POP HL ; offset
 778  54C3 CD 56 00         CALL BIOS_FILVRM
 779  54C6
 780  54C6              .L3:
 781  54C6 DD E5        	PUSH IX
 782  54C8 E1           	POP HL
 783  54C9 C9           	RET
 784  54CA              ; *******************************************************************************************************
 785  54CA               ENDIF
 786  54CA
 787  54CA               IF (RAM_CMDS == 1)
 788  54CA              ; *******************************************************************************************************
 789  54CA              ; function to handle CALL FILRAM basic extension
 790  54CA              ; FILRAM ( INT start address,
 791  54CA              ;		   INT count,
 792  54CA              ;		   BYTE value,
 793  54CA              ; will put ram in page 0 also, page 1 is already there
 794  54CA              FILRAM:
 795  54CA              	; opening (
 796  54CA CD 19 54     	CALL CHKCHAR
 797  54CD 28           	DB '('
 798  54CE              	; get start address
 799  54CE DD 21 2F 54  	LD IX, FRMQNT
 800  54D2 CD 59 01     	CALL CALBAS
 801  54D5 D5           	PUSH DE
 802  54D6              	; comma
 803  54D6 CD 19 54     	CALL CHKCHAR
 804  54D9 2C           	DB ','
 805  54DA              	; get count
 806  54DA DD 21 2F 54  	LD IX, FRMQNT
 807  54DE CD 59 01     	CALL CALBAS
 808  54E1 D5           	PUSH DE
 809  54E2              	; comma
 810  54E2 CD 19 54     	CALL CHKCHAR
 811  54E5 2C           	DB ','
 812  54E6              	; get value
 813  54E6 DD 21 1C 52  	LD IX, GETBYT
 814  54EA CD 59 01     	CALL CALBAS
 815  54ED F5           	PUSH AF
 816  54EE              	; ending )
 817  54EE CD 19 54     	CALL CHKCHAR
 818  54F1 29           	DB ')'
 819  54F2
 820  54F2              	; save position
 821  54F2 E5           	PUSH HL
 822  54F3 DD E1        	POP IX
 823  54F5
 824  54F5 D1           	POP DE ; actually AF
 825  54F6 C1           	POP BC ; count
 826  54F7 E1           	POP HL ; start address
 827  54F8 78           	LD A, B
 828  54F9 B7           	OR A
 829  54FA 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 830  54FC B1           	OR C
 831  54FD 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 832  54FF 79           	LD A, C
 833  5500 3D           	DEC A
 834  5501 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 835  5503              	; one byte to fill
 836  5503 72           	LD (HL), D
 837  5504 18 12        	JR .EXIT
 838  5506              .L1:
 839  5506 D9           	EXX
 840  5507              	; enable page 0
 841  5507 FD 21 0E 55  	LD IY, .RET
 842  550B C3 CC 53     	JP ENABLE_PAGE0
 843  550E              .RET:
 844  550E FB           	EI
 845  550F D9           	EXX
 846  5510 CD 1C 55     	CALL .FILLVALUE
 847  5513 D1               POP DE
 848  5514 C1               POP BC
 849  5515 CD 43 53         CALL RESTORE_PAGE_INFO
 850  5518              .EXIT:
 851  5518 DD E5        	PUSH IX
 852  551A E1           	POP HL
 853  551B C9           	RET
 854  551C
 855  551C              .FILLVALUE:
 856  551C 72               LD (HL), D
 857  551D 54               LD D, H
 858  551E 5D               LD E, L
 859  551F 13               INC DE
 860  5520 0B               DEC BC
 861  5521 ED B0            LDIR
 862  5523 C9               RET
 863  5524              ; *******************************************************************************************************
 864  5524               ENDIF
 865  5524
 866  5524               IF (GENCAL_CMD == 1)
 867  5524              ; *******************************************************************************************************
 868  5524              ; function to handle CALL GENCAL basic extension
 869  5524              ; GENCAL ( INT fn_addr, = address of the function to call
 870  5524              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 871  5524              ; output values of reristers will also be stored at reg_list_ptr
 872  5524              GENCAL_VAR_SP:
 873  5524 00 00            DW 0
 874  5526              GENCAL_VAR_SP2:
 875  5526 00 00            DW 0
 876  5528              GENCAL:
 877  5528              	; opening (
 878  5528 CD 19 54     	CALL CHKCHAR
 879  552B 28           	DB '('
 880  552C              	; get function address
 881  552C DD 21 2F 54  	LD IX, FRMQNT
 882  5530 CD 59 01     	CALL CALBAS
 883  5533 D5           	PUSH DE
 884  5534              	; comma
 885  5534 CD 19 54     	CALL CHKCHAR
 886  5537 2C           	DB ','
 887  5538              	; get pointer to register list
 888  5538 DD 21 2F 54  	LD IX, FRMQNT
 889  553C CD 59 01     	CALL CALBAS
 890  553F D5           	PUSH DE
 891  5540              	; ending )
 892  5540 CD 19 54     	CALL CHKCHAR
 893  5543 29           	DB ')'
 894  5544
 895  5544              	; save BASIC token position
 896  5544 E5           	PUSH HL
 897  5545 D9               EXX
 898  5546 E1           	POP HL ; HL'=next basic token
 899  5547 D9               EXX
 900  5548
 901  5548 E1               POP HL ; get pointer to register values
 902  5549 F3           	DI
 903  554A ED 73 24 55      LD (GENCAL_VAR_SP), SP
 904  554E F9               LD SP, HL
 905  554F F1               POP AF
 906  5550 C1               POP BC
 907  5551 D1               POP DE
 908  5552 E1               POP HL
 909  5553 DD E1            POP IX
 910  5555 FD E1            POP IY
 911  5557 D9               EXX
 912  5558 ED 73 26 55      LD (GENCAL_VAR_SP2), SP
 913  555C ED 7B 24 55      LD SP, (GENCAL_VAR_SP)
 914  5560 FB               EI
 915  5561 D1               POP DE ; get function to call
 916  5562 E5               PUSH HL
 917  5563 CD 7E 55         CALL .EXXDECALL
 918  5566 F3               DI
 919  5567 ED 73 24 55      LD (GENCAL_VAR_SP), SP
 920  556B ED 7B 26 55      LD SP, (GENCAL_VAR_SP2)
 921  556F FD E5            PUSH IY
 922  5571 DD E5            PUSH IX
 923  5573 E5               PUSH HL
 924  5574 D5               PUSH DE
 925  5575 C5               PUSH BC
 926  5576 F5               PUSH AF
 927  5577 ED 7B 24 55      LD SP, (GENCAL_VAR_SP)
 928  557B FB               EI
 929  557C E1               POP HL
 930  557D C9           	RET
 931  557E
 932  557E              .EXXDECALL:
 933  557E D5               PUSH DE
 934  557F D9               EXX
 935  5580 C9               RET
 936  5581              ; *******************************************************************************************************
 937  5581               ENDIF
 938  5581
 939  5581               IF (VRAM_CMDS == 1)
 940  5581              ; *******************************************************************************************************
 941  5581              ; function to handle CALL MEMVRM basic extension
 942  5581              ; copies from RAM to VRAM
 943  5581              ; _MEMVRM ( INT source,
 944  5581              ;			INT destination,
 945  5581              ;			INT count,
 946  5581              ;			BYTE wait_vsync) >0 = true
 947  5581              ; will put ram in page 0 also, page 1 is already there
 948  5581              ; wait_vsync will issue HALT before copying
 949  5581              MEMVRM:
 950  5581              	; opening (
 951  5581 CD 19 54     	CALL CHKCHAR
 952  5584 28           	DB '('
 953  5585              	; get source address
 954  5585 DD 21 2F 54  	LD IX, FRMQNT
 955  5589 CD 59 01     	CALL CALBAS
 956  558C D5           	PUSH DE
 957  558D              	; comma
 958  558D CD 19 54     	CALL CHKCHAR
 959  5590 2C           	DB ','
 960  5591              	; get destination address
 961  5591 DD 21 2F 54  	LD IX, FRMQNT
 962  5595 CD 59 01     	CALL CALBAS
 963  5598 D5           	PUSH DE
 964  5599              	; comma
 965  5599 CD 19 54     	CALL CHKCHAR
 966  559C 2C           	DB ','
 967  559D              	; get length
 968  559D DD 21 2F 54  	LD IX, FRMQNT
 969  55A1 CD 59 01     	CALL CALBAS
 970  55A4 D5           	PUSH DE
 971  55A5              	; comma
 972  55A5 CD 19 54     	CALL CHKCHAR
 973  55A8 2C           	DB ','
 974  55A9              	; get vsync wait
 975  55A9 DD 21 1C 52  	LD IX, GETBYT
 976  55AD CD 59 01     	CALL CALBAS
 977  55B0 F5           	PUSH AF
 978  55B1              	; ending )
 979  55B1 CD 19 54     	CALL CHKCHAR
 980  55B4 29           	DB ')'
 981  55B5
 982  55B5                  ; save position in BASIC text
 983  55B5 E5           	PUSH HL
 984  55B6 DD E1        	POP IX
 985  55B8
 986  55B8 F1           	POP AF ; wait vsync
 987  55B9 B7           	OR A
 988  55BA 28 03        	JR Z, .L1
 989  55BC FB               EI
 990  55BD 76           	HALT
 991  55BE F3           	DI
 992  55BF              .L1:
 993  55BF              	; pop LDIR parameters and store away for later
 994  55BF C1           	POP BC ; count
 995  55C0 D1           	POP DE ; vram destination
 996  55C1 E1           	POP HL ; ram source
 997  55C2 D9           	EXX
 998  55C3 FD 21 CA 55   	LD IY, .RET
 999  55C7 C3 CC 53     	JP ENABLE_PAGE0
1000  55CA              .RET:
1001  55CA FB           	EI
1002  55CB D9           	EXX
1003  55CC CD D8 55     	CALL .LDIRVM
1004  55CF D1               POP DE
1005  55D0 C1               POP BC
1006  55D1 CD 43 53         CALL RESTORE_PAGE_INFO
1007  55D4 DD E5        	PUSH IX
1008  55D6 E1           	POP HL
1009  55D7 C9           	RET
1010  55D8
1011  55D8              .LDIRVM:
1012  55D8 EB           	EX DE, HL
1013  55D9 F3           	DI
1014  55DA CD F6 52     	CALL SETWRT_LOCAL
1015  55DD FB           	EI
1016  55DE EB           	EX DE, HL
1017  55DF 78           	LD A, B
1018  55E0 B7           	OR A
1019  55E1 28 0D        	JR Z, .L3
1020  55E3 C5           	PUSH BC
1021  55E4 0E 98        	LD C, #98
1022  55E6              .L2:
1023  55E6 50           	LD D, B
1024  55E7 06 00        	LD B, 0
1025  55E9 CD 01 53     	CALL BBYTECOPY
1026  55EC 42           	LD B, D
1027  55ED 10 F7        	DJNZ .L2
1028  55EF C1           	POP BC
1029  55F0              .L3:
1030  55F0 79           	LD A, C
1031  55F1 B7           	OR A
1032  55F2 C8           	RET Z
1033  55F3 41           	LD B, C
1034  55F4 0E 98        	LD C, #98
1035  55F6 C3 01 53     	JP BBYTECOPY
1036  55F9              ; *******************************************************************************************************
1037  55F9               ENDIF
1038  55F9
1039  55F9               IF (VRAM_CMDS == 1)
1040  55F9              ; *******************************************************************************************************
1041  55F9              ; function to handle CALL VRMMEM basic extension
1042  55F9              ; copies from RAM to VRAM
1043  55F9              ; _VRMMEM ( INT source,
1044  55F9              ;			INT destination,
1045  55F9              ;			INT count
1046  55F9              ; will put ram in page 0 also, page 1 is already there
1047  55F9              VRMMEM:
1048  55F9              	; opening (
1049  55F9 CD 19 54     	CALL CHKCHAR
1050  55FC 28           	DB '('
1051  55FD              	; get source address
1052  55FD DD 21 2F 54  	LD IX, FRMQNT
1053  5601 CD 59 01     	CALL CALBAS
1054  5604 D5           	PUSH DE
1055  5605              	; comma
1056  5605 CD 19 54     	CALL CHKCHAR
1057  5608 2C           	DB ','
1058  5609              	; get destination address
1059  5609 DD 21 2F 54  	LD IX, FRMQNT
1060  560D CD 59 01     	CALL CALBAS
1061  5610 D5           	PUSH DE
1062  5611              	; comma
1063  5611 CD 19 54     	CALL CHKCHAR
1064  5614 2C           	DB ','
1065  5615              	; get length
1066  5615 DD 21 2F 54  	LD IX, FRMQNT
1067  5619 CD 59 01     	CALL CALBAS
1068  561C D5           	PUSH DE
1069  561D              	; ending )
1070  561D CD 19 54     	CALL CHKCHAR
1071  5620 29           	DB ')'
1072  5621
1073  5621                  ; save position in BASIC text
1074  5621 E5           	PUSH HL
1075  5622 DD E1        	POP IX
1076  5624
1077  5624 C1           	POP BC ; count
1078  5625 D1           	POP DE ; destination
1079  5626 E1           	POP HL ; source
1080  5627 D9           	EXX
1081  5628 FD 21 2F 56  	LD IY, .RET
1082  562C C3 CC 53     	JP ENABLE_PAGE0
1083  562F              .RET:
1084  562F FB           	EI
1085  5630 D9           	EXX
1086  5631 CD 3D 56     	CALL .LDIRMV
1087  5634 D1               POP DE
1088  5635 C1               POP BC
1089  5636 CD 43 53         CALL RESTORE_PAGE_INFO
1090  5639 DD E5        	PUSH IX
1091  563B E1           	POP HL
1092  563C C9           	RET
1093  563D
1094  563D              .LDIRMV:
1095  563D              	; set VRAM address *exactly* as in ROM, otherwise corruption
1096  563D 7D           	LD	A, L
1097  563E F3           	DI
1098  563F D3 99        	OUT	(099H), A
1099  5641 7C           	LD	A, H
1100  5642 E6 3F        	AND	03FH
1101  5644 D3 99        	OUT	(099H), A
1102  5646 FB           	EI
1103  5647              	;EX (SP), HL
1104  5647              	;EX (SP), HL
1105  5647              	;NOP
1106  5647              	;NOP
1107  5647              .L4:
1108  5647 DB 98            IN A, (#98)
1109  5649 12           	LD (DE), A
1110  564A 13               INC DE
1111  564B 0B               DEC BC
1112  564C 79               LD A, C
1113  564D B0               OR B
1114  564E 20 F7            JR NZ, .L4
1115  5650 C9               RET
1116  5651              ; *******************************************************************************************************
1117  5651               ENDIF
1118  5651
1119  5651              ; *******************************************************************************************************
1120  5651              ; H.TIMI function
1121  5651              MBGE_HTIMI:
1122  5651               EXPORT MBGE_HTIMI
1123  5651 F5           	PUSH AF
1124  5652
1125  5652               IF (SPRITE_CMDS == 1)
1126  5652 CD 01 4D     	CALL SPRATR_UPDATE
1127  5655               ENDIF
1128  5655
1129  5655               IF (SOUND_CMDS == 1)
1130  5655 3A F7 4C     	LD A, (SOUND_ENABLED)
1131  5658 B7           	OR A
1132  5659 28 2A        	JR Z, .EXIT
1133  565B
1134  565B              	; enable page 2
1135  565B 3E 02            LD A, 2
1136  565D CD 0C 53         CALL GET_PAGE_INFO
1137  5660 C5               PUSH BC
1138  5661 D5               PUSH DE
1139  5662 3A 43 F3         LD A, (RAMAD2)
1140  5665 26 80            LD H, 080H
1141  5667 CD 53 53         CALL LOCAL_ENASLT
1142  566A              	; enable page 0
1143  566A AF               XOR A
1144  566B CD 0C 53         CALL GET_PAGE_INFO
1145  566E C5               PUSH BC
1146  566F D5               PUSH DE
1147  5670 3A 41 F3         LD A, (RAMAD0)
1148  5673 26 00            LD H, 0
1149  5675 CD 53 53         CALL LOCAL_ENASLT
1150  5678
1151  5678 CD 33 42     	CALL PLY_AKG_PLAY
1152  567B
1153  567B              	; restore page 0
1154  567B D1               POP DE
1155  567C C1               POP BC
1156  567D CD 43 53         CALL RESTORE_PAGE_INFO
1157  5680              	; restore page 2
1158  5680 D1               POP DE
1159  5681 C1               POP BC
1160  5682 CD 43 53         CALL RESTORE_PAGE_INFO
1161  5685               ENDIF
1162  5685
1163  5685              .EXIT:
1164  5685 F1           	POP AF
1165  5686 C3 F0 4C     	JP ORIG.HTIMI
1166  5689              ; *******************************************************************************************************
1167  5689
1168  5689              ; *******************************************************************************************************
1169  5689              ; interrupt handler when page 0 enabled
1170  5689              VBLANK:
1171  5689              	EXPORT VBLANK
1172  5689
1173  5689 F5               PUSH AF
1174  568A              	; is VDP originator ?
1175  568A DB 99        	IN	A, (099H)
1176  568C A7           	AND	A
1177  568D F2 B3 56     	JP P, .EXIT
1178  5690
1179  5690               IF (SOUND_CMDS == 1)
1180  5690 3A F7 4C     	LD A, (SOUND_ENABLED)
1181  5693 B7           	OR A
1182  5694 28 1D        	JR Z, .EXIT
1183  5696
1184  5696 C5               PUSH BC
1185  5697 D5               PUSH DE
1186  5698 E5               PUSH HL
1187  5699 08               EX AF, AF'
1188  569A D9               EXX
1189  569B F5               PUSH AF
1190  569C C5               PUSH BC
1191  569D D5               PUSH DE
1192  569E E5               PUSH HL
1193  569F DD E5            PUSH IX
1194  56A1 FD E5            PUSH IY
1195  56A3
1196  56A3 CD 33 42     	CALL PLY_AKG_PLAY
1197  56A6
1198  56A6 FD E1            POP IY
1199  56A8 DD E1            POP IX
1200  56AA E1               POP HL
1201  56AB D1               POP DE
1202  56AC C1               POP BC
1203  56AD F1               POP AF
1204  56AE 08               EX AF, AF'
1205  56AF D9               EXX
1206  56B0 E1               POP HL
1207  56B1 D1               POP DE
1208  56B2 C1               POP BC
1209  56B3               ENDIF
1210  56B3
1211  56B3              .EXIT:
1212  56B3 F1           	POP AF
1213  56B4 FB           	EI
1214  56B5 ED 4D        	RETI
1215  56B7              ; *******************************************************************************************************
1216  56B7
1217  56B7               IF (SOUND_CMDS == 1)
1218  56B7              ; *******************************************************************************************************
1219  56B7              ; function to handle CALL SNDPLYINIT basic extension
1220  56B7              ; initializes sound player
1221  56B7              ; _SNDPLYINIT ( INT music_offset,
1222  56B7              ;				INT sfx_offset, can be -1 if no SFX
1223  56B7              ; will put ram in page 0 also, page 1 is already there
1224  56B7              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1225  56B7              SNDPLYINIT:
1226  56B7              	; opening (
1227  56B7 CD 19 54     	CALL CHKCHAR
1228  56BA 28           	DB '('
1229  56BB              	; get music address
1230  56BB DD 21 2F 54  	LD IX, FRMQNT
1231  56BF CD 59 01     	CALL CALBAS
1232  56C2 D5           	PUSH DE
1233  56C3              	; comma
1234  56C3 CD 19 54     	CALL CHKCHAR
1235  56C6 2C           	DB ','
1236  56C7              	; get sfx address
1237  56C7 DD 21 2F 54  	LD IX, FRMQNT
1238  56CB CD 59 01     	CALL CALBAS
1239  56CE D5           	PUSH DE
1240  56CF              	; ending )
1241  56CF CD 19 54     	CALL CHKCHAR
1242  56D2 29           	DB ')'
1243  56D3
1244  56D3                  ; save position in BASIC text
1245  56D3 44           	LD B, H
1246  56D4 4D           	LD C, L
1247  56D5
1248  56D5              	; pop LDIR parameters and store away for later
1249  56D5 D1           	POP DE ; sfx address
1250  56D6 E1           	POP HL ; music address
1251  56D7 C5           	PUSH BC ; basic text location
1252  56D8 D9           	EXX
1253  56D9 FD 21 E0 56  	LD IY, .RET
1254  56DD C3 CC 53     	JP ENABLE_PAGE0
1255  56E0              .RET:
1256  56E0 D9           	EXX
1257  56E1
1258  56E1 D5           	PUSH DE
1259  56E2 AF           	XOR A
1260  56E3              	; HL = music location
1261  56E3 CD 62 41     	CALL PLY_AKG_INIT
1262  56E6 3E 01        	LD A, 1
1263  56E8 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1264  56EB
1265  56EB E1           	POP HL ; SFX
1266  56EC              	; check if SFX address -1
1267  56EC 23           	INC HL
1268  56ED 7D           	LD A, L
1269  56EE B4           	OR H
1270  56EF 28 09        	JR Z,.L1
1271  56F1 2B           	DEC HL
1272  56F2 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1273  56F5 3E 01        	LD A, 1
1274  56F7 32 F6 4C     	LD (SFX_INIT_STATUS), A
1275  56FA              .L1:
1276  56FA D1               POP DE
1277  56FB C1               POP BC
1278  56FC CD 43 53         CALL RESTORE_PAGE_INFO
1279  56FF
1280  56FF E1           	POP HL
1281  5700 C9           	RET
1282  5701              ; *******************************************************************************************************
1283  5701
1284  5701              ; *******************************************************************************************************
1285  5701              ; function to handle CALL SNDPLYON basic extension
1286  5701              ; enables sound player
1287  5701              ; _SNDPLYON
1288  5701              ; sets SOUND_ENABLED variable to 1 if init call was done
1289  5701              ; if not throws out of data error
1290  5701              SNDPLYON:
1291  5701 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1292  5704 B7           	OR A
1293  5705 20 05        	JR NZ, .L1
1294  5707              	; player not initialized, throw error
1295  5707 1E 04        	LD E, 04 ; Out of DATA
1296  5709 C3 39 54     	JP THROW_ERROR
1297  570C              .L1:
1298  570C 32 F7 4C     	LD (SOUND_ENABLED), A
1299  570F              	; disable key click
1300  570F AF           	XOR A
1301  5710 32 DB F3     	LD (CLIKSW), A
1302  5713 C9           	RET
1303  5714              ; *******************************************************************************************************
1304  5714
1305  5714              ; *******************************************************************************************************
1306  5714              ; function to handle CALL SNDPLYOFF basic extension
1307  5714              ; disables sound player
1308  5714              ; _SNDPLYOFF
1309  5714              ; sets SOUND_ENABLED variable to 0
1310  5714              ; calls AKG to stop music and SFX on all channels if initialized
1311  5714              SNDPLYOFF:
1312  5714 3A F7 4C     	LD A, (SOUND_ENABLED)
1313  5717 B7           	OR A
1314  5718 C8           	RET Z ; already stopped
1315  5719 AF           	XOR A
1316  571A 32 F7 4C     	LD (SOUND_ENABLED), A
1317  571D E5           	PUSH HL
1318  571E CD 21 42     	CALL PLY_AKG_STOP
1319  5721 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1320  5724 B7           	OR A
1321  5725 28 0E        	JR Z, .EXIT ; SFX not in use
1322  5727 AF           	XOR A
1323  5728 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1324  572B 3E 01        	LD A, 1
1325  572D CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1326  5730 3E 02        	LD A, 2
1327  5732 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1328  5735              .EXIT:
1329  5735 E1           	POP HL
1330  5736 C9           	RET
1331  5737              ; *******************************************************************************************************
1332  5737
1333  5737              ; *******************************************************************************************************
1334  5737              ; function to handle CALL SNDSFX basic extension
1335  5737              ; plays a sound effect
1336  5737              ; _SNDSFX ( BYTE sfx_number, >0
1337  5737              ;			BYTE channel, = 0,1 or 2
1338  5737              ;			BYTE inverted_volume = 0-16, 0 being full volume
1339  5737              ; will put ram in page 0 also, page 1 is already there
1340  5737              ; if sound off throws illegal function call
1341  5737              ; if sfx not initialized, throws out of data
1342  5737              SNDSFX:
1343  5737              	; opening (
1344  5737 CD 19 54     	CALL CHKCHAR
1345  573A 28           	DB '('
1346  573B              	; get sfx_number
1347  573B DD 21 1C 52  	LD IX, GETBYT
1348  573F CD 59 01     	CALL CALBAS
1349  5742 D5           	PUSH DE
1350  5743              	; comma
1351  5743 CD 19 54     	CALL CHKCHAR
1352  5746 2C           	DB ','
1353  5747              	; get sfx address
1354  5747 DD 21 1C 52  	LD IX, GETBYT
1355  574B CD 59 01     	CALL CALBAS
1356  574E D5           	PUSH DE
1357  574F              	; comma
1358  574F CD 19 54     	CALL CHKCHAR
1359  5752 2C           	DB ','
1360  5753              	; get inverted volume
1361  5753 DD 21 1C 52  	LD IX, GETBYT
1362  5757 CD 59 01     	CALL CALBAS
1363  575A D5           	PUSH DE
1364  575B              	; ending )
1365  575B CD 19 54     	CALL CHKCHAR
1366  575E 29           	DB ')'
1367  575F
1368  575F 3A F7 4C     	LD A, (SOUND_ENABLED)
1369  5762 B7           	OR A
1370  5763 20 05        	JR NZ, .L1
1371  5765              	; sound disabled, throw illegal function call
1372  5765 1E 05        	LD E, 5
1373  5767 C3 39 54     	JP THROW_ERROR
1374  576A              .L1:
1375  576A 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1376  576D B7           	OR A
1377  576E 20 05        	JR NZ, .L2
1378  5770              	; sfx data not initialized, throw out of data
1379  5770 1E 04        	LD E, 4
1380  5772 C3 39 54     	JP THROW_ERROR
1381  5775              .L2:
1382  5775              	; pop  parameters and store away for later
1383  5775 D1           	POP DE ; inverted volume
1384  5776 43           	LD B, E
1385  5777 D1           	POP DE ; channel
1386  5778 4B           	LD C, E
1387  5779 D1           	POP DE
1388  577A 7B           	LD A, E
1389  577B 08           	EX AF, AF'
1390  577C E5           	PUSH HL ; basic text location
1391  577D D9           	EXX
1392  577E FD 21 85 57  	LD IY, .RET
1393  5782 C3 CC 53     	JP ENABLE_PAGE0
1394  5785              .RET:
1395  5785 D9           	EXX
1396  5786 08           	EX AF, AF'
1397  5787 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1398  578A
1399  578A D1               POP DE
1400  578B C1               POP BC
1401  578C CD 43 53         CALL RESTORE_PAGE_INFO
1402  578F
1403  578F E1           	POP HL
1404  5790 C9           	RET
1405  5791              ; *******************************************************************************************************
1406  5791               ENDIF
1407  5791
1408  5791               IF (BLIT_CMDS == 1)
1409  5791              ; *******************************************************************************************************
1410  5791              ; function rotates mask and data of several characters and applies to background data
1411  5791              ; this handles x-shift from 0 to 4
1412  5791              ; contains self-modifying code that is set-up from external function
1413  5791              ; input HL=pointer to mask data
1414  5791              ; input HL'=pointer to character data
1415  5791              ; input DE=output buffer containing background data
1416  5791              ; input BC=DE+8
1417  5791              ; input A=number of characters to process
1418  5791              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1419  5791              SHIFT04:
1420  5791 08           	EX AF, AF'
1421  5792 7E           	LD A, (HL) ; get mask
1422  5793 D9           	EXX
1423  5794 57           	LD D, A
1424  5795 1E FF        	LD E, #FF
1425  5797 37           	SCF
1426  5798              .M1:
1427  5798 18 FE        	JR .M1 ; this is self-modifying part
1428  579A CB 1A        	RR D
1429  579C CB 1B        	RR E
1430  579E CB 1A        	RR D
1431  57A0 CB 1B        	RR E
1432  57A2 CB 1A        	RR D
1433  57A4 CB 1B        	RR E
1434  57A6 CB 1A        	RR D
1435  57A8 CB 1B        	RR E
1436  57AA
1437  57AA 46           	LD B, (HL) ; get data
1438  57AB 0E 00        	LD C, 0
1439  57AD              .M2:
1440  57AD 18 FE        	JR .M2 ; also self-modifying part
1441  57AF CB 38        	SRL B
1442  57B1 CB 19        	RR C
1443  57B3 CB 38        	SRL B
1444  57B5 CB 19        	RR C
1445  57B7 CB 38        	SRL B
1446  57B9 CB 19        	RR C
1447  57BB CB 38        	SRL B
1448  57BD CB 19        	RR C
1449  57BF
1450  57BF D9           	EXX
1451  57C0 1A           	LD A, (DE) ; background
1452  57C1 D9           	EXX
1453  57C2 A2           	AND D
1454  57C3 B0           	OR B
1455  57C4 D9           	EXX
1456  57C5 12           	LD (DE), A
1457  57C6
1458  57C6 0A           	LD A, (BC)
1459  57C7 D9           	EXX
1460  57C8 A3           	AND E
1461  57C9 B1           	OR C
1462  57CA 23           	INC HL
1463  57CB D9           	EXX
1464  57CC 02           	LD (BC), A
1465  57CD
1466  57CD 23           	INC HL
1467  57CE 13           	INC DE
1468  57CF 03           	INC BC
1469  57D0
1470  57D0 08           	EX AF, AF'
1471  57D1 3D           	DEC A
1472  57D2 C2 91 57     	JP NZ, SHIFT04
1473  57D5 C9           	RET
1474  57D6              ; *******************************************************************************************************
1475  57D6
1476  57D6              ; *******************************************************************************************************
1477  57D6              ; function rotates mask and data of several characters and applies to background data
1478  57D6              ; this handles x-shift from 5 to 8
1479  57D6              ; contains self-modifying code that is set-up from external function
1480  57D6              ; input HL=pointer to mask data
1481  57D6              ; input HL'=pointer to character data
1482  57D6              ; input DE=output buffer containing background data
1483  57D6              ; input BC=DE+8
1484  57D6              ; input A=number of characters to process
1485  57D6              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1486  57D6              SHIFT58:
1487  57D6 08           	EX AF, AF'
1488  57D7 7E           	LD A, (HL) ; get mask
1489  57D8 D9           	EXX
1490  57D9 57           	LD D, A
1491  57DA 1E FF        	LD E, #FF
1492  57DC 37           	SCF
1493  57DD              .M1:
1494  57DD 18 FE        	JR .M1 ; this is self-modifying part
1495  57DF CB 12        	RL D
1496  57E1 CB 13        	RL E
1497  57E3 CB 12        	RL D
1498  57E5 CB 13        	RL E
1499  57E7 CB 12        	RL D
1500  57E9 CB 13        	RL E
1501  57EB
1502  57EB 46           	LD B, (HL)
1503  57EC 0E 00        	LD C, 0
1504  57EE              .M2:
1505  57EE 18 FE        	JR .M2 ; also self-modifying part
1506  57F0 CB 20        	SLA B
1507  57F2 CB 11        	RL C
1508  57F4 CB 20        	SLA B
1509  57F6 CB 11        	RL C
1510  57F8 CB 20        	SLA B
1511  57FA CB 11        	RL C
1512  57FC
1513  57FC D9           	EXX
1514  57FD 1A           	LD A, (DE) ; background
1515  57FE D9           	EXX
1516  57FF A3           	AND E
1517  5800 B1           	OR C
1518  5801 D9           	EXX
1519  5802 12           	LD (DE), A
1520  5803
1521  5803 0A           	LD A, (BC)
1522  5804 D9           	EXX
1523  5805 A2           	AND D
1524  5806 B0           	OR B
1525  5807 23           	INC HL
1526  5808 D9           	EXX
1527  5809 02           	LD (BC), A
1528  580A
1529  580A 23           	INC HL
1530  580B 13           	INC DE
1531  580C 03           	INC BC
1532  580D
1533  580D 08           	EX AF, AF'
1534  580E 3D           	DEC A
1535  580F C2 D6 57     	JP NZ, SHIFT58
1536  5812 C9           	RET
1537  5813              ; *******************************************************************************************************
1538  5813
1539  5813              ; *******************************************************************************************************
1540  5813              ; routine that shifts one row of characters
1541  5813              ; contains self-modifying code that is set-up from external function
1542  5813              ; input HL=pointer to mask data
1543  5813              ; input HL'=pointer to character data
1544  5813              ; input DE=output buffer containing background data
1545  5813              ; input A=number of characters to process
1546  5813              ; input IX=pointer to structure describing input data
1547  5813              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1548  5813              SHIFT_ROW:
1549  5813 F5           	PUSH AF
1550  5814 ED 53 9F 51  		LD (BLIT_TMP1), DE
1551  5818 E5           		PUSH HL
1552  5819 CD 5C 58     			CALL .ADDYSHIFT
1553  581C E1           		POP HL
1554  581D ED 53 A1 51  		LD (BLIT_TMP2), DE ; DE+vertical shift
1555  5821              .L1:
1556  5821 3E 08        		LD A, 8
1557  5823 DD 96 02     		SUB (IX+2) ; y shift
1558  5826              .CALL1:
1559  5826 CD 00 00     		CALL 0
1560  5829 DD 7E 02     		LD A, (IX+2); y shift
1561  582C B7           		OR A
1562  582D 28 26        		JR Z, .DONE
1563  582F ED 5B 9F 51  		LD DE, (BLIT_TMP1)
1564  5833 E5           		PUSH HL
1565  5834 CD 6A 58     			CALL .DETONEXTROW
1566  5837 E1           		POP HL
1567  5838              .CALL2:
1568  5838 CD 00 00     		CALL 0
1569  583B ED 5B 9F 51  		LD DE, (BLIT_TMP1)
1570  583F E5           		PUSH HL
1571  5840 CD 64 58     			CALL .ADD8
1572  5843 E1           		POP HL
1573  5844 ED 53 9F 51  		LD (BLIT_TMP1), DE
1574  5848 ED 5B A1 51  		LD DE, (BLIT_TMP2)
1575  584C E5           		PUSH HL
1576  584D CD 64 58     			CALL .ADD8
1577  5850 E1           		POP HL
1578  5851 ED 53 A1 51  		LD (BLIT_TMP2), DE ; DE+vertical shift
1579  5855              .DONE:
1580  5855 F1           	POP AF
1581  5856 3D           	DEC A
1582  5857 C8           	RET Z
1583  5858 F5           	PUSH AF
1584  5859 C3 21 58     	JP .L1
1585  585C              .ADDYSHIFT:
1586  585C EB           	EX DE, HL
1587  585D 16 00        	LD D, 0
1588  585F DD 5E 02     	LD E, (IX+2); y shift
1589  5862 18 0C        	JR .MOVDEBC
1590  5864              .ADD8:
1591  5864 21 08 00     	LD HL, 8
1592  5867 C3 70 58     	JP .MOVDEBC
1593  586A              .DETONEXTROW:
1594  586A DD 6E 06     	LD L, (IX+6)
1595  586D DD 66 07     	LD H, (IX+7) ; bkg add to value
1596  5870              .MOVDEBC:
1597  5870 19           	ADD HL, DE
1598  5871 54           	LD D, H
1599  5872 5D           	LD E, L
1600  5873 01 08 00     	LD BC, 8
1601  5876 09           	ADD HL, BC
1602  5877 44           	LD B, H
1603  5878 4D           	LD C, L
1604  5879 C9           	RET
1605  587A              ; *******************************************************************************************************
1606  587A
1607  587A              ; *******************************************************************************************************
1608  587A              ; function rotates mask and character data and applies it to background
1609  587A              ; input IX=pointer to structure describing input data
1610  587A              ; +0  DW horizontal shift count 0-7 (low byte used)
1611  587A              ; +2  DW vertical shift count 0-7 (low byte used)
1612  587A              ; +4  DW background data start;
1613  587A              ; +6  DW background add to value to next row of background data
1614  587A              ; +8  DW mask data start;
1615  587A              ; +10  DW character data start;
1616  587A              ; +12 DW character&mask add to value to next row of data
1617  587A              ; +14 DW columns (low byte used)
1618  587A              ; +16 DW rows (low byte used)
1619  587A              SHIFT_MERGE_CHARACTER:
1620  587A DD 7E 00     	LD A, (IX) ; shift
1621  587D FE 05        	CP 5
1622  587F 38 25        	JR C, .RIGHT
1623  5881              	; shifts 5-7, use rotate towards left 1-3
1624  5881 21 D6 57     	LD HL, SHIFT58
1625  5884 22 27 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1626  5887 22 39 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1627  588A D6 05        	SUB 5
1628  588C 28 0D        	JR Z, .L1
1629  588E 87           	ADD A, A
1630  588F 87           	ADD A, A
1631  5890 67           	LD H, A
1632  5891 2E 18        	LD L, #18 ; JR opcode
1633  5893 22 DD 57     	LD (SHIFT58.M1), HL
1634  5896 22 EE 57     	LD (SHIFT58.M2), HL
1635  5899 18 32        	JR .DO
1636  589B              .L1:
1637  589B 21 00 00     	LD HL, 0 ; 2xNOP opcode
1638  589E 22 DD 57     	LD (SHIFT58.M1), HL
1639  58A1 22 EE 57     	LD (SHIFT58.M2), HL
1640  58A4 18 27        	JR .DO
1641  58A6              .RIGHT:
1642  58A6              	; shifts 0-4, rotate towards right
1643  58A6 21 91 57     	LD HL, SHIFT04
1644  58A9 22 27 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1645  58AC 22 39 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1646  58AF FE 04        	CP 4
1647  58B1 28 11        	JR Z, .R1
1648  58B3 D6 04        	SUB 4
1649  58B5 ED 44        	NEG
1650  58B7 87           	ADD A, A
1651  58B8 87           	ADD A, A
1652  58B9 67           	LD H, A
1653  58BA 2E 18        	LD L, #18 ; JR opcode
1654  58BC 22 98 57     	LD (SHIFT04.M1), HL
1655  58BF 22 AD 57     	LD (SHIFT04.M2), HL
1656  58C2 18 09        	JR .DO
1657  58C4              .R1:
1658  58C4 21 00 00     	LD HL, 0 ; 2xNOP opcode
1659  58C7 22 98 57     	LD (SHIFT04.M1), HL
1660  58CA 22 AD 57     	LD (SHIFT04.M2), HL
1661  58CD              .DO:
1662  58CD DD 46 10     	LD B, (IX+16) ; rows
1663  58D0 DD 6E 08     	LD L, (IX+8)
1664  58D3 DD 66 09     	LD H, (IX+9) ; mask data
1665  58D6 DD 5E 04     	LD E, (IX+4)
1666  58D9 DD 56 05     	LD D, (IX+5) ; background data
1667  58DC D9           	EXX
1668  58DD DD 6E 0A     	LD L, (IX+10)
1669  58E0 DD 66 0B     	LD H, (IX+11) ; character data
1670  58E3 D9           	EXX
1671  58E4              .LOOP:
1672  58E4 C5           	PUSH BC
1673  58E5 E5           		PUSH HL
1674  58E6 D5           			PUSH DE
1675  58E7 D9           				EXX
1676  58E8 E5           				PUSH HL
1677  58E9 D9           					EXX
1678  58EA DD 7E 0E     					LD A, (IX+14) ; columns
1679  58ED              .CALL:
1680  58ED CD 13 58     					CALL SHIFT_ROW
1681  58F0 E1           				POP HL
1682  58F1 DD 5E 0C     				LD E, (IX+12)
1683  58F4 DD 56 0D     				LD D, (IX+13) ; char data to next row
1684  58F7 19           				ADD HL, DE
1685  58F8 D9           				EXX
1686  58F9 E1           			POP HL
1687  58FA DD 5E 06     			LD E, (IX+6)
1688  58FD DD 56 07     			LD D, (IX+7) ; background to next row
1689  5900 19           			ADD HL, DE
1690  5901 EB           			EX DE, HL
1691  5902 E1           		POP HL
1692  5903 DD 4E 0C     		LD C, (IX+12)
1693  5906 DD 46 0D     		LD B, (IX+13) ; char data to next row
1694  5909 09           		ADD HL, BC
1695  590A C1           	POP BC
1696  590B 10 D7        	DJNZ .LOOP
1697  590D C9           	RET
1698  590E              ; *******************************************************************************************************
1699  590E
1700  590E               IFNDEF CMDS_WITH_PARAMETERS
1701  590E ~            ; *******************************************************************************************************
1702  590E ~            ; function to handle CALL BLIT basic extension
1703  590E ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1704  590E ~            ; fuses with background data and applies vertical shift too
1705  590E ~            ; BLIT ( INT request_data_ptr )
1706  590E ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1707  590E ~            ; will put ram in page 0 also, page 1 is already there
1708  590E ~            BLIT:
1709  590E ~            	; opening (
1710  590E ~            	CALL CHKCHAR
1711  590E ~            	DB '('
1712  590E ~            	; get pointer to request struct
1713  590E ~            	LD IX, FRMQNT
1714  590E ~            	CALL CALBAS
1715  590E ~            	PUSH DE
1716  590E ~            	; ending )
1717  590E ~            	CALL CHKCHAR
1718  590E ~            	DB ')'
1719  590E ~
1720  590E ~            	POP IX ; pointer to request struct
1721  590E ~
1722  590E ~            	PUSH HL ; save position in BASIC buffer
1723  590E ~
1724  590E ~            	LD IY, .RET
1725  590E ~            	JP ENABLE_PAGE0
1726  590E ~            .RET:
1727  590E ~            	EI
1728  590E ~            	CALL SHIFT_MERGE_CHARACTER
1729  590E ~
1730  590E ~                POP DE
1731  590E ~                POP BC
1732  590E ~                CALL RESTORE_PAGE_INFO
1733  590E ~
1734  590E ~            	POP HL
1735  590E ~            	RET
1736  590E ~            ; *******************************************************************************************************
1737  590E               ENDIF
1738  590E
1739  590E               IFDEF CMDS_WITH_PARAMETERS
1740  590E              ; *******************************************************************************************************
1741  590E              ; function to handle CALL BLIT basic extension
1742  590E              ; rotates 1-bit character drawing horizontally with mask and character data and
1743  590E              ; fuses with background data and applies vertical shift too
1744  590E              ; in form without pointers
1745  590E              ; BLIT ( INT x,
1746  590E              ;		 INT y,
1747  590E              ;		 INT char_data_pointer,
1748  590E              ;		 INT mask_data_pointer,
1749  590E              ;		 INT width (in characters),
1750  590E              ;		 INT height (in characters),
1751  590E              ;		 INT background_pointer (top left),
1752  590E              ;		 INT background_width (in characters),
1753  590E              ;		 INT background_height (in characters))
1754  590E              ; will put ram in page 0 also, page 1 is already there
1755  590E              BLIT:
1756  590E              	; opening (
1757  590E CD 19 54     	CALL CHKCHAR
1758  5911 28           	DB '('
1759  5912              	; get x coordinate
1760  5912 DD 21 2F 54  	LD IX, FRMQNT
1761  5916 CD 59 01     	CALL CALBAS
1762  5919 7B           	LD A, E
1763  591A E6 07        	AND 7
1764  591C 32 A3 51     	LD (BLIT_STRUCT+0), A
1765  591F CD FC 59     	CALL .DAdiv8
1766  5922 32 9F 51     	LD (BLIT_TMP+0),A
1767  5925              	; comma
1768  5925 CD 19 54     	CALL CHKCHAR
1769  5928 2C           	DB ','
1770  5929              	; get y coordinate
1771  5929 DD 21 2F 54  	LD IX, FRMQNT
1772  592D CD 59 01     	CALL CALBAS
1773  5930 7B           	LD A, E
1774  5931 E6 07        	AND 7
1775  5933 32 A5 51     	LD (BLIT_STRUCT+2), A
1776  5936 CD FC 59     	CALL .DAdiv8
1777  5939 32 A0 51     	LD (BLIT_TMP+1),A
1778  593C              	; comma
1779  593C CD 19 54     	CALL CHKCHAR
1780  593F 2C           	DB ','
1781  5940              	; get char data pointer
1782  5940 DD 21 2F 54  	LD IX, FRMQNT
1783  5944 CD 59 01     	CALL CALBAS
1784  5947 ED 53 AD 51  	LD (BLIT_STRUCT+10), DE
1785  594B              	; comma
1786  594B CD 19 54     	CALL CHKCHAR
1787  594E 2C           	DB ','
1788  594F              	; get mask data pointer
1789  594F DD 21 2F 54  	LD IX, FRMQNT
1790  5953 CD 59 01     	CALL CALBAS
1791  5956 ED 53 AB 51  	LD (BLIT_STRUCT+8), DE
1792  595A              	; comma
1793  595A CD 19 54     	CALL CHKCHAR
1794  595D 2C           	DB ','
1795  595E              	; get width
1796  595E DD 21 2F 54  	LD IX, FRMQNT
1797  5962 CD 59 01     	CALL CALBAS
1798  5965 7B           	LD A, E
1799  5966 32 B1 51     	LD (BLIT_STRUCT+14), A
1800  5969              	; comma
1801  5969 CD 19 54     	CALL CHKCHAR
1802  596C 2C           	DB ','
1803  596D              	; get height
1804  596D DD 21 2F 54  	LD IX, FRMQNT
1805  5971 CD 59 01     	CALL CALBAS
1806  5974 7B           	LD A, E
1807  5975 32 B3 51     	LD (BLIT_STRUCT+16), A
1808  5978              	; comma
1809  5978 CD 19 54     	CALL CHKCHAR
1810  597B 2C           	DB ','
1811  597C              	; get background pointer
1812  597C DD 21 2F 54  	LD IX, FRMQNT
1813  5980 CD 59 01     	CALL CALBAS
1814  5983 ED 53 A7 51  	LD (BLIT_STRUCT+4), DE
1815  5987              	; comma
1816  5987 CD 19 54     	CALL CHKCHAR
1817  598A 2C           	DB ','
1818  598B              	; get background width
1819  598B DD 21 2F 54  	LD IX, FRMQNT
1820  598F CD 59 01     	CALL CALBAS
1821  5992 7B           	LD A, E
1822  5993 32 A1 51     	LD (BLIT_TMP+2), A
1823  5996              	; comma
1824  5996 CD 19 54     	CALL CHKCHAR
1825  5999 2C           	DB ','
1826  599A              	; get background height
1827  599A DD 21 2F 54  	LD IX, FRMQNT
1828  599E CD 59 01     	CALL CALBAS
1829  59A1 7B           	LD A, E
1830  59A2 32 A2 51     	LD (BLIT_TMP+3), A
1831  59A5              	; ending )
1832  59A5 CD 19 54     	CALL CHKCHAR
1833  59A8 29           	DB ')'
1834  59A9
1835  59A9 E5           	PUSH HL ; save position in BASIC buffer
1836  59AA
1837  59AA              	; calculate char&mask add to value
1838  59AA 26 00        	LD H, 0
1839  59AC 3A B1 51     	LD A, (BLIT_STRUCT+14)
1840  59AF 6F           	LD L, A
1841  59B0 CD 08 53     	CALL HLx8
1842  59B3 22 AF 51     	LD (BLIT_STRUCT+12), HL
1843  59B6              	; calculate background add to value
1844  59B6 26 00        	LD H, 0
1845  59B8 3A A1 51     	LD A, (BLIT_TMP+2)
1846  59BB 6F           	LD L, A
1847  59BC CD 08 53     	CALL HLx8
1848  59BF 22 A9 51     	LD (BLIT_STRUCT+6), HL
1849  59C2              	; calculate pointer to background location
1850  59C2 21 00 00     	LD HL, 0
1851  59C5 3A A0 51     	LD A,(BLIT_TMP+1)
1852  59C8 B7           	OR A
1853  59C9 28 08        	JR Z, .L1
1854  59CB 47           	LD B,A
1855  59CC ED 5B A9 51  	LD DE,(BLIT_STRUCT+6)
1856  59D0              .L0:
1857  59D0 19           	ADD HL, DE
1858  59D1 10 FD        	DJNZ .L0
1859  59D3              .L1:
1860  59D3 EB           	EX DE,HL
1861  59D4 26 00        	LD H,0
1862  59D6 3A 9F 51     	LD A,(BLIT_TMP+0)
1863  59D9 6F           	LD L,A
1864  59DA CD 08 53     	CALL HLx8
1865  59DD 19           	ADD HL,DE
1866  59DE ED 5B A7 51  	LD DE,(BLIT_STRUCT+4)
1867  59E2 19           	ADD HL,DE
1868  59E3 22 A7 51     	LD (BLIT_STRUCT+4),HL
1869  59E6
1870  59E6 FD 21 ED 59  	LD IY, .RET
1871  59EA C3 CC 53     	JP ENABLE_PAGE0
1872  59ED              .RET:
1873  59ED FB           	EI
1874  59EE DD 21 A3 51  	LD IX, BLIT_STRUCT
1875  59F2 CD 7A 58     	CALL SHIFT_MERGE_CHARACTER
1876  59F5
1877  59F5 D1               POP DE
1878  59F6 C1               POP BC
1879  59F7 CD 43 53         CALL RESTORE_PAGE_INFO
1880  59FA
1881  59FA E1           	POP HL
1882  59FB C9           	RET
1883  59FC              .DAdiv8:
1884  59FC 7B           	LD A,E
1885  59FD CB 2A        	SRA D
1886  59FF CB 1F            RR  A
1887  5A01 CB 2A            SRA D
1888  5A03 CB 1F            RR  A
1889  5A05 CB 2A            SRA D
1890  5A07 CB 1F            RR  A
1891  5A09 C9           	RET
1892  5A0A              ; *******************************************************************************************************
1893  5A0A               ENDIF
1894  5A0A               ENDIF
1895  5A0A
1896  5A0A               IF (TILE_CMDS == 1)
1897  5A0A              ; *******************************************************************************************************
1898  5A0A              ; generic function to implement tiling
1899  5A0A              ; should be modified to call appropriate function for memory or vram
1900  5A0A              ; input IX=pointer to following structure
1901  5A0A              ; +00 tile_data_ptr
1902  5A0A              ; +02 tile_rows
1903  5A0A              ; +04 tile_columns
1904  5A0A              ; +06 destination_address
1905  5A0A              ; +08 dest_to_next_row_add_to_value
1906  5A0A              ; +10 num_horizontal_tiles
1907  5A0A              ; +12 num_vertical_tiles
1908  5A0A              ; modifies AF, BC, DE, HL
1909  5A0A              TILE:
1910  5A0A DD 6E 06     	LD L, (IX+6)
1911  5A0D DD 66 07     	LD H, (IX+7) ; destination address
1912  5A10 22 9F 51     	LD (TILETMP1), HL
1913  5A13 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1914  5A16              .L1:
1915  5A16 C5           	PUSH BC
1916  5A17 DD 6E 00     		LD L, (IX+0)
1917  5A1A DD 66 01     		LD H, (IX+1) ; tile address
1918  5A1D 22 A1 51     		LD (TILETMP2), HL
1919  5A20 DD 46 02     		LD B, (IX+2) ; tile rows
1920  5A23              .L2:
1921  5A23 C5           		PUSH BC
1922  5A24              .CALL1:
1923  5A24 CD 00 00     			CALL 0
1924  5A27 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1925  5A2A              .L3:
1926  5A2A C5           			PUSH BC
1927  5A2B 2A A1 51     				LD HL, (TILETMP2)
1928  5A2E DD 46 04     				LD B, (IX+4) ; tile columns
1929  5A31              .L4:
1930  5A31 C5           				PUSH BC
1931  5A32              .CALL2:
1932  5A32 CD 00 00     					CALL 0
1933  5A35 C1           				POP BC
1934  5A36 10 F9        				DJNZ .L4
1935  5A38 C1           			POP BC
1936  5A39 10 EF        			DJNZ .L3
1937  5A3B 22 A1 51     			LD (TILETMP2), HL
1938  5A3E 2A 9F 51     			LD HL, (TILETMP1)
1939  5A41 DD 5E 08     			LD E, (IX+8)
1940  5A44 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1941  5A47 19           			ADD HL, DE
1942  5A48 22 9F 51     			LD (TILETMP1), HL
1943  5A4B C1           		POP BC
1944  5A4C 10 D5        		DJNZ .L2
1945  5A4E C1           	POP BC
1946  5A4F 10 C5        	DJNZ .L1
1947  5A51 C9           	RET
1948  5A52              ; *******************************************************************************************************
1949  5A52
1950  5A52               IFNDEF CMDS_WITH_PARAMETERS
1951  5A52 ~            ; *******************************************************************************************************
1952  5A52 ~            ; function to handle CALL TILERAM basic extension
1953  5A52 ~            ; fills memory with tiles
1954  5A52 ~            ; TILERAM ( INT request_data_ptr )
1955  5A52 ~            ; request_data_ptr described in TILE
1956  5A52 ~            ; will put ram in page 0 also, page 1 is already there
1957  5A52 ~            TILERAM:
1958  5A52 ~            	; opening (
1959  5A52 ~            	CALL CHKCHAR
1960  5A52 ~            	DB '('
1961  5A52 ~            	; get pointer to request struct
1962  5A52 ~            	LD IX, FRMQNT
1963  5A52 ~            	CALL CALBAS
1964  5A52 ~            	PUSH DE
1965  5A52 ~            	; ending )
1966  5A52 ~            	CALL CHKCHAR
1967  5A52 ~            	DB ')'
1968  5A52 ~
1969  5A52 ~            	POP IX ; pointer to request struct
1970  5A52 ~
1971  5A52 ~            	PUSH HL ; save position in BASIC buffer
1972  5A52 ~
1973  5A52 ~            	LD IY, .RET
1974  5A52 ~            	JP ENABLE_PAGE0
1975  5A52 ~            .RET:
1976  5A52 ~            	EI
1977  5A52 ~            	; set RAM functions to call
1978  5A52 ~            	LD HL, .TILECOPY
1979  5A52 ~            	LD (TILE.CALL2+1), HL
1980  5A52 ~            	LD HL, .SETDESTROW
1981  5A52 ~            	LD (TILE.CALL1+1), HL
1982  5A52 ~            	CALL TILE
1983  5A52 ~
1984  5A52 ~                POP DE
1985  5A52 ~                POP BC
1986  5A52 ~                CALL RESTORE_PAGE_INFO
1987  5A52 ~
1988  5A52 ~            	POP HL
1989  5A52 ~            	RET
1990  5A52 ~            .TILECOPY:
1991  5A52 ~            	.8 LDI
1992  5A52 ~            	RET
1993  5A52 ~            .SETDESTROW:
1994  5A52 ~            	LD DE, (TILETMP1)
1995  5A52 ~            	RET
1996  5A52 ~            ; *******************************************************************************************************
1997  5A52               ENDIF
1998  5A52
1999  5A52               IFDEF CMDS_WITH_PARAMETERS
2000  5A52              ; *******************************************************************************************************
2001  5A52              ; function to handle CALL TILERAM basic extension
2002  5A52              ; fills memory with tiles
2003  5A52              ; TILERAM ( INT tile_data_pointer,
2004  5A52              ;			INT tile_columns,
2005  5A52              ;			INT tile_rows,
2006  5A52              ;			INT destination_pointer,
2007  5A52              ;			INT destination_columns,
2008  5A52              ;			INT destination_rows,
2009  5A52              ;			INT destination_begin_column,
2010  5A52              ;			INT destination_begin_row,
2011  5A52              ;			INT number_of_tiles_horizontally,
2012  5A52              ;			INT	number_of_tiles_vertically )
2013  5A52              ; will put ram in page 0 also, page 1 is already there
2014  5A52              TILERAM:
2015  5A52              	; opening (
2016  5A52 CD 19 54     	CALL CHKCHAR
2017  5A55 28           	DB '('
2018  5A56              	; get tile data pointer coordinate
2019  5A56 DD 21 2F 54  	LD IX, FRMQNT
2020  5A5A CD 59 01     	CALL CALBAS
2021  5A5D ED 53 A3 51  	LD (BLIT_STRUCT+0), DE
2022  5A61              	; comma
2023  5A61 CD 19 54     	CALL CHKCHAR
2024  5A64 2C           	DB ','
2025  5A65              	; get tile columns
2026  5A65 DD 21 2F 54  	LD IX, FRMQNT
2027  5A69 CD 59 01     	CALL CALBAS
2028  5A6C ED 53 A7 51  	LD (BLIT_STRUCT+4), DE
2029  5A70              	; comma
2030  5A70 CD 19 54     	CALL CHKCHAR
2031  5A73 2C           	DB ','
2032  5A74              	; get tile columns
2033  5A74 DD 21 2F 54  	LD IX, FRMQNT
2034  5A78 CD 59 01     	CALL CALBAS
2035  5A7B ED 53 A5 51  	LD (BLIT_STRUCT+2), DE
2036  5A7F              	; comma
2037  5A7F CD 19 54     	CALL CHKCHAR
2038  5A82 2C           	DB ','
2039  5A83              	; get destintion pointer
2040  5A83 DD 21 2F 54  	LD IX, FRMQNT
2041  5A87 CD 59 01     	CALL CALBAS
2042  5A8A ED 53 A9 51  	LD (BLIT_STRUCT+6), DE
2043  5A8E              	; comma
2044  5A8E CD 19 54     	CALL CHKCHAR
2045  5A91 2C           	DB ','
2046  5A92              	; get destination columns
2047  5A92 DD 21 2F 54  	LD IX, FRMQNT
2048  5A96 CD 59 01     	CALL CALBAS
2049  5A99 7B           	LD A, E
2050  5A9A 32 9F 51     	LD (BLIT_TMP+0), A
2051  5A9D              	; comma
2052  5A9D CD 19 54     	CALL CHKCHAR
2053  5AA0 2C           	DB ','
2054  5AA1              	; get destination rows
2055  5AA1 DD 21 2F 54  	LD IX, FRMQNT
2056  5AA5 CD 59 01     	CALL CALBAS
2057  5AA8 7B           	LD A, E
2058  5AA9 32 A0 51     	LD (BLIT_TMP+1), A
2059  5AAC              	; comma
2060  5AAC CD 19 54     	CALL CHKCHAR
2061  5AAF 2C           	DB ','
2062  5AB0              	; get destination begin column
2063  5AB0 DD 21 2F 54  	LD IX, FRMQNT
2064  5AB4 CD 59 01     	CALL CALBAS
2065  5AB7 7B           	LD A, E
2066  5AB8 32 A1 51     	LD (BLIT_TMP+2), A
2067  5ABB              	; comma
2068  5ABB CD 19 54     	CALL CHKCHAR
2069  5ABE 2C           	DB ','
2070  5ABF              	; get destination begin row
2071  5ABF DD 21 2F 54  	LD IX, FRMQNT
2072  5AC3 CD 59 01     	CALL CALBAS
2073  5AC6 7B           	LD A, E
2074  5AC7 32 A2 51     	LD (BLIT_TMP+3), A
2075  5ACA              	; comma
2076  5ACA CD 19 54     	CALL CHKCHAR
2077  5ACD 2C           	DB ','
2078  5ACE              	; get number of tiles horizontally
2079  5ACE DD 21 2F 54  	LD IX, FRMQNT
2080  5AD2 CD 59 01     	CALL CALBAS
2081  5AD5 ED 53 AD 51  	LD (BLIT_STRUCT+10), DE
2082  5AD9              	; comma
2083  5AD9 CD 19 54     	CALL CHKCHAR
2084  5ADC 2C           	DB ','
2085  5ADD              	; get number of tiles vertically
2086  5ADD DD 21 2F 54  	LD IX, FRMQNT
2087  5AE1 CD 59 01     	CALL CALBAS
2088  5AE4 ED 53 AF 51  	LD (BLIT_STRUCT+12), DE
2089  5AE8              	; ending )
2090  5AE8 CD 19 54     	CALL CHKCHAR
2091  5AEB 29           	DB ')'
2092  5AEC
2093  5AEC E5           	PUSH HL ; save position in BASIC buffer
2094  5AED
2095  5AED              	; calculate destination add to value
2096  5AED 26 00        	LD H, 0
2097  5AEF 3A 9F 51     	LD A, (BLIT_TMP+0)
2098  5AF2 6F           	LD L, A
2099  5AF3 CD 08 53     	CALL HLx8
2100  5AF6 22 AB 51     	LD (BLIT_STRUCT+8), HL
2101  5AF9              	; calculate pointer to background location
2102  5AF9 21 00 00     	LD HL, 0
2103  5AFC 3A A2 51     	LD A,(BLIT_TMP+3)
2104  5AFF B7           	OR A
2105  5B00 28 08        	JR Z, .L1
2106  5B02 47           	LD B,A
2107  5B03 ED 5B AB 51  	LD DE,(BLIT_STRUCT+8)
2108  5B07              .L0:
2109  5B07 19           	ADD HL, DE
2110  5B08 10 FD        	DJNZ .L0
2111  5B0A              .L1:
2112  5B0A EB           	EX DE,HL
2113  5B0B 26 00        	LD H,0
2114  5B0D 3A A1 51     	LD A,(BLIT_TMP+2)
2115  5B10 6F           	LD L,A
2116  5B11 CD 08 53     	CALL HLx8
2117  5B14 19           	ADD HL,DE
2118  5B15 ED 5B A9 51  	LD DE,(BLIT_STRUCT+6)
2119  5B19 19           	ADD HL,DE
2120  5B1A 22 A9 51     	LD (BLIT_STRUCT+6),HL
2121  5B1D
2122  5B1D FD 21 24 5B  	LD IY, .RET
2123  5B21 C3 CC 53     	JP ENABLE_PAGE0
2124  5B24              .RET:
2125  5B24 FB           	EI
2126  5B25              	; set RAM functions to call
2127  5B25 21 3F 5B     	LD HL, .TILECOPY
2128  5B28 22 33 5A     	LD (TILE.CALL2+1), HL
2129  5B2B 21 50 5B     	LD HL, .SETDESTROW
2130  5B2E 22 25 5A     	LD (TILE.CALL1+1), HL
2131  5B31 DD 21 A3 51  	LD IX,BLIT_STRUCT
2132  5B35 CD 0A 5A     	CALL TILE
2133  5B38
2134  5B38 D1               POP DE
2135  5B39 C1               POP BC
2136  5B3A CD 43 53         CALL RESTORE_PAGE_INFO
2137  5B3D
2138  5B3D E1           	POP HL
2139  5B3E C9           	RET
2140  5B3F              .TILECOPY:
2141  5B3F ED A0       > LDI
2141  5B41 ED A0       > LDI
2141  5B43 ED A0       > LDI
2141  5B45 ED A0       > LDI
2141  5B47 ED A0       > LDI
2141  5B49 ED A0       > LDI
2141  5B4B ED A0       > LDI
2141  5B4D ED A0       > LDI
2142  5B4F C9           	RET
2143  5B50              .SETDESTROW:
2144  5B50 ED 5B 9F 51  	LD DE, (TILETMP1)
2145  5B54 C9           	RET
2146  5B55              ; *******************************************************************************************************
2147  5B55               ENDIF
2148  5B55
2149  5B55               IFDEF CMDS_WITH_PARAMETERS
2150  5B55              ; *******************************************************************************************************
2151  5B55              ; function to handle CALL TILEVRM basic extension
2152  5B55              ; fills vram with tiles
2153  5B55              ; TILEVRM ( INT tile_data_pointer,
2154  5B55              ;			INT tile_columns,
2155  5B55              ;			INT tile_rows,
2156  5B55              ;			INT destination_begin_column,
2157  5B55              ;			INT destination_begin_row,
2158  5B55              ;			INT number_of_tiles_horizontally,
2159  5B55              ;			INT	number_of_tiles_vertically )
2160  5B55              ; will put ram in page 0 also, page 1 is already there
2161  5B55              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2162  5B55              TILEVRM:
2163  5B55              	; opening (
2164  5B55 CD 19 54     	CALL CHKCHAR
2165  5B58 28           	DB '('
2166  5B59              	; get tile data pointer coordinate
2167  5B59 DD 21 2F 54  	LD IX, FRMQNT
2168  5B5D CD 59 01     	CALL CALBAS
2169  5B60 ED 53 A3 51  	LD (BLIT_STRUCT+0), DE
2170  5B64              	; comma
2171  5B64 CD 19 54     	CALL CHKCHAR
2172  5B67 2C           	DB ','
2173  5B68              	; get tile columns
2174  5B68 DD 21 2F 54  	LD IX, FRMQNT
2175  5B6C CD 59 01     	CALL CALBAS
2176  5B6F ED 53 A7 51  	LD (BLIT_STRUCT+4), DE
2177  5B73              	; comma
2178  5B73 CD 19 54     	CALL CHKCHAR
2179  5B76 2C           	DB ','
2180  5B77              	; get tile columns
2181  5B77 DD 21 2F 54  	LD IX, FRMQNT
2182  5B7B CD 59 01     	CALL CALBAS
2183  5B7E ED 53 A5 51  	LD (BLIT_STRUCT+2), DE
2184  5B82              	; comma
2185  5B82 CD 19 54     	CALL CHKCHAR
2186  5B85 2C           	DB ','
2187  5B86              	; get destination begin column
2188  5B86 DD 21 2F 54  	LD IX, FRMQNT
2189  5B8A CD 59 01     	CALL CALBAS
2190  5B8D 7B           	LD A, E
2191  5B8E 32 A1 51     	LD (BLIT_TMP+2), A
2192  5B91              	; comma
2193  5B91 CD 19 54     	CALL CHKCHAR
2194  5B94 2C           	DB ','
2195  5B95              	; get destination begin row
2196  5B95 DD 21 2F 54  	LD IX, FRMQNT
2197  5B99 CD 59 01     	CALL CALBAS
2198  5B9C 7B           	LD A, E
2199  5B9D 32 A2 51     	LD (BLIT_TMP+3), A
2200  5BA0              	; comma
2201  5BA0 CD 19 54     	CALL CHKCHAR
2202  5BA3 2C           	DB ','
2203  5BA4              	; get number of tiles horizontally
2204  5BA4 DD 21 2F 54  	LD IX, FRMQNT
2205  5BA8 CD 59 01     	CALL CALBAS
2206  5BAB ED 53 AD 51  	LD (BLIT_STRUCT+10), DE
2207  5BAF              	; comma
2208  5BAF CD 19 54     	CALL CHKCHAR
2209  5BB2 2C           	DB ','
2210  5BB3              	; get number of tiles vertically
2211  5BB3 DD 21 2F 54  	LD IX, FRMQNT
2212  5BB7 CD 59 01     	CALL CALBAS
2213  5BBA ED 53 AF 51  	LD (BLIT_STRUCT+12), DE
2214  5BBE              	; ending )
2215  5BBE CD 19 54     	CALL CHKCHAR
2216  5BC1 29           	DB ')'
2217  5BC2
2218  5BC2 E5           	PUSH HL ; save position in BASIC buffer
2219  5BC3
2220  5BC3              	; calculate destination add to value
2221  5BC3 21 00 01     	LD HL, 256
2222  5BC6 22 AB 51     	LD (BLIT_STRUCT+8), HL
2223  5BC9              	; calculate pointer to background location
2224  5BC9 3A A2 51     	LD A,(BLIT_TMP+3)
2225  5BCC 67           	LD H,A
2226  5BCD 2E 00        	LD L,0
2227  5BCF EB           	EX DE,HL
2228  5BD0 26 00        	LD H,0
2229  5BD2 3A A1 51     	LD A,(BLIT_TMP+2)
2230  5BD5 6F           	LD L,A
2231  5BD6 CD 08 53     	CALL HLx8
2232  5BD9 19           	ADD HL,DE
2233  5BDA ED 5B CB F3  	LD DE,(GRPCGP)
2234  5BDE 19           	ADD HL,DE
2235  5BDF 22 A9 51     	LD (BLIT_STRUCT+6),HL
2236  5BE2
2237  5BE2 FD 21 E9 5B  	LD IY, .RET
2238  5BE6 C3 CC 53     	JP ENABLE_PAGE0
2239  5BE9              .RET:
2240  5BE9 FB           	EI
2241  5BEA              	; set RAM functions to call
2242  5BEA 21 04 5C     	LD HL, .TILECOPY
2243  5BED 22 33 5A     	LD (TILE.CALL2+1), HL
2244  5BF0 21 0A 5C     	LD HL, .SETDESTROW
2245  5BF3 22 25 5A     	LD (TILE.CALL1+1), HL
2246  5BF6 DD 21 A3 51  	LD IX,BLIT_STRUCT
2247  5BFA CD 0A 5A     	CALL TILE
2248  5BFD
2249  5BFD D1               POP DE
2250  5BFE C1               POP BC
2251  5BFF CD 43 53         CALL RESTORE_PAGE_INFO
2252  5C02
2253  5C02 E1           	POP HL
2254  5C03 C9           	RET
2255  5C04              .TILECOPY:
2256  5C04 01 98 08     	LD BC, #0898
2257  5C07 C3 01 53     	JP BBYTECOPY
2258  5C0A              .SETDESTROW:
2259  5C0A 2A 9F 51     	LD HL, (TILETMP1)
2260  5C0D F3           	DI
2261  5C0E CD F6 52     	CALL SETWRT_LOCAL
2262  5C11 FB           	EI
2263  5C12 C9           	RET
2264  5C13              ; *******************************************************************************************************
2265  5C13               ENDIF
2266  5C13
2267  5C13               IFNDEF CMDS_WITH_PARAMETERS
2268  5C13 ~            ; *******************************************************************************************************
2269  5C13 ~            ; function to handle CALL TILEVRM basic extension
2270  5C13 ~            ; fills vram with tiles
2271  5C13 ~            ; TILEVRM ( INT request_data_ptr )
2272  5C13 ~            ; request_data_ptr described in TILE
2273  5C13 ~            ; will put ram in page 0 also, page 1 is already there
2274  5C13 ~            TILEVRM:
2275  5C13 ~            	; opening (
2276  5C13 ~            	CALL CHKCHAR
2277  5C13 ~            	DB '('
2278  5C13 ~            	; get pointer to request struct
2279  5C13 ~            	LD IX, FRMQNT
2280  5C13 ~            	CALL CALBAS
2281  5C13 ~            	PUSH DE
2282  5C13 ~            	; ending )
2283  5C13 ~            	CALL CHKCHAR
2284  5C13 ~            	DB ')'
2285  5C13 ~
2286  5C13 ~            	POP IX ; pointer to request struct
2287  5C13 ~
2288  5C13 ~            	PUSH HL ; save position in BASIC buffer
2289  5C13 ~
2290  5C13 ~            	LD IY, .RET
2291  5C13 ~            	JP ENABLE_PAGE0
2292  5C13 ~            .RET:
2293  5C13 ~            	EI
2294  5C13 ~            	; set RAM functions to call
2295  5C13 ~            	LD HL, .TILECOPY
2296  5C13 ~            	LD (TILE.CALL2+1), HL
2297  5C13 ~            	LD HL, .SETDESTROW
2298  5C13 ~            	LD (TILE.CALL1+1), HL
2299  5C13 ~            	CALL TILE
2300  5C13 ~
2301  5C13 ~                POP DE
2302  5C13 ~                POP BC
2303  5C13 ~                CALL RESTORE_PAGE_INFO
2304  5C13 ~
2305  5C13 ~            	POP HL
2306  5C13 ~            	RET
2307  5C13 ~            .TILECOPY:
2308  5C13 ~            	LD BC, #0898
2309  5C13 ~            	JP BBYTECOPY
2310  5C13 ~            .SETDESTROW:
2311  5C13 ~            	LD HL, (TILETMP1)
2312  5C13 ~            	DI
2313  5C13 ~            	CALL SETWRT_LOCAL
2314  5C13 ~            	EI
2315  5C13 ~            	RET
2316  5C13 ~            ; *******************************************************************************************************
2317  5C13               ENDIF
2318  5C13               ENDIF
2319  5C13
2320  5C13               IF (BOX_CMDS == 1)
2321  5C13              ; *******************************************************************************************************
2322  5C13              ; generic function to implement rectangle data copy
2323  5C13              ; should be modified to call appropriate function for memory or vram
2324  5C13              ; input IX=pointer to following structure
2325  5C13              ; +00 source data pointer
2326  5C13              ; +02 num bytes in a row
2327  5C13              ; +04 number of rows
2328  5C13              ; +06 source add-to value till next row
2329  5C13              ; +08 destination address
2330  5C13              ; +10 destination add-to value till next row
2331  5C13              ; modifies AF, BC, DE, HL
2332  5C13              RECTANGLE_COPY:
2333  5C13 DD 6E 00     	LD L, (IX+0)
2334  5C16 DD 66 01     	LD H, (IX+1) ; source address
2335  5C19 DD 5E 08     	LD E, (IX+8)
2336  5C1C DD 56 09     	LD D, (IX+9) ; destination
2337  5C1F DD 46 04     	LD B, (IX+4) ; row number
2338  5C22              .L1:
2339  5C22 C5           	PUSH BC
2340  5C23 E5           		PUSH HL
2341  5C24 D5           			PUSH DE
2342  5C25 DD 4E 02     				LD C, (IX+2)
2343  5C28 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2344  5C2B              .CALL1:
2345  5C2B CD 00 00     				CALL 0 ; set destination address from DE
2346  5C2E              .CALL2:
2347  5C2E CD 00 00     				CALL 0 ; copy data fn
2348  5C31 E1           			POP HL
2349  5C32 DD 4E 0A     			LD C, (IX+10)
2350  5C35 DD 46 0B     			LD B, (IX+11) ; destination add-to
2351  5C38 09           			ADD HL, BC
2352  5C39 EB           			EX DE, HL
2353  5C3A E1           		POP HL
2354  5C3B DD 4E 06     		LD C, (IX+6)
2355  5C3E DD 46 07     		LD B, (IX+7) ; src add-to
2356  5C41 09           		ADD HL, BC
2357  5C42 C1           	POP BC
2358  5C43 10 DD        	DJNZ .L1
2359  5C45 C9           	RET
2360  5C46              ; *******************************************************************************************************
2361  5C46
2362  5C46              ; *******************************************************************************************************
2363  5C46              ; function to handle CALL BOXMEMCPY basic extension
2364  5C46              ; copies data with window like boundaries to ram
2365  5C46              ; BOXMEMCPY ( INT request_data_ptr )
2366  5C46              ; request_data_ptr described in RECTANGLE_COPY
2367  5C46              ; will put ram in page 0 also, page 1 is already there
2368  5C46              BOXMEMCPY:
2369  5C46              	; opening (
2370  5C46 CD 19 54     	CALL CHKCHAR
2371  5C49 28           	DB '('
2372  5C4A              	; get pointer to request struct
2373  5C4A DD 21 2F 54  	LD IX, FRMQNT
2374  5C4E CD 59 01     	CALL CALBAS
2375  5C51 D5           	PUSH DE
2376  5C52              	; ending )
2377  5C52 CD 19 54     	CALL CHKCHAR
2378  5C55 29           	DB ')'
2379  5C56
2380  5C56 DD E1        	POP IX ; pointer to request struct
2381  5C58
2382  5C58 E5           	PUSH HL ; save position in BASIC buffer
2383  5C59
2384  5C59 FD 21 60 5C  	LD IY, .RET
2385  5C5D C3 CC 53     	JP ENABLE_PAGE0
2386  5C60              .RET:
2387  5C60 FB           	EI
2388  5C61              	; set RAM functions to call
2389  5C61 21 00 00     	LD HL, 0
2390  5C64 22 2B 5C     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2391  5C67 22 2D 5C     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2392  5C6A 21 ED B0     	LD HL, #B0ED ; LDIR
2393  5C6D 22 2F 5C     	LD (RECTANGLE_COPY.CALL1+4), HL
2394  5C70 CD 13 5C     	CALL RECTANGLE_COPY
2395  5C73
2396  5C73 D1               POP DE
2397  5C74 C1               POP BC
2398  5C75 CD 43 53         CALL RESTORE_PAGE_INFO
2399  5C78
2400  5C78 E1           	POP HL
2401  5C79 C9           	RET
2402  5C7A              ; *******************************************************************************************************
2403  5C7A
2404  5C7A              ; *******************************************************************************************************
2405  5C7A              ; function to handle CALL BOXMEMVRM basic extension
2406  5C7A              ; copies data with window like boundaries to ram
2407  5C7A              ; BOXMEMVRM ( INT request_data_ptr )
2408  5C7A              ; request_data_ptr described in RECTANGLE_COPY
2409  5C7A              ; will put ram in page 0 also, page 1 is already there
2410  5C7A              BOXMEMVRM:
2411  5C7A              	; opening (
2412  5C7A CD 19 54     	CALL CHKCHAR
2413  5C7D 28           	DB '('
2414  5C7E              	; get pointer to request struct
2415  5C7E DD 21 2F 54  	LD IX, FRMQNT
2416  5C82 CD 59 01     	CALL CALBAS
2417  5C85 D5           	PUSH DE
2418  5C86              	; ending )
2419  5C86 CD 19 54     	CALL CHKCHAR
2420  5C89 29           	DB ')'
2421  5C8A
2422  5C8A DD E1        	POP IX ; pointer to request struct
2423  5C8C
2424  5C8C E5           	PUSH HL ; save position in BASIC buffer
2425  5C8D
2426  5C8D FD 21 94 5C  	LD IY, .RET
2427  5C91 C3 CC 53     	JP ENABLE_PAGE0
2428  5C94              .RET:
2429  5C94 FB           	EI
2430  5C95              	; set RAM functions to call
2431  5C95 21 B3 5C     	LD HL, .SETDEST
2432  5C98 22 2C 5C     	LD (RECTANGLE_COPY.CALL1+1), HL
2433  5C9B 21 BB 5C     	LD HL, .COPYDATA
2434  5C9E 22 2F 5C     	LD (RECTANGLE_COPY.CALL2+1), HL
2435  5CA1 3E CD        	LD A, #CD ; CALL
2436  5CA3 32 2B 5C     	LD (RECTANGLE_COPY.CALL1), A
2437  5CA6 32 2E 5C     	LD (RECTANGLE_COPY.CALL2), A
2438  5CA9 CD 13 5C     	CALL RECTANGLE_COPY
2439  5CAC
2440  5CAC D1               POP DE
2441  5CAD C1               POP BC
2442  5CAE CD 43 53         CALL RESTORE_PAGE_INFO
2443  5CB1
2444  5CB1 E1           	POP HL
2445  5CB2 C9           	RET
2446  5CB3              .SETDEST:
2447  5CB3 EB           	EX DE, HL
2448  5CB4 F3           	DI
2449  5CB5 CD F6 52     	CALL SETWRT_LOCAL
2450  5CB8 FB           	EI
2451  5CB9 EB           	EX DE, HL
2452  5CBA C9           	RET
2453  5CBB              .COPYDATA:
2454  5CBB 41           	LD B, C
2455  5CBC 0E 98        	LD C, #98
2456  5CBE C3 01 53     	JP BBYTECOPY
2457  5CC1              ; *******************************************************************************************************
2458  5CC1               ENDIF
2459  5CC1
2460  5CC1              EXT_END:
2461  5CC1
# file closed: asm\main.asm
