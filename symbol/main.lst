# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; DEFINE EXCLUDE_SOUND_PLAYER
   4  4000              ; DEFINE EXCLUDE_RAM_CMDS
   5  4000              ; DEFINE EXCLUDE_VRAM_CMDS
   6  4000              ; DEFINE EXCLUDE_BLIT_CMDS
   7  4000              ; DEFINE EXCLUDE_SPRITE_CMDS
   8  4000              ; DEFINE EXCLUDE_GENCAL
   9  4000
  10  4000               ;DEFINE BLIT_WITH_STRUCT_POINTER
  11  4000               DEFINE BLIT_WITH_PARAMETERS
  12  4000
  13  4000              CHPUT   EQU     #A2
  14  4000              CALBAS	EQU		#159
  15  4000              ERRHAND EQU     #406F
  16  4000              FRMEVL  EQU     #4C64
  17  4000              FRESTR	EQU		#67D0
  18  4000              ; FRMQNT = formula quantificator
  19  4000              ; input HL=pointer to current program expression
  20  4000              ; output HL=next address
  21  4000              ; output DE=integer datum
  22  4000              FRMQNT	EQU		#542F
  23  4000              ; GETBYT = get byte parameter
  24  4000              ; input HL=pointer to current program expression
  25  4000              ; output HL=next address
  26  4000              ; output A=E=byte read
  27  4000              GETBYT	EQU		#521C
  28  4000              CHRGTR  EQU     #4666
  29  4000              SYNCHR	EQU		#558C
  30  4000              VALTYP  EQU     #F663
  31  4000              USR     EQU     #F7F8
  32  4000              PROCNM	EQU		#FD89
  33  4000              BIOS_FILVRM  EQU     #56
  34  4000              CLIKSW	EQU		#F3DB
  35  4000              ATRBAS	EQU		#F928
  36  4000
  37  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  38  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  39  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  40  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  41  4000              EXPTBL	EQU #FCC1
  42  4000              SCRMOD	EQU #FCAF ; current screen mode
  43  4000              REG1SAV EQU #F3E0 ; VDP(1)
  44  4000
  45  4000              ; BASIC error codes
  46  4000              ;01 NEXT without FOR
  47  4000              ;02 Syntax error
  48  4000              ;03 RETURN without GOSUB
  49  4000              ;04 Out of DATA
  50  4000              ;05 Illegal function call
  51  4000              ;06 Overflow
  52  4000              ;07 Out of memory
  53  4000              ;08 Undefined line number
  54  4000              ;09 Subscript out of range
  55  4000              ;10 Redimensioned array
  56  4000              ;11 Division by zero
  57  4000              ;12 Illegal direct
  58  4000              ;13 Type mismatch
  59  4000              ;14 Out of string space
  60  4000              ;15 String too long
  61  4000              ;16 String formula too complex
  62  4000              ;17 Can't CONTINUE
  63  4000              ;18 Undefined user function
  64  4000              ;19 Device I/O error
  65  4000              ;20 Verify error
  66  4000              ;21 No RESUME
  67  4000              ;22 RESUME without error
  68  4000              ;23 Unprintable error
  69  4000              ;24 Missing operand
  70  4000              ;25 Line buffer overflow
  71  4000              ;50 FIELD overflow
  72  4000              ;51 Internal error
  73  4000              ;52 Bad file number
  74  4000              ;53 File not found
  75  4000              ;54 File already open
  76  4000              ;55 Input past end
  77  4000              ;56 Bad file name
  78  4000              ;57 Direct statement in file
  79  4000              ;58 Sequential I/O only
  80  4000              ;59 File not OPEN
  81  4000
  82  4000
  83  4000               ; simulate cartridge with BASIC extension
  84  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  84  4004 AB 4F 00 00
  84  4008 00 00 00 00
  84  400C 00 00 00 00
  85  4010
  86  4010              ; this location #4010 stores last location used by basic extension
  87  4010              ; free memory after that point
  88  4010 E9 58         DW EXT_END
  89  4012
  90  4012              ; this location #4012 stores extension version in DAA format
  91  4012              ; first byte is major version and second minor
  92  4012 00 70         DB #00, #70
  93  4014
  94  4014              ; binary included AKG player compiled at #4014
  95  4014               IFNDEF EXCLUDE_SOUND_PLAYER
  96  4014              	INCBIN "bin/AKG.bin"
  97  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
  98  4CF0               ENDIF
  99  4CF0
 100  4CF0              ORIG.HTIMI:
 101  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 101  4CF4 00
 102  4CF5               EXPORT ORIG.HTIMI
 103  4CF5
 104  4CF5               IFNDEF EXCLUDE_SOUND_PLAYER
 105  4CF5              MUSIC_INIT_STATUS:
 106  4CF5 00            DB 0
 107  4CF6              SFX_INIT_STATUS:
 108  4CF6 00            DB 0
 109  4CF7              SOUND_ENABLED:
 110  4CF7 00            DB 0
 111  4CF8               ENDIF
 112  4CF8
 113  4CF8               IFNDEF EXCLUDE_SPRITE_CMDS
 114  4CF8              SPRATR_INIT_STATUS:
 115  4CF8 00            DB 0
 116  4CF9              SPRATR_UPDATE_FLAG:
 117  4CF9 00 00         DW 0
 118  4CFB              SPRATR_DATA:
 119  4CFB 00 00         DW 0
 120  4CFD              SPRFLICKER_ENABLED:
 121  4CFD 00            DB 0
 122  4CFE              ; to support sprite flicker
 123  4CFE              FLICKER:
 124  4CFE 00            DB 0
 125  4CFF               ENDIF
 126  4CFF
 127  4CFF              ; to temporarily store stack pointer
 128  4CFF              TMPSP:
 129  4CFF 00 00         DW 0
 130  4D01
 131  4D01              ; temp variables for BLIT, TILE functions
 132  4D01              TILETMP1:
 133  4D01              BLIT_TMP1:
 134  4D01 00 00         DW 0
 135  4D03              TILETMP2:
 136  4D03              BLIT_TMP2:
 137  4D03 00 00         DW 0
 138  4D05               IFDEF BLIT_WITH_PARAMETERS
 139  4D05              BLIT_TMP:
 140  4D05 00 00 00 00   DS 4
 141  4D09              BLIT_STRUCT:
 142  4D09 00 00 00...   DS 17
 143  4D0D               ENDIF
 144  4D1A
 145  4D1A              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 146  4D1A              ; per starting letter, if no commands with this letter, NULL value
 147  4D1A              CMDS:
 148  4D1A 00 00            DW 0 ; A
 149  4D1C E3 4D            DW CMDS_B ; B
 150  4D1E 00 00            DW 0 ; C
 151  4D20 00 00            DW 0 ; D
 152  4D22 00 00            DW 0 ; E
 153  4D24 61 4D            DW CMDS_F; F
 154  4D26 74 4D            DW CMDS_G; G
 155  4D28 00 00            DW 0 ; H
 156  4D2A 00 00            DW 0 ; I
 157  4D2C 00 00            DW 0 ; J
 158  4D2E 00 00            DW 0 ; K
 159  4D30 00 00            DW 0 ; L
 160  4D32 4E 4D            DW CMDS_M ; M
 161  4D34 00 00            DW 0 ; N
 162  4D36 00 00            DW 0 ; O
 163  4D38 00 00            DW 0 ; P
 164  4D3A 00 00            DW 0 ; Q
 165  4D3C 00 00            DW 0 ; R
 166  4D3E 88 4D            DW CMDS_S ; S
 167  4D40 03 4E            DW CMDS_T ; T
 168  4D42 00 00            DW 0 ; U
 169  4D44 7E 4D            DW CMDS_V ; V
 170  4D46 00 00            DW 0 ; W
 171  4D48 00 00            DW 0 ; X
 172  4D4A 00 00            DW 0 ; Y
 173  4D4C 00 00            DW 0 ; Z
 174  4D4E
 175  4D4E              CMDS_M:
 176  4D4E               IFNDEF EXCLUDE_VRAM_CMDS
 177  4D4E 4D 45 4D 56      DB "MEMVRM", 0
 177  4D52 52 4D 00
 178  4D55 48 51            DW MEMVRM
 179  4D57               ENDIF
 180  4D57               IFNDEF EXCLUDE_RAM_CMDS
 181  4D57 4D 45 4D 43  	DB "MEMCPY", 0
 181  4D5B 50 59 00
 182  4D5E 07 50        	DW MEMCPY
 183  4D60               ENDIF
 184  4D60 00           	DB 0
 185  4D61              CMDS_F:
 186  4D61               IFNDEF EXCLUDE_VRAM_CMDS
 187  4D61 46 49 4C 56      DB "FILVRM", 0
 187  4D65 52 4D 00
 188  4D68 4A 50            DW FILVRM
 189  4D6A               ENDIF
 190  4D6A               IFNDEF EXCLUDE_RAM_CMDS
 191  4D6A 46 49 4C 52      DB "FILRAM", 0
 191  4D6E 41 4D 00
 192  4D71 91 50            DW FILRAM
 193  4D73               ENDIF
 194  4D73 00               DB 0
 195  4D74              CMDS_G:
 196  4D74               IFNDEF EXCLUDE_GENCAL
 197  4D74 47 45 4E 43      DB "GENCAL", 0
 197  4D78 41 4C 00
 198  4D7B EF 50            DW GENCAL
 199  4D7D               ENDIF
 200  4D7D 00           	DB	0
 201  4D7E              CMDS_V:
 202  4D7E               IFNDEF EXCLUDE_VRAM_CMDS
 203  4D7E 56 52 4D 4D  	DB "VRMMEM", 0
 203  4D82 45 4D 00
 204  4D85 C3 51        	DW VRMMEM
 205  4D87               ENDIF
 206  4D87 00           	DB 0
 207  4D88              CMDS_S:
 208  4D88               IFNDEF EXCLUDE_SPRITE_CMDS
 209  4D88 53 50 52 53  	DB "SPRSET", 0
 209  4D8C 45 54 00
 210  4D8F B0 53        	DW SPRSET
 211  4D91 53 50 52 47  	DB "SPRGRPMOV", 0
 211  4D95 52 50 4D 4F
 211  4D99 56 00
 212  4D9B 6E 54        	DW SPRGRPMOV
 213  4D9D               ENDIF
 214  4D9D               IFNDEF EXCLUDE_SOUND_PLAYER
 215  4D9D 53 4E 44 53  	DB "SNDSFX", 0
 215  4DA1 46 58 00
 216  4DA4 01 53        	DW SNDSFX
 217  4DA6 53 4E 44 50  	DB "SNDPLYON", 0
 217  4DAA 4C 59 4F 4E
 217  4DAE 00
 218  4DAF CB 52        	DW SNDPLYON
 219  4DB1 53 4E 44 50  	DB "SNDPLYOFF", 0
 219  4DB5 4C 59 4F 46
 219  4DB9 46 00
 220  4DBB DE 52        	DW SNDPLYOFF
 221  4DBD 53 4E 44 50  	DB "SNDPLYINI", 0
 221  4DC1 4C 59 49 4E
 221  4DC5 49 00
 222  4DC7 81 52        	DW SNDPLYINIT
 223  4DC9               ENDIF
 224  4DC9               IFNDEF EXCLUDE_SPRITE_CMDS
 225  4DC9 53 50 52 45  	DB "SPRENABLE", 0
 225  4DCD 4E 41 42 4C
 225  4DD1 45 00
 226  4DD3 5B 53        	DW SPRENABLE
 227  4DD5 53 50 52 44  	DB "SPRDISABLE", 0
 227  4DD9 49 53 41 42
 227  4DDD 4C 45 00
 228  4DE0 AB 53        	DW SPRDISABLE
 229  4DE2               ENDIF
 230  4DE2 00           	DB 0
 231  4DE3              CMDS_B:
 232  4DE3               IFNDEF EXCLUDE_BLIT_CMDS
 233  4DE3 42 4C 49 54  	DB "BLIT", 0
 233  4DE7 00
 234  4DE8 6C 56        	DW BLIT
 235  4DEA 42 4F 58 4D  	DB "BOXMEMCPY", 0
 235  4DEE 45 4D 43 50
 235  4DF2 59 00
 236  4DF4 6E 58        	DW BOXMEMCPY
 237  4DF6 42 4F 58 4D  	DB "BOXMEMVRM", 0
 237  4DFA 45 4D 56 52
 237  4DFE 4D 00
 238  4E00 A2 58        	DW BOXMEMVRM
 239  4E02               ENDIF
 240  4E02 00           	DB 0
 241  4E03              CMDS_T:
 242  4E03               IFNDEF EXCLUDE_BLIT_CMDS
 243  4E03 54 49 4C 45  	DB "TILERAM", 0
 243  4E07 52 41 4D 00
 244  4E0B B4 57        	DW TILERAM
 245  4E0D 54 49 4C 45  	DB "TILEVRM", 0
 245  4E11 56 52 4D 00
 246  4E15 FB 57        	DW TILEVRM
 247  4E17               ENDIF
 248  4E17 00           	DB 0
 249  4E18
 250  4E18              ; ****************************************************************************************************
 251  4E18              ; function sets VRAM address
 252  4E18              ; input HL=address
 253  4E18              ; modifies AF
 254  4E18              SETWRT_LOCAL:
 255  4E18 7D           	LD	A, L
 256  4E19 D3 99        	OUT	(099H), A
 257  4E1B 7C           	LD	A, H
 258  4E1C E6 3F        	AND	03FH
 259  4E1E F6 40        	OR	040H
 260  4E20 D3 99        	OUT	(099H), A
 261  4E22 C9           	RET
 262  4E23              ; ****************************************************************************************************
 263  4E23
 264  4E23              ; ****************************************************************************************************
 265  4E23              ; function gets slot and subslot data for specific page
 266  4E23              ; input A=page (0, 1 or 2)
 267  4E23              ; output B = 0A8H register value
 268  4E23              ; output D = 0 is no subslots, 1 if yes
 269  4E23              ; output C = 0A8H value when page 3 slot equals to requested page slot
 270  4E23              ; output E = subslot value if present
 271  4E23              ; modifies AF, BC, DE, HL
 272  4E23              GET_PAGE_INFO:
 273  4E23 6F               LD L, A
 274  4E24 C6 C1            ADD A, low (EXPTBL)
 275  4E26 32 30 4E         LD (GET_PAGE_INFO_L1+1), A
 276  4E29 DB A8            IN A, (0A8H)
 277  4E2B 47               LD B, A
 278  4E2C E6 3F            AND 03FH
 279  4E2E 4F               LD C, A
 280  4E2F              GET_PAGE_INFO_L1:
 281  4E2F 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 282  4E32 E6 80            AND 080H
 283  4E34 28 1B            JR Z, GET_PAGE_INFO_L2
 284  4E36                  ; expanded
 285  4E36 2D               DEC L
 286  4E37 FA 56 4E         JP M, GET_PAGE_INFO_L3
 287  4E3A 2D               DEC L
 288  4E3B FA 54 4E         JP M, GET_PAGE_INFO_L4
 289  4E3E                  ; page 2
 290  4E3E 07               RLCA
 291  4E3F 07               RLCA
 292  4E40              GET_PAGE_INFO_L5:
 293  4E40 E6 C0            AND 0C0H
 294  4E42 B1               OR C
 295  4E43 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 296  4E45 4F               LD C, A
 297  4E46 3A FF FF         LD A, (0FFFFH)
 298  4E49 2F               CPL
 299  4E4A 5F               LD E, A
 300  4E4B 16 01            LD D, 1
 301  4E4D 78               LD A, B ; return stack
 302  4E4E D3 A8            OUT (0A8H), A
 303  4E50 C9               RET
 304  4E51              GET_PAGE_INFO_L2:
 305  4E51                  ; not expanded
 306  4E51 16 00            LD D, 0
 307  4E53 C9               RET
 308  4E54              GET_PAGE_INFO_L4:
 309  4E54                  ; page 1
 310  4E54 0F               RRCA
 311  4E55 0F               RRCA
 312  4E56              GET_PAGE_INFO_L3:
 313  4E56                  ; page 0
 314  4E56 0F               RRCA
 315  4E57 0F               RRCA
 316  4E58 18 E6            JR GET_PAGE_INFO_L5
 317  4E5A              ; ****************************************************************************************************
 318  4E5A
 319  4E5A              ; ****************************************************************************************************
 320  4E5A              ; function returns original slot and subslot info
 321  4E5A              ; input B = 0A8H register value
 322  4E5A              ; input D = 0 is no subslots, 1 if yes
 323  4E5A              ; input C = 0A8H value when page 3 slot equals to requested page slot
 324  4E5A              ; input E = subslot value if present
 325  4E5A              ; modifies AF, disables interrupts
 326  4E5A              RESTORE_PAGE_INFO:
 327  4E5A 7A               LD A, D
 328  4E5B B7               OR A
 329  4E5C 28 08            JR Z, RESTORE_PAGE_INFO_L1
 330  4E5E 79               LD A, C
 331  4E5F F3           	DI
 332  4E60 D3 A8            OUT (0A8H), A
 333  4E62 7B               LD A, E
 334  4E63 32 FF FF         LD (0FFFFH), A
 335  4E66              RESTORE_PAGE_INFO_L1:
 336  4E66 78               LD A, B
 337  4E67 D3 A8            OUT (0A8H), A
 338  4E69 C9               RET
 339  4E6A              ; ****************************************************************************************************
 340  4E6A
 341  4E6A              ; *******************************************************************************************************
 342  4E6A              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 343  4E6A              ; INPUT:  A = SLOT ID: EXXXSSPP
 344  4E6A              ; E = EXPANDED FLAG
 345  4E6A              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 346  4E6A              ; PP = PRIMARY SLOT NUMBER
 347  4E6A              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 348  4E6A              ; CHANGES: AF, BC, DE
 349  4E6A
 350  4E6A              LOCAL_ENASLT:
 351  4E6A CD 8A 4E         CALL L0353
 352  4E6D FA 77 4E         JP M, L0340
 353  4E70 DB A8            IN A, (0A8H)
 354  4E72 A1               AND C
 355  4E73 B0               OR B
 356  4E74 D3 A8            OUT (0A8H), A
 357  4E76 C9               RET
 358  4E77              L0340:
 359  4E77 E5               PUSH HL
 360  4E78 CD AF 4E         CALL L0378
 361  4E7B 4F               LD C, A
 362  4E7C 06 00            LD B, 0
 363  4E7E 7D               LD A, L
 364  4E7F A4               AND H
 365  4E80 B2               OR D
 366  4E81 21 C5 FC         LD HL, 0FCC5H
 367  4E84 09               ADD HL, BC
 368  4E85 77               LD (HL), A
 369  4E86 E1               POP HL
 370  4E87 79               LD A, C
 371  4E88 18 E0            JR LOCAL_ENASLT
 372  4E8A              L0353:
 373  4E8A F3               DI
 374  4E8B F5               PUSH AF
 375  4E8C 7C               LD A, H
 376  4E8D 07               RLCA
 377  4E8E 07               RLCA
 378  4E8F E6 03            AND 3
 379  4E91 5F               LD E, A
 380  4E92 3E C0            LD A, 0C0H
 381  4E94              L035D:
 382  4E94 07               RLCA
 383  4E95 07               RLCA
 384  4E96 1D               DEC E
 385  4E97 F2 94 4E         JP P, L035D
 386  4E9A 5F               LD E, A
 387  4E9B 2F               CPL
 388  4E9C 4F               LD C, A
 389  4E9D F1               POP AF
 390  4E9E F5               PUSH AF
 391  4E9F E6 03            AND 3
 392  4EA1 3C               INC A
 393  4EA2 47               LD B, A
 394  4EA3 3E AB            LD A, 0ABH
 395  4EA5              L036E:
 396  4EA5 C6 55            ADD A, 055H
 397  4EA7 10 FC            DJNZ L036E
 398  4EA9 57               LD D, A
 399  4EAA A3               AND E
 400  4EAB 47               LD B, A
 401  4EAC F1               POP AF
 402  4EAD A7               AND A
 403  4EAE C9               RET
 404  4EAF              L0378:
 405  4EAF F5               PUSH AF
 406  4EB0 7A               LD A, D
 407  4EB1 E6 C0            AND 0C0H
 408  4EB3 4F               LD C, A
 409  4EB4 F1               POP AF
 410  4EB5 F5               PUSH AF
 411  4EB6 57               LD D, A
 412  4EB7 DB A8            IN A, (0A8H)
 413  4EB9 47               LD B, A
 414  4EBA E6 3F            AND 03FH
 415  4EBC B1               OR C
 416  4EBD D3 A8            OUT (0A8H), A
 417  4EBF 7A               LD A, D
 418  4EC0 0F               RRCA
 419  4EC1 0F               RRCA
 420  4EC2 E6 03            AND 3
 421  4EC4 57               LD D, A
 422  4EC5 3E AB            LD A, 0ABH
 423  4EC7              L0390:
 424  4EC7 C6 55            ADD A, 055H
 425  4EC9 15               DEC D
 426  4ECA F2 C7 4E         JP P, L0390
 427  4ECD A3               AND E
 428  4ECE 57               LD D, A
 429  4ECF 7B               LD A, E
 430  4ED0 2F               CPL
 431  4ED1 67               LD H, A
 432  4ED2 3A FF FF         LD A, (0FFFFH)
 433  4ED5 2F               CPL
 434  4ED6 6F               LD L, A
 435  4ED7 A4               AND H
 436  4ED8 B2               OR D
 437  4ED9 32 FF FF         LD (0FFFFH), A
 438  4EDC 78               LD A, B
 439  4EDD D3 A8            OUT (0A8H), A
 440  4EDF F1               POP AF
 441  4EE0 E6 03            AND 3
 442  4EE2 C9               RET
 443  4EE3              ; *******************************************************************************************************
 444  4EE3
 445  4EE3              ; *******************************************************************************************************
 446  4EE3              ; some common code to activate page 0 and place values needed to restore original page on stack
 447  4EE3              ; input IY=return address
 448  4EE3              ENABLE_PAGE0:
 449  4EE3 AF               XOR A
 450  4EE4 CD 23 4E         CALL GET_PAGE_INFO
 451  4EE7 C5               PUSH BC
 452  4EE8 D5               PUSH DE
 453  4EE9 3A 41 F3         LD A, (RAMAD0)
 454  4EEC 26 00            LD H, 0
 455  4EEE CD 6A 4E         CALL LOCAL_ENASLT
 456  4EF1 FD E9        	JP (IY)
 457  4EF3              ; *******************************************************************************************************
 458  4EF3
 459  4EF3               IFNDEF EXCLUDE_SPRITE_CMDS
 460  4EF3              ; *******************************************************************************************************
 461  4EF3              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 462  4EF3              ; struct {
 463  4EF3              ; DW y
 464  4EF3              ; DW x
 465  4EF3              ; DW pattern (0-63)
 466  4EF3              ; DW color
 467  4EF3              ; } [32]
 468  4EF3              ; will hide sprites whose location is outside of visible area
 469  4EF3              ; works in screen 1 and 2
 470  4EF3              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 471  4EF3              ; modifies AF, AF', BC, DE, HL
 472  4EF3              SPRATR_UPDATE:
 473  4EF3              	; check if initialized
 474  4EF3 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 475  4EF6 B7           	OR A
 476  4EF7 C8           	RET Z
 477  4EF8              	; check if update requested
 478  4EF8 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 479  4EFB 7E           	LD A, (HL)
 480  4EFC B7           	OR A
 481  4EFD C8           	RET Z
 482  4EFE              	; check screen mode
 483  4EFE 3A AF FC     	LD A, (SCRMOD)
 484  4F01 3D           	DEC A
 485  4F02 28 02        	JR Z, .L0 ; screen 1
 486  4F04 3D           	DEC A
 487  4F05 C0           	RET NZ ; not screen 2
 488  4F06              .L0:
 489  4F06 06 20        	LD B, 32 ; sprite number
 490  4F08 0E 98        	LD C, #98 ; register for vdp data output
 491  4F0A              	; set VDP address
 492  4F0A 2A 28 F9     	LD HL, (ATRBAS)
 493  4F0D 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
 494  4F10 B7           	OR A
 495  4F11 28 03        	JR Z, .L3
 496  4F13 3A FE 4C     	LD A, (FLICKER)
 497  4F16              .L3:
 498  4F16 5F           	LD E, A
 499  4F17 08           	EX AF, AF'
 500  4F18 7B           	LD A, E
 501  4F19 87           	ADD A, A
 502  4F1A 87           	ADD A, A
 503  4F1B 16 00        	LD D, 0
 504  4F1D 5F           	LD E, A
 505  4F1E 19           	ADD HL, DE
 506  4F1F CD 18 4E     	CALL SETWRT_LOCAL
 507  4F22 ED 73 FF 4C  	LD (TMPSP), SP
 508  4F26 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
 509  4F2A
 510  4F2A              .LOOP:
 511  4F2A E1           	POP HL
 512  4F2B 24           	INC H
 513  4F2C 28 0D        	JR Z, .L1 ; negative number above -256
 514  4F2E 25           	DEC H
 515  4F2F 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 516  4F31 7D           	LD A, L
 517  4F32 FE C0        	CP 192
 518  4F34 30 10        	JR NC, .OUT3
 519  4F36 3D           	DEC A ; due to VDP rule that top of screen is -1
 520  4F37 57           	LD D, A
 521  4F38 C3 56 4F     	JP .X
 522  4F3B              .L1:
 523  4F3B 7D           	LD A, L
 524  4F3C C6 10        	ADD 16
 525  4F3E FA 46 4F     	JP M, .OUT3 ; below -16
 526  4F41 2D           	DEC L ; due to VDP rule that top of screen is -1
 527  4F42 55           	LD D, L
 528  4F43 C3 56 4F     	JP .X
 529  4F46              .OUT3:
 530  4F46 E1           	POP HL ; skip x value
 531  4F47              .OUT2:
 532  4F47 E1           	POP HL ; skip pattern
 533  4F48 E1           	POP HL ; skip color
 534  4F49 3E D1        	LD A, #D1
 535  4F4B D3 98        	OUT (#98), A ; sprite hidden
 536  4F4D D3 98        	OUT (#98), A ; value unimportant
 537  4F4F D3 98        	OUT (#98), A ; value unimportant
 538  4F51 D3 98        	OUT (#98), A ; value unimportant
 539  4F53 C3 81 4F     	JP .NEXT
 540  4F56              .X:
 541  4F56 E1           	POP HL
 542  4F57 24           	INC H
 543  4F58 28 08        	JR Z, .L2
 544  4F5A 25           	DEC H
 545  4F5B 20 EA        	JR NZ, .OUT2
 546  4F5D 1E 00        	LD E, 0 ; EC bit
 547  4F5F C3 6B 4F     	JP .XY
 548  4F62              .L2:
 549  4F62 7D           	LD A, L
 550  4F63 C6 20        	ADD 32
 551  4F65 FA 47 4F     	JP M, .OUT2
 552  4F68 6F           	LD L, A
 553  4F69 1E 80        	LD E, #80
 554  4F6B              .XY:
 555  4F6B ED 51        	OUT (C), D
 556  4F6D ED 69        	OUT (C), L
 557  4F6F E1           	POP HL ; pattern
 558  4F70 3A E0 F3     	LD A, (REG1SAV)
 559  4F73 E6 02        	AND 2
 560  4F75 7D           	LD A, L
 561  4F76 28 02        	JR Z, .SMALLSPRITES
 562  4F78 87           	ADD A, A
 563  4F79 87           	ADD A, A ; needs to go at 4x
 564  4F7A              .SMALLSPRITES:
 565  4F7A D3 98        	OUT (#98), A
 566  4F7C E1           	POP HL ; color
 567  4F7D 7D           	LD A, L
 568  4F7E B3           	OR E
 569  4F7F D3 98        	OUT (#98), A
 570  4F81              .NEXT:
 571  4F81 08           	EX AF, AF'
 572  4F82 3C           	INC A
 573  4F83 E6 1F        	AND 31
 574  4F85 C2 99 4F     	JP NZ, .NEXT2
 575  4F88 08           	EX AF, AF'
 576  4F89 2A 28 F9     	LD HL, (ATRBAS)
 577  4F8C              	; CALL SETWRT_LOCAL not allowed as SP modified
 578  4F8C 7D           	LD	A, L
 579  4F8D D3 99        	OUT	(099H), A
 580  4F8F 7C           	LD	A, H
 581  4F90 E6 3F        	AND	03FH
 582  4F92 F6 40        	OR	040H
 583  4F94 D3 99        	OUT	(099H), A
 584  4F96 C3 9A 4F     	JP .NEXT3
 585  4F99              .NEXT2:
 586  4F99 08           	EX AF, AF'
 587  4F9A              .NEXT3:
 588  4F9A 10 8E        	DJNZ .LOOP
 589  4F9C 08           	EX AF, AF'
 590  4F9D 3C           	INC A
 591  4F9E 32 FE 4C     	LD (FLICKER), A
 592  4FA1
 593  4FA1 ED 7B FF 4C  	LD SP, (TMPSP)
 594  4FA5 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 595  4FA8 36 00        	LD (HL), 0 ; zero out update flag
 596  4FAA C9           	RET
 597  4FAB              ; *******************************************************************************************************
 598  4FAB               ENDIF
 599  4FAB
 600  4FAB              ; General BASIC CALL-instruction handler
 601  4FAB              CALLHAND:
 602  4FAB E5           	PUSH HL
 603  4FAC 21 1A 4D     	LD	HL, CMDS ; pointer table based on starting letter
 604  4FAF 3A 89 FD         LD A, (PROCNM)
 605  4FB2 D6 41            SUB 'A'
 606  4FB4 87               ADD A, A
 607  4FB5 16 00            LD D, 0
 608  4FB7 5F               LD E, A
 609  4FB8 19               ADD HL, DE
 610  4FB9 5E               LD E, (HL)
 611  4FBA 23               INC HL
 612  4FBB 56               LD D, (HL)
 613  4FBC 7A               LD A, D
 614  4FBD B3               OR E
 615  4FBE 28 23            JR Z, .CMDNOTRECOGNIZED
 616  4FC0 EB               EX DE, HL
 617  4FC1              .CHKCMD:
 618  4FC1 11 89 FD     	LD	DE, PROCNM
 619  4FC4 1A           .LOOP:	LD	A,(DE)
 620  4FC5 BE           	CP	(HL)
 621  4FC6 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 622  4FC8 13           	INC	DE
 623  4FC9 23           	INC	HL
 624  4FCA A7           	AND	A
 625  4FCB 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 626  4FCD 5E           	LD	E,(HL)
 627  4FCE 23           	INC	HL
 628  4FCF 56           	LD	D,(HL)
 629  4FD0 E1           	POP	HL		; routine address
 630  4FD1 CD F2 4F     	CALL	GETPREVCHAR
 631  4FD4 CD E6 4F     	CALL	.CALLDE		; Call routine
 632  4FD7 A7           	AND	A
 633  4FD8 C9           	RET
 634  4FD9
 635  4FD9              .TONEXTCMD:
 636  4FD9 0E FF        	LD	C,0FFH
 637  4FDB AF           	XOR	A
 638  4FDC ED B1        	CPIR			; Skip to end of instruction name
 639  4FDE 23           	INC	HL
 640  4FDF 23           	INC	HL		; Skip address
 641  4FE0 BE           	CP	(HL)
 642  4FE1 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 643  4FE3              .CMDNOTRECOGNIZED:
 644  4FE3 E1           	POP	HL
 645  4FE4 37               SCF
 646  4FE5 C9           	RET
 647  4FE6
 648  4FE6              .CALLDE:
 649  4FE6 D5           	PUSH	DE
 650  4FE7 C9           	RET
 651  4FE8
 652  4FE8              ;---------------------------
 653  4FE8
 654  4FE8              ;GETSTRPNT:
 655  4FE8              ; OUT:
 656  4FE8              ; HL = String Address
 657  4FE8              ; B  = Lenght
 658  4FE8              ;        LD      HL,(USR)
 659  4FE8              ;        LD      B,(HL)
 660  4FE8              ;        INC     HL
 661  4FE8              ;        LD      E,(HL)
 662  4FE8              ;        INC     HL
 663  4FE8              ;        LD      D,(HL)
 664  4FE8              ;        EX      DE,HL
 665  4FE8              ;        RET
 666  4FE8
 667  4FE8              ;EVALTXTPARAM:
 668  4FE8              ;	CALL	CHKCHAR
 669  4FE8              ;	DEFB	"("             ; Check for (
 670  4FE8              ;	LD	IX,FRMEVL
 671  4FE8              ;	CALL	CALBAS		; Evaluate expression
 672  4FE8              ;       LD      A,(VALTYP)
 673  4FE8              ;        CP      3               ; Text type?
 674  4FE8              ;        JP      NZ,TYPE_MISMATCH
 675  4FE8              ;        PUSH	HL
 676  4FE8              ;        LD	IX,FRESTR         ; Free the temporary string
 677  4FE8              ;        CALL	CALBAS
 678  4FE8              ;        POP	HL
 679  4FE8              ;	CALL	CHKCHAR
 680  4FE8              ;	DEFB	")"             ; Check for )
 681  4FE8              ;        RET
 682  4FE8
 683  4FE8
 684  4FE8              CHKCHAR:
 685  4FE8 CD F2 4F     	CALL	GETPREVCHAR	; Get previous basic char
 686  4FEB E3           	EX	(SP),HL
 687  4FEC BE           	CP	(HL) 	        ; Check if good char
 688  4FED 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 689  4FEF 23           	INC	HL
 690  4FF0 E3           	EX	(SP),HL
 691  4FF1 23           	INC	HL		; Get next basic char
 692  4FF2
 693  4FF2              GETPREVCHAR:
 694  4FF2 2B           	DEC	HL
 695  4FF3 DD 21 66 46  	LD	IX,CHRGTR
 696  4FF7 C3 59 01     	JP      CALBAS
 697  4FFA
 698  4FFA
 699  4FFA              TYPE_MISMATCH:
 700  4FFA 1E 0D            LD E, 13 ; Type mismatch
 701  4FFC 18 02            JR THROW_ERROR
 702  4FFE
 703  4FFE              SYNTAX_ERROR:
 704  4FFE 1E 02            LD E, 2 ; Syntax error
 705  5000              THROW_ERROR:
 706  5000 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 707  5004 C3 59 01     	JP	CALBAS
 708  5007
 709  5007              ;---------------------------
 710  5007
 711  5007               IFNDEF EXCLUDE_RAM_CMDS
 712  5007              ; *******************************************************************************************************
 713  5007              ; function to handle CALL MEMCPY basic extension
 714  5007              ; _MEMCPY ( INT source,
 715  5007              ;			INT destination,
 716  5007              ;			INT count,
 717  5007              ; will put ram in page 0 also, page 1 is already there
 718  5007              MEMCPY:
 719  5007              	; opening (
 720  5007 CD E8 4F     	CALL CHKCHAR
 721  500A 28           	DB '('
 722  500B              	; get source address
 723  500B DD 21 2F 54  	LD IX, FRMQNT
 724  500F CD 59 01     	CALL CALBAS
 725  5012 D5           	PUSH DE
 726  5013              	; comma
 727  5013 CD E8 4F     	CALL CHKCHAR
 728  5016 2C           	DB ','
 729  5017              	; get destination address
 730  5017 DD 21 2F 54  	LD IX, FRMQNT
 731  501B CD 59 01     	CALL CALBAS
 732  501E D5           	PUSH DE
 733  501F              	; comma
 734  501F CD E8 4F     	CALL CHKCHAR
 735  5022 2C           	DB ','
 736  5023              	; get length
 737  5023 DD 21 2F 54  	LD IX, FRMQNT
 738  5027 CD 59 01     	CALL CALBAS
 739  502A D5           	PUSH DE
 740  502B              	; ending )
 741  502B CD E8 4F     	CALL CHKCHAR
 742  502E 29           	DB ')'
 743  502F
 744  502F              	; save position
 745  502F E5           	PUSH HL
 746  5030 DD E1        	POP IX
 747  5032
 748  5032 C1           	POP BC ; count
 749  5033 D1           	POP DE ; destination
 750  5034 E1           	POP HL ; source
 751  5035 D9           	EXX
 752  5036              	; enable page 0
 753  5036 FD 21 3D 50  	LD IY, .RET
 754  503A C3 E3 4E     	JP ENABLE_PAGE0
 755  503D              .RET:
 756  503D FB           	EI
 757  503E D9           	EXX
 758  503F ED B0        	LDIR
 759  5041 D1               POP DE
 760  5042 C1               POP BC
 761  5043 CD 5A 4E         CALL RESTORE_PAGE_INFO
 762  5046 DD E5        	PUSH IX
 763  5048 E1           	POP HL
 764  5049 C9           	RET
 765  504A              ; *******************************************************************************************************
 766  504A               ENDIF
 767  504A               IFNDEF EXCLUDE_VRAM_CMDS
 768  504A              ; *******************************************************************************************************
 769  504A              ; function to handle CALL FILVRM basic extension
 770  504A              ; FILVRM ( INT offset,
 771  504A              ;		   INT count,
 772  504A              ;		   BYTE value,
 773  504A              ;		   BYTE wait_vsync) >0 = true
 774  504A              ; wait_vsync will issue HALT before copying
 775  504A              FILVRM:
 776  504A              	; opening (
 777  504A CD E8 4F     	CALL CHKCHAR
 778  504D 28           	DB '('
 779  504E              	; get offset address
 780  504E DD 21 2F 54  	LD IX, FRMQNT
 781  5052 CD 59 01     	CALL CALBAS
 782  5055 D5           	PUSH DE
 783  5056              	; comma
 784  5056 CD E8 4F     	CALL CHKCHAR
 785  5059 2C           	DB ','
 786  505A              	; get count
 787  505A DD 21 2F 54  	LD IX, FRMQNT
 788  505E CD 59 01     	CALL CALBAS
 789  5061 D5           	PUSH DE
 790  5062              	; comma
 791  5062 CD E8 4F     	CALL CHKCHAR
 792  5065 2C           	DB ','
 793  5066              	; get value
 794  5066 DD 21 1C 52  	LD IX, GETBYT
 795  506A CD 59 01     	CALL CALBAS
 796  506D F5           	PUSH AF
 797  506E              	; comma
 798  506E CD E8 4F     	CALL CHKCHAR
 799  5071 2C           	DB ','
 800  5072              	; get vsync wait
 801  5072 DD 21 1C 52  	LD IX, GETBYT
 802  5076 CD 59 01     	CALL CALBAS
 803  5079 F5           	PUSH AF
 804  507A              	; ending )
 805  507A CD E8 4F     	CALL CHKCHAR
 806  507D 29           	DB ')'
 807  507E
 808  507E FB               EI
 809  507F              	; save position
 810  507F E5           	PUSH HL
 811  5080 DD E1        	POP IX
 812  5082
 813  5082              	; syntax ok
 814  5082              	; wait for vsync if needed
 815  5082 F1           	POP AF
 816  5083 B7           	OR A
 817  5084 28 01        	JR Z, .L1
 818  5086 76           	HALT
 819  5087
 820  5087              .L1:
 821  5087 F1               POP AF ; value
 822  5088 C1               POP BC ; count
 823  5089 E1               POP HL ; offset
 824  508A CD 56 00         CALL BIOS_FILVRM
 825  508D
 826  508D              .L3:
 827  508D DD E5        	PUSH IX
 828  508F E1           	POP HL
 829  5090 C9           	RET
 830  5091              ; *******************************************************************************************************
 831  5091               ENDIF
 832  5091
 833  5091               IFNDEF EXCLUDE_RAM_CMDS
 834  5091              ; *******************************************************************************************************
 835  5091              ; function to handle CALL FILRAM basic extension
 836  5091              ; FILRAM ( INT start address,
 837  5091              ;		   INT count,
 838  5091              ;		   BYTE value,
 839  5091              ; will put ram in page 0 also, page 1 is already there
 840  5091              FILRAM:
 841  5091              	; opening (
 842  5091 CD E8 4F     	CALL CHKCHAR
 843  5094 28           	DB '('
 844  5095              	; get start address
 845  5095 DD 21 2F 54  	LD IX, FRMQNT
 846  5099 CD 59 01     	CALL CALBAS
 847  509C D5           	PUSH DE
 848  509D              	; comma
 849  509D CD E8 4F     	CALL CHKCHAR
 850  50A0 2C           	DB ','
 851  50A1              	; get count
 852  50A1 DD 21 2F 54  	LD IX, FRMQNT
 853  50A5 CD 59 01     	CALL CALBAS
 854  50A8 D5           	PUSH DE
 855  50A9              	; comma
 856  50A9 CD E8 4F     	CALL CHKCHAR
 857  50AC 2C           	DB ','
 858  50AD              	; get value
 859  50AD DD 21 1C 52  	LD IX, GETBYT
 860  50B1 CD 59 01     	CALL CALBAS
 861  50B4 F5           	PUSH AF
 862  50B5              	; ending )
 863  50B5 CD E8 4F     	CALL CHKCHAR
 864  50B8 29           	DB ')'
 865  50B9
 866  50B9              	; save position
 867  50B9 E5           	PUSH HL
 868  50BA DD E1        	POP IX
 869  50BC
 870  50BC D1           	POP DE ; actually AF
 871  50BD C1           	POP BC ; count
 872  50BE E1           	POP HL ; start address
 873  50BF 78           	LD A, B
 874  50C0 B7           	OR A
 875  50C1 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 876  50C3 B1           	OR C
 877  50C4 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 878  50C6 79           	LD A, C
 879  50C7 3D           	DEC A
 880  50C8 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 881  50CA              	; one byte to fill
 882  50CA 72           	LD (HL), D
 883  50CB 18 12        	JR .EXIT
 884  50CD              .L1:
 885  50CD D9           	EXX
 886  50CE              	; enable page 0
 887  50CE FD 21 D5 50  	LD IY, .RET
 888  50D2 C3 E3 4E     	JP ENABLE_PAGE0
 889  50D5              .RET:
 890  50D5 FB           	EI
 891  50D6 D9           	EXX
 892  50D7 CD E3 50     	CALL .FILLVALUE
 893  50DA D1               POP DE
 894  50DB C1               POP BC
 895  50DC CD 5A 4E         CALL RESTORE_PAGE_INFO
 896  50DF              .EXIT:
 897  50DF DD E5        	PUSH IX
 898  50E1 E1           	POP HL
 899  50E2 C9           	RET
 900  50E3
 901  50E3              .FILLVALUE:
 902  50E3 72               LD (HL), D
 903  50E4 54               LD D, H
 904  50E5 5D               LD E, L
 905  50E6 13               INC DE
 906  50E7 0B               DEC BC
 907  50E8 ED B0            LDIR
 908  50EA C9               RET
 909  50EB              ; *******************************************************************************************************
 910  50EB               ENDIF
 911  50EB
 912  50EB               IFNDEF EXCLUDE_GENCAL
 913  50EB              ; *******************************************************************************************************
 914  50EB              ; function to handle CALL GENCAL basic extension
 915  50EB              ; GENCAL ( INT fn_addr, = address of the function to call
 916  50EB              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 917  50EB              ; output values of reristers will also be stored at reg_list_ptr
 918  50EB              GENCAL_VAR_SP:
 919  50EB 00 00            DW 0
 920  50ED              GENCAL_VAR_SP2:
 921  50ED 00 00            DW 0
 922  50EF              GENCAL:
 923  50EF              	; opening (
 924  50EF CD E8 4F     	CALL CHKCHAR
 925  50F2 28           	DB '('
 926  50F3              	; get function address
 927  50F3 DD 21 2F 54  	LD IX, FRMQNT
 928  50F7 CD 59 01     	CALL CALBAS
 929  50FA D5           	PUSH DE
 930  50FB              	; comma
 931  50FB CD E8 4F     	CALL CHKCHAR
 932  50FE 2C           	DB ','
 933  50FF              	; get pointer to register list
 934  50FF DD 21 2F 54  	LD IX, FRMQNT
 935  5103 CD 59 01     	CALL CALBAS
 936  5106 D5           	PUSH DE
 937  5107              	; ending )
 938  5107 CD E8 4F     	CALL CHKCHAR
 939  510A 29           	DB ')'
 940  510B
 941  510B              	; save BASIC token position
 942  510B E5           	PUSH HL
 943  510C D9               EXX
 944  510D E1           	POP HL ; HL'=next basic token
 945  510E D9               EXX
 946  510F
 947  510F E1               POP HL ; get pointer to register values
 948  5110 ED 73 EB 50      LD (GENCAL_VAR_SP), SP
 949  5114 F3               DI
 950  5115 F9               LD SP, HL
 951  5116 F1               POP AF
 952  5117 C1               POP BC
 953  5118 D1               POP DE
 954  5119 E1               POP HL
 955  511A DD E1            POP IX
 956  511C FD E1            POP IY
 957  511E D9               EXX
 958  511F ED 73 ED 50      LD (GENCAL_VAR_SP2), SP
 959  5123 ED 7B EB 50      LD SP, (GENCAL_VAR_SP)
 960  5127 FB               EI
 961  5128 D1               POP DE ; get function to call
 962  5129 E5               PUSH HL
 963  512A CD 45 51         CALL .EXXDECALL
 964  512D F3               DI
 965  512E ED 73 EB 50      LD (GENCAL_VAR_SP), SP
 966  5132 ED 7B ED 50      LD SP, (GENCAL_VAR_SP2)
 967  5136 FD E5            PUSH IY
 968  5138 DD E5            PUSH IX
 969  513A E5               PUSH HL
 970  513B D5               PUSH DE
 971  513C C5               PUSH BC
 972  513D F5               PUSH AF
 973  513E ED 7B EB 50      LD SP, (GENCAL_VAR_SP)
 974  5142 FB               EI
 975  5143 E1               POP HL
 976  5144 C9           	RET
 977  5145
 978  5145              .EXXDECALL:
 979  5145 D5               PUSH DE
 980  5146 D9               EXX
 981  5147 C9               RET
 982  5148              ; *******************************************************************************************************
 983  5148               ENDIF
 984  5148
 985  5148               IFNDEF EXCLUDE_VRAM_CMDS
 986  5148              ; *******************************************************************************************************
 987  5148              ; function to handle CALL MEMVRM basic extension
 988  5148              ; copies from RAM to VRAM
 989  5148              ; _MEMVRM ( INT source,
 990  5148              ;			INT destination,
 991  5148              ;			INT count,
 992  5148              ;			BYTE wait_vsync) >0 = true
 993  5148              ; will put ram in page 0 also, page 1 is already there
 994  5148              ; wait_vsync will issue HALT before copying
 995  5148              MEMVRM:
 996  5148              	; opening (
 997  5148 CD E8 4F     	CALL CHKCHAR
 998  514B 28           	DB '('
 999  514C              	; get source address
1000  514C DD 21 2F 54  	LD IX, FRMQNT
1001  5150 CD 59 01     	CALL CALBAS
1002  5153 D5           	PUSH DE
1003  5154              	; comma
1004  5154 CD E8 4F     	CALL CHKCHAR
1005  5157 2C           	DB ','
1006  5158              	; get destination address
1007  5158 DD 21 2F 54  	LD IX, FRMQNT
1008  515C CD 59 01     	CALL CALBAS
1009  515F D5           	PUSH DE
1010  5160              	; comma
1011  5160 CD E8 4F     	CALL CHKCHAR
1012  5163 2C           	DB ','
1013  5164              	; get length
1014  5164 DD 21 2F 54  	LD IX, FRMQNT
1015  5168 CD 59 01     	CALL CALBAS
1016  516B D5           	PUSH DE
1017  516C              	; comma
1018  516C CD E8 4F     	CALL CHKCHAR
1019  516F 2C           	DB ','
1020  5170              	; get vsync wait
1021  5170 DD 21 1C 52  	LD IX, GETBYT
1022  5174 CD 59 01     	CALL CALBAS
1023  5177 F5           	PUSH AF
1024  5178              	; ending )
1025  5178 CD E8 4F     	CALL CHKCHAR
1026  517B 29           	DB ')'
1027  517C
1028  517C                  ; save position in BASIC text
1029  517C E5           	PUSH HL
1030  517D DD E1        	POP IX
1031  517F
1032  517F F1           	POP AF ; wait vsync
1033  5180 B7           	OR A
1034  5181 28 03        	JR Z, .L1
1035  5183 FB               EI
1036  5184 76           	HALT
1037  5185 F3           	DI
1038  5186              .L1:
1039  5186              	; pop LDIR parameters and store away for later
1040  5186 C1           	POP BC ; count
1041  5187 D1           	POP DE ; vram destination
1042  5188 E1           	POP HL ; ram source
1043  5189 D9           	EXX
1044  518A FD 21 91 51   	LD IY, .RET
1045  518E C3 E3 4E     	JP ENABLE_PAGE0
1046  5191              .RET:
1047  5191 FB           	EI
1048  5192 D9           	EXX
1049  5193 CD 9F 51     	CALL .LDIRVM
1050  5196 D1               POP DE
1051  5197 C1               POP BC
1052  5198 CD 5A 4E         CALL RESTORE_PAGE_INFO
1053  519B DD E5        	PUSH IX
1054  519D E1           	POP HL
1055  519E C9           	RET
1056  519F
1057  519F              .LDIRVM:
1058  519F EB           	EX DE, HL
1059  51A0 F3           	DI
1060  51A1 CD 18 4E     	CALL SETWRT_LOCAL
1061  51A4 FB           	EI
1062  51A5 EB           	EX DE, HL
1063  51A6 78           	LD A, B
1064  51A7 B7           	OR A
1065  51A8 28 0D        	JR Z, .L3
1066  51AA C5           	PUSH BC
1067  51AB 0E 98        	LD C, #98
1068  51AD              .L2:
1069  51AD 50           	LD D, B
1070  51AE 06 00        	LD B, 0
1071  51B0 CD BD 51     	CALL .BBYTECOPY
1072  51B3 42           	LD B, D
1073  51B4 10 F7        	DJNZ .L2
1074  51B6 C1           	POP BC
1075  51B7              .L3:
1076  51B7 79           	LD A, C
1077  51B8 B7           	OR A
1078  51B9 C8           	RET Z
1079  51BA 41           	LD B, C
1080  51BB 0E 98        	LD C, #98
1081  51BD              .BBYTECOPY:
1082  51BD ED A3        	OUTI
1083  51BF C2 BD 51     	JP	NZ, .BBYTECOPY
1084  51C2 C9           	RET
1085  51C3              ; *******************************************************************************************************
1086  51C3               ENDIF
1087  51C3
1088  51C3               IFNDEF EXCLUDE_VRAM_CMDS
1089  51C3              ; *******************************************************************************************************
1090  51C3              ; function to handle CALL VRMMEM basic extension
1091  51C3              ; copies from RAM to VRAM
1092  51C3              ; _VRMMEM ( INT source,
1093  51C3              ;			INT destination,
1094  51C3              ;			INT count
1095  51C3              ; will put ram in page 0 also, page 1 is already there
1096  51C3              VRMMEM:
1097  51C3              	; opening (
1098  51C3 CD E8 4F     	CALL CHKCHAR
1099  51C6 28           	DB '('
1100  51C7              	; get source address
1101  51C7 DD 21 2F 54  	LD IX, FRMQNT
1102  51CB CD 59 01     	CALL CALBAS
1103  51CE D5           	PUSH DE
1104  51CF              	; comma
1105  51CF CD E8 4F     	CALL CHKCHAR
1106  51D2 2C           	DB ','
1107  51D3              	; get destination address
1108  51D3 DD 21 2F 54  	LD IX, FRMQNT
1109  51D7 CD 59 01     	CALL CALBAS
1110  51DA D5           	PUSH DE
1111  51DB              	; comma
1112  51DB CD E8 4F     	CALL CHKCHAR
1113  51DE 2C           	DB ','
1114  51DF              	; get length
1115  51DF DD 21 2F 54  	LD IX, FRMQNT
1116  51E3 CD 59 01     	CALL CALBAS
1117  51E6 D5           	PUSH DE
1118  51E7              	; ending )
1119  51E7 CD E8 4F     	CALL CHKCHAR
1120  51EA 29           	DB ')'
1121  51EB
1122  51EB                  ; save position in BASIC text
1123  51EB E5           	PUSH HL
1124  51EC DD E1        	POP IX
1125  51EE
1126  51EE C1           	POP BC ; count
1127  51EF D1           	POP DE ; destination
1128  51F0 E1           	POP HL ; source
1129  51F1 D9           	EXX
1130  51F2 FD 21 F9 51  	LD IY, .RET
1131  51F6 C3 E3 4E     	JP ENABLE_PAGE0
1132  51F9              .RET:
1133  51F9 FB           	EI
1134  51FA D9           	EXX
1135  51FB CD 07 52     	CALL .LDIRMV
1136  51FE D1               POP DE
1137  51FF C1               POP BC
1138  5200 CD 5A 4E         CALL RESTORE_PAGE_INFO
1139  5203 DD E5        	PUSH IX
1140  5205 E1           	POP HL
1141  5206 C9           	RET
1142  5207
1143  5207              .LDIRMV:
1144  5207              	; set VRAM address *exactly* as in ROM, otherwise corruption
1145  5207 7D           	LD	A, L
1146  5208 F3           	DI
1147  5209 D3 99        	OUT	(099H), A
1148  520B 7C           	LD	A, H
1149  520C E6 3F        	AND	03FH
1150  520E D3 99        	OUT	(099H), A
1151  5210 FB           	EI
1152  5211              	;EX (SP), HL
1153  5211              	;EX (SP), HL
1154  5211              	;NOP
1155  5211              	;NOP
1156  5211              .L4:
1157  5211 DB 98            IN A, (#98)
1158  5213 12           	LD (DE), A
1159  5214 13               INC DE
1160  5215 0B               DEC BC
1161  5216 79               LD A, C
1162  5217 B0               OR B
1163  5218 20 F7            JR NZ, .L4
1164  521A C9               RET
1165  521B              ; *******************************************************************************************************
1166  521B               ENDIF
1167  521B
1168  521B              ; *******************************************************************************************************
1169  521B              ; H.TIMI function
1170  521B              MBGE_HTIMI:
1171  521B               EXPORT MBGE_HTIMI
1172  521B F5           	PUSH AF
1173  521C
1174  521C               IFNDEF EXCLUDE_SPRITE_CMDS
1175  521C CD F3 4E     	CALL SPRATR_UPDATE
1176  521F               ENDIF
1177  521F
1178  521F               IFNDEF EXCLUDE_SOUND_PLAYER
1179  521F 3A F7 4C     	LD A, (SOUND_ENABLED)
1180  5222 B7           	OR A
1181  5223 28 2A        	JR Z, .EXIT
1182  5225
1183  5225              	; enable page 2
1184  5225 3E 02            LD A, 2
1185  5227 CD 23 4E         CALL GET_PAGE_INFO
1186  522A C5               PUSH BC
1187  522B D5               PUSH DE
1188  522C 3A 43 F3         LD A, (RAMAD2)
1189  522F 26 80            LD H, 080H
1190  5231 CD 6A 4E         CALL LOCAL_ENASLT
1191  5234              	; enable page 0
1192  5234 AF               XOR A
1193  5235 CD 23 4E         CALL GET_PAGE_INFO
1194  5238 C5               PUSH BC
1195  5239 D5               PUSH DE
1196  523A 3A 41 F3         LD A, (RAMAD0)
1197  523D 26 00            LD H, 0
1198  523F CD 6A 4E         CALL LOCAL_ENASLT
1199  5242
1200  5242 CD 33 42     	CALL PLY_AKG_PLAY
1201  5245
1202  5245              	; restore page 0
1203  5245 D1               POP DE
1204  5246 C1               POP BC
1205  5247 CD 5A 4E         CALL RESTORE_PAGE_INFO
1206  524A              	; restore page 2
1207  524A D1               POP DE
1208  524B C1               POP BC
1209  524C CD 5A 4E         CALL RESTORE_PAGE_INFO
1210  524F               ENDIF
1211  524F
1212  524F              .EXIT:
1213  524F F1           	POP AF
1214  5250 C3 F0 4C     	JP ORIG.HTIMI
1215  5253              ; *******************************************************************************************************
1216  5253
1217  5253              ; *******************************************************************************************************
1218  5253              ; interrupt handler when page 0 enabled
1219  5253              VBLANK:
1220  5253              	EXPORT VBLANK
1221  5253
1222  5253 F5               PUSH AF
1223  5254              	; is VDP originator ?
1224  5254 DB 99        	IN	A, (099H)
1225  5256 A7           	AND	A
1226  5257 F2 7D 52     	JP P, .EXIT
1227  525A
1228  525A               IFNDEF EXCLUDE_SOUND_PLAYER
1229  525A 3A F7 4C     	LD A, (SOUND_ENABLED)
1230  525D B7           	OR A
1231  525E 28 1D        	JR Z, .EXIT
1232  5260
1233  5260 C5               PUSH BC
1234  5261 D5               PUSH DE
1235  5262 E5               PUSH HL
1236  5263 08               EX AF, AF'
1237  5264 D9               EXX
1238  5265 F5               PUSH AF
1239  5266 C5               PUSH BC
1240  5267 D5               PUSH DE
1241  5268 E5               PUSH HL
1242  5269 DD E5            PUSH IX
1243  526B FD E5            PUSH IY
1244  526D
1245  526D CD 33 42     	CALL PLY_AKG_PLAY
1246  5270
1247  5270 FD E1            POP IY
1248  5272 DD E1            POP IX
1249  5274 E1               POP HL
1250  5275 D1               POP DE
1251  5276 C1               POP BC
1252  5277 F1               POP AF
1253  5278 08               EX AF, AF'
1254  5279 D9               EXX
1255  527A E1               POP HL
1256  527B D1               POP DE
1257  527C C1               POP BC
1258  527D               ENDIF
1259  527D
1260  527D              .EXIT:
1261  527D F1           	POP AF
1262  527E FB           	EI
1263  527F ED 4D        	RETI
1264  5281              ; *******************************************************************************************************
1265  5281
1266  5281               IFNDEF EXCLUDE_SOUND_PLAYER
1267  5281              ; *******************************************************************************************************
1268  5281              ; function to handle CALL SNDPLYINIT basic extension
1269  5281              ; initializes sound player
1270  5281              ; _SNDPLYINIT ( INT music_offset,
1271  5281              ;				INT sfx_offset, can be -1 if no SFX
1272  5281              ; will put ram in page 0 also, page 1 is already there
1273  5281              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1274  5281              SNDPLYINIT:
1275  5281              	; opening (
1276  5281 CD E8 4F     	CALL CHKCHAR
1277  5284 28           	DB '('
1278  5285              	; get music address
1279  5285 DD 21 2F 54  	LD IX, FRMQNT
1280  5289 CD 59 01     	CALL CALBAS
1281  528C D5           	PUSH DE
1282  528D              	; comma
1283  528D CD E8 4F     	CALL CHKCHAR
1284  5290 2C           	DB ','
1285  5291              	; get sfx address
1286  5291 DD 21 2F 54  	LD IX, FRMQNT
1287  5295 CD 59 01     	CALL CALBAS
1288  5298 D5           	PUSH DE
1289  5299              	; ending )
1290  5299 CD E8 4F     	CALL CHKCHAR
1291  529C 29           	DB ')'
1292  529D
1293  529D                  ; save position in BASIC text
1294  529D 44           	LD B, H
1295  529E 4D           	LD C, L
1296  529F
1297  529F              	; pop LDIR parameters and store away for later
1298  529F D1           	POP DE ; sfx address
1299  52A0 E1           	POP HL ; music address
1300  52A1 C5           	PUSH BC ; basic text location
1301  52A2 D9           	EXX
1302  52A3 FD 21 AA 52  	LD IY, .RET
1303  52A7 C3 E3 4E     	JP ENABLE_PAGE0
1304  52AA              .RET:
1305  52AA D9           	EXX
1306  52AB
1307  52AB D5           	PUSH DE
1308  52AC AF           	XOR A
1309  52AD              	; HL = music location
1310  52AD CD 62 41     	CALL PLY_AKG_INIT
1311  52B0 3E 01        	LD A, 1
1312  52B2 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1313  52B5
1314  52B5 E1           	POP HL ; SFX
1315  52B6              	; check if SFX address -1
1316  52B6 23           	INC HL
1317  52B7 7D           	LD A, L
1318  52B8 B4           	OR H
1319  52B9 28 09        	JR Z,.L1
1320  52BB 2B           	DEC HL
1321  52BC CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1322  52BF 3E 01        	LD A, 1
1323  52C1 32 F6 4C     	LD (SFX_INIT_STATUS), A
1324  52C4              .L1:
1325  52C4 D1               POP DE
1326  52C5 C1               POP BC
1327  52C6 CD 5A 4E         CALL RESTORE_PAGE_INFO
1328  52C9
1329  52C9 E1           	POP HL
1330  52CA C9           	RET
1331  52CB              ; *******************************************************************************************************
1332  52CB
1333  52CB              ; *******************************************************************************************************
1334  52CB              ; function to handle CALL SNDPLYON basic extension
1335  52CB              ; enables sound player
1336  52CB              ; _SNDPLYON
1337  52CB              ; sets SOUND_ENABLED variable to 1 if init call was done
1338  52CB              ; if not throws out of data error
1339  52CB              SNDPLYON:
1340  52CB 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1341  52CE B7           	OR A
1342  52CF 20 05        	JR NZ, .L1
1343  52D1              	; player not initialized, throw error
1344  52D1 1E 04        	LD E, 04 ; Out of DATA
1345  52D3 C3 00 50     	JP THROW_ERROR
1346  52D6              .L1:
1347  52D6 32 F7 4C     	LD (SOUND_ENABLED), A
1348  52D9              	; disable key click
1349  52D9 AF           	XOR A
1350  52DA 32 DB F3     	LD (CLIKSW), A
1351  52DD C9           	RET
1352  52DE              ; *******************************************************************************************************
1353  52DE
1354  52DE              ; *******************************************************************************************************
1355  52DE              ; function to handle CALL SNDPLYOFF basic extension
1356  52DE              ; disables sound player
1357  52DE              ; _SNDPLYOFF
1358  52DE              ; sets SOUND_ENABLED variable to 0
1359  52DE              ; calls AKG to stop music and SFX on all channels if initialized
1360  52DE              SNDPLYOFF:
1361  52DE 3A F7 4C     	LD A, (SOUND_ENABLED)
1362  52E1 B7           	OR A
1363  52E2 C8           	RET Z ; already stopped
1364  52E3 AF           	XOR A
1365  52E4 32 F7 4C     	LD (SOUND_ENABLED), A
1366  52E7 E5           	PUSH HL
1367  52E8 CD 21 42     	CALL PLY_AKG_STOP
1368  52EB 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1369  52EE B7           	OR A
1370  52EF 28 0E        	JR Z, .EXIT ; SFX not in use
1371  52F1 AF           	XOR A
1372  52F2 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1373  52F5 3E 01        	LD A, 1
1374  52F7 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1375  52FA 3E 02        	LD A, 2
1376  52FC CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1377  52FF              .EXIT:
1378  52FF E1           	POP HL
1379  5300 C9           	RET
1380  5301              ; *******************************************************************************************************
1381  5301
1382  5301              ; *******************************************************************************************************
1383  5301              ; function to handle CALL SNDSFX basic extension
1384  5301              ; plays a sound effect
1385  5301              ; _SNDSFX ( BYTE sfx_number, >0
1386  5301              ;			BYTE channel, = 0,1 or 2
1387  5301              ;			BYTE inverted_volume = 0-16, 0 being full volume
1388  5301              ; will put ram in page 0 also, page 1 is already there
1389  5301              ; if sound off throws illegal function call
1390  5301              ; if sfx not initialized, throws out of data
1391  5301              SNDSFX:
1392  5301              	; opening (
1393  5301 CD E8 4F     	CALL CHKCHAR
1394  5304 28           	DB '('
1395  5305              	; get sfx_number
1396  5305 DD 21 1C 52  	LD IX, GETBYT
1397  5309 CD 59 01     	CALL CALBAS
1398  530C D5           	PUSH DE
1399  530D              	; comma
1400  530D CD E8 4F     	CALL CHKCHAR
1401  5310 2C           	DB ','
1402  5311              	; get sfx address
1403  5311 DD 21 1C 52  	LD IX, GETBYT
1404  5315 CD 59 01     	CALL CALBAS
1405  5318 D5           	PUSH DE
1406  5319              	; comma
1407  5319 CD E8 4F     	CALL CHKCHAR
1408  531C 2C           	DB ','
1409  531D              	; get inverted volume
1410  531D DD 21 1C 52  	LD IX, GETBYT
1411  5321 CD 59 01     	CALL CALBAS
1412  5324 D5           	PUSH DE
1413  5325              	; ending )
1414  5325 CD E8 4F     	CALL CHKCHAR
1415  5328 29           	DB ')'
1416  5329
1417  5329 3A F7 4C     	LD A, (SOUND_ENABLED)
1418  532C B7           	OR A
1419  532D 20 05        	JR NZ, .L1
1420  532F              	; sound disabled, throw illegal function call
1421  532F 1E 05        	LD E, 5
1422  5331 C3 00 50     	JP THROW_ERROR
1423  5334              .L1:
1424  5334 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1425  5337 B7           	OR A
1426  5338 20 05        	JR NZ, .L2
1427  533A              	; sfx data not initialized, throw out of data
1428  533A 1E 04        	LD E, 4
1429  533C C3 00 50     	JP THROW_ERROR
1430  533F              .L2:
1431  533F              	; pop  parameters and store away for later
1432  533F D1           	POP DE ; inverted volume
1433  5340 43           	LD B, E
1434  5341 D1           	POP DE ; channel
1435  5342 4B           	LD C, E
1436  5343 D1           	POP DE
1437  5344 7B           	LD A, E
1438  5345 08           	EX AF, AF'
1439  5346 E5           	PUSH HL ; basic text location
1440  5347 D9           	EXX
1441  5348 FD 21 4F 53  	LD IY, .RET
1442  534C C3 E3 4E     	JP ENABLE_PAGE0
1443  534F              .RET:
1444  534F D9           	EXX
1445  5350 08           	EX AF, AF'
1446  5351 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1447  5354
1448  5354 D1               POP DE
1449  5355 C1               POP BC
1450  5356 CD 5A 4E         CALL RESTORE_PAGE_INFO
1451  5359
1452  5359 E1           	POP HL
1453  535A C9           	RET
1454  535B              ; *******************************************************************************************************
1455  535B               ENDIF
1456  535B
1457  535B               IFNDEF EXCLUDE_SPRITE_CMDS
1458  535B              ; *******************************************************************************************************
1459  535B              ; function to handle CALL SPRENABLE basic extension
1460  535B              ; initializes sprites handler
1461  535B              ; _SPRENABLE ( INT sprites_attributes_data,
1462  535B              ;			   INT update_variable_location,
1463  535B              ;			   INT sprite_flicker_enabled )
1464  535B              ; expects both locations to be in range #8000+ or throws an error
1465  535B              ; since these should be BASIC variables
1466  535B              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
1467  535B              SPRENABLE:
1468  535B              	; opening (
1469  535B CD E8 4F     	CALL CHKCHAR
1470  535E 28           	DB '('
1471  535F              	; get address of sprite attribute table DIM SA%(3,31)
1472  535F DD 21 2F 54  	LD IX, FRMQNT
1473  5363 CD 59 01     	CALL CALBAS
1474  5366 D5           	PUSH DE
1475  5367              	; comma
1476  5367 CD E8 4F     	CALL CHKCHAR
1477  536A 2C           	DB ','
1478  536B              	; get address of sprite update flag location
1479  536B DD 21 2F 54  	LD IX, FRMQNT
1480  536F CD 59 01     	CALL CALBAS
1481  5372 D5           	PUSH DE
1482  5373              	; comma
1483  5373 CD E8 4F     	CALL CHKCHAR
1484  5376 2C           	DB ','
1485  5377              	; get flicker enabled flag
1486  5377 DD 21 2F 54  	LD IX, FRMQNT
1487  537B CD 59 01     	CALL CALBAS
1488  537E D5           	PUSH DE
1489  537F              	; ending )
1490  537F CD E8 4F     	CALL CHKCHAR
1491  5382 29           	DB ')'
1492  5383
1493  5383 D1           	POP DE ; get flicker flag
1494  5384 7A           	LD A, D
1495  5385 B3           	OR E
1496  5386 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
1497  5389
1498  5389 D1           	POP DE ; update variable location
1499  538A CB 7A        	BIT 7, D ; is address >= &h8000
1500  538C 20 05        	JR NZ, .L1
1501  538E 1E 05        	LD E, 5 ; illegal function call
1502  5390 C3 00 50     	JP THROW_ERROR
1503  5393              .L1:
1504  5393 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
1505  5397 D1           	POP DE ; address of sprite attribute table
1506  5398 CB 7A        	BIT 7, D ; is address >= &h8000
1507  539A 20 05        	JR NZ, .L2
1508  539C 1E 05        	LD E, 5 ; illegal function call
1509  539E C3 00 50     	JP THROW_ERROR
1510  53A1              .L2:
1511  53A1 ED 53 FB 4C  	LD (SPRATR_DATA), DE
1512  53A5 3E 01        	LD A, 1
1513  53A7 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1514  53AA C9           	RET
1515  53AB              ; *******************************************************************************************************
1516  53AB
1517  53AB              ; *******************************************************************************************************
1518  53AB              ; function to handle CALL SPRDISABLE basic extension
1519  53AB              ; disables sprites handling
1520  53AB              ; _SPRDISABLE
1521  53AB              ; resets variable SPRATR_INIT_STATUS
1522  53AB              SPRDISABLE:
1523  53AB AF           	XOR A
1524  53AC 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1525  53AF C9           	RET
1526  53B0              ; *******************************************************************************************************
1527  53B0
1528  53B0              ; *******************************************************************************************************
1529  53B0              ; function to handle CALL SPRSET basic extension
1530  53B0              ; sets position, and optionally pattern and color of sprite
1531  53B0              ; _SPRSET ( BYTE sprite_num , valid 0-31
1532  53B0              ;			INT x,
1533  53B0              ;			INT y,
1534  53B0              ;			INT pattern, valid 0-63, otherwise ignored
1535  53B0              ;			INT color, valid 0-15, otherwise ignored
1536  53B0              SPRSET:
1537  53B0 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1538  53B3 B7           	OR A
1539  53B4 20 05        	JR NZ, .L1
1540  53B6 1E 05        	LD E, 5 ; illegal function call
1541  53B8 C3 00 50     	JP THROW_ERROR
1542  53BB              .L1:
1543  53BB              	; opening (
1544  53BB CD E8 4F     	CALL CHKCHAR
1545  53BE 28           	DB '('
1546  53BF              	; get sprite number
1547  53BF DD 21 1C 52  	LD IX, GETBYT
1548  53C3 CD 59 01     	CALL CALBAS
1549  53C6 F5           	PUSH AF
1550  53C7              	; comma
1551  53C7 CD E8 4F     	CALL CHKCHAR
1552  53CA 2C           	DB ','
1553  53CB              	; get x
1554  53CB DD 21 2F 54  	LD IX, FRMQNT
1555  53CF CD 59 01     	CALL CALBAS
1556  53D2 D5           	PUSH DE
1557  53D3              	; comma
1558  53D3 CD E8 4F     	CALL CHKCHAR
1559  53D6 2C           	DB ','
1560  53D7              	; get y
1561  53D7 DD 21 2F 54  	LD IX, FRMQNT
1562  53DB CD 59 01     	CALL CALBAS
1563  53DE D5           	PUSH DE
1564  53DF              	; comma
1565  53DF CD E8 4F     	CALL CHKCHAR
1566  53E2 2C           	DB ','
1567  53E3              	; get pattern
1568  53E3 DD 21 2F 54  	LD IX, FRMQNT
1569  53E7 CD 59 01     	CALL CALBAS
1570  53EA D5           	PUSH DE
1571  53EB              	; comma
1572  53EB CD E8 4F     	CALL CHKCHAR
1573  53EE 2C           	DB ','
1574  53EF              	; get color
1575  53EF DD 21 2F 54  	LD IX, FRMQNT
1576  53F3 CD 59 01     	CALL CALBAS
1577  53F6 D5           	PUSH DE
1578  53F7              	; ending )
1579  53F7 CD E8 4F     	CALL CHKCHAR
1580  53FA 29           	DB ')'
1581  53FB
1582  53FB                  ; save position in BASIC text
1583  53FB E5           	PUSH HL
1584  53FC DD E1        	POP IX
1585  53FE
1586  53FE C1           	POP BC ; color
1587  53FF D1           	POP DE ; pattern
1588  5400 D9           	EXX
1589  5401 C1           	POP BC ; y
1590  5402 D1           	POP DE ; x
1591  5403 F1           	POP AF ; sprite number
1592  5404 FE 20        	CP 32
1593  5406 38 05        	JR C, .L2
1594  5408 1E 05        	LD E, 5 ; illegal function call
1595  540A C3 00 50     	JP THROW_ERROR
1596  540D              .L2:
1597  540D              	; find location in sprite attributes table
1598  540D 87          > ADD A, A
1598  540E 87          > ADD A, A
1598  540F 87          > ADD A, A
1599  5410 D5           	PUSH DE
1600  5411 16 00        	LD D, 0
1601  5413 5F           	LD E, A
1602  5414 2A FB 4C     	LD HL, (SPRATR_DATA)
1603  5417 19           	ADD HL, DE
1604  5418 D1           	POP DE
1605  5419              	; set y
1606  5419 71           	LD (HL), C
1607  541A 23           	INC HL
1608  541B 70           	LD (HL), B
1609  541C 23           	INC HL
1610  541D              	; set x
1611  541D 73           	LD (HL), E
1612  541E 23           	INC HL
1613  541F 72           	LD (HL), D
1614  5420 23           	INC HL
1615  5421 E5           	PUSH HL
1616  5422 D9           	EXX
1617  5423 E1           	POP HL
1618  5424              	; check if 0<=pattern<64
1619  5424 7A           	LD A, D
1620  5425 B7           	OR A
1621  5426 20 0B        	JR NZ, .L3
1622  5428 7B           	LD A, E
1623  5429 FE 40        	CP 64
1624  542B 30 06        	JR NC, .L3
1625  542D              	; set pattern
1626  542D              	;ADD A, A
1627  542D              	;ADD A, A
1628  542D              	;ADD A, A
1629  542D 77           	LD (HL), A
1630  542E 23           	INC HL
1631  542F 72           	LD (HL), D
1632  5430 23           	INC HL
1633  5431 18 02        	JR .L4
1634  5433              .L3:
1635  5433              	; skip pattern
1636  5433 23          > INC HL
1636  5434 23          > INC HL
1637  5435              .L4:
1638  5435              	; check if 0<=color<16
1639  5435 78           	LD A, B
1640  5436 B7           	OR A
1641  5437 20 08        	JR NZ, .L5
1642  5439 79           	LD A, C
1643  543A FE 10        	CP 16
1644  543C 30 03        	JR NC, .L5
1645  543E              	; set color
1646  543E 71           	LD (HL), C
1647  543F 23           	INC HL
1648  5440 70           	LD (HL), B
1649  5441
1650  5441              .L5:
1651  5441 DD E5        	PUSH IX
1652  5443 E1           	POP HL
1653  5444 C9           	RET
1654  5445              ; *******************************************************************************************************
1655  5445
1656  5445              ; *******************************************************************************************************
1657  5445              ; function sets sprite location based on initial coordinates and offset provided
1658  5445              ; input A=sprite number in SPRATR_DATA , 0-31
1659  5445              ; input DE=initial x
1660  5445              ; input BC=initial y
1661  5445              ; input IY=location where delta y,x are located
1662  5445              ; modifies AF, HL, IX
1663  5445              SPRSET_DELTA_POS:
1664  5445 87          > ADD A, A
1664  5446 87          > ADD A, A
1664  5447 87          > ADD A, A
1665  5448 D5           	PUSH DE
1666  5449 16 00        	LD D, 0
1667  544B 5F           	LD E, A
1668  544C DD 2A FB 4C  	LD IX, (SPRATR_DATA)
1669  5450 DD 19        	ADD IX, DE
1670  5452 D1           	POP DE
1671  5453              	; IX=sprite's y location
1672  5453 FD 6E 00     	LD L, (IY)
1673  5456 FD 66 01     	LD H, (IY+1)
1674  5459 09           	ADD HL, BC
1675  545A DD 75 00     	LD (IX), L
1676  545D DD 74 01     	LD (IX+1), H
1677  5460 FD 6E 02     	LD L, (IY+2)
1678  5463 FD 66 03     	LD H, (IY+3)
1679  5466 19           	ADD HL, DE
1680  5467 DD 75 02     	LD (IX+2), L
1681  546A DD 74 03     	LD (IX+3), H
1682  546D C9           	RET
1683  546E              ; *******************************************************************************************************
1684  546E
1685  546E              ; *******************************************************************************************************
1686  546E              ; function to handle CALL SPRGRPMOV basic extension
1687  546E              ; sets position of a group of sprites described with
1688  546E              ; { int sprite_num, int delta_y, int delta_x } [count]
1689  546E              ; _SPRGRPMOV ( INT x,
1690  546E              ;			   INT y,
1691  546E              ;			   INT data_ptr,
1692  546E              ;			   BYTE count,
1693  546E              ; will put ram in page 0 also, page 1 is already there
1694  546E              SPRGRPMOV:
1695  546E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1696  5471 B7           	OR A
1697  5472 20 05        	JR NZ, .L1
1698  5474 1E 05        	LD E, 5 ; illegal function call
1699  5476 C3 00 50     	JP THROW_ERROR
1700  5479              .L1:
1701  5479              	; opening (
1702  5479 CD E8 4F     	CALL CHKCHAR
1703  547C 28           	DB '('
1704  547D              	; get x
1705  547D DD 21 2F 54  	LD IX, FRMQNT
1706  5481 CD 59 01     	CALL CALBAS
1707  5484 D5           	PUSH DE
1708  5485              	; comma
1709  5485 CD E8 4F     	CALL CHKCHAR
1710  5488 2C           	DB ','
1711  5489              	; get y
1712  5489 DD 21 2F 54  	LD IX, FRMQNT
1713  548D CD 59 01     	CALL CALBAS
1714  5490 D5           	PUSH DE
1715  5491              	; comma
1716  5491 CD E8 4F     	CALL CHKCHAR
1717  5494 2C           	DB ','
1718  5495              	; get data pointer
1719  5495 DD 21 2F 54  	LD IX, FRMQNT
1720  5499 CD 59 01     	CALL CALBAS
1721  549C D5           	PUSH DE
1722  549D              	; comma
1723  549D CD E8 4F     	CALL CHKCHAR
1724  54A0 2C           	DB ','
1725  54A1              	; get count
1726  54A1 DD 21 1C 52  	LD IX, GETBYT
1727  54A5 CD 59 01     	CALL CALBAS
1728  54A8 F5           	PUSH AF
1729  54A9              	; ending )
1730  54A9 CD E8 4F     	CALL CHKCHAR
1731  54AC 29           	DB ')'
1732  54AD
1733  54AD E5           	PUSH HL
1734  54AE DD E1        	POP IX
1735  54B0
1736  54B0 C1           	POP BC ; count
1737  54B1 E1           	POP HL ; data pointer
1738  54B2 D9           	EXX
1739  54B3 C1           	POP BC ; y
1740  54B4 D1           	POP DE ; x
1741  54B5 D9           	EXX
1742  54B6
1743  54B6 DD E5        	PUSH IX ; save position in BASIC buffer
1744  54B8
1745  54B8 C5           	PUSH BC
1746  54B9 E5           	PUSH HL
1747  54BA AF               XOR A
1748  54BB CD 23 4E         CALL GET_PAGE_INFO
1749  54BE D9           	EXX
1750  54BF E1           	POP HL
1751  54C0 F1           	POP AF
1752  54C1 D9           	EXX
1753  54C2 C5               PUSH BC
1754  54C3 D5               PUSH DE
1755  54C4 D9           	EXX
1756  54C5 F5           	PUSH AF
1757  54C6 E5           	PUSH HL
1758  54C7 D9           	EXX
1759  54C8 3A 41 F3         LD A, (RAMAD0)
1760  54CB 26 00            LD H, 0
1761  54CD CD 6A 4E         CALL LOCAL_ENASLT
1762  54D0 FB           	EI
1763  54D1 E1           	POP HL
1764  54D2 C1           	POP BC
1765  54D3 CD DD 54     	CALL .UPDATE_LOC
1766  54D6 D1               POP DE
1767  54D7 C1               POP BC
1768  54D8 CD 5A 4E         CALL RESTORE_PAGE_INFO
1769  54DB E1           	POP HL
1770  54DC C9           	RET
1771  54DD
1772  54DD              .UPDATE_LOC:
1773  54DD              .L4:
1774  54DD 7E           	LD A, (HL)
1775  54DE 23           	INC HL
1776  54DF 23           	INC HL
1777  54E0 E5           	PUSH HL
1778  54E1 FD E1        	POP IY
1779  54E3 D9           	EXX
1780  54E4 CD 45 54     	CALL SPRSET_DELTA_POS
1781  54E7 D9           	EXX
1782  54E8 23          > INC HL
1782  54E9 23          > INC HL
1782  54EA 23          > INC HL
1782  54EB 23          > INC HL
1783  54EC 10 EF        	DJNZ .L4
1784  54EE C9           	RET
1785  54EF              ; *******************************************************************************************************
1786  54EF               ENDIF
1787  54EF
1788  54EF               IFNDEF EXCLUDE_BLIT_CMDS
1789  54EF              ; *******************************************************************************************************
1790  54EF              ; function rotates mask and data of several characters and applies to background data
1791  54EF              ; this handles x-shift from 0 to 4
1792  54EF              ; contains self-modifying code that is set-up from external function
1793  54EF              ; input HL=pointer to mask data
1794  54EF              ; input HL'=pointer to character data
1795  54EF              ; input DE=output buffer containing background data
1796  54EF              ; input BC=DE+8
1797  54EF              ; input A=number of characters to process
1798  54EF              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1799  54EF              SHIFT04:
1800  54EF 08           	EX AF, AF'
1801  54F0 7E           	LD A, (HL) ; get mask
1802  54F1 D9           	EXX
1803  54F2 57           	LD D, A
1804  54F3 1E FF        	LD E, #FF
1805  54F5 37           	SCF
1806  54F6              .M1:
1807  54F6 18 FE        	JR .M1 ; this is self-modifying part
1808  54F8 CB 1A        	RR D
1809  54FA CB 1B        	RR E
1810  54FC CB 1A        	RR D
1811  54FE CB 1B        	RR E
1812  5500 CB 1A        	RR D
1813  5502 CB 1B        	RR E
1814  5504 CB 1A        	RR D
1815  5506 CB 1B        	RR E
1816  5508
1817  5508 46           	LD B, (HL) ; get data
1818  5509 0E 00        	LD C, 0
1819  550B              .M2:
1820  550B 18 FE        	JR .M2 ; also self-modifying part
1821  550D CB 38        	SRL B
1822  550F CB 19        	RR C
1823  5511 CB 38        	SRL B
1824  5513 CB 19        	RR C
1825  5515 CB 38        	SRL B
1826  5517 CB 19        	RR C
1827  5519 CB 38        	SRL B
1828  551B CB 19        	RR C
1829  551D
1830  551D D9           	EXX
1831  551E 1A           	LD A, (DE) ; background
1832  551F D9           	EXX
1833  5520 A2           	AND D
1834  5521 B0           	OR B
1835  5522 D9           	EXX
1836  5523 12           	LD (DE), A
1837  5524
1838  5524 0A           	LD A, (BC)
1839  5525 D9           	EXX
1840  5526 A3           	AND E
1841  5527 B1           	OR C
1842  5528 23           	INC HL
1843  5529 D9           	EXX
1844  552A 02           	LD (BC), A
1845  552B
1846  552B 23           	INC HL
1847  552C 13           	INC DE
1848  552D 03           	INC BC
1849  552E
1850  552E 08           	EX AF, AF'
1851  552F 3D           	DEC A
1852  5530 C2 EF 54     	JP NZ, SHIFT04
1853  5533 C9           	RET
1854  5534              ; *******************************************************************************************************
1855  5534
1856  5534              ; *******************************************************************************************************
1857  5534              ; function rotates mask and data of several characters and applies to background data
1858  5534              ; this handles x-shift from 5 to 8
1859  5534              ; contains self-modifying code that is set-up from external function
1860  5534              ; input HL=pointer to mask data
1861  5534              ; input HL'=pointer to character data
1862  5534              ; input DE=output buffer containing background data
1863  5534              ; input BC=DE+8
1864  5534              ; input A=number of characters to process
1865  5534              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1866  5534              SHIFT58:
1867  5534 08           	EX AF, AF'
1868  5535 7E           	LD A, (HL) ; get mask
1869  5536 D9           	EXX
1870  5537 57           	LD D, A
1871  5538 1E FF        	LD E, #FF
1872  553A 37           	SCF
1873  553B              .M1:
1874  553B 18 FE        	JR .M1 ; this is self-modifying part
1875  553D CB 12        	RL D
1876  553F CB 13        	RL E
1877  5541 CB 12        	RL D
1878  5543 CB 13        	RL E
1879  5545 CB 12        	RL D
1880  5547 CB 13        	RL E
1881  5549
1882  5549 46           	LD B, (HL)
1883  554A 0E 00        	LD C, 0
1884  554C              .M2:
1885  554C 18 FE        	JR .M2 ; also self-modifying part
1886  554E CB 20        	SLA B
1887  5550 CB 11        	RL C
1888  5552 CB 20        	SLA B
1889  5554 CB 11        	RL C
1890  5556 CB 20        	SLA B
1891  5558 CB 11        	RL C
1892  555A
1893  555A D9           	EXX
1894  555B 1A           	LD A, (DE) ; background
1895  555C D9           	EXX
1896  555D A3           	AND E
1897  555E B1           	OR C
1898  555F D9           	EXX
1899  5560 12           	LD (DE), A
1900  5561
1901  5561 0A           	LD A, (BC)
1902  5562 D9           	EXX
1903  5563 A2           	AND D
1904  5564 B0           	OR B
1905  5565 23           	INC HL
1906  5566 D9           	EXX
1907  5567 02           	LD (BC), A
1908  5568
1909  5568 23           	INC HL
1910  5569 13           	INC DE
1911  556A 03           	INC BC
1912  556B
1913  556B 08           	EX AF, AF'
1914  556C 3D           	DEC A
1915  556D C2 34 55     	JP NZ, SHIFT58
1916  5570 C9           	RET
1917  5571              ; *******************************************************************************************************
1918  5571
1919  5571              ; *******************************************************************************************************
1920  5571              ; routine that shifts one row of characters
1921  5571              ; contains self-modifying code that is set-up from external function
1922  5571              ; input HL=pointer to mask data
1923  5571              ; input HL'=pointer to character data
1924  5571              ; input DE=output buffer containing background data
1925  5571              ; input A=number of characters to process
1926  5571              ; input IX=pointer to structure describing input data
1927  5571              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1928  5571              SHIFT_ROW:
1929  5571 F5           	PUSH AF
1930  5572 ED 53 01 4D  		LD (BLIT_TMP1), DE
1931  5576 E5           		PUSH HL
1932  5577 CD BA 55     			CALL .ADDYSHIFT
1933  557A E1           		POP HL
1934  557B ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1935  557F              .L1:
1936  557F 3E 08        		LD A, 8
1937  5581 DD 96 02     		SUB (IX+2) ; y shift
1938  5584              .CALL1:
1939  5584 CD 00 00     		CALL 0
1940  5587 DD 7E 02     		LD A, (IX+2); y shift
1941  558A B7           		OR A
1942  558B 28 26        		JR Z, .DONE
1943  558D ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1944  5591 E5           		PUSH HL
1945  5592 CD C8 55     			CALL .DETONEXTROW
1946  5595 E1           		POP HL
1947  5596              .CALL2:
1948  5596 CD 00 00     		CALL 0
1949  5599 ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1950  559D E5           		PUSH HL
1951  559E CD C2 55     			CALL .ADD8
1952  55A1 E1           		POP HL
1953  55A2 ED 53 01 4D  		LD (BLIT_TMP1), DE
1954  55A6 ED 5B 03 4D  		LD DE, (BLIT_TMP2)
1955  55AA E5           		PUSH HL
1956  55AB CD C2 55     			CALL .ADD8
1957  55AE E1           		POP HL
1958  55AF ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1959  55B3              .DONE:
1960  55B3 F1           	POP AF
1961  55B4 3D           	DEC A
1962  55B5 C8           	RET Z
1963  55B6 F5           	PUSH AF
1964  55B7 C3 7F 55     	JP .L1
1965  55BA              .ADDYSHIFT:
1966  55BA EB           	EX DE, HL
1967  55BB 16 00        	LD D, 0
1968  55BD DD 5E 02     	LD E, (IX+2); y shift
1969  55C0 18 0C        	JR .MOVDEBC
1970  55C2              .ADD8:
1971  55C2 21 08 00     	LD HL, 8
1972  55C5 C3 CE 55     	JP .MOVDEBC
1973  55C8              .DETONEXTROW:
1974  55C8 DD 6E 06     	LD L, (IX+6)
1975  55CB DD 66 07     	LD H, (IX+7) ; bkg add to value
1976  55CE              .MOVDEBC:
1977  55CE 19           	ADD HL, DE
1978  55CF 54           	LD D, H
1979  55D0 5D           	LD E, L
1980  55D1 01 08 00     	LD BC, 8
1981  55D4 09           	ADD HL, BC
1982  55D5 44           	LD B, H
1983  55D6 4D           	LD C, L
1984  55D7 C9           	RET
1985  55D8              ; *******************************************************************************************************
1986  55D8
1987  55D8              ; *******************************************************************************************************
1988  55D8              ; function rotates mask and character data and applies it to background
1989  55D8              ; input IX=pointer to structure describing input data
1990  55D8              ; +0  DW horizontal shift count 0-7 (low byte used)
1991  55D8              ; +2  DW vertical shift count 0-7 (low byte used)
1992  55D8              ; +4  DW background data start;
1993  55D8              ; +6  DW background add to value to next row of background data
1994  55D8              ; +8  DW mask data start;
1995  55D8              ; +10  DW character data start;
1996  55D8              ; +12 DW character&mask add to value to next row of data
1997  55D8              ; +14 DW columns (low byte used)
1998  55D8              ; +16 DW rows (low byte used)
1999  55D8              SHIFT_MERGE_CHARACTER:
2000  55D8 DD 7E 00     	LD A, (IX) ; shift
2001  55DB FE 05        	CP 5
2002  55DD 38 25        	JR C, .RIGHT
2003  55DF              	; shifts 5-7, use rotate towards left 1-3
2004  55DF 21 34 55     	LD HL, SHIFT58
2005  55E2 22 85 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2006  55E5 22 97 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2007  55E8 D6 05        	SUB 5
2008  55EA 28 0D        	JR Z, .L1
2009  55EC 87           	ADD A, A
2010  55ED 87           	ADD A, A
2011  55EE 67           	LD H, A
2012  55EF 2E 18        	LD L, #18 ; JR opcode
2013  55F1 22 3B 55     	LD (SHIFT58.M1), HL
2014  55F4 22 4C 55     	LD (SHIFT58.M2), HL
2015  55F7 18 32        	JR .DO
2016  55F9              .L1:
2017  55F9 21 00 00     	LD HL, 0 ; 2xNOP opcode
2018  55FC 22 3B 55     	LD (SHIFT58.M1), HL
2019  55FF 22 4C 55     	LD (SHIFT58.M2), HL
2020  5602 18 27        	JR .DO
2021  5604              .RIGHT:
2022  5604              	; shifts 0-4, rotate towards right
2023  5604 21 EF 54     	LD HL, SHIFT04
2024  5607 22 85 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2025  560A 22 97 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2026  560D FE 04        	CP 4
2027  560F 28 11        	JR Z, .R1
2028  5611 D6 04        	SUB 4
2029  5613 ED 44        	NEG
2030  5615 87           	ADD A, A
2031  5616 87           	ADD A, A
2032  5617 67           	LD H, A
2033  5618 2E 18        	LD L, #18 ; JR opcode
2034  561A 22 F6 54     	LD (SHIFT04.M1), HL
2035  561D 22 0B 55     	LD (SHIFT04.M2), HL
2036  5620 18 09        	JR .DO
2037  5622              .R1:
2038  5622 21 00 00     	LD HL, 0 ; 2xNOP opcode
2039  5625 22 F6 54     	LD (SHIFT04.M1), HL
2040  5628 22 0B 55     	LD (SHIFT04.M2), HL
2041  562B              .DO:
2042  562B DD 46 10     	LD B, (IX+16) ; rows
2043  562E DD 6E 08     	LD L, (IX+8)
2044  5631 DD 66 09     	LD H, (IX+9) ; mask data
2045  5634 DD 5E 04     	LD E, (IX+4)
2046  5637 DD 56 05     	LD D, (IX+5) ; background data
2047  563A D9           	EXX
2048  563B DD 6E 0A     	LD L, (IX+10)
2049  563E DD 66 0B     	LD H, (IX+11) ; character data
2050  5641 D9           	EXX
2051  5642              .LOOP:
2052  5642 C5           	PUSH BC
2053  5643 E5           		PUSH HL
2054  5644 D5           			PUSH DE
2055  5645 D9           				EXX
2056  5646 E5           				PUSH HL
2057  5647 D9           					EXX
2058  5648 DD 7E 0E     					LD A, (IX+14) ; columns
2059  564B              .CALL:
2060  564B CD 71 55     					CALL SHIFT_ROW
2061  564E E1           				POP HL
2062  564F DD 5E 0C     				LD E, (IX+12)
2063  5652 DD 56 0D     				LD D, (IX+13) ; char data to next row
2064  5655 19           				ADD HL, DE
2065  5656 D9           				EXX
2066  5657 E1           			POP HL
2067  5658 DD 5E 06     			LD E, (IX+6)
2068  565B DD 56 07     			LD D, (IX+7) ; background to next row
2069  565E 19           			ADD HL, DE
2070  565F EB           			EX DE, HL
2071  5660 E1           		POP HL
2072  5661 DD 4E 0C     		LD C, (IX+12)
2073  5664 DD 46 0D     		LD B, (IX+13) ; char data to next row
2074  5667 09           		ADD HL, BC
2075  5668 C1           	POP BC
2076  5669 10 D7        	DJNZ .LOOP
2077  566B C9           	RET
2078  566C              ; *******************************************************************************************************
2079  566C
2080  566C               IFDEF BLIT_WITH_STRUCT_POINTER
2081  566C ~            ; *******************************************************************************************************
2082  566C ~            ; function to handle CALL BLIT basic extension
2083  566C ~            ; rotates 1-bit character drawing horizontally with mask and character data and
2084  566C ~            ; fuses with background data and applies vertical shift too
2085  566C ~            ; BLIT ( INT request_data_ptr )
2086  566C ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
2087  566C ~            ; will put ram in page 0 also, page 1 is already there
2088  566C ~            BLIT:
2089  566C ~            	; opening (
2090  566C ~            	CALL CHKCHAR
2091  566C ~            	DB '('
2092  566C ~            	; get pointer to request struct
2093  566C ~            	LD IX, FRMQNT
2094  566C ~            	CALL CALBAS
2095  566C ~            	PUSH DE
2096  566C ~            	; ending )
2097  566C ~            	CALL CHKCHAR
2098  566C ~            	DB ')'
2099  566C ~
2100  566C ~            	POP IX ; pointer to request struct
2101  566C ~
2102  566C ~            	PUSH HL ; save position in BASIC buffer
2103  566C ~
2104  566C ~            	LD IY, .RET
2105  566C ~            	JP ENABLE_PAGE0
2106  566C ~            .RET:
2107  566C ~            	EI
2108  566C ~            	CALL SHIFT_MERGE_CHARACTER
2109  566C ~
2110  566C ~                POP DE
2111  566C ~                POP BC
2112  566C ~                CALL RESTORE_PAGE_INFO
2113  566C ~
2114  566C ~            	POP HL
2115  566C ~            	RET
2116  566C ~            ; *******************************************************************************************************
2117  566C               ENDIF
2118  566C
2119  566C               IFDEF BLIT_WITH_PARAMETERS
2120  566C              ; *******************************************************************************************************
2121  566C              ; function to handle CALL BLIT basic extension
2122  566C              ; rotates 1-bit character drawing horizontally with mask and character data and
2123  566C              ; fuses with background data and applies vertical shift too
2124  566C              ; in form without pointers
2125  566C              ; BLIT ( INT x,
2126  566C              ;		 INT y,
2127  566C              ;		 INT char_data_pointer,
2128  566C              ;		 INT mask_data_pointer,
2129  566C              ;		 INT width (in characters),
2130  566C              ;		 INT height (in characters),
2131  566C              ;		 INT background_pointer (top left),
2132  566C              ;		 INT background_width (in characters),
2133  566C              ;		 INT background_height (in characters))
2134  566C              ; will put ram in page 0 also, page 1 is already there
2135  566C              BLIT:
2136  566C              	; opening (
2137  566C CD E8 4F     	CALL CHKCHAR
2138  566F 28           	DB '('
2139  5670              	; get x coordinate
2140  5670 DD 21 2F 54  	LD IX, FRMQNT
2141  5674 CD 59 01     	CALL CALBAS
2142  5677 7B           	LD A, E
2143  5678 E6 07        	AND 7
2144  567A 32 09 4D     	LD (BLIT_STRUCT+0), A
2145  567D CD 5E 57     	CALL .DAdiv8
2146  5680 32 05 4D     	LD (BLIT_TMP+0),A
2147  5683              	; comma
2148  5683 CD E8 4F     	CALL CHKCHAR
2149  5686 2C           	DB ','
2150  5687              	; get y coordinate
2151  5687 DD 21 2F 54  	LD IX, FRMQNT
2152  568B CD 59 01     	CALL CALBAS
2153  568E 7B           	LD A, E
2154  568F E6 07        	AND 7
2155  5691 32 0B 4D     	LD (BLIT_STRUCT+2), A
2156  5694 CD 5E 57     	CALL .DAdiv8
2157  5697 32 06 4D     	LD (BLIT_TMP+1),A
2158  569A              	; comma
2159  569A CD E8 4F     	CALL CHKCHAR
2160  569D 2C           	DB ','
2161  569E              	; get char data pointer
2162  569E DD 21 2F 54  	LD IX, FRMQNT
2163  56A2 CD 59 01     	CALL CALBAS
2164  56A5 ED 53 13 4D  	LD (BLIT_STRUCT+10), DE
2165  56A9              	; comma
2166  56A9 CD E8 4F     	CALL CHKCHAR
2167  56AC 2C           	DB ','
2168  56AD              	; get mask data pointer
2169  56AD DD 21 2F 54  	LD IX, FRMQNT
2170  56B1 CD 59 01     	CALL CALBAS
2171  56B4 ED 53 11 4D  	LD (BLIT_STRUCT+8), DE
2172  56B8              	; comma
2173  56B8 CD E8 4F     	CALL CHKCHAR
2174  56BB 2C           	DB ','
2175  56BC              	; get width
2176  56BC DD 21 2F 54  	LD IX, FRMQNT
2177  56C0 CD 59 01     	CALL CALBAS
2178  56C3 7B           	LD A, E
2179  56C4 32 17 4D     	LD (BLIT_STRUCT+14), A
2180  56C7              	; comma
2181  56C7 CD E8 4F     	CALL CHKCHAR
2182  56CA 2C           	DB ','
2183  56CB              	; get height
2184  56CB DD 21 2F 54  	LD IX, FRMQNT
2185  56CF CD 59 01     	CALL CALBAS
2186  56D2 7B           	LD A, E
2187  56D3 32 19 4D     	LD (BLIT_STRUCT+16), A
2188  56D6              	; comma
2189  56D6 CD E8 4F     	CALL CHKCHAR
2190  56D9 2C           	DB ','
2191  56DA              	; get background pointer
2192  56DA DD 21 2F 54  	LD IX, FRMQNT
2193  56DE CD 59 01     	CALL CALBAS
2194  56E1 ED 53 0D 4D  	LD (BLIT_STRUCT+4), DE
2195  56E5              	; comma
2196  56E5 CD E8 4F     	CALL CHKCHAR
2197  56E8 2C           	DB ','
2198  56E9              	; get background width
2199  56E9 DD 21 2F 54  	LD IX, FRMQNT
2200  56ED CD 59 01     	CALL CALBAS
2201  56F0 7B           	LD A, E
2202  56F1 32 07 4D     	LD (BLIT_TMP+2), A
2203  56F4              	; comma
2204  56F4 CD E8 4F     	CALL CHKCHAR
2205  56F7 2C           	DB ','
2206  56F8              	; get background height
2207  56F8 DD 21 2F 54  	LD IX, FRMQNT
2208  56FC CD 59 01     	CALL CALBAS
2209  56FF 7B           	LD A, E
2210  5700 32 08 4D     	LD (BLIT_TMP+3), A
2211  5703              	; ending )
2212  5703 CD E8 4F     	CALL CHKCHAR
2213  5706 29           	DB ')'
2214  5707
2215  5707 E5           	PUSH HL ; save position in BASIC buffer
2216  5708
2217  5708              	; calculate char&mask add to value
2218  5708 26 00        	LD H, 0
2219  570A 3A 17 4D     	LD A, (BLIT_STRUCT+14)
2220  570D 6F           	LD L, A
2221  570E CD 5A 57     	CALL .HLx8
2222  5711 22 15 4D     	LD (BLIT_STRUCT+12), HL
2223  5714              	; calculate background add to value
2224  5714 26 00        	LD H, 0
2225  5716 3A 07 4D     	LD A, (BLIT_TMP+2)
2226  5719 6F           	LD L, A
2227  571A CD 5A 57     	CALL .HLx8
2228  571D 22 0F 4D     	LD (BLIT_STRUCT+6), HL
2229  5720              	; calculate pointer to background location
2230  5720 21 00 00     	LD HL, 0
2231  5723 3A 06 4D     	LD A,(BLIT_TMP+1)
2232  5726 B7           	OR A
2233  5727 28 08        	JR Z, .L1
2234  5729 47           	LD B,A
2235  572A ED 5B 0F 4D  	LD DE,(BLIT_STRUCT+6)
2236  572E              .L0:
2237  572E 19           	ADD HL, DE
2238  572F 10 FD        	DJNZ .L0
2239  5731              .L1:
2240  5731 EB           	EX DE,HL
2241  5732 26 00        	LD H,0
2242  5734 3A 05 4D     	LD A,(BLIT_TMP+0)
2243  5737 6F           	LD L,A
2244  5738 CD 5A 57     	CALL .HLx8
2245  573B 19           	ADD HL,DE
2246  573C ED 5B 0D 4D  	LD DE,(BLIT_STRUCT+4)
2247  5740 19           	ADD HL,DE
2248  5741 22 0D 4D     	LD (BLIT_STRUCT+4),HL
2249  5744
2250  5744 FD 21 4B 57  	LD IY, .RET
2251  5748 C3 E3 4E     	JP ENABLE_PAGE0
2252  574B              .RET:
2253  574B FB           	EI
2254  574C DD 21 09 4D  	LD IX, BLIT_STRUCT
2255  5750 CD D8 55     	CALL SHIFT_MERGE_CHARACTER
2256  5753
2257  5753 D1               POP DE
2258  5754 C1               POP BC
2259  5755 CD 5A 4E         CALL RESTORE_PAGE_INFO
2260  5758
2261  5758 E1           	POP HL
2262  5759 C9           	RET
2263  575A              .HLx8:
2264  575A 29          > ADD HL, HL
2264  575B 29          > ADD HL, HL
2264  575C 29          > ADD HL, HL
2265  575D C9           	RET
2266  575E              .DAdiv8:
2267  575E 7B           	LD A,E
2268  575F CB 2A        	SRA D
2269  5761 CB 1F            RR  A
2270  5763 CB 2A            SRA D
2271  5765 CB 1F            RR  A
2272  5767 CB 2A            SRA D
2273  5769 CB 1F            RR  A
2274  576B C9           	RET
2275  576C              ; *******************************************************************************************************
2276  576C               ENDIF
2277  576C
2278  576C              ; *******************************************************************************************************
2279  576C              ; generic function to implement tiling
2280  576C              ; should be modified to call appropriate function for memory or vram
2281  576C              ; input IX=pointer to following structure
2282  576C              ; +00 tile_data_ptr
2283  576C              ; +02 tile_rows
2284  576C              ; +04 tile_columns
2285  576C              ; +06 destination_address
2286  576C              ; +08 dest_to_next_row_add_to_value
2287  576C              ; +10 num_horizontal_tiles
2288  576C              ; +12 num_vertical_tiles
2289  576C              ; modifies AF, BC, DE, HL
2290  576C              TILE:
2291  576C DD 6E 06     	LD L, (IX+6)
2292  576F DD 66 07     	LD H, (IX+7) ; destination address
2293  5772 22 01 4D     	LD (TILETMP1), HL
2294  5775 DD 46 0C     	LD B, (IX+12) ; vertical tile number
2295  5778              .L1:
2296  5778 C5           	PUSH BC
2297  5779 DD 6E 00     		LD L, (IX+0)
2298  577C DD 66 01     		LD H, (IX+1) ; tile address
2299  577F 22 03 4D     		LD (TILETMP2), HL
2300  5782 DD 46 02     		LD B, (IX+2) ; tile rows
2301  5785              .L2:
2302  5785 C5           		PUSH BC
2303  5786              .CALL1:
2304  5786 CD 00 00     			CALL 0
2305  5789 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
2306  578C              .L3:
2307  578C C5           			PUSH BC
2308  578D 2A 03 4D     				LD HL, (TILETMP2)
2309  5790 DD 46 04     				LD B, (IX+4) ; tile columns
2310  5793              .L4:
2311  5793 C5           				PUSH BC
2312  5794              .CALL2:
2313  5794 CD 00 00     					CALL 0
2314  5797 C1           				POP BC
2315  5798 10 F9        				DJNZ .L4
2316  579A C1           			POP BC
2317  579B 10 EF        			DJNZ .L3
2318  579D 22 03 4D     			LD (TILETMP2), HL
2319  57A0 2A 01 4D     			LD HL, (TILETMP1)
2320  57A3 DD 5E 08     			LD E, (IX+8)
2321  57A6 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
2322  57A9 19           			ADD HL, DE
2323  57AA 22 01 4D     			LD (TILETMP1), HL
2324  57AD C1           		POP BC
2325  57AE 10 D5        		DJNZ .L2
2326  57B0 C1           	POP BC
2327  57B1 10 C5        	DJNZ .L1
2328  57B3 C9           	RET
2329  57B4              ; *******************************************************************************************************
2330  57B4
2331  57B4              ; *******************************************************************************************************
2332  57B4              ; function to handle CALL TILERAM basic extension
2333  57B4              ; fills memory with tiles
2334  57B4              ; fuses with background data and applies vertical shift too
2335  57B4              ; TILERAM ( INT request_data_ptr )
2336  57B4              ; request_data_ptr described in TILE
2337  57B4              ; will put ram in page 0 also, page 1 is already there
2338  57B4              TILERAM:
2339  57B4              	; opening (
2340  57B4 CD E8 4F     	CALL CHKCHAR
2341  57B7 28           	DB '('
2342  57B8              	; get pointer to request struct
2343  57B8 DD 21 2F 54  	LD IX, FRMQNT
2344  57BC CD 59 01     	CALL CALBAS
2345  57BF D5           	PUSH DE
2346  57C0              	; ending )
2347  57C0 CD E8 4F     	CALL CHKCHAR
2348  57C3 29           	DB ')'
2349  57C4
2350  57C4 DD E1        	POP IX ; pointer to request struct
2351  57C6
2352  57C6 E5           	PUSH HL ; save position in BASIC buffer
2353  57C7
2354  57C7 FD 21 CE 57  	LD IY, .RET
2355  57CB C3 E3 4E     	JP ENABLE_PAGE0
2356  57CE              .RET:
2357  57CE FB           	EI
2358  57CF              	; set RAM functions to call
2359  57CF 21 E5 57     	LD HL, .TILECOPY
2360  57D2 22 95 57     	LD (TILE.CALL2+1), HL
2361  57D5 21 F6 57     	LD HL, .SETDESTROW
2362  57D8 22 87 57     	LD (TILE.CALL1+1), HL
2363  57DB CD 6C 57     	CALL TILE
2364  57DE
2365  57DE D1               POP DE
2366  57DF C1               POP BC
2367  57E0 CD 5A 4E         CALL RESTORE_PAGE_INFO
2368  57E3
2369  57E3 E1           	POP HL
2370  57E4 C9           	RET
2371  57E5              .TILECOPY:
2372  57E5 ED A0       > LDI
2372  57E7 ED A0       > LDI
2372  57E9 ED A0       > LDI
2372  57EB ED A0       > LDI
2372  57ED ED A0       > LDI
2372  57EF ED A0       > LDI
2372  57F1 ED A0       > LDI
2372  57F3 ED A0       > LDI
2373  57F5 C9           	RET
2374  57F6              .SETDESTROW:
2375  57F6 ED 5B 01 4D  	LD DE, (TILETMP1)
2376  57FA C9           	RET
2377  57FB              ; *******************************************************************************************************
2378  57FB
2379  57FB              ; *******************************************************************************************************
2380  57FB              ; function to handle CALL TILEVRM basic extension
2381  57FB              ; fills vram with tiles
2382  57FB              ; fuses with background data and applies vertical shift too
2383  57FB              ; TILEVRM ( INT request_data_ptr )
2384  57FB              ; request_data_ptr described in TILE
2385  57FB              ; will put ram in page 0 also, page 1 is already there
2386  57FB              TILEVRM:
2387  57FB              	; opening (
2388  57FB CD E8 4F     	CALL CHKCHAR
2389  57FE 28           	DB '('
2390  57FF              	; get pointer to request struct
2391  57FF DD 21 2F 54  	LD IX, FRMQNT
2392  5803 CD 59 01     	CALL CALBAS
2393  5806 D5           	PUSH DE
2394  5807              	; ending )
2395  5807 CD E8 4F     	CALL CHKCHAR
2396  580A 29           	DB ')'
2397  580B
2398  580B DD E1        	POP IX ; pointer to request struct
2399  580D
2400  580D E5           	PUSH HL ; save position in BASIC buffer
2401  580E
2402  580E FD 21 15 58  	LD IY, .RET
2403  5812 C3 E3 4E     	JP ENABLE_PAGE0
2404  5815              .RET:
2405  5815 FB           	EI
2406  5816              	; set RAM functions to call
2407  5816 21 2C 58     	LD HL, .TILECOPY
2408  5819 22 95 57     	LD (TILE.CALL2+1), HL
2409  581C 21 32 58     	LD HL, .SETDESTROW
2410  581F 22 87 57     	LD (TILE.CALL1+1), HL
2411  5822 CD 6C 57     	CALL TILE
2412  5825
2413  5825 D1               POP DE
2414  5826 C1               POP BC
2415  5827 CD 5A 4E         CALL RESTORE_PAGE_INFO
2416  582A
2417  582A E1           	POP HL
2418  582B C9           	RET
2419  582C              .TILECOPY:
2420  582C 01 98 08     	LD BC, #0898
2421  582F               IFNDEF EXCLUDE_VRAM_CMDS
2422  582F C3 BD 51     	JP MEMVRM.BBYTECOPY
2423  5832               ELSE
2424  5832 ~            .BBYTECOPY:
2425  5832 ~            	OUTI
2426  5832 ~            	JP	NZ, .BBYTECOPY
2427  5832 ~            	RET
2428  5832               ENDIF
2429  5832              .SETDESTROW:
2430  5832 2A 01 4D     	LD HL, (TILETMP1)
2431  5835 F3           	DI
2432  5836 CD 18 4E     	CALL SETWRT_LOCAL
2433  5839 FB           	EI
2434  583A C9           	RET
2435  583B              ; *******************************************************************************************************
2436  583B
2437  583B              ; *******************************************************************************************************
2438  583B              ; generic function to implement rectangle data copy
2439  583B              ; should be modified to call appropriate function for memory or vram
2440  583B              ; input IX=pointer to following structure
2441  583B              ; +00 source data pointer
2442  583B              ; +02 num bytes in a row
2443  583B              ; +04 number of rows
2444  583B              ; +06 source add-to value till next row
2445  583B              ; +08 destination address
2446  583B              ; +10 destination add-to value till next row
2447  583B              ; modifies AF, BC, DE, HL
2448  583B              RECTANGLE_COPY:
2449  583B DD 6E 00     	LD L, (IX+0)
2450  583E DD 66 01     	LD H, (IX+1) ; source address
2451  5841 DD 5E 08     	LD E, (IX+8)
2452  5844 DD 56 09     	LD D, (IX+9) ; destination
2453  5847 DD 46 04     	LD B, (IX+4) ; row number
2454  584A              .L1:
2455  584A C5           	PUSH BC
2456  584B E5           		PUSH HL
2457  584C D5           			PUSH DE
2458  584D DD 4E 02     				LD C, (IX+2)
2459  5850 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2460  5853              .CALL1:
2461  5853 CD 00 00     				CALL 0 ; set destination address from DE
2462  5856              .CALL2:
2463  5856 CD 00 00     				CALL 0 ; copy data fn
2464  5859 E1           			POP HL
2465  585A DD 4E 0A     			LD C, (IX+10)
2466  585D DD 46 0B     			LD B, (IX+11) ; destination add-to
2467  5860 09           			ADD HL, BC
2468  5861 EB           			EX DE, HL
2469  5862 E1           		POP HL
2470  5863 DD 4E 06     		LD C, (IX+6)
2471  5866 DD 46 07     		LD B, (IX+7) ; src add-to
2472  5869 09           		ADD HL, BC
2473  586A C1           	POP BC
2474  586B 10 DD        	DJNZ .L1
2475  586D C9           	RET
2476  586E              ; *******************************************************************************************************
2477  586E
2478  586E              ; *******************************************************************************************************
2479  586E              ; function to handle CALL BOXMEMCPY basic extension
2480  586E              ; copies data with window like boundaries to ram
2481  586E              ; BOXMEMCPY ( INT request_data_ptr )
2482  586E              ; request_data_ptr described in RECTANGLE_COPY
2483  586E              ; will put ram in page 0 also, page 1 is already there
2484  586E              BOXMEMCPY:
2485  586E              	; opening (
2486  586E CD E8 4F     	CALL CHKCHAR
2487  5871 28           	DB '('
2488  5872              	; get pointer to request struct
2489  5872 DD 21 2F 54  	LD IX, FRMQNT
2490  5876 CD 59 01     	CALL CALBAS
2491  5879 D5           	PUSH DE
2492  587A              	; ending )
2493  587A CD E8 4F     	CALL CHKCHAR
2494  587D 29           	DB ')'
2495  587E
2496  587E DD E1        	POP IX ; pointer to request struct
2497  5880
2498  5880 E5           	PUSH HL ; save position in BASIC buffer
2499  5881
2500  5881 FD 21 88 58  	LD IY, .RET
2501  5885 C3 E3 4E     	JP ENABLE_PAGE0
2502  5888              .RET:
2503  5888 FB           	EI
2504  5889              	; set RAM functions to call
2505  5889 21 00 00     	LD HL, 0
2506  588C 22 53 58     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2507  588F 22 55 58     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2508  5892 21 ED B0     	LD HL, #B0ED ; LDIR
2509  5895 22 57 58     	LD (RECTANGLE_COPY.CALL1+4), HL
2510  5898 CD 3B 58     	CALL RECTANGLE_COPY
2511  589B
2512  589B D1               POP DE
2513  589C C1               POP BC
2514  589D CD 5A 4E         CALL RESTORE_PAGE_INFO
2515  58A0
2516  58A0 E1           	POP HL
2517  58A1 C9           	RET
2518  58A2              ; *******************************************************************************************************
2519  58A2
2520  58A2              ; *******************************************************************************************************
2521  58A2              ; function to handle CALL BOXMEMVRM basic extension
2522  58A2              ; copies data with window like boundaries to ram
2523  58A2              ; BOXMEMVRM ( INT request_data_ptr )
2524  58A2              ; request_data_ptr described in RECTANGLE_COPY
2525  58A2              ; will put ram in page 0 also, page 1 is already there
2526  58A2              BOXMEMVRM:
2527  58A2              	; opening (
2528  58A2 CD E8 4F     	CALL CHKCHAR
2529  58A5 28           	DB '('
2530  58A6              	; get pointer to request struct
2531  58A6 DD 21 2F 54  	LD IX, FRMQNT
2532  58AA CD 59 01     	CALL CALBAS
2533  58AD D5           	PUSH DE
2534  58AE              	; ending )
2535  58AE CD E8 4F     	CALL CHKCHAR
2536  58B1 29           	DB ')'
2537  58B2
2538  58B2 DD E1        	POP IX ; pointer to request struct
2539  58B4
2540  58B4 E5           	PUSH HL ; save position in BASIC buffer
2541  58B5
2542  58B5 FD 21 BC 58  	LD IY, .RET
2543  58B9 C3 E3 4E     	JP ENABLE_PAGE0
2544  58BC              .RET:
2545  58BC FB           	EI
2546  58BD              	; set RAM functions to call
2547  58BD 21 DB 58     	LD HL, .SETDEST
2548  58C0 22 54 58     	LD (RECTANGLE_COPY.CALL1+1), HL
2549  58C3 21 E3 58     	LD HL, .COPYDATA
2550  58C6 22 57 58     	LD (RECTANGLE_COPY.CALL2+1), HL
2551  58C9 3E CD        	LD A, #CD ; CALL
2552  58CB 32 53 58     	LD (RECTANGLE_COPY.CALL1), A
2553  58CE 32 56 58     	LD (RECTANGLE_COPY.CALL2), A
2554  58D1 CD 3B 58     	CALL RECTANGLE_COPY
2555  58D4
2556  58D4 D1               POP DE
2557  58D5 C1               POP BC
2558  58D6 CD 5A 4E         CALL RESTORE_PAGE_INFO
2559  58D9
2560  58D9 E1           	POP HL
2561  58DA C9           	RET
2562  58DB              .SETDEST:
2563  58DB EB           	EX DE, HL
2564  58DC F3           	DI
2565  58DD CD 18 4E     	CALL SETWRT_LOCAL
2566  58E0 FB           	EI
2567  58E1 EB           	EX DE, HL
2568  58E2 C9           	RET
2569  58E3              .COPYDATA:
2570  58E3 41           	LD B, C
2571  58E4 0E 98        	LD C, #98
2572  58E6               IFNDEF EXCLUDE_VRAM_CMDS
2573  58E6 C3 BD 51     	JP MEMVRM.BBYTECOPY
2574  58E9               ELSE
2575  58E9 ~            	JP TILEVRM.BBYTECOPY
2576  58E9               ENDIF
2577  58E9              ; *******************************************************************************************************
2578  58E9               ENDIF
2579  58E9
2580  58E9              EXT_END:
2581  58E9
# file closed: asm\main.asm
