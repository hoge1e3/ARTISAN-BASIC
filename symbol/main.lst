# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000               DEFINE EXCLUDE_SOUND_PLAYER
   4  4000
   5  4000              CHPUT   EQU     #A2
   6  4000              CALBAS	EQU		#159
   7  4000              ERRHAND EQU     #406F
   8  4000              FRMEVL  EQU     #4C64
   9  4000              FRESTR	EQU		#67D0
  10  4000              ; FRMQNT = formula quantificator
  11  4000              ; input HL=pointer to current program expression
  12  4000              ; output HL=next address
  13  4000              ; output DE=integer datum
  14  4000              FRMQNT	EQU		#542F
  15  4000              ; GETBYT = get byte parameter
  16  4000              ; input HL=pointer to current program expression
  17  4000              ; output HL=next address
  18  4000              ; output A=E=byte read
  19  4000              GETBYT	EQU		#521C
  20  4000              CHRGTR  EQU     #4666
  21  4000              SYNCHR	EQU		#558C
  22  4000              VALTYP  EQU     #F663
  23  4000              USR     EQU     #F7F8
  24  4000              PROCNM	EQU		#FD89
  25  4000              BIOS_FILVRM  EQU     #56
  26  4000              CLIKSW	EQU		#F3DB
  27  4000              ATRBAS	EQU		#F928
  28  4000
  29  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  30  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  31  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  32  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  33  4000              EXPTBL	EQU #FCC1
  34  4000              SCRMOD	EQU #FCAF ; current screen mode
  35  4000
  36  4000              ; BASIC error codes
  37  4000              ;01 NEXT without FOR
  38  4000              ;02 Syntax error
  39  4000              ;03 RETURN without GOSUB
  40  4000              ;04 Out of DATA
  41  4000              ;05 Illegal function call
  42  4000              ;06 Overflow
  43  4000              ;07 Out of memory
  44  4000              ;08 Undefined line number
  45  4000              ;09 Subscript out of range
  46  4000              ;10 Redimensioned array
  47  4000              ;11 Division by zero
  48  4000              ;12 Illegal direct
  49  4000              ;13 Type mismatch
  50  4000              ;14 Out of string space
  51  4000              ;15 String too long
  52  4000              ;16 String formula too complex
  53  4000              ;17 Can't CONTINUE
  54  4000              ;18 Undefined user function
  55  4000              ;19 Device I/O error
  56  4000              ;20 Verify error
  57  4000              ;21 No RESUME
  58  4000              ;22 RESUME without error
  59  4000              ;23 Unprintable error
  60  4000              ;24 Missing operand
  61  4000              ;25 Line buffer overflow
  62  4000              ;50 FIELD overflow
  63  4000              ;51 Internal error
  64  4000              ;52 Bad file number
  65  4000              ;53 File not found
  66  4000              ;54 File already open
  67  4000              ;55 Input past end
  68  4000              ;56 Bad file name
  69  4000              ;57 Direct statement in file
  70  4000              ;58 Sequential I/O only
  71  4000              ;59 File not OPEN
  72  4000
  73  4000
  74  4000               ; simulate cartridge with BASIC extension
  75  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  75  4004 89 42 00 00
  75  4008 00 00 00 00
  75  400C 00 00 00 00
  76  4010
  77  4010              ; this location #400A stores last location used by basic extension
  78  4010              ; free memory after that point
  79  4010 18 4A         DW EXT_END
  80  4012
  81  4012              ; binary included AKG player compiled at #4012
  82  4012               IFNDEF EXCLUDE_SOUND_PLAYER
  83  4012 ~            	INCBIN "bin/AKG.bin"
  84  4012 ~            	INCLUDE "symbol/AKG.sym"
  85  4012               ENDIF
  86  4012
  87  4012              ORIG.HTIMI:
  88  4012 00 00 00 00  	DB 0, 0, 0, 0, 0
  88  4016 00
  89  4017               EXPORT ORIG.HTIMI
  90  4017
  91  4017               IFNDEF EXCLUDE_SOUND_PLAYER
  92  4017 ~            MUSIC_INIT_STATUS:
  93  4017 ~             DB 0
  94  4017 ~            SFX_INIT_STATUS:
  95  4017 ~             DB 0
  96  4017 ~            SOUND_ENABLED:
  97  4017 ~             DB 0
  98  4017               ENDIF
  99  4017
 100  4017              SPRATR_INIT_STATUS:
 101  4017 00            DB 0
 102  4018              SPRATR_UPDATE_FLAG:
 103  4018 00 00         DW 0
 104  401A              SPRATR_DATA:
 105  401A 00 00         DW 0
 106  401C              SPRFLICKER_ENABLED:
 107  401C 00            DB 0
 108  401D
 109  401D              ; to temporarily store stack pointer
 110  401D              TMPSP:
 111  401D 00 00         DW 0
 112  401F              ; to support sprite flicker
 113  401F              FLICKER:
 114  401F 00            DB 0
 115  4020
 116  4020              ; temp variables for BLIT, TILE functions
 117  4020              TILETMP1:
 118  4020              BLIT_TMP1:
 119  4020 00 00         DW 0
 120  4022              TILETMP2:
 121  4022              BLIT_TMP2:
 122  4022 00 00         DW 0
 123  4024
 124  4024              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 125  4024              ; per starting letter, if no commands with this letter, NULL value
 126  4024              CMDS:
 127  4024 00 00            DW 0 ; A
 128  4026 C8 40            DW CMDS_B ; B
 129  4028 00 00            DW 0 ; C
 130  402A 00 00            DW 0 ; D
 131  402C 00 00            DW 0 ; E
 132  402E 7F 40            DW CMDS_F; F
 133  4030 92 40            DW CMDS_G; G
 134  4032 00 00            DW 0 ; H
 135  4034 00 00            DW 0 ; I
 136  4036 00 00            DW 0 ; J
 137  4038 00 00            DW 0 ; K
 138  403A 62 40            DW CMDS_L ; L
 139  403C 6C 40            DW CMDS_M ; M
 140  403E 00 00            DW 0 ; N
 141  4040 00 00            DW 0 ; O
 142  4042 00 00            DW 0 ; P
 143  4044 00 00            DW 0 ; Q
 144  4046 00 00            DW 0 ; R
 145  4048 A6 40            DW CMDS_S ; S
 146  404A E8 40            DW CMDS_T ; T
 147  404C 58 40            DW CMDS_U ; U
 148  404E 9C 40            DW CMDS_V ; V
 149  4050 00 00            DW 0 ; W
 150  4052 00 00            DW 0 ; X
 151  4054 00 00            DW 0 ; Y
 152  4056 00 00            DW 0 ; Z
 153  4058
 154  4058              CMDS_U:
 155  4058 55 50 52 49  	DEFB	"UPRINT",0      ; Print upper case string
 155  405C 4E 54 00
 156  405F C6 42        	DEFW	UPRINT
 157  4061 00               DB 0
 158  4062              CMDS_L:
 159  4062 4C 50 52 49  	DEFB	"LPRINT",0      ; Print lower case string
 159  4066 4E 54 00
 160  4069 E3 42        	DEFW	LPRINT
 161  406B 00               DB 0
 162  406C              CMDS_M:
 163  406C 4D 45 4D 56      DB "MEMVRM", 0
 163  4070 52 4D 00
 164  4073 8B 44            DW MEMVRM
 165  4075 4D 45 4D 43  	DB "MEMCPY", 0
 165  4079 50 59 00
 166  407C 4A 43        	DW MEMCPY
 167  407E 00           	DB 0
 168  407F              CMDS_F:
 169  407F 46 49 4C 56      DB "FILVRM", 0
 169  4083 52 4D 00
 170  4086 8D 43            DW FILVRM
 171  4088 46 49 4C 52      DB "FILRAM", 0
 171  408C 41 4D 00
 172  408F D4 43            DW FILRAM
 173  4091 00               DB 0
 174  4092              CMDS_G:
 175  4092 47 45 4E 43      DB "GENCAL", 0
 175  4096 41 4C 00
 176  4099 32 44            DW GENCAL
 177  409B 00           	DB	0
 178  409C              CMDS_V:
 179  409C 56 52 4D 4D  	DB "VRMMEM", 0
 179  40A0 45 4D 00
 180  40A3 04 45        	DW VRMMEM
 181  40A5 00           	DB 0
 182  40A6              CMDS_S:
 183  40A6 53 50 52 53  	DB "SPRSET", 0
 183  40AA 45 54 00
 184  40AD BF 45        	DW SPRSET
 185  40AF 53 50 52 47  	DB "SPRGRPMOV", 0
 185  40B3 52 50 4D 4F
 185  40B7 56 00
 186  40B9 7D 46        	DW SPRGRPMOV
 187  40BB               IFNDEF EXCLUDE_SOUND_PLAYER
 188  40BB ~            	DB "SNDSFX", 0
 189  40BB ~            	DW SNDSFX
 190  40BB ~            	DB "SNDPLYON", 0
 191  40BB ~            	DW SNDPLYON
 192  40BB ~            	DB "SNDPLYOFF", 0
 193  40BB ~            	DW SNDPLYOFF
 194  40BB ~            	DB "SNDPLYINI", 0
 195  40BB ~            	DW SNDPLYINIT
 196  40BB               ENDIF
 197  40BB 53 50 52 41  	DB "SPRATRINI", 0
 197  40BF 54 52 49 4E
 197  40C3 49 00
 198  40C5 6F 45        	DW SPRATRINI
 199  40C7 00           	DB 0
 200  40C8              CMDS_B:
 201  40C8 42 4C 49 54  	DB "BLIT", 0
 201  40CC 00
 202  40CD 7B 48        	DW BLIT
 203  40CF 42 4F 58 4D  	DB "BOXMEMCPY", 0
 203  40D3 45 4D 43 50
 203  40D7 59 00
 204  40D9 9F 49        	DW BOXMEMCPY
 205  40DB 42 4F 58 4D  	DB "BOXMEMVRM", 0
 205  40DF 45 4D 56 52
 205  40E3 4D 00
 206  40E5 D3 49        	DW BOXMEMVRM
 207  40E7 00           	DB 0
 208  40E8              CMDS_T:
 209  40E8 54 49 4C 45  	DB "TILERAM", 0
 209  40EC 52 41 4D 00
 210  40F0 E8 48        	DW TILERAM
 211  40F2 54 49 4C 45  	DB "TILEVRM", 0
 211  40F6 56 52 4D 00
 212  40FA 2F 49        	DW TILEVRM
 213  40FC 00           	DB 0
 214  40FD
 215  40FD              ; ****************************************************************************************************
 216  40FD              ; function sets VRAM address
 217  40FD              ; input HL=address
 218  40FD              ; modifies AF
 219  40FD              SETWRT_LOCAL:
 220  40FD 7D           	LD	A, L
 221  40FE D3 99        	OUT	(099H), A
 222  4100 7C           	LD	A, H
 223  4101 E6 3F        	AND	03FH
 224  4103 F6 40        	OR	040H
 225  4105 D3 99        	OUT	(099H), A
 226  4107 C9           	RET
 227  4108              ; ****************************************************************************************************
 228  4108
 229  4108              ; ****************************************************************************************************
 230  4108              ; function gets slot and subslot data for specific page
 231  4108              ; input A=page (0, 1 or 2)
 232  4108              ; output B = 0A8H register value
 233  4108              ; output D = 0 is no subslots, 1 if yes
 234  4108              ; output C = 0A8H value when page 3 slot equals to requested page slot
 235  4108              ; output E = subslot value if present
 236  4108              ; modifies AF, BC, DE, HL
 237  4108              GET_PAGE_INFO:
 238  4108 6F               LD L, A
 239  4109 C6 C1            ADD A, low (EXPTBL)
 240  410B 32 15 41         LD (GET_PAGE_INFO_L1+1), A
 241  410E DB A8            IN A, (0A8H)
 242  4110 47               LD B, A
 243  4111 E6 3F            AND 03FH
 244  4113 4F               LD C, A
 245  4114              GET_PAGE_INFO_L1:
 246  4114 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 247  4117 E6 80            AND 080H
 248  4119 28 1B            JR Z, GET_PAGE_INFO_L2
 249  411B                  ; expanded
 250  411B 2D               DEC L
 251  411C FA 3B 41         JP M, GET_PAGE_INFO_L3
 252  411F 2D               DEC L
 253  4120 FA 39 41         JP M, GET_PAGE_INFO_L4
 254  4123                  ; page 2
 255  4123 07               RLCA
 256  4124 07               RLCA
 257  4125              GET_PAGE_INFO_L5:
 258  4125 E6 C0            AND 0C0H
 259  4127 B1               OR C
 260  4128 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 261  412A 4F               LD C, A
 262  412B 3A FF FF         LD A, (0FFFFH)
 263  412E 2F               CPL
 264  412F 5F               LD E, A
 265  4130 16 01            LD D, 1
 266  4132 78               LD A, B ; return stack
 267  4133 D3 A8            OUT (0A8H), A
 268  4135 C9               RET
 269  4136              GET_PAGE_INFO_L2:
 270  4136                  ; not expanded
 271  4136 16 00            LD D, 0
 272  4138 C9               RET
 273  4139              GET_PAGE_INFO_L4:
 274  4139                  ; page 1
 275  4139 0F               RRCA
 276  413A 0F               RRCA
 277  413B              GET_PAGE_INFO_L3:
 278  413B                  ; page 0
 279  413B 0F               RRCA
 280  413C 0F               RRCA
 281  413D 18 E6            JR GET_PAGE_INFO_L5
 282  413F              ; ****************************************************************************************************
 283  413F
 284  413F              ; ****************************************************************************************************
 285  413F              ; function returns original slot and subslot info
 286  413F              ; input B = 0A8H register value
 287  413F              ; input D = 0 is no subslots, 1 if yes
 288  413F              ; input C = 0A8H value when page 3 slot equals to requested page slot
 289  413F              ; input E = subslot value if present
 290  413F              ; modifies AF, disables interrupts
 291  413F              RESTORE_PAGE_INFO:
 292  413F 7A               LD A, D
 293  4140 B7               OR A
 294  4141 28 08            JR Z, RESTORE_PAGE_INFO_L1
 295  4143 79               LD A, C
 296  4144 F3           	DI
 297  4145 D3 A8            OUT (0A8H), A
 298  4147 7B               LD A, E
 299  4148 32 FF FF         LD (0FFFFH), A
 300  414B              RESTORE_PAGE_INFO_L1:
 301  414B 78               LD A, B
 302  414C D3 A8            OUT (0A8H), A
 303  414E C9               RET
 304  414F              ; ****************************************************************************************************
 305  414F
 306  414F              ; *******************************************************************************************************
 307  414F              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 308  414F              ; INPUT:  A = SLOT ID: EXXXSSPP
 309  414F              ; E = EXPANDED FLAG
 310  414F              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 311  414F              ; PP = PRIMARY SLOT NUMBER
 312  414F              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 313  414F              ; CHANGES: AF, BC, DE
 314  414F
 315  414F              LOCAL_ENASLT:
 316  414F CD 6F 41         CALL L0353
 317  4152 FA 5C 41         JP M, L0340
 318  4155 DB A8            IN A, (0A8H)
 319  4157 A1               AND C
 320  4158 B0               OR B
 321  4159 D3 A8            OUT (0A8H), A
 322  415B C9               RET
 323  415C              L0340:
 324  415C E5               PUSH HL
 325  415D CD 94 41         CALL L0378
 326  4160 4F               LD C, A
 327  4161 06 00            LD B, 0
 328  4163 7D               LD A, L
 329  4164 A4               AND H
 330  4165 B2               OR D
 331  4166 21 C5 FC         LD HL, 0FCC5H
 332  4169 09               ADD HL, BC
 333  416A 77               LD (HL), A
 334  416B E1               POP HL
 335  416C 79               LD A, C
 336  416D 18 E0            JR LOCAL_ENASLT
 337  416F              L0353:
 338  416F F3               DI
 339  4170 F5               PUSH AF
 340  4171 7C               LD A, H
 341  4172 07               RLCA
 342  4173 07               RLCA
 343  4174 E6 03            AND 3
 344  4176 5F               LD E, A
 345  4177 3E C0            LD A, 0C0H
 346  4179              L035D:
 347  4179 07               RLCA
 348  417A 07               RLCA
 349  417B 1D               DEC E
 350  417C F2 79 41         JP P, L035D
 351  417F 5F               LD E, A
 352  4180 2F               CPL
 353  4181 4F               LD C, A
 354  4182 F1               POP AF
 355  4183 F5               PUSH AF
 356  4184 E6 03            AND 3
 357  4186 3C               INC A
 358  4187 47               LD B, A
 359  4188 3E AB            LD A, 0ABH
 360  418A              L036E:
 361  418A C6 55            ADD A, 055H
 362  418C 10 FC            DJNZ L036E
 363  418E 57               LD D, A
 364  418F A3               AND E
 365  4190 47               LD B, A
 366  4191 F1               POP AF
 367  4192 A7               AND A
 368  4193 C9               RET
 369  4194              L0378:
 370  4194 F5               PUSH AF
 371  4195 7A               LD A, D
 372  4196 E6 C0            AND 0C0H
 373  4198 4F               LD C, A
 374  4199 F1               POP AF
 375  419A F5               PUSH AF
 376  419B 57               LD D, A
 377  419C DB A8            IN A, (0A8H)
 378  419E 47               LD B, A
 379  419F E6 3F            AND 03FH
 380  41A1 B1               OR C
 381  41A2 D3 A8            OUT (0A8H), A
 382  41A4 7A               LD A, D
 383  41A5 0F               RRCA
 384  41A6 0F               RRCA
 385  41A7 E6 03            AND 3
 386  41A9 57               LD D, A
 387  41AA 3E AB            LD A, 0ABH
 388  41AC              L0390:
 389  41AC C6 55            ADD A, 055H
 390  41AE 15               DEC D
 391  41AF F2 AC 41         JP P, L0390
 392  41B2 A3               AND E
 393  41B3 57               LD D, A
 394  41B4 7B               LD A, E
 395  41B5 2F               CPL
 396  41B6 67               LD H, A
 397  41B7 3A FF FF         LD A, (0FFFFH)
 398  41BA 2F               CPL
 399  41BB 6F               LD L, A
 400  41BC A4               AND H
 401  41BD B2               OR D
 402  41BE 32 FF FF         LD (0FFFFH), A
 403  41C1 78               LD A, B
 404  41C2 D3 A8            OUT (0A8H), A
 405  41C4 F1               POP AF
 406  41C5 E6 03            AND 3
 407  41C7 C9               RET
 408  41C8              ; *******************************************************************************************************
 409  41C8
 410  41C8              ; *******************************************************************************************************
 411  41C8              ; some common code to activate page 0 and place values needed to restore original page on stack
 412  41C8              ; input IY=return address
 413  41C8              ENABLE_PAGE0:
 414  41C8 AF               XOR A
 415  41C9 CD 08 41         CALL GET_PAGE_INFO
 416  41CC C5               PUSH BC
 417  41CD D5               PUSH DE
 418  41CE 3A 41 F3         LD A, (RAMAD0)
 419  41D1 26 00            LD H, 0
 420  41D3 CD 4F 41         CALL LOCAL_ENASLT
 421  41D6 FD E9        	JP (IY)
 422  41D8              ; *******************************************************************************************************
 423  41D8
 424  41D8              ; *******************************************************************************************************
 425  41D8              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 426  41D8              ; struct {
 427  41D8              ; DW y
 428  41D8              ; DW x
 429  41D8              ; DW pattern (0-31)
 430  41D8              ; DW color
 431  41D8              ; } [32]
 432  41D8              ; will hide sprites whose location is outside of visible area
 433  41D8              ; works in screen 1 and 2
 434  41D8              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 435  41D8              ; modifies AF, AF', BC, DE, HL
 436  41D8              SPRATR_UPDATE:
 437  41D8              	; check if initialized
 438  41D8 3A 17 40     	LD A, (SPRATR_INIT_STATUS)
 439  41DB B7           	OR A
 440  41DC C8           	RET Z
 441  41DD              	; check if update requested
 442  41DD 2A 18 40     	LD HL, (SPRATR_UPDATE_FLAG)
 443  41E0 7E           	LD A, (HL)
 444  41E1 B7           	OR A
 445  41E2 C8           	RET Z
 446  41E3              	; check screen mode
 447  41E3 3A AF FC     	LD A, (SCRMOD)
 448  41E6 3D           	DEC A
 449  41E7 28 02        	JR Z, .L0 ; screen 1
 450  41E9 3D           	DEC A
 451  41EA C0           	RET NZ ; not screen 2
 452  41EB              .L0:
 453  41EB 06 20        	LD B, 32 ; sprite number
 454  41ED 0E 98        	LD C, #98 ; register for vdp data output
 455  41EF              	; set VDP address
 456  41EF 2A 28 F9     	LD HL, (ATRBAS)
 457  41F2 3A 1C 40     	LD A, (SPRFLICKER_ENABLED)
 458  41F5 B7           	OR A
 459  41F6 28 03        	JR Z, .L3
 460  41F8 3A 1F 40     	LD A, (FLICKER)
 461  41FB              .L3:
 462  41FB 5F           	LD E, A
 463  41FC 08           	EX AF, AF'
 464  41FD 7B           	LD A, E
 465  41FE 87           	ADD A, A
 466  41FF 87           	ADD A, A
 467  4200 16 00        	LD D, 0
 468  4202 5F           	LD E, A
 469  4203 19           	ADD HL, DE
 470  4204 CD FD 40     	CALL SETWRT_LOCAL
 471  4207 ED 73 1D 40  	LD (TMPSP), SP
 472  420B ED 7B 1A 40  	LD SP, (SPRATR_DATA)
 473  420F
 474  420F              .LOOP:
 475  420F E1           	POP HL
 476  4210 24           	INC H
 477  4211 28 0D        	JR Z, .L1 ; negative number above -256
 478  4213 25           	DEC H
 479  4214 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 480  4216 7D           	LD A, L
 481  4217 FE C0        	CP 192
 482  4219 30 10        	JR NC, .OUT3
 483  421B 3D           	DEC A ; due to VDP rule that top of screen is -1
 484  421C 57           	LD D, A
 485  421D C3 3B 42     	JP .X
 486  4220              .L1:
 487  4220 7D           	LD A, L
 488  4221 C6 10        	ADD 16
 489  4223 FA 2B 42     	JP M, .OUT3 ; below -16
 490  4226 2D           	DEC L ; due to VDP rule that top of screen is -1
 491  4227 55           	LD D, L
 492  4228 C3 3B 42     	JP .X
 493  422B              .OUT3:
 494  422B E1           	POP HL ; skip x value
 495  422C              .OUT2:
 496  422C E1           	POP HL ; skip pattern
 497  422D E1           	POP HL ; skip color
 498  422E 3E D1        	LD A, #D1
 499  4230 D3 98        	OUT (#98), A ; sprite hidden
 500  4232 D3 98        	OUT (#98), A ; value unimportant
 501  4234 D3 98        	OUT (#98), A ; value unimportant
 502  4236 D3 98        	OUT (#98), A ; value unimportant
 503  4238 C3 5F 42     	JP .NEXT
 504  423B              .X:
 505  423B E1           	POP HL
 506  423C 24           	INC H
 507  423D 28 08        	JR Z, .L2
 508  423F 25           	DEC H
 509  4240 20 EA        	JR NZ, .OUT2
 510  4242 1E 00        	LD E, 0 ; EC bit
 511  4244 C3 50 42     	JP .XY
 512  4247              .L2:
 513  4247 7D           	LD A, L
 514  4248 C6 20        	ADD 32
 515  424A FA 2C 42     	JP M, .OUT2
 516  424D 6F           	LD L, A
 517  424E 1E 80        	LD E, #80
 518  4250              .XY:
 519  4250 ED 51        	OUT (C), D
 520  4252 ED 69        	OUT (C), L
 521  4254 E1           	POP HL ; pattern
 522  4255 7D           	LD A, L
 523  4256 87           	ADD A, A
 524  4257 87           	ADD A, A ; needs to go at 4x
 525  4258 D3 98        	OUT (#98), A
 526  425A E1           	POP HL ; color
 527  425B 7D           	LD A, L
 528  425C B3           	OR E
 529  425D D3 98        	OUT (#98), A
 530  425F              .NEXT:
 531  425F 08           	EX AF, AF'
 532  4260 3C           	INC A
 533  4261 E6 1F        	AND 31
 534  4263 C2 77 42     	JP NZ, .NEXT2
 535  4266 08           	EX AF, AF'
 536  4267 2A 28 F9     	LD HL, (ATRBAS)
 537  426A              	; CALL SETWRT_LOCAL not allowed as SP modified
 538  426A 7D           	LD	A, L
 539  426B D3 99        	OUT	(099H), A
 540  426D 7C           	LD	A, H
 541  426E E6 3F        	AND	03FH
 542  4270 F6 40        	OR	040H
 543  4272 D3 99        	OUT	(099H), A
 544  4274 C3 78 42     	JP .NEXT3
 545  4277              .NEXT2:
 546  4277 08           	EX AF, AF'
 547  4278              .NEXT3:
 548  4278 10 95        	DJNZ .LOOP
 549  427A 08           	EX AF, AF'
 550  427B 3C           	INC A
 551  427C 32 1F 40     	LD (FLICKER), A
 552  427F
 553  427F ED 7B 1D 40  	LD SP, (TMPSP)
 554  4283 2A 18 40     	LD HL, (SPRATR_UPDATE_FLAG)
 555  4286 36 00        	LD (HL), 0 ; zero out update flag
 556  4288 C9           	RET
 557  4289              ; *******************************************************************************************************
 558  4289
 559  4289              ; General BASIC CALL-instruction handler
 560  4289              CALLHAND:
 561  4289 E5           	PUSH HL
 562  428A 21 24 40     	LD	HL, CMDS ; pointer table based on starting letter
 563  428D 3A 89 FD         LD A, (PROCNM)
 564  4290 D6 41            SUB 'A'
 565  4292 87               ADD A, A
 566  4293 16 00            LD D, 0
 567  4295 5F               LD E, A
 568  4296 19               ADD HL, DE
 569  4297 5E               LD E, (HL)
 570  4298 23               INC HL
 571  4299 56               LD D, (HL)
 572  429A 7A               LD A, D
 573  429B B3               OR E
 574  429C 28 24            JR Z, .CMDNOTRECOGNIZED
 575  429E EB               EX DE, HL
 576  429F              .CHKCMD:
 577  429F 11 89 FD     	LD	DE, PROCNM
 578  42A2 1A           .LOOP:	LD	A,(DE)
 579  42A3 BE           	CP	(HL)
 580  42A4 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 581  42A6 13           	INC	DE
 582  42A7 23           	INC	HL
 583  42A8 A7           	AND	A
 584  42A9 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 585  42AB 5E           	LD	E,(HL)
 586  42AC 23           	INC	HL
 587  42AD 56           	LD	D,(HL)
 588  42AE E1           	POP	HL		; routine address
 589  42AF CD 35 43     	CALL	GETPREVCHAR
 590  42B2 CD C4 42     	CALL	.CALLDE		; Call routine
 591  42B5 A7           	AND	A
 592  42B6 C9           	RET
 593  42B7
 594  42B7              .TONEXTCMD:
 595  42B7 0E FF        	LD	C,0FFH
 596  42B9 AF           	XOR	A
 597  42BA ED B1        	CPIR			; Skip to end of instruction name
 598  42BC 23           	INC	HL
 599  42BD 23           	INC	HL		; Skip address
 600  42BE BE           	CP	(HL)
 601  42BF 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 602  42C1 E1           	POP	HL
 603  42C2              .CMDNOTRECOGNIZED:
 604  42C2 37               SCF
 605  42C3 C9           	RET
 606  42C4
 607  42C4              .CALLDE:
 608  42C4 D5           	PUSH	DE
 609  42C5 C9           	RET
 610  42C6
 611  42C6              ;---------------------------
 612  42C6
 613  42C6              ;---------------------------
 614  42C6              UPRINT:
 615  42C6 CD 0A 43     	CALL	EVALTXTPARAM	; Evaluate text parameter
 616  42C9 E5           	PUSH	HL
 617  42CA CD 00 43             CALL    GETSTRPNT
 618  42CD              .LOOP
 619  42CD 7E                   LD      A,(HL)
 620  42CE CD DA 42             CALL    .UCASE
 621  42D1 CD A2 00             CALL    CHPUT  ;Print
 622  42D4 23                   INC     HL
 623  42D5 10 F6                DJNZ    .LOOP
 624  42D7
 625  42D7 E1           	POP	HL
 626  42D8 B7           	OR      A
 627  42D9 C9           	RET
 628  42DA
 629  42DA              .UCASE:
 630  42DA FE 61                CP      "a"
 631  42DC D8                   RET     C
 632  42DD FE 7B                CP      "z"+1
 633  42DF D0                   RET     NC
 634  42E0 E6 DF                AND     %11011111
 635  42E2 C9                   RET
 636  42E3              ;---------------------------
 637  42E3              LPRINT:
 638  42E3 CD 0A 43     	CALL	EVALTXTPARAM	; Evaluate text parameter
 639  42E6 E5           	PUSH	HL
 640  42E7 CD 00 43             CALL    GETSTRPNT
 641  42EA              .LOOP
 642  42EA 7E                   LD      A,(HL)
 643  42EB CD F7 42             CALL    .LCASE
 644  42EE CD A2 00             CALL    CHPUT  ;Print
 645  42F1 23                   INC     HL
 646  42F2 10 F6                DJNZ    .LOOP
 647  42F4
 648  42F4 E1           	POP	HL
 649  42F5 B7           	OR      A
 650  42F6 C9           	RET
 651  42F7
 652  42F7              .LCASE:
 653  42F7 FE 41                CP      "A"
 654  42F9 D8                   RET     C
 655  42FA FE 5B                CP      "Z"+1
 656  42FC D0                   RET     NC
 657  42FD F6 20                OR      %00100000
 658  42FF C9                   RET
 659  4300              ;---------------------------
 660  4300
 661  4300              GETSTRPNT:
 662  4300              ; OUT:
 663  4300              ; HL = String Address
 664  4300              ; B  = Lenght
 665  4300
 666  4300 2A F8 F7             LD      HL,(USR)
 667  4303 46                   LD      B,(HL)
 668  4304 23                   INC     HL
 669  4305 5E                   LD      E,(HL)
 670  4306 23                   INC     HL
 671  4307 56                   LD      D,(HL)
 672  4308 EB                   EX      DE,HL
 673  4309 C9                   RET
 674  430A
 675  430A              EVALTXTPARAM:
 676  430A CD 2B 43     	CALL	CHKCHAR
 677  430D 28           	DEFB	"("             ; Check for (
 678  430E DD 21 64 4C  	LD	IX,FRMEVL
 679  4312 CD 59 01     	CALL	CALBAS		; Evaluate expression
 680  4315 3A 63 F6             LD      A,(VALTYP)
 681  4318 FE 03                CP      3               ; Text type?
 682  431A C2 3D 43             JP      NZ,TYPE_MISMATCH
 683  431D E5                   PUSH	HL
 684  431E DD 21 D0 67          LD	IX,FRESTR         ; Free the temporary string
 685  4322 CD 59 01             CALL	CALBAS
 686  4325 E1                   POP	HL
 687  4326 CD 2B 43     	CALL	CHKCHAR
 688  4329 29           	DEFB	")"             ; Check for )
 689  432A C9                   RET
 690  432B
 691  432B
 692  432B              CHKCHAR:
 693  432B CD 35 43     	CALL	GETPREVCHAR	; Get previous basic char
 694  432E E3           	EX	(SP),HL
 695  432F BE           	CP	(HL) 	        ; Check if good char
 696  4330 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 697  4332 23           	INC	HL
 698  4333 E3           	EX	(SP),HL
 699  4334 23           	INC	HL		; Get next basic char
 700  4335
 701  4335              GETPREVCHAR:
 702  4335 2B           	DEC	HL
 703  4336 DD 21 66 46  	LD	IX,CHRGTR
 704  433A C3 59 01     	JP      CALBAS
 705  433D
 706  433D
 707  433D              TYPE_MISMATCH:
 708  433D 1E 0D            LD E, 13 ; Type mismatch
 709  433F 18 02            JR THROW_ERROR
 710  4341
 711  4341              SYNTAX_ERROR:
 712  4341 1E 02            LD E, 2 ; Syntax error
 713  4343              THROW_ERROR:
 714  4343 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 715  4347 C3 59 01     	JP	CALBAS
 716  434A
 717  434A              ;---------------------------
 718  434A
 719  434A              ; *******************************************************************************************************
 720  434A              ; function to handle CALL MEMCPY basic extension
 721  434A              ; _MEMCPY ( INT source,
 722  434A              ;			INT destination,
 723  434A              ;			INT count,
 724  434A              ; will put ram in page 0 also, page 1 is already there
 725  434A              MEMCPY:
 726  434A              	; opening (
 727  434A CD 2B 43     	CALL CHKCHAR
 728  434D 28           	DB '('
 729  434E              	; get source address
 730  434E DD 21 2F 54  	LD IX, FRMQNT
 731  4352 CD 59 01     	CALL CALBAS
 732  4355 D5           	PUSH DE
 733  4356              	; comma
 734  4356 CD 2B 43     	CALL CHKCHAR
 735  4359 2C           	DB ','
 736  435A              	; get destination address
 737  435A DD 21 2F 54  	LD IX, FRMQNT
 738  435E CD 59 01     	CALL CALBAS
 739  4361 D5           	PUSH DE
 740  4362              	; comma
 741  4362 CD 2B 43     	CALL CHKCHAR
 742  4365 2C           	DB ','
 743  4366              	; get length
 744  4366 DD 21 2F 54  	LD IX, FRMQNT
 745  436A CD 59 01     	CALL CALBAS
 746  436D D5           	PUSH DE
 747  436E              	; ending )
 748  436E CD 2B 43     	CALL CHKCHAR
 749  4371 29           	DB ')'
 750  4372
 751  4372              	; save position
 752  4372 E5           	PUSH HL
 753  4373 DD E1        	POP IX
 754  4375
 755  4375 C1           	POP BC ; count
 756  4376 D1           	POP DE ; destination
 757  4377 E1           	POP HL ; source
 758  4378 D9           	EXX
 759  4379              	; enable page 0
 760  4379 FD 21 80 43  	LD IY, .RET
 761  437D C3 C8 41     	JP ENABLE_PAGE0
 762  4380              .RET:
 763  4380 FB           	EI
 764  4381 D9           	EXX
 765  4382 ED B0        	LDIR
 766  4384 D1               POP DE
 767  4385 C1               POP BC
 768  4386 CD 3F 41         CALL RESTORE_PAGE_INFO
 769  4389 DD E5        	PUSH IX
 770  438B E1           	POP HL
 771  438C C9           	RET
 772  438D              ; *******************************************************************************************************
 773  438D
 774  438D              ; *******************************************************************************************************
 775  438D              ; function to handle CALL FILVRM basic extension
 776  438D              ; FILVRM ( INT offset,
 777  438D              ;		   INT count,
 778  438D              ;		   BYTE value,
 779  438D              ;		   BYTE wait_vsync) >0 = true
 780  438D              ; wait_vsync will issue HALT before copying
 781  438D              FILVRM:
 782  438D              	; opening (
 783  438D CD 2B 43     	CALL CHKCHAR
 784  4390 28           	DB '('
 785  4391              	; get offset address
 786  4391 DD 21 2F 54  	LD IX, FRMQNT
 787  4395 CD 59 01     	CALL CALBAS
 788  4398 D5           	PUSH DE
 789  4399              	; comma
 790  4399 CD 2B 43     	CALL CHKCHAR
 791  439C 2C           	DB ','
 792  439D              	; get count
 793  439D DD 21 2F 54  	LD IX, FRMQNT
 794  43A1 CD 59 01     	CALL CALBAS
 795  43A4 D5           	PUSH DE
 796  43A5              	; comma
 797  43A5 CD 2B 43     	CALL CHKCHAR
 798  43A8 2C           	DB ','
 799  43A9              	; get value
 800  43A9 DD 21 1C 52  	LD IX, GETBYT
 801  43AD CD 59 01     	CALL CALBAS
 802  43B0 F5           	PUSH AF
 803  43B1              	; comma
 804  43B1 CD 2B 43     	CALL CHKCHAR
 805  43B4 2C           	DB ','
 806  43B5              	; get vsync wait
 807  43B5 DD 21 1C 52  	LD IX, GETBYT
 808  43B9 CD 59 01     	CALL CALBAS
 809  43BC F5           	PUSH AF
 810  43BD              	; ending )
 811  43BD CD 2B 43     	CALL CHKCHAR
 812  43C0 29           	DB ')'
 813  43C1
 814  43C1 FB               EI
 815  43C2              	; save position
 816  43C2 E5           	PUSH HL
 817  43C3 DD E1        	POP IX
 818  43C5
 819  43C5              	; syntax ok
 820  43C5              	; wait for vsync if needed
 821  43C5 F1           	POP AF
 822  43C6 B7           	OR A
 823  43C7 28 01        	JR Z, .L1
 824  43C9 76           	HALT
 825  43CA
 826  43CA              .L1:
 827  43CA F1               POP AF ; value
 828  43CB C1               POP BC ; count
 829  43CC E1               POP HL ; offset
 830  43CD CD 56 00         CALL BIOS_FILVRM
 831  43D0
 832  43D0              .L3:
 833  43D0 DD E5        	PUSH IX
 834  43D2 E1           	POP HL
 835  43D3 C9           	RET
 836  43D4              ; *******************************************************************************************************
 837  43D4
 838  43D4              ; *******************************************************************************************************
 839  43D4              ; function to handle CALL FILRAM basic extension
 840  43D4              ; FILRAM ( INT start address,
 841  43D4              ;		   INT count,
 842  43D4              ;		   BYTE value,
 843  43D4              ; will put ram in page 0 also, page 1 is already there
 844  43D4              FILRAM:
 845  43D4              	; opening (
 846  43D4 CD 2B 43     	CALL CHKCHAR
 847  43D7 28           	DB '('
 848  43D8              	; get start address
 849  43D8 DD 21 2F 54  	LD IX, FRMQNT
 850  43DC CD 59 01     	CALL CALBAS
 851  43DF D5           	PUSH DE
 852  43E0              	; comma
 853  43E0 CD 2B 43     	CALL CHKCHAR
 854  43E3 2C           	DB ','
 855  43E4              	; get count
 856  43E4 DD 21 2F 54  	LD IX, FRMQNT
 857  43E8 CD 59 01     	CALL CALBAS
 858  43EB D5           	PUSH DE
 859  43EC              	; comma
 860  43EC CD 2B 43     	CALL CHKCHAR
 861  43EF 2C           	DB ','
 862  43F0              	; get value
 863  43F0 DD 21 1C 52  	LD IX, GETBYT
 864  43F4 CD 59 01     	CALL CALBAS
 865  43F7 F5           	PUSH AF
 866  43F8              	; ending )
 867  43F8 CD 2B 43     	CALL CHKCHAR
 868  43FB 29           	DB ')'
 869  43FC
 870  43FC              	; save position
 871  43FC E5           	PUSH HL
 872  43FD DD E1        	POP IX
 873  43FF
 874  43FF D1           	POP DE ; actually AF
 875  4400 C1           	POP BC ; count
 876  4401 E1           	POP HL ; start address
 877  4402 78           	LD A, B
 878  4403 B7           	OR A
 879  4404 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 880  4406 B1           	OR C
 881  4407 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 882  4409 79           	LD A, C
 883  440A 3D           	DEC A
 884  440B 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 885  440D              	; one byte to fill
 886  440D 72           	LD (HL), D
 887  440E 18 12        	JR .EXIT
 888  4410              .L1:
 889  4410 D9           	EXX
 890  4411              	; enable page 0
 891  4411 FD 21 18 44  	LD IY, .RET
 892  4415 C3 C8 41     	JP ENABLE_PAGE0
 893  4418              .RET:
 894  4418 FB           	EI
 895  4419 D9           	EXX
 896  441A CD 26 44     	CALL .FILLVALUE
 897  441D D1               POP DE
 898  441E C1               POP BC
 899  441F CD 3F 41         CALL RESTORE_PAGE_INFO
 900  4422              .EXIT:
 901  4422 DD E5        	PUSH IX
 902  4424 E1           	POP HL
 903  4425 C9           	RET
 904  4426
 905  4426              .FILLVALUE:
 906  4426 72               LD (HL), D
 907  4427 54               LD D, H
 908  4428 5D               LD E, L
 909  4429 13               INC DE
 910  442A 0B               DEC BC
 911  442B ED B0            LDIR
 912  442D C9               RET
 913  442E              ; *******************************************************************************************************
 914  442E
 915  442E              ; *******************************************************************************************************
 916  442E              ; function to handle CALL GENCAL basic extension
 917  442E              ; GENCAL ( INT fn_addr, = address of the function to call
 918  442E              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 919  442E              ; output values of reristers will also be stored at reg_list_ptr
 920  442E              GENCAL_VAR_SP:
 921  442E 00 00            DW 0
 922  4430              GENCAL_VAR_SP2:
 923  4430 00 00            DW 0
 924  4432              GENCAL:
 925  4432              	; opening (
 926  4432 CD 2B 43     	CALL CHKCHAR
 927  4435 28           	DB '('
 928  4436              	; get function address
 929  4436 DD 21 2F 54  	LD IX, FRMQNT
 930  443A CD 59 01     	CALL CALBAS
 931  443D D5           	PUSH DE
 932  443E              	; comma
 933  443E CD 2B 43     	CALL CHKCHAR
 934  4441 2C           	DB ','
 935  4442              	; get pointer to register list
 936  4442 DD 21 2F 54  	LD IX, FRMQNT
 937  4446 CD 59 01     	CALL CALBAS
 938  4449 D5           	PUSH DE
 939  444A              	; ending )
 940  444A CD 2B 43     	CALL CHKCHAR
 941  444D 29           	DB ')'
 942  444E
 943  444E              	; save BASIC token position
 944  444E E5           	PUSH HL
 945  444F D9               EXX
 946  4450 E1           	POP HL ; HL'=next basic token
 947  4451 D9               EXX
 948  4452
 949  4452 E1               POP HL ; get pointer to register values
 950  4453 ED 73 2E 44      LD (GENCAL_VAR_SP), SP
 951  4457 F3               DI
 952  4458 F9               LD SP, HL
 953  4459 F1               POP AF
 954  445A C1               POP BC
 955  445B D1               POP DE
 956  445C E1               POP HL
 957  445D DD E1            POP IX
 958  445F FD E1            POP IY
 959  4461 D9               EXX
 960  4462 ED 73 30 44      LD (GENCAL_VAR_SP2), SP
 961  4466 ED 7B 2E 44      LD SP, (GENCAL_VAR_SP)
 962  446A FB               EI
 963  446B D1               POP DE ; get function to call
 964  446C E5               PUSH HL
 965  446D CD 88 44         CALL .EXXDECALL
 966  4470 F3               DI
 967  4471 ED 73 2E 44      LD (GENCAL_VAR_SP), SP
 968  4475 ED 7B 30 44      LD SP, (GENCAL_VAR_SP2)
 969  4479 FD E5            PUSH IY
 970  447B DD E5            PUSH IX
 971  447D E5               PUSH HL
 972  447E D5               PUSH DE
 973  447F C5               PUSH BC
 974  4480 F5               PUSH AF
 975  4481 ED 7B 2E 44      LD SP, (GENCAL_VAR_SP)
 976  4485 FB               EI
 977  4486 E1               POP HL
 978  4487 C9           	RET
 979  4488
 980  4488              .EXXDECALL:
 981  4488 D5               PUSH DE
 982  4489 D9               EXX
 983  448A C9               RET
 984  448B              ; *******************************************************************************************************
 985  448B
 986  448B              ; *******************************************************************************************************
 987  448B              ; function to handle CALL MEMVRM basic extension
 988  448B              ; copies from RAM to VRAM
 989  448B              ; _MEMVRM ( INT source,
 990  448B              ;			INT destination,
 991  448B              ;			INT count,
 992  448B              ;			BYTE wait_vsync) >0 = true
 993  448B              ; will put ram in page 0 also, page 1 is already there
 994  448B              ; wait_vsync will issue HALT before copying
 995  448B              MEMVRM:
 996  448B              	; opening (
 997  448B CD 2B 43     	CALL CHKCHAR
 998  448E 28           	DB '('
 999  448F              	; get source address
1000  448F DD 21 2F 54  	LD IX, FRMQNT
1001  4493 CD 59 01     	CALL CALBAS
1002  4496 D5           	PUSH DE
1003  4497              	; comma
1004  4497 CD 2B 43     	CALL CHKCHAR
1005  449A 2C           	DB ','
1006  449B              	; get destination address
1007  449B DD 21 2F 54  	LD IX, FRMQNT
1008  449F CD 59 01     	CALL CALBAS
1009  44A2 D5           	PUSH DE
1010  44A3              	; comma
1011  44A3 CD 2B 43     	CALL CHKCHAR
1012  44A6 2C           	DB ','
1013  44A7              	; get length
1014  44A7 DD 21 2F 54  	LD IX, FRMQNT
1015  44AB CD 59 01     	CALL CALBAS
1016  44AE D5           	PUSH DE
1017  44AF              	; comma
1018  44AF CD 2B 43     	CALL CHKCHAR
1019  44B2 2C           	DB ','
1020  44B3              	; get vsync wait
1021  44B3 DD 21 1C 52  	LD IX, GETBYT
1022  44B7 CD 59 01     	CALL CALBAS
1023  44BA F5           	PUSH AF
1024  44BB              	; ending )
1025  44BB CD 2B 43     	CALL CHKCHAR
1026  44BE 29           	DB ')'
1027  44BF
1028  44BF                  ; save position in BASIC text
1029  44BF E5           	PUSH HL
1030  44C0 DD E1        	POP IX
1031  44C2
1032  44C2 F1           	POP AF ; wait vsync
1033  44C3 B7           	OR A
1034  44C4 28 03        	JR Z, .L1
1035  44C6 FB               EI
1036  44C7 76           	HALT
1037  44C8 F3           	DI
1038  44C9              .L1:
1039  44C9              	; pop LDIR parameters and store away for later
1040  44C9 C1           	POP BC ; count
1041  44CA D1           	POP DE ; vram destination
1042  44CB E1           	POP HL ; ram source
1043  44CC D9           	EXX
1044  44CD FD 21 D4 44   	LD IY, .RET
1045  44D1 C3 C8 41     	JP ENABLE_PAGE0
1046  44D4              .RET:
1047  44D4 FB           	EI
1048  44D5 D9           	EXX
1049  44D6 CD E2 44     	CALL .LDIRVM
1050  44D9 D1               POP DE
1051  44DA C1               POP BC
1052  44DB CD 3F 41         CALL RESTORE_PAGE_INFO
1053  44DE DD E5        	PUSH IX
1054  44E0 E1           	POP HL
1055  44E1 C9           	RET
1056  44E2
1057  44E2              .LDIRVM:
1058  44E2 EB           	EX DE, HL
1059  44E3 CD FD 40     	CALL SETWRT_LOCAL
1060  44E6 EB           	EX DE, HL
1061  44E7 78           	LD A, B
1062  44E8 B7           	OR A
1063  44E9 28 0D        	JR Z, .L3
1064  44EB C5           	PUSH BC
1065  44EC 0E 98        	LD C, #98
1066  44EE              .L2:
1067  44EE 50           	LD D, B
1068  44EF 06 00        	LD B, 0
1069  44F1 CD FE 44     	CALL .BBYTECOPY
1070  44F4 42           	LD B, D
1071  44F5 10 F7        	DJNZ .L2
1072  44F7 C1           	POP BC
1073  44F8              .L3:
1074  44F8 79           	LD A, C
1075  44F9 B7           	OR A
1076  44FA C8           	RET Z
1077  44FB 41           	LD B, C
1078  44FC 0E 98        	LD C, #98
1079  44FE              .BBYTECOPY:
1080  44FE ED A3        	OUTI
1081  4500 C2 FE 44     	JP	NZ, .BBYTECOPY
1082  4503 C9           	RET
1083  4504              ; *******************************************************************************************************
1084  4504
1085  4504              ; *******************************************************************************************************
1086  4504              ; function to handle CALL VRMMEM basic extension
1087  4504              ; copies from RAM to VRAM
1088  4504              ; _VRMMEM ( INT source,
1089  4504              ;			INT destination,
1090  4504              ;			INT count
1091  4504              ; will put ram in page 0 also, page 1 is already there
1092  4504              VRMMEM:
1093  4504              	; opening (
1094  4504 CD 2B 43     	CALL CHKCHAR
1095  4507 28           	DB '('
1096  4508              	; get source address
1097  4508 DD 21 2F 54  	LD IX, FRMQNT
1098  450C CD 59 01     	CALL CALBAS
1099  450F D5           	PUSH DE
1100  4510              	; comma
1101  4510 CD 2B 43     	CALL CHKCHAR
1102  4513 2C           	DB ','
1103  4514              	; get destination address
1104  4514 DD 21 2F 54  	LD IX, FRMQNT
1105  4518 CD 59 01     	CALL CALBAS
1106  451B D5           	PUSH DE
1107  451C              	; comma
1108  451C CD 2B 43     	CALL CHKCHAR
1109  451F 2C           	DB ','
1110  4520              	; get length
1111  4520 DD 21 2F 54  	LD IX, FRMQNT
1112  4524 CD 59 01     	CALL CALBAS
1113  4527 D5           	PUSH DE
1114  4528              	; ending )
1115  4528 CD 2B 43     	CALL CHKCHAR
1116  452B 29           	DB ')'
1117  452C
1118  452C                  ; save position in BASIC text
1119  452C E5           	PUSH HL
1120  452D DD E1        	POP IX
1121  452F
1122  452F C1           	POP BC ; count
1123  4530 D1           	POP DE ; destination
1124  4531 E1           	POP HL ; source
1125  4532 D9           	EXX
1126  4533 FD 21 3A 45  	LD IY, .RET
1127  4537 C3 C8 41     	JP ENABLE_PAGE0
1128  453A              .RET:
1129  453A FB           	EI
1130  453B D9           	EXX
1131  453C CD 48 45     	CALL .LDIRMV
1132  453F D1               POP DE
1133  4540 C1               POP BC
1134  4541 CD 3F 41         CALL RESTORE_PAGE_INFO
1135  4544 DD E5        	PUSH IX
1136  4546 E1           	POP HL
1137  4547 C9           	RET
1138  4548
1139  4548              .LDIRMV:
1140  4548              	; set VRAM address *exactly* as in ROM, otherwise corruption
1141  4548 7D           	LD	A, L
1142  4549 F3           	DI
1143  454A D3 99        	OUT	(099H), A
1144  454C 7C           	LD	A, H
1145  454D E6 3F        	AND	03FH
1146  454F D3 99        	OUT	(099H), A
1147  4551 FB           	EI
1148  4552              	;EX (SP), HL
1149  4552              	;EX (SP), HL
1150  4552              	;NOP
1151  4552              	;NOP
1152  4552              .L4:
1153  4552 DB 98            IN A, (#98)
1154  4554 12           	LD (DE), A
1155  4555 13               INC DE
1156  4556 0B               DEC BC
1157  4557 79               LD A, C
1158  4558 B0               OR B
1159  4559 20 F7            JR NZ, .L4
1160  455B C9               RET
1161  455C              ; *******************************************************************************************************
1162  455C
1163  455C              ; *******************************************************************************************************
1164  455C              ; H.TIMI function
1165  455C              MBGE_HTIMI:
1166  455C               EXPORT MBGE_HTIMI
1167  455C F5           	PUSH AF
1168  455D
1169  455D CD D8 41     	CALL SPRATR_UPDATE
1170  4560
1171  4560               IFNDEF EXCLUDE_SOUND_PLAYER
1172  4560 ~            	LD A, (SOUND_ENABLED)
1173  4560 ~            	OR A
1174  4560 ~            	JR Z, .EXIT
1175  4560 ~
1176  4560 ~            	; enable page 2
1177  4560 ~                LD A, 2
1178  4560 ~                CALL GET_PAGE_INFO
1179  4560 ~                PUSH BC
1180  4560 ~                PUSH DE
1181  4560 ~                LD A, (RAMAD2)
1182  4560 ~                LD H, 080H
1183  4560 ~                CALL LOCAL_ENASLT
1184  4560 ~            	; enable page 0
1185  4560 ~                XOR A
1186  4560 ~                CALL GET_PAGE_INFO
1187  4560 ~                PUSH BC
1188  4560 ~                PUSH DE
1189  4560 ~                LD A, (RAMAD0)
1190  4560 ~                LD H, 0
1191  4560 ~                CALL LOCAL_ENASLT
1192  4560 ~
1193  4560 ~            	CALL PLY_AKG_PLAY
1194  4560 ~
1195  4560 ~            	; restore page 0
1196  4560 ~                POP DE
1197  4560 ~                POP BC
1198  4560 ~                CALL RESTORE_PAGE_INFO
1199  4560 ~            	; restore page 2
1200  4560 ~                POP DE
1201  4560 ~                POP BC
1202  4560 ~                CALL RESTORE_PAGE_INFO
1203  4560               ENDIF
1204  4560
1205  4560              .EXIT:
1206  4560 F1           	POP AF
1207  4561 C3 12 40     	JP ORIG.HTIMI
1208  4564              ; *******************************************************************************************************
1209  4564
1210  4564              ; *******************************************************************************************************
1211  4564              ; interrupt handler when page 0 enabled
1212  4564              VBLANK:
1213  4564              	EXPORT VBLANK
1214  4564
1215  4564 F5               PUSH AF
1216  4565              	; is VDP originator ?
1217  4565 DB 99        	IN	A, (099H)
1218  4567 A7           	AND	A
1219  4568 F2 6B 45     	JP P, .EXIT
1220  456B
1221  456B               IFNDEF EXCLUDE_SOUND_PLAYER
1222  456B ~            	LD A, (SOUND_ENABLED)
1223  456B ~            	OR A
1224  456B ~            	JR Z, .EXIT
1225  456B ~
1226  456B ~                PUSH BC
1227  456B ~                PUSH DE
1228  456B ~                PUSH HL
1229  456B ~                EX AF, AF'
1230  456B ~                EXX
1231  456B ~                PUSH AF
1232  456B ~                PUSH BC
1233  456B ~                PUSH DE
1234  456B ~                PUSH HL
1235  456B ~                PUSH IX
1236  456B ~                PUSH IY
1237  456B ~
1238  456B ~            	CALL PLY_AKG_PLAY
1239  456B ~
1240  456B ~                POP IY
1241  456B ~                POP IX
1242  456B ~                POP HL
1243  456B ~                POP DE
1244  456B ~                POP BC
1245  456B ~                POP AF
1246  456B ~                EX AF, AF'
1247  456B ~                EXX
1248  456B ~                POP HL
1249  456B ~                POP DE
1250  456B ~                POP BC
1251  456B               ENDIF
1252  456B
1253  456B              .EXIT:
1254  456B F1           	POP AF
1255  456C FB           	EI
1256  456D ED 4D        	RETI
1257  456F              ; *******************************************************************************************************
1258  456F
1259  456F               IFNDEF EXCLUDE_SOUND_PLAYER
1260  456F ~            ; *******************************************************************************************************
1261  456F ~            ; function to handle CALL SNDPLYINIT basic extension
1262  456F ~            ; initializes sound player
1263  456F ~            ; _SNDPLYINIT ( INT music_offset,
1264  456F ~            ;				INT sfx_offset, can be -1 if no SFX
1265  456F ~            ; will put ram in page 0 also, page 1 is already there
1266  456F ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1267  456F ~            SNDPLYINIT:
1268  456F ~            	; opening (
1269  456F ~            	CALL CHKCHAR
1270  456F ~            	DB '('
1271  456F ~            	; get music address
1272  456F ~            	LD IX, FRMQNT
1273  456F ~            	CALL CALBAS
1274  456F ~            	PUSH DE
1275  456F ~            	; comma
1276  456F ~            	CALL CHKCHAR
1277  456F ~            	DB ','
1278  456F ~            	; get sfx address
1279  456F ~            	LD IX, FRMQNT
1280  456F ~            	CALL CALBAS
1281  456F ~            	PUSH DE
1282  456F ~            	; ending )
1283  456F ~            	CALL CHKCHAR
1284  456F ~            	DB ')'
1285  456F ~
1286  456F ~                ; save position in BASIC text
1287  456F ~            	LD B, H
1288  456F ~            	LD C, L
1289  456F ~
1290  456F ~            	; pop LDIR parameters and store away for later
1291  456F ~            	POP DE ; sfx address
1292  456F ~            	POP HL ; music address
1293  456F ~            	PUSH BC ; basic text location
1294  456F ~            	EXX
1295  456F ~            	LD IY, .RET
1296  456F ~            	JP ENABLE_PAGE0
1297  456F ~            .RET:
1298  456F ~            	EXX
1299  456F ~
1300  456F ~            	PUSH DE
1301  456F ~            	XOR A
1302  456F ~            	; HL = music location
1303  456F ~            	CALL PLY_AKG_INIT
1304  456F ~            	LD A, 1
1305  456F ~            	LD (MUSIC_INIT_STATUS), A
1306  456F ~
1307  456F ~            	POP HL ; SFX
1308  456F ~            	; check if SFX address -1
1309  456F ~            	INC HL
1310  456F ~            	LD A, L
1311  456F ~            	OR H
1312  456F ~            	JR Z,.L1
1313  456F ~            	DEC HL
1314  456F ~            	CALL PLY_AKG_INITSOUNDEFFECTS
1315  456F ~            	LD A, 1
1316  456F ~            	LD (SFX_INIT_STATUS), A
1317  456F ~            .L1:
1318  456F ~                POP DE
1319  456F ~                POP BC
1320  456F ~                CALL RESTORE_PAGE_INFO
1321  456F ~
1322  456F ~            	POP HL
1323  456F ~            	RET
1324  456F ~            ; *******************************************************************************************************
1325  456F ~
1326  456F ~            ; *******************************************************************************************************
1327  456F ~            ; function to handle CALL SNDPLYON basic extension
1328  456F ~            ; enables sound player
1329  456F ~            ; _SNDPLYON
1330  456F ~            ; sets SOUND_ENABLED variable to 1 if init call was done
1331  456F ~            ; if not throws out of data error
1332  456F ~            SNDPLYON:
1333  456F ~            	LD A, (MUSIC_INIT_STATUS)
1334  456F ~            	OR A
1335  456F ~            	JR NZ, .L1
1336  456F ~            	; player not initialized, throw error
1337  456F ~            	LD E, 04 ; Out of DATA
1338  456F ~            	JP THROW_ERROR
1339  456F ~            .L1:
1340  456F ~            	LD (SOUND_ENABLED), A
1341  456F ~            	; disable key click
1342  456F ~            	XOR A
1343  456F ~            	LD (CLIKSW), A
1344  456F ~            	RET
1345  456F ~            ; *******************************************************************************************************
1346  456F ~
1347  456F ~            ; *******************************************************************************************************
1348  456F ~            ; function to handle CALL SNDPLYOFF basic extension
1349  456F ~            ; disables sound player
1350  456F ~            ; _SNDPLYOFF
1351  456F ~            ; sets SOUND_ENABLED variable to 0
1352  456F ~            ; calls AKG to stop music and SFX on all channels if initialized
1353  456F ~            SNDPLYOFF:
1354  456F ~            	LD A, (SOUND_ENABLED)
1355  456F ~            	OR A
1356  456F ~            	RET Z ; already stopped
1357  456F ~            	XOR A
1358  456F ~            	LD (SOUND_ENABLED), A
1359  456F ~            	PUSH HL
1360  456F ~            	CALL PLY_AKG_STOP
1361  456F ~            	LD A, (SFX_INIT_STATUS)
1362  456F ~            	OR A
1363  456F ~            	JR Z, .EXIT ; SFX not in use
1364  456F ~            	XOR A
1365  456F ~            	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1366  456F ~            	LD A, 1
1367  456F ~            	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1368  456F ~            	LD A, 2
1369  456F ~            	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1370  456F ~            .EXIT:
1371  456F ~            	POP HL
1372  456F ~            	RET
1373  456F ~            ; *******************************************************************************************************
1374  456F ~
1375  456F ~            ; *******************************************************************************************************
1376  456F ~            ; function to handle CALL SNDSFX basic extension
1377  456F ~            ; plays a sound effect
1378  456F ~            ; _SNDSFX ( BYTE sfx_number, >0
1379  456F ~            ;			BYTE channel, = 0,1 or 2
1380  456F ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
1381  456F ~            ; will put ram in page 0 also, page 1 is already there
1382  456F ~            ; if sound off throws illegal function call
1383  456F ~            ; if sfx not initialized, throws out of data
1384  456F ~            SNDSFX:
1385  456F ~            	; opening (
1386  456F ~            	CALL CHKCHAR
1387  456F ~            	DB '('
1388  456F ~            	; get sfx_number
1389  456F ~            	LD IX, GETBYT
1390  456F ~            	CALL CALBAS
1391  456F ~            	PUSH DE
1392  456F ~            	; comma
1393  456F ~            	CALL CHKCHAR
1394  456F ~            	DB ','
1395  456F ~            	; get sfx address
1396  456F ~            	LD IX, GETBYT
1397  456F ~            	CALL CALBAS
1398  456F ~            	PUSH DE
1399  456F ~            	; comma
1400  456F ~            	CALL CHKCHAR
1401  456F ~            	DB ','
1402  456F ~            	; get inverted volume
1403  456F ~            	LD IX, GETBYT
1404  456F ~            	CALL CALBAS
1405  456F ~            	PUSH DE
1406  456F ~            	; ending )
1407  456F ~            	CALL CHKCHAR
1408  456F ~            	DB ')'
1409  456F ~
1410  456F ~            	LD A, (SOUND_ENABLED)
1411  456F ~            	OR A
1412  456F ~            	JR NZ, .L1
1413  456F ~            	; sound disabled, throw illegal function call
1414  456F ~            	LD E, 5
1415  456F ~            	JP THROW_ERROR
1416  456F ~            .L1:
1417  456F ~            	LD A, (SFX_INIT_STATUS)
1418  456F ~            	OR A
1419  456F ~            	JR NZ, .L2
1420  456F ~            	; sfx data not initialized, throw out of data
1421  456F ~            	LD E, 4
1422  456F ~            	JP THROW_ERROR
1423  456F ~            .L2:
1424  456F ~            	; pop  parameters and store away for later
1425  456F ~            	POP DE ; inverted volume
1426  456F ~            	LD B, E
1427  456F ~            	POP DE ; channel
1428  456F ~            	LD C, E
1429  456F ~            	POP DE
1430  456F ~            	LD A, E
1431  456F ~            	EX AF, AF'
1432  456F ~            	PUSH HL ; basic text location
1433  456F ~            	EXX
1434  456F ~            	LD IY, .RET
1435  456F ~            	JP ENABLE_PAGE0
1436  456F ~            .RET:
1437  456F ~            	EXX
1438  456F ~            	EX AF, AF'
1439  456F ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
1440  456F ~
1441  456F ~                POP DE
1442  456F ~                POP BC
1443  456F ~                CALL RESTORE_PAGE_INFO
1444  456F ~
1445  456F ~            	POP HL
1446  456F ~            	RET
1447  456F ~            ; *******************************************************************************************************
1448  456F               ENDIF
1449  456F
1450  456F              ; *******************************************************************************************************
1451  456F              ; function to handle CALL SPRATRINI basic extension
1452  456F              ; initializes sprites handler
1453  456F              ; _SPRATRINI ( INT sprites_attributes_data,
1454  456F              ;			   INT update_variable_location,
1455  456F              ;			   INT sprite_flicker_enabled )
1456  456F              ; expects both locations to be in range #8000+ or throws an error
1457  456F              ; since these should be BASIC variables
1458  456F              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
1459  456F              SPRATRINI:
1460  456F              	; opening (
1461  456F CD 2B 43     	CALL CHKCHAR
1462  4572 28           	DB '('
1463  4573              	; get address of sprite attribute table DIM SA%(3,31)
1464  4573 DD 21 2F 54  	LD IX, FRMQNT
1465  4577 CD 59 01     	CALL CALBAS
1466  457A D5           	PUSH DE
1467  457B              	; comma
1468  457B CD 2B 43     	CALL CHKCHAR
1469  457E 2C           	DB ','
1470  457F              	; get address of sprite attribute table DIM SA%(3,31)
1471  457F DD 21 2F 54  	LD IX, FRMQNT
1472  4583 CD 59 01     	CALL CALBAS
1473  4586 D5           	PUSH DE
1474  4587              	; comma
1475  4587 CD 2B 43     	CALL CHKCHAR
1476  458A 2C           	DB ','
1477  458B              	; get flicker enabled flag
1478  458B DD 21 2F 54  	LD IX, FRMQNT
1479  458F CD 59 01     	CALL CALBAS
1480  4592 D5           	PUSH DE
1481  4593              	; ending )
1482  4593 CD 2B 43     	CALL CHKCHAR
1483  4596 29           	DB ')'
1484  4597
1485  4597 D1           	POP DE ; get flicker flag
1486  4598 7A           	LD A, D
1487  4599 B3           	OR E
1488  459A 32 1C 40     	LD (SPRFLICKER_ENABLED), A
1489  459D
1490  459D D1           	POP DE ; update variable location
1491  459E CB 7A        	BIT 7, D ; is address >= &h8000
1492  45A0 20 05        	JR NZ, .L1
1493  45A2 1E 05        	LD E, 5 ; illegal function call
1494  45A4 C3 43 43     	JP THROW_ERROR
1495  45A7              .L1:
1496  45A7 ED 53 18 40  	LD (SPRATR_UPDATE_FLAG), DE
1497  45AB D1           	POP DE ; address of sprite attribute table
1498  45AC CB 7A        	BIT 7, D ; is address >= &h8000
1499  45AE 20 05        	JR NZ, .L2
1500  45B0 1E 05        	LD E, 5 ; illegal function call
1501  45B2 C3 43 43     	JP THROW_ERROR
1502  45B5              .L2:
1503  45B5 ED 53 1A 40  	LD (SPRATR_DATA), DE
1504  45B9 3E 01        	LD A, 1
1505  45BB 32 17 40     	LD (SPRATR_INIT_STATUS), A
1506  45BE C9           	RET
1507  45BF              ; *******************************************************************************************************
1508  45BF
1509  45BF              ; *******************************************************************************************************
1510  45BF              ; function to handle CALL SPRSET basic extension
1511  45BF              ; sets position, and optionally pattern and color of sprite
1512  45BF              ; _SPRSET ( BYTE sprite_num , valid 0-31
1513  45BF              ;			INT x,
1514  45BF              ;			INT y,
1515  45BF              ;			INT pattern, valid 0-31, otherwise ignored
1516  45BF              ;			INT color, valid 0-15, otherwise ignored
1517  45BF              SPRSET:
1518  45BF 3A 17 40     	LD A, (SPRATR_INIT_STATUS)
1519  45C2 B7           	OR A
1520  45C3 20 05        	JR NZ, .L1
1521  45C5 1E 05        	LD E, 5 ; illegal function call
1522  45C7 C3 43 43     	JP THROW_ERROR
1523  45CA              .L1:
1524  45CA              	; opening (
1525  45CA CD 2B 43     	CALL CHKCHAR
1526  45CD 28           	DB '('
1527  45CE              	; get sprite number
1528  45CE DD 21 1C 52  	LD IX, GETBYT
1529  45D2 CD 59 01     	CALL CALBAS
1530  45D5 F5           	PUSH AF
1531  45D6              	; comma
1532  45D6 CD 2B 43     	CALL CHKCHAR
1533  45D9 2C           	DB ','
1534  45DA              	; get x
1535  45DA DD 21 2F 54  	LD IX, FRMQNT
1536  45DE CD 59 01     	CALL CALBAS
1537  45E1 D5           	PUSH DE
1538  45E2              	; comma
1539  45E2 CD 2B 43     	CALL CHKCHAR
1540  45E5 2C           	DB ','
1541  45E6              	; get y
1542  45E6 DD 21 2F 54  	LD IX, FRMQNT
1543  45EA CD 59 01     	CALL CALBAS
1544  45ED D5           	PUSH DE
1545  45EE              	; comma
1546  45EE CD 2B 43     	CALL CHKCHAR
1547  45F1 2C           	DB ','
1548  45F2              	; get pattern
1549  45F2 DD 21 2F 54  	LD IX, FRMQNT
1550  45F6 CD 59 01     	CALL CALBAS
1551  45F9 D5           	PUSH DE
1552  45FA              	; comma
1553  45FA CD 2B 43     	CALL CHKCHAR
1554  45FD 2C           	DB ','
1555  45FE              	; get color
1556  45FE DD 21 2F 54  	LD IX, FRMQNT
1557  4602 CD 59 01     	CALL CALBAS
1558  4605 D5           	PUSH DE
1559  4606              	; ending )
1560  4606 CD 2B 43     	CALL CHKCHAR
1561  4609 29           	DB ')'
1562  460A
1563  460A                  ; save position in BASIC text
1564  460A E5           	PUSH HL
1565  460B DD E1        	POP IX
1566  460D
1567  460D C1           	POP BC ; color
1568  460E D1           	POP DE ; pattern
1569  460F D9           	EXX
1570  4610 C1           	POP BC ; y
1571  4611 D1           	POP DE ; x
1572  4612 F1           	POP AF ; sprite number
1573  4613 FE 20        	CP 32
1574  4615 38 05        	JR C, .L2
1575  4617 1E 05        	LD E, 5 ; illegal function call
1576  4619 C3 43 43     	JP THROW_ERROR
1577  461C              .L2:
1578  461C              	; find location in sprite attributes table
1579  461C 87          > ADD A, A
1579  461D 87          > ADD A, A
1579  461E 87          > ADD A, A
1580  461F D5           	PUSH DE
1581  4620 16 00        	LD D, 0
1582  4622 5F           	LD E, A
1583  4623 2A 1A 40     	LD HL, (SPRATR_DATA)
1584  4626 19           	ADD HL, DE
1585  4627 D1           	POP DE
1586  4628              	; set y
1587  4628 71           	LD (HL), C
1588  4629 23           	INC HL
1589  462A 70           	LD (HL), B
1590  462B 23           	INC HL
1591  462C              	; set x
1592  462C 73           	LD (HL), E
1593  462D 23           	INC HL
1594  462E 72           	LD (HL), D
1595  462F 23           	INC HL
1596  4630 E5           	PUSH HL
1597  4631 D9           	EXX
1598  4632 E1           	POP HL
1599  4633              	; check if 0<=pattern<32
1600  4633 7A           	LD A, D
1601  4634 B7           	OR A
1602  4635 20 0B        	JR NZ, .L3
1603  4637 7D           	LD A, L
1604  4638 FE 20        	CP 32
1605  463A 30 06        	JR NC, .L3
1606  463C              	; set pattern
1607  463C 73           	LD (HL), E
1608  463D 23           	INC HL
1609  463E 72           	LD (HL), D
1610  463F 23           	INC HL
1611  4640 18 02        	JR .L4
1612  4642              .L3:
1613  4642              	; skip pattern
1614  4642 23          > INC HL
1614  4643 23          > INC HL
1615  4644              .L4:
1616  4644              	; check if 0<=color<16
1617  4644 78           	LD A, B
1618  4645 B7           	OR A
1619  4646 20 08        	JR NZ, .L5
1620  4648 79           	LD A, C
1621  4649 FE 10        	CP 16
1622  464B 30 03        	JR NC, .L5
1623  464D              	; set color
1624  464D 71           	LD (HL), C
1625  464E 23           	INC HL
1626  464F 70           	LD (HL), B
1627  4650
1628  4650              .L5:
1629  4650 DD E5        	PUSH IX
1630  4652 E1           	POP HL
1631  4653 C9           	RET
1632  4654              ; *******************************************************************************************************
1633  4654
1634  4654              ; *******************************************************************************************************
1635  4654              ; function sets sprite location based on initial coordinates and offset provided
1636  4654              ; input A=sprite number in SPRATR_DATA , 0-31
1637  4654              ; input DE=initial x
1638  4654              ; input BC=initial y
1639  4654              ; input IY=location where delta y,x are located
1640  4654              ; modifies AF, HL, IX
1641  4654              SPRSET_DELTA_POS:
1642  4654 87          > ADD A, A
1642  4655 87          > ADD A, A
1642  4656 87          > ADD A, A
1643  4657 D5           	PUSH DE
1644  4658 16 00        	LD D, 0
1645  465A 5F           	LD E, A
1646  465B DD 2A 1A 40  	LD IX, (SPRATR_DATA)
1647  465F DD 19        	ADD IX, DE
1648  4661 D1           	POP DE
1649  4662              	; IX=sprite's y location
1650  4662 FD 6E 00     	LD L, (IY)
1651  4665 FD 66 01     	LD H, (IY+1)
1652  4668 09           	ADD HL, BC
1653  4669 DD 75 00     	LD (IX), L
1654  466C DD 74 01     	LD (IX+1), H
1655  466F FD 6E 02     	LD L, (IY+2)
1656  4672 FD 66 03     	LD H, (IY+3)
1657  4675 19           	ADD HL, DE
1658  4676 DD 75 02     	LD (IX+2), L
1659  4679 DD 74 03     	LD (IX+3), H
1660  467C C9           	RET
1661  467D              ; *******************************************************************************************************
1662  467D
1663  467D              ; *******************************************************************************************************
1664  467D              ; function to handle CALL SPRGRPMOV basic extension
1665  467D              ; sets position of a group of sprites described with
1666  467D              ; { int sprite_num, int delta_y, int delta_x } [count]
1667  467D              ; _SPRGRPMOV ( INT x,
1668  467D              ;			   INT y,
1669  467D              ;			   INT data_ptr,
1670  467D              ;			   BYTE count,
1671  467D              ; will put ram in page 0 also, page 1 is already there
1672  467D              SPRGRPMOV:
1673  467D 3A 17 40     	LD A, (SPRATR_INIT_STATUS)
1674  4680 B7           	OR A
1675  4681 20 05        	JR NZ, .L1
1676  4683 1E 05        	LD E, 5 ; illegal function call
1677  4685 C3 43 43     	JP THROW_ERROR
1678  4688              .L1:
1679  4688              	; opening (
1680  4688 CD 2B 43     	CALL CHKCHAR
1681  468B 28           	DB '('
1682  468C              	; get x
1683  468C DD 21 2F 54  	LD IX, FRMQNT
1684  4690 CD 59 01     	CALL CALBAS
1685  4693 D5           	PUSH DE
1686  4694              	; comma
1687  4694 CD 2B 43     	CALL CHKCHAR
1688  4697 2C           	DB ','
1689  4698              	; get y
1690  4698 DD 21 2F 54  	LD IX, FRMQNT
1691  469C CD 59 01     	CALL CALBAS
1692  469F D5           	PUSH DE
1693  46A0              	; comma
1694  46A0 CD 2B 43     	CALL CHKCHAR
1695  46A3 2C           	DB ','
1696  46A4              	; get data pointer
1697  46A4 DD 21 2F 54  	LD IX, FRMQNT
1698  46A8 CD 59 01     	CALL CALBAS
1699  46AB D5           	PUSH DE
1700  46AC              	; comma
1701  46AC CD 2B 43     	CALL CHKCHAR
1702  46AF 2C           	DB ','
1703  46B0              	; get count
1704  46B0 DD 21 1C 52  	LD IX, GETBYT
1705  46B4 CD 59 01     	CALL CALBAS
1706  46B7 F5           	PUSH AF
1707  46B8              	; ending )
1708  46B8 CD 2B 43     	CALL CHKCHAR
1709  46BB 29           	DB ')'
1710  46BC
1711  46BC E5           	PUSH HL
1712  46BD DD E1        	POP IX
1713  46BF
1714  46BF C1           	POP BC ; count
1715  46C0 E1           	POP HL ; data pointer
1716  46C1 D9           	EXX
1717  46C2 C1           	POP BC ; y
1718  46C3 D1           	POP DE ; x
1719  46C4 D9           	EXX
1720  46C5
1721  46C5 DD E5        	PUSH IX ; save position in BASIC buffer
1722  46C7
1723  46C7 C5           	PUSH BC
1724  46C8 E5           	PUSH HL
1725  46C9 AF               XOR A
1726  46CA CD 08 41         CALL GET_PAGE_INFO
1727  46CD D9           	EXX
1728  46CE E1           	POP HL
1729  46CF F1           	POP AF
1730  46D0 D9           	EXX
1731  46D1 C5               PUSH BC
1732  46D2 D5               PUSH DE
1733  46D3 D9           	EXX
1734  46D4 F5           	PUSH AF
1735  46D5 E5           	PUSH HL
1736  46D6 D9           	EXX
1737  46D7 3A 41 F3         LD A, (RAMAD0)
1738  46DA 26 00            LD H, 0
1739  46DC CD 4F 41         CALL LOCAL_ENASLT
1740  46DF FB           	EI
1741  46E0 E1           	POP HL
1742  46E1 C1           	POP BC
1743  46E2 CD EC 46     	CALL .UPDATE_LOC
1744  46E5 D1               POP DE
1745  46E6 C1               POP BC
1746  46E7 CD 3F 41         CALL RESTORE_PAGE_INFO
1747  46EA E1           	POP HL
1748  46EB C9           	RET
1749  46EC
1750  46EC              .UPDATE_LOC:
1751  46EC              .L4:
1752  46EC 7E           	LD A, (HL)
1753  46ED 23           	INC HL
1754  46EE 23           	INC HL
1755  46EF E5           	PUSH HL
1756  46F0 FD E1        	POP IY
1757  46F2 D9           	EXX
1758  46F3 CD 54 46     	CALL SPRSET_DELTA_POS
1759  46F6 D9           	EXX
1760  46F7 23          > INC HL
1760  46F8 23          > INC HL
1760  46F9 23          > INC HL
1760  46FA 23          > INC HL
1761  46FB 10 EF        	DJNZ .L4
1762  46FD C9           	RET
1763  46FE              ; *******************************************************************************************************
1764  46FE
1765  46FE              ; *******************************************************************************************************
1766  46FE              ; function rotates mask and data of several characters and applies to background data
1767  46FE              ; this handles x-shift from 0 to 4
1768  46FE              ; contains self-modifying code that is set-up from external function
1769  46FE              ; input HL=pointer to mask data
1770  46FE              ; input HL'=pointer to character data
1771  46FE              ; input DE=output buffer containing background data
1772  46FE              ; input BC=DE+8
1773  46FE              ; input A=number of characters to process
1774  46FE              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1775  46FE              SHIFT04:
1776  46FE 08           	EX AF, AF'
1777  46FF 7E           	LD A, (HL) ; get mask
1778  4700 D9           	EXX
1779  4701 57           	LD D, A
1780  4702 1E FF        	LD E, #FF
1781  4704 37           	SCF
1782  4705              .M1:
1783  4705 18 FE        	JR .M1 ; this is self-modifying part
1784  4707 CB 1A        	RR D
1785  4709 CB 1B        	RR E
1786  470B CB 1A        	RR D
1787  470D CB 1B        	RR E
1788  470F CB 1A        	RR D
1789  4711 CB 1B        	RR E
1790  4713 CB 1A        	RR D
1791  4715 CB 1B        	RR E
1792  4717
1793  4717 46           	LD B, (HL) ; get data
1794  4718 0E 00        	LD C, 0
1795  471A              .M2:
1796  471A 18 FE        	JR .M2 ; also self-modifying part
1797  471C CB 38        	SRL B
1798  471E CB 19        	RR C
1799  4720 CB 38        	SRL B
1800  4722 CB 19        	RR C
1801  4724 CB 38        	SRL B
1802  4726 CB 19        	RR C
1803  4728 CB 38        	SRL B
1804  472A CB 19        	RR C
1805  472C
1806  472C D9           	EXX
1807  472D 1A           	LD A, (DE) ; background
1808  472E D9           	EXX
1809  472F A2           	AND D
1810  4730 B0           	OR B
1811  4731 D9           	EXX
1812  4732 12           	LD (DE), A
1813  4733
1814  4733 0A           	LD A, (BC)
1815  4734 D9           	EXX
1816  4735 A3           	AND E
1817  4736 B1           	OR C
1818  4737 23           	INC HL
1819  4738 D9           	EXX
1820  4739 02           	LD (BC), A
1821  473A
1822  473A 23           	INC HL
1823  473B 13           	INC DE
1824  473C 03           	INC BC
1825  473D
1826  473D 08           	EX AF, AF'
1827  473E 3D           	DEC A
1828  473F C2 FE 46     	JP NZ, SHIFT04
1829  4742 C9           	RET
1830  4743              ; *******************************************************************************************************
1831  4743
1832  4743              ; *******************************************************************************************************
1833  4743              ; function rotates mask and data of several characters and applies to background data
1834  4743              ; this handles x-shift from 5 to 8
1835  4743              ; contains self-modifying code that is set-up from external function
1836  4743              ; input HL=pointer to mask data
1837  4743              ; input HL'=pointer to character data
1838  4743              ; input DE=output buffer containing background data
1839  4743              ; input BC=DE+8
1840  4743              ; input A=number of characters to process
1841  4743              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1842  4743              SHIFT58:
1843  4743 08           	EX AF, AF'
1844  4744 7E           	LD A, (HL) ; get mask
1845  4745 D9           	EXX
1846  4746 57           	LD D, A
1847  4747 1E FF        	LD E, #FF
1848  4749 37           	SCF
1849  474A              .M1:
1850  474A 18 FE        	JR .M1 ; this is self-modifying part
1851  474C CB 12        	RL D
1852  474E CB 13        	RL E
1853  4750 CB 12        	RL D
1854  4752 CB 13        	RL E
1855  4754 CB 12        	RL D
1856  4756 CB 13        	RL E
1857  4758
1858  4758 46           	LD B, (HL)
1859  4759 0E 00        	LD C, 0
1860  475B              .M2:
1861  475B 18 FE        	JR .M2 ; also self-modifying part
1862  475D CB 20        	SLA B
1863  475F CB 11        	RL C
1864  4761 CB 20        	SLA B
1865  4763 CB 11        	RL C
1866  4765 CB 20        	SLA B
1867  4767 CB 11        	RL C
1868  4769
1869  4769 D9           	EXX
1870  476A 1A           	LD A, (DE) ; background
1871  476B D9           	EXX
1872  476C A3           	AND E
1873  476D B1           	OR C
1874  476E D9           	EXX
1875  476F 12           	LD (DE), A
1876  4770
1877  4770 0A           	LD A, (BC)
1878  4771 D9           	EXX
1879  4772 A2           	AND D
1880  4773 B0           	OR B
1881  4774 23           	INC HL
1882  4775 D9           	EXX
1883  4776 02           	LD (BC), A
1884  4777
1885  4777 23           	INC HL
1886  4778 13           	INC DE
1887  4779 03           	INC BC
1888  477A
1889  477A 08           	EX AF, AF'
1890  477B 3D           	DEC A
1891  477C C2 43 47     	JP NZ, SHIFT58
1892  477F C9           	RET
1893  4780              ; *******************************************************************************************************
1894  4780
1895  4780              ; *******************************************************************************************************
1896  4780              ; routine that shifts one row of characters
1897  4780              ; contains self-modifying code that is set-up from external function
1898  4780              ; input HL=pointer to mask data
1899  4780              ; input HL'=pointer to character data
1900  4780              ; input DE=output buffer containing background data
1901  4780              ; input A=number of characters to process
1902  4780              ; input IX=pointer to structure describing input data
1903  4780              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1904  4780              SHIFT_ROW:
1905  4780 F5           	PUSH AF
1906  4781 ED 53 20 40  		LD (BLIT_TMP1), DE
1907  4785 E5           		PUSH HL
1908  4786 CD C9 47     			CALL .ADDYSHIFT
1909  4789 E1           		POP HL
1910  478A ED 53 22 40  		LD (BLIT_TMP2), DE ; DE+vertical shift
1911  478E              .L1:
1912  478E 3E 08        		LD A, 8
1913  4790 DD 96 02     		SUB (IX+2) ; y shift
1914  4793              .CALL1:
1915  4793 CD 00 00     		CALL 0
1916  4796 DD 7E 02     		LD A, (IX+2); y shift
1917  4799 B7           		OR A
1918  479A 28 26        		JR Z, .DONE
1919  479C ED 5B 20 40  		LD DE, (BLIT_TMP1)
1920  47A0 E5           		PUSH HL
1921  47A1 CD D7 47     			CALL .DETONEXTROW
1922  47A4 E1           		POP HL
1923  47A5              .CALL2:
1924  47A5 CD 00 00     		CALL 0
1925  47A8 ED 5B 20 40  		LD DE, (BLIT_TMP1)
1926  47AC E5           		PUSH HL
1927  47AD CD D1 47     			CALL .ADD8
1928  47B0 E1           		POP HL
1929  47B1 ED 53 20 40  		LD (BLIT_TMP1), DE
1930  47B5 ED 5B 22 40  		LD DE, (BLIT_TMP2)
1931  47B9 E5           		PUSH HL
1932  47BA CD D1 47     			CALL .ADD8
1933  47BD E1           		POP HL
1934  47BE ED 53 22 40  		LD (BLIT_TMP2), DE ; DE+vertical shift
1935  47C2              .DONE:
1936  47C2 F1           	POP AF
1937  47C3 3D           	DEC A
1938  47C4 C8           	RET Z
1939  47C5 F5           	PUSH AF
1940  47C6 C3 8E 47     	JP .L1
1941  47C9              .ADDYSHIFT:
1942  47C9 EB           	EX DE, HL
1943  47CA 16 00        	LD D, 0
1944  47CC DD 5E 02     	LD E, (IX+2); y shift
1945  47CF 18 0C        	JR .MOVDEBC
1946  47D1              .ADD8:
1947  47D1 21 08 00     	LD HL, 8
1948  47D4 C3 DD 47     	JP .MOVDEBC
1949  47D7              .DETONEXTROW:
1950  47D7 DD 6E 06     	LD L, (IX+6)
1951  47DA DD 66 07     	LD H, (IX+7) ; bkg add to value
1952  47DD              .MOVDEBC:
1953  47DD 19           	ADD HL, DE
1954  47DE 54           	LD D, H
1955  47DF 5D           	LD E, L
1956  47E0 01 08 00     	LD BC, 8
1957  47E3 09           	ADD HL, BC
1958  47E4 44           	LD B, H
1959  47E5 4D           	LD C, L
1960  47E6 C9           	RET
1961  47E7              ; *******************************************************************************************************
1962  47E7
1963  47E7              ; *******************************************************************************************************
1964  47E7              ; function rotates mask and character data and applies it to background
1965  47E7              ; input IX=pointer to structure describing input data
1966  47E7              ; +0  DW horizontal shift count 0-7
1967  47E7              ; +2  DW vertical shift count 0-7
1968  47E7              ; +4  DW background data start;
1969  47E7              ; +6  DW background add to value to next row of background data
1970  47E7              ; +8  DW mask data start;
1971  47E7              ; +10  DW character data start;
1972  47E7              ; +12 DW character&mask add to value to next row of data
1973  47E7              ; +14 DW columns (low byte used)
1974  47E7              ; +16 DW rows (low byte used)
1975  47E7              SHIFT_MERGE_CHARACTER:
1976  47E7 DD 7E 00     	LD A, (IX) ; shift
1977  47EA FE 05        	CP 5
1978  47EC 38 25        	JR C, .RIGHT
1979  47EE              	; shifts 5-7, use rotate towards left 1-3
1980  47EE 21 43 47     	LD HL, SHIFT58
1981  47F1 22 94 47     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1982  47F4 22 A6 47     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1983  47F7 D6 05        	SUB 5
1984  47F9 28 0D        	JR Z, .L1
1985  47FB 87           	ADD A, A
1986  47FC 87           	ADD A, A
1987  47FD 67           	LD H, A
1988  47FE 2E 18        	LD L, #18 ; JR opcode
1989  4800 22 4A 47     	LD (SHIFT58.M1), HL
1990  4803 22 5B 47     	LD (SHIFT58.M2), HL
1991  4806 18 32        	JR .DO
1992  4808              .L1:
1993  4808 21 00 00     	LD HL, 0 ; 2xNOP opcode
1994  480B 22 4A 47     	LD (SHIFT58.M1), HL
1995  480E 22 5B 47     	LD (SHIFT58.M2), HL
1996  4811 18 27        	JR .DO
1997  4813              .RIGHT:
1998  4813              	; shifts 0-4, rotate towards right
1999  4813 21 FE 46     	LD HL, SHIFT04
2000  4816 22 94 47     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2001  4819 22 A6 47     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2002  481C FE 04        	CP 4
2003  481E 28 11        	JR Z, .R1
2004  4820 D6 04        	SUB 4
2005  4822 ED 44        	NEG
2006  4824 87           	ADD A, A
2007  4825 87           	ADD A, A
2008  4826 67           	LD H, A
2009  4827 2E 18        	LD L, #18 ; JR opcode
2010  4829 22 05 47     	LD (SHIFT04.M1), HL
2011  482C 22 1A 47     	LD (SHIFT04.M2), HL
2012  482F 18 09        	JR .DO
2013  4831              .R1:
2014  4831 21 00 00     	LD HL, 0 ; 2xNOP opcode
2015  4834 22 05 47     	LD (SHIFT04.M1), HL
2016  4837 22 1A 47     	LD (SHIFT04.M2), HL
2017  483A              .DO:
2018  483A DD 46 10     	LD B, (IX+16) ; rows
2019  483D DD 6E 08     	LD L, (IX+8)
2020  4840 DD 66 09     	LD H, (IX+9) ; mask data
2021  4843 DD 5E 04     	LD E, (IX+4)
2022  4846 DD 56 05     	LD D, (IX+5) ; background data
2023  4849 D9           	EXX
2024  484A DD 6E 0A     	LD L, (IX+10)
2025  484D DD 66 0B     	LD H, (IX+11) ; character data
2026  4850 D9           	EXX
2027  4851              .LOOP:
2028  4851 C5           	PUSH BC
2029  4852 E5           		PUSH HL
2030  4853 D5           			PUSH DE
2031  4854 D9           				EXX
2032  4855 E5           				PUSH HL
2033  4856 D9           					EXX
2034  4857 DD 7E 0E     					LD A, (IX+14) ; columns
2035  485A              .CALL:
2036  485A CD 80 47     					CALL SHIFT_ROW
2037  485D E1           				POP HL
2038  485E DD 5E 0C     				LD E, (IX+12)
2039  4861 DD 56 0D     				LD D, (IX+13) ; char data to next row
2040  4864 19           				ADD HL, DE
2041  4865 D9           				EXX
2042  4866 E1           			POP HL
2043  4867 DD 5E 06     			LD E, (IX+6)
2044  486A DD 56 07     			LD D, (IX+7) ; background to next row
2045  486D 19           			ADD HL, DE
2046  486E EB           			EX DE, HL
2047  486F E1           		POP HL
2048  4870 DD 4E 0C     		LD C, (IX+12)
2049  4873 DD 46 0D     		LD B, (IX+13) ; char data to next row
2050  4876 09           		ADD HL, BC
2051  4877 C1           	POP BC
2052  4878 10 D7        	DJNZ .LOOP
2053  487A C9           	RET
2054  487B              ; *******************************************************************************************************
2055  487B
2056  487B              ; *******************************************************************************************************
2057  487B              ; function to handle CALL BLIT basic extension
2058  487B              ; rotates 1-bit character drawing horizontally with mask and character data and
2059  487B              ; fuses with background data and applies vertical shift too
2060  487B              ; BLIT ( INT request_data_ptr )
2061  487B              ; request_data_ptr described in SHIFT_MERGE_CHARACTER
2062  487B              ; will put ram in page 0 also, page 1 is already there
2063  487B              BLIT:
2064  487B              	; opening (
2065  487B CD 2B 43     	CALL CHKCHAR
2066  487E 28           	DB '('
2067  487F              	; get pointer to request struct
2068  487F DD 21 2F 54  	LD IX, FRMQNT
2069  4883 CD 59 01     	CALL CALBAS
2070  4886 D5           	PUSH DE
2071  4887              	; ending )
2072  4887 CD 2B 43     	CALL CHKCHAR
2073  488A 29           	DB ')'
2074  488B
2075  488B DD E1        	POP IX ; pointer to request struct
2076  488D
2077  488D E5           	PUSH HL ; save position in BASIC buffer
2078  488E
2079  488E FD 21 95 48  	LD IY, .RET
2080  4892 C3 C8 41     	JP ENABLE_PAGE0
2081  4895              .RET:
2082  4895 FB           	EI
2083  4896 CD E7 47     	CALL SHIFT_MERGE_CHARACTER
2084  4899
2085  4899 D1               POP DE
2086  489A C1               POP BC
2087  489B CD 3F 41         CALL RESTORE_PAGE_INFO
2088  489E
2089  489E E1           	POP HL
2090  489F C9           	RET
2091  48A0              ; *******************************************************************************************************
2092  48A0
2093  48A0              ; *******************************************************************************************************
2094  48A0              ; generic function to implement tiling
2095  48A0              ; should be modified to call appropriate function for memory or vram
2096  48A0              ; input IX=pointer to following structure
2097  48A0              ; +00 tile_data_ptr
2098  48A0              ; +02 tile_rows
2099  48A0              ; +04 tile_columns
2100  48A0              ; +06 destination_address
2101  48A0              ; +08 dest_to_next_row_add_to_value
2102  48A0              ; +10 num_horizontal_tiles
2103  48A0              ; +12 num_vertical_tiles
2104  48A0              ; modifies AF, BC, DE, HL
2105  48A0              TILE:
2106  48A0 DD 6E 06     	LD L, (IX+6)
2107  48A3 DD 66 07     	LD H, (IX+7) ; destination address
2108  48A6 22 20 40     	LD (TILETMP1), HL
2109  48A9 DD 46 0C     	LD B, (IX+12) ; vertical tile number
2110  48AC              .L1:
2111  48AC C5           	PUSH BC
2112  48AD DD 6E 00     		LD L, (IX+0)
2113  48B0 DD 66 01     		LD H, (IX+1) ; tile address
2114  48B3 22 22 40     		LD (TILETMP2), HL
2115  48B6 DD 46 02     		LD B, (IX+2) ; tile rows
2116  48B9              .L2:
2117  48B9 C5           		PUSH BC
2118  48BA              .CALL1:
2119  48BA CD 00 00     			CALL 0
2120  48BD DD 46 0A     			LD B, (IX+10) ; horizontal tile num
2121  48C0              .L3:
2122  48C0 C5           			PUSH BC
2123  48C1 2A 22 40     				LD HL, (TILETMP2)
2124  48C4 DD 46 04     				LD B, (IX+4) ; tile columns
2125  48C7              .L4:
2126  48C7 C5           				PUSH BC
2127  48C8              .CALL2:
2128  48C8 CD 00 00     					CALL 0
2129  48CB C1           				POP BC
2130  48CC 10 F9        				DJNZ .L4
2131  48CE C1           			POP BC
2132  48CF 10 EF        			DJNZ .L3
2133  48D1 22 22 40     			LD (TILETMP2), HL
2134  48D4 2A 20 40     			LD HL, (TILETMP1)
2135  48D7 DD 5E 08     			LD E, (IX+8)
2136  48DA DD 56 09     			LD D, (IX+9) ; add to value for dest next row
2137  48DD 19           			ADD HL, DE
2138  48DE 22 20 40     			LD (TILETMP1), HL
2139  48E1 C1           		POP BC
2140  48E2 10 D5        		DJNZ .L2
2141  48E4 C1           	POP BC
2142  48E5 10 C5        	DJNZ .L1
2143  48E7 C9           	RET
2144  48E8              ; *******************************************************************************************************
2145  48E8
2146  48E8              ; *******************************************************************************************************
2147  48E8              ; function to handle CALL TILERAM basic extension
2148  48E8              ; fills memory with tiles
2149  48E8              ; fuses with background data and applies vertical shift too
2150  48E8              ; TILERAM ( INT request_data_ptr )
2151  48E8              ; request_data_ptr described in TILE
2152  48E8              ; will put ram in page 0 also, page 1 is already there
2153  48E8              TILERAM:
2154  48E8              	; opening (
2155  48E8 CD 2B 43     	CALL CHKCHAR
2156  48EB 28           	DB '('
2157  48EC              	; get pointer to request struct
2158  48EC DD 21 2F 54  	LD IX, FRMQNT
2159  48F0 CD 59 01     	CALL CALBAS
2160  48F3 D5           	PUSH DE
2161  48F4              	; ending )
2162  48F4 CD 2B 43     	CALL CHKCHAR
2163  48F7 29           	DB ')'
2164  48F8
2165  48F8 DD E1        	POP IX ; pointer to request struct
2166  48FA
2167  48FA E5           	PUSH HL ; save position in BASIC buffer
2168  48FB
2169  48FB FD 21 02 49  	LD IY, .RET
2170  48FF C3 C8 41     	JP ENABLE_PAGE0
2171  4902              .RET:
2172  4902 FB           	EI
2173  4903              	; set RAM functions to call
2174  4903 21 19 49     	LD HL, .TILECOPY
2175  4906 22 C9 48     	LD (TILE.CALL2+1), HL
2176  4909 21 2A 49     	LD HL, .SETDESTROW
2177  490C 22 BB 48     	LD (TILE.CALL1+1), HL
2178  490F CD A0 48     	CALL TILE
2179  4912
2180  4912 D1               POP DE
2181  4913 C1               POP BC
2182  4914 CD 3F 41         CALL RESTORE_PAGE_INFO
2183  4917
2184  4917 E1           	POP HL
2185  4918 C9           	RET
2186  4919              .TILECOPY:
2187  4919 ED A0       > LDI
2187  491B ED A0       > LDI
2187  491D ED A0       > LDI
2187  491F ED A0       > LDI
2187  4921 ED A0       > LDI
2187  4923 ED A0       > LDI
2187  4925 ED A0       > LDI
2187  4927 ED A0       > LDI
2188  4929 C9           	RET
2189  492A              .SETDESTROW:
2190  492A ED 5B 20 40  	LD DE, (TILETMP1)
2191  492E C9           	RET
2192  492F              ; *******************************************************************************************************
2193  492F
2194  492F              ; *******************************************************************************************************
2195  492F              ; function to handle CALL TILEVRM basic extension
2196  492F              ; fills vram with tiles
2197  492F              ; fuses with background data and applies vertical shift too
2198  492F              ; TILEVRM ( INT request_data_ptr )
2199  492F              ; request_data_ptr described in TILE
2200  492F              ; will put ram in page 0 also, page 1 is already there
2201  492F              TILEVRM:
2202  492F              	; opening (
2203  492F CD 2B 43     	CALL CHKCHAR
2204  4932 28           	DB '('
2205  4933              	; get pointer to request struct
2206  4933 DD 21 2F 54  	LD IX, FRMQNT
2207  4937 CD 59 01     	CALL CALBAS
2208  493A D5           	PUSH DE
2209  493B              	; ending )
2210  493B CD 2B 43     	CALL CHKCHAR
2211  493E 29           	DB ')'
2212  493F
2213  493F DD E1        	POP IX ; pointer to request struct
2214  4941
2215  4941 E5           	PUSH HL ; save position in BASIC buffer
2216  4942
2217  4942 FD 21 49 49  	LD IY, .RET
2218  4946 C3 C8 41     	JP ENABLE_PAGE0
2219  4949              .RET:
2220  4949 FB           	EI
2221  494A              	; set RAM functions to call
2222  494A 21 60 49     	LD HL, .TILECOPY
2223  494D 22 C9 48     	LD (TILE.CALL2+1), HL
2224  4950 21 66 49     	LD HL, .SETDESTROW
2225  4953 22 BB 48     	LD (TILE.CALL1+1), HL
2226  4956 CD A0 48     	CALL TILE
2227  4959
2228  4959 D1               POP DE
2229  495A C1               POP BC
2230  495B CD 3F 41         CALL RESTORE_PAGE_INFO
2231  495E
2232  495E E1           	POP HL
2233  495F C9           	RET
2234  4960              .TILECOPY:
2235  4960 01 98 08     	LD BC, #0898
2236  4963 C3 FE 44     	JP MEMVRM.BBYTECOPY
2237  4966              .SETDESTROW:
2238  4966 2A 20 40     	LD HL, (TILETMP1)
2239  4969 C3 FD 40     	JP SETWRT_LOCAL
2240  496C              ; *******************************************************************************************************
2241  496C
2242  496C              ; *******************************************************************************************************
2243  496C              ; generic function to implement rectangle data copy
2244  496C              ; should be modified to call appropriate function for memory or vram
2245  496C              ; input IX=pointer to following structure
2246  496C              ; +00 source data pointer
2247  496C              ; +02 num bytes in a row
2248  496C              ; +04 number of rows
2249  496C              ; +06 source add-to value till next row
2250  496C              ; +08 destination address
2251  496C              ; +10 destination add-to value till next row
2252  496C              ; modifies AF, BC, DE, HL
2253  496C              RECTANGLE_COPY:
2254  496C DD 6E 00     	LD L, (IX+0)
2255  496F DD 66 01     	LD H, (IX+1) ; source address
2256  4972 DD 5E 08     	LD E, (IX+8)
2257  4975 DD 56 09     	LD D, (IX+9) ; destination
2258  4978 DD 46 04     	LD B, (IX+4) ; row number
2259  497B              .L1:
2260  497B C5           	PUSH BC
2261  497C E5           		PUSH HL
2262  497D D5           			PUSH DE
2263  497E DD 4E 02     				LD C, (IX+2)
2264  4981 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2265  4984              .CALL1:
2266  4984 CD 00 00     				CALL 0 ; set destination address from DE
2267  4987              .CALL2:
2268  4987 CD 00 00     				CALL 0 ; copy data fn
2269  498A E1           			POP HL
2270  498B DD 4E 0A     			LD C, (IX+10)
2271  498E DD 46 0B     			LD B, (IX+11) ; destination add-to
2272  4991 09           			ADD HL, BC
2273  4992 EB           			EX DE, HL
2274  4993 E1           		POP HL
2275  4994 DD 4E 06     		LD C, (IX+6)
2276  4997 DD 46 07     		LD B, (IX+7) ; src add-to
2277  499A 09           		ADD HL, BC
2278  499B C1           	POP BC
2279  499C 10 DD        	DJNZ .L1
2280  499E C9           	RET
2281  499F              ; *******************************************************************************************************
2282  499F
2283  499F              ; *******************************************************************************************************
2284  499F              ; function to handle CALL BOXMEMCPY basic extension
2285  499F              ; copies data with window like boundaries to ram
2286  499F              ; BOXMEMCPY ( INT request_data_ptr )
2287  499F              ; request_data_ptr described in RECTANGLE_COPY
2288  499F              ; will put ram in page 0 also, page 1 is already there
2289  499F              BOXMEMCPY:
2290  499F              	; opening (
2291  499F CD 2B 43     	CALL CHKCHAR
2292  49A2 28           	DB '('
2293  49A3              	; get pointer to request struct
2294  49A3 DD 21 2F 54  	LD IX, FRMQNT
2295  49A7 CD 59 01     	CALL CALBAS
2296  49AA D5           	PUSH DE
2297  49AB              	; ending )
2298  49AB CD 2B 43     	CALL CHKCHAR
2299  49AE 29           	DB ')'
2300  49AF
2301  49AF DD E1        	POP IX ; pointer to request struct
2302  49B1
2303  49B1 E5           	PUSH HL ; save position in BASIC buffer
2304  49B2
2305  49B2 FD 21 B9 49  	LD IY, .RET
2306  49B6 C3 C8 41     	JP ENABLE_PAGE0
2307  49B9              .RET:
2308  49B9 FB           	EI
2309  49BA              	; set RAM functions to call
2310  49BA 21 00 00     	LD HL, 0
2311  49BD 22 84 49     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2312  49C0 22 86 49     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2313  49C3 21 ED B0     	LD HL, #B0ED ; LDIR
2314  49C6 22 88 49     	LD (RECTANGLE_COPY.CALL1+4), HL
2315  49C9 CD 6C 49     	CALL RECTANGLE_COPY
2316  49CC
2317  49CC D1               POP DE
2318  49CD C1               POP BC
2319  49CE CD 3F 41         CALL RESTORE_PAGE_INFO
2320  49D1
2321  49D1 E1           	POP HL
2322  49D2 C9           	RET
2323  49D3              ; *******************************************************************************************************
2324  49D3
2325  49D3              ; *******************************************************************************************************
2326  49D3              ; function to handle CALL BOXMEMVRM basic extension
2327  49D3              ; copies data with window like boundaries to ram
2328  49D3              ; BOXMEMVRM ( INT request_data_ptr )
2329  49D3              ; request_data_ptr described in RECTANGLE_COPY
2330  49D3              ; will put ram in page 0 also, page 1 is already there
2331  49D3              BOXMEMVRM:
2332  49D3              	; opening (
2333  49D3 CD 2B 43     	CALL CHKCHAR
2334  49D6 28           	DB '('
2335  49D7              	; get pointer to request struct
2336  49D7 DD 21 2F 54  	LD IX, FRMQNT
2337  49DB CD 59 01     	CALL CALBAS
2338  49DE D5           	PUSH DE
2339  49DF              	; ending )
2340  49DF CD 2B 43     	CALL CHKCHAR
2341  49E2 29           	DB ')'
2342  49E3
2343  49E3 DD E1        	POP IX ; pointer to request struct
2344  49E5
2345  49E5 E5           	PUSH HL ; save position in BASIC buffer
2346  49E6
2347  49E6 FD 21 ED 49  	LD IY, .RET
2348  49EA C3 C8 41     	JP ENABLE_PAGE0
2349  49ED              .RET:
2350  49ED FB           	EI
2351  49EE              	; set RAM functions to call
2352  49EE 21 0C 4A     	LD HL, .SETDEST
2353  49F1 22 85 49     	LD (RECTANGLE_COPY.CALL1+1), HL
2354  49F4 21 12 4A     	LD HL, .COPYDATA
2355  49F7 22 88 49     	LD (RECTANGLE_COPY.CALL2+1), HL
2356  49FA 3E CD        	LD A, #CD ; CALL
2357  49FC 32 84 49     	LD (RECTANGLE_COPY.CALL1), A
2358  49FF 32 87 49     	LD (RECTANGLE_COPY.CALL2), A
2359  4A02 CD 6C 49     	CALL RECTANGLE_COPY
2360  4A05
2361  4A05 D1               POP DE
2362  4A06 C1               POP BC
2363  4A07 CD 3F 41         CALL RESTORE_PAGE_INFO
2364  4A0A
2365  4A0A E1           	POP HL
2366  4A0B C9           	RET
2367  4A0C              .SETDEST:
2368  4A0C EB           	EX DE, HL
2369  4A0D CD FD 40     	CALL SETWRT_LOCAL
2370  4A10 EB           	EX DE, HL
2371  4A11 C9           	RET
2372  4A12              .COPYDATA:
2373  4A12 41           	LD B, C
2374  4A13 0E 98        	LD C, #98
2375  4A15 C3 FE 44     	JP MEMVRM.BBYTECOPY
2376  4A18              ; *******************************************************************************************************
2377  4A18
2378  4A18              EXT_END:
2379  4A18
# file closed: asm\main.asm
