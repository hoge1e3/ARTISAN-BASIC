# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		   EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000              BYTEOPS_CMDS   EQU 0
 14   4000              COLL_CMD       EQU 1
 15   4000
 16   4000               DEFINE CMDS_WITH_PARAMETERS
 17   4000
 18   4000              CHPUT   EQU    #A2
 19   4000              CALBAS  EQU		#159
 20   4000              ERRHAND EQU    #406F
 21   4000              FRMEVL  EQU    #4C64
 22   4000              FRESTR  EQU		#67D0
 23   4000              ; FRMQNT = formula quantificator
 24   4000              ; input HL=pointer to current program expression
 25   4000              ; output HL=next address
 26   4000              ; output DE=integer datum
 27   4000              FRMQNT	EQU		#542F
 28   4000              ; GETBYT = get byte parameter
 29   4000              ; input HL=pointer to current program expression
 30   4000              ; output HL=next address
 31   4000              ; output A=E=byte read
 32   4000              GETBYT		EQU	#521C
 33   4000              CHRGTR  	   EQU   #4666
 34   4000              PTRGET		EQU 	#5EA4
 35   4000              SUBFLG		EQU	#F6A5
 36   4000              SYNCHR		EQU	#558C
 37   4000              VALTYP  	   EQU   #F663
 38   4000              DAC         EQU   #F7F6
 39   4000              USR     	   EQU   #F7F8
 40   4000              PROCNM		EQU	#FD89
 41   4000              BIOS_FILVRM EQU   #0056
 42   4000              CLIKSW		EQU	#F3DB
 43   4000
 44   4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 45   4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 46   4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 47   4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 48   4000              EXPTBL	   EQU   #FCC1
 49   4000              SCRMOD	   EQU   #FCAF ; current screen mode
 50   4000              REG1SAV     EQU   #F3E0 ; VDP(1)
 51   4000              JIFFY	      EQU   #FC9E
 52   4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
 53   4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
 54   4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
 55   4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
 56   4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
 57   4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
 58   4000
 59   4000              ; BASIC error codes
 60   4000              ;01 NEXT without FOR
 61   4000              ;02 Syntax error
 62   4000              ;03 RETURN without GOSUB
 63   4000              ;04 Out of DATA
 64   4000              ;05 Illegal function call
 65   4000              ;06 Overflow
 66   4000              ;07 Out of memory
 67   4000              ;08 Undefined line number
 68   4000              ;09 Subscript out of range
 69   4000              ;10 Redimensioned array
 70   4000              ;11 Division by zero
 71   4000              ;12 Illegal direct
 72   4000              ;13 Type mismatch
 73   4000              ;14 Out of string space
 74   4000              ;15 String too long
 75   4000              ;16 String formula too complex
 76   4000              ;17 Can't CONTINUE
 77   4000              ;18 Undefined user function
 78   4000              ;19 Device I/O error
 79   4000              ;20 Verify error
 80   4000              ;21 No RESUME
 81   4000              ;22 RESUME without error
 82   4000              ;23 Unprintable error
 83   4000              ;24 Missing operand
 84   4000              ;25 Line buffer overflow
 85   4000              ;50 FIELD overflow
 86   4000              ;51 Internal error
 87   4000              ;52 Bad file number
 88   4000              ;53 File not found
 89   4000              ;54 File already open
 90   4000              ;55 Input past end
 91   4000              ;56 Bad file name
 92   4000              ;57 Direct statement in file
 93   4000              ;58 Sequential I/O only
 94   4000              ;59 File not OPEN
 95   4000
 96   4000
 97   4000               ; simulate cartridge with BASIC extension
 98   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 98   4004 29 62 00 00
 98   4008 00 00 00 00
 98   400C 00 00 00 00
 99   4010
100   4010              ; this location #4010 stores last location used by basic extension
101   4010              ; free memory after that point
102   4010              FREEMEMPTR:
103   4010 C6 62         DW EXT_END
104   4012
105   4012              ; this location #4012 stores extension version in DAA format
106   4012              ; first byte is major version and second minor
107   4012              VERSION:
108   4012 00 70         DB #00, #70
109   4014
110   4014              ; binary included AKG player compiled at #4014
111   4014               IF (SOUND_CMDS == 1)
112   4014              	INCBIN "bin/AKG.bin"
113   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
114   4CF0               ENDIF
115   4CF0
116   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A 41 56     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD 59 61         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD A0 61         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD 59 61         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD A0 61         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A 41 56     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD 90 61         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD 90 61         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A A6 5F         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD DA 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
117   4D73
118   4D73               IF (SPRITE_CMDS == 1)
119   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD 55 61         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 3A AF FC         LD A,(SCRMOD)
 53+  4D95 3D               DEC A
 54+  4D96 20 05            JR NZ,.L4
 55+  4D98 2A C3 F3         LD HL, (T32ATR)
 56+  4D9B 18 03            JR .L5
 57+  4D9D              .L4:
 58+  4D9D 2A CD F3         LD HL, (GRPATR)
 59+  4DA0              .L5:
 60+  4DA0 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 61+  4DA3 B7           	OR A
 62+  4DA4 28 03        	JR Z, .L3
 63+  4DA6 3A 79 4D     	LD A, (FLICKER)
 64+  4DA9              .L3:
 65+  4DA9 5F           	LD E, A
 66+  4DAA 08           	EX AF, AF'
 67+  4DAB 7B           	LD A, E
 68+  4DAC 87           	ADD A, A
 69+  4DAD 87           	ADD A, A
 70+  4DAE 16 00        	LD D, 0
 71+  4DB0 5F           	LD E, A
 72+  4DB1 19           	ADD HL, DE
 73+  4DB2 CD 40 61     	CALL SETWRT_LOCAL
 74+  4DB5 ED 73 7A 4D  	LD (TMPSP), SP
 75+  4DB9 ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 76+  4DBD
 77+  4DBD              .LOOP:
 78+  4DBD E1           	POP HL
 79+  4DBE 24           	INC H
 80+  4DBF 28 0D        	JR Z, .L1 ; negative number between -256 and -1
 81+  4DC1 25           	DEC H
 82+  4DC2 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
 83+  4DC4 7D           	LD A, L
 84+  4DC5 FE C0        	CP 192
 85+  4DC7 30 10        	JR NC, .OUT3
 86+  4DC9 3D           	DEC A ; due to VDP rule that top of screen is -1
 87+  4DCA 57           	LD D, A
 88+  4DCB C3 F2 4D     	JP .X
 89+  4DCE              .L1:
 90+  4DCE 7D           	LD A, L
 91+  4DCF C6 10        	ADD 16
 92+  4DD1 FA D9 4D     	JP M, .OUT3 ; below -16
 93+  4DD4 2D           	DEC L ; due to VDP rule that top of screen is -1
 94+  4DD5 55           	LD D, L
 95+  4DD6 C3 F2 4D     	JP .X
 96+  4DD9              .OUT3:
 97+  4DD9 E1           	POP HL ; skip x value
 98+  4DDA              .OUT2:
 99+  4DDA E1           	POP HL ; skip pattern
100+  4DDB E1           	POP HL ; skip color
101+  4DDC 3E D1        	LD A, #D1
102+  4DDE ED 79        	OUT (C), A ; sprite hidden
103+  4DE0 00          > NOP
103+  4DE1 00          > NOP
103+  4DE2 00          > NOP
104+  4DE3 ED 79        	OUT (C), A ; value unimportant
105+  4DE5 00          > NOP
105+  4DE6 00          > NOP
105+  4DE7 00          > NOP
106+  4DE8 ED 79        	OUT (C), A ; value unimportant
107+  4DEA 00          > NOP
107+  4DEB 00          > NOP
107+  4DEC 00          > NOP
108+  4DED ED 79        	OUT (C), A ; value unimportant
109+  4DEF C3 1D 4E     	JP .NEXT
110+  4DF2              .X:
111+  4DF2 E1           	POP HL
112+  4DF3 24           	INC H
113+  4DF4 28 08        	JR Z, .L2
114+  4DF6 25           	DEC H
115+  4DF7 20 E1        	JR NZ, .OUT2
116+  4DF9 1E 00        	LD E, 0 ; EC bit
117+  4DFB C3 07 4E     	JP .XY
118+  4DFE              .L2:
119+  4DFE 7D           	LD A, L
120+  4DFF C6 20        	ADD 32
121+  4E01 FA DA 4D     	JP M, .OUT2
122+  4E04 6F           	LD L, A
123+  4E05 1E 80        	LD E, #80
124+  4E07              .XY:
125+  4E07 ED 51        	OUT (C), D
126+  4E09 3A E0 F3     	LD A, (REG1SAV)
127+  4E0C E6 02        	AND 2
128+  4E0E ED 69        	OUT (C), L
129+  4E10 E1           	POP HL ; pattern
130+  4E11 7D           	LD A, L
131+  4E12 28 02        	JR Z, .SMALLSPRITES
132+  4E14 87           	ADD A, A
133+  4E15 87           	ADD A, A ; needs to go at 4x
134+  4E16              .SMALLSPRITES:
135+  4E16 D3 98        	OUT (#98), A
136+  4E18 E1           	POP HL ; color
137+  4E19 7D           	LD A, L
138+  4E1A B3           	OR E
139+  4E1B D3 98        	OUT (#98), A
140+  4E1D              .NEXT:
141+  4E1D 08           	EX AF, AF'
142+  4E1E 3C           	INC A
143+  4E1F E6 1F        	AND 31
144+  4E21 C2 40 4E     	JP NZ, .NEXT2
145+  4E24 08           	EX AF, AF'
146+  4E25 3A AF FC         LD A,(SCRMOD)
147+  4E28 3D               DEC A
148+  4E29 20 05            JR NZ,.L6
149+  4E2B 2A C3 F3         LD HL, (T32ATR)
150+  4E2E 18 03            JR .L7
151+  4E30              .L6:
152+  4E30 2A CD F3         LD HL, (GRPATR)
153+  4E33              .L7:
154+  4E33              	; CALL SETWRT_LOCAL not allowed as SP modified
155+  4E33 7D           	LD	A, L
156+  4E34 D3 99        	OUT	(099H), A
157+  4E36 7C           	LD	A, H
158+  4E37 E6 3F        	AND	03FH
159+  4E39 F6 40        	OR	040H
160+  4E3B D3 99        	OUT	(099H), A
161+  4E3D C3 41 4E     	JP .NEXT3
162+  4E40              .NEXT2:
163+  4E40 08           	EX AF, AF'
164+  4E41              .NEXT3:
165+  4E41 05           	DEC B
166+  4E42 C2 BD 4D     	JP NZ, .LOOP
167+  4E45 08           	EX AF, AF'
168+  4E46 3C           	INC A
169+  4E47 32 79 4D     	LD (FLICKER), A
170+  4E4A
171+  4E4A ED 7B 7A 4D  	LD SP, (TMPSP)
172+  4E4E 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
173+  4E51 36 00        	LD (HL), 0 ; zero out update flag
174+  4E53 C9           	RET
175+  4E54              ; *******************************************************************************************************
176+  4E54
177+  4E54              ; *******************************************************************************************************
178+  4E54              ; function to handle CALL SPRENABLE basic extension
179+  4E54              ; initializes sprites handler
180+  4E54              ; _SPRENABLE ( INT[][] sprites_attributes,
181+  4E54              ;			   INT update_variable,
182+  4E54              ;			   BYTE sprite_flicker_enabled )
183+  4E54              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
184+  4E54              SPRENABLE:
185+  4E54              	; opening (
186+  4E54 CD 66 62     	CALL CHKCHAR
187+  4E57 28           	DB '('
188+  4E58              	; get address of sprite attribute table DIM SA%(3,31)
189+  4E58 3E 02        	LD A,2
190+  4E5A 06 02        	LD B,2
191+  4E5C 11 20 04     	LD DE,#0420
192+  4E5F CD 91 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
193+  4E62 C5           	PUSH BC
194+  4E63              	; comma
195+  4E63 CD 66 62     	CALL CHKCHAR
196+  4E66 2C           	DB ','
197+  4E67              	; get address of sprite update flag
198+  4E67 DD 21 A4 5E  	LD IX, PTRGET
199+  4E6B CD 59 01     	CALL CALBAS
200+  4E6E D5           	PUSH DE
201+  4E6F              	; comma
202+  4E6F CD 66 62     	CALL CHKCHAR
203+  4E72 2C           	DB ','
204+  4E73              	; get flicker enabled flag
205+  4E73 DD 21 1C 52  	LD IX, GETBYT
206+  4E77 CD 59 01     	CALL CALBAS
207+  4E7A F5           	PUSH AF
208+  4E7B              	; ending )
209+  4E7B CD 66 62     	CALL CHKCHAR
210+  4E7E 29           	DB ')'
211+  4E7F
212+  4E7F F1           	POP AF ; get flicker flag
213+  4E80 B7           	OR A
214+  4E81 32 78 4D     	LD (SPRFLICKER_ENABLED), A
215+  4E84
216+  4E84 D1           	POP DE ; update variable location
217+  4E85 ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
218+  4E89 D1           	POP DE ; address of sprite attribute table
219+  4E8A ED 53 76 4D  	LD (SPRATR_DATA), DE
220+  4E8E 3E 01        	LD A, 1
221+  4E90 32 73 4D     	LD (SPRATR_INIT_STATUS), A
222+  4E93 C9           	RET
223+  4E94              ; *******************************************************************************************************
224+  4E94
225+  4E94              ; *******************************************************************************************************
226+  4E94              ; function to handle CALL SPRDISABLE basic extension
227+  4E94              ; disables sprites handling
228+  4E94              ; _SPRDISABLE
229+  4E94              ; resets variable SPRATR_INIT_STATUS
230+  4E94              SPRDISABLE:
231+  4E94 AF           	XOR A
232+  4E95 32 73 4D     	LD (SPRATR_INIT_STATUS), A
233+  4E98 C9           	RET
234+  4E99              ; *******************************************************************************************************
235+  4E99
236+  4E99              ; *******************************************************************************************************
237+  4E99              ; function to handle CALL SPRSET basic extension
238+  4E99              ; sets position, and optionally pattern and color of sprite
239+  4E99              ; _SPRSET ( BYTE sprite_num , valid 0-31
240+  4E99              ;			INT x,
241+  4E99              ;			INT y,
242+  4E99              ;			INT pattern, valid 0-63, otherwise ignored
243+  4E99              ;			INT color, valid 0-15, otherwise ignored
244+  4E99              SPRSET:
245+  4E99 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
246+  4E9C B7           	OR A
247+  4E9D 20 05        	JR NZ, .L1
248+  4E9F 1E 05        	LD E, 5 ; illegal function call
249+  4EA1 C3 8A 62     	JP THROW_ERROR
250+  4EA4              .L1:
251+  4EA4              	; opening (
252+  4EA4 CD 66 62     	CALL CHKCHAR
253+  4EA7 28           	DB '('
254+  4EA8              	; get sprite number
255+  4EA8 DD 21 1C 52  	LD IX, GETBYT
256+  4EAC CD 59 01     	CALL CALBAS
257+  4EAF F5           	PUSH AF
258+  4EB0              	; comma
259+  4EB0 CD 66 62     	CALL CHKCHAR
260+  4EB3 2C           	DB ','
261+  4EB4              	; get x
262+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
263+  4EB8 CD 59 01     	CALL CALBAS
264+  4EBB D5           	PUSH DE
265+  4EBC              	; comma
266+  4EBC CD 66 62     	CALL CHKCHAR
267+  4EBF 2C           	DB ','
268+  4EC0              	; get y
269+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
270+  4EC4 CD 59 01     	CALL CALBAS
271+  4EC7 D5           	PUSH DE
272+  4EC8              	; comma
273+  4EC8 CD 66 62     	CALL CHKCHAR
274+  4ECB 2C           	DB ','
275+  4ECC              	; get pattern
276+  4ECC DD 21 2F 54  	LD IX, FRMQNT
277+  4ED0 CD 59 01     	CALL CALBAS
278+  4ED3 D5           	PUSH DE
279+  4ED4              	; comma
280+  4ED4 CD 66 62     	CALL CHKCHAR
281+  4ED7 2C           	DB ','
282+  4ED8              	; get color
283+  4ED8 DD 21 2F 54  	LD IX, FRMQNT
284+  4EDC CD 59 01     	CALL CALBAS
285+  4EDF D5           	PUSH DE
286+  4EE0              	; ending )
287+  4EE0 CD 66 62     	CALL CHKCHAR
288+  4EE3 29           	DB ')'
289+  4EE4
290+  4EE4                  ; save position in BASIC text
291+  4EE4 E5           	PUSH HL
292+  4EE5 DD E1        	POP IX
293+  4EE7
294+  4EE7 C1           	POP BC ; color
295+  4EE8 D1           	POP DE ; pattern
296+  4EE9 D9           	EXX
297+  4EEA C1           	POP BC ; y
298+  4EEB D1           	POP DE ; x
299+  4EEC F1           	POP AF ; sprite number
300+  4EED FE 20        	CP 32
301+  4EEF 38 05        	JR C, .L2
302+  4EF1 1E 05        	LD E, 5 ; illegal function call
303+  4EF3 C3 8A 62     	JP THROW_ERROR
304+  4EF6              .L2:
305+  4EF6              	; find location in sprite attributes table
306+  4EF6 D5           	PUSH DE
307+  4EF7 CD 7C 4D     	CALL GETnthSPRATTR
308+  4EFA D1           	POP DE
309+  4EFB              	; set y
310+  4EFB 71           	LD (HL), C
311+  4EFC 23           	INC HL
312+  4EFD 70           	LD (HL), B
313+  4EFE 23           	INC HL
314+  4EFF              	; set x
315+  4EFF 73           	LD (HL), E
316+  4F00 23           	INC HL
317+  4F01 72           	LD (HL), D
318+  4F02 23           	INC HL
319+  4F03 E5           	PUSH HL
320+  4F04 D9           	EXX
321+  4F05 E1           	POP HL
322+  4F06              	; check if 0<=pattern<64
323+  4F06 7A           	LD A, D
324+  4F07 B7           	OR A
325+  4F08 20 0B        	JR NZ, .L3
326+  4F0A 7B           	LD A, E
327+  4F0B FE 40        	CP 64
328+  4F0D 30 06        	JR NC, .L3
329+  4F0F              	; set pattern
330+  4F0F              	;ADD A, A
331+  4F0F              	;ADD A, A
332+  4F0F              	;ADD A, A
333+  4F0F 77           	LD (HL), A
334+  4F10 23           	INC HL
335+  4F11 72           	LD (HL), D
336+  4F12 23           	INC HL
337+  4F13 18 02        	JR .L4
338+  4F15              .L3:
339+  4F15              	; skip pattern
340+  4F15 23          > INC HL
340+  4F16 23          > INC HL
341+  4F17              .L4:
342+  4F17              	; check if 0<=color<16
343+  4F17 78           	LD A, B
344+  4F18 B7           	OR A
345+  4F19 20 08        	JR NZ, .L5
346+  4F1B 79           	LD A, C
347+  4F1C FE 10        	CP 16
348+  4F1E 30 03        	JR NC, .L5
349+  4F20              	; set color
350+  4F20 71           	LD (HL), C
351+  4F21 23           	INC HL
352+  4F22 70           	LD (HL), B
353+  4F23
354+  4F23              .L5:
355+  4F23 DD E5        	PUSH IX
356+  4F25 E1           	POP HL
357+  4F26 C9           	RET
358+  4F27              ; *******************************************************************************************************
359+  4F27
360+  4F27              ; *******************************************************************************************************
361+  4F27              ; function sets sprite location based on initial coordinates and offset provided
362+  4F27              ; input A=sprite number in SPRATR_DATA , 0-31
363+  4F27              ; input DE=initial x
364+  4F27              ; input BC=initial y
365+  4F27              ; input IY=location where delta y,x are located
366+  4F27              ; modifies AF, HL, IX
367+  4F27              SPRSET_DELTA_POS:
368+  4F27 D5           	PUSH DE
369+  4F28 CD 7C 4D     	CALL GETnthSPRATTR
370+  4F2B E5           	PUSH HL
371+  4F2C DD E1        	POP IX
372+  4F2E D1           	POP DE
373+  4F2F              	; IX=sprite's y location
374+  4F2F FD 6E 00     	LD L, (IY)
375+  4F32 FD 66 01     	LD H, (IY+1)
376+  4F35 09           	ADD HL, BC
377+  4F36 DD 75 00     	LD (IX), L
378+  4F39 DD 74 01     	LD (IX+1), H
379+  4F3C FD 6E 02     	LD L, (IY+2)
380+  4F3F FD 66 03     	LD H, (IY+3)
381+  4F42 19           	ADD HL, DE
382+  4F43 DD 75 02     	LD (IX+2), L
383+  4F46 DD 74 03     	LD (IX+3), H
384+  4F49 C9           	RET
385+  4F4A              ; *******************************************************************************************************
386+  4F4A
387+  4F4A              ; *******************************************************************************************************
388+  4F4A              ; function to handle CALL SPRGRPMOV basic extension
389+  4F4A              ; sets position of a group of sprites described with
390+  4F4A              ; { int sprite_num, int delta_y, int delta_x } [count]
391+  4F4A              ; _SPRGRPMOV ( INT x,
392+  4F4A              ;			   INT y,
393+  4F4A              ;			   BYTE count,
394+  4F4A              ;			   INT[2][count] data_ptr
395+  4F4A              ; will put ram in page 0 also, page 1 is already there
396+  4F4A              SPRGRPMOV:
397+  4F4A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
398+  4F4D B7           	OR A
399+  4F4E CA 84 62     	JP Z,ILLEGAL_FUNCTION
400+  4F51              	; opening (
401+  4F51 CD 66 62     	CALL CHKCHAR
402+  4F54 28           	DB '('
403+  4F55              	; get x
404+  4F55 DD 21 2F 54  	LD IX, FRMQNT
405+  4F59 CD 59 01     	CALL CALBAS
406+  4F5C D5           	PUSH DE
407+  4F5D              	; comma
408+  4F5D CD 66 62     	CALL CHKCHAR
409+  4F60 2C           	DB ','
410+  4F61              	; get y
411+  4F61 DD 21 2F 54  	LD IX, FRMQNT
412+  4F65 CD 59 01     	CALL CALBAS
413+  4F68 D5           	PUSH DE
414+  4F69              	; comma
415+  4F69 CD 66 62     	CALL CHKCHAR
416+  4F6C 2C           	DB ','
417+  4F6D              	; get count
418+  4F6D DD 21 1C 52  	LD IX, GETBYT
419+  4F71 CD 59 01     	CALL CALBAS
420+  4F74 F5           	PUSH AF
421+  4F75              	; comma
422+  4F75 CD 66 62     	CALL CHKCHAR
423+  4F78 2C           	DB ','
424+  4F79              	; get sprite group definition array data pointer
425+  4F79 D1           	POP DE
426+  4F7A D5           	PUSH DE
427+  4F7B 5A           	LD E,D
428+  4F7C 16 03        	LD D,3
429+  4F7E 3E 02        	LD A,2
430+  4F80 47           	LD B,A
431+  4F81 CD 91 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
432+  4F84 C5           	PUSH BC
433+  4F85              	; ending )
434+  4F85 CD 66 62     	CALL CHKCHAR
435+  4F88 29           	DB ')'
436+  4F89
437+  4F89 E5           	PUSH HL
438+  4F8A DD E1        	POP IX
439+  4F8C
440+  4F8C E1           	POP HL ; data pointer
441+  4F8D C1           	POP BC ; count
442+  4F8E D9           	EXX
443+  4F8F C1           	POP BC ; y
444+  4F90 D1           	POP DE ; x
445+  4F91 D9           	EXX
446+  4F92
447+  4F92 DD E5        	PUSH IX ; save position in BASIC buffer
448+  4F94
449+  4F94 C5           	PUSH BC
450+  4F95 E5           	PUSH HL
451+  4F96 AF               XOR A
452+  4F97 CD 59 61         CALL GET_PAGE_INFO
453+  4F9A D9           	EXX
454+  4F9B E1           	POP HL
455+  4F9C F1           	POP AF
456+  4F9D D9           	EXX
457+  4F9E C5               PUSH BC
458+  4F9F D5               PUSH DE
459+  4FA0 D9           	EXX
460+  4FA1 F5           	PUSH AF
461+  4FA2 E5           	PUSH HL
462+  4FA3 D9           	EXX
463+  4FA4 3A 41 F3         LD A, (RAMAD0)
464+  4FA7 26 00            LD H, 0
465+  4FA9 CD A0 61         CALL LOCAL_ENASLT
466+  4FAC FB           	EI
467+  4FAD E1           	POP HL
468+  4FAE C1           	POP BC
469+  4FAF 3E 01        	LD A,1
470+  4FB1 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
471+  4FB4 CD C2 4F     	CALL .UPDATE_LOC
472+  4FB7 AF           	XOR A
473+  4FB8 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
474+  4FBB D1               POP DE
475+  4FBC C1               POP BC
476+  4FBD CD 90 61         CALL RESTORE_PAGE_INFO
477+  4FC0 E1           	POP HL
478+  4FC1 C9           	RET
479+  4FC2
480+  4FC2              .UPDATE_LOC:
481+  4FC2 7E           	LD A, (HL)
482+  4FC3 23           	INC HL
483+  4FC4 23           	INC HL
484+  4FC5 E5           	PUSH HL
485+  4FC6 FD E1        	POP IY
486+  4FC8 D9           	EXX
487+  4FC9 CD 27 4F     	CALL SPRSET_DELTA_POS
488+  4FCC D9           	EXX
489+  4FCD 23          > INC HL
489+  4FCE 23          > INC HL
489+  4FCF 23          > INC HL
489+  4FD0 23          > INC HL
490+  4FD1 10 EF        	DJNZ .UPDATE_LOC
491+  4FD3 C9           	RET
492+  4FD4              ; *******************************************************************************************************
493+  4FD4
# file closed: asm\SPRITES.asm
120   4FD4               ENDIF
121   4FD4
122   4FD4               IF (ANIM_CMDS == 1)
123   4FD4               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FD4              ; sprite animation routines
  2+  4FD4
  3+  4FD4              ; number of animation items and pointer
  4+  4FD4              ANIMITEMNUM:
  5+  4FD4 00            DB 0
  6+  4FD5              ANIMITEMPTR:
  7+  4FD5 C6 62         DW EXT_END
  8+  4FD7              ; number of animation definitions and pointer
  9+  4FD7              ANIMDEFNUM:
 10+  4FD7 00            DB 0
 11+  4FD8              ANIMDEFPTR:
 12+  4FD8 C6 62         DW EXT_END
 13+  4FDA              ; number of links between sprite and animation definitions
 14+  4FDA              ANIMSPRNUM:
 15+  4FDA 00            DB 0
 16+  4FDB              ANIMSPRPTR:
 17+  4FDB C6 62         DW EXT_END
 18+  4FDD
 19+  4FDD              ; ANIMATION ITEM
 20+  4FDD              ; byte type = [0 - pattern and color change
 21+  4FDD              ;              1 - pattern definition change ]
 22+  4FDD              ; word ticks - number of ticks to hold this state
 23+  4FDD              ; for type = 0
 24+  4FDD              ;   byte pattern;
 25+  4FDD              ;   byte color;
 26+  4FDD              ; for type = 1
 27+  4FDD              ;   work data_pointer;
 28+  4FDD              ; total size = 5b
 29+  4FDD
 30+  4FDD              ; ANIMATION DEFINITION
 31+  4FDD              ; byte number of items 1-15
 32+  4FDD              ; byte[15] anim_item;
 33+  4FDD              ; total size = 16b
 34+  4FDD
 35+  4FDD              ; SPRITE/CHAR ANIMATION
 36+  4FDD              ; +00 byte sprite/char number;
 37+  4FDD              ; +01 word time;
 38+  4FDD              ; +03 byte current item;
 39+  4FDD              ; +04 byte animation definition;
 40+  4FDD              ; +05 byte cyclic;
 41+  4FDD              ; +06 byte active;
 42+  4FDD              ; +07 byte 0=sprite, 1-3 character bank
 43+  4FDD              ; total size = 8b
 44+  4FDD
 45+  4FDD              ; *******************************************************************************************************
 46+  4FDD              ; helper function HL=A*5
 47+  4FDD              ; changes HL,DE;
 48+  4FDD              Ax5:
 49+  4FDD 26 00            LD H,0
 50+  4FDF 6F               LD L,A
 51+  4FE0 54               LD D,H
 52+  4FE1 5D               LD E,L
 53+  4FE2 29               ADD HL,HL
 54+  4FE3 29               ADD HL,HL
 55+  4FE4 19               ADD HL,DE
 56+  4FE5 C9               RET
 57+  4FE6              ; *******************************************************************************************************
 58+  4FE6
 59+  4FE6              ; *******************************************************************************************************
 60+  4FE6              ; helper function gets pointer to n-th animation item
 61+  4FE6              ; changes HL,DE;
 62+  4FE6              GETnthANIMITEM:
 63+  4FE6 CD DD 4F         CALL Ax5
 64+  4FE9 ED 5B D5 4F      LD DE,(ANIMITEMPTR)
 65+  4FED 19               ADD HL,DE
 66+  4FEE C9               RET
 67+  4FEF              ; *******************************************************************************************************
 68+  4FEF
 69+  4FEF              ; *******************************************************************************************************
 70+  4FEF              ; helper function gets pointer to n-th entry in animation definition
 71+  4FEF              ; changes HL,DE;
 72+  4FEF              GETnthANIMDEF:
 73+  4FEF 26 00            LD H,0
 74+  4FF1 6F               LD L,A
 75+  4FF2 CD 54 61         CALL HLx16
 76+  4FF5 ED 5B D8 4F      LD DE,(ANIMDEFPTR)
 77+  4FF9 19               ADD HL,DE
 78+  4FFA C9               RET
 79+  4FFB              ; *******************************************************************************************************
 80+  4FFB
 81+  4FFB              ; *******************************************************************************************************
 82+  4FFB              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FFB              ; changes HL,DE;
 84+  4FFB              GETnthSPRANIM:
 85+  4FFB 26 00            LD H,0
 86+  4FFD 6F               LD L,A
 87+  4FFE CD 55 61         CALL HLx8
 88+  5001 ED 5B DB 4F      LD DE,(ANIMSPRPTR)
 89+  5005 19               ADD HL,DE
 90+  5006 C9               RET
 91+  5007              ; *******************************************************************************************************
 92+  5007
 93+  5007              ; *******************************************************************************************************
 94+  5007              ; function to handle CALL MAXANIMITEMS basic extension
 95+  5007              ; MAXANIMITEMS (BYTE number)
 96+  5007              ; sets new number and moves memory buffers as needed
 97+  5007              MAXANIMITEMS:
 98+  5007              	; opening (
 99+  5007 CD 66 62     	CALL CHKCHAR
100+  500A 28           	DB '('
101+  500B              	; get value
102+  500B DD 21 1C 52  	LD IX, GETBYT
103+  500F CD 59 01     	CALL CALBAS
104+  5012 F5               PUSH AF
105+  5013              	; ending )
106+  5013 CD 66 62     	CALL CHKCHAR
107+  5016 29           	DB ')'
108+  5017 F1               POP AF
109+  5018
110+  5018              	; save position
111+  5018 E5           	PUSH HL
112+  5019              .ENTRY:
113+  5019 47               LD B,A
114+  501A 3A D4 4F         LD A,(ANIMITEMNUM)
115+  501D 90               SUB B
116+  501E 28 1F            JR Z, .EXIT; same value as before
117+  5020 FD 21 D8 4F      LD IY,ANIMDEFPTR
118+  5024 FA 42 50         JP M, .INCREASE
119+  5027                  ; new value is lower than previous one
120+  5027 CD 5A 50         CALL .SIZEDIFF
121+  502A CD 75 50         CALL .DECREASE_COMMON
122+  502D 2A DB 4F         LD HL,(ANIMSPRPTR)
123+  5030 AF               XOR A
124+  5031 ED 42            SBC HL,BC
125+  5033 22 DB 4F         LD (ANIMSPRPTR),HL
126+  5036              .E1:
127+  5036 2A 10 40         LD HL,(FREEMEMPTR)
128+  5039 AF               XOR A
129+  503A ED 42            SBC HL,BC
130+  503C 22 10 40         LD (FREEMEMPTR),HL
131+  503F              .EXIT:
132+  503F FB               EI
133+  5040 E1           	POP HL
134+  5041 C9           	RET
135+  5042              .INCREASE:
136+  5042 ED 44            NEG
137+  5044 CD 5A 50         CALL .SIZEDIFF
138+  5047 CD A1 50         CALL .INCREASE_COMMON
139+  504A 2A DB 4F         LD HL,(ANIMSPRPTR)
140+  504D 09               ADD HL,BC
141+  504E 22 DB 4F         LD (ANIMSPRPTR),HL
142+  5051              .E2:
143+  5051 2A 10 40         LD HL,(FREEMEMPTR)
144+  5054 09               ADD HL,BC
145+  5055 22 10 40         LD (FREEMEMPTR),HL
146+  5058 18 E5            JR .EXIT
147+  505A              .SIZEDIFF:
148+  505A CD DD 4F         CALL Ax5
149+  505D 78               LD A,B
150+  505E 32 D4 4F         LD (ANIMITEMNUM),A
151+  5061 44               LD B,H
152+  5062 4D               LD C,L
153+  5063 C9               RET ; BC=size difference in bytes
154+  5064              .SIZETOMOVE:
155+  5064 D5               PUSH DE
156+  5065 2A 10 40         LD HL,(FREEMEMPTR)
157+  5068 FD 5E 00         LD E,(IY)
158+  506B FD 56 01         LD D,(IY+1)
159+  506E AF               XOR A
160+  506F ED 52            SBC HL,DE
161+  5071 44               LD B,H
162+  5072 4D               LD C,L
163+  5073 D1               POP DE
164+  5074 C9               RET
165+  5075              .DECREASE_COMMON:
166+  5075 FD 6E 00         LD L,(IY)
167+  5078 FD 66 01         LD H,(IY+1)
168+  507B AF               XOR A
169+  507C ED 42            SBC HL,BC
170+  507E EB               EX DE,HL
171+  507F C5               PUSH BC
172+  5080 CD 64 50         CALL .SIZETOMOVE
173+  5083 F3               DI
174+  5084 78               LD A,B
175+  5085 B1               OR C
176+  5086 28 08            JR Z,.L1
177+  5088 FD 6E 00         LD L,(IY)
178+  508B FD 66 01         LD H,(IY+1)
179+  508E ED B0            LDIR
180+  5090              .L1:
181+  5090 C1               POP BC
182+  5091 FD 6E 00         LD L,(IY)
183+  5094 FD 66 01         LD H,(IY+1)
184+  5097 AF               XOR A
185+  5098 ED 42            SBC HL,BC
186+  509A FD 75 00         LD (IY),L
187+  509D FD 74 01         LD (IY+1),H
188+  50A0 C9               RET
189+  50A1              .INCREASE_COMMON:
190+  50A1 2A 10 40         LD HL,(FREEMEMPTR)
191+  50A4 2B               DEC HL
192+  50A5 AF               XOR A
193+  50A6 ED 42            SBC HL,BC
194+  50A8 EB               EX DE,HL
195+  50A9 C5               PUSH BC
196+  50AA CD 64 50         CALL .SIZETOMOVE
197+  50AD F3               DI
198+  50AE 78               LD A,B
199+  50AF B1               OR C
200+  50B0 28 06            JR Z,.L2
201+  50B2 2A 10 40         LD HL,(FREEMEMPTR)
202+  50B5 2B               DEC HL
203+  50B6 ED B8            LDDR
204+  50B8              .L2:
205+  50B8 C1               POP BC
206+  50B9 FD 6E 00         LD L,(IY)
207+  50BC FD 66 01         LD H,(IY+1)
208+  50BF 09               ADD HL,BC
209+  50C0 FD 75 00         LD (IY),L
210+  50C3 FD 74 01         LD (IY+1),H
211+  50C6 C9               RET
212+  50C7              ; *******************************************************************************************************
213+  50C7
214+  50C7              ; *******************************************************************************************************
215+  50C7              ; function to handle CALL ANIMITEMPAT basic extension
216+  50C7              ; ANIMITEMPAT ( BYTE id,
217+  50C7              ;               INT ticks,
218+  50C7              ;               BYTE pattern,
219+  50C7              ;               BYTE color )
220+  50C7              ; fills animation item data, returns an error if out of bounds
221+  50C7              ANIMITEMPAT:
222+  50C7                  ; opening (
223+  50C7 CD 66 62     	CALL CHKCHAR
224+  50CA 28           	DB '('
225+  50CB              	; get id
226+  50CB DD 21 1C 52  	LD IX, GETBYT
227+  50CF CD 59 01     	CALL CALBAS
228+  50D2 F5               PUSH AF
229+  50D3                  ; check if out of bounds
230+  50D3 3C               INC A
231+  50D4 4F               LD C,A
232+  50D5 3A D4 4F         LD A,(ANIMITEMNUM)
233+  50D8 B9               CP C
234+  50D9 DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50DC              	; comma
236+  50DC CD 66 62     	CALL CHKCHAR
237+  50DF 2C           	DB ','
238+  50E0              	; get ticks
239+  50E0 DD 21 2F 54  	LD IX, FRMQNT
240+  50E4 CD 59 01     	CALL CALBAS
241+  50E7 D5           	PUSH DE
242+  50E8              	; comma
243+  50E8 CD 66 62     	CALL CHKCHAR
244+  50EB 2C           	DB ','
245+  50EC              	; get pattern
246+  50EC DD 21 1C 52  	LD IX, GETBYT
247+  50F0 CD 59 01     	CALL CALBAS
248+  50F3 F5               PUSH AF
249+  50F4              	; comma
250+  50F4 CD 66 62     	CALL CHKCHAR
251+  50F7 2C           	DB ','
252+  50F8              	; get color
253+  50F8 DD 21 1C 52  	LD IX, GETBYT
254+  50FC CD 59 01     	CALL CALBAS
255+  50FF F5               PUSH AF
256+  5100              	; ending )
257+  5100 CD 66 62     	CALL CHKCHAR
258+  5103 29           	DB ')'
259+  5104              .ENTRY:
260+  5104 E5               PUSH HL
261+  5105 DD E1            POP IX
262+  5107 D9               EXX
263+  5108 C1               POP BC ; color
264+  5109 D1               POP DE ; pattern
265+  510A E1               POP HL ; ticks
266+  510B D9               EXX
267+  510C F1               POP AF
268+  510D CD E6 4F         CALL GETnthANIMITEM
269+  5110 E5               PUSH HL
270+  5111 FD E1            POP IY
271+  5113 D9               EXX
272+  5114 FD 36 00 00      LD (IY),0 ; type=0
273+  5118 FD 75 01         LD (IY+1),L
274+  511B FD 74 02         LD (IY+2),H
275+  511E FD 72 03         LD (IY+3),D
276+  5121 FD 70 04         LD (IY+4),B
277+  5124
278+  5124 DD E5            PUSH IX
279+  5126 E1               POP HL
280+  5127 C9               RET
281+  5128              ; *******************************************************************************************************
282+  5128
283+  5128              ; *******************************************************************************************************
284+  5128              ; function to handle CALL ANIMITEMPTR basic extension
285+  5128              ; ANIMITEMPTR ( BYTE id,
286+  5128              ;               INT ticks,
287+  5128              ;               INT pointer,
288+  5128              ; fills animation item data, returns an error if out of bounds
289+  5128              ANIMITEMPTR_CMD:
290+  5128                  ; opening (
291+  5128 CD 66 62     	CALL CHKCHAR
292+  512B 28           	DB '('
293+  512C              	; get id
294+  512C DD 21 1C 52  	LD IX, GETBYT
295+  5130 CD 59 01     	CALL CALBAS
296+  5133 F5               PUSH AF
297+  5134                  ; check if out of bounds
298+  5134 3C               INC A
299+  5135 4F               LD C,A
300+  5136 3A D4 4F         LD A,(ANIMITEMNUM)
301+  5139 B9               CP C
302+  513A DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  513D              	; comma
304+  513D CD 66 62     	CALL CHKCHAR
305+  5140 2C           	DB ','
306+  5141              	; get ticks
307+  5141 DD 21 2F 54  	LD IX, FRMQNT
308+  5145 CD 59 01     	CALL CALBAS
309+  5148 D5           	PUSH DE
310+  5149              	; comma
311+  5149 CD 66 62     	CALL CHKCHAR
312+  514C 2C           	DB ','
313+  514D              	; get pointer
314+  514D DD 21 2F 54  	LD IX, FRMQNT
315+  5151 CD 59 01     	CALL CALBAS
316+  5154 D5           	PUSH DE
317+  5155              	; ending )
318+  5155 CD 66 62     	CALL CHKCHAR
319+  5158 29           	DB ')'
320+  5159              .ENTRY:
321+  5159 E5               PUSH HL
322+  515A DD E1            POP IX
323+  515C D9               EXX
324+  515D D1               POP DE ; pointer
325+  515E E1               POP HL ; ticks
326+  515F D9               EXX
327+  5160 F1               POP AF
328+  5161 CD E6 4F         CALL GETnthANIMITEM
329+  5164 E5               PUSH HL
330+  5165 FD E1            POP IY
331+  5167 D9               EXX
332+  5168 FD 36 00 01      LD (IY),1 ; type=1
333+  516C FD 75 01         LD (IY+1),L
334+  516F FD 74 02         LD (IY+2),H
335+  5172 FD 73 03         LD (IY+3),E
336+  5175 FD 72 04         LD (IY+4),D
337+  5178
338+  5178 DD E5            PUSH IX
339+  517A E1               POP HL
340+  517B C9               RET
341+  517C              ; *******************************************************************************************************
342+  517C
343+  517C              ; *******************************************************************************************************
344+  517C              ; function to handle CALL MAXANIMDEFS basic extension
345+  517C              ; MAXANIMDEFS (BYTE number)
346+  517C              ; sets new number and moves memory buffers as needed
347+  517C              MAXANIMDEFS:
348+  517C              	; opening (
349+  517C CD 66 62     	CALL CHKCHAR
350+  517F 28           	DB '('
351+  5180              	; get value
352+  5180 DD 21 1C 52  	LD IX, GETBYT
353+  5184 CD 59 01     	CALL CALBAS
354+  5187 F5               PUSH AF
355+  5188              	; ending )
356+  5188 CD 66 62     	CALL CHKCHAR
357+  518B 29           	DB ')'
358+  518C F1               POP AF
359+  518D
360+  518D              	; save position
361+  518D E5           	PUSH HL
362+  518E              .ENTRY:
363+  518E 47               LD B,A
364+  518F 3A D7 4F         LD A,(ANIMDEFNUM)
365+  5192 90               SUB B
366+  5193 CA 3F 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  5196 FD 21 DB 4F      LD IY,ANIMSPRPTR
368+  519A FA A6 51         JP M, .INCREASE
369+  519D                  ; new value is lower than previous one
370+  519D CD B1 51         CALL .SIZEDIFF
371+  51A0 CD 75 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  51A3 C3 36 50         JP MAXANIMITEMS.E1
373+  51A6              .INCREASE:
374+  51A6 ED 44            NEG
375+  51A8 CD B1 51         CALL .SIZEDIFF
376+  51AB CD A1 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  51AE C3 51 50         JP MAXANIMITEMS.E2
378+  51B1              .SIZEDIFF:
379+  51B1 26 00            LD H,0
380+  51B3 6F               LD L,A
381+  51B4 CD 54 61         CALL HLx16
382+  51B7 78               LD A,B
383+  51B8 32 D7 4F         LD (ANIMDEFNUM),A
384+  51BB 44               LD B,H
385+  51BC 4D               LD C,L
386+  51BD C9               RET ; BC=size difference in bytes
387+  51BE              ; *******************************************************************************************************
388+  51BE
389+  51BE              ; *******************************************************************************************************
390+  51BE              ; function to handle CALL ANIMDEF basic extension
391+  51BE              ; ANIMITEMPAT ( BYTE id,
392+  51BE              ;               BYTE size,
393+  51BE              ;               INT[] list )
394+  51BE              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51BE              ANIMDEF:
396+  51BE                  ; opening (
397+  51BE CD 66 62     	CALL CHKCHAR
398+  51C1 28           	DB '('
399+  51C2              	; get id
400+  51C2 DD 21 1C 52  	LD IX, GETBYT
401+  51C6 CD 59 01     	CALL CALBAS
402+  51C9 F5               PUSH AF
403+  51CA                  ; check if out of bounds
404+  51CA 3C               INC A
405+  51CB 4F               LD C,A
406+  51CC 3A D7 4F         LD A,(ANIMDEFNUM)
407+  51CF B9               CP C
408+  51D0 DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51D3              	; comma
410+  51D3 CD 66 62     	CALL CHKCHAR
411+  51D6 2C           	DB ','
412+  51D7              	; get size
413+  51D7 DD 21 1C 52  	LD IX, GETBYT
414+  51DB CD 59 01     	CALL CALBAS
415+  51DE FE 10            CP 16
416+  51E0 D2 80 62         JP NC, OVERFLOW
417+  51E3 B7               OR A
418+  51E4 CA 80 62         JP Z, OVERFLOW
419+  51E7 F5           	PUSH AF
420+  51E8              	; comma
421+  51E8 CD 66 62     	CALL CHKCHAR
422+  51EB 2C           	DB ','
423+  51EC              	; get pointer to a list of animation items in integer array format
424+  51EC                  ; get array pointer
425+  51EC D1               POP DE
426+  51ED D5               PUSH DE
427+  51EE 3E 02            LD A,2
428+  51F0 06 01            LD B,1
429+  51F2 CD 91 62         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51F5 C5               PUSH BC
431+  51F6              	; ending )
432+  51F6 CD 66 62     	CALL CHKCHAR
433+  51F9 29           	DB ')'
434+  51FA              .ENTRY:
435+  51FA E5               PUSH HL
436+  51FB DD E1            POP IX
437+  51FD D1               POP DE ; pointer to INT array
438+  51FE C1               POP BC ; B=item number
439+  51FF F1               POP AF ; id
440+  5200 D5               PUSH DE
441+  5201 CD EF 4F         CALL GETnthANIMDEF
442+  5204 D1               POP DE
443+  5205 70               LD (HL),B
444+  5206              .L1:
445+  5206 23               INC HL
446+  5207 1A               LD A,(DE)
447+  5208 13          > INC DE
447+  5209 13          > INC DE
448+  520A 77               LD (HL),A
449+  520B 10 F9            DJNZ .L1
450+  520D DD E5            PUSH IX
451+  520F E1               POP HL
452+  5210 C9               RET
453+  5211              ; *******************************************************************************************************
454+  5211
455+  5211              ; *******************************************************************************************************
456+  5211              ; function to handle CALL MAXANIMSPRS basic extension
457+  5211              ; MAXANIMSPRS (BYTE number)
458+  5211              ; sets new number and moves memory buffers as needed
459+  5211              MAXANIMSPRS:
460+  5211              	; opening (
461+  5211 CD 66 62     	CALL CHKCHAR
462+  5214 28           	DB '('
463+  5215              	; get value
464+  5215 DD 21 1C 52  	LD IX, GETBYT
465+  5219 CD 59 01     	CALL CALBAS
466+  521C F5               PUSH AF
467+  521D              	; ending )
468+  521D CD 66 62     	CALL CHKCHAR
469+  5220 29           	DB ')'
470+  5221 F1               POP AF
471+  5222
472+  5222              	; save position
473+  5222 E5           	PUSH HL
474+  5223              .ENTRY:
475+  5223 47               LD B,A
476+  5224 3A DA 4F         LD A,(ANIMSPRNUM)
477+  5227 90               SUB B
478+  5228 CA 3F 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  522B FD 21 10 40      LD IY,FREEMEMPTR
480+  522F FA 3B 52         JP M, .INCREASE
481+  5232                  ; new value is lower than previous one
482+  5232 CD 5A 52         CALL .SIZEDIFF
483+  5235 CD 75 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  5238 C3 3F 50         JP MAXANIMITEMS.EXIT
485+  523B              .INCREASE:
486+  523B ED 44            NEG
487+  523D F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  523E CD 5A 52         CALL .SIZEDIFF
489+  5241 CD A1 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  5244 AF               XOR A
491+  5245 ED 42            SBC HL,BC ; location of new stuff
492+  5247 F1               POP AF
493+  5248 47               LD B,A
494+  5249 11 08 00         LD DE,8
495+  524C E5               PUSH HL
496+  524D DD E1            POP IX
497+  524F              .L1:
498+  524F DD 36 06 00      LD (IX+6),0
499+  5253 DD 19            ADD IX,DE
500+  5255 10 F8            DJNZ .L1
501+  5257 C3 3F 50         JP MAXANIMITEMS.EXIT
502+  525A              .SIZEDIFF:
503+  525A 26 00            LD H,0
504+  525C 6F               LD L,A
505+  525D CD 55 61         CALL HLx8
506+  5260 78               LD A,B
507+  5261 32 DA 4F         LD (ANIMSPRNUM),A
508+  5264 44               LD B,H
509+  5265 4D               LD C,L
510+  5266 C9               RET ; BC=size difference in bytes
511+  5267              ; *******************************************************************************************************
512+  5267
513+  5267              ; *******************************************************************************************************
514+  5267              ; function to handle CALL ANIMSPRITE basic extension
515+  5267              ; ANIMSPRITE ( BYTE id,
516+  5267              ;              BYTE sprite_number,
517+  5267              ;              BYTE animation_definition_id,
518+  5267              ;              BYTE cyclic_flag )
519+  5267              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  5267              ANIMSPRITE:
521+  5267                  ; opening (
522+  5267 CD 66 62     	CALL CHKCHAR
523+  526A 28           	DB '('
524+  526B              	; get sprite animation id
525+  526B DD 21 1C 52  	LD IX, GETBYT
526+  526F CD 59 01     	CALL CALBAS
527+  5272 F5               PUSH AF
528+  5273 3C               INC A
529+  5274 4F               LD C,A
530+  5275 3A DA 4F         LD A,(ANIMSPRNUM)
531+  5278 B9               CP C
532+  5279 DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  527C              	; comma
534+  527C CD 66 62     	CALL CHKCHAR
535+  527F 2C           	DB ','
536+  5280              	; get sprite number
537+  5280 DD 21 1C 52  	LD IX, GETBYT
538+  5284 CD 59 01     	CALL CALBAS
539+  5287 F5               PUSH AF
540+  5288                  ; check if out of bounds
541+  5288 FE 20            CP 32
542+  528A D2 7C 62         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  528D              	; comma
544+  528D CD 66 62     	CALL CHKCHAR
545+  5290 2C           	DB ','
546+  5291              	; get animation definition id
547+  5291 DD 21 1C 52  	LD IX, GETBYT
548+  5295 CD 59 01     	CALL CALBAS
549+  5298 F5               PUSH AF
550+  5299 3C               INC A
551+  529A 4F               LD C,A
552+  529B 3A D7 4F         LD A,(ANIMDEFNUM)
553+  529E B9               CP C
554+  529F DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  52A2              	; comma
556+  52A2 CD 66 62     	CALL CHKCHAR
557+  52A5 2C           	DB ','
558+  52A6              	; get cyclic flag
559+  52A6 DD 21 1C 52  	LD IX, GETBYT
560+  52AA CD 59 01         CALL CALBAS
561+  52AD F5           	PUSH AF
562+  52AE              	; ending )
563+  52AE CD 66 62     	CALL CHKCHAR
564+  52B1 29           	DB ')'
565+  52B2              .ENTRY:
566+  52B2 E5               PUSH HL
567+  52B3 DD E1            POP IX
568+  52B5 D9               EXX
569+  52B6 D1               POP DE ; cyclic
570+  52B7 C1               POP BC ; animation definition id
571+  52B8 E1               POP HL ; sprite number
572+  52B9 D9               EXX
573+  52BA F1               POP AF ; sprite animation id
574+  52BB CD FB 4F         CALL GETnthSPRANIM
575+  52BE E5               PUSH HL
576+  52BF FD E1            POP IY
577+  52C1 D9               EXX
578+  52C2 FD 74 00         LD (IY),H
579+  52C5 FD 70 04         LD (IY+4),B
580+  52C8 FD 72 05         LD (IY+5),D
581+  52CB                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
582+  52CB                  ; following will do preparation for ANIMSTEP situation
583+  52CB                  ; current item set to above limit and timer to 1
584+  52CB                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
585+  52CB FD 36 03 FF      LD (IY+3),255
586+  52CF FD 36 01 01      LD (IY+1),1
587+  52D3 FD 36 02 00      LD (IY+2),0
588+  52D7                  ; mark as sprite animation
589+  52D7 FD 36 07 00      LD (IY+7),0
590+  52DB DD E5            PUSH IX
591+  52DD E1               POP HL
592+  52DE C9               RET
593+  52DF              ; *******************************************************************************************************
594+  52DF
595+  52DF              ; *******************************************************************************************************
596+  52DF              ; function to handle CALL ANIMCHAR basic extension
597+  52DF              ; ANIMCHAR ( BYTE id,
598+  52DF              ;            INT character number 0-767,
599+  52DF              ;            BYTE animation_definition_id,
600+  52DF              ;            BYTE cyclic_flag )
601+  52DF              ; fills sprite animation data, returns an error if out of bounds, or invalid type
602+  52DF              ANIMCHAR:
603+  52DF                  ; opening (
604+  52DF CD 66 62     	CALL CHKCHAR
605+  52E2 28           	DB '('
606+  52E3              	; get sprite animation id
607+  52E3 DD 21 1C 52  	LD IX, GETBYT
608+  52E7 CD 59 01     	CALL CALBAS
609+  52EA F5               PUSH AF
610+  52EB 3C               INC A
611+  52EC 4F               LD C,A
612+  52ED 3A DA 4F         LD A,(ANIMSPRNUM)
613+  52F0 B9               CP C
614+  52F1 DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
615+  52F4              	; comma
616+  52F4 CD 66 62     	CALL CHKCHAR
617+  52F7 2C           	DB ','
618+  52F8              	; get character number
619+  52F8 DD 21 2F 54  	LD IX, FRMQNT
620+  52FC CD 59 01     	CALL CALBAS
621+  52FF D5               PUSH DE
622+  5300                  ; check if out of bounds
623+  5300 7A               LD A,D
624+  5301 FE 03            CP 3
625+  5303 D2 7C 62         JP NC, SUBSCRIPT_OUT_OF_RANGE
626+  5306              	; comma
627+  5306 CD 66 62     	CALL CHKCHAR
628+  5309 2C           	DB ','
629+  530A              	; get animation definition id
630+  530A DD 21 1C 52  	LD IX, GETBYT
631+  530E CD 59 01     	CALL CALBAS
632+  5311 F5               PUSH AF
633+  5312 3C               INC A
634+  5313 4F               LD C,A
635+  5314 3A D7 4F         LD A,(ANIMDEFNUM)
636+  5317 B9               CP C
637+  5318 DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
638+  531B              	; comma
639+  531B CD 66 62     	CALL CHKCHAR
640+  531E 2C           	DB ','
641+  531F              	; get cyclic flag
642+  531F DD 21 1C 52  	LD IX, GETBYT
643+  5323 CD 59 01         CALL CALBAS
644+  5326 F5           	PUSH AF
645+  5327              	; ending )
646+  5327 CD 66 62     	CALL CHKCHAR
647+  532A 29           	DB ')'
648+  532B              .ENTRY:
649+  532B E5               PUSH HL
650+  532C DD E1            POP IX
651+  532E D9               EXX
652+  532F D1               POP DE ; cyclic
653+  5330 C1               POP BC ; animation definition id
654+  5331 E1               POP HL ; character number
655+  5332 D9               EXX
656+  5333 F1               POP AF ; sprite animation id
657+  5334 CD FB 4F         CALL GETnthSPRANIM
658+  5337 E5               PUSH HL
659+  5338 FD E1            POP IY
660+  533A D9               EXX
661+  533B FD 75 00         LD (IY),L
662+  533E 24               INC H ; save character bank+1
663+  533F FD 74 07         LD (IY+7),H
664+  5342 FD 70 04         LD (IY+4),B
665+  5345 FD 72 05         LD (IY+5),D
666+  5348                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
667+  5348                  ; following will do preparation for ANIMSTEP situation
668+  5348                  ; current item set to above limit and timer to 1
669+  5348                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
670+  5348 FD 36 03 FF      LD (IY+3),255
671+  534C FD 36 01 01      LD (IY+1),1
672+  5350 FD 36 02 00      LD (IY+2),0
673+  5354 DD E5            PUSH IX
674+  5356 E1               POP HL
675+  5357 C9               RET
676+  5358              ; *******************************************************************************************************
677+  5358
678+  5358              ; *******************************************************************************************************
679+  5358              ; function to handle CALL ANIMSTEP basic extension
680+  5358              ; two forms
681+  5358              ; ANIMSTEP ( BYTE id )
682+  5358              ; or
683+  5358              ; ANIMSTEP ( BYTE item_number,
684+  5358              ;            INT[] sprite_animations )
685+  5358              ; sets active flag to 1
686+  5358              ANIMSTEP:
687+  5358 11 D5 53         LD DE,ANIMSTARTSTOP_COMMON.STEP
688+  535B 18 08            JR ANIMSTARTSTOP_COMMON
689+  535D              ; *******************************************************************************************************
690+  535D              ; *******************************************************************************************************
691+  535D              ; function to handle CALL ANIMSTART basic extension
692+  535D              ; two forms
693+  535D              ; ANIMSTART ( BYTE id )
694+  535D              ; or
695+  535D              ; ANIMSTART ( BYTE item_number,
696+  535D              ;             INT[] sprite_animations )
697+  535D              ; sets active flag to 1
698+  535D              ANIMSTART:
699+  535D 11 C3 53         LD DE,ANIMSTARTSTOP_COMMON.START
700+  5360 18 03            JR ANIMSTARTSTOP_COMMON
701+  5362              ; *******************************************************************************************************
702+  5362              ; *******************************************************************************************************
703+  5362              ; function to handle CALL ANIMSTOP basic extension
704+  5362              ; two forms
705+  5362              ; ANIMSTOP ( BYTE id )
706+  5362              ; or
707+  5362              ; ANIMSTOP ( BYTE item_number,
708+  5362              ;            INT[] sprite_animations )
709+  5362              ; sets active flag to 1
710+  5362              ANIMSTOP:
711+  5362 11 D0 53         LD DE,ANIMSTARTSTOP_COMMON.STOP
712+  5365              ; *******************************************************************************************************
713+  5365              ANIMSTARTSTOP_COMMON:
714+  5365 ED 53 C1 53      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
715+  5369                  ; opening (
716+  5369 CD 66 62     	CALL CHKCHAR
717+  536C 28           	DB '('
718+  536D              	; get sprite animation id or array size
719+  536D DD 21 1C 52  	LD IX,GETBYT
720+  5371 CD 59 01     	CALL CALBAS
721+  5374 F5               PUSH AF
722+  5375                  ; check if comma present
723+  5375 CD 70 62         CALL GETPREVCHAR
724+  5378 23               INC HL
725+  5379 FE 2C            CP ','
726+  537B 28 0C            JR Z,.L1
727+  537D FE 29            CP ')'
728+  537F C2 88 62         JP NZ,SYNTAX_ERROR
729+  5382                  ; ok so single argument variant
730+  5382 F1               POP AF
731+  5383 E5               PUSH HL
732+  5384 CD AF 53         CALL .SETVALUE
733+  5387 E1               POP HL
734+  5388 C9               RET
735+  5389              .L1:
736+  5389                  ; get array pointer
737+  5389 D1               POP DE
738+  538A D5               PUSH DE
739+  538B 3E 02            LD A,2
740+  538D 06 01            LD B,1
741+  538F CD 91 62         CALL GET_BASIC_ARRAY_DATA_POINTER
742+  5392 C5               PUSH BC
743+  5393              	; ending )
744+  5393 CD 66 62     	CALL CHKCHAR
745+  5396 29           	DB ')'
746+  5397 D1               POP DE ; array pointer
747+  5398 C1               POP BC ; number of items
748+  5399 78               LD A,B
749+  539A B7               OR A
750+  539B CA 7C 62         JP Z,SUBSCRIPT_OUT_OF_RANGE
751+  539E E5               PUSH HL
752+  539F F3               DI
753+  53A0              .L2:
754+  53A0 C5               PUSH BC
755+  53A1 1A               LD A,(DE)
756+  53A2 13          > INC DE
756+  53A3 13          > INC DE
757+  53A4 D5               PUSH DE
758+  53A5 CD AF 53         CALL .SETVALUE
759+  53A8 D1               POP DE
760+  53A9 C1               POP BC
761+  53AA 10 F4            DJNZ .L2
762+  53AC FB               EI
763+  53AD E1               POP HL
764+  53AE C9               RET
765+  53AF
766+  53AF              .SETVALUE:
767+  53AF 47               LD B,A
768+  53B0 3C               INC A
769+  53B1 4F               LD C,A
770+  53B2 3A DA 4F         LD A,(ANIMSPRNUM)
771+  53B5 B9               CP C
772+  53B6 DA 7C 62         JP C,SUBSCRIPT_OUT_OF_RANGE
773+  53B9 78               LD A,B
774+  53BA CD FB 4F         CALL GETnthSPRANIM
775+  53BD E5               PUSH HL
776+  53BE DD E1            POP IX
777+  53C0              .FN:
778+  53C0 C3 00 00         JP 0
779+  53C3              .START:
780+  53C3 DD 36 06 01      LD (IX+6),1 ; active flag
781+  53C7 DD 36 03 00      LD (IX+3),0 ; current item
782+  53CB 06 00            LD B,0 ; setup timer
783+  53CD C3 54 54         JP SETUP_ANIM_STEP
784+  53D0              .STOP:
785+  53D0 DD 36 06 00      LD (IX+6),0 ; active flag
786+  53D4 C9               RET
787+  53D5              .STEP:
788+  53D5 06 00            LD B,0
789+  53D7 C3 F8 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
790+  53DA              ; *******************************************************************************************************
791+  53DA
792+  53DA              ; *******************************************************************************************************
793+  53DA              ; function processes animations during vblank period
794+  53DA              PROCESS_ANIMATIONS:
795+  53DA 3A DA 4F         LD A,(ANIMSPRNUM)
796+  53DD B7               OR A
797+  53DE C8               RET Z; no animations defined
798+  53DF 47               LD B,A
799+  53E0 DD 2A DB 4F      LD IX,(ANIMSPRPTR)
800+  53E4              .L1:
801+  53E4 C5               PUSH BC
802+  53E5 06 00            LD B,0 ; normal mode, change on timer expiry only
803+  53E7 CD F3 53         CALL PROCESS_SINGLE_ANIMATION
804+  53EA 11 08 00         LD DE,8
805+  53ED DD 19            ADD IX,DE
806+  53EF C1               POP BC
807+  53F0 10 F2            DJNZ .L1
808+  53F2 C9               RET
809+  53F3              ; *******************************************************************************************************
810+  53F3
811+  53F3              ; *******************************************************************************************************
812+  53F3              ; processes single sprite animation
813+  53F3              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
814+  53F3              ; on timer expiry goes to next animation item
815+  53F3              ; input IX=sprite animation pointer
816+  53F3              ; input B=1 force mode, activate animation action regardless of expired timer
817+  53F3              PROCESS_SINGLE_ANIMATION:
818+  53F3 DD 7E 06         LD A,(IX+6); active
819+  53F6 B7               OR A
820+  53F7 C8               RET Z ; inactive animation
821+  53F8              .INACTIVE_TOO:
822+  53F8 DD 6E 01         LD L,(IX+1)
823+  53FB DD 66 02         LD H,(IX+2) ; HL=end time
824+  53FE 2B               DEC HL
825+  53FF DD 75 01         LD (IX+1),L
826+  5402 DD 74 02         LD (IX+2),H
827+  5405 7D               LD A,L
828+  5406 B4               OR H
829+  5407 28 06            JR Z,.STEP
830+  5409 05               DEC B
831+  540A 04               INC B
832+  540B C8               RET Z ; not forced mode, return
833+  540C C3 54 54         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
834+  540F              .STEP:
835+  540F 06 00            LD B,0; setup timer
836+  5411 DD 34 03         INC (IX+3) ; current animation item
837+  5414 C3 54 54         JP SETUP_ANIM_STEP
838+  5417              ; *******************************************************************************************************
839+  5417
840+  5417              ; *******************************************************************************************************
841+  5417              ; function will setup sprite animation after current item change
842+  5417              ; input A=current animation definition
843+  5417              ; input IX=pointer to sprite animation
844+  5417              ; input B=1 skip timer setup
845+  5417              ; output IY=pointer to animation item
846+  5417              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
847+  5417              ; basically sets new end time for current animation
848+  5417              INIT_CURRENT_ANIMATION:
849+  5417 CD EF 4F         CALL GETnthANIMDEF
850+  541A DD 7E 03         LD A,(IX+3) ; current animation item
851+  541D BE               CP (HL) ; number of animation items in the animation definition
852+  541E 38 0A            JR C,.L3 ; last item not reached
853+  5420                  ; last item reached
854+  5420 DD 7E 05         LD A,(IX+5) ; cyclic flag
855+  5423 B7               OR A
856+  5424 28 2C            JR Z,.ERROR ; non-cyclic animation
857+  5426                  ; cyclic animation, restart
858+  5426 DD 36 03 00      LD (IX+3),0; current item
859+  542A              .L3:
860+  542A                  ; HL = animation definition
861+  542A 23               INC HL ; skip animation definition size field
862+  542B 16 00            LD D,0
863+  542D DD 5E 03         LD E,(IX+3); current item
864+  5430 19               ADD HL,DE
865+  5431 4E               LD C,(HL) ; current animation item
866+  5432 0C               INC C
867+  5433 3A D4 4F         LD A,(ANIMITEMNUM)
868+  5436 B9               CP C
869+  5437 38 19            JR C,.ERROR ; invalid animation item, stop animation
870+  5439 0D               DEC C
871+  543A 79               LD A,C
872+  543B CD E6 4F         CALL GETnthANIMITEM
873+  543E E5               PUSH HL
874+  543F FD E1            POP IY ; IY=animation item
875+  5441 05               DEC B
876+  5442 28 0C            JR Z,.EXIT
877+  5444 FD 5E 01         LD E,(IY+1)
878+  5447 FD 56 02         LD D,(IY+2) ; duration
879+  544A DD 73 01         LD (IX+1),E
880+  544D DD 72 02         LD (IX+2),D
881+  5450              .EXIT:
882+  5450 AF               XOR A
883+  5451 C9               RET
884+  5452              .ERROR:
885+  5452 37               SCF
886+  5453 C9               RET
887+  5454              ; *******************************************************************************************************
888+  5454
889+  5454              ; *******************************************************************************************************
890+  5454              ; function will display currect item and set up expiry time
891+  5454              ; it will also stop the animation if expired
892+  5454              ; sets sprite update flag if any changes in sprite data made
893+  5454              ; input IX=current sprite animation
894+  5454              ; input B=1 skip timer setup
895+  5454              SETUP_ANIM_STEP:
896+  5454 DD 4E 04         LD C,(IX+4) ; animation definition ID
897+  5457 0C               INC C
898+  5458 3A D7 4F         LD A,(ANIMDEFNUM)
899+  545B B9               CP C
900+  545C 30 05            JR NC,.L2
901+  545E                  ; given animation item is outside of bounds, deactivate animation
902+  545E              .STOPANIM:
903+  545E DD 36 06 00      LD (IX+6),0
904+  5462 C9               RET
905+  5463              .L2:
906+  5463 0D               DEC C
907+  5464 79               LD A,C
908+  5465 CD 17 54         CALL INIT_CURRENT_ANIMATION
909+  5468 38 F4            JR C, .STOPANIM
910+  546A FD 7E 00         LD A,(IY) ; type of animation item
911+  546D B7               OR A
912+  546E 28 44            JR Z,.L4 ; change pattern and/or color
913+  5470              .PAT:
914+  5470                  ; change pattern definition
915+  5470                  ; check if sprite or character
916+  5470 DD 7E 07         LD A,(IX+7)
917+  5473 B7               OR A
918+  5474 20 58            JR NZ,.CHAR
919+  5476 DD 7E 00         LD A,(IX) ; sprite number
920+  5479 CD 7C 4D         CALL GETnthSPRATTR
921+  547C 23          > INC HL ; skip y and x
921+  547D 23          > INC HL
921+  547E 23          > INC HL
921+  547F 23          > INC HL
922+  5480 7E               LD A,(HL); current pattern
923+  5481 26 00            LD H,0
924+  5483 6F               LD L,A
925+  5484 3A E0 F3         LD A,(REG1SAV)
926+  5487 E6 02            AND 2
927+  5489 20 07            JR NZ,.L6
928+  548B                  ; 8x8 sprite
929+  548B CD 55 61         CALL HLx8
930+  548E 06 08            LD B,8
931+  5490 18 05            JR .L5
932+  5492              .L6:
933+  5492 CD 53 61         CALL HLx32
934+  5495 06 20            LD B,32
935+  5497              .L5:
936+  5497 3A AF FC         LD A,(SCRMOD)
937+  549A 3D               DEC A
938+  549B 20 06            JR NZ,.L10
939+  549D ED 5B C5 F3      LD DE,(T32PAT)
940+  54A1 18 04            JR .L7
941+  54A3              .L10:
942+  54A3 ED 5B CF F3      LD DE,(GRPPAT)
943+  54A7              .L7:
944+  54A7 19               ADD HL,DE
945+  54A8 CD 40 61         CALL SETWRT_LOCAL
946+  54AB FD 6E 03         LD L,(IY+3)
947+  54AE FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
948+  54B1 C3 4B 61         JP BBYTECOPY
949+  54B4              .L4:
950+  54B4                  ; change pattern and color in sprite attributes table
951+  54B4 DD 7E 00         LD A,(IX) ; sprite number
952+  54B7 CD 7C 4D         CALL GETnthSPRATTR
953+  54BA 23          > INC HL ; skip y and x
953+  54BB 23          > INC HL
953+  54BC 23          > INC HL
953+  54BD 23          > INC HL
954+  54BE FD 7E 03         LD A,(IY+3) ; new pattern
955+  54C1 77               LD (HL),A
956+  54C2 23          > INC HL
956+  54C3 23          > INC HL
957+  54C4 FD 7E 04         LD A,(IY+4) ; new color
958+  54C7 77               LD (HL),A
959+  54C8 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
960+  54CB 36 01            LD (HL),1
961+  54CD C9               RET
962+  54CE              .CHAR:
963+  54CE DD 6E 00         LD L,(IX)
964+  54D1 3D               DEC A
965+  54D2 67               LD H,A
966+  54D3 CD 55 61         CALL HLx8
967+  54D6 3A AF FC         LD A,(SCRMOD)
968+  54D9 3D               DEC A
969+  54DA 20 06            JR NZ,.L8
970+  54DC ED 5B C1 F3      LD DE,(T32CGP)
971+  54E0 18 04            JR .L9
972+  54E2              .L8:
973+  54E2 ED 5B CB F3      LD DE,(GRPCGP)
974+  54E6              .L9:
975+  54E6 06 08            LD B,8
976+  54E8 18 BD            JR .L7
977+  54EA              ; *******************************************************************************************************
978+  54EA
# file closed: asm\ANIMATION.asm
124   54EA               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
  1+  54EA              ; Sprite Group Animate and Move
  2+  54EA
  3+  54EA              ; *******************************************************************************************************
  4+  54EA              ; function to handle CALL SGAM basic extension
  5+  54EA              ; sets position of a group of sprites as described in SPRGRPMOV
  6+  54EA              ; and manually animate a list of animations
  7+  54EA              ; _SGAM ( INT x,
  8+  54EA              ;	      INT y,
  9+  54EA              ;		  BYTE count,
 10+  54EA              ;		  INT[2][count] data_ptr,
 11+  54EA              ;         BYTE item_number,
 12+  54EA              ;         INT[] sprite_animations )
 13+  54EA              ; will put ram in page 0 also, page 1 is already there
 14+  54EA              SGAM:
 15+  54EA 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
 16+  54ED B7           	OR A
 17+  54EE CA 84 62     	JP Z,ILLEGAL_FUNCTION
 18+  54F1              	; opening (
 19+  54F1 CD 66 62     	CALL CHKCHAR
 20+  54F4 28           	DB '('
 21+  54F5              	; get x
 22+  54F5 DD 21 2F 54  	LD IX, FRMQNT
 23+  54F9 CD 59 01     	CALL CALBAS
 24+  54FC ED 53 95 5F  	LD (BLIT_STRUCT),DE
 25+  5500              	; comma
 26+  5500 CD 66 62     	CALL CHKCHAR
 27+  5503 2C           	DB ','
 28+  5504              	; get y
 29+  5504 DD 21 2F 54  	LD IX, FRMQNT
 30+  5508 CD 59 01     	CALL CALBAS
 31+  550B ED 53 97 5F  	LD (BLIT_STRUCT+2),DE
 32+  550F              	; comma
 33+  550F CD 66 62     	CALL CHKCHAR
 34+  5512 2C           	DB ','
 35+  5513              	; get count
 36+  5513 DD 21 1C 52  	LD IX, GETBYT
 37+  5517 CD 59 01     	CALL CALBAS
 38+  551A B7               OR A
 39+  551B CA 7C 62         JP Z,SUBSCRIPT_OUT_OF_RANGE
 40+  551E 32 99 5F     	LD (BLIT_STRUCT+4),A
 41+  5521              	; comma
 42+  5521 CD 66 62     	CALL CHKCHAR
 43+  5524 2C           	DB ','
 44+  5525              	; get sprite group definition array data pointer
 45+  5525 3A 99 5F         LD A,(BLIT_STRUCT+4)
 46+  5528 5F           	LD E,A
 47+  5529 16 03        	LD D,3
 48+  552B 3E 02        	LD A,2
 49+  552D 47           	LD B,A
 50+  552E CD 91 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
 51+  5531 ED 43 9A 5F  	LD (BLIT_STRUCT+5),BC
 52+  5535              	; comma
 53+  5535 CD 66 62     	CALL CHKCHAR
 54+  5538 2C           	DB ','
 55+  5539              	; get sprite animation array size
 56+  5539 DD 21 1C 52  	LD IX,GETBYT
 57+  553D CD 59 01     	CALL CALBAS
 58+  5540 32 9C 5F         LD (BLIT_STRUCT+7),A
 59+  5543 B7               OR A
 60+  5544 CA 7C 62         JP Z,SUBSCRIPT_OUT_OF_RANGE
 61+  5547              	; comma
 62+  5547 CD 66 62     	CALL CHKCHAR
 63+  554A 2C           	DB ','
 64+  554B                  ; get array pointer
 65+  554B 3A 9C 5F         LD A,(BLIT_STRUCT+7)
 66+  554E 57               LD D,A
 67+  554F 3E 02            LD A,2
 68+  5551 06 01            LD B,1
 69+  5553 CD 91 62         CALL GET_BASIC_ARRAY_DATA_POINTER
 70+  5556 ED 43 9D 5F      LD (BLIT_STRUCT+8),BC
 71+  555A              	; ending )
 72+  555A CD 66 62     	CALL CHKCHAR
 73+  555D 29           	DB ')'
 74+  555E
 75+  555E E5               PUSH HL
 76+  555F F3               DI
 77+  5560
 78+  5560              	; enable page 0
 79+  5560 FD 21 67 55  	LD IY, .RET
 80+  5564 C3 19 62     	JP ENABLE_PAGE0
 81+  5567              .RET:
 82+  5567 D9               EXX
 83+  5568 ED 5B 95 5F      LD DE,(BLIT_STRUCT) ; initial x
 84+  556C ED 4B 97 5F      LD BC,(BLIT_STRUCT+2) ; initial y
 85+  5570 D9               EXX
 86+  5571 2A 9A 5F         LD HL,(BLIT_STRUCT+5) ; pointer to data
 87+  5574 3A 99 5F         LD A,(BLIT_STRUCT+4) ; number of entries
 88+  5577 47               LD B,A
 89+  5578 CD C2 4F         CALL SPRGRPMOV.UPDATE_LOC
 90+  557B
 91+  557B 21 9D 55         LD HL,.STEP
 92+  557E 22 C1 53         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
 93+  5581 3A 9C 5F         LD A,(BLIT_STRUCT+7) ; anim number
 94+  5584 47               LD B,A
 95+  5585 ED 5B 9D 5F      LD DE,(BLIT_STRUCT+8) ; anim list
 96+  5589              .L1:
 97+  5589 C5               PUSH BC
 98+  558A 1A               LD A,(DE)
 99+  558B 13          > INC DE
 99+  558C 13          > INC DE
100+  558D D5               PUSH DE
101+  558E CD AF 53         CALL ANIMSTARTSTOP_COMMON.SETVALUE
102+  5591 D1               POP DE
103+  5592 C1               POP BC
104+  5593 10 F4            DJNZ .L1
105+  5595
106+  5595 D1               POP DE
107+  5596 C1               POP BC
108+  5597 CD 90 61         CALL RESTORE_PAGE_INFO
109+  559A FB               EI
110+  559B E1               POP HL
111+  559C C9               RET
112+  559D              .STEP:
113+  559D 06 01            LD B,1
114+  559F C3 F8 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
115+  55A2              ; *******************************************************************************************************
116+  55A2
# file closed: asm\SGAM.asm
125   55A2               ENDIF
126   55A2
127   55A2               IF (RAM_CMDS == 1)
128   55A2               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  55A2              ; *******************************************************************************************************
  2+  55A2              ; function to handle CALL MEMCPY basic extension
  3+  55A2              ; _MEMCPY ( INT source,
  4+  55A2              ;			INT destination,
  5+  55A2              ;			INT count,
  6+  55A2              ; will put ram in page 0 also, page 1 is already there
  7+  55A2              MEMCPY:
  8+  55A2              	; opening (
  9+  55A2 CD 66 62     	CALL CHKCHAR
 10+  55A5 28           	DB '('
 11+  55A6              	; get source address
 12+  55A6 DD 21 2F 54  	LD IX, FRMQNT
 13+  55AA CD 59 01     	CALL CALBAS
 14+  55AD D5           	PUSH DE
 15+  55AE              	; comma
 16+  55AE CD 66 62     	CALL CHKCHAR
 17+  55B1 2C           	DB ','
 18+  55B2              	; get destination address
 19+  55B2 DD 21 2F 54  	LD IX, FRMQNT
 20+  55B6 CD 59 01     	CALL CALBAS
 21+  55B9 D5           	PUSH DE
 22+  55BA              	; comma
 23+  55BA CD 66 62     	CALL CHKCHAR
 24+  55BD 2C           	DB ','
 25+  55BE              	; get length
 26+  55BE DD 21 2F 54  	LD IX, FRMQNT
 27+  55C2 CD 59 01     	CALL CALBAS
 28+  55C5 D5           	PUSH DE
 29+  55C6              	; ending )
 30+  55C6 CD 66 62     	CALL CHKCHAR
 31+  55C9 29           	DB ')'
 32+  55CA
 33+  55CA              	; save position
 34+  55CA E5           	PUSH HL
 35+  55CB DD E1        	POP IX
 36+  55CD
 37+  55CD C1           	POP BC ; count
 38+  55CE D1           	POP DE ; destination
 39+  55CF E1           	POP HL ; source
 40+  55D0 D9           	EXX
 41+  55D1              	; enable page 0
 42+  55D1 FD 21 D8 55  	LD IY, .RET
 43+  55D5 C3 19 62     	JP ENABLE_PAGE0
 44+  55D8              .RET:
 45+  55D8 FB           	EI
 46+  55D9 D9           	EXX
 47+  55DA ED B0        	LDIR
 48+  55DC D1               POP DE
 49+  55DD C1               POP BC
 50+  55DE CD 90 61         CALL RESTORE_PAGE_INFO
 51+  55E1 DD E5        	PUSH IX
 52+  55E3 E1           	POP HL
 53+  55E4 C9           	RET
 54+  55E5              ; *******************************************************************************************************
 55+  55E5
 56+  55E5              ; *******************************************************************************************************
 57+  55E5              ; function to handle CALL FILRAM basic extension
 58+  55E5              ; FILRAM ( INT start address,
 59+  55E5              ;		   INT count,
 60+  55E5              ;		   BYTE value,
 61+  55E5              ; will put ram in page 0 also, page 1 is already there
 62+  55E5              FILRAM:
 63+  55E5              	; opening (
 64+  55E5 CD 66 62     	CALL CHKCHAR
 65+  55E8 28           	DB '('
 66+  55E9              	; get start address
 67+  55E9 DD 21 2F 54  	LD IX, FRMQNT
 68+  55ED CD 59 01     	CALL CALBAS
 69+  55F0 D5           	PUSH DE
 70+  55F1              	; comma
 71+  55F1 CD 66 62     	CALL CHKCHAR
 72+  55F4 2C           	DB ','
 73+  55F5              	; get count
 74+  55F5 DD 21 2F 54  	LD IX, FRMQNT
 75+  55F9 CD 59 01     	CALL CALBAS
 76+  55FC D5           	PUSH DE
 77+  55FD              	; comma
 78+  55FD CD 66 62     	CALL CHKCHAR
 79+  5600 2C           	DB ','
 80+  5601              	; get value
 81+  5601 DD 21 1C 52  	LD IX, GETBYT
 82+  5605 CD 59 01     	CALL CALBAS
 83+  5608 F5           	PUSH AF
 84+  5609              	; ending )
 85+  5609 CD 66 62     	CALL CHKCHAR
 86+  560C 29           	DB ')'
 87+  560D
 88+  560D              	; save position
 89+  560D E5           	PUSH HL
 90+  560E DD E1        	POP IX
 91+  5610
 92+  5610 D1           	POP DE ; actually AF
 93+  5611 C1           	POP BC ; count
 94+  5612 E1           	POP HL ; start address
 95+  5613 78           	LD A, B
 96+  5614 B7           	OR A
 97+  5615 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  5617 B1           	OR C
 99+  5618 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  561A 79           	LD A, C
101+  561B 3D           	DEC A
102+  561C 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  561E              	; one byte to fill
104+  561E 72           	LD (HL), D
105+  561F 18 12        	JR .EXIT
106+  5621              .L1:
107+  5621 D9           	EXX
108+  5622              	; enable page 0
109+  5622 FD 21 29 56  	LD IY, .RET
110+  5626 C3 19 62     	JP ENABLE_PAGE0
111+  5629              .RET:
112+  5629 FB           	EI
113+  562A D9           	EXX
114+  562B CD 37 56     	CALL .FILLVALUE
115+  562E D1               POP DE
116+  562F C1               POP BC
117+  5630 CD 90 61         CALL RESTORE_PAGE_INFO
118+  5633              .EXIT:
119+  5633 DD E5        	PUSH IX
120+  5635 E1           	POP HL
121+  5636 C9           	RET
122+  5637
123+  5637              .FILLVALUE:
124+  5637 72               LD (HL), D
125+  5638 54               LD D, H
126+  5639 5D               LD E, L
127+  563A 13               INC DE
128+  563B 0B               DEC BC
129+  563C ED B0            LDIR
130+  563E C9               RET
131+  563F              ; *******************************************************************************************************
132+  563F
# file closed: asm\MEMORY.asm
129   563F               ENDIF
130   563F
131   563F               IF (SOUND_CMDS == 1)
132   563F               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  563F              MUSIC_INIT_STATUS:
  2+  563F 00            DB 0
  3+  5640              SFX_INIT_STATUS:
  4+  5640 00            DB 0
  5+  5641              SOUND_ENABLED:
  6+  5641 00            DB 0
  7+  5642
  8+  5642              ; *******************************************************************************************************
  9+  5642              ; function to handle CALL SNDPLYINIT basic extension
 10+  5642              ; initializes sound player
 11+  5642              ; _SNDPLYINIT ( INT music_offset,
 12+  5642              ;				INT sfx_offset, can be -1 if no SFX
 13+  5642              ; will put ram in page 0 also, page 1 is already there
 14+  5642              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  5642              SNDPLYINIT:
 16+  5642              	; opening (
 17+  5642 CD 66 62     	CALL CHKCHAR
 18+  5645 28           	DB '('
 19+  5646              	; get music address
 20+  5646 DD 21 2F 54  	LD IX, FRMQNT
 21+  564A CD 59 01     	CALL CALBAS
 22+  564D D5           	PUSH DE
 23+  564E              	; comma
 24+  564E CD 66 62     	CALL CHKCHAR
 25+  5651 2C           	DB ','
 26+  5652              	; get sfx address
 27+  5652 DD 21 2F 54  	LD IX, FRMQNT
 28+  5656 CD 59 01     	CALL CALBAS
 29+  5659 D5           	PUSH DE
 30+  565A              	; ending )
 31+  565A CD 66 62     	CALL CHKCHAR
 32+  565D 29           	DB ')'
 33+  565E
 34+  565E                  ; save position in BASIC text
 35+  565E 44           	LD B, H
 36+  565F 4D           	LD C, L
 37+  5660
 38+  5660              	; pop LDIR parameters and store away for later
 39+  5660 D1           	POP DE ; sfx address
 40+  5661 E1           	POP HL ; music address
 41+  5662 C5           	PUSH BC ; basic text location
 42+  5663 D9           	EXX
 43+  5664 FD 21 6B 56  	LD IY, .RET
 44+  5668 C3 19 62     	JP ENABLE_PAGE0
 45+  566B              .RET:
 46+  566B D9           	EXX
 47+  566C
 48+  566C D5           	PUSH DE
 49+  566D AF           	XOR A
 50+  566E              	; HL = music location
 51+  566E CD 62 41     	CALL PLY_AKG_INIT
 52+  5671 3E 01        	LD A, 1
 53+  5673 32 3F 56     	LD (MUSIC_INIT_STATUS), A
 54+  5676
 55+  5676 E1           	POP HL ; SFX
 56+  5677              	; check if SFX address -1
 57+  5677 23           	INC HL
 58+  5678 7D           	LD A, L
 59+  5679 B4           	OR H
 60+  567A 28 09        	JR Z,.L1
 61+  567C 2B           	DEC HL
 62+  567D CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  5680 3E 01        	LD A, 1
 64+  5682 32 40 56     	LD (SFX_INIT_STATUS), A
 65+  5685              .L1:
 66+  5685 D1               POP DE
 67+  5686 C1               POP BC
 68+  5687 CD 90 61         CALL RESTORE_PAGE_INFO
 69+  568A
 70+  568A E1           	POP HL
 71+  568B C9           	RET
 72+  568C              ; *******************************************************************************************************
 73+  568C
 74+  568C              ; *******************************************************************************************************
 75+  568C              ; function to handle CALL SNDPLYON basic extension
 76+  568C              ; enables sound player
 77+  568C              ; _SNDPLYON
 78+  568C              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  568C              ; if not throws out of data error
 80+  568C              SNDPLYON:
 81+  568C 3A 3F 56     	LD A, (MUSIC_INIT_STATUS)
 82+  568F B7           	OR A
 83+  5690 20 05        	JR NZ, .L1
 84+  5692              	; player not initialized, throw error
 85+  5692 1E 04        	LD E, 04 ; Out of DATA
 86+  5694 C3 8A 62     	JP THROW_ERROR
 87+  5697              .L1:
 88+  5697 32 41 56     	LD (SOUND_ENABLED), A
 89+  569A              	; disable key click
 90+  569A AF           	XOR A
 91+  569B 32 DB F3     	LD (CLIKSW), A
 92+  569E C9           	RET
 93+  569F              ; *******************************************************************************************************
 94+  569F
 95+  569F              ; *******************************************************************************************************
 96+  569F              ; function to handle CALL SNDPLYOFF basic extension
 97+  569F              ; disables sound player
 98+  569F              ; _SNDPLYOFF
 99+  569F              ; sets SOUND_ENABLED variable to 0
100+  569F              ; calls AKG to stop music and SFX on all channels if initialized
101+  569F              SNDPLYOFF:
102+  569F 3A 41 56     	LD A, (SOUND_ENABLED)
103+  56A2 B7           	OR A
104+  56A3 C8           	RET Z ; already stopped
105+  56A4 AF           	XOR A
106+  56A5 32 41 56     	LD (SOUND_ENABLED), A
107+  56A8 E5           	PUSH HL
108+  56A9 CD 21 42     	CALL PLY_AKG_STOP
109+  56AC 3A 40 56     	LD A, (SFX_INIT_STATUS)
110+  56AF B7           	OR A
111+  56B0 28 0E        	JR Z, .EXIT ; SFX not in use
112+  56B2 AF           	XOR A
113+  56B3 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  56B6 3E 01        	LD A, 1
115+  56B8 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  56BB 3E 02        	LD A, 2
117+  56BD CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  56C0              .EXIT:
119+  56C0 E1           	POP HL
120+  56C1 C9           	RET
121+  56C2              ; *******************************************************************************************************
122+  56C2
123+  56C2              ; *******************************************************************************************************
124+  56C2              ; function to handle CALL SNDSFX basic extension
125+  56C2              ; plays a sound effect
126+  56C2              ; _SNDSFX ( BYTE sfx_number, >0
127+  56C2              ;			BYTE channel, = 0,1 or 2
128+  56C2              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  56C2              ; will put ram in page 0 also, page 1 is already there
130+  56C2              ; if sound off throws illegal function call
131+  56C2              ; if sfx not initialized, throws out of data
132+  56C2              SNDSFX:
133+  56C2              	; opening (
134+  56C2 CD 66 62     	CALL CHKCHAR
135+  56C5 28           	DB '('
136+  56C6              	; get sfx_number
137+  56C6 DD 21 1C 52  	LD IX, GETBYT
138+  56CA CD 59 01     	CALL CALBAS
139+  56CD D5           	PUSH DE
140+  56CE              	; comma
141+  56CE CD 66 62     	CALL CHKCHAR
142+  56D1 2C           	DB ','
143+  56D2              	; get sfx address
144+  56D2 DD 21 1C 52  	LD IX, GETBYT
145+  56D6 CD 59 01     	CALL CALBAS
146+  56D9 D5           	PUSH DE
147+  56DA              	; comma
148+  56DA CD 66 62     	CALL CHKCHAR
149+  56DD 2C           	DB ','
150+  56DE              	; get inverted volume
151+  56DE DD 21 1C 52  	LD IX, GETBYT
152+  56E2 CD 59 01     	CALL CALBAS
153+  56E5 D5           	PUSH DE
154+  56E6              	; ending )
155+  56E6 CD 66 62     	CALL CHKCHAR
156+  56E9 29           	DB ')'
157+  56EA
158+  56EA 3A 41 56     	LD A, (SOUND_ENABLED)
159+  56ED B7           	OR A
160+  56EE 20 05        	JR NZ, .L1
161+  56F0              	; sound disabled, throw illegal function call
162+  56F0 1E 05        	LD E, 5
163+  56F2 C3 8A 62     	JP THROW_ERROR
164+  56F5              .L1:
165+  56F5 3A 40 56     	LD A, (SFX_INIT_STATUS)
166+  56F8 B7           	OR A
167+  56F9 20 05        	JR NZ, .L2
168+  56FB              	; sfx data not initialized, throw out of data
169+  56FB 1E 04        	LD E, 4
170+  56FD C3 8A 62     	JP THROW_ERROR
171+  5700              .L2:
172+  5700              	; pop  parameters and store away for later
173+  5700 D1           	POP DE ; inverted volume
174+  5701 43           	LD B, E
175+  5702 D1           	POP DE ; channel
176+  5703 4B           	LD C, E
177+  5704 D1           	POP DE
178+  5705 7B           	LD A, E
179+  5706 08           	EX AF, AF'
180+  5707 E5           	PUSH HL ; basic text location
181+  5708 D9           	EXX
182+  5709 FD 21 10 57  	LD IY, .RET
183+  570D C3 19 62     	JP ENABLE_PAGE0
184+  5710              .RET:
185+  5710 D9           	EXX
186+  5711 08           	EX AF, AF'
187+  5712 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  5715
189+  5715 D1               POP DE
190+  5716 C1               POP BC
191+  5717 CD 90 61         CALL RESTORE_PAGE_INFO
192+  571A
193+  571A E1           	POP HL
194+  571B C9           	RET
195+  571C              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
133   571C               ENDIF
134   571C
135   571C               IF (VRAM_CMDS == 1)
136   571C               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  571C              ; *******************************************************************************************************
  2+  571C              ; function to handle CALL FILVRM basic extension
  3+  571C              ; FILVRM ( INT offset,
  4+  571C              ;		   INT count,
  5+  571C              ;		   BYTE value,
  6+  571C              ;		   BYTE wait_vsync) >0 = true
  7+  571C              ; wait_vsync will issue HALT before copying
  8+  571C              FILVRM:
  9+  571C              	; opening (
 10+  571C CD 66 62     	CALL CHKCHAR
 11+  571F 28           	DB '('
 12+  5720              	; get offset address
 13+  5720 DD 21 2F 54  	LD IX, FRMQNT
 14+  5724 CD 59 01     	CALL CALBAS
 15+  5727 D5           	PUSH DE
 16+  5728              	; comma
 17+  5728 CD 66 62     	CALL CHKCHAR
 18+  572B 2C           	DB ','
 19+  572C              	; get count
 20+  572C DD 21 2F 54  	LD IX, FRMQNT
 21+  5730 CD 59 01     	CALL CALBAS
 22+  5733 D5           	PUSH DE
 23+  5734              	; comma
 24+  5734 CD 66 62     	CALL CHKCHAR
 25+  5737 2C           	DB ','
 26+  5738              	; get value
 27+  5738 DD 21 1C 52  	LD IX, GETBYT
 28+  573C CD 59 01     	CALL CALBAS
 29+  573F F5           	PUSH AF
 30+  5740              	; comma
 31+  5740 CD 66 62     	CALL CHKCHAR
 32+  5743 2C           	DB ','
 33+  5744              	; get vsync wait
 34+  5744 DD 21 1C 52  	LD IX, GETBYT
 35+  5748 CD 59 01     	CALL CALBAS
 36+  574B F5           	PUSH AF
 37+  574C              	; ending )
 38+  574C CD 66 62     	CALL CHKCHAR
 39+  574F 29           	DB ')'
 40+  5750
 41+  5750 FB               EI
 42+  5751              	; save position
 43+  5751 E5           	PUSH HL
 44+  5752 DD E1        	POP IX
 45+  5754
 46+  5754              	; syntax ok
 47+  5754              	; wait for vsync if needed
 48+  5754 F1           	POP AF
 49+  5755 B7           	OR A
 50+  5756 28 01        	JR Z, .L1
 51+  5758 76           	HALT
 52+  5759
 53+  5759              .L1:
 54+  5759 3E 01        	LD A,1
 55+  575B 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  575E F1               POP AF ; value
 57+  575F C1               POP BC ; count
 58+  5760 E1               POP HL ; offset
 59+  5761 CD 56 00         CALL BIOS_FILVRM
 60+  5764 AF           	XOR A
 61+  5765 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  5768
 63+  5768              .L3:
 64+  5768 DD E5        	PUSH IX
 65+  576A E1           	POP HL
 66+  576B C9           	RET
 67+  576C              ; *******************************************************************************************************
 68+  576C
 69+  576C              ; *******************************************************************************************************
 70+  576C              ; function to handle CALL MEMVRM basic extension
 71+  576C              ; copies from RAM to VRAM
 72+  576C              ; _MEMVRM ( INT source,
 73+  576C              ;			INT destination,
 74+  576C              ;			INT count,
 75+  576C              ;			BYTE wait_vsync) >0 = true
 76+  576C              ; will put ram in page 0 also, page 1 is already there
 77+  576C              ; wait_vsync will issue HALT before copying
 78+  576C              MEMVRM:
 79+  576C              	; opening (
 80+  576C CD 66 62     	CALL CHKCHAR
 81+  576F 28           	DB '('
 82+  5770              	; get source address
 83+  5770 DD 21 2F 54  	LD IX, FRMQNT
 84+  5774 CD 59 01     	CALL CALBAS
 85+  5777 D5           	PUSH DE
 86+  5778              	; comma
 87+  5778 CD 66 62     	CALL CHKCHAR
 88+  577B 2C           	DB ','
 89+  577C              	; get destination address
 90+  577C DD 21 2F 54  	LD IX, FRMQNT
 91+  5780 CD 59 01     	CALL CALBAS
 92+  5783 D5           	PUSH DE
 93+  5784              	; comma
 94+  5784 CD 66 62     	CALL CHKCHAR
 95+  5787 2C           	DB ','
 96+  5788              	; get length
 97+  5788 DD 21 2F 54  	LD IX, FRMQNT
 98+  578C CD 59 01     	CALL CALBAS
 99+  578F D5           	PUSH DE
100+  5790              	; comma
101+  5790 CD 66 62     	CALL CHKCHAR
102+  5793 2C           	DB ','
103+  5794              	; get vsync wait
104+  5794 DD 21 1C 52  	LD IX, GETBYT
105+  5798 CD 59 01     	CALL CALBAS
106+  579B F5           	PUSH AF
107+  579C              	; ending )
108+  579C CD 66 62     	CALL CHKCHAR
109+  579F 29           	DB ')'
110+  57A0
111+  57A0                  ; save position in BASIC text
112+  57A0 E5           	PUSH HL
113+  57A1 DD E1        	POP IX
114+  57A3
115+  57A3 F1           	POP AF ; wait vsync
116+  57A4 B7           	OR A
117+  57A5 28 03        	JR Z, .L1
118+  57A7 FB               EI
119+  57A8 76           	HALT
120+  57A9 F3           	DI
121+  57AA              .L1:
122+  57AA              	; pop LDIR parameters and store away for later
123+  57AA C1           	POP BC ; count
124+  57AB D1           	POP DE ; vram destination
125+  57AC E1           	POP HL ; ram source
126+  57AD D9           	EXX
127+  57AE FD 21 B5 57   	LD IY, .RET
128+  57B2 C3 19 62     	JP ENABLE_PAGE0
129+  57B5              .RET:
130+  57B5 FB           	EI
131+  57B6 D9           	EXX
132+  57B7 3E 01        	LD A,1
133+  57B9 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  57BC CD CC 57     	CALL .LDIRVM
135+  57BF AF           	XOR A
136+  57C0 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  57C3 D1               POP DE
138+  57C4 C1               POP BC
139+  57C5 CD 90 61         CALL RESTORE_PAGE_INFO
140+  57C8 DD E5        	PUSH IX
141+  57CA E1           	POP HL
142+  57CB C9           	RET
143+  57CC
144+  57CC              .LDIRVM:
145+  57CC EB           	EX DE, HL
146+  57CD F3           	DI
147+  57CE CD 40 61     	CALL SETWRT_LOCAL
148+  57D1 FB           	EI
149+  57D2 EB           	EX DE, HL
150+  57D3 78           	LD A, B
151+  57D4 B7           	OR A
152+  57D5 28 0D        	JR Z, .L3
153+  57D7 C5           	PUSH BC
154+  57D8 0E 98        	LD C, #98
155+  57DA              .L2:
156+  57DA 50           	LD D, B
157+  57DB 06 00        	LD B, 0
158+  57DD CD 4D 61     	CALL BBYTECOPY_NO_C
159+  57E0 42           	LD B, D
160+  57E1 10 F7        	DJNZ .L2
161+  57E3 C1           	POP BC
162+  57E4              .L3:
163+  57E4 79           	LD A, C
164+  57E5 B7           	OR A
165+  57E6 C8           	RET Z
166+  57E7 41           	LD B, C
167+  57E8 C3 4B 61     	JP BBYTECOPY
168+  57EB              ; *******************************************************************************************************
169+  57EB
170+  57EB              ; *******************************************************************************************************
171+  57EB              ; function to handle CALL VRMMEM basic extension
172+  57EB              ; copies from RAM to VRAM
173+  57EB              ; _VRMMEM ( INT source,
174+  57EB              ;			INT destination,
175+  57EB              ;			INT count
176+  57EB              ; will put ram in page 0 also, page 1 is already there
177+  57EB              VRMMEM:
178+  57EB              	; opening (
179+  57EB CD 66 62     	CALL CHKCHAR
180+  57EE 28           	DB '('
181+  57EF              	; get source address
182+  57EF DD 21 2F 54  	LD IX, FRMQNT
183+  57F3 CD 59 01     	CALL CALBAS
184+  57F6 D5           	PUSH DE
185+  57F7              	; comma
186+  57F7 CD 66 62     	CALL CHKCHAR
187+  57FA 2C           	DB ','
188+  57FB              	; get destination address
189+  57FB DD 21 2F 54  	LD IX, FRMQNT
190+  57FF CD 59 01     	CALL CALBAS
191+  5802 D5           	PUSH DE
192+  5803              	; comma
193+  5803 CD 66 62     	CALL CHKCHAR
194+  5806 2C           	DB ','
195+  5807              	; get length
196+  5807 DD 21 2F 54  	LD IX, FRMQNT
197+  580B CD 59 01     	CALL CALBAS
198+  580E D5           	PUSH DE
199+  580F              	; ending )
200+  580F CD 66 62     	CALL CHKCHAR
201+  5812 29           	DB ')'
202+  5813
203+  5813                  ; save position in BASIC text
204+  5813 E5           	PUSH HL
205+  5814 DD E1        	POP IX
206+  5816
207+  5816 C1           	POP BC ; count
208+  5817 D1           	POP DE ; destination
209+  5818 E1           	POP HL ; source
210+  5819 D9           	EXX
211+  581A FD 21 21 58  	LD IY, .RET
212+  581E C3 19 62     	JP ENABLE_PAGE0
213+  5821              .RET:
214+  5821 FB           	EI
215+  5822 D9           	EXX
216+  5823 3E 01        	LD A,1
217+  5825 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  5828 CD 38 58     	CALL .LDIRMV
219+  582B AF           	XOR A
220+  582C 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  582F D1               POP DE
222+  5830 C1               POP BC
223+  5831 CD 90 61         CALL RESTORE_PAGE_INFO
224+  5834 DD E5        	PUSH IX
225+  5836 E1           	POP HL
226+  5837 C9           	RET
227+  5838
228+  5838              .LDIRMV:
229+  5838              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  5838 7D           	LD	A, L
231+  5839 F3           	DI
232+  583A D3 99        	OUT	(099H), A
233+  583C 7C           	LD	A, H
234+  583D E6 3F        	AND	03FH
235+  583F D3 99        	OUT	(099H), A
236+  5841 FB           	EI
237+  5842              	;EX (SP), HL
238+  5842              	;EX (SP), HL
239+  5842              	;NOP
240+  5842              	;NOP
241+  5842              .L4:
242+  5842 DB 98            IN A, (#98)
243+  5844 12           	LD (DE), A
244+  5845 13               INC DE
245+  5846 0B               DEC BC
246+  5847 79               LD A, C
247+  5848 B0               OR B
248+  5849 20 F7            JR NZ, .L4
249+  584B C9               RET
250+  584C              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
137   584C               ENDIF
138   584C
139   584C               IF (GENCAL_CMD == 1)
140   584C               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  584C              ; *******************************************************************************************************
  2+  584C              ; function to handle CALL GENCAL basic extension
  3+  584C              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  584C              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  584C              ; output values of registers will also be stored at reg_list_ptr
  6+  584C              GENCAL_VAR_SP:
  7+  584C 00 00            DW 0
  8+  584E              GENCAL_VAR_SP2:
  9+  584E 00 00            DW 0
 10+  5850              GENCAL:
 11+  5850              	; opening (
 12+  5850 CD 66 62     	CALL CHKCHAR
 13+  5853 28           	DB '('
 14+  5854              	; get function address
 15+  5854 DD 21 2F 54  	LD IX, FRMQNT
 16+  5858 CD 59 01     	CALL CALBAS
 17+  585B D5           	PUSH DE
 18+  585C              	; comma
 19+  585C CD 66 62     	CALL CHKCHAR
 20+  585F 2C           	DB ','
 21+  5860              	; get pointer to register list
 22+  5860 3E 02            LD A,2
 23+  5862 06 01            LD B,1
 24+  5864 11 00 05         LD DE,#0500
 25+  5867 CD 91 62         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  586A C5           	PUSH BC
 27+  586B              	; ending )
 28+  586B CD 66 62     	CALL CHKCHAR
 29+  586E 29           	DB ')'
 30+  586F
 31+  586F              	; save BASIC token position
 32+  586F E5           	PUSH HL
 33+  5870 D9               EXX
 34+  5871 E1           	POP HL ; HL'=next basic token
 35+  5872 D9               EXX
 36+  5873
 37+  5873 E1               POP HL ; get pointer to register values
 38+  5874 F3           	DI
 39+  5875 ED 73 4C 58      LD (GENCAL_VAR_SP), SP
 40+  5879 F9               LD SP, HL
 41+  587A F1               POP AF
 42+  587B C1               POP BC
 43+  587C D1               POP DE
 44+  587D E1               POP HL
 45+  587E DD E1            POP IX
 46+  5880 FD E1            POP IY
 47+  5882 D9               EXX
 48+  5883 ED 73 4E 58      LD (GENCAL_VAR_SP2), SP
 49+  5887 ED 7B 4C 58      LD SP, (GENCAL_VAR_SP)
 50+  588B FB               EI
 51+  588C D1               POP DE ; get function to call
 52+  588D E5               PUSH HL
 53+  588E CD A9 58         CALL .EXXDECALL
 54+  5891 F3               DI
 55+  5892 ED 73 4C 58      LD (GENCAL_VAR_SP), SP
 56+  5896 ED 7B 4E 58      LD SP, (GENCAL_VAR_SP2)
 57+  589A FD E5            PUSH IY
 58+  589C DD E5            PUSH IX
 59+  589E E5               PUSH HL
 60+  589F D5               PUSH DE
 61+  58A0 C5               PUSH BC
 62+  58A1 F5               PUSH AF
 63+  58A2 ED 7B 4C 58      LD SP, (GENCAL_VAR_SP)
 64+  58A6 FB               EI
 65+  58A7 E1               POP HL
 66+  58A8 C9           	RET
 67+  58A9
 68+  58A9              .EXXDECALL:
 69+  58A9 D5               PUSH DE
 70+  58AA D9               EXX
 71+  58AB C9               RET
 72+  58AC              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
141   58AC               ENDIF
142   58AC
143   58AC               IF (BOX_CMDS == 1)
144   58AC               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  58AC              ; *******************************************************************************************************
  2+  58AC              ; generic function to implement rectangle data copy
  3+  58AC              ; should be modified to call appropriate function for memory or vram
  4+  58AC              ; input IX=pointer to following structure
  5+  58AC              ; +00 source data pointer
  6+  58AC              ; +02 num bytes in a row
  7+  58AC              ; +04 number of rows
  8+  58AC              ; +06 source add-to value till next row
  9+  58AC              ; +08 destination address
 10+  58AC              ; +10 destination add-to value till next row
 11+  58AC              ; modifies AF, BC, DE, HL
 12+  58AC              RECTANGLE_COPY:
 13+  58AC DD 6E 00     	LD L, (IX+0)
 14+  58AF DD 66 01     	LD H, (IX+1) ; source address
 15+  58B2 DD 5E 08     	LD E, (IX+8)
 16+  58B5 DD 56 09     	LD D, (IX+9) ; destination
 17+  58B8 DD 46 04     	LD B, (IX+4) ; row number
 18+  58BB              .L1:
 19+  58BB C5           	PUSH BC
 20+  58BC E5           		PUSH HL
 21+  58BD D5           			PUSH DE
 22+  58BE DD 4E 02     				LD C, (IX+2)
 23+  58C1 DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  58C4              .CALL1:
 25+  58C4 CD 00 00     				CALL 0 ; set destination address from DE
 26+  58C7              .CALL2:
 27+  58C7 CD 00 00     				CALL 0 ; copy data fn
 28+  58CA E1           			POP HL
 29+  58CB DD 4E 0A     			LD C, (IX+10)
 30+  58CE DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  58D1 09           			ADD HL, BC
 32+  58D2 EB           			EX DE, HL
 33+  58D3 E1           		POP HL
 34+  58D4 DD 4E 06     		LD C, (IX+6)
 35+  58D7 DD 46 07     		LD B, (IX+7) ; src add-to
 36+  58DA 09           		ADD HL, BC
 37+  58DB C1           	POP BC
 38+  58DC 10 DD        	DJNZ .L1
 39+  58DE C9           	RET
 40+  58DF              ; *******************************************************************************************************
 41+  58DF
 42+  58DF              ; *******************************************************************************************************
 43+  58DF              ; function to handle CALL BOXMEMCPY basic extension
 44+  58DF              ; copies data with window like boundaries within ram
 45+  58DF              ; BOXMEMCPY ( INT source data pointer,
 46+  58DF              ;			  INT source number of bytes in a row,
 47+  58DF              ;			  INT number of rows,
 48+  58DF              ;			  INT source add-to value till next row,
 49+  58DF              ; 			  INT destination pointer,
 50+  58DF              ;			  INT destination add-to value till next row )
 51+  58DF              ; request_data_ptr described in RECTANGLE_COPY
 52+  58DF              ; will put ram in page 0 also, page 1 is already there
 53+  58DF              BOXMEMCPY:
 54+  58DF 11 E9 58     	LD DE,BOXMEMCPY.RET
 55+  58E2 ED 53 5D 59  	LD (BOXCOMMON.ADDR+2), DE
 56+  58E6 C3 FC 58     	JP BOXCOMMON
 57+  58E9              .RET:
 58+  58E9 FB           	EI
 59+  58EA              	; set RAM functions to call
 60+  58EA 21 00 00     	LD HL, 0
 61+  58ED 22 C4 58     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 62+  58F0 22 C6 58     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 63+  58F3 21 ED B0     	LD HL, #B0ED ; LDIR
 64+  58F6 22 C8 58     	LD (RECTANGLE_COPY.CALL1+4), HL
 65+  58F9 C3 62 59     	JP BOXCOMMON.CALL
 66+  58FC              ; *******************************************************************************************************
 67+  58FC
 68+  58FC              ; *******************************************************************************************************
 69+  58FC              ; common parts of BOX commands
 70+  58FC              BOXCOMMON:
 71+  58FC              	; opening (
 72+  58FC CD 66 62     	CALL CHKCHAR
 73+  58FF 28           	DB '('
 74+  5900              	; get source data pointer
 75+  5900 DD 21 2F 54  	LD IX, FRMQNT
 76+  5904 CD 59 01     	CALL CALBAS
 77+  5907 ED 53 95 5F  	LD (BLIT_STRUCT+0), DE
 78+  590B              	; comma
 79+  590B CD 66 62     	CALL CHKCHAR
 80+  590E 2C           	DB ','
 81+  590F              	; source number of bytes in a row
 82+  590F DD 21 2F 54  	LD IX, FRMQNT
 83+  5913 CD 59 01     	CALL CALBAS
 84+  5916 ED 53 97 5F  	LD (BLIT_STRUCT+2), DE
 85+  591A              	; comma
 86+  591A CD 66 62     	CALL CHKCHAR
 87+  591D 2C           	DB ','
 88+  591E              	; number of rows
 89+  591E DD 21 2F 54  	LD IX, FRMQNT
 90+  5922 CD 59 01     	CALL CALBAS
 91+  5925 ED 53 99 5F  	LD (BLIT_STRUCT+4), DE
 92+  5929              	; comma
 93+  5929 CD 66 62     	CALL CHKCHAR
 94+  592C 2C           	DB ','
 95+  592D              	; source add-to value till next row
 96+  592D DD 21 2F 54  	LD IX, FRMQNT
 97+  5931 CD 59 01     	CALL CALBAS
 98+  5934 ED 53 9B 5F  	LD (BLIT_STRUCT+6), DE
 99+  5938              	; comma
100+  5938 CD 66 62     	CALL CHKCHAR
101+  593B 2C           	DB ','
102+  593C              	; destination pointer
103+  593C DD 21 2F 54  	LD IX, FRMQNT
104+  5940 CD 59 01     	CALL CALBAS
105+  5943 ED 53 9D 5F  	LD (BLIT_STRUCT+8), DE
106+  5947              	; comma
107+  5947 CD 66 62     	CALL CHKCHAR
108+  594A 2C           	DB ','
109+  594B              	; destination add-to value till next row
110+  594B DD 21 2F 54  	LD IX, FRMQNT
111+  594F CD 59 01     	CALL CALBAS
112+  5952 ED 53 9F 5F  	LD (BLIT_STRUCT+10), DE
113+  5956              	; ending )
114+  5956 CD 66 62     	CALL CHKCHAR
115+  5959 29           	DB ')'
116+  595A
117+  595A E5           	PUSH HL ; save position in BASIC buffer
118+  595B              .ADDR:
119+  595B FD 21 00 00  	LD IY, 0
120+  595F C3 19 62     	JP ENABLE_PAGE0
121+  5962              .CALL:
122+  5962 DD 21 95 5F  	LD IX,BLIT_STRUCT
123+  5966 CD AC 58     	CALL RECTANGLE_COPY
124+  5969 AF           	XOR A
125+  596A 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
126+  596D
127+  596D D1               POP DE
128+  596E C1               POP BC
129+  596F CD 90 61         CALL RESTORE_PAGE_INFO
130+  5972
131+  5972 E1           	POP HL
132+  5973 C9           	RET
133+  5974              ; *******************************************************************************************************
134+  5974
135+  5974              ; *******************************************************************************************************
136+  5974              ; function to handle CALL BOXMEMVRM basic extension
137+  5974              ; copies data with window like boundaries from ram to Vram
138+  5974              ; BOXMEMVRM ( INT source data pointer,
139+  5974              ;			  INT source number of bytes in a row,
140+  5974              ;			  INT number of rows,
141+  5974              ;			  INT source add-to value till next row,
142+  5974              ; 			  INT destination pointer,
143+  5974              ;			  INT destination add-to value till next row )
144+  5974              ; request_data_ptr described in RECTANGLE_COPY
145+  5974              ; will put ram in page 0 also, page 1 is already there
146+  5974              BOXMEMVRM:
147+  5974 11 7E 59     	LD DE,BOXMEMVRM.RET
148+  5977 ED 53 5D 59  	LD (BOXCOMMON.ADDR+2), DE
149+  597B C3 FC 58     	JP BOXCOMMON
150+  597E              .RET:
151+  597E FB           	EI
152+  597F              	; set RAM functions to call
153+  597F 21 99 59     	LD HL, .SETDEST
154+  5982 22 C5 58     	LD (RECTANGLE_COPY.CALL1+1), HL
155+  5985 21 A1 59     	LD HL, .COPYDATA
156+  5988 22 C8 58     	LD (RECTANGLE_COPY.CALL2+1), HL
157+  598B 3E CD        	LD A, #CD ; CALL
158+  598D 32 C4 58     	LD (RECTANGLE_COPY.CALL1), A
159+  5990 32 C7 58     	LD (RECTANGLE_COPY.CALL2), A
160+  5993              	;LD A,1
161+  5993 32 A6 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
162+  5996 C3 62 59     	JP BOXCOMMON.CALL
163+  5999              .SETDEST:
164+  5999 EB           	EX DE, HL
165+  599A F3           	DI
166+  599B CD 40 61     	CALL SETWRT_LOCAL
167+  599E FB           	EI
168+  599F EB           	EX DE, HL
169+  59A0 C9           	RET
170+  59A1              .COPYDATA:
171+  59A1 41           	LD B, C
172+  59A2 C3 4B 61     	JP BBYTECOPY
173+  59A5              ; *******************************************************************************************************
# file closed: asm\BOX.asm
145   59A5               ENDIF
146   59A5
147   59A5               IF (BLIT_CMDS == 1)
148   59A5               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  59A5              ; *******************************************************************************************************
  2+  59A5              ; function rotates mask and data of several characters and applies to background data
  3+  59A5              ; this handles x-shift from 0 to 4
  4+  59A5              ; contains self-modifying code that is set-up from external function
  5+  59A5              ; input HL=pointer to mask data
  6+  59A5              ; input HL'=pointer to character data
  7+  59A5              ; input DE=output buffer containing background data
  8+  59A5              ; input BC=DE+8
  9+  59A5              ; input A=number of characters to process
 10+  59A5              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  59A5              SHIFT04:
 12+  59A5 08           	EX AF, AF'
 13+  59A6 7E           	LD A, (HL) ; get mask
 14+  59A7 D9           	EXX
 15+  59A8 57           	LD D, A
 16+  59A9 1E FF        	LD E, #FF
 17+  59AB 37           	SCF
 18+  59AC              .M1:
 19+  59AC 18 FE        	JR .M1 ; this is self-modifying part
 20+  59AE CB 1A        	RR D
 21+  59B0 CB 1B        	RR E
 22+  59B2 CB 1A        	RR D
 23+  59B4 CB 1B        	RR E
 24+  59B6 CB 1A        	RR D
 25+  59B8 CB 1B        	RR E
 26+  59BA CB 1A        	RR D
 27+  59BC CB 1B        	RR E
 28+  59BE
 29+  59BE 46           	LD B, (HL) ; get data
 30+  59BF 0E 00        	LD C, 0
 31+  59C1              .M2:
 32+  59C1 18 FE        	JR .M2 ; also self-modifying part
 33+  59C3 CB 38        	SRL B
 34+  59C5 CB 19        	RR C
 35+  59C7 CB 38        	SRL B
 36+  59C9 CB 19        	RR C
 37+  59CB CB 38        	SRL B
 38+  59CD CB 19        	RR C
 39+  59CF CB 38        	SRL B
 40+  59D1 CB 19        	RR C
 41+  59D3
 42+  59D3 D9           	EXX
 43+  59D4 1A           	LD A, (DE) ; background
 44+  59D5 D9           	EXX
 45+  59D6 A2           	AND D
 46+  59D7 B0           	OR B
 47+  59D8 D9           	EXX
 48+  59D9 12           	LD (DE), A
 49+  59DA
 50+  59DA 0A           	LD A, (BC)
 51+  59DB D9           	EXX
 52+  59DC A3           	AND E
 53+  59DD B1           	OR C
 54+  59DE 23           	INC HL
 55+  59DF D9           	EXX
 56+  59E0 02           	LD (BC), A
 57+  59E1
 58+  59E1 23           	INC HL
 59+  59E2 13           	INC DE
 60+  59E3 03           	INC BC
 61+  59E4
 62+  59E4 08           	EX AF, AF'
 63+  59E5 3D           	DEC A
 64+  59E6 C2 A5 59     	JP NZ, SHIFT04
 65+  59E9 C9           	RET
 66+  59EA              ; *******************************************************************************************************
 67+  59EA
 68+  59EA              ; *******************************************************************************************************
 69+  59EA              ; function rotates mask and data of several characters and applies to background data
 70+  59EA              ; this handles x-shift from 5 to 8
 71+  59EA              ; contains self-modifying code that is set-up from external function
 72+  59EA              ; input HL=pointer to mask data
 73+  59EA              ; input HL'=pointer to character data
 74+  59EA              ; input DE=output buffer containing background data
 75+  59EA              ; input BC=DE+8
 76+  59EA              ; input A=number of characters to process
 77+  59EA              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  59EA              SHIFT58:
 79+  59EA 08           	EX AF, AF'
 80+  59EB 7E           	LD A, (HL) ; get mask
 81+  59EC D9           	EXX
 82+  59ED 57           	LD D, A
 83+  59EE 1E FF        	LD E, #FF
 84+  59F0 37           	SCF
 85+  59F1              .M1:
 86+  59F1 18 FE        	JR .M1 ; this is self-modifying part
 87+  59F3 CB 12        	RL D
 88+  59F5 CB 13        	RL E
 89+  59F7 CB 12        	RL D
 90+  59F9 CB 13        	RL E
 91+  59FB CB 12        	RL D
 92+  59FD CB 13        	RL E
 93+  59FF
 94+  59FF 46           	LD B, (HL)
 95+  5A00 0E 00        	LD C, 0
 96+  5A02              .M2:
 97+  5A02 18 FE        	JR .M2 ; also self-modifying part
 98+  5A04 CB 20        	SLA B
 99+  5A06 CB 11        	RL C
100+  5A08 CB 20        	SLA B
101+  5A0A CB 11        	RL C
102+  5A0C CB 20        	SLA B
103+  5A0E CB 11        	RL C
104+  5A10
105+  5A10 D9           	EXX
106+  5A11 1A           	LD A, (DE) ; background
107+  5A12 D9           	EXX
108+  5A13 A3           	AND E
109+  5A14 B1           	OR C
110+  5A15 D9           	EXX
111+  5A16 12           	LD (DE), A
112+  5A17
113+  5A17 0A           	LD A, (BC)
114+  5A18 D9           	EXX
115+  5A19 A2           	AND D
116+  5A1A B0           	OR B
117+  5A1B 23           	INC HL
118+  5A1C D9           	EXX
119+  5A1D 02           	LD (BC), A
120+  5A1E
121+  5A1E 23           	INC HL
122+  5A1F 13           	INC DE
123+  5A20 03           	INC BC
124+  5A21
125+  5A21 08           	EX AF, AF'
126+  5A22 3D           	DEC A
127+  5A23 C2 EA 59     	JP NZ, SHIFT58
128+  5A26 C9           	RET
129+  5A27              ; *******************************************************************************************************
130+  5A27
131+  5A27              ; *******************************************************************************************************
132+  5A27              ; routine that shifts one row of characters
133+  5A27              ; contains self-modifying code that is set-up from external function
134+  5A27              ; input HL=pointer to mask data
135+  5A27              ; input HL'=pointer to character data
136+  5A27              ; input DE=output buffer containing background data
137+  5A27              ; input A=number of characters to process
138+  5A27              ; input IX=pointer to structure describing input data
139+  5A27              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  5A27              SHIFT_ROW:
141+  5A27 F5           	PUSH AF
142+  5A28 ED 53 91 5F  		LD (BLIT_TMP1), DE
143+  5A2C E5           		PUSH HL
144+  5A2D CD 70 5A     			CALL .ADDYSHIFT
145+  5A30 E1           		POP HL
146+  5A31 ED 53 93 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  5A35              .L1:
148+  5A35 3E 08        		LD A, 8
149+  5A37 DD 96 02     		SUB (IX+2) ; y shift
150+  5A3A              .CALL1:
151+  5A3A CD 00 00     		CALL 0
152+  5A3D DD 7E 02     		LD A, (IX+2); y shift
153+  5A40 B7           		OR A
154+  5A41 28 26        		JR Z, .DONE
155+  5A43 ED 5B 91 5F  		LD DE, (BLIT_TMP1)
156+  5A47 E5           		PUSH HL
157+  5A48 CD 7E 5A     			CALL .DETONEXTROW
158+  5A4B E1           		POP HL
159+  5A4C              .CALL2:
160+  5A4C CD 00 00     		CALL 0
161+  5A4F ED 5B 91 5F  		LD DE, (BLIT_TMP1)
162+  5A53 E5           		PUSH HL
163+  5A54 CD 78 5A     			CALL .ADD8
164+  5A57 E1           		POP HL
165+  5A58 ED 53 91 5F  		LD (BLIT_TMP1), DE
166+  5A5C ED 5B 93 5F  		LD DE, (BLIT_TMP2)
167+  5A60 E5           		PUSH HL
168+  5A61 CD 78 5A     			CALL .ADD8
169+  5A64 E1           		POP HL
170+  5A65 ED 53 93 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  5A69              .DONE:
172+  5A69 F1           	POP AF
173+  5A6A 3D           	DEC A
174+  5A6B C8           	RET Z
175+  5A6C F5           	PUSH AF
176+  5A6D C3 35 5A     	JP .L1
177+  5A70              .ADDYSHIFT:
178+  5A70 EB           	EX DE, HL
179+  5A71 16 00        	LD D, 0
180+  5A73 DD 5E 02     	LD E, (IX+2); y shift
181+  5A76 18 0C        	JR .MOVDEBC
182+  5A78              .ADD8:
183+  5A78 21 08 00     	LD HL, 8
184+  5A7B C3 84 5A     	JP .MOVDEBC
185+  5A7E              .DETONEXTROW:
186+  5A7E DD 6E 06     	LD L, (IX+6)
187+  5A81 DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5A84              .MOVDEBC:
189+  5A84 19           	ADD HL, DE
190+  5A85 54           	LD D, H
191+  5A86 5D           	LD E, L
192+  5A87 01 08 00     	LD BC, 8
193+  5A8A 09           	ADD HL, BC
194+  5A8B 44           	LD B, H
195+  5A8C 4D           	LD C, L
196+  5A8D C9           	RET
197+  5A8E              ; *******************************************************************************************************
198+  5A8E
199+  5A8E              ; *******************************************************************************************************
200+  5A8E              ; function rotates mask and character data and applies it to background
201+  5A8E              ; input IX=pointer to structure describing input data
202+  5A8E              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  5A8E              ; +2  DW vertical shift count 0-7 (low byte used)
204+  5A8E              ; +4  DW background data start;
205+  5A8E              ; +6  DW background add to value to next row of background data
206+  5A8E              ; +8  DW mask data start;
207+  5A8E              ; +10  DW character data start;
208+  5A8E              ; +12 DW character&mask add to value to next row of data
209+  5A8E              ; +14 DW columns (low byte used)
210+  5A8E              ; +16 DW rows (low byte used)
211+  5A8E              SHIFT_MERGE_CHARACTER:
212+  5A8E DD 7E 00     	LD A, (IX) ; shift
213+  5A91 FE 05        	CP 5
214+  5A93 38 25        	JR C, .RIGHT
215+  5A95              	; shifts 5-7, use rotate towards left 1-3
216+  5A95 21 EA 59     	LD HL, SHIFT58
217+  5A98 22 3B 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  5A9B 22 4D 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  5A9E D6 05        	SUB 5
220+  5AA0 28 0D        	JR Z, .L1
221+  5AA2 87           	ADD A, A
222+  5AA3 87           	ADD A, A
223+  5AA4 67           	LD H, A
224+  5AA5 2E 18        	LD L, #18 ; JR opcode
225+  5AA7 22 F1 59     	LD (SHIFT58.M1), HL
226+  5AAA 22 02 5A     	LD (SHIFT58.M2), HL
227+  5AAD 18 32        	JR .DO
228+  5AAF              .L1:
229+  5AAF 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  5AB2 22 F1 59     	LD (SHIFT58.M1), HL
231+  5AB5 22 02 5A     	LD (SHIFT58.M2), HL
232+  5AB8 18 27        	JR .DO
233+  5ABA              .RIGHT:
234+  5ABA              	; shifts 0-4, rotate towards right
235+  5ABA 21 A5 59     	LD HL, SHIFT04
236+  5ABD 22 3B 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  5AC0 22 4D 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  5AC3 FE 04        	CP 4
239+  5AC5 28 11        	JR Z, .R1
240+  5AC7 D6 04        	SUB 4
241+  5AC9 ED 44        	NEG
242+  5ACB 87           	ADD A, A
243+  5ACC 87           	ADD A, A
244+  5ACD 67           	LD H, A
245+  5ACE 2E 18        	LD L, #18 ; JR opcode
246+  5AD0 22 AC 59     	LD (SHIFT04.M1), HL
247+  5AD3 22 C1 59     	LD (SHIFT04.M2), HL
248+  5AD6 18 09        	JR .DO
249+  5AD8              .R1:
250+  5AD8 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  5ADB 22 AC 59     	LD (SHIFT04.M1), HL
252+  5ADE 22 C1 59     	LD (SHIFT04.M2), HL
253+  5AE1              .DO:
254+  5AE1 DD 46 10     	LD B, (IX+16) ; rows
255+  5AE4 DD 6E 08     	LD L, (IX+8)
256+  5AE7 DD 66 09     	LD H, (IX+9) ; mask data
257+  5AEA DD 5E 04     	LD E, (IX+4)
258+  5AED DD 56 05     	LD D, (IX+5) ; background data
259+  5AF0 D9           	EXX
260+  5AF1 DD 6E 0A     	LD L, (IX+10)
261+  5AF4 DD 66 0B     	LD H, (IX+11) ; character data
262+  5AF7 D9           	EXX
263+  5AF8              .LOOP:
264+  5AF8 C5           	PUSH BC
265+  5AF9 E5           		PUSH HL
266+  5AFA D5           			PUSH DE
267+  5AFB D9           				EXX
268+  5AFC E5           				PUSH HL
269+  5AFD D9           					EXX
270+  5AFE DD 7E 0E     					LD A, (IX+14) ; columns
271+  5B01              .CALL:
272+  5B01 CD 27 5A     					CALL SHIFT_ROW
273+  5B04 E1           				POP HL
274+  5B05 DD 5E 0C     				LD E, (IX+12)
275+  5B08 DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  5B0B 19           				ADD HL, DE
277+  5B0C D9           				EXX
278+  5B0D E1           			POP HL
279+  5B0E DD 5E 06     			LD E, (IX+6)
280+  5B11 DD 56 07     			LD D, (IX+7) ; background to next row
281+  5B14 19           			ADD HL, DE
282+  5B15 EB           			EX DE, HL
283+  5B16 E1           		POP HL
284+  5B17 DD 4E 0C     		LD C, (IX+12)
285+  5B1A DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  5B1D 09           		ADD HL, BC
287+  5B1E C1           	POP BC
288+  5B1F 10 D7        	DJNZ .LOOP
289+  5B21 C9           	RET
290+  5B22              ; *******************************************************************************************************
291+  5B22
292+  5B22               IFNDEF CMDS_WITH_PARAMETERS
293+  5B22 ~            ; *******************************************************************************************************
294+  5B22 ~            ; function to handle CALL BLIT basic extension
295+  5B22 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  5B22 ~            ; fuses with background data and applies vertical shift too
297+  5B22 ~            ; BLIT ( INT request_data_ptr )
298+  5B22 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  5B22 ~            ; will put ram in page 0 also, page 1 is already there
300+  5B22 ~            BLIT:
301+  5B22 ~            	; opening (
302+  5B22 ~            	CALL CHKCHAR
303+  5B22 ~            	DB '('
304+  5B22 ~            	; get pointer to request struct
305+  5B22 ~            	LD IX, FRMQNT
306+  5B22 ~            	CALL CALBAS
307+  5B22 ~            	PUSH DE
308+  5B22 ~            	; ending )
309+  5B22 ~            	CALL CHKCHAR
310+  5B22 ~            	DB ')'
311+  5B22 ~
312+  5B22 ~            	POP IX ; pointer to request struct
313+  5B22 ~
314+  5B22 ~            	PUSH HL ; save position in BASIC buffer
315+  5B22 ~
316+  5B22 ~            	LD IY, .RET
317+  5B22 ~            	JP ENABLE_PAGE0
318+  5B22 ~            .RET:
319+  5B22 ~            	EI
320+  5B22 ~            	CALL SHIFT_MERGE_CHARACTER
321+  5B22 ~
322+  5B22 ~                POP DE
323+  5B22 ~                POP BC
324+  5B22 ~                CALL RESTORE_PAGE_INFO
325+  5B22 ~
326+  5B22 ~            	POP HL
327+  5B22 ~            	RET
328+  5B22 ~            ; *******************************************************************************************************
329+  5B22               ENDIF
330+  5B22
331+  5B22               IFDEF CMDS_WITH_PARAMETERS
332+  5B22              ; *******************************************************************************************************
333+  5B22              ; function to handle CALL BLIT basic extension
334+  5B22              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  5B22              ; fuses with background data and applies vertical shift too
336+  5B22              ; in form without pointers
337+  5B22              ; BLIT ( INT x,
338+  5B22              ;		 INT y,
339+  5B22              ;		 INT char_data_pointer,
340+  5B22              ;		 INT mask_data_pointer,
341+  5B22              ;		 INT width (in characters),
342+  5B22              ;		 INT height (in characters),
343+  5B22              ;		 INT background_pointer (top left),
344+  5B22              ;		 INT background_width (in characters),
345+  5B22              ;		 INT background_height (in characters))
346+  5B22              ; will put ram in page 0 also, page 1 is already there
347+  5B22              BLIT:
348+  5B22              	; opening (
349+  5B22 CD 66 62     	CALL CHKCHAR
350+  5B25 28           	DB '('
351+  5B26              	; get x coordinate
352+  5B26 DD 21 2F 54  	LD IX, FRMQNT
353+  5B2A CD 59 01     	CALL CALBAS
354+  5B2D 7B           	LD A, E
355+  5B2E E6 07        	AND 7
356+  5B30 32 95 5F     	LD (BLIT_STRUCT+0), A
357+  5B33 CD 10 5C     	CALL .DAdiv8
358+  5B36 32 91 5F     	LD (BLIT_TMP+0),A
359+  5B39              	; comma
360+  5B39 CD 66 62     	CALL CHKCHAR
361+  5B3C 2C           	DB ','
362+  5B3D              	; get y coordinate
363+  5B3D DD 21 2F 54  	LD IX, FRMQNT
364+  5B41 CD 59 01     	CALL CALBAS
365+  5B44 7B           	LD A, E
366+  5B45 E6 07        	AND 7
367+  5B47 32 97 5F     	LD (BLIT_STRUCT+2), A
368+  5B4A CD 10 5C     	CALL .DAdiv8
369+  5B4D 32 92 5F     	LD (BLIT_TMP+1),A
370+  5B50              	; comma
371+  5B50 CD 66 62     	CALL CHKCHAR
372+  5B53 2C           	DB ','
373+  5B54              	; get char data pointer
374+  5B54 DD 21 2F 54  	LD IX, FRMQNT
375+  5B58 CD 59 01     	CALL CALBAS
376+  5B5B ED 53 9F 5F  	LD (BLIT_STRUCT+10), DE
377+  5B5F              	; comma
378+  5B5F CD 66 62     	CALL CHKCHAR
379+  5B62 2C           	DB ','
380+  5B63              	; get mask data pointer
381+  5B63 DD 21 2F 54  	LD IX, FRMQNT
382+  5B67 CD 59 01     	CALL CALBAS
383+  5B6A ED 53 9D 5F  	LD (BLIT_STRUCT+8), DE
384+  5B6E              	; comma
385+  5B6E CD 66 62     	CALL CHKCHAR
386+  5B71 2C           	DB ','
387+  5B72              	; get width
388+  5B72 DD 21 2F 54  	LD IX, FRMQNT
389+  5B76 CD 59 01     	CALL CALBAS
390+  5B79 7B           	LD A, E
391+  5B7A 32 A3 5F     	LD (BLIT_STRUCT+14), A
392+  5B7D              	; comma
393+  5B7D CD 66 62     	CALL CHKCHAR
394+  5B80 2C           	DB ','
395+  5B81              	; get height
396+  5B81 DD 21 2F 54  	LD IX, FRMQNT
397+  5B85 CD 59 01     	CALL CALBAS
398+  5B88 7B           	LD A, E
399+  5B89 32 A5 5F     	LD (BLIT_STRUCT+16), A
400+  5B8C              	; comma
401+  5B8C CD 66 62     	CALL CHKCHAR
402+  5B8F 2C           	DB ','
403+  5B90              	; get background pointer
404+  5B90 DD 21 2F 54  	LD IX, FRMQNT
405+  5B94 CD 59 01     	CALL CALBAS
406+  5B97 ED 53 99 5F  	LD (BLIT_STRUCT+4), DE
407+  5B9B              	; comma
408+  5B9B CD 66 62     	CALL CHKCHAR
409+  5B9E 2C           	DB ','
410+  5B9F              	; get background width
411+  5B9F DD 21 2F 54  	LD IX, FRMQNT
412+  5BA3 CD 59 01     	CALL CALBAS
413+  5BA6 7B           	LD A, E
414+  5BA7 32 93 5F     	LD (BLIT_TMP+2), A
415+  5BAA              	; comma
416+  5BAA CD 66 62     	CALL CHKCHAR
417+  5BAD 2C           	DB ','
418+  5BAE              	; get background height
419+  5BAE DD 21 2F 54  	LD IX, FRMQNT
420+  5BB2 CD 59 01     	CALL CALBAS
421+  5BB5 7B           	LD A, E
422+  5BB6 32 94 5F     	LD (BLIT_TMP+3), A
423+  5BB9              	; ending )
424+  5BB9 CD 66 62     	CALL CHKCHAR
425+  5BBC 29           	DB ')'
426+  5BBD
427+  5BBD E5           	PUSH HL ; save position in BASIC buffer
428+  5BBE
429+  5BBE              	; calculate char&mask add to value
430+  5BBE 26 00        	LD H, 0
431+  5BC0 3A A3 5F     	LD A, (BLIT_STRUCT+14)
432+  5BC3 6F           	LD L, A
433+  5BC4 CD 55 61     	CALL HLx8
434+  5BC7 22 A1 5F     	LD (BLIT_STRUCT+12), HL
435+  5BCA              	; calculate background add to value
436+  5BCA 26 00        	LD H, 0
437+  5BCC 3A 93 5F     	LD A, (BLIT_TMP+2)
438+  5BCF 6F           	LD L, A
439+  5BD0 CD 55 61     	CALL HLx8
440+  5BD3 22 9B 5F     	LD (BLIT_STRUCT+6), HL
441+  5BD6              	; calculate pointer to background location
442+  5BD6 21 00 00     	LD HL, 0
443+  5BD9 3A 92 5F     	LD A,(BLIT_TMP+1)
444+  5BDC B7           	OR A
445+  5BDD 28 08        	JR Z, .L1
446+  5BDF 47           	LD B,A
447+  5BE0 ED 5B 9B 5F  	LD DE,(BLIT_STRUCT+6)
448+  5BE4              .L0:
449+  5BE4 19           	ADD HL, DE
450+  5BE5 10 FD        	DJNZ .L0
451+  5BE7              .L1:
452+  5BE7 EB           	EX DE,HL
453+  5BE8 26 00        	LD H,0
454+  5BEA 3A 91 5F     	LD A,(BLIT_TMP+0)
455+  5BED 6F           	LD L,A
456+  5BEE CD 55 61     	CALL HLx8
457+  5BF1 19           	ADD HL,DE
458+  5BF2 ED 5B 99 5F  	LD DE,(BLIT_STRUCT+4)
459+  5BF6 19           	ADD HL,DE
460+  5BF7 22 99 5F     	LD (BLIT_STRUCT+4),HL
461+  5BFA
462+  5BFA FD 21 01 5C  	LD IY, .RET
463+  5BFE C3 19 62     	JP ENABLE_PAGE0
464+  5C01              .RET:
465+  5C01 FB           	EI
466+  5C02 DD 21 95 5F  	LD IX, BLIT_STRUCT
467+  5C06 CD 8E 5A     	CALL SHIFT_MERGE_CHARACTER
468+  5C09
469+  5C09 D1               POP DE
470+  5C0A C1               POP BC
471+  5C0B CD 90 61         CALL RESTORE_PAGE_INFO
472+  5C0E
473+  5C0E E1           	POP HL
474+  5C0F C9           	RET
475+  5C10              .DAdiv8:
476+  5C10 7B           	LD A,E
477+  5C11 CB 2A        	SRA D
478+  5C13 CB 1F            RR  A
479+  5C15 CB 2A            SRA D
480+  5C17 CB 1F            RR  A
481+  5C19 CB 2A            SRA D
482+  5C1B CB 1F            RR  A
483+  5C1D C9           	RET
484+  5C1E              ; *******************************************************************************************************
485+  5C1E               ENDIF
# file closed: asm\BLIT.asm
149   5C1E               ENDIF
150   5C1E
151   5C1E               IF (TILE_CMDS == 1)
152   5C1E               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5C1E              ; *******************************************************************************************************
  2+  5C1E              ; generic function to implement tiling
  3+  5C1E              ; should be modified to call appropriate function for memory or vram
  4+  5C1E              ; input IX=pointer to following structure
  5+  5C1E              ; +00 tile_data_ptr
  6+  5C1E              ; +02 tile_rows
  7+  5C1E              ; +04 tile_columns
  8+  5C1E              ; +06 destination_address
  9+  5C1E              ; +08 dest_to_next_row_add_to_value
 10+  5C1E              ; +10 num_horizontal_tiles
 11+  5C1E              ; +12 num_vertical_tiles
 12+  5C1E              ; modifies AF, BC, DE, HL
 13+  5C1E              TILE:
 14+  5C1E DD 6E 06     	LD L, (IX+6)
 15+  5C21 DD 66 07     	LD H, (IX+7) ; destination address
 16+  5C24 22 91 5F     	LD (TILETMP1), HL
 17+  5C27 DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5C2A              .L1:
 19+  5C2A C5           	PUSH BC
 20+  5C2B DD 6E 00     		LD L, (IX+0)
 21+  5C2E DD 66 01     		LD H, (IX+1) ; tile address
 22+  5C31 22 93 5F     		LD (TILETMP2), HL
 23+  5C34 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5C37              .L2:
 25+  5C37 C5           		PUSH BC
 26+  5C38 CD 00 00     .CALL1:		CALL 0
 27+  5C3B DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5C3E              .L3:
 29+  5C3E C5           			PUSH BC
 30+  5C3F 2A 93 5F     				LD HL, (TILETMP2)
 31+  5C42 DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5C45              .L4:
 33+  5C45 C5           				PUSH BC
 34+  5C46              .CALL2:
 35+  5C46 CD 00 00     					CALL 0
 36+  5C49 C1           				POP BC
 37+  5C4A 10 F9        				DJNZ .L4
 38+  5C4C C1           			POP BC
 39+  5C4D 10 EF        			DJNZ .L3
 40+  5C4F 22 93 5F     			LD (TILETMP2), HL
 41+  5C52 2A 91 5F     			LD HL, (TILETMP1)
 42+  5C55 DD 5E 08     			LD E, (IX+8)
 43+  5C58 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5C5B 19           			ADD HL, DE
 45+  5C5C 22 91 5F     			LD (TILETMP1), HL
 46+  5C5F C1           		POP BC
 47+  5C60 10 D5        		DJNZ .L2
 48+  5C62 C1           	POP BC
 49+  5C63 10 C5        	DJNZ .L1
 50+  5C65 C9           	RET
 51+  5C66              ; *******************************************************************************************************
 52+  5C66
 53+  5C66               IFNDEF CMDS_WITH_PARAMETERS
 54+  5C66 ~            ; *******************************************************************************************************
 55+  5C66 ~            ; function to handle CALL TILERAM basic extension
 56+  5C66 ~            ; fills memory with tiles
 57+  5C66 ~            ; TILERAM ( INT request_data_ptr )
 58+  5C66 ~            ; request_data_ptr described in TILE
 59+  5C66 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5C66 ~            TILERAM:
 61+  5C66 ~            	; opening (
 62+  5C66 ~            	CALL CHKCHAR
 63+  5C66 ~            	DB '('
 64+  5C66 ~            	; get pointer to request struct
 65+  5C66 ~            	LD IX, FRMQNT
 66+  5C66 ~            	CALL CALBAS
 67+  5C66 ~            	PUSH DE
 68+  5C66 ~            	; ending )
 69+  5C66 ~            	CALL CHKCHAR
 70+  5C66 ~            	DB ')'
 71+  5C66 ~
 72+  5C66 ~            	POP IX ; pointer to request struct
 73+  5C66 ~
 74+  5C66 ~            	PUSH HL ; save position in BASIC buffer
 75+  5C66 ~
 76+  5C66 ~            	LD IY, .RET
 77+  5C66 ~            	JP ENABLE_PAGE0
 78+  5C66 ~            .RET:
 79+  5C66 ~            	EI
 80+  5C66 ~            	; set RAM functions to call
 81+  5C66 ~            	LD HL, .TILECOPY
 82+  5C66 ~            	LD (TILE.CALL2+1), HL
 83+  5C66 ~            	LD HL, .SETDESTROW
 84+  5C66 ~            	LD (TILE.CALL1+1), HL
 85+  5C66 ~            	LD A,1
 86+  5C66 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5C66 ~            	CALL TILE
 88+  5C66 ~            	XOR A
 89+  5C66 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5C66 ~
 91+  5C66 ~                POP DE
 92+  5C66 ~                POP BC
 93+  5C66 ~                CALL RESTORE_PAGE_INFO
 94+  5C66 ~
 95+  5C66 ~            	POP HL
 96+  5C66 ~            	RET
 97+  5C66 ~            .TILECOPY:
 98+  5C66 ~            	.8 LDI
 99+  5C66 ~            	RET
100+  5C66 ~            .SETDESTROW:
101+  5C66 ~            	LD DE, (TILETMP1)
102+  5C66 ~            	RET
103+  5C66 ~            ; *******************************************************************************************************
104+  5C66               ENDIF
105+  5C66
106+  5C66               IFDEF CMDS_WITH_PARAMETERS
107+  5C66              ; *******************************************************************************************************
108+  5C66              ; function to handle CALL TILERAM basic extension
109+  5C66              ; fills memory with tiles
110+  5C66              ; TILERAM ( INT tile_data_pointer,
111+  5C66              ;			INT tile_columns,
112+  5C66              ;			INT tile_rows,
113+  5C66              ;			INT destination_pointer,
114+  5C66              ;			INT destination_columns,
115+  5C66              ;			INT destination_rows,
116+  5C66              ;			INT destination_begin_column,
117+  5C66              ;			INT destination_begin_row,
118+  5C66              ;			INT number_of_tiles_horizontally,
119+  5C66              ;			INT	number_of_tiles_vertically )
120+  5C66              ; will put ram in page 0 also, page 1 is already there
121+  5C66              TILERAM:
122+  5C66              	; opening (
123+  5C66 CD 66 62     	CALL CHKCHAR
124+  5C69 28           	DB '('
125+  5C6A              	; get tile data pointer coordinate
126+  5C6A DD 21 2F 54  	LD IX, FRMQNT
127+  5C6E CD 59 01     	CALL CALBAS
128+  5C71 ED 53 95 5F  	LD (BLIT_STRUCT+0), DE
129+  5C75              	; comma
130+  5C75 CD 66 62     	CALL CHKCHAR
131+  5C78 2C           	DB ','
132+  5C79              	; get tile columns
133+  5C79 DD 21 2F 54  	LD IX, FRMQNT
134+  5C7D CD 59 01     	CALL CALBAS
135+  5C80 ED 53 99 5F  	LD (BLIT_STRUCT+4), DE
136+  5C84              	; comma
137+  5C84 CD 66 62     	CALL CHKCHAR
138+  5C87 2C           	DB ','
139+  5C88              	; get tile columns
140+  5C88 DD 21 2F 54  	LD IX, FRMQNT
141+  5C8C CD 59 01     	CALL CALBAS
142+  5C8F ED 53 97 5F  	LD (BLIT_STRUCT+2), DE
143+  5C93              	; comma
144+  5C93 CD 66 62     	CALL CHKCHAR
145+  5C96 2C           	DB ','
146+  5C97              	; get destintion pointer
147+  5C97 DD 21 2F 54  	LD IX, FRMQNT
148+  5C9B CD 59 01     	CALL CALBAS
149+  5C9E ED 53 9B 5F  	LD (BLIT_STRUCT+6), DE
150+  5CA2              	; comma
151+  5CA2 CD 66 62     	CALL CHKCHAR
152+  5CA5 2C           	DB ','
153+  5CA6              	; get destination columns
154+  5CA6 DD 21 2F 54  	LD IX, FRMQNT
155+  5CAA CD 59 01     	CALL CALBAS
156+  5CAD 7B           	LD A, E
157+  5CAE 32 91 5F     	LD (BLIT_TMP+0), A
158+  5CB1              	; comma
159+  5CB1 CD 66 62     	CALL CHKCHAR
160+  5CB4 2C           	DB ','
161+  5CB5              	; get destination rows
162+  5CB5 DD 21 2F 54  	LD IX, FRMQNT
163+  5CB9 CD 59 01     	CALL CALBAS
164+  5CBC 7B           	LD A, E
165+  5CBD 32 92 5F     	LD (BLIT_TMP+1), A
166+  5CC0              	; comma
167+  5CC0 CD 66 62     	CALL CHKCHAR
168+  5CC3 2C           	DB ','
169+  5CC4              	; get destination begin column
170+  5CC4 DD 21 2F 54  	LD IX, FRMQNT
171+  5CC8 CD 59 01     	CALL CALBAS
172+  5CCB 7B           	LD A, E
173+  5CCC 32 93 5F     	LD (BLIT_TMP+2), A
174+  5CCF              	; comma
175+  5CCF CD 66 62     	CALL CHKCHAR
176+  5CD2 2C           	DB ','
177+  5CD3              	; get destination begin row
178+  5CD3 DD 21 2F 54  	LD IX, FRMQNT
179+  5CD7 CD 59 01     	CALL CALBAS
180+  5CDA 7B           	LD A, E
181+  5CDB 32 94 5F     	LD (BLIT_TMP+3), A
182+  5CDE              	; comma
183+  5CDE CD 66 62     	CALL CHKCHAR
184+  5CE1 2C           	DB ','
185+  5CE2              	; get number of tiles horizontally
186+  5CE2 DD 21 2F 54  	LD IX, FRMQNT
187+  5CE6 CD 59 01     	CALL CALBAS
188+  5CE9 ED 53 9F 5F  	LD (BLIT_STRUCT+10), DE
189+  5CED              	; comma
190+  5CED CD 66 62     	CALL CHKCHAR
191+  5CF0 2C           	DB ','
192+  5CF1              	; get number of tiles vertically
193+  5CF1 DD 21 2F 54  	LD IX, FRMQNT
194+  5CF5 CD 59 01     	CALL CALBAS
195+  5CF8 ED 53 A1 5F  	LD (BLIT_STRUCT+12), DE
196+  5CFC              	; ending )
197+  5CFC CD 66 62     	CALL CHKCHAR
198+  5CFF 29           	DB ')'
199+  5D00
200+  5D00 E5           	PUSH HL ; save position in BASIC buffer
201+  5D01
202+  5D01              	; calculate destination add to value
203+  5D01 26 00        	LD H, 0
204+  5D03 3A 91 5F     	LD A, (BLIT_TMP+0)
205+  5D06 6F           	LD L, A
206+  5D07 CD 55 61     	CALL HLx8
207+  5D0A 22 9D 5F     	LD (BLIT_STRUCT+8), HL
208+  5D0D              	; calculate pointer to background location
209+  5D0D 21 00 00     	LD HL, 0
210+  5D10 3A 94 5F     	LD A,(BLIT_TMP+3)
211+  5D13 B7           	OR A
212+  5D14 28 08        	JR Z, .L1
213+  5D16 47           	LD B,A
214+  5D17 ED 5B 9D 5F  	LD DE,(BLIT_STRUCT+8)
215+  5D1B              .L0:
216+  5D1B 19           	ADD HL, DE
217+  5D1C 10 FD        	DJNZ .L0
218+  5D1E              .L1:
219+  5D1E EB           	EX DE,HL
220+  5D1F 26 00        	LD H,0
221+  5D21 3A 93 5F     	LD A,(BLIT_TMP+2)
222+  5D24 6F           	LD L,A
223+  5D25 CD 55 61     	CALL HLx8
224+  5D28 19           	ADD HL,DE
225+  5D29 ED 5B 9B 5F  	LD DE,(BLIT_STRUCT+6)
226+  5D2D 19           	ADD HL,DE
227+  5D2E 22 9B 5F     	LD (BLIT_STRUCT+6),HL
228+  5D31
229+  5D31 FD 21 38 5D  	LD IY, .RET
230+  5D35 C3 19 62     	JP ENABLE_PAGE0
231+  5D38              .RET:
232+  5D38 FB           	EI
233+  5D39              	; set RAM functions to call
234+  5D39 21 53 5D     	LD HL, .TILECOPY
235+  5D3C 22 47 5C     	LD (TILE.CALL2+1), HL
236+  5D3F 21 64 5D     	LD HL, .SETDESTROW
237+  5D42 22 39 5C     	LD (TILE.CALL1+1), HL
238+  5D45 DD 21 95 5F  	LD IX,BLIT_STRUCT
239+  5D49 CD 1E 5C     	CALL TILE
240+  5D4C
241+  5D4C D1               POP DE
242+  5D4D C1               POP BC
243+  5D4E CD 90 61         CALL RESTORE_PAGE_INFO
244+  5D51
245+  5D51 E1           	POP HL
246+  5D52 C9           	RET
247+  5D53              .TILECOPY:
248+  5D53 ED A0       > LDI
248+  5D55 ED A0       > LDI
248+  5D57 ED A0       > LDI
248+  5D59 ED A0       > LDI
248+  5D5B ED A0       > LDI
248+  5D5D ED A0       > LDI
248+  5D5F ED A0       > LDI
248+  5D61 ED A0       > LDI
249+  5D63 C9           	RET
250+  5D64              .SETDESTROW:
251+  5D64 ED 5B 91 5F  	LD DE, (TILETMP1)
252+  5D68 C9           	RET
253+  5D69              ; *******************************************************************************************************
254+  5D69               ENDIF
255+  5D69
256+  5D69               IFDEF CMDS_WITH_PARAMETERS
257+  5D69              ; *******************************************************************************************************
258+  5D69              ; function to handle CALL TILEVRM basic extension
259+  5D69              ; fills vram with tiles
260+  5D69              ; TILEVRM ( INT tile_data_pointer,
261+  5D69              ;			INT tile_columns,
262+  5D69              ;			INT tile_rows,
263+  5D69              ;			INT destination_begin_column,
264+  5D69              ;			INT destination_begin_row,
265+  5D69              ;			INT number_of_tiles_horizontally,
266+  5D69              ;			INT	number_of_tiles_vertically )
267+  5D69              ; will put ram in page 0 also, page 1 is already there
268+  5D69              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5D69              TILEVRM:
270+  5D69              	; opening (
271+  5D69 CD 66 62     	CALL CHKCHAR
272+  5D6C 28           	DB '('
273+  5D6D              	; get tile data pointer coordinate
274+  5D6D DD 21 2F 54  	LD IX, FRMQNT
275+  5D71 CD 59 01     	CALL CALBAS
276+  5D74 ED 53 95 5F  	LD (BLIT_STRUCT+0), DE
277+  5D78              	; comma
278+  5D78 CD 66 62     	CALL CHKCHAR
279+  5D7B 2C           	DB ','
280+  5D7C              	; get tile columns
281+  5D7C DD 21 2F 54  	LD IX, FRMQNT
282+  5D80 CD 59 01     	CALL CALBAS
283+  5D83 ED 53 99 5F  	LD (BLIT_STRUCT+4), DE
284+  5D87              	; comma
285+  5D87 CD 66 62     	CALL CHKCHAR
286+  5D8A 2C           	DB ','
287+  5D8B              	; get tile columns
288+  5D8B DD 21 2F 54  	LD IX, FRMQNT
289+  5D8F CD 59 01     	CALL CALBAS
290+  5D92 ED 53 97 5F  	LD (BLIT_STRUCT+2), DE
291+  5D96              	; comma
292+  5D96 CD 66 62     	CALL CHKCHAR
293+  5D99 2C           	DB ','
294+  5D9A              	; get destination begin column
295+  5D9A DD 21 2F 54  	LD IX, FRMQNT
296+  5D9E CD 59 01     	CALL CALBAS
297+  5DA1 7B           	LD A, E
298+  5DA2 32 93 5F     	LD (BLIT_TMP+2), A
299+  5DA5              	; comma
300+  5DA5 CD 66 62     	CALL CHKCHAR
301+  5DA8 2C           	DB ','
302+  5DA9              	; get destination begin row
303+  5DA9 DD 21 2F 54  	LD IX, FRMQNT
304+  5DAD CD 59 01     	CALL CALBAS
305+  5DB0 7B           	LD A, E
306+  5DB1 32 94 5F     	LD (BLIT_TMP+3), A
307+  5DB4              	; comma
308+  5DB4 CD 66 62     	CALL CHKCHAR
309+  5DB7 2C           	DB ','
310+  5DB8              	; get number of tiles horizontally
311+  5DB8 DD 21 2F 54  	LD IX, FRMQNT
312+  5DBC CD 59 01     	CALL CALBAS
313+  5DBF ED 53 9F 5F  	LD (BLIT_STRUCT+10), DE
314+  5DC3              	; comma
315+  5DC3 CD 66 62     	CALL CHKCHAR
316+  5DC6 2C           	DB ','
317+  5DC7              	; get number of tiles vertically
318+  5DC7 DD 21 2F 54  	LD IX, FRMQNT
319+  5DCB CD 59 01     	CALL CALBAS
320+  5DCE ED 53 A1 5F  	LD (BLIT_STRUCT+12), DE
321+  5DD2              	; ending )
322+  5DD2 CD 66 62     	CALL CHKCHAR
323+  5DD5 29           	DB ')'
324+  5DD6
325+  5DD6 E5           	PUSH HL ; save position in BASIC buffer
326+  5DD7
327+  5DD7              	; calculate destination add to value
328+  5DD7 21 00 01     	LD HL, 256
329+  5DDA 22 9D 5F     	LD (BLIT_STRUCT+8), HL
330+  5DDD              	; calculate pointer to background location
331+  5DDD 3A 94 5F     	LD A,(BLIT_TMP+3)
332+  5DE0 67           	LD H,A
333+  5DE1 2E 00        	LD L,0
334+  5DE3 EB           	EX DE,HL
335+  5DE4 26 00        	LD H,0
336+  5DE6 3A 93 5F     	LD A,(BLIT_TMP+2)
337+  5DE9 6F           	LD L,A
338+  5DEA CD 55 61     	CALL HLx8
339+  5DED 19           	ADD HL,DE
340+  5DEE ED 5B CB F3  	LD DE,(GRPCGP)
341+  5DF2 19           	ADD HL,DE
342+  5DF3 22 9B 5F     	LD (BLIT_STRUCT+6),HL
343+  5DF6
344+  5DF6 FD 21 FD 5D  	LD IY, .RET
345+  5DFA C3 19 62     	JP ENABLE_PAGE0
346+  5DFD              .RET:
347+  5DFD FB           	EI
348+  5DFE              	; set RAM functions to call
349+  5DFE 21 18 5E     	LD HL, .TILECOPY
350+  5E01 22 47 5C     	LD (TILE.CALL2+1), HL
351+  5E04 21 1E 5E     	LD HL, .SETDESTROW
352+  5E07 22 39 5C     	LD (TILE.CALL1+1), HL
353+  5E0A DD 21 95 5F  	LD IX,BLIT_STRUCT
354+  5E0E CD 1E 5C     	CALL TILE
355+  5E11
356+  5E11 D1               POP DE
357+  5E12 C1               POP BC
358+  5E13 CD 90 61         CALL RESTORE_PAGE_INFO
359+  5E16
360+  5E16 E1           	POP HL
361+  5E17 C9           	RET
362+  5E18              .TILECOPY:
363+  5E18 01 98 08     	LD BC, #0898
364+  5E1B C3 4D 61     	JP BBYTECOPY_NO_C
365+  5E1E              .SETDESTROW:
366+  5E1E 2A 91 5F     	LD HL, (TILETMP1)
367+  5E21 F3           	DI
368+  5E22 CD 40 61     	CALL SETWRT_LOCAL
369+  5E25 FB           	EI
370+  5E26 C9           	RET
371+  5E27              ; *******************************************************************************************************
372+  5E27               ENDIF
373+  5E27
374+  5E27               IFNDEF CMDS_WITH_PARAMETERS
375+  5E27 ~            ; *******************************************************************************************************
376+  5E27 ~            ; function to handle CALL TILEVRM basic extension
377+  5E27 ~            ; fills vram with tiles
378+  5E27 ~            ; TILEVRM ( INT request_data_ptr )
379+  5E27 ~            ; request_data_ptr described in TILE
380+  5E27 ~            ; will put ram in page 0 also, page 1 is already there
381+  5E27 ~            TILEVRM:
382+  5E27 ~            	; opening (
383+  5E27 ~            	CALL CHKCHAR
384+  5E27 ~            	DB '('
385+  5E27 ~            	; get pointer to request struct
386+  5E27 ~            	LD IX, FRMQNT
387+  5E27 ~            	CALL CALBAS
388+  5E27 ~            	PUSH DE
389+  5E27 ~            	; ending )
390+  5E27 ~            	CALL CHKCHAR
391+  5E27 ~            	DB ')'
392+  5E27 ~
393+  5E27 ~            	POP IX ; pointer to request struct
394+  5E27 ~
395+  5E27 ~            	PUSH HL ; save position in BASIC buffer
396+  5E27 ~
397+  5E27 ~            	LD IY, .RET
398+  5E27 ~            	JP ENABLE_PAGE0
399+  5E27 ~            .RET:
400+  5E27 ~            	EI
401+  5E27 ~            	; set RAM functions to call
402+  5E27 ~            	LD HL, .TILECOPY
403+  5E27 ~            	LD (TILE.CALL2+1), HL
404+  5E27 ~            	LD HL, .SETDESTROW
405+  5E27 ~            	LD (TILE.CALL1+1), HL
406+  5E27 ~            	CALL TILE
407+  5E27 ~
408+  5E27 ~                POP DE
409+  5E27 ~                POP BC
410+  5E27 ~                CALL RESTORE_PAGE_INFO
411+  5E27 ~
412+  5E27 ~            	POP HL
413+  5E27 ~            	RET
414+  5E27 ~            .TILECOPY:
415+  5E27 ~            	LD BC, #0898
416+  5E27 ~            	JP BBYTECOPY_NO_C
417+  5E27 ~            .SETDESTROW:
418+  5E27 ~            	LD HL, (TILETMP1)
419+  5E27 ~            	DI
420+  5E27 ~            	CALL SETWRT_LOCAL
421+  5E27 ~            	EI
422+  5E27 ~            	RET
423+  5E27 ~            ; *******************************************************************************************************
424+  5E27               ENDIF
# file closed: asm\TILE.asm
153   5E27               ENDIF
154   5E27
155   5E27               IF (BYTEOPS_CMDS == 1)
156   5E27 ~             INCLUDE "BYTEOPS.asm"
157   5E27               ENDIF
158   5E27
159   5E27               IF (COLL_CMD == 1)
160   5E27               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
  1+  5E27              ; ************************************************************************************************
  2+  5E27              ; quick test if HL<=DE<=HL+BC
  3+  5E27              ; input BC=width, DE=x, HL=min
  4+  5E27              ; if not true flag C set
  5+  5E27              ; modifies AF
  6+  5E27              GENERIC_INNER_CHECK:
  7+  5E27 E5               PUSH HL
  8+  5E28 D5               PUSH DE
  9+  5E29 EB               EX DE,HL
 10+  5E2A A7               AND A
 11+  5E2B ED 52            SBC HL, DE
 12+  5E2D FA 3B 5E         JP M, .GENERIC_INNER_CHECK_NOT
 13+  5E30 A7               AND A
 14+  5E31 ED 42            SBC HL, BC
 15+  5E33 28 03            JR Z, .L2
 16+  5E35 F2 3B 5E         JP P, .GENERIC_INNER_CHECK_NOT
 17+  5E38              .L2:
 18+  5E38 A7               AND A
 19+  5E39 18 01            JR .EXIT
 20+  5E3B              .GENERIC_INNER_CHECK_NOT:
 21+  5E3B 37               SCF
 22+  5E3C              .EXIT:
 23+  5E3C D1               POP DE
 24+  5E3D E1               POP HL
 25+  5E3E C9               RET
 26+  5E3F              ; ************************************************************************************************
 27+  5E3F
 28+  5E3F              ; ************************************************************************************************
 29+  5E3F              ; function to check if rectangles are overlapping
 30+  5E3F              ; input IX=pointer to struct
 31+  5E3F              ;  +00 active flag
 32+  5E3F              ;  +02 x coordinate
 33+  5E3F              ;  +04 y coordinate
 34+  5E3F              ;  +06 x offset where rectangle begins
 35+  5E3F              ;  +08 y offset where rectangle begins
 36+  5E3F              ;  +10 width
 37+  5E3F              ;  +12 height
 38+  5E3F              ; input BLIT_STRUCT data
 39+  5E3F              ;  +00 x coordinate
 40+  5E3F              ;  +02 y coordinate
 41+  5E3F              ;  +04 width
 42+  5E3F              ;  +06 height
 43+  5E3F              ; returns CF=1 if not overlapping, CF=0 if overlapping
 44+  5E3F              RECTANGLE_OVERLAP_CHECK:
 45+  5E3F                  ; first check which rectanlge is higher
 46+  5E3F DD 6E 0C         LD L,(IX+12)
 47+  5E42 DD 66 0D         LD H,(IX+13)
 48+  5E45 ED 5B 9B 5F      LD DE,(BLIT_STRUCT+6)
 49+  5E49 A7               AND A
 50+  5E4A ED 52            SBC HL,DE
 51+  5E4C DD 6E 04         LD L,(IX+4)
 52+  5E4F DD 66 05         LD H,(IX+5)
 53+  5E52 DD 5E 08         LD E,(IX+8)
 54+  5E55 DD 56 09         LD D,(IX+9)
 55+  5E58 FA 78 5E         JP M,.L1
 56+  5E5B                  ; equally high or IX defined one higher
 57+  5E5B                  ; check upper boundary
 58+  5E5B 19               ADD HL,DE
 59+  5E5C ED 5B 97 5F      LD DE,(BLIT_STRUCT+2)
 60+  5E60 DD 4E 0C         LD C,(IX+12)
 61+  5E63 DD 46 0D         LD B,(IX+13)
 62+  5E66 CD 27 5E         CALL GENERIC_INNER_CHECK
 63+  5E69 30 29            JR NC,.INSIDE
 64+  5E6B                  ; check lower boundary
 65+  5E6B E5               PUSH HL
 66+  5E6C 2A 9B 5F         LD HL,(BLIT_STRUCT+6)
 67+  5E6F 19               ADD HL,DE
 68+  5E70 EB               EX DE,HL
 69+  5E71 E1               POP HL
 70+  5E72 CD 27 5E         CALL GENERIC_INNER_CHECK
 71+  5E75 30 1D            JR NC,.INSIDE
 72+  5E77 C9               RET ; not overlapping
 73+  5E78              .L1:
 74+  5E78                  ; rectangle defined in BLIT_STRUCT is higher
 75+  5E78 19               ADD HL,DE
 76+  5E79 EB               EX DE,HL
 77+  5E7A 2A 97 5F         LD HL,(BLIT_STRUCT+2)
 78+  5E7D ED 4B 9B 5F      LD BC,(BLIT_STRUCT+6)
 79+  5E81 CD 27 5E         CALL GENERIC_INNER_CHECK
 80+  5E84 30 0E            JR NC,.INSIDE
 81+  5E86 E5               PUSH HL
 82+  5E87 DD 6E 0C         LD L,(IX+12)
 83+  5E8A DD 66 0D         LD H,(IX+13)
 84+  5E8D 19               ADD HL,DE
 85+  5E8E EB               EX DE,HL
 86+  5E8F E1               POP HL
 87+  5E90 CD 27 5E         CALL GENERIC_INNER_CHECK
 88+  5E93 D8               RET C
 89+  5E94              .INSIDE:
 90+  5E94                  ; check x coordinate
 91+  5E94                  ; first check which rectangle is wider
 92+  5E94 DD 6E 0A         LD L,(IX+10)
 93+  5E97 DD 66 0B         LD H,(IX+11)
 94+  5E9A ED 5B 99 5F      LD DE,(BLIT_STRUCT+4)
 95+  5E9E A7               AND A
 96+  5E9F ED 52            SBC HL,DE
 97+  5EA1 DD 6E 02         LD L,(IX+2)
 98+  5EA4 DD 66 03         LD H,(IX+3)
 99+  5EA7 DD 5E 06         LD E,(IX+6)
100+  5EAA DD 56 07         LD D,(IX+7)
101+  5EAD FA C9 5E         JP M,.L2
102+  5EB0                  ; equally wide or IX defined one wider
103+  5EB0                  ; check left boundary
104+  5EB0 19               ADD HL,DE
105+  5EB1 ED 5B 95 5F      LD DE,(BLIT_STRUCT+0)
106+  5EB5 DD 4E 0A         LD C,(IX+10)
107+  5EB8 DD 46 0B         LD B,(IX+11)
108+  5EBB CD 27 5E         CALL GENERIC_INNER_CHECK
109+  5EBE D0               RET NC ; overlap
110+  5EBF                  ; check right boundary
111+  5EBF E5               PUSH HL
112+  5EC0 2A 99 5F         LD HL,(BLIT_STRUCT+4)
113+  5EC3 19               ADD HL,DE
114+  5EC4 EB               EX DE,HL
115+  5EC5 E1               POP HL
116+  5EC6 C3 27 5E         JP GENERIC_INNER_CHECK ; CF and result set by fn call
117+  5EC9              .L2:
118+  5EC9                  ; rectangle defined in BLIT_STRUCT is higher
119+  5EC9 19               ADD HL,DE
120+  5ECA EB               EX DE,HL
121+  5ECB 2A 95 5F         LD HL,(BLIT_STRUCT+0)
122+  5ECE ED 4B 99 5F      LD BC,(BLIT_STRUCT+4)
123+  5ED2 CD 27 5E         CALL GENERIC_INNER_CHECK
124+  5ED5 D0               RET NC ; overlap
125+  5ED6 E5               PUSH HL
126+  5ED7 DD 6E 0A         LD L,(IX+10)
127+  5EDA DD 66 0B         LD H,(IX+11)
128+  5EDD 19               ADD HL,DE
129+  5EDE EB               EX DE,HL
130+  5EDF E1               POP HL
131+  5EE0 C3 27 5E         JP GENERIC_INNER_CHECK
132+  5EE3              ; ************************************************************************************************
133+  5EE3
134+  5EE3              ; ************************************************************************************************
135+  5EE3              ; function tries to find rectangle overlap and returns an index if found
136+  5EE3              ; input BLIT_STRUCT data
137+  5EE3              ;  +00 x coordinate
138+  5EE3              ;  +02 y coordinate
139+  5EE3              ;  +04 width
140+  5EE3              ;  +06 height
141+  5EE3              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
142+  5EE3              ;  +09 pointer to first element
143+  5EE3              ;  +11 pointer to INT result variable
144+  5EE3              ; returns CF=1 if not overlapping
145+  5EE3              ; returns A=list index and CF=0 if overlapping
146+  5EE3              FIND_OVERLAP:
147+  5EE3 3A 9D 5F         LD A,(BLIT_STRUCT+8)
148+  5EE6 47               LD B,A
149+  5EE7 DD 2A 9E 5F      LD IX,(BLIT_STRUCT+9)
150+  5EEB              .L1:
151+  5EEB C5               PUSH BC
152+  5EEC DD 7E 00         LD A,(IX)
153+  5EEF DD B6 01         OR (IX+1)
154+  5EF2 28 0C            JR Z,.NEXT
155+  5EF4 CD 3F 5E         CALL RECTANGLE_OVERLAP_CHECK
156+  5EF7 38 07            JR C,.NEXT
157+  5EF9                  ; found
158+  5EF9 C1               POP BC
159+  5EFA 3A 9D 5F         LD A,(BLIT_STRUCT+8)
160+  5EFD 90               SUB B
161+  5EFE A7               AND A
162+  5EFF C9               RET
163+  5F00              .NEXT:
164+  5F00 11 0E 00         LD DE,14
165+  5F03 DD 19            ADD IX,DE
166+  5F05 C1               POP BC
167+  5F06 10 E3            DJNZ .L1
168+  5F08 37               SCF
169+  5F09 C9               RET
170+  5F0A              ; ************************************************************************************************
171+  5F0A
172+  5F0A              ; ************************************************************************************************
173+  5F0A              ; function to handle CALL COLL basic extension
174+  5F0A              ; checks for collision between player and other rectangles
175+  5F0A              ; COLL ( INT result variable,
176+  5F0A              ;	     INT player x value,
177+  5F0A              ;	     INT player y value,
178+  5F0A              ;	     INT player width,
179+  5F0A              ;	     INT player height,
180+  5F0A              ;	     INT number of items in a list,
181+  5F0A              ;		 INT[6][n] rectangle struct )
182+  5F0A              ; will fill result variable with index or -1 if no collision
183+  5F0A              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
184+  5F0A              COLL:
185+  5F0A              	; opening (
186+  5F0A CD 66 62     	CALL CHKCHAR
187+  5F0D 28           	DB '('
188+  5F0E              	; get address of result variable
189+  5F0E DD 21 A4 5E  	LD IX, PTRGET
190+  5F12 CD 59 01     	CALL CALBAS
191+  5F15 ED 53 A0 5F  	LD (BLIT_STRUCT+11),DE
192+  5F19              	; comma
193+  5F19 CD 66 62     	CALL CHKCHAR
194+  5F1C 2C           	DB ','
195+  5F1D              	; get x
196+  5F1D DD 21 2F 54  	LD IX, FRMQNT
197+  5F21 CD 59 01     	CALL CALBAS
198+  5F24 ED 53 95 5F  	LD (BLIT_STRUCT+0),DE
199+  5F28              	; comma
200+  5F28 CD 66 62     	CALL CHKCHAR
201+  5F2B 2C           	DB ','
202+  5F2C              	; get y
203+  5F2C DD 21 2F 54  	LD IX, FRMQNT
204+  5F30 CD 59 01     	CALL CALBAS
205+  5F33 ED 53 97 5F  	LD (BLIT_STRUCT+2),DE
206+  5F37              	; comma
207+  5F37 CD 66 62     	CALL CHKCHAR
208+  5F3A 2C           	DB ','
209+  5F3B              	; get width
210+  5F3B DD 21 2F 54  	LD IX, FRMQNT
211+  5F3F CD 59 01     	CALL CALBAS
212+  5F42 ED 53 99 5F  	LD (BLIT_STRUCT+4),DE
213+  5F46              	; comma
214+  5F46 CD 66 62     	CALL CHKCHAR
215+  5F49 2C           	DB ','
216+  5F4A              	; get height
217+  5F4A DD 21 2F 54  	LD IX, FRMQNT
218+  5F4E CD 59 01     	CALL CALBAS
219+  5F51 ED 53 9B 5F  	LD (BLIT_STRUCT+6),DE
220+  5F55              	; comma
221+  5F55 CD 66 62     	CALL CHKCHAR
222+  5F58 2C           	DB ','
223+  5F59              	; get number of items in a list
224+  5F59 DD 21 1C 52  	LD IX, GETBYT
225+  5F5D CD 59 01     	CALL CALBAS
226+  5F60 32 9D 5F     	LD (BLIT_STRUCT+8),A
227+  5F63              	; comma
228+  5F63 CD 66 62     	CALL CHKCHAR
229+  5F66 2C           	DB ','
230+  5F67              	; get address of rectangle structure array DIM R%(6,n)
231+  5F67 3A 9D 5F     	LD A,(BLIT_STRUCT+8)
232+  5F6A 5F               LD E,A
233+  5F6B 3E 02            LD A,2
234+  5F6D 47           	LD B,A
235+  5F6E 16 07        	LD D,7
236+  5F70 CD 91 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
237+  5F73 ED 43 9E 5F  	LD (BLIT_STRUCT+9),BC
238+  5F77              	; ending )
239+  5F77 CD 66 62     	CALL CHKCHAR
240+  5F7A 29           	DB ')'
241+  5F7B
242+  5F7B E5               PUSH HL
243+  5F7C CD E3 5E         CALL FIND_OVERLAP
244+  5F7F 2A A0 5F         LD HL,(BLIT_STRUCT+11)
245+  5F82 38 06            JR C,.NOTFOUND
246+  5F84 77               LD (HL),A
247+  5F85 23               INC HL
248+  5F86 36 00            LD (HL),0
249+  5F88 E1               POP HL
250+  5F89 C9               RET
251+  5F8A              .NOTFOUND:
252+  5F8A 36 FF            LD (HL),#FF
253+  5F8C 23               INC HL
254+  5F8D 36 FF            LD (HL),#FF
255+  5F8F E1               POP HL
256+  5F90 C9               RET
257+  5F91              ; ************************************************************************************************
258+  5F91
# file closed: asm\COLLISION.asm
161   5F91               ENDIF
162   5F91
163   5F91              ; temp variables for BLIT, TILE functions
164   5F91               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
165   5F91              BLIT_TMP:
166   5F91              TILETMP1:
167   5F91              BLIT_TMP1:
168   5F91 00 00         DW 0
169   5F93              TILETMP2:
170   5F93              BLIT_TMP2:
171   5F93 00 00         DW 0
172   5F95                IFDEF CMDS_WITH_PARAMETERS
173   5F95              BLIT_STRUCT:
174   5F95 00 00 00...   DS 17
175   5F99                ENDIF
176   5F99               ENDIF
177   5FA6
178   5FA6               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
179   5FA6              VRAM_UPDATE_IN_PROGRESS:
180   5FA6 00            DB 0
181   5FA7               ENDIF
182   5FA7
183   5FA7              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
184   5FA7              ; per starting letter, if no commands with this letter, NULL value
185   5FA7              CMDS:
186   5FA7               IF (ANIM_CMDS == 1)
187   5FA7 D7 60        	DW CMDS_A ;
188   5FA9               ELSE
189   5FA9 ~                DW 0 ; A
190   5FA9               ENDIF
191   5FA9               IF (BLIT_CMDS + BOX_CMDS > 0)
192   5FA9 A2 60            DW CMDS_B ; B
193   5FAB               ELSE
194   5FAB ~            	DW 0
195   5FAB               ENDIF
196   5FAB               IF (COLL_CMD == 1)
197   5FAB 38 61        	DW CMDS_C ;
198   5FAD               ELSE
199   5FAD ~                DW 0 ; C
200   5FAD               ENDIF
201   5FAD 00 00            DW 0 ; D
202   5FAF 00 00            DW 0 ; E
203   5FB1               IF (VRAM_CMDS + RAM_CMDS > 0)
204   5FB1 19 60            DW CMDS_F; F
205   5FB3               ELSE
206   5FB3 ~            	DW 0
207   5FB3               ENDIF
208   5FB3               IF (GENCAL_CMD > 0)
209   5FB3 2C 60            DW CMDS_G; G
210   5FB5               ELSE
211   5FB5 ~            	DW 0
212   5FB5               ENDIF
213   5FB5               IF (BYTEOPS_CMDS == 1)
214   5FB5 ~                DW CMDS_H; H
215   5FB5               ELSE
216   5FB5 00 00            DW 0
217   5FB7               ENDIF
218   5FB7 00 00            DW 0 ; I
219   5FB9 00 00            DW 0 ; J
220   5FBB 00 00            DW 0 ; K
221   5FBD               IF (BYTEOPS_CMDS == 1)
222   5FBD ~                DW CMDS_L; L
223   5FBD               ELSE
224   5FBD 00 00            DW 0
225   5FBF               ENDIF
226   5FBF               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
227   5FBF DB 5F            DW CMDS_M ; M
228   5FC1               ELSE
229   5FC1 ~            	DW 0
230   5FC1               ENDIF
231   5FC1 00 00            DW 0 ; N
232   5FC3 00 00            DW 0 ; O
233   5FC5 00 00            DW 0 ; P
234   5FC7 00 00            DW 0 ; Q
235   5FC9               IF (BYTEOPS_CMDS == 1)
236   5FC9 ~                DW CMDS_R; R
237   5FC9               ELSE
238   5FC9 00 00            DW 0
239   5FCB               ENDIF
240   5FCB               IF (SOUND_CMDS + SPRITE_CMDS > 0)
241   5FCB 40 60            DW CMDS_S ; S
242   5FCD               ELSE
243   5FCD ~            	DW 0
244   5FCD               ENDIF
245   5FCD               IF (TILE_CMDS > 0)
246   5FCD C2 60            DW CMDS_T ; T
247   5FCF               ELSE
248   5FCF ~            	DW 0
249   5FCF               ENDIF
250   5FCF 00 00            DW 0 ; U
251   5FD1               IF (VRAM_CMDS > 0)
252   5FD1 36 60            DW CMDS_V ; V
253   5FD3               ELSE
254   5FD3 ~            	DW 0
255   5FD3               ENDIF
256   5FD3               IF (BYTEOPS_CMDS == 1)
257   5FD3 ~                DW CMDS_W; W
258   5FD3               ELSE
259   5FD3 00 00            DW 0
260   5FD5               ENDIF
261   5FD5 00 00            DW 0 ; X
262   5FD7 00 00            DW 0 ; Y
263   5FD9 00 00            DW 0 ; Z
264   5FDB
265   5FDB              CMDS_M:
266   5FDB               IF (VRAM_CMDS == 1)
267   5FDB 4D 45 4D 56      DB "MEMVRM", 0
267   5FDF 52 4D 00
268   5FE2 6C 57            DW MEMVRM
269   5FE4               ENDIF
270   5FE4               IF (RAM_CMDS == 1)
271   5FE4 4D 45 4D 43  	DB "MEMCPY", 0
271   5FE8 50 59 00
272   5FEB A2 55        	DW MEMCPY
273   5FED               ENDIF
274   5FED               IF (ANIM_CMDS == 1)
275   5FED 4D 41 58 41  	DB "MAXANIMITEMS",0
275   5FF1 4E 49 4D 49
275   5FF5 54 45 4D 53
275   5FF9 00
276   5FFA 07 50        	DW MAXANIMITEMS
277   5FFC 4D 41 58 41  	DB "MAXANIMDEFS",0
277   6000 4E 49 4D 44
277   6004 45 46 53 00
278   6008 7C 51        	DW MAXANIMDEFS
279   600A 4D 41 58 41  	DB "MAXANIMSPRS",0
279   600E 4E 49 4D 53
279   6012 50 52 53 00
280   6016 11 52        	DW MAXANIMSPRS
281   6018               ENDIF
282   6018               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
283   6018 00           	DB 0
284   6019               ENDIF
285   6019              CMDS_F:
286   6019               IF (VRAM_CMDS == 1)
287   6019 46 49 4C 56      DB "FILVRM", 0
287   601D 52 4D 00
288   6020 1C 57            DW FILVRM
289   6022               ENDIF
290   6022               IF (RAM_CMDS == 1)
291   6022 46 49 4C 52      DB "FILRAM", 0
291   6026 41 4D 00
292   6029 E5 55            DW FILRAM
293   602B               ENDIF
294   602B               IF (VRAM_CMDS + RAM_CMDS > 0)
295   602B 00               DB 0
296   602C               ENDIF
297   602C              CMDS_G:
298   602C               IF (GENCAL_CMD == 1)
299   602C 47 45 4E 43      DB "GENCAL", 0
299   6030 41 4C 00
300   6033 50 58            DW GENCAL
301   6035               ENDIF
302   6035               IF (GENCAL_CMD > 0)
303   6035 00           	DB	0
304   6036               ENDIF
305   6036              CMDS_V:
306   6036               IF (VRAM_CMDS == 1)
307   6036 56 52 4D 4D  	DB "VRMMEM", 0
307   603A 45 4D 00
308   603D EB 57        	DW VRMMEM
309   603F               ENDIF
310   603F               IF (VRAM_CMDS > 0)
311   603F 00           	DB 0
312   6040               ENDIF
313   6040              CMDS_S:
314   6040               IF (SPRITE_CMDS + ANIM_CMDS > 0)
315   6040 53 47 41 4D      DB "SGAM",0
315   6044 00
316   6045 EA 54            DW SGAM
317   6047               ENDIF
318   6047               IF (SPRITE_CMDS == 1)
319   6047 53 50 52 53   	DB "SPRSET", 0
319   604B 45 54 00
320   604E 99 4E        	DW SPRSET
321   6050 53 50 52 47  	DB "SPRGRPMOV", 0
321   6054 52 50 4D 4F
321   6058 56 00
322   605A 4A 4F        	DW SPRGRPMOV
323   605C               ENDIF
324   605C               IF (SOUND_CMDS == 1)
325   605C 53 4E 44 53  	DB "SNDSFX", 0
325   6060 46 58 00
326   6063 C2 56        	DW SNDSFX
327   6065 53 4E 44 50  	DB "SNDPLYON", 0
327   6069 4C 59 4F 4E
327   606D 00
328   606E 8C 56        	DW SNDPLYON
329   6070 53 4E 44 50  	DB "SNDPLYOFF", 0
329   6074 4C 59 4F 46
329   6078 46 00
330   607A 9F 56        	DW SNDPLYOFF
331   607C 53 4E 44 50  	DB "SNDPLYINI", 0
331   6080 4C 59 49 4E
331   6084 49 00
332   6086 42 56        	DW SNDPLYINIT
333   6088               ENDIF
334   6088               IF (SPRITE_CMDS == 1)
335   6088 53 50 52 45  	DB "SPRENABLE", 0
335   608C 4E 41 42 4C
335   6090 45 00
336   6092 54 4E        	DW SPRENABLE
337   6094 53 50 52 44  	DB "SPRDISABLE", 0
337   6098 49 53 41 42
337   609C 4C 45 00
338   609F 94 4E        	DW SPRDISABLE
339   60A1               ENDIF
340   60A1               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
341   60A1 00           	DB 0
342   60A2               ENDIF
343   60A2              CMDS_B:
344   60A2               IF (BLIT_CMDS == 1)
345   60A2 42 4C 49 54  	DB "BLIT", 0
345   60A6 00
346   60A7 22 5B        	DW BLIT
347   60A9               ENDIF
348   60A9               IF (BOX_CMDS == 1)
349   60A9 42 4F 58 4D  	DB "BOXMEMCPY", 0
349   60AD 45 4D 43 50
349   60B1 59 00
350   60B3 DF 58        	DW BOXMEMCPY
351   60B5 42 4F 58 4D  	DB "BOXMEMVRM", 0
351   60B9 45 4D 56 52
351   60BD 4D 00
352   60BF 74 59        	DW BOXMEMVRM
353   60C1               ENDIF
354   60C1               IF (BLIT_CMDS + BOX_CMDS > 0)
355   60C1 00           	DB 0
356   60C2               ENDIF
357   60C2              CMDS_T:
358   60C2               IF (TILE_CMDS == 1)
359   60C2 54 49 4C 45  	DB "TILERAM", 0
359   60C6 52 41 4D 00
360   60CA 66 5C        	DW TILERAM
361   60CC 54 49 4C 45  	DB "TILEVRM", 0
361   60D0 56 52 4D 00
362   60D4 69 5D        	DW TILEVRM
363   60D6               ENDIF
364   60D6               IF (TILE_CMDS > 0)
365   60D6 00           	DB 0
366   60D7               ENDIF
367   60D7              CMDS_A:
368   60D7               IF (ANIM_CMDS == 1)
369   60D7 41 4E 49 4D      DB "ANIMSTEP",0
369   60DB 53 54 45 50
369   60DF 00
370   60E0 58 53            DW ANIMSTEP
371   60E2 41 4E 49 4D  	DB "ANIMSTART",0
371   60E6 53 54 41 52
371   60EA 54 00
372   60EC 5D 53        	DW ANIMSTART
373   60EE 41 4E 49 4D  	DB "ANIMSTOP",0
373   60F2 53 54 4F 50
373   60F6 00
374   60F7 62 53        	DW ANIMSTOP
375   60F9 41 4E 49 4D  	DB "ANIMITEMPAT",0
375   60FD 49 54 45 4D
375   6101 50 41 54 00
376   6105 C7 50        	DW ANIMITEMPAT
377   6107 41 4E 49 4D  	DB "ANIMITEMPTR",0
377   610B 49 54 45 4D
377   610F 50 54 52 00
378   6113 28 51        	DW ANIMITEMPTR_CMD
379   6115 41 4E 49 4D  	DB "ANIMDEF",0
379   6119 44 45 46 00
380   611D BE 51        	DW ANIMDEF
381   611F 41 4E 49 4D  	DB "ANIMSPRITE",0
381   6123 53 50 52 49
381   6127 54 45 00
382   612A 67 52        	DW ANIMSPRITE
383   612C 41 4E 49 4D      DB "ANIMCHAR",0
383   6130 43 48 41 52
383   6134 00
384   6135 DF 52            DW ANIMCHAR
385   6137 00           	DB 0
386   6138               ENDIF
387   6138              CMDS_H:
388   6138               IF (BYTEOPS_CMDS == 1)
389   6138 ~                DB "HI", 0
390   6138 ~                DW HI
391   6138               ENDIF
392   6138               IF (BYTEOPS_CMDS > 0)
393   6138 ~            	DB	0
394   6138               ENDIF
395   6138              CMDS_L:
396   6138               IF (BYTEOPS_CMDS == 1)
397   6138 ~                DB "LO", 0
398   6138 ~                DW LO
399   6138               ENDIF
400   6138               IF (BYTEOPS_CMDS > 0)
401   6138 ~            	DB	0
402   6138               ENDIF
403   6138              CMDS_W:
404   6138               IF (BYTEOPS_CMDS == 1)
405   6138 ~                DB "W", 0
406   6138 ~                DW WORD
407   6138               ENDIF
408   6138               IF (BYTEOPS_CMDS > 0)
409   6138 ~            	DB	0
410   6138               ENDIF
411   6138              CMDS_R:
412   6138               IF (BYTEOPS_CMDS == 1)
413   6138 ~                DB "RANGE", 0
414   6138 ~                DW RANGE
415   6138               ENDIF
416   6138               IF (BYTEOPS_CMDS > 0)
417   6138 ~            	DB	0
418   6138               ENDIF
419   6138              CMDS_C:
420   6138               IF (COLL_CMD == 1)
421   6138 43 4F 4C 4C      DB "COLL", 0
421   613C 00
422   613D 0A 5F            DW COLL
423   613F               ENDIF
424   613F               IF (COLL_CMD > 0)
425   613F 00           	DB	0
426   6140               ENDIF
427   6140
428   6140               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
429   6140              ; ****************************************************************************************************
430   6140              ; function sets VRAM address
431   6140              ; input HL=address
432   6140              ; modifies AF
433   6140              SETWRT_LOCAL:
434   6140 7D           	LD	A, L
435   6141 D3 99        	OUT	(099H), A
436   6143 7C           	LD	A, H
437   6144 E6 3F        	AND	03FH
438   6146 F6 40        	OR	040H
439   6148 D3 99        	OUT	(099H), A
440   614A C9           	RET
441   614B              ; ****************************************************************************************************
442   614B               ENDIF
443   614B
444   614B               IF (VRAM_CMDS + TILE_CMDS > 0)
445   614B              ; ****************************************************************************************************
446   614B              ; function copies data from RAM to VRAM
447   614B              ; input HL=address in RAM
448   614B              ; input B=count
449   614B              ; modifies AF, BC, HL
450   614B              BBYTECOPY:
451   614B 0E 98        	LD C,#98
452   614D              BBYTECOPY_NO_C:
453   614D ED A3        	OUTI
454   614F C2 4D 61     	JP	NZ, BBYTECOPY_NO_C
455   6152 C9           	RET
456   6153              ; ****************************************************************************************************
457   6153               ENDIF
458   6153
459   6153              ; ****************************************************************************************************
460   6153              ; function multiplies HL by 32
461   6153              HLx32:
462   6153 29           	ADD HL,HL
463   6154              ; ****************************************************************************************************
464   6154              ; function multiplies HL by 16
465   6154              HLx16:
466   6154 29           	ADD HL,HL
467   6155              ; ****************************************************************************************************
468   6155              ; function multiplies HL by 8
469   6155              HLx8:
470   6155 29          > ADD HL, HL
470   6156 29          > ADD HL, HL
470   6157 29          > ADD HL, HL
471   6158 C9           	RET
472   6159              ; ****************************************************************************************************
473   6159
474   6159              ; ****************************************************************************************************
475   6159              ; function gets slot and subslot data for specific page
476   6159              ; input A=page (0, 1 or 2)
477   6159              ; output B = 0A8H register value
478   6159              ; output D = 0 is no subslots, 1 if yes
479   6159              ; output C = 0A8H value when page 3 slot equals to requested page slot
480   6159              ; output E = subslot value if present
481   6159              ; modifies AF, BC, DE, HL
482   6159              GET_PAGE_INFO:
483   6159 6F               LD L, A
484   615A C6 C1            ADD A, low (EXPTBL)
485   615C 32 66 61         LD (GET_PAGE_INFO_L1+1), A
486   615F DB A8            IN A, (0A8H)
487   6161 47               LD B, A
488   6162 E6 3F            AND 03FH
489   6164 4F               LD C, A
490   6165              GET_PAGE_INFO_L1:
491   6165 3A C1 FC         LD A, (EXPTBL) ; modified by code above
492   6168 E6 80            AND 080H
493   616A 28 1B            JR Z, GET_PAGE_INFO_L2
494   616C                  ; expanded
495   616C 2D               DEC L
496   616D FA 8C 61         JP M, GET_PAGE_INFO_L3
497   6170 2D               DEC L
498   6171 FA 8A 61         JP M, GET_PAGE_INFO_L4
499   6174                  ; page 2
500   6174 07               RLCA
501   6175 07               RLCA
502   6176              GET_PAGE_INFO_L5:
503   6176 E6 C0            AND 0C0H
504   6178 B1               OR C
505   6179 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
506   617B 4F               LD C, A
507   617C 3A FF FF         LD A, (0FFFFH)
508   617F 2F               CPL
509   6180 5F               LD E, A
510   6181 16 01            LD D, 1
511   6183 78               LD A, B ; return stack
512   6184 D3 A8            OUT (0A8H), A
513   6186 C9               RET
514   6187              GET_PAGE_INFO_L2:
515   6187                  ; not expanded
516   6187 16 00            LD D, 0
517   6189 C9               RET
518   618A              GET_PAGE_INFO_L4:
519   618A                  ; page 1
520   618A 0F               RRCA
521   618B 0F               RRCA
522   618C              GET_PAGE_INFO_L3:
523   618C                  ; page 0
524   618C 0F               RRCA
525   618D 0F               RRCA
526   618E 18 E6            JR GET_PAGE_INFO_L5
527   6190              ; ****************************************************************************************************
528   6190
529   6190              ; ****************************************************************************************************
530   6190              ; function returns original slot and subslot info
531   6190              ; input B = 0A8H register value
532   6190              ; input D = 0 is no subslots, 1 if yes
533   6190              ; input C = 0A8H value when page 3 slot equals to requested page slot
534   6190              ; input E = subslot value if present
535   6190              ; modifies AF, disables interrupts
536   6190              RESTORE_PAGE_INFO:
537   6190 7A               LD A, D
538   6191 B7               OR A
539   6192 28 08            JR Z, RESTORE_PAGE_INFO_L1
540   6194 79               LD A, C
541   6195 F3           	DI
542   6196 D3 A8            OUT (0A8H), A
543   6198 7B               LD A, E
544   6199 32 FF FF         LD (0FFFFH), A
545   619C              RESTORE_PAGE_INFO_L1:
546   619C 78               LD A, B
547   619D D3 A8            OUT (0A8H), A
548   619F C9               RET
549   61A0              ; ****************************************************************************************************
550   61A0
551   61A0              ; *******************************************************************************************************
552   61A0              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
553   61A0              ; INPUT:  A = SLOT ID: EXXXSSPP
554   61A0              ; E = EXPANDED FLAG
555   61A0              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
556   61A0              ; PP = PRIMARY SLOT NUMBER
557   61A0              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
558   61A0              ; CHANGES: AF, BC, DE
559   61A0
560   61A0              LOCAL_ENASLT:
561   61A0 CD C0 61         CALL L0353
562   61A3 FA AD 61         JP M, L0340
563   61A6 DB A8            IN A, (0A8H)
564   61A8 A1               AND C
565   61A9 B0               OR B
566   61AA D3 A8            OUT (0A8H), A
567   61AC C9               RET
568   61AD              L0340:
569   61AD E5               PUSH HL
570   61AE CD E5 61         CALL L0378
571   61B1 4F               LD C, A
572   61B2 06 00            LD B, 0
573   61B4 7D               LD A, L
574   61B5 A4               AND H
575   61B6 B2               OR D
576   61B7 21 C5 FC         LD HL, 0FCC5H
577   61BA 09               ADD HL, BC
578   61BB 77               LD (HL), A
579   61BC E1               POP HL
580   61BD 79               LD A, C
581   61BE 18 E0            JR LOCAL_ENASLT
582   61C0              L0353:
583   61C0 F3               DI
584   61C1 F5               PUSH AF
585   61C2 7C               LD A, H
586   61C3 07               RLCA
587   61C4 07               RLCA
588   61C5 E6 03            AND 3
589   61C7 5F               LD E, A
590   61C8 3E C0            LD A, 0C0H
591   61CA              L035D:
592   61CA 07               RLCA
593   61CB 07               RLCA
594   61CC 1D               DEC E
595   61CD F2 CA 61         JP P, L035D
596   61D0 5F               LD E, A
597   61D1 2F               CPL
598   61D2 4F               LD C, A
599   61D3 F1               POP AF
600   61D4 F5               PUSH AF
601   61D5 E6 03            AND 3
602   61D7 3C               INC A
603   61D8 47               LD B, A
604   61D9 3E AB            LD A, 0ABH
605   61DB              L036E:
606   61DB C6 55            ADD A, 055H
607   61DD 10 FC            DJNZ L036E
608   61DF 57               LD D, A
609   61E0 A3               AND E
610   61E1 47               LD B, A
611   61E2 F1               POP AF
612   61E3 A7               AND A
613   61E4 C9               RET
614   61E5              L0378:
615   61E5 F5               PUSH AF
616   61E6 7A               LD A, D
617   61E7 E6 C0            AND 0C0H
618   61E9 4F               LD C, A
619   61EA F1               POP AF
620   61EB F5               PUSH AF
621   61EC 57               LD D, A
622   61ED DB A8            IN A, (0A8H)
623   61EF 47               LD B, A
624   61F0 E6 3F            AND 03FH
625   61F2 B1               OR C
626   61F3 D3 A8            OUT (0A8H), A
627   61F5 7A               LD A, D
628   61F6 0F               RRCA
629   61F7 0F               RRCA
630   61F8 E6 03            AND 3
631   61FA 57               LD D, A
632   61FB 3E AB            LD A, 0ABH
633   61FD              L0390:
634   61FD C6 55            ADD A, 055H
635   61FF 15               DEC D
636   6200 F2 FD 61         JP P, L0390
637   6203 A3               AND E
638   6204 57               LD D, A
639   6205 7B               LD A, E
640   6206 2F               CPL
641   6207 67               LD H, A
642   6208 3A FF FF         LD A, (0FFFFH)
643   620B 2F               CPL
644   620C 6F               LD L, A
645   620D A4               AND H
646   620E B2               OR D
647   620F 32 FF FF         LD (0FFFFH), A
648   6212 78               LD A, B
649   6213 D3 A8            OUT (0A8H), A
650   6215 F1               POP AF
651   6216 E6 03            AND 3
652   6218 C9               RET
653   6219              ; *******************************************************************************************************
654   6219
655   6219              ; *******************************************************************************************************
656   6219              ; some common code to activate page 0 and place values needed to restore original page on stack
657   6219              ; input IY=return address
658   6219              ENABLE_PAGE0:
659   6219 AF               XOR A
660   621A CD 59 61         CALL GET_PAGE_INFO
661   621D C5               PUSH BC
662   621E D5               PUSH DE
663   621F 3A 41 F3         LD A, (RAMAD0)
664   6222 26 00            LD H, 0
665   6224 CD A0 61         CALL LOCAL_ENASLT
666   6227 FD E9        	JP (IY)
667   6229              ; *******************************************************************************************************
668   6229
669   6229              ; General BASIC CALL-instruction handler
670   6229              CALLHAND:
671   6229 E5           	PUSH HL
672   622A 21 A7 5F     	LD	HL, CMDS ; pointer table based on starting letter
673   622D 3A 89 FD         LD A, (PROCNM)
674   6230 D6 41            SUB 'A'
675   6232 87               ADD A, A
676   6233 16 00            LD D, 0
677   6235 5F               LD E, A
678   6236 19               ADD HL, DE
679   6237 5E               LD E, (HL)
680   6238 23               INC HL
681   6239 56               LD D, (HL)
682   623A 7A               LD A, D
683   623B B3               OR E
684   623C 28 23            JR Z, .CMDNOTRECOGNIZED
685   623E EB               EX DE, HL
686   623F              .CHKCMD:
687   623F 11 89 FD     	LD	DE, PROCNM
688   6242 1A           .LOOP:	LD	A,(DE)
689   6243 BE           	CP	(HL)
690   6244 20 11        	JR	NZ,.TONEXTCMD	; Not equal
691   6246 13           	INC	DE
692   6247 23           	INC	HL
693   6248 A7           	AND	A
694   6249 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
695   624B 5E           	LD	E,(HL)
696   624C 23           	INC	HL
697   624D 56           	LD	D,(HL)
698   624E E1           	POP	HL		; routine address
699   624F CD 70 62     	CALL	GETPREVCHAR
700   6252 CD 64 62     	CALL	.CALLDE		; Call routine
701   6255 A7           	AND	A
702   6256 C9           	RET
703   6257
704   6257              .TONEXTCMD:
705   6257 0E FF        	LD	C,0FFH
706   6259 AF           	XOR	A
707   625A ED B1        	CPIR			; Skip to end of instruction name
708   625C 23           	INC	HL
709   625D 23           	INC	HL		; Skip address
710   625E BE           	CP	(HL)
711   625F 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
712   6261              .CMDNOTRECOGNIZED:
713   6261 E1           	POP	HL
714   6262 37               SCF
715   6263 C9           	RET
716   6264
717   6264              .CALLDE:
718   6264 D5           	PUSH	DE
719   6265 C9           	RET
720   6266
721   6266              ;---------------------------
722   6266
723   6266              ;GETSTRPNT:
724   6266              ; OUT:
725   6266              ; HL = String Address
726   6266              ; B  = Lenght
727   6266              ;        LD      HL,(USR)
728   6266              ;        LD      B,(HL)
729   6266              ;        INC     HL
730   6266              ;        LD      E,(HL)
731   6266              ;        INC     HL
732   6266              ;        LD      D,(HL)
733   6266              ;        EX      DE,HL
734   6266              ;        RET
735   6266
736   6266              ;EVALTXTPARAM:
737   6266              ;	CALL	CHKCHAR
738   6266              ;	DEFB	"("             ; Check for (
739   6266              ;	LD	IX,FRMEVL
740   6266              ;	CALL	CALBAS		; Evaluate expression
741   6266              ;       LD      A,(VALTYP)
742   6266              ;        CP      3               ; Text type?
743   6266              ;        JP      NZ,TYPE_MISMATCH
744   6266              ;        PUSH	HL
745   6266              ;        LD	IX,FRESTR         ; Free the temporary string
746   6266              ;        CALL	CALBAS
747   6266              ;        POP	HL
748   6266              ;	CALL	CHKCHAR
749   6266              ;	DEFB	")"             ; Check for )
750   6266              ;        RET
751   6266
752   6266
753   6266              CHKCHAR:
754   6266 CD 70 62     	CALL	GETPREVCHAR	; Get previous basic char
755   6269 E3           	EX	(SP),HL
756   626A BE           	CP	(HL) 	        ; Check if good char
757   626B 20 1B        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
758   626D 23           	INC	HL
759   626E E3           	EX	(SP),HL
760   626F 23           	INC	HL		; Get next basic char
761   6270
762   6270              GETPREVCHAR:
763   6270 2B           	DEC	HL
764   6271 DD 21 66 46  	LD	IX,CHRGTR
765   6275 C3 59 01     	JP      CALBAS
766   6278
767   6278
768   6278              TYPE_MISMATCH:
769   6278 1E 0D            LD E, 13 ; Type mismatch
770   627A 18 0E            JR THROW_ERROR
771   627C              SUBSCRIPT_OUT_OF_RANGE:
772   627C 1E 09            LD E,9 ; subscript out of range
773   627E 18 0A        	JR THROW_ERROR
774   6280              OVERFLOW:
775   6280 1E 06        	LD E,6
776   6282 18 06        	JR THROW_ERROR
777   6284              ILLEGAL_FUNCTION:
778   6284 1E 05            LD E, 5 ; illegal function call
779   6286 18 02            JR THROW_ERROR
780   6288              SYNTAX_ERROR:
781   6288 1E 02            LD E, 2 ; Syntax error
782   628A              THROW_ERROR:
783   628A DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
784   628E C3 59 01     	JP	CALBAS
785   6291
786   6291              ;---------------------------
787   6291
788   6291              ; *******************************************************************************************************
789   6291              ; helper function to get pointer to BASIC array data
790   6291              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
791   6291              ; input B=dimensions (1 or 2)
792   6291              ; input D=minimal first dimension
793   6291              ; input E=minimal second dimension, if applicable
794   6291              ; returns BC=pointer to first data element
795   6291              ; throws BASIC error if invalid type
796   6291              GET_BASIC_ARRAY_DATA_POINTER:
797   6291 D5           	PUSH DE
798   6292 C5           	PUSH BC
799   6293 F5           	PUSH AF
800   6294 3E 01           LD A,1
801   6296 32 A5 F6        LD (SUBFLG),A ; search for arrays only
802   6299 DD 21 A4 5E  	LD IX, PTRGET
803   629D CD 59 01     	CALL CALBAS
804   62A0 AF              XOR A
805   62A1 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
806   62A4 3A 63 F6     	LD A,(VALTYP)
807   62A7 D1           	POP DE ; required type
808   62A8 BA           	CP D
809   62A9 C2 78 62     	JP NZ,TYPE_MISMATCH
810   62AC 0A           	LD A,(BC)
811   62AD 03           	INC BC
812   62AE D1           	POP DE ; required number of dimensions
813   62AF BA           	CP D
814   62B0 C2 78 62     	JP NZ,TYPE_MISMATCH
815   62B3 D1           	POP DE ; required minimal array dimensions
816   62B4 3D           	DEC A
817   62B5 28 07        	JR Z,.ONE_DIMENSION
818   62B7              	; 2-dimension array
819   62B7 0A           	LD A,(BC)
820   62B8 03          > INC BC
820   62B9 03          > INC BC
821   62BA BB           	CP E
822   62BB DA 7C 62     	JP C,SUBSCRIPT_OUT_OF_RANGE
823   62BE              .ONE_DIMENSION:
824   62BE 0A           	LD A,(BC)
825   62BF 03          > INC BC
825   62C0 03          > INC BC
826   62C1 BA           	CP D
827   62C2 DA 7C 62     	JP C,SUBSCRIPT_OUT_OF_RANGE
828   62C5 C9           	RET
829   62C6              ; *******************************************************************************************************
830   62C6
831   62C6              EXT_END:
832   62C6
# file closed: asm\main.asm
