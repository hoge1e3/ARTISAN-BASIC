# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000
  51  4000              ; BASIC error codes
  52  4000              ;01 NEXT without FOR
  53  4000              ;02 Syntax error
  54  4000              ;03 RETURN without GOSUB
  55  4000              ;04 Out of DATA
  56  4000              ;05 Illegal function call
  57  4000              ;06 Overflow
  58  4000              ;07 Out of memory
  59  4000              ;08 Undefined line number
  60  4000              ;09 Subscript out of range
  61  4000              ;10 Redimensioned array
  62  4000              ;11 Division by zero
  63  4000              ;12 Illegal direct
  64  4000              ;13 Type mismatch
  65  4000              ;14 Out of string space
  66  4000              ;15 String too long
  67  4000              ;16 String formula too complex
  68  4000              ;17 Can't CONTINUE
  69  4000              ;18 Undefined user function
  70  4000              ;19 Device I/O error
  71  4000              ;20 Verify error
  72  4000              ;21 No RESUME
  73  4000              ;22 RESUME without error
  74  4000              ;23 Unprintable error
  75  4000              ;24 Missing operand
  76  4000              ;25 Line buffer overflow
  77  4000              ;50 FIELD overflow
  78  4000              ;51 Internal error
  79  4000              ;52 Bad file number
  80  4000              ;53 File not found
  81  4000              ;54 File already open
  82  4000              ;55 Input past end
  83  4000              ;56 Bad file name
  84  4000              ;57 Direct statement in file
  85  4000              ;58 Sequential I/O only
  86  4000              ;59 File not OPEN
  87  4000
  88  4000
  89  4000               ; simulate cartridge with BASIC extension
  90  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  90  4004 B5 54 00 00
  90  4008 00 00 00 00
  90  400C 00 00 00 00
  91  4010
  92  4010              ; this location #4010 stores last location used by basic extension
  93  4010              ; free memory after that point
  94  4010              FREEMEMPTR:
  95  4010 9A 5D         DW EXT_END
  96  4012
  97  4012              ; this location #4012 stores extension version in DAA format
  98  4012              ; first byte is major version and second minor
  99  4012              VERSION:
 100  4012 00 70         DB #00, #70
 101  4014
 102  4014              ; binary included AKG player compiled at #4014
 103  4014               IF (SOUND_CMDS == 1)
 104  4014              	INCBIN "bin/AKG.bin"
 105  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 106  4CF0               ENDIF
 107  4CF0
 108  4CF0              ORIG.HTIMI:
 109  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 109  4CF4 00
 110  4CF5               EXPORT ORIG.HTIMI
 111  4CF5
 112  4CF5               IF (SOUND_CMDS == 1)
 113  4CF5              MUSIC_INIT_STATUS:
 114  4CF5 00            DB 0
 115  4CF6              SFX_INIT_STATUS:
 116  4CF6 00            DB 0
 117  4CF7              SOUND_ENABLED:
 118  4CF7 00            DB 0
 119  4CF8               ENDIF
 120  4CF8
 121  4CF8               IF (SPRITE_CMDS == 1)
 122  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD CF 53     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD F2 54     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD F2 54     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD F2 54     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD F2 54     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 12 55     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 12 55     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 12 55     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD F2 54     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD F2 54     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD F2 54     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD F2 54     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD F2 54     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD F2 54     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 12 55     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 12 55     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD F2 54     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD F2 54     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD F2 54     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD F2 54     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD F2 54     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD E5 53         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD 2C 54         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD 1C 54         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 123  4F4D               ENDIF
 124  4F4D
 125  4F4D               IF (ANIM_CMDS == 1)
 126  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E 9A 5D         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 9A 5D         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 9A 5D         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; ANIMATION DEFINITION
  31+ 4F56              ; byte number of items 1-15
  32+ 4F56              ; byte[15] anim_item;
  33+ 4F56              ; total size = 16b
  34+ 4F56
  35+ 4F56              ; SPRITE ANIMATION
  36+ 4F56              ; +00 byte sprite number;
  37+ 4F56              ; +01 word time;
  38+ 4F56              ; +03 byte current item;
  39+ 4F56              ; +04 byte animation definition;
  40+ 4F56              ; +05 byte cyclic;
  41+ 4F56              ; +06 byte active;
  42+ 4F56              ; +07 byte reserved
  43+ 4F56              ; total size = 8b
  44+ 4F56
  45+ 4F56              ; *******************************************************************************************************
  46+ 4F56              ; helper function HL=A*5
  47+ 4F56              ; changes HL,DE;
  48+ 4F56              Ax5:
  49+ 4F56 26 00            LD H,0
  50+ 4F58 6F               LD L,A
  51+ 4F59 54               LD D,H
  52+ 4F5A 5D               LD E,L
  53+ 4F5B 29               ADD HL,HL
  54+ 4F5C 29               ADD HL,HL
  55+ 4F5D 19               ADD HL,DE
  56+ 4F5E C9               RET
  57+ 4F5F              ; *******************************************************************************************************
  58+ 4F5F
  59+ 4F5F              ; *******************************************************************************************************
  60+ 4F5F              ; function to handle CALL MAXANIMITEMS basic extension
  61+ 4F5F              ; MAXANIMITEMS (BYTE number)
  62+ 4F5F              ; sets new number and moves memory buffers as needed
  63+ 4F5F              MAXANIMITEMS:
  64+ 4F5F              	; opening (
  65+ 4F5F CD F2 54     	CALL CHKCHAR
  66+ 4F62 28           	DB '('
  67+ 4F63              	; get value
  68+ 4F63 DD 21 1C 52  	LD IX, GETBYT
  69+ 4F67 CD 59 01     	CALL CALBAS
  70+ 4F6A F5               PUSH AF
  71+ 4F6B              	; ending )
  72+ 4F6B CD F2 54     	CALL CHKCHAR
  73+ 4F6E 29           	DB ')'
  74+ 4F6F F1               POP AF
  75+ 4F70
  76+ 4F70              	; save position
  77+ 4F70 E5           	PUSH HL
  78+ 4F71              .ENTRY:
  79+ 4F71 47               LD B,A
  80+ 4F72 3A 4D 4F         LD A,(ANIMITEMNUM)
  81+ 4F75 90               SUB B
  82+ 4F76 28 1F            JR Z, .EXIT; same value as before
  83+ 4F78 FD 21 51 4F      LD IY,ANIMDEFPTR
  84+ 4F7C FA 9A 4F         JP M, .INCREASE
  85+ 4F7F                  ; new value is lower than previous one
  86+ 4F7F CD B2 4F         CALL .SIZEDIFF
  87+ 4F82 CD CD 4F         CALL .DECREASE_COMMON
  88+ 4F85 2A 54 4F         LD HL,(ANIMSPRPTR)
  89+ 4F88 AF               XOR A
  90+ 4F89 ED 42            SBC HL,BC
  91+ 4F8B 22 54 4F         LD (ANIMSPRPTR),HL
  92+ 4F8E              .E1:
  93+ 4F8E 2A 10 40         LD HL,(FREEMEMPTR)
  94+ 4F91 AF               XOR A
  95+ 4F92 ED 42            SBC HL,BC
  96+ 4F94 22 10 40         LD (FREEMEMPTR),HL
  97+ 4F97              .EXIT:
  98+ 4F97 FB               EI
  99+ 4F98 E1           	POP HL
 100+ 4F99 C9           	RET
 101+ 4F9A              .INCREASE:
 102+ 4F9A ED 44            NEG
 103+ 4F9C CD B2 4F         CALL .SIZEDIFF
 104+ 4F9F CD F9 4F         CALL .INCREASE_COMMON
 105+ 4FA2 2A 54 4F         LD HL,(ANIMSPRPTR)
 106+ 4FA5 09               ADD HL,BC
 107+ 4FA6 22 54 4F         LD (ANIMSPRPTR),HL
 108+ 4FA9              .E2:
 109+ 4FA9 2A 10 40         LD HL,(FREEMEMPTR)
 110+ 4FAC 09               ADD HL,BC
 111+ 4FAD 22 10 40         LD (FREEMEMPTR),HL
 112+ 4FB0 18 E5            JR .EXIT
 113+ 4FB2              .SIZEDIFF:
 114+ 4FB2 CD 56 4F         CALL Ax5
 115+ 4FB5 78               LD A,B
 116+ 4FB6 32 4D 4F         LD (ANIMITEMNUM),A
 117+ 4FB9 44               LD B,H
 118+ 4FBA 4D               LD C,L
 119+ 4FBB C9               RET ; BC=size difference in bytes
 120+ 4FBC              .SIZETOMOVE:
 121+ 4FBC D5               PUSH DE
 122+ 4FBD 2A 10 40         LD HL,(FREEMEMPTR)
 123+ 4FC0 FD 5E 00         LD E,(IY)
 124+ 4FC3 FD 56 01         LD D,(IY+1)
 125+ 4FC6 AF               XOR A
 126+ 4FC7 ED 52            SBC HL,DE
 127+ 4FC9 44               LD B,H
 128+ 4FCA 4D               LD C,L
 129+ 4FCB D1               POP DE
 130+ 4FCC C9               RET
 131+ 4FCD              .DECREASE_COMMON:
 132+ 4FCD FD 6E 00         LD L,(IY)
 133+ 4FD0 FD 66 01         LD H,(IY+1)
 134+ 4FD3 AF               XOR A
 135+ 4FD4 ED 42            SBC HL,BC
 136+ 4FD6 EB               EX DE,HL
 137+ 4FD7 C5               PUSH BC
 138+ 4FD8 CD BC 4F         CALL .SIZETOMOVE
 139+ 4FDB F3               DI
 140+ 4FDC 78               LD A,B
 141+ 4FDD B1               OR C
 142+ 4FDE 28 08            JR Z,.L1
 143+ 4FE0 FD 6E 00         LD L,(IY)
 144+ 4FE3 FD 66 01         LD H,(IY+1)
 145+ 4FE6 ED B0            LDIR
 146+ 4FE8              .L1:
 147+ 4FE8 C1               POP BC
 148+ 4FE9 FD 6E 00         LD L,(IY)
 149+ 4FEC FD 66 01         LD H,(IY+1)
 150+ 4FEF AF               XOR A
 151+ 4FF0 ED 42            SBC HL,BC
 152+ 4FF2 FD 75 00         LD (IY),L
 153+ 4FF5 FD 74 01         LD (IY+1),H
 154+ 4FF8 C9               RET
 155+ 4FF9              .INCREASE_COMMON:
 156+ 4FF9 2A 10 40         LD HL,(FREEMEMPTR)
 157+ 4FFC 2B               DEC HL
 158+ 4FFD AF               XOR A
 159+ 4FFE ED 42            SBC HL,BC
 160+ 5000 EB               EX DE,HL
 161+ 5001 C5               PUSH BC
 162+ 5002 CD BC 4F         CALL .SIZETOMOVE
 163+ 5005 F3               DI
 164+ 5006 78               LD A,B
 165+ 5007 B1               OR C
 166+ 5008 28 06            JR Z,.L2
 167+ 500A 2A 10 40         LD HL,(FREEMEMPTR)
 168+ 500D 2B               DEC HL
 169+ 500E ED B8            LDDR
 170+ 5010              .L2:
 171+ 5010 C1               POP BC
 172+ 5011 FD 6E 00         LD L,(IY)
 173+ 5014 FD 66 01         LD H,(IY+1)
 174+ 5017 09               ADD HL,BC
 175+ 5018 FD 75 00         LD (IY),L
 176+ 501B FD 74 01         LD (IY+1),H
 177+ 501E C9               RET
 178+ 501F              ; *******************************************************************************************************
 179+ 501F
 180+ 501F              ; *******************************************************************************************************
 181+ 501F              ; function to handle CALL ANIMITEMPAT basic extension
 182+ 501F              ; ANIMITEMPAT ( BYTE id,
 183+ 501F              ;               INT ticks,
 184+ 501F              ;               BYTE pattern,
 185+ 501F              ;               BYTE color )
 186+ 501F              ; fills animation item data, returns an error if out of bounds
 187+ 501F              ANIMITEMPAT:
 188+ 501F                  ; opening (
 189+ 501F CD F2 54     	CALL CHKCHAR
 190+ 5022 28           	DB '('
 191+ 5023              	; get id
 192+ 5023 DD 21 1C 52  	LD IX, GETBYT
 193+ 5027 CD 59 01     	CALL CALBAS
 194+ 502A F5               PUSH AF
 195+ 502B                  ; check if out of bounds
 196+ 502B 3C               INC A
 197+ 502C 4F               LD C,A
 198+ 502D 3A 4D 4F         LD A,(ANIMITEMNUM)
 199+ 5030 B9               CP C
 200+ 5031 DA 08 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 201+ 5034              	; comma
 202+ 5034 CD F2 54     	CALL CHKCHAR
 203+ 5037 2C           	DB ','
 204+ 5038              	; get ticks
 205+ 5038 DD 21 2F 54  	LD IX, FRMQNT
 206+ 503C CD 59 01     	CALL CALBAS
 207+ 503F D5           	PUSH DE
 208+ 5040              	; comma
 209+ 5040 CD F2 54     	CALL CHKCHAR
 210+ 5043 2C           	DB ','
 211+ 5044              	; get pattern
 212+ 5044 DD 21 1C 52  	LD IX, GETBYT
 213+ 5048 CD 59 01     	CALL CALBAS
 214+ 504B F5               PUSH AF
 215+ 504C              	; comma
 216+ 504C CD F2 54     	CALL CHKCHAR
 217+ 504F 2C           	DB ','
 218+ 5050              	; get color
 219+ 5050 DD 21 1C 52  	LD IX, GETBYT
 220+ 5054 CD 59 01     	CALL CALBAS
 221+ 5057 F5               PUSH AF
 222+ 5058              	; ending )
 223+ 5058 CD F2 54     	CALL CHKCHAR
 224+ 505B 29           	DB ')'
 225+ 505C              .ENTRY:
 226+ 505C E5               PUSH HL
 227+ 505D DD E1            POP IX
 228+ 505F D9               EXX
 229+ 5060 C1               POP BC ; color
 230+ 5061 D1               POP DE ; pattern
 231+ 5062 E1               POP HL ; ticks
 232+ 5063 D9               EXX
 233+ 5064 F1               POP AF
 234+ 5065 CD 56 4F         CALL Ax5
 235+ 5068 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 236+ 506C 19               ADD HL,DE
 237+ 506D E5               PUSH HL
 238+ 506E FD E1            POP IY
 239+ 5070 D9               EXX
 240+ 5071 FD 36 00 00      LD (IY),0 ; type=0
 241+ 5075 FD 75 01         LD (IY+1),L
 242+ 5078 FD 74 02         LD (IY+2),H
 243+ 507B FD 72 03         LD (IY+3),D
 244+ 507E FD 70 04         LD (IY+4),B
 245+ 5081
 246+ 5081 DD E5            PUSH IX
 247+ 5083 E1               POP HL
 248+ 5084 C9               RET
 249+ 5085              ; *******************************************************************************************************
 250+ 5085
 251+ 5085              ; *******************************************************************************************************
 252+ 5085              ; function to handle CALL ANIMITEMPTR basic extension
 253+ 5085              ; ANIMITEMPTR ( BYTE id,
 254+ 5085              ;               INT ticks,
 255+ 5085              ;               INT pointer,
 256+ 5085              ; fills animation item data, returns an error if out of bounds
 257+ 5085              ANIMITEMPTR_CMD:
 258+ 5085                  ; opening (
 259+ 5085 CD F2 54     	CALL CHKCHAR
 260+ 5088 28           	DB '('
 261+ 5089              	; get id
 262+ 5089 DD 21 1C 52  	LD IX, GETBYT
 263+ 508D CD 59 01     	CALL CALBAS
 264+ 5090 F5               PUSH AF
 265+ 5091                  ; check if out of bounds
 266+ 5091 3C               INC A
 267+ 5092 4F               LD C,A
 268+ 5093 3A 4D 4F         LD A,(ANIMITEMNUM)
 269+ 5096 B9               CP C
 270+ 5097 DA 08 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 271+ 509A              	; comma
 272+ 509A CD F2 54     	CALL CHKCHAR
 273+ 509D 2C           	DB ','
 274+ 509E              	; get ticks
 275+ 509E DD 21 2F 54  	LD IX, FRMQNT
 276+ 50A2 CD 59 01     	CALL CALBAS
 277+ 50A5 D5           	PUSH DE
 278+ 50A6              	; comma
 279+ 50A6 CD F2 54     	CALL CHKCHAR
 280+ 50A9 2C           	DB ','
 281+ 50AA              	; get pointer
 282+ 50AA DD 21 2F 54  	LD IX, FRMQNT
 283+ 50AE CD 59 01     	CALL CALBAS
 284+ 50B1 D5           	PUSH DE
 285+ 50B2              	; ending )
 286+ 50B2 CD F2 54     	CALL CHKCHAR
 287+ 50B5 29           	DB ')'
 288+ 50B6              .ENTRY:
 289+ 50B6 E5               PUSH HL
 290+ 50B7 DD E1            POP IX
 291+ 50B9 D9               EXX
 292+ 50BA D1               POP DE ; pointer
 293+ 50BB E1               POP HL ; ticks
 294+ 50BC D9               EXX
 295+ 50BD F1               POP AF
 296+ 50BE CD 56 4F         CALL Ax5
 297+ 50C1 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 298+ 50C5 19               ADD HL,DE
 299+ 50C6 E5               PUSH HL
 300+ 50C7 FD E1            POP IY
 301+ 50C9 D9               EXX
 302+ 50CA FD 36 00 01      LD (IY),1 ; type=1
 303+ 50CE FD 75 01         LD (IY+1),L
 304+ 50D1 FD 74 02         LD (IY+2),H
 305+ 50D4 FD 73 03         LD (IY+3),E
 306+ 50D7 FD 72 04         LD (IY+4),D
 307+ 50DA
 308+ 50DA DD E5            PUSH IX
 309+ 50DC E1               POP HL
 310+ 50DD C9               RET
 311+ 50DE              ; *******************************************************************************************************
 312+ 50DE
 313+ 50DE              ; *******************************************************************************************************
 314+ 50DE              ; function to handle CALL MAXANIMDEFS basic extension
 315+ 50DE              ; MAXANIMDEFS (BYTE number)
 316+ 50DE              ; sets new number and moves memory buffers as needed
 317+ 50DE              MAXANIMDEFS:
 318+ 50DE              	; opening (
 319+ 50DE CD F2 54     	CALL CHKCHAR
 320+ 50E1 28           	DB '('
 321+ 50E2              	; get value
 322+ 50E2 DD 21 1C 52  	LD IX, GETBYT
 323+ 50E6 CD 59 01     	CALL CALBAS
 324+ 50E9 F5               PUSH AF
 325+ 50EA              	; ending )
 326+ 50EA CD F2 54     	CALL CHKCHAR
 327+ 50ED 29           	DB ')'
 328+ 50EE F1               POP AF
 329+ 50EF
 330+ 50EF              	; save position
 331+ 50EF E5           	PUSH HL
 332+ 50F0              .ENTRY:
 333+ 50F0 47               LD B,A
 334+ 50F1 3A 50 4F         LD A,(ANIMDEFNUM)
 335+ 50F4 90               SUB B
 336+ 50F5 CA 97 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 337+ 50F8 FD 21 54 4F      LD IY,ANIMSPRPTR
 338+ 50FC FA 08 51         JP M, .INCREASE
 339+ 50FF                  ; new value is lower than previous one
 340+ 50FF CD 13 51         CALL .SIZEDIFF
 341+ 5102 CD CD 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 342+ 5105 C3 8E 4F         JP MAXANIMITEMS.E1
 343+ 5108              .INCREASE:
 344+ 5108 ED 44            NEG
 345+ 510A CD 13 51         CALL .SIZEDIFF
 346+ 510D CD F9 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 347+ 5110 C3 A9 4F         JP MAXANIMITEMS.E2
 348+ 5113              .SIZEDIFF:
 349+ 5113 26 00            LD H,0
 350+ 5115 6F               LD L,A
 351+ 5116 CD E0 53         CALL HLx16
 352+ 5119 78               LD A,B
 353+ 511A 32 50 4F         LD (ANIMDEFNUM),A
 354+ 511D 44               LD B,H
 355+ 511E 4D               LD C,L
 356+ 511F C9               RET ; BC=size difference in bytes
 357+ 5120              ; *******************************************************************************************************
 358+ 5120
 359+ 5120              ; *******************************************************************************************************
 360+ 5120              ; function to handle CALL ANIMDEF basic extension
 361+ 5120              ; ANIMITEMPAT ( BYTE id,
 362+ 5120              ;               BYTE size,
 363+ 5120              ;               INT[] list )
 364+ 5120              ; fills animation definition data, returns an error if out of bounds, or invalid type
 365+ 5120              ANIMDEF:
 366+ 5120                  ; opening (
 367+ 5120 CD F2 54     	CALL CHKCHAR
 368+ 5123 28           	DB '('
 369+ 5124              	; get id
 370+ 5124 DD 21 1C 52  	LD IX, GETBYT
 371+ 5128 CD 59 01     	CALL CALBAS
 372+ 512B F5               PUSH AF
 373+ 512C                  ; check if out of bounds
 374+ 512C 3C               INC A
 375+ 512D 4F               LD C,A
 376+ 512E 3A 50 4F         LD A,(ANIMDEFNUM)
 377+ 5131 B9               CP C
 378+ 5132 DA 08 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 379+ 5135              	; comma
 380+ 5135 CD F2 54     	CALL CHKCHAR
 381+ 5138 2C           	DB ','
 382+ 5139              	; get size
 383+ 5139 DD 21 1C 52  	LD IX, GETBYT
 384+ 513D CD 59 01     	CALL CALBAS
 385+ 5140 FE 10            CP 16
 386+ 5142 D2 0C 55         JP NC, OVERFLOW
 387+ 5145 B7               OR A
 388+ 5146 CA 0C 55         JP Z, OVERFLOW
 389+ 5149 F5           	PUSH AF
 390+ 514A              	; comma
 391+ 514A CD F2 54     	CALL CHKCHAR
 392+ 514D 2C           	DB ','
 393+ 514E              	; get pointer to a list of animation items in integer array format
 394+ 514E 3E 01            LD A,1
 395+ 5150 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 396+ 5153 DD 21 A4 5E  	LD IX, PTRGET
 397+ 5157 CD 59 01     	CALL CALBAS
 398+ 515A                  ; contrary to documentation we get a pointer to array dimension in BC
 399+ 515A                  ; and type in VALTYP
 400+ 515A 3A 63 F6         LD A,(VALTYP)
 401+ 515D FE 02            CP 2
 402+ 515F C2 04 55         JP NZ,TYPE_MISMATCH
 403+ 5162 0A               LD A,(BC)
 404+ 5163 FE 01            CP 1
 405+ 5165 C2 04 55         JP NZ,TYPE_MISMATCH
 406+ 5168 03               INC BC
 407+ 5169 0A               LD A,(BC)
 408+ 516A D1               POP DE
 409+ 516B D5               PUSH DE
 410+ 516C 3C               INC A
 411+ 516D BA               CP D
 412+ 516E DA 08 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 413+ 5171 03          > INC BC
 413+ 5172 03          > INC BC
 414+ 5173 C5               PUSH BC
 415+ 5174              	; ending )
 416+ 5174 CD F2 54     	CALL CHKCHAR
 417+ 5177 29           	DB ')'
 418+ 5178              .ENTRY:
 419+ 5178 E5               PUSH HL
 420+ 5179 DD E1            POP IX
 421+ 517B D1               POP DE ; pointer to INT array
 422+ 517C C1               POP BC ; B=item number
 423+ 517D F1               POP AF ; id
 424+ 517E 26 00            LD H,0
 425+ 5180 6F               LD L,A
 426+ 5181 CD E0 53         CALL HLx16
 427+ 5184 D5               PUSH DE
 428+ 5185 ED 5B 51 4F      LD DE,(ANIMDEFPTR)
 429+ 5189 19               ADD HL,DE
 430+ 518A D1               POP DE
 431+ 518B 70               LD (HL),B
 432+ 518C              .L1:
 433+ 518C 23               INC HL
 434+ 518D 1A               LD A,(DE)
 435+ 518E 13          > INC DE
 435+ 518F 13          > INC DE
 436+ 5190 77               LD (HL),A
 437+ 5191 10 F9            DJNZ .L1
 438+ 5193 DD E5            PUSH IX
 439+ 5195 E1               POP HL
 440+ 5196 C9               RET
 441+ 5197              ; *******************************************************************************************************
 442+ 5197
 443+ 5197              ; *******************************************************************************************************
 444+ 5197              ; function to handle CALL MAXANIMSPRS basic extension
 445+ 5197              ; MAXANIMSPRS (BYTE number)
 446+ 5197              ; sets new number and moves memory buffers as needed
 447+ 5197              MAXANIMSPRS:
 448+ 5197              	; opening (
 449+ 5197 CD F2 54     	CALL CHKCHAR
 450+ 519A 28           	DB '('
 451+ 519B              	; get value
 452+ 519B DD 21 1C 52  	LD IX, GETBYT
 453+ 519F CD 59 01     	CALL CALBAS
 454+ 51A2 F5               PUSH AF
 455+ 51A3              	; ending )
 456+ 51A3 CD F2 54     	CALL CHKCHAR
 457+ 51A6 29           	DB ')'
 458+ 51A7 F1               POP AF
 459+ 51A8
 460+ 51A8              	; save position
 461+ 51A8 E5           	PUSH HL
 462+ 51A9              .ENTRY:
 463+ 51A9 47               LD B,A
 464+ 51AA 3A 53 4F         LD A,(ANIMSPRNUM)
 465+ 51AD 90               SUB B
 466+ 51AE CA 97 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 467+ 51B1 FD 21 10 40      LD IY,FREEMEMPTR
 468+ 51B5 FA C1 51         JP M, .INCREASE
 469+ 51B8                  ; new value is lower than previous one
 470+ 51B8 CD E0 51         CALL .SIZEDIFF
 471+ 51BB CD CD 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 472+ 51BE C3 97 4F         JP MAXANIMITEMS.EXIT
 473+ 51C1              .INCREASE:
 474+ 51C1 ED 44            NEG
 475+ 51C3 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 476+ 51C4 CD E0 51         CALL .SIZEDIFF
 477+ 51C7 CD F9 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 478+ 51CA AF               XOR A
 479+ 51CB ED 42            SBC HL,BC ; location of new stuff
 480+ 51CD F1               POP AF
 481+ 51CE 47               LD B,A
 482+ 51CF 11 08 00         LD DE,8
 483+ 51D2 E5               PUSH HL
 484+ 51D3 DD E1            POP IX
 485+ 51D5              .L1:
 486+ 51D5 DD 36 06 00      LD (IX+6),0
 487+ 51D9 DD 19            ADD IX,DE
 488+ 51DB 10 F8            DJNZ .L1
 489+ 51DD C3 97 4F         JP MAXANIMITEMS.EXIT
 490+ 51E0              .SIZEDIFF:
 491+ 51E0 26 00            LD H,0
 492+ 51E2 6F               LD L,A
 493+ 51E3 CD E1 53         CALL HLx8
 494+ 51E6 78               LD A,B
 495+ 51E7 32 53 4F         LD (ANIMSPRNUM),A
 496+ 51EA 44               LD B,H
 497+ 51EB 4D               LD C,L
 498+ 51EC C9               RET ; BC=size difference in bytes
 499+ 51ED              ; *******************************************************************************************************
 500+ 51ED
 501+ 51ED              ; *******************************************************************************************************
 502+ 51ED              ; function to handle CALL ANIMSPRITE basic extension
 503+ 51ED              ; ANIMSPRITE ( BYTE id,
 504+ 51ED              ;              BYTE sprite_number,
 505+ 51ED              ;              BYTE animation_definition_id,
 506+ 51ED              ;              BYTE cyclic_flag )
 507+ 51ED              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 508+ 51ED              ANIMSPRITE:
 509+ 51ED                  ; opening (
 510+ 51ED CD F2 54     	CALL CHKCHAR
 511+ 51F0 28           	DB '('
 512+ 51F1              	; get sprite animation id
 513+ 51F1 DD 21 1C 52  	LD IX, GETBYT
 514+ 51F5 CD 59 01     	CALL CALBAS
 515+ 51F8 F5               PUSH AF
 516+ 51F9 3C               INC A
 517+ 51FA 4F               LD C,A
 518+ 51FB 3A 53 4F         LD A,(ANIMSPRNUM)
 519+ 51FE B9               CP C
 520+ 51FF DA 08 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 521+ 5202              	; comma
 522+ 5202 CD F2 54     	CALL CHKCHAR
 523+ 5205 2C           	DB ','
 524+ 5206              	; get sprite number
 525+ 5206 DD 21 1C 52  	LD IX, GETBYT
 526+ 520A CD 59 01     	CALL CALBAS
 527+ 520D F5               PUSH AF
 528+ 520E                  ; check if out of bounds
 529+ 520E FE 20            CP 32
 530+ 5210 D2 08 55         JP NC, SUBSCRIPT_OUT_OF_RANGE
 531+ 5213              	; comma
 532+ 5213 CD F2 54     	CALL CHKCHAR
 533+ 5216 2C           	DB ','
 534+ 5217              	; get animation definition id
 535+ 5217 DD 21 1C 52  	LD IX, GETBYT
 536+ 521B CD 59 01     	CALL CALBAS
 537+ 521E F5               PUSH AF
 538+ 521F 3C               INC A
 539+ 5220 4F               LD C,A
 540+ 5221 3A 50 4F         LD A,(ANIMDEFNUM)
 541+ 5224 B9               CP C
 542+ 5225 DA 08 55         JP C,SUBSCRIPT_OUT_OF_RANGE
 543+ 5228              	; comma
 544+ 5228 CD F2 54     	CALL CHKCHAR
 545+ 522B 2C           	DB ','
 546+ 522C              	; get cyclic flag
 547+ 522C DD 21 1C 52  	LD IX, GETBYT
 548+ 5230 CD 59 01         CALL CALBAS
 549+ 5233 F5           	PUSH AF
 550+ 5234              	; ending )
 551+ 5234 CD F2 54     	CALL CHKCHAR
 552+ 5237 29           	DB ')'
 553+ 5238              .ENTRY:
 554+ 5238 E5               PUSH HL
 555+ 5239 DD E1            POP IX
 556+ 523B D9               EXX
 557+ 523C D1               POP DE ; cyclic
 558+ 523D C1               POP BC ; animation definition id
 559+ 523E E1               POP HL ; sprite number
 560+ 523F D9               EXX
 561+ 5240 F1               POP AF ; sprite animation id
 562+ 5241 26 00            LD H,0
 563+ 5243 6F               LD L,A
 564+ 5244 CD E1 53         CALL HLx8
 565+ 5247 ED 5B 54 4F      LD DE,(ANIMSPRPTR)
 566+ 524B 19               ADD HL,DE
 567+ 524C E5               PUSH HL
 568+ 524D FD E1            POP IY
 569+ 524F D9               EXX
 570+ 5250 FD 74 00         LD (IY),H
 571+ 5253 FD 70 04         LD (IY+4),B
 572+ 5256 FD 72 05         LD (IY+5),D
 573+ 5259                  ;LD (IY+6),0
 574+ 5259 DD E5            PUSH IX
 575+ 525B E1               POP HL
 576+ 525C C9               RET
 577+ 525D              ; *******************************************************************************************************
# file closed: asm\ANIMATION.asm
 127  525D               ENDIF
 128  525D
 129  525D              ; temp variables for BLIT, TILE functions
 130  525D               IF (BLIT_CMDS + TILE_CMDS > 0)
 131  525D              BLIT_TMP:
 132  525D              TILETMP1:
 133  525D              BLIT_TMP1:
 134  525D 00 00         DW 0
 135  525F              TILETMP2:
 136  525F              BLIT_TMP2:
 137  525F 00 00         DW 0
 138  5261                IFDEF CMDS_WITH_PARAMETERS
 139  5261              BLIT_STRUCT:
 140  5261 00 00 00...   DS 17
 141  5265                ENDIF
 142  5265               ENDIF
 143  5272
 144  5272              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 145  5272              ; per starting letter, if no commands with this letter, NULL value
 146  5272              CMDS:
 147  5272               IF (ANIM_CMDS == 1)
 148  5272 9B 53        	DW CMDS_A ;
 149  5274               ELSE
 150  5274 ~                DW 0 ; A
 151  5274               ENDIF
 152  5274               IF (BLIT_CMDS + BOX_CMDS > 0)
 153  5274 66 53            DW CMDS_B ; B
 154  5276               ELSE
 155  5276 ~            	DW 0
 156  5276               ENDIF
 157  5276 00 00            DW 0 ; C
 158  5278 00 00            DW 0 ; D
 159  527A 00 00            DW 0 ; E
 160  527C               IF (VRAM_CMDS + RAM_CMDS > 0)
 161  527C E4 52            DW CMDS_F; F
 162  527E               ELSE
 163  527E ~            	DW 0
 164  527E               ENDIF
 165  527E               IF (GENCAL_CMD > 0)
 166  527E F7 52            DW CMDS_G; G
 167  5280               ELSE
 168  5280 ~            	DW 0
 169  5280               ENDIF
 170  5280 00 00            DW 0 ; H
 171  5282 00 00            DW 0 ; I
 172  5284 00 00            DW 0 ; J
 173  5286 00 00            DW 0 ; K
 174  5288 00 00            DW 0 ; L
 175  528A               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 176  528A A6 52            DW CMDS_M ; M
 177  528C               ELSE
 178  528C ~            	DW 0
 179  528C               ENDIF
 180  528C 00 00            DW 0 ; N
 181  528E 00 00            DW 0 ; O
 182  5290 00 00            DW 0 ; P
 183  5292 00 00            DW 0 ; Q
 184  5294 00 00            DW 0 ; R
 185  5296               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 186  5296 0B 53            DW CMDS_S ; S
 187  5298               ELSE
 188  5298 ~            	DW 0
 189  5298               ENDIF
 190  5298               IF (TILE_CMDS > 0)
 191  5298 86 53            DW CMDS_T ; T
 192  529A               ELSE
 193  529A ~            	DW 0
 194  529A               ENDIF
 195  529A 00 00            DW 0 ; U
 196  529C               IF (VRAM_CMDS > 0)
 197  529C 01 53            DW CMDS_V ; V
 198  529E               ELSE
 199  529E ~            	DW 0
 200  529E               ENDIF
 201  529E 00 00            DW 0 ; W
 202  52A0 00 00            DW 0 ; X
 203  52A2 00 00            DW 0 ; Y
 204  52A4 00 00            DW 0 ; Z
 205  52A6
 206  52A6              CMDS_M:
 207  52A6               IF (VRAM_CMDS == 1)
 208  52A6 4D 45 4D 56      DB "MEMVRM", 0
 208  52AA 52 4D 00
 209  52AD 5A 56            DW MEMVRM
 210  52AF               ENDIF
 211  52AF               IF (RAM_CMDS == 1)
 212  52AF 4D 45 4D 43  	DB "MEMCPY", 0
 212  52B3 50 59 00
 213  52B6 19 55        	DW MEMCPY
 214  52B8               ENDIF
 215  52B8               IF (ANIM_CMDS == 1)
 216  52B8 4D 41 58 41  	DB "MAXANIMITEMS",0
 216  52BC 4E 49 4D 49
 216  52C0 54 45 4D 53
 216  52C4 00
 217  52C5 5F 4F        	DW MAXANIMITEMS
 218  52C7 4D 41 58 41  	DB "MAXANIMDEFS",0
 218  52CB 4E 49 4D 44
 218  52CF 45 46 53 00
 219  52D3 DE 50        	DW MAXANIMDEFS
 220  52D5 4D 41 58 41  	DB "MAXANIMSPRS",0
 220  52D9 4E 49 4D 53
 220  52DD 50 52 53 00
 221  52E1 97 51        	DW MAXANIMSPRS
 222  52E3               ENDIF
 223  52E3               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 224  52E3 00           	DB 0
 225  52E4               ENDIF
 226  52E4              CMDS_F:
 227  52E4               IF (VRAM_CMDS == 1)
 228  52E4 46 49 4C 56      DB "FILVRM", 0
 228  52E8 52 4D 00
 229  52EB 5C 55            DW FILVRM
 230  52ED               ENDIF
 231  52ED               IF (RAM_CMDS == 1)
 232  52ED 46 49 4C 52      DB "FILRAM", 0
 232  52F1 41 4D 00
 233  52F4 A3 55            DW FILRAM
 234  52F6               ENDIF
 235  52F6               IF (VRAM_CMDS + RAM_CMDS > 0)
 236  52F6 00               DB 0
 237  52F7               ENDIF
 238  52F7              CMDS_G:
 239  52F7               IF (GENCAL_CMD == 1)
 240  52F7 47 45 4E 43      DB "GENCAL", 0
 240  52FB 41 4C 00
 241  52FE 01 56            DW GENCAL
 242  5300               ENDIF
 243  5300               IF (GENCAL_CMD > 0)
 244  5300 00           	DB	0
 245  5301               ENDIF
 246  5301              CMDS_V:
 247  5301               IF (VRAM_CMDS == 1)
 248  5301 56 52 4D 4D  	DB "VRMMEM", 0
 248  5305 45 4D 00
 249  5308 D2 56        	DW VRMMEM
 250  530A               ENDIF
 251  530A               IF (VRAM_CMDS > 0)
 252  530A 00           	DB 0
 253  530B               ENDIF
 254  530B              CMDS_S:
 255  530B               IF (SPRITE_CMDS == 1)
 256  530B 53 50 52 53  	DB "SPRSET", 0
 256  530F 45 54 00
 257  5312 0E 4E        	DW SPRSET
 258  5314 53 50 52 47  	DB "SPRGRPMOV", 0
 258  5318 52 50 4D 4F
 258  531C 56 00
 259  531E CC 4E        	DW SPRGRPMOV
 260  5320               ENDIF
 261  5320               IF (SOUND_CMDS == 1)
 262  5320 53 4E 44 53  	DB "SNDSFX", 0
 262  5324 46 58 00
 263  5327 10 58        	DW SNDSFX
 264  5329 53 4E 44 50  	DB "SNDPLYON", 0
 264  532D 4C 59 4F 4E
 264  5331 00
 265  5332 DA 57        	DW SNDPLYON
 266  5334 53 4E 44 50  	DB "SNDPLYOFF", 0
 266  5338 4C 59 4F 46
 266  533C 46 00
 267  533E ED 57        	DW SNDPLYOFF
 268  5340 53 4E 44 50  	DB "SNDPLYINI", 0
 268  5344 4C 59 49 4E
 268  5348 49 00
 269  534A 90 57        	DW SNDPLYINIT
 270  534C               ENDIF
 271  534C               IF (SPRITE_CMDS == 1)
 272  534C 53 50 52 45  	DB "SPRENABLE", 0
 272  5350 4E 41 42 4C
 272  5354 45 00
 273  5356 B9 4D        	DW SPRENABLE
 274  5358 53 50 52 44  	DB "SPRDISABLE", 0
 274  535C 49 53 41 42
 274  5360 4C 45 00
 275  5363 09 4E        	DW SPRDISABLE
 276  5365               ENDIF
 277  5365               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 278  5365 00           	DB 0
 279  5366               ENDIF
 280  5366              CMDS_B:
 281  5366               IF (BLIT_CMDS == 1)
 282  5366 42 4C 49 54  	DB "BLIT", 0
 282  536A 00
 283  536B E7 59        	DW BLIT
 284  536D               ENDIF
 285  536D               IF (BOX_CMDS == 1)
 286  536D 42 4F 58 4D  	DB "BOXMEMCPY", 0
 286  5371 45 4D 43 50
 286  5375 59 00
 287  5377 1F 5D        	DW BOXMEMCPY
 288  5379 42 4F 58 4D  	DB "BOXMEMVRM", 0
 288  537D 45 4D 56 52
 288  5381 4D 00
 289  5383 53 5D        	DW BOXMEMVRM
 290  5385               ENDIF
 291  5385               IF (BLIT_CMDS + BOX_CMDS > 0)
 292  5385 00           	DB 0
 293  5386               ENDIF
 294  5386              CMDS_T:
 295  5386               IF (TILE_CMDS == 1)
 296  5386 54 49 4C 45  	DB "TILERAM", 0
 296  538A 52 41 4D 00
 297  538E 2B 5B        	DW TILERAM
 298  5390 54 49 4C 45  	DB "TILEVRM", 0
 298  5394 56 52 4D 00
 299  5398 2E 5C        	DW TILEVRM
 300  539A               ENDIF
 301  539A               IF (TILE_CMDS > 0)
 302  539A 00           	DB 0
 303  539B               ENDIF
 304  539B              CMDS_A:
 305  539B               IF (ANIM_CMDS == 1)
 306  539B 41 4E 49 4D  	DB "ANIMITEMPAT",0
 306  539F 49 54 45 4D
 306  53A3 50 41 54 00
 307  53A7 1F 50        	DW ANIMITEMPAT
 308  53A9 41 4E 49 4D  	DB "ANIMITEMPTR",0
 308  53AD 49 54 45 4D
 308  53B1 50 54 52 00
 309  53B5 85 50        	DW ANIMITEMPTR_CMD
 310  53B7 41 4E 49 4D  	DB "ANIMDEF",0
 310  53BB 44 45 46 00
 311  53BF 20 51        	DW ANIMDEF
 312  53C1 41 4E 49 4D  	DB "ANIMSPRITE",0
 312  53C5 53 50 52 49
 312  53C9 54 45 00
 313  53CC ED 51        	DW ANIMSPRITE
 314  53CE 00           	DB 0
 315  53CF               ENDIF
 316  53CF
 317  53CF               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 318  53CF              ; ****************************************************************************************************
 319  53CF              ; function sets VRAM address
 320  53CF              ; input HL=address
 321  53CF              ; modifies AF
 322  53CF              SETWRT_LOCAL:
 323  53CF 7D           	LD	A, L
 324  53D0 D3 99        	OUT	(099H), A
 325  53D2 7C           	LD	A, H
 326  53D3 E6 3F        	AND	03FH
 327  53D5 F6 40        	OR	040H
 328  53D7 D3 99        	OUT	(099H), A
 329  53D9 C9           	RET
 330  53DA              ; ****************************************************************************************************
 331  53DA               ENDIF
 332  53DA
 333  53DA               IF (VRAM_CMDS + TILE_CMDS > 0)
 334  53DA              ; ****************************************************************************************************
 335  53DA              ; function copies data from RAM to VRAM
 336  53DA              ; input HL=address in RAM
 337  53DA              ; input B=count
 338  53DA              ; modifies AF
 339  53DA              BBYTECOPY:
 340  53DA ED A3        	OUTI
 341  53DC C2 DA 53     	JP	NZ, BBYTECOPY
 342  53DF C9           	RET
 343  53E0              ; ****************************************************************************************************
 344  53E0               ENDIF
 345  53E0
 346  53E0              ; ****************************************************************************************************
 347  53E0              ; function multiplies HL by 16
 348  53E0              HLx16:
 349  53E0 29           	ADD HL,HL
 350  53E1              ; ****************************************************************************************************
 351  53E1              ; function multiplies HL by 8
 352  53E1              HLx8:
 353  53E1 29          > ADD HL, HL
 353  53E2 29          > ADD HL, HL
 353  53E3 29          > ADD HL, HL
 354  53E4 C9           	RET
 355  53E5              ; ****************************************************************************************************
 356  53E5
 357  53E5              ; ****************************************************************************************************
 358  53E5              ; function gets slot and subslot data for specific page
 359  53E5              ; input A=page (0, 1 or 2)
 360  53E5              ; output B = 0A8H register value
 361  53E5              ; output D = 0 is no subslots, 1 if yes
 362  53E5              ; output C = 0A8H value when page 3 slot equals to requested page slot
 363  53E5              ; output E = subslot value if present
 364  53E5              ; modifies AF, BC, DE, HL
 365  53E5              GET_PAGE_INFO:
 366  53E5 6F               LD L, A
 367  53E6 C6 C1            ADD A, low (EXPTBL)
 368  53E8 32 F2 53         LD (GET_PAGE_INFO_L1+1), A
 369  53EB DB A8            IN A, (0A8H)
 370  53ED 47               LD B, A
 371  53EE E6 3F            AND 03FH
 372  53F0 4F               LD C, A
 373  53F1              GET_PAGE_INFO_L1:
 374  53F1 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 375  53F4 E6 80            AND 080H
 376  53F6 28 1B            JR Z, GET_PAGE_INFO_L2
 377  53F8                  ; expanded
 378  53F8 2D               DEC L
 379  53F9 FA 18 54         JP M, GET_PAGE_INFO_L3
 380  53FC 2D               DEC L
 381  53FD FA 16 54         JP M, GET_PAGE_INFO_L4
 382  5400                  ; page 2
 383  5400 07               RLCA
 384  5401 07               RLCA
 385  5402              GET_PAGE_INFO_L5:
 386  5402 E6 C0            AND 0C0H
 387  5404 B1               OR C
 388  5405 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 389  5407 4F               LD C, A
 390  5408 3A FF FF         LD A, (0FFFFH)
 391  540B 2F               CPL
 392  540C 5F               LD E, A
 393  540D 16 01            LD D, 1
 394  540F 78               LD A, B ; return stack
 395  5410 D3 A8            OUT (0A8H), A
 396  5412 C9               RET
 397  5413              GET_PAGE_INFO_L2:
 398  5413                  ; not expanded
 399  5413 16 00            LD D, 0
 400  5415 C9               RET
 401  5416              GET_PAGE_INFO_L4:
 402  5416                  ; page 1
 403  5416 0F               RRCA
 404  5417 0F               RRCA
 405  5418              GET_PAGE_INFO_L3:
 406  5418                  ; page 0
 407  5418 0F               RRCA
 408  5419 0F               RRCA
 409  541A 18 E6            JR GET_PAGE_INFO_L5
 410  541C              ; ****************************************************************************************************
 411  541C
 412  541C              ; ****************************************************************************************************
 413  541C              ; function returns original slot and subslot info
 414  541C              ; input B = 0A8H register value
 415  541C              ; input D = 0 is no subslots, 1 if yes
 416  541C              ; input C = 0A8H value when page 3 slot equals to requested page slot
 417  541C              ; input E = subslot value if present
 418  541C              ; modifies AF, disables interrupts
 419  541C              RESTORE_PAGE_INFO:
 420  541C 7A               LD A, D
 421  541D B7               OR A
 422  541E 28 08            JR Z, RESTORE_PAGE_INFO_L1
 423  5420 79               LD A, C
 424  5421 F3           	DI
 425  5422 D3 A8            OUT (0A8H), A
 426  5424 7B               LD A, E
 427  5425 32 FF FF         LD (0FFFFH), A
 428  5428              RESTORE_PAGE_INFO_L1:
 429  5428 78               LD A, B
 430  5429 D3 A8            OUT (0A8H), A
 431  542B C9               RET
 432  542C              ; ****************************************************************************************************
 433  542C
 434  542C              ; *******************************************************************************************************
 435  542C              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 436  542C              ; INPUT:  A = SLOT ID: EXXXSSPP
 437  542C              ; E = EXPANDED FLAG
 438  542C              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 439  542C              ; PP = PRIMARY SLOT NUMBER
 440  542C              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 441  542C              ; CHANGES: AF, BC, DE
 442  542C
 443  542C              LOCAL_ENASLT:
 444  542C CD 4C 54         CALL L0353
 445  542F FA 39 54         JP M, L0340
 446  5432 DB A8            IN A, (0A8H)
 447  5434 A1               AND C
 448  5435 B0               OR B
 449  5436 D3 A8            OUT (0A8H), A
 450  5438 C9               RET
 451  5439              L0340:
 452  5439 E5               PUSH HL
 453  543A CD 71 54         CALL L0378
 454  543D 4F               LD C, A
 455  543E 06 00            LD B, 0
 456  5440 7D               LD A, L
 457  5441 A4               AND H
 458  5442 B2               OR D
 459  5443 21 C5 FC         LD HL, 0FCC5H
 460  5446 09               ADD HL, BC
 461  5447 77               LD (HL), A
 462  5448 E1               POP HL
 463  5449 79               LD A, C
 464  544A 18 E0            JR LOCAL_ENASLT
 465  544C              L0353:
 466  544C F3               DI
 467  544D F5               PUSH AF
 468  544E 7C               LD A, H
 469  544F 07               RLCA
 470  5450 07               RLCA
 471  5451 E6 03            AND 3
 472  5453 5F               LD E, A
 473  5454 3E C0            LD A, 0C0H
 474  5456              L035D:
 475  5456 07               RLCA
 476  5457 07               RLCA
 477  5458 1D               DEC E
 478  5459 F2 56 54         JP P, L035D
 479  545C 5F               LD E, A
 480  545D 2F               CPL
 481  545E 4F               LD C, A
 482  545F F1               POP AF
 483  5460 F5               PUSH AF
 484  5461 E6 03            AND 3
 485  5463 3C               INC A
 486  5464 47               LD B, A
 487  5465 3E AB            LD A, 0ABH
 488  5467              L036E:
 489  5467 C6 55            ADD A, 055H
 490  5469 10 FC            DJNZ L036E
 491  546B 57               LD D, A
 492  546C A3               AND E
 493  546D 47               LD B, A
 494  546E F1               POP AF
 495  546F A7               AND A
 496  5470 C9               RET
 497  5471              L0378:
 498  5471 F5               PUSH AF
 499  5472 7A               LD A, D
 500  5473 E6 C0            AND 0C0H
 501  5475 4F               LD C, A
 502  5476 F1               POP AF
 503  5477 F5               PUSH AF
 504  5478 57               LD D, A
 505  5479 DB A8            IN A, (0A8H)
 506  547B 47               LD B, A
 507  547C E6 3F            AND 03FH
 508  547E B1               OR C
 509  547F D3 A8            OUT (0A8H), A
 510  5481 7A               LD A, D
 511  5482 0F               RRCA
 512  5483 0F               RRCA
 513  5484 E6 03            AND 3
 514  5486 57               LD D, A
 515  5487 3E AB            LD A, 0ABH
 516  5489              L0390:
 517  5489 C6 55            ADD A, 055H
 518  548B 15               DEC D
 519  548C F2 89 54         JP P, L0390
 520  548F A3               AND E
 521  5490 57               LD D, A
 522  5491 7B               LD A, E
 523  5492 2F               CPL
 524  5493 67               LD H, A
 525  5494 3A FF FF         LD A, (0FFFFH)
 526  5497 2F               CPL
 527  5498 6F               LD L, A
 528  5499 A4               AND H
 529  549A B2               OR D
 530  549B 32 FF FF         LD (0FFFFH), A
 531  549E 78               LD A, B
 532  549F D3 A8            OUT (0A8H), A
 533  54A1 F1               POP AF
 534  54A2 E6 03            AND 3
 535  54A4 C9               RET
 536  54A5              ; *******************************************************************************************************
 537  54A5
 538  54A5              ; *******************************************************************************************************
 539  54A5              ; some common code to activate page 0 and place values needed to restore original page on stack
 540  54A5              ; input IY=return address
 541  54A5              ENABLE_PAGE0:
 542  54A5 AF               XOR A
 543  54A6 CD E5 53         CALL GET_PAGE_INFO
 544  54A9 C5               PUSH BC
 545  54AA D5               PUSH DE
 546  54AB 3A 41 F3         LD A, (RAMAD0)
 547  54AE 26 00            LD H, 0
 548  54B0 CD 2C 54         CALL LOCAL_ENASLT
 549  54B3 FD E9        	JP (IY)
 550  54B5              ; *******************************************************************************************************
 551  54B5
 552  54B5              ; General BASIC CALL-instruction handler
 553  54B5              CALLHAND:
 554  54B5 E5           	PUSH HL
 555  54B6 21 72 52     	LD	HL, CMDS ; pointer table based on starting letter
 556  54B9 3A 89 FD         LD A, (PROCNM)
 557  54BC D6 41            SUB 'A'
 558  54BE 87               ADD A, A
 559  54BF 16 00            LD D, 0
 560  54C1 5F               LD E, A
 561  54C2 19               ADD HL, DE
 562  54C3 5E               LD E, (HL)
 563  54C4 23               INC HL
 564  54C5 56               LD D, (HL)
 565  54C6 7A               LD A, D
 566  54C7 B3               OR E
 567  54C8 28 23            JR Z, .CMDNOTRECOGNIZED
 568  54CA EB               EX DE, HL
 569  54CB              .CHKCMD:
 570  54CB 11 89 FD     	LD	DE, PROCNM
 571  54CE 1A           .LOOP:	LD	A,(DE)
 572  54CF BE           	CP	(HL)
 573  54D0 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 574  54D2 13           	INC	DE
 575  54D3 23           	INC	HL
 576  54D4 A7           	AND	A
 577  54D5 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 578  54D7 5E           	LD	E,(HL)
 579  54D8 23           	INC	HL
 580  54D9 56           	LD	D,(HL)
 581  54DA E1           	POP	HL		; routine address
 582  54DB CD FC 54     	CALL	GETPREVCHAR
 583  54DE CD F0 54     	CALL	.CALLDE		; Call routine
 584  54E1 A7           	AND	A
 585  54E2 C9           	RET
 586  54E3
 587  54E3              .TONEXTCMD:
 588  54E3 0E FF        	LD	C,0FFH
 589  54E5 AF           	XOR	A
 590  54E6 ED B1        	CPIR			; Skip to end of instruction name
 591  54E8 23           	INC	HL
 592  54E9 23           	INC	HL		; Skip address
 593  54EA BE           	CP	(HL)
 594  54EB 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 595  54ED              .CMDNOTRECOGNIZED:
 596  54ED E1           	POP	HL
 597  54EE 37               SCF
 598  54EF C9           	RET
 599  54F0
 600  54F0              .CALLDE:
 601  54F0 D5           	PUSH	DE
 602  54F1 C9           	RET
 603  54F2
 604  54F2              ;---------------------------
 605  54F2
 606  54F2              ;GETSTRPNT:
 607  54F2              ; OUT:
 608  54F2              ; HL = String Address
 609  54F2              ; B  = Lenght
 610  54F2              ;        LD      HL,(USR)
 611  54F2              ;        LD      B,(HL)
 612  54F2              ;        INC     HL
 613  54F2              ;        LD      E,(HL)
 614  54F2              ;        INC     HL
 615  54F2              ;        LD      D,(HL)
 616  54F2              ;        EX      DE,HL
 617  54F2              ;        RET
 618  54F2
 619  54F2              ;EVALTXTPARAM:
 620  54F2              ;	CALL	CHKCHAR
 621  54F2              ;	DEFB	"("             ; Check for (
 622  54F2              ;	LD	IX,FRMEVL
 623  54F2              ;	CALL	CALBAS		; Evaluate expression
 624  54F2              ;       LD      A,(VALTYP)
 625  54F2              ;        CP      3               ; Text type?
 626  54F2              ;        JP      NZ,TYPE_MISMATCH
 627  54F2              ;        PUSH	HL
 628  54F2              ;        LD	IX,FRESTR         ; Free the temporary string
 629  54F2              ;        CALL	CALBAS
 630  54F2              ;        POP	HL
 631  54F2              ;	CALL	CHKCHAR
 632  54F2              ;	DEFB	")"             ; Check for )
 633  54F2              ;        RET
 634  54F2
 635  54F2
 636  54F2              CHKCHAR:
 637  54F2 CD FC 54     	CALL	GETPREVCHAR	; Get previous basic char
 638  54F5 E3           	EX	(SP),HL
 639  54F6 BE           	CP	(HL) 	        ; Check if good char
 640  54F7 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 641  54F9 23           	INC	HL
 642  54FA E3           	EX	(SP),HL
 643  54FB 23           	INC	HL		; Get next basic char
 644  54FC
 645  54FC              GETPREVCHAR:
 646  54FC 2B           	DEC	HL
 647  54FD DD 21 66 46  	LD	IX,CHRGTR
 648  5501 C3 59 01     	JP      CALBAS
 649  5504
 650  5504
 651  5504              TYPE_MISMATCH:
 652  5504 1E 0D            LD E, 13 ; Type mismatch
 653  5506 18 0A            JR THROW_ERROR
 654  5508              SUBSCRIPT_OUT_OF_RANGE:
 655  5508 1E 09            LD E,9 ; subscript out of range
 656  550A 18 06        	JR THROW_ERROR
 657  550C              OVERFLOW:
 658  550C 1E 06        	LD E,6
 659  550E 18 02        	JR THROW_ERROR
 660  5510              SYNTAX_ERROR:
 661  5510 1E 02            LD E, 2 ; Syntax error
 662  5512              THROW_ERROR:
 663  5512 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 664  5516 C3 59 01     	JP	CALBAS
 665  5519
 666  5519              ;---------------------------
 667  5519
 668  5519               IF (RAM_CMDS == 1)
 669  5519              ; *******************************************************************************************************
 670  5519              ; function to handle CALL MEMCPY basic extension
 671  5519              ; _MEMCPY ( INT source,
 672  5519              ;			INT destination,
 673  5519              ;			INT count,
 674  5519              ; will put ram in page 0 also, page 1 is already there
 675  5519              MEMCPY:
 676  5519              	; opening (
 677  5519 CD F2 54     	CALL CHKCHAR
 678  551C 28           	DB '('
 679  551D              	; get source address
 680  551D DD 21 2F 54  	LD IX, FRMQNT
 681  5521 CD 59 01     	CALL CALBAS
 682  5524 D5           	PUSH DE
 683  5525              	; comma
 684  5525 CD F2 54     	CALL CHKCHAR
 685  5528 2C           	DB ','
 686  5529              	; get destination address
 687  5529 DD 21 2F 54  	LD IX, FRMQNT
 688  552D CD 59 01     	CALL CALBAS
 689  5530 D5           	PUSH DE
 690  5531              	; comma
 691  5531 CD F2 54     	CALL CHKCHAR
 692  5534 2C           	DB ','
 693  5535              	; get length
 694  5535 DD 21 2F 54  	LD IX, FRMQNT
 695  5539 CD 59 01     	CALL CALBAS
 696  553C D5           	PUSH DE
 697  553D              	; ending )
 698  553D CD F2 54     	CALL CHKCHAR
 699  5540 29           	DB ')'
 700  5541
 701  5541              	; save position
 702  5541 E5           	PUSH HL
 703  5542 DD E1        	POP IX
 704  5544
 705  5544 C1           	POP BC ; count
 706  5545 D1           	POP DE ; destination
 707  5546 E1           	POP HL ; source
 708  5547 D9           	EXX
 709  5548              	; enable page 0
 710  5548 FD 21 4F 55  	LD IY, .RET
 711  554C C3 A5 54     	JP ENABLE_PAGE0
 712  554F              .RET:
 713  554F FB           	EI
 714  5550 D9           	EXX
 715  5551 ED B0        	LDIR
 716  5553 D1               POP DE
 717  5554 C1               POP BC
 718  5555 CD 1C 54         CALL RESTORE_PAGE_INFO
 719  5558 DD E5        	PUSH IX
 720  555A E1           	POP HL
 721  555B C9           	RET
 722  555C              ; *******************************************************************************************************
 723  555C               ENDIF
 724  555C
 725  555C               IF (VRAM_CMDS == 1)
 726  555C              ; *******************************************************************************************************
 727  555C              ; function to handle CALL FILVRM basic extension
 728  555C              ; FILVRM ( INT offset,
 729  555C              ;		   INT count,
 730  555C              ;		   BYTE value,
 731  555C              ;		   BYTE wait_vsync) >0 = true
 732  555C              ; wait_vsync will issue HALT before copying
 733  555C              FILVRM:
 734  555C              	; opening (
 735  555C CD F2 54     	CALL CHKCHAR
 736  555F 28           	DB '('
 737  5560              	; get offset address
 738  5560 DD 21 2F 54  	LD IX, FRMQNT
 739  5564 CD 59 01     	CALL CALBAS
 740  5567 D5           	PUSH DE
 741  5568              	; comma
 742  5568 CD F2 54     	CALL CHKCHAR
 743  556B 2C           	DB ','
 744  556C              	; get count
 745  556C DD 21 2F 54  	LD IX, FRMQNT
 746  5570 CD 59 01     	CALL CALBAS
 747  5573 D5           	PUSH DE
 748  5574              	; comma
 749  5574 CD F2 54     	CALL CHKCHAR
 750  5577 2C           	DB ','
 751  5578              	; get value
 752  5578 DD 21 1C 52  	LD IX, GETBYT
 753  557C CD 59 01     	CALL CALBAS
 754  557F F5           	PUSH AF
 755  5580              	; comma
 756  5580 CD F2 54     	CALL CHKCHAR
 757  5583 2C           	DB ','
 758  5584              	; get vsync wait
 759  5584 DD 21 1C 52  	LD IX, GETBYT
 760  5588 CD 59 01     	CALL CALBAS
 761  558B F5           	PUSH AF
 762  558C              	; ending )
 763  558C CD F2 54     	CALL CHKCHAR
 764  558F 29           	DB ')'
 765  5590
 766  5590 FB               EI
 767  5591              	; save position
 768  5591 E5           	PUSH HL
 769  5592 DD E1        	POP IX
 770  5594
 771  5594              	; syntax ok
 772  5594              	; wait for vsync if needed
 773  5594 F1           	POP AF
 774  5595 B7           	OR A
 775  5596 28 01        	JR Z, .L1
 776  5598 76           	HALT
 777  5599
 778  5599              .L1:
 779  5599 F1               POP AF ; value
 780  559A C1               POP BC ; count
 781  559B E1               POP HL ; offset
 782  559C CD 56 00         CALL BIOS_FILVRM
 783  559F
 784  559F              .L3:
 785  559F DD E5        	PUSH IX
 786  55A1 E1           	POP HL
 787  55A2 C9           	RET
 788  55A3              ; *******************************************************************************************************
 789  55A3               ENDIF
 790  55A3
 791  55A3               IF (RAM_CMDS == 1)
 792  55A3              ; *******************************************************************************************************
 793  55A3              ; function to handle CALL FILRAM basic extension
 794  55A3              ; FILRAM ( INT start address,
 795  55A3              ;		   INT count,
 796  55A3              ;		   BYTE value,
 797  55A3              ; will put ram in page 0 also, page 1 is already there
 798  55A3              FILRAM:
 799  55A3              	; opening (
 800  55A3 CD F2 54     	CALL CHKCHAR
 801  55A6 28           	DB '('
 802  55A7              	; get start address
 803  55A7 DD 21 2F 54  	LD IX, FRMQNT
 804  55AB CD 59 01     	CALL CALBAS
 805  55AE D5           	PUSH DE
 806  55AF              	; comma
 807  55AF CD F2 54     	CALL CHKCHAR
 808  55B2 2C           	DB ','
 809  55B3              	; get count
 810  55B3 DD 21 2F 54  	LD IX, FRMQNT
 811  55B7 CD 59 01     	CALL CALBAS
 812  55BA D5           	PUSH DE
 813  55BB              	; comma
 814  55BB CD F2 54     	CALL CHKCHAR
 815  55BE 2C           	DB ','
 816  55BF              	; get value
 817  55BF DD 21 1C 52  	LD IX, GETBYT
 818  55C3 CD 59 01     	CALL CALBAS
 819  55C6 F5           	PUSH AF
 820  55C7              	; ending )
 821  55C7 CD F2 54     	CALL CHKCHAR
 822  55CA 29           	DB ')'
 823  55CB
 824  55CB              	; save position
 825  55CB E5           	PUSH HL
 826  55CC DD E1        	POP IX
 827  55CE
 828  55CE D1           	POP DE ; actually AF
 829  55CF C1           	POP BC ; count
 830  55D0 E1           	POP HL ; start address
 831  55D1 78           	LD A, B
 832  55D2 B7           	OR A
 833  55D3 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 834  55D5 B1           	OR C
 835  55D6 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 836  55D8 79           	LD A, C
 837  55D9 3D           	DEC A
 838  55DA 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 839  55DC              	; one byte to fill
 840  55DC 72           	LD (HL), D
 841  55DD 18 12        	JR .EXIT
 842  55DF              .L1:
 843  55DF D9           	EXX
 844  55E0              	; enable page 0
 845  55E0 FD 21 E7 55  	LD IY, .RET
 846  55E4 C3 A5 54     	JP ENABLE_PAGE0
 847  55E7              .RET:
 848  55E7 FB           	EI
 849  55E8 D9           	EXX
 850  55E9 CD F5 55     	CALL .FILLVALUE
 851  55EC D1               POP DE
 852  55ED C1               POP BC
 853  55EE CD 1C 54         CALL RESTORE_PAGE_INFO
 854  55F1              .EXIT:
 855  55F1 DD E5        	PUSH IX
 856  55F3 E1           	POP HL
 857  55F4 C9           	RET
 858  55F5
 859  55F5              .FILLVALUE:
 860  55F5 72               LD (HL), D
 861  55F6 54               LD D, H
 862  55F7 5D               LD E, L
 863  55F8 13               INC DE
 864  55F9 0B               DEC BC
 865  55FA ED B0            LDIR
 866  55FC C9               RET
 867  55FD              ; *******************************************************************************************************
 868  55FD               ENDIF
 869  55FD
 870  55FD               IF (GENCAL_CMD == 1)
 871  55FD              ; *******************************************************************************************************
 872  55FD              ; function to handle CALL GENCAL basic extension
 873  55FD              ; GENCAL ( INT fn_addr, = address of the function to call
 874  55FD              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 875  55FD              ; output values of reristers will also be stored at reg_list_ptr
 876  55FD              GENCAL_VAR_SP:
 877  55FD 00 00            DW 0
 878  55FF              GENCAL_VAR_SP2:
 879  55FF 00 00            DW 0
 880  5601              GENCAL:
 881  5601              	; opening (
 882  5601 CD F2 54     	CALL CHKCHAR
 883  5604 28           	DB '('
 884  5605              	; get function address
 885  5605 DD 21 2F 54  	LD IX, FRMQNT
 886  5609 CD 59 01     	CALL CALBAS
 887  560C D5           	PUSH DE
 888  560D              	; comma
 889  560D CD F2 54     	CALL CHKCHAR
 890  5610 2C           	DB ','
 891  5611              	; get pointer to register list
 892  5611 DD 21 2F 54  	LD IX, FRMQNT
 893  5615 CD 59 01     	CALL CALBAS
 894  5618 D5           	PUSH DE
 895  5619              	; ending )
 896  5619 CD F2 54     	CALL CHKCHAR
 897  561C 29           	DB ')'
 898  561D
 899  561D              	; save BASIC token position
 900  561D E5           	PUSH HL
 901  561E D9               EXX
 902  561F E1           	POP HL ; HL'=next basic token
 903  5620 D9               EXX
 904  5621
 905  5621 E1               POP HL ; get pointer to register values
 906  5622 F3           	DI
 907  5623 ED 73 FD 55      LD (GENCAL_VAR_SP), SP
 908  5627 F9               LD SP, HL
 909  5628 F1               POP AF
 910  5629 C1               POP BC
 911  562A D1               POP DE
 912  562B E1               POP HL
 913  562C DD E1            POP IX
 914  562E FD E1            POP IY
 915  5630 D9               EXX
 916  5631 ED 73 FF 55      LD (GENCAL_VAR_SP2), SP
 917  5635 ED 7B FD 55      LD SP, (GENCAL_VAR_SP)
 918  5639 FB               EI
 919  563A D1               POP DE ; get function to call
 920  563B E5               PUSH HL
 921  563C CD 57 56         CALL .EXXDECALL
 922  563F F3               DI
 923  5640 ED 73 FD 55      LD (GENCAL_VAR_SP), SP
 924  5644 ED 7B FF 55      LD SP, (GENCAL_VAR_SP2)
 925  5648 FD E5            PUSH IY
 926  564A DD E5            PUSH IX
 927  564C E5               PUSH HL
 928  564D D5               PUSH DE
 929  564E C5               PUSH BC
 930  564F F5               PUSH AF
 931  5650 ED 7B FD 55      LD SP, (GENCAL_VAR_SP)
 932  5654 FB               EI
 933  5655 E1               POP HL
 934  5656 C9           	RET
 935  5657
 936  5657              .EXXDECALL:
 937  5657 D5               PUSH DE
 938  5658 D9               EXX
 939  5659 C9               RET
 940  565A              ; *******************************************************************************************************
 941  565A               ENDIF
 942  565A
 943  565A               IF (VRAM_CMDS == 1)
 944  565A              ; *******************************************************************************************************
 945  565A              ; function to handle CALL MEMVRM basic extension
 946  565A              ; copies from RAM to VRAM
 947  565A              ; _MEMVRM ( INT source,
 948  565A              ;			INT destination,
 949  565A              ;			INT count,
 950  565A              ;			BYTE wait_vsync) >0 = true
 951  565A              ; will put ram in page 0 also, page 1 is already there
 952  565A              ; wait_vsync will issue HALT before copying
 953  565A              MEMVRM:
 954  565A              	; opening (
 955  565A CD F2 54     	CALL CHKCHAR
 956  565D 28           	DB '('
 957  565E              	; get source address
 958  565E DD 21 2F 54  	LD IX, FRMQNT
 959  5662 CD 59 01     	CALL CALBAS
 960  5665 D5           	PUSH DE
 961  5666              	; comma
 962  5666 CD F2 54     	CALL CHKCHAR
 963  5669 2C           	DB ','
 964  566A              	; get destination address
 965  566A DD 21 2F 54  	LD IX, FRMQNT
 966  566E CD 59 01     	CALL CALBAS
 967  5671 D5           	PUSH DE
 968  5672              	; comma
 969  5672 CD F2 54     	CALL CHKCHAR
 970  5675 2C           	DB ','
 971  5676              	; get length
 972  5676 DD 21 2F 54  	LD IX, FRMQNT
 973  567A CD 59 01     	CALL CALBAS
 974  567D D5           	PUSH DE
 975  567E              	; comma
 976  567E CD F2 54     	CALL CHKCHAR
 977  5681 2C           	DB ','
 978  5682              	; get vsync wait
 979  5682 DD 21 1C 52  	LD IX, GETBYT
 980  5686 CD 59 01     	CALL CALBAS
 981  5689 F5           	PUSH AF
 982  568A              	; ending )
 983  568A CD F2 54     	CALL CHKCHAR
 984  568D 29           	DB ')'
 985  568E
 986  568E                  ; save position in BASIC text
 987  568E E5           	PUSH HL
 988  568F DD E1        	POP IX
 989  5691
 990  5691 F1           	POP AF ; wait vsync
 991  5692 B7           	OR A
 992  5693 28 03        	JR Z, .L1
 993  5695 FB               EI
 994  5696 76           	HALT
 995  5697 F3           	DI
 996  5698              .L1:
 997  5698              	; pop LDIR parameters and store away for later
 998  5698 C1           	POP BC ; count
 999  5699 D1           	POP DE ; vram destination
1000  569A E1           	POP HL ; ram source
1001  569B D9           	EXX
1002  569C FD 21 A3 56   	LD IY, .RET
1003  56A0 C3 A5 54     	JP ENABLE_PAGE0
1004  56A3              .RET:
1005  56A3 FB           	EI
1006  56A4 D9           	EXX
1007  56A5 CD B1 56     	CALL .LDIRVM
1008  56A8 D1               POP DE
1009  56A9 C1               POP BC
1010  56AA CD 1C 54         CALL RESTORE_PAGE_INFO
1011  56AD DD E5        	PUSH IX
1012  56AF E1           	POP HL
1013  56B0 C9           	RET
1014  56B1
1015  56B1              .LDIRVM:
1016  56B1 EB           	EX DE, HL
1017  56B2 F3           	DI
1018  56B3 CD CF 53     	CALL SETWRT_LOCAL
1019  56B6 FB           	EI
1020  56B7 EB           	EX DE, HL
1021  56B8 78           	LD A, B
1022  56B9 B7           	OR A
1023  56BA 28 0D        	JR Z, .L3
1024  56BC C5           	PUSH BC
1025  56BD 0E 98        	LD C, #98
1026  56BF              .L2:
1027  56BF 50           	LD D, B
1028  56C0 06 00        	LD B, 0
1029  56C2 CD DA 53     	CALL BBYTECOPY
1030  56C5 42           	LD B, D
1031  56C6 10 F7        	DJNZ .L2
1032  56C8 C1           	POP BC
1033  56C9              .L3:
1034  56C9 79           	LD A, C
1035  56CA B7           	OR A
1036  56CB C8           	RET Z
1037  56CC 41           	LD B, C
1038  56CD 0E 98        	LD C, #98
1039  56CF C3 DA 53     	JP BBYTECOPY
1040  56D2              ; *******************************************************************************************************
1041  56D2               ENDIF
1042  56D2
1043  56D2               IF (VRAM_CMDS == 1)
1044  56D2              ; *******************************************************************************************************
1045  56D2              ; function to handle CALL VRMMEM basic extension
1046  56D2              ; copies from RAM to VRAM
1047  56D2              ; _VRMMEM ( INT source,
1048  56D2              ;			INT destination,
1049  56D2              ;			INT count
1050  56D2              ; will put ram in page 0 also, page 1 is already there
1051  56D2              VRMMEM:
1052  56D2              	; opening (
1053  56D2 CD F2 54     	CALL CHKCHAR
1054  56D5 28           	DB '('
1055  56D6              	; get source address
1056  56D6 DD 21 2F 54  	LD IX, FRMQNT
1057  56DA CD 59 01     	CALL CALBAS
1058  56DD D5           	PUSH DE
1059  56DE              	; comma
1060  56DE CD F2 54     	CALL CHKCHAR
1061  56E1 2C           	DB ','
1062  56E2              	; get destination address
1063  56E2 DD 21 2F 54  	LD IX, FRMQNT
1064  56E6 CD 59 01     	CALL CALBAS
1065  56E9 D5           	PUSH DE
1066  56EA              	; comma
1067  56EA CD F2 54     	CALL CHKCHAR
1068  56ED 2C           	DB ','
1069  56EE              	; get length
1070  56EE DD 21 2F 54  	LD IX, FRMQNT
1071  56F2 CD 59 01     	CALL CALBAS
1072  56F5 D5           	PUSH DE
1073  56F6              	; ending )
1074  56F6 CD F2 54     	CALL CHKCHAR
1075  56F9 29           	DB ')'
1076  56FA
1077  56FA                  ; save position in BASIC text
1078  56FA E5           	PUSH HL
1079  56FB DD E1        	POP IX
1080  56FD
1081  56FD C1           	POP BC ; count
1082  56FE D1           	POP DE ; destination
1083  56FF E1           	POP HL ; source
1084  5700 D9           	EXX
1085  5701 FD 21 08 57  	LD IY, .RET
1086  5705 C3 A5 54     	JP ENABLE_PAGE0
1087  5708              .RET:
1088  5708 FB           	EI
1089  5709 D9           	EXX
1090  570A CD 16 57     	CALL .LDIRMV
1091  570D D1               POP DE
1092  570E C1               POP BC
1093  570F CD 1C 54         CALL RESTORE_PAGE_INFO
1094  5712 DD E5        	PUSH IX
1095  5714 E1           	POP HL
1096  5715 C9           	RET
1097  5716
1098  5716              .LDIRMV:
1099  5716              	; set VRAM address *exactly* as in ROM, otherwise corruption
1100  5716 7D           	LD	A, L
1101  5717 F3           	DI
1102  5718 D3 99        	OUT	(099H), A
1103  571A 7C           	LD	A, H
1104  571B E6 3F        	AND	03FH
1105  571D D3 99        	OUT	(099H), A
1106  571F FB           	EI
1107  5720              	;EX (SP), HL
1108  5720              	;EX (SP), HL
1109  5720              	;NOP
1110  5720              	;NOP
1111  5720              .L4:
1112  5720 DB 98            IN A, (#98)
1113  5722 12           	LD (DE), A
1114  5723 13               INC DE
1115  5724 0B               DEC BC
1116  5725 79               LD A, C
1117  5726 B0               OR B
1118  5727 20 F7            JR NZ, .L4
1119  5729 C9               RET
1120  572A              ; *******************************************************************************************************
1121  572A               ENDIF
1122  572A
1123  572A              ; *******************************************************************************************************
1124  572A              ; H.TIMI function
1125  572A              MBGE_HTIMI:
1126  572A               EXPORT MBGE_HTIMI
1127  572A F5           	PUSH AF
1128  572B
1129  572B               IF (SPRITE_CMDS == 1)
1130  572B CD 01 4D     	CALL SPRATR_UPDATE
1131  572E               ENDIF
1132  572E
1133  572E               IF (SOUND_CMDS == 1)
1134  572E 3A F7 4C     	LD A, (SOUND_ENABLED)
1135  5731 B7           	OR A
1136  5732 28 2A        	JR Z, .EXIT
1137  5734
1138  5734              	; enable page 2
1139  5734 3E 02            LD A, 2
1140  5736 CD E5 53         CALL GET_PAGE_INFO
1141  5739 C5               PUSH BC
1142  573A D5               PUSH DE
1143  573B 3A 43 F3         LD A, (RAMAD2)
1144  573E 26 80            LD H, 080H
1145  5740 CD 2C 54         CALL LOCAL_ENASLT
1146  5743              	; enable page 0
1147  5743 AF               XOR A
1148  5744 CD E5 53         CALL GET_PAGE_INFO
1149  5747 C5               PUSH BC
1150  5748 D5               PUSH DE
1151  5749 3A 41 F3         LD A, (RAMAD0)
1152  574C 26 00            LD H, 0
1153  574E CD 2C 54         CALL LOCAL_ENASLT
1154  5751
1155  5751 CD 33 42     	CALL PLY_AKG_PLAY
1156  5754
1157  5754              	; restore page 0
1158  5754 D1               POP DE
1159  5755 C1               POP BC
1160  5756 CD 1C 54         CALL RESTORE_PAGE_INFO
1161  5759              	; restore page 2
1162  5759 D1               POP DE
1163  575A C1               POP BC
1164  575B CD 1C 54         CALL RESTORE_PAGE_INFO
1165  575E               ENDIF
1166  575E
1167  575E              .EXIT:
1168  575E F1           	POP AF
1169  575F C3 F0 4C     	JP ORIG.HTIMI
1170  5762              ; *******************************************************************************************************
1171  5762
1172  5762              ; *******************************************************************************************************
1173  5762              ; interrupt handler when page 0 enabled
1174  5762              VBLANK:
1175  5762              	EXPORT VBLANK
1176  5762
1177  5762 F5               PUSH AF
1178  5763              	; is VDP originator ?
1179  5763 DB 99        	IN	A, (099H)
1180  5765 A7           	AND	A
1181  5766 F2 8C 57     	JP P, .EXIT
1182  5769
1183  5769               IF (SOUND_CMDS == 1)
1184  5769 3A F7 4C     	LD A, (SOUND_ENABLED)
1185  576C B7           	OR A
1186  576D 28 1D        	JR Z, .EXIT
1187  576F
1188  576F C5               PUSH BC
1189  5770 D5               PUSH DE
1190  5771 E5               PUSH HL
1191  5772 08               EX AF, AF'
1192  5773 D9               EXX
1193  5774 F5               PUSH AF
1194  5775 C5               PUSH BC
1195  5776 D5               PUSH DE
1196  5777 E5               PUSH HL
1197  5778 DD E5            PUSH IX
1198  577A FD E5            PUSH IY
1199  577C
1200  577C CD 33 42     	CALL PLY_AKG_PLAY
1201  577F
1202  577F FD E1            POP IY
1203  5781 DD E1            POP IX
1204  5783 E1               POP HL
1205  5784 D1               POP DE
1206  5785 C1               POP BC
1207  5786 F1               POP AF
1208  5787 08               EX AF, AF'
1209  5788 D9               EXX
1210  5789 E1               POP HL
1211  578A D1               POP DE
1212  578B C1               POP BC
1213  578C               ENDIF
1214  578C
1215  578C              .EXIT:
1216  578C F1           	POP AF
1217  578D FB           	EI
1218  578E ED 4D        	RETI
1219  5790              ; *******************************************************************************************************
1220  5790
1221  5790               IF (SOUND_CMDS == 1)
1222  5790              ; *******************************************************************************************************
1223  5790              ; function to handle CALL SNDPLYINIT basic extension
1224  5790              ; initializes sound player
1225  5790              ; _SNDPLYINIT ( INT music_offset,
1226  5790              ;				INT sfx_offset, can be -1 if no SFX
1227  5790              ; will put ram in page 0 also, page 1 is already there
1228  5790              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1229  5790              SNDPLYINIT:
1230  5790              	; opening (
1231  5790 CD F2 54     	CALL CHKCHAR
1232  5793 28           	DB '('
1233  5794              	; get music address
1234  5794 DD 21 2F 54  	LD IX, FRMQNT
1235  5798 CD 59 01     	CALL CALBAS
1236  579B D5           	PUSH DE
1237  579C              	; comma
1238  579C CD F2 54     	CALL CHKCHAR
1239  579F 2C           	DB ','
1240  57A0              	; get sfx address
1241  57A0 DD 21 2F 54  	LD IX, FRMQNT
1242  57A4 CD 59 01     	CALL CALBAS
1243  57A7 D5           	PUSH DE
1244  57A8              	; ending )
1245  57A8 CD F2 54     	CALL CHKCHAR
1246  57AB 29           	DB ')'
1247  57AC
1248  57AC                  ; save position in BASIC text
1249  57AC 44           	LD B, H
1250  57AD 4D           	LD C, L
1251  57AE
1252  57AE              	; pop LDIR parameters and store away for later
1253  57AE D1           	POP DE ; sfx address
1254  57AF E1           	POP HL ; music address
1255  57B0 C5           	PUSH BC ; basic text location
1256  57B1 D9           	EXX
1257  57B2 FD 21 B9 57  	LD IY, .RET
1258  57B6 C3 A5 54     	JP ENABLE_PAGE0
1259  57B9              .RET:
1260  57B9 D9           	EXX
1261  57BA
1262  57BA D5           	PUSH DE
1263  57BB AF           	XOR A
1264  57BC              	; HL = music location
1265  57BC CD 62 41     	CALL PLY_AKG_INIT
1266  57BF 3E 01        	LD A, 1
1267  57C1 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1268  57C4
1269  57C4 E1           	POP HL ; SFX
1270  57C5              	; check if SFX address -1
1271  57C5 23           	INC HL
1272  57C6 7D           	LD A, L
1273  57C7 B4           	OR H
1274  57C8 28 09        	JR Z,.L1
1275  57CA 2B           	DEC HL
1276  57CB CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1277  57CE 3E 01        	LD A, 1
1278  57D0 32 F6 4C     	LD (SFX_INIT_STATUS), A
1279  57D3              .L1:
1280  57D3 D1               POP DE
1281  57D4 C1               POP BC
1282  57D5 CD 1C 54         CALL RESTORE_PAGE_INFO
1283  57D8
1284  57D8 E1           	POP HL
1285  57D9 C9           	RET
1286  57DA              ; *******************************************************************************************************
1287  57DA
1288  57DA              ; *******************************************************************************************************
1289  57DA              ; function to handle CALL SNDPLYON basic extension
1290  57DA              ; enables sound player
1291  57DA              ; _SNDPLYON
1292  57DA              ; sets SOUND_ENABLED variable to 1 if init call was done
1293  57DA              ; if not throws out of data error
1294  57DA              SNDPLYON:
1295  57DA 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1296  57DD B7           	OR A
1297  57DE 20 05        	JR NZ, .L1
1298  57E0              	; player not initialized, throw error
1299  57E0 1E 04        	LD E, 04 ; Out of DATA
1300  57E2 C3 12 55     	JP THROW_ERROR
1301  57E5              .L1:
1302  57E5 32 F7 4C     	LD (SOUND_ENABLED), A
1303  57E8              	; disable key click
1304  57E8 AF           	XOR A
1305  57E9 32 DB F3     	LD (CLIKSW), A
1306  57EC C9           	RET
1307  57ED              ; *******************************************************************************************************
1308  57ED
1309  57ED              ; *******************************************************************************************************
1310  57ED              ; function to handle CALL SNDPLYOFF basic extension
1311  57ED              ; disables sound player
1312  57ED              ; _SNDPLYOFF
1313  57ED              ; sets SOUND_ENABLED variable to 0
1314  57ED              ; calls AKG to stop music and SFX on all channels if initialized
1315  57ED              SNDPLYOFF:
1316  57ED 3A F7 4C     	LD A, (SOUND_ENABLED)
1317  57F0 B7           	OR A
1318  57F1 C8           	RET Z ; already stopped
1319  57F2 AF           	XOR A
1320  57F3 32 F7 4C     	LD (SOUND_ENABLED), A
1321  57F6 E5           	PUSH HL
1322  57F7 CD 21 42     	CALL PLY_AKG_STOP
1323  57FA 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1324  57FD B7           	OR A
1325  57FE 28 0E        	JR Z, .EXIT ; SFX not in use
1326  5800 AF           	XOR A
1327  5801 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1328  5804 3E 01        	LD A, 1
1329  5806 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1330  5809 3E 02        	LD A, 2
1331  580B CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1332  580E              .EXIT:
1333  580E E1           	POP HL
1334  580F C9           	RET
1335  5810              ; *******************************************************************************************************
1336  5810
1337  5810              ; *******************************************************************************************************
1338  5810              ; function to handle CALL SNDSFX basic extension
1339  5810              ; plays a sound effect
1340  5810              ; _SNDSFX ( BYTE sfx_number, >0
1341  5810              ;			BYTE channel, = 0,1 or 2
1342  5810              ;			BYTE inverted_volume = 0-16, 0 being full volume
1343  5810              ; will put ram in page 0 also, page 1 is already there
1344  5810              ; if sound off throws illegal function call
1345  5810              ; if sfx not initialized, throws out of data
1346  5810              SNDSFX:
1347  5810              	; opening (
1348  5810 CD F2 54     	CALL CHKCHAR
1349  5813 28           	DB '('
1350  5814              	; get sfx_number
1351  5814 DD 21 1C 52  	LD IX, GETBYT
1352  5818 CD 59 01     	CALL CALBAS
1353  581B D5           	PUSH DE
1354  581C              	; comma
1355  581C CD F2 54     	CALL CHKCHAR
1356  581F 2C           	DB ','
1357  5820              	; get sfx address
1358  5820 DD 21 1C 52  	LD IX, GETBYT
1359  5824 CD 59 01     	CALL CALBAS
1360  5827 D5           	PUSH DE
1361  5828              	; comma
1362  5828 CD F2 54     	CALL CHKCHAR
1363  582B 2C           	DB ','
1364  582C              	; get inverted volume
1365  582C DD 21 1C 52  	LD IX, GETBYT
1366  5830 CD 59 01     	CALL CALBAS
1367  5833 D5           	PUSH DE
1368  5834              	; ending )
1369  5834 CD F2 54     	CALL CHKCHAR
1370  5837 29           	DB ')'
1371  5838
1372  5838 3A F7 4C     	LD A, (SOUND_ENABLED)
1373  583B B7           	OR A
1374  583C 20 05        	JR NZ, .L1
1375  583E              	; sound disabled, throw illegal function call
1376  583E 1E 05        	LD E, 5
1377  5840 C3 12 55     	JP THROW_ERROR
1378  5843              .L1:
1379  5843 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1380  5846 B7           	OR A
1381  5847 20 05        	JR NZ, .L2
1382  5849              	; sfx data not initialized, throw out of data
1383  5849 1E 04        	LD E, 4
1384  584B C3 12 55     	JP THROW_ERROR
1385  584E              .L2:
1386  584E              	; pop  parameters and store away for later
1387  584E D1           	POP DE ; inverted volume
1388  584F 43           	LD B, E
1389  5850 D1           	POP DE ; channel
1390  5851 4B           	LD C, E
1391  5852 D1           	POP DE
1392  5853 7B           	LD A, E
1393  5854 08           	EX AF, AF'
1394  5855 E5           	PUSH HL ; basic text location
1395  5856 D9           	EXX
1396  5857 FD 21 5E 58  	LD IY, .RET
1397  585B C3 A5 54     	JP ENABLE_PAGE0
1398  585E              .RET:
1399  585E D9           	EXX
1400  585F 08           	EX AF, AF'
1401  5860 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1402  5863
1403  5863 D1               POP DE
1404  5864 C1               POP BC
1405  5865 CD 1C 54         CALL RESTORE_PAGE_INFO
1406  5868
1407  5868 E1           	POP HL
1408  5869 C9           	RET
1409  586A              ; *******************************************************************************************************
1410  586A               ENDIF
1411  586A
1412  586A               IF (BLIT_CMDS == 1)
1413  586A              ; *******************************************************************************************************
1414  586A              ; function rotates mask and data of several characters and applies to background data
1415  586A              ; this handles x-shift from 0 to 4
1416  586A              ; contains self-modifying code that is set-up from external function
1417  586A              ; input HL=pointer to mask data
1418  586A              ; input HL'=pointer to character data
1419  586A              ; input DE=output buffer containing background data
1420  586A              ; input BC=DE+8
1421  586A              ; input A=number of characters to process
1422  586A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1423  586A              SHIFT04:
1424  586A 08           	EX AF, AF'
1425  586B 7E           	LD A, (HL) ; get mask
1426  586C D9           	EXX
1427  586D 57           	LD D, A
1428  586E 1E FF        	LD E, #FF
1429  5870 37           	SCF
1430  5871              .M1:
1431  5871 18 FE        	JR .M1 ; this is self-modifying part
1432  5873 CB 1A        	RR D
1433  5875 CB 1B        	RR E
1434  5877 CB 1A        	RR D
1435  5879 CB 1B        	RR E
1436  587B CB 1A        	RR D
1437  587D CB 1B        	RR E
1438  587F CB 1A        	RR D
1439  5881 CB 1B        	RR E
1440  5883
1441  5883 46           	LD B, (HL) ; get data
1442  5884 0E 00        	LD C, 0
1443  5886              .M2:
1444  5886 18 FE        	JR .M2 ; also self-modifying part
1445  5888 CB 38        	SRL B
1446  588A CB 19        	RR C
1447  588C CB 38        	SRL B
1448  588E CB 19        	RR C
1449  5890 CB 38        	SRL B
1450  5892 CB 19        	RR C
1451  5894 CB 38        	SRL B
1452  5896 CB 19        	RR C
1453  5898
1454  5898 D9           	EXX
1455  5899 1A           	LD A, (DE) ; background
1456  589A D9           	EXX
1457  589B A2           	AND D
1458  589C B0           	OR B
1459  589D D9           	EXX
1460  589E 12           	LD (DE), A
1461  589F
1462  589F 0A           	LD A, (BC)
1463  58A0 D9           	EXX
1464  58A1 A3           	AND E
1465  58A2 B1           	OR C
1466  58A3 23           	INC HL
1467  58A4 D9           	EXX
1468  58A5 02           	LD (BC), A
1469  58A6
1470  58A6 23           	INC HL
1471  58A7 13           	INC DE
1472  58A8 03           	INC BC
1473  58A9
1474  58A9 08           	EX AF, AF'
1475  58AA 3D           	DEC A
1476  58AB C2 6A 58     	JP NZ, SHIFT04
1477  58AE C9           	RET
1478  58AF              ; *******************************************************************************************************
1479  58AF
1480  58AF              ; *******************************************************************************************************
1481  58AF              ; function rotates mask and data of several characters and applies to background data
1482  58AF              ; this handles x-shift from 5 to 8
1483  58AF              ; contains self-modifying code that is set-up from external function
1484  58AF              ; input HL=pointer to mask data
1485  58AF              ; input HL'=pointer to character data
1486  58AF              ; input DE=output buffer containing background data
1487  58AF              ; input BC=DE+8
1488  58AF              ; input A=number of characters to process
1489  58AF              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1490  58AF              SHIFT58:
1491  58AF 08           	EX AF, AF'
1492  58B0 7E           	LD A, (HL) ; get mask
1493  58B1 D9           	EXX
1494  58B2 57           	LD D, A
1495  58B3 1E FF        	LD E, #FF
1496  58B5 37           	SCF
1497  58B6              .M1:
1498  58B6 18 FE        	JR .M1 ; this is self-modifying part
1499  58B8 CB 12        	RL D
1500  58BA CB 13        	RL E
1501  58BC CB 12        	RL D
1502  58BE CB 13        	RL E
1503  58C0 CB 12        	RL D
1504  58C2 CB 13        	RL E
1505  58C4
1506  58C4 46           	LD B, (HL)
1507  58C5 0E 00        	LD C, 0
1508  58C7              .M2:
1509  58C7 18 FE        	JR .M2 ; also self-modifying part
1510  58C9 CB 20        	SLA B
1511  58CB CB 11        	RL C
1512  58CD CB 20        	SLA B
1513  58CF CB 11        	RL C
1514  58D1 CB 20        	SLA B
1515  58D3 CB 11        	RL C
1516  58D5
1517  58D5 D9           	EXX
1518  58D6 1A           	LD A, (DE) ; background
1519  58D7 D9           	EXX
1520  58D8 A3           	AND E
1521  58D9 B1           	OR C
1522  58DA D9           	EXX
1523  58DB 12           	LD (DE), A
1524  58DC
1525  58DC 0A           	LD A, (BC)
1526  58DD D9           	EXX
1527  58DE A2           	AND D
1528  58DF B0           	OR B
1529  58E0 23           	INC HL
1530  58E1 D9           	EXX
1531  58E2 02           	LD (BC), A
1532  58E3
1533  58E3 23           	INC HL
1534  58E4 13           	INC DE
1535  58E5 03           	INC BC
1536  58E6
1537  58E6 08           	EX AF, AF'
1538  58E7 3D           	DEC A
1539  58E8 C2 AF 58     	JP NZ, SHIFT58
1540  58EB C9           	RET
1541  58EC              ; *******************************************************************************************************
1542  58EC
1543  58EC              ; *******************************************************************************************************
1544  58EC              ; routine that shifts one row of characters
1545  58EC              ; contains self-modifying code that is set-up from external function
1546  58EC              ; input HL=pointer to mask data
1547  58EC              ; input HL'=pointer to character data
1548  58EC              ; input DE=output buffer containing background data
1549  58EC              ; input A=number of characters to process
1550  58EC              ; input IX=pointer to structure describing input data
1551  58EC              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1552  58EC              SHIFT_ROW:
1553  58EC F5           	PUSH AF
1554  58ED ED 53 5D 52  		LD (BLIT_TMP1), DE
1555  58F1 E5           		PUSH HL
1556  58F2 CD 35 59     			CALL .ADDYSHIFT
1557  58F5 E1           		POP HL
1558  58F6 ED 53 5F 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1559  58FA              .L1:
1560  58FA 3E 08        		LD A, 8
1561  58FC DD 96 02     		SUB (IX+2) ; y shift
1562  58FF              .CALL1:
1563  58FF CD 00 00     		CALL 0
1564  5902 DD 7E 02     		LD A, (IX+2); y shift
1565  5905 B7           		OR A
1566  5906 28 26        		JR Z, .DONE
1567  5908 ED 5B 5D 52  		LD DE, (BLIT_TMP1)
1568  590C E5           		PUSH HL
1569  590D CD 43 59     			CALL .DETONEXTROW
1570  5910 E1           		POP HL
1571  5911              .CALL2:
1572  5911 CD 00 00     		CALL 0
1573  5914 ED 5B 5D 52  		LD DE, (BLIT_TMP1)
1574  5918 E5           		PUSH HL
1575  5919 CD 3D 59     			CALL .ADD8
1576  591C E1           		POP HL
1577  591D ED 53 5D 52  		LD (BLIT_TMP1), DE
1578  5921 ED 5B 5F 52  		LD DE, (BLIT_TMP2)
1579  5925 E5           		PUSH HL
1580  5926 CD 3D 59     			CALL .ADD8
1581  5929 E1           		POP HL
1582  592A ED 53 5F 52  		LD (BLIT_TMP2), DE ; DE+vertical shift
1583  592E              .DONE:
1584  592E F1           	POP AF
1585  592F 3D           	DEC A
1586  5930 C8           	RET Z
1587  5931 F5           	PUSH AF
1588  5932 C3 FA 58     	JP .L1
1589  5935              .ADDYSHIFT:
1590  5935 EB           	EX DE, HL
1591  5936 16 00        	LD D, 0
1592  5938 DD 5E 02     	LD E, (IX+2); y shift
1593  593B 18 0C        	JR .MOVDEBC
1594  593D              .ADD8:
1595  593D 21 08 00     	LD HL, 8
1596  5940 C3 49 59     	JP .MOVDEBC
1597  5943              .DETONEXTROW:
1598  5943 DD 6E 06     	LD L, (IX+6)
1599  5946 DD 66 07     	LD H, (IX+7) ; bkg add to value
1600  5949              .MOVDEBC:
1601  5949 19           	ADD HL, DE
1602  594A 54           	LD D, H
1603  594B 5D           	LD E, L
1604  594C 01 08 00     	LD BC, 8
1605  594F 09           	ADD HL, BC
1606  5950 44           	LD B, H
1607  5951 4D           	LD C, L
1608  5952 C9           	RET
1609  5953              ; *******************************************************************************************************
1610  5953
1611  5953              ; *******************************************************************************************************
1612  5953              ; function rotates mask and character data and applies it to background
1613  5953              ; input IX=pointer to structure describing input data
1614  5953              ; +0  DW horizontal shift count 0-7 (low byte used)
1615  5953              ; +2  DW vertical shift count 0-7 (low byte used)
1616  5953              ; +4  DW background data start;
1617  5953              ; +6  DW background add to value to next row of background data
1618  5953              ; +8  DW mask data start;
1619  5953              ; +10  DW character data start;
1620  5953              ; +12 DW character&mask add to value to next row of data
1621  5953              ; +14 DW columns (low byte used)
1622  5953              ; +16 DW rows (low byte used)
1623  5953              SHIFT_MERGE_CHARACTER:
1624  5953 DD 7E 00     	LD A, (IX) ; shift
1625  5956 FE 05        	CP 5
1626  5958 38 25        	JR C, .RIGHT
1627  595A              	; shifts 5-7, use rotate towards left 1-3
1628  595A 21 AF 58     	LD HL, SHIFT58
1629  595D 22 00 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1630  5960 22 12 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1631  5963 D6 05        	SUB 5
1632  5965 28 0D        	JR Z, .L1
1633  5967 87           	ADD A, A
1634  5968 87           	ADD A, A
1635  5969 67           	LD H, A
1636  596A 2E 18        	LD L, #18 ; JR opcode
1637  596C 22 B6 58     	LD (SHIFT58.M1), HL
1638  596F 22 C7 58     	LD (SHIFT58.M2), HL
1639  5972 18 32        	JR .DO
1640  5974              .L1:
1641  5974 21 00 00     	LD HL, 0 ; 2xNOP opcode
1642  5977 22 B6 58     	LD (SHIFT58.M1), HL
1643  597A 22 C7 58     	LD (SHIFT58.M2), HL
1644  597D 18 27        	JR .DO
1645  597F              .RIGHT:
1646  597F              	; shifts 0-4, rotate towards right
1647  597F 21 6A 58     	LD HL, SHIFT04
1648  5982 22 00 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1649  5985 22 12 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1650  5988 FE 04        	CP 4
1651  598A 28 11        	JR Z, .R1
1652  598C D6 04        	SUB 4
1653  598E ED 44        	NEG
1654  5990 87           	ADD A, A
1655  5991 87           	ADD A, A
1656  5992 67           	LD H, A
1657  5993 2E 18        	LD L, #18 ; JR opcode
1658  5995 22 71 58     	LD (SHIFT04.M1), HL
1659  5998 22 86 58     	LD (SHIFT04.M2), HL
1660  599B 18 09        	JR .DO
1661  599D              .R1:
1662  599D 21 00 00     	LD HL, 0 ; 2xNOP opcode
1663  59A0 22 71 58     	LD (SHIFT04.M1), HL
1664  59A3 22 86 58     	LD (SHIFT04.M2), HL
1665  59A6              .DO:
1666  59A6 DD 46 10     	LD B, (IX+16) ; rows
1667  59A9 DD 6E 08     	LD L, (IX+8)
1668  59AC DD 66 09     	LD H, (IX+9) ; mask data
1669  59AF DD 5E 04     	LD E, (IX+4)
1670  59B2 DD 56 05     	LD D, (IX+5) ; background data
1671  59B5 D9           	EXX
1672  59B6 DD 6E 0A     	LD L, (IX+10)
1673  59B9 DD 66 0B     	LD H, (IX+11) ; character data
1674  59BC D9           	EXX
1675  59BD              .LOOP:
1676  59BD C5           	PUSH BC
1677  59BE E5           		PUSH HL
1678  59BF D5           			PUSH DE
1679  59C0 D9           				EXX
1680  59C1 E5           				PUSH HL
1681  59C2 D9           					EXX
1682  59C3 DD 7E 0E     					LD A, (IX+14) ; columns
1683  59C6              .CALL:
1684  59C6 CD EC 58     					CALL SHIFT_ROW
1685  59C9 E1           				POP HL
1686  59CA DD 5E 0C     				LD E, (IX+12)
1687  59CD DD 56 0D     				LD D, (IX+13) ; char data to next row
1688  59D0 19           				ADD HL, DE
1689  59D1 D9           				EXX
1690  59D2 E1           			POP HL
1691  59D3 DD 5E 06     			LD E, (IX+6)
1692  59D6 DD 56 07     			LD D, (IX+7) ; background to next row
1693  59D9 19           			ADD HL, DE
1694  59DA EB           			EX DE, HL
1695  59DB E1           		POP HL
1696  59DC DD 4E 0C     		LD C, (IX+12)
1697  59DF DD 46 0D     		LD B, (IX+13) ; char data to next row
1698  59E2 09           		ADD HL, BC
1699  59E3 C1           	POP BC
1700  59E4 10 D7        	DJNZ .LOOP
1701  59E6 C9           	RET
1702  59E7              ; *******************************************************************************************************
1703  59E7
1704  59E7               IFNDEF CMDS_WITH_PARAMETERS
1705  59E7 ~            ; *******************************************************************************************************
1706  59E7 ~            ; function to handle CALL BLIT basic extension
1707  59E7 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1708  59E7 ~            ; fuses with background data and applies vertical shift too
1709  59E7 ~            ; BLIT ( INT request_data_ptr )
1710  59E7 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1711  59E7 ~            ; will put ram in page 0 also, page 1 is already there
1712  59E7 ~            BLIT:
1713  59E7 ~            	; opening (
1714  59E7 ~            	CALL CHKCHAR
1715  59E7 ~            	DB '('
1716  59E7 ~            	; get pointer to request struct
1717  59E7 ~            	LD IX, FRMQNT
1718  59E7 ~            	CALL CALBAS
1719  59E7 ~            	PUSH DE
1720  59E7 ~            	; ending )
1721  59E7 ~            	CALL CHKCHAR
1722  59E7 ~            	DB ')'
1723  59E7 ~
1724  59E7 ~            	POP IX ; pointer to request struct
1725  59E7 ~
1726  59E7 ~            	PUSH HL ; save position in BASIC buffer
1727  59E7 ~
1728  59E7 ~            	LD IY, .RET
1729  59E7 ~            	JP ENABLE_PAGE0
1730  59E7 ~            .RET:
1731  59E7 ~            	EI
1732  59E7 ~            	CALL SHIFT_MERGE_CHARACTER
1733  59E7 ~
1734  59E7 ~                POP DE
1735  59E7 ~                POP BC
1736  59E7 ~                CALL RESTORE_PAGE_INFO
1737  59E7 ~
1738  59E7 ~            	POP HL
1739  59E7 ~            	RET
1740  59E7 ~            ; *******************************************************************************************************
1741  59E7               ENDIF
1742  59E7
1743  59E7               IFDEF CMDS_WITH_PARAMETERS
1744  59E7              ; *******************************************************************************************************
1745  59E7              ; function to handle CALL BLIT basic extension
1746  59E7              ; rotates 1-bit character drawing horizontally with mask and character data and
1747  59E7              ; fuses with background data and applies vertical shift too
1748  59E7              ; in form without pointers
1749  59E7              ; BLIT ( INT x,
1750  59E7              ;		 INT y,
1751  59E7              ;		 INT char_data_pointer,
1752  59E7              ;		 INT mask_data_pointer,
1753  59E7              ;		 INT width (in characters),
1754  59E7              ;		 INT height (in characters),
1755  59E7              ;		 INT background_pointer (top left),
1756  59E7              ;		 INT background_width (in characters),
1757  59E7              ;		 INT background_height (in characters))
1758  59E7              ; will put ram in page 0 also, page 1 is already there
1759  59E7              BLIT:
1760  59E7              	; opening (
1761  59E7 CD F2 54     	CALL CHKCHAR
1762  59EA 28           	DB '('
1763  59EB              	; get x coordinate
1764  59EB DD 21 2F 54  	LD IX, FRMQNT
1765  59EF CD 59 01     	CALL CALBAS
1766  59F2 7B           	LD A, E
1767  59F3 E6 07        	AND 7
1768  59F5 32 61 52     	LD (BLIT_STRUCT+0), A
1769  59F8 CD D5 5A     	CALL .DAdiv8
1770  59FB 32 5D 52     	LD (BLIT_TMP+0),A
1771  59FE              	; comma
1772  59FE CD F2 54     	CALL CHKCHAR
1773  5A01 2C           	DB ','
1774  5A02              	; get y coordinate
1775  5A02 DD 21 2F 54  	LD IX, FRMQNT
1776  5A06 CD 59 01     	CALL CALBAS
1777  5A09 7B           	LD A, E
1778  5A0A E6 07        	AND 7
1779  5A0C 32 63 52     	LD (BLIT_STRUCT+2), A
1780  5A0F CD D5 5A     	CALL .DAdiv8
1781  5A12 32 5E 52     	LD (BLIT_TMP+1),A
1782  5A15              	; comma
1783  5A15 CD F2 54     	CALL CHKCHAR
1784  5A18 2C           	DB ','
1785  5A19              	; get char data pointer
1786  5A19 DD 21 2F 54  	LD IX, FRMQNT
1787  5A1D CD 59 01     	CALL CALBAS
1788  5A20 ED 53 6B 52  	LD (BLIT_STRUCT+10), DE
1789  5A24              	; comma
1790  5A24 CD F2 54     	CALL CHKCHAR
1791  5A27 2C           	DB ','
1792  5A28              	; get mask data pointer
1793  5A28 DD 21 2F 54  	LD IX, FRMQNT
1794  5A2C CD 59 01     	CALL CALBAS
1795  5A2F ED 53 69 52  	LD (BLIT_STRUCT+8), DE
1796  5A33              	; comma
1797  5A33 CD F2 54     	CALL CHKCHAR
1798  5A36 2C           	DB ','
1799  5A37              	; get width
1800  5A37 DD 21 2F 54  	LD IX, FRMQNT
1801  5A3B CD 59 01     	CALL CALBAS
1802  5A3E 7B           	LD A, E
1803  5A3F 32 6F 52     	LD (BLIT_STRUCT+14), A
1804  5A42              	; comma
1805  5A42 CD F2 54     	CALL CHKCHAR
1806  5A45 2C           	DB ','
1807  5A46              	; get height
1808  5A46 DD 21 2F 54  	LD IX, FRMQNT
1809  5A4A CD 59 01     	CALL CALBAS
1810  5A4D 7B           	LD A, E
1811  5A4E 32 71 52     	LD (BLIT_STRUCT+16), A
1812  5A51              	; comma
1813  5A51 CD F2 54     	CALL CHKCHAR
1814  5A54 2C           	DB ','
1815  5A55              	; get background pointer
1816  5A55 DD 21 2F 54  	LD IX, FRMQNT
1817  5A59 CD 59 01     	CALL CALBAS
1818  5A5C ED 53 65 52  	LD (BLIT_STRUCT+4), DE
1819  5A60              	; comma
1820  5A60 CD F2 54     	CALL CHKCHAR
1821  5A63 2C           	DB ','
1822  5A64              	; get background width
1823  5A64 DD 21 2F 54  	LD IX, FRMQNT
1824  5A68 CD 59 01     	CALL CALBAS
1825  5A6B 7B           	LD A, E
1826  5A6C 32 5F 52     	LD (BLIT_TMP+2), A
1827  5A6F              	; comma
1828  5A6F CD F2 54     	CALL CHKCHAR
1829  5A72 2C           	DB ','
1830  5A73              	; get background height
1831  5A73 DD 21 2F 54  	LD IX, FRMQNT
1832  5A77 CD 59 01     	CALL CALBAS
1833  5A7A 7B           	LD A, E
1834  5A7B 32 60 52     	LD (BLIT_TMP+3), A
1835  5A7E              	; ending )
1836  5A7E CD F2 54     	CALL CHKCHAR
1837  5A81 29           	DB ')'
1838  5A82
1839  5A82 E5           	PUSH HL ; save position in BASIC buffer
1840  5A83
1841  5A83              	; calculate char&mask add to value
1842  5A83 26 00        	LD H, 0
1843  5A85 3A 6F 52     	LD A, (BLIT_STRUCT+14)
1844  5A88 6F           	LD L, A
1845  5A89 CD E1 53     	CALL HLx8
1846  5A8C 22 6D 52     	LD (BLIT_STRUCT+12), HL
1847  5A8F              	; calculate background add to value
1848  5A8F 26 00        	LD H, 0
1849  5A91 3A 5F 52     	LD A, (BLIT_TMP+2)
1850  5A94 6F           	LD L, A
1851  5A95 CD E1 53     	CALL HLx8
1852  5A98 22 67 52     	LD (BLIT_STRUCT+6), HL
1853  5A9B              	; calculate pointer to background location
1854  5A9B 21 00 00     	LD HL, 0
1855  5A9E 3A 5E 52     	LD A,(BLIT_TMP+1)
1856  5AA1 B7           	OR A
1857  5AA2 28 08        	JR Z, .L1
1858  5AA4 47           	LD B,A
1859  5AA5 ED 5B 67 52  	LD DE,(BLIT_STRUCT+6)
1860  5AA9              .L0:
1861  5AA9 19           	ADD HL, DE
1862  5AAA 10 FD        	DJNZ .L0
1863  5AAC              .L1:
1864  5AAC EB           	EX DE,HL
1865  5AAD 26 00        	LD H,0
1866  5AAF 3A 5D 52     	LD A,(BLIT_TMP+0)
1867  5AB2 6F           	LD L,A
1868  5AB3 CD E1 53     	CALL HLx8
1869  5AB6 19           	ADD HL,DE
1870  5AB7 ED 5B 65 52  	LD DE,(BLIT_STRUCT+4)
1871  5ABB 19           	ADD HL,DE
1872  5ABC 22 65 52     	LD (BLIT_STRUCT+4),HL
1873  5ABF
1874  5ABF FD 21 C6 5A  	LD IY, .RET
1875  5AC3 C3 A5 54     	JP ENABLE_PAGE0
1876  5AC6              .RET:
1877  5AC6 FB           	EI
1878  5AC7 DD 21 61 52  	LD IX, BLIT_STRUCT
1879  5ACB CD 53 59     	CALL SHIFT_MERGE_CHARACTER
1880  5ACE
1881  5ACE D1               POP DE
1882  5ACF C1               POP BC
1883  5AD0 CD 1C 54         CALL RESTORE_PAGE_INFO
1884  5AD3
1885  5AD3 E1           	POP HL
1886  5AD4 C9           	RET
1887  5AD5              .DAdiv8:
1888  5AD5 7B           	LD A,E
1889  5AD6 CB 2A        	SRA D
1890  5AD8 CB 1F            RR  A
1891  5ADA CB 2A            SRA D
1892  5ADC CB 1F            RR  A
1893  5ADE CB 2A            SRA D
1894  5AE0 CB 1F            RR  A
1895  5AE2 C9           	RET
1896  5AE3              ; *******************************************************************************************************
1897  5AE3               ENDIF
1898  5AE3               ENDIF
1899  5AE3
1900  5AE3               IF (TILE_CMDS == 1)
1901  5AE3              ; *******************************************************************************************************
1902  5AE3              ; generic function to implement tiling
1903  5AE3              ; should be modified to call appropriate function for memory or vram
1904  5AE3              ; input IX=pointer to following structure
1905  5AE3              ; +00 tile_data_ptr
1906  5AE3              ; +02 tile_rows
1907  5AE3              ; +04 tile_columns
1908  5AE3              ; +06 destination_address
1909  5AE3              ; +08 dest_to_next_row_add_to_value
1910  5AE3              ; +10 num_horizontal_tiles
1911  5AE3              ; +12 num_vertical_tiles
1912  5AE3              ; modifies AF, BC, DE, HL
1913  5AE3              TILE:
1914  5AE3 DD 6E 06     	LD L, (IX+6)
1915  5AE6 DD 66 07     	LD H, (IX+7) ; destination address
1916  5AE9 22 5D 52     	LD (TILETMP1), HL
1917  5AEC DD 46 0C     	LD B, (IX+12) ; vertical tile number
1918  5AEF              .L1:
1919  5AEF C5           	PUSH BC
1920  5AF0 DD 6E 00     		LD L, (IX+0)
1921  5AF3 DD 66 01     		LD H, (IX+1) ; tile address
1922  5AF6 22 5F 52     		LD (TILETMP2), HL
1923  5AF9 DD 46 02     		LD B, (IX+2) ; tile rows
1924  5AFC              .L2:
1925  5AFC C5           		PUSH BC
1926  5AFD              .CALL1:
1927  5AFD CD 00 00     			CALL 0
1928  5B00 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1929  5B03              .L3:
1930  5B03 C5           			PUSH BC
1931  5B04 2A 5F 52     				LD HL, (TILETMP2)
1932  5B07 DD 46 04     				LD B, (IX+4) ; tile columns
1933  5B0A              .L4:
1934  5B0A C5           				PUSH BC
1935  5B0B              .CALL2:
1936  5B0B CD 00 00     					CALL 0
1937  5B0E C1           				POP BC
1938  5B0F 10 F9        				DJNZ .L4
1939  5B11 C1           			POP BC
1940  5B12 10 EF        			DJNZ .L3
1941  5B14 22 5F 52     			LD (TILETMP2), HL
1942  5B17 2A 5D 52     			LD HL, (TILETMP1)
1943  5B1A DD 5E 08     			LD E, (IX+8)
1944  5B1D DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1945  5B20 19           			ADD HL, DE
1946  5B21 22 5D 52     			LD (TILETMP1), HL
1947  5B24 C1           		POP BC
1948  5B25 10 D5        		DJNZ .L2
1949  5B27 C1           	POP BC
1950  5B28 10 C5        	DJNZ .L1
1951  5B2A C9           	RET
1952  5B2B              ; *******************************************************************************************************
1953  5B2B
1954  5B2B               IFNDEF CMDS_WITH_PARAMETERS
1955  5B2B ~            ; *******************************************************************************************************
1956  5B2B ~            ; function to handle CALL TILERAM basic extension
1957  5B2B ~            ; fills memory with tiles
1958  5B2B ~            ; TILERAM ( INT request_data_ptr )
1959  5B2B ~            ; request_data_ptr described in TILE
1960  5B2B ~            ; will put ram in page 0 also, page 1 is already there
1961  5B2B ~            TILERAM:
1962  5B2B ~            	; opening (
1963  5B2B ~            	CALL CHKCHAR
1964  5B2B ~            	DB '('
1965  5B2B ~            	; get pointer to request struct
1966  5B2B ~            	LD IX, FRMQNT
1967  5B2B ~            	CALL CALBAS
1968  5B2B ~            	PUSH DE
1969  5B2B ~            	; ending )
1970  5B2B ~            	CALL CHKCHAR
1971  5B2B ~            	DB ')'
1972  5B2B ~
1973  5B2B ~            	POP IX ; pointer to request struct
1974  5B2B ~
1975  5B2B ~            	PUSH HL ; save position in BASIC buffer
1976  5B2B ~
1977  5B2B ~            	LD IY, .RET
1978  5B2B ~            	JP ENABLE_PAGE0
1979  5B2B ~            .RET:
1980  5B2B ~            	EI
1981  5B2B ~            	; set RAM functions to call
1982  5B2B ~            	LD HL, .TILECOPY
1983  5B2B ~            	LD (TILE.CALL2+1), HL
1984  5B2B ~            	LD HL, .SETDESTROW
1985  5B2B ~            	LD (TILE.CALL1+1), HL
1986  5B2B ~            	CALL TILE
1987  5B2B ~
1988  5B2B ~                POP DE
1989  5B2B ~                POP BC
1990  5B2B ~                CALL RESTORE_PAGE_INFO
1991  5B2B ~
1992  5B2B ~            	POP HL
1993  5B2B ~            	RET
1994  5B2B ~            .TILECOPY:
1995  5B2B ~            	.8 LDI
1996  5B2B ~            	RET
1997  5B2B ~            .SETDESTROW:
1998  5B2B ~            	LD DE, (TILETMP1)
1999  5B2B ~            	RET
2000  5B2B ~            ; *******************************************************************************************************
2001  5B2B               ENDIF
2002  5B2B
2003  5B2B               IFDEF CMDS_WITH_PARAMETERS
2004  5B2B              ; *******************************************************************************************************
2005  5B2B              ; function to handle CALL TILERAM basic extension
2006  5B2B              ; fills memory with tiles
2007  5B2B              ; TILERAM ( INT tile_data_pointer,
2008  5B2B              ;			INT tile_columns,
2009  5B2B              ;			INT tile_rows,
2010  5B2B              ;			INT destination_pointer,
2011  5B2B              ;			INT destination_columns,
2012  5B2B              ;			INT destination_rows,
2013  5B2B              ;			INT destination_begin_column,
2014  5B2B              ;			INT destination_begin_row,
2015  5B2B              ;			INT number_of_tiles_horizontally,
2016  5B2B              ;			INT	number_of_tiles_vertically )
2017  5B2B              ; will put ram in page 0 also, page 1 is already there
2018  5B2B              TILERAM:
2019  5B2B              	; opening (
2020  5B2B CD F2 54     	CALL CHKCHAR
2021  5B2E 28           	DB '('
2022  5B2F              	; get tile data pointer coordinate
2023  5B2F DD 21 2F 54  	LD IX, FRMQNT
2024  5B33 CD 59 01     	CALL CALBAS
2025  5B36 ED 53 61 52  	LD (BLIT_STRUCT+0), DE
2026  5B3A              	; comma
2027  5B3A CD F2 54     	CALL CHKCHAR
2028  5B3D 2C           	DB ','
2029  5B3E              	; get tile columns
2030  5B3E DD 21 2F 54  	LD IX, FRMQNT
2031  5B42 CD 59 01     	CALL CALBAS
2032  5B45 ED 53 65 52  	LD (BLIT_STRUCT+4), DE
2033  5B49              	; comma
2034  5B49 CD F2 54     	CALL CHKCHAR
2035  5B4C 2C           	DB ','
2036  5B4D              	; get tile columns
2037  5B4D DD 21 2F 54  	LD IX, FRMQNT
2038  5B51 CD 59 01     	CALL CALBAS
2039  5B54 ED 53 63 52  	LD (BLIT_STRUCT+2), DE
2040  5B58              	; comma
2041  5B58 CD F2 54     	CALL CHKCHAR
2042  5B5B 2C           	DB ','
2043  5B5C              	; get destintion pointer
2044  5B5C DD 21 2F 54  	LD IX, FRMQNT
2045  5B60 CD 59 01     	CALL CALBAS
2046  5B63 ED 53 67 52  	LD (BLIT_STRUCT+6), DE
2047  5B67              	; comma
2048  5B67 CD F2 54     	CALL CHKCHAR
2049  5B6A 2C           	DB ','
2050  5B6B              	; get destination columns
2051  5B6B DD 21 2F 54  	LD IX, FRMQNT
2052  5B6F CD 59 01     	CALL CALBAS
2053  5B72 7B           	LD A, E
2054  5B73 32 5D 52     	LD (BLIT_TMP+0), A
2055  5B76              	; comma
2056  5B76 CD F2 54     	CALL CHKCHAR
2057  5B79 2C           	DB ','
2058  5B7A              	; get destination rows
2059  5B7A DD 21 2F 54  	LD IX, FRMQNT
2060  5B7E CD 59 01     	CALL CALBAS
2061  5B81 7B           	LD A, E
2062  5B82 32 5E 52     	LD (BLIT_TMP+1), A
2063  5B85              	; comma
2064  5B85 CD F2 54     	CALL CHKCHAR
2065  5B88 2C           	DB ','
2066  5B89              	; get destination begin column
2067  5B89 DD 21 2F 54  	LD IX, FRMQNT
2068  5B8D CD 59 01     	CALL CALBAS
2069  5B90 7B           	LD A, E
2070  5B91 32 5F 52     	LD (BLIT_TMP+2), A
2071  5B94              	; comma
2072  5B94 CD F2 54     	CALL CHKCHAR
2073  5B97 2C           	DB ','
2074  5B98              	; get destination begin row
2075  5B98 DD 21 2F 54  	LD IX, FRMQNT
2076  5B9C CD 59 01     	CALL CALBAS
2077  5B9F 7B           	LD A, E
2078  5BA0 32 60 52     	LD (BLIT_TMP+3), A
2079  5BA3              	; comma
2080  5BA3 CD F2 54     	CALL CHKCHAR
2081  5BA6 2C           	DB ','
2082  5BA7              	; get number of tiles horizontally
2083  5BA7 DD 21 2F 54  	LD IX, FRMQNT
2084  5BAB CD 59 01     	CALL CALBAS
2085  5BAE ED 53 6B 52  	LD (BLIT_STRUCT+10), DE
2086  5BB2              	; comma
2087  5BB2 CD F2 54     	CALL CHKCHAR
2088  5BB5 2C           	DB ','
2089  5BB6              	; get number of tiles vertically
2090  5BB6 DD 21 2F 54  	LD IX, FRMQNT
2091  5BBA CD 59 01     	CALL CALBAS
2092  5BBD ED 53 6D 52  	LD (BLIT_STRUCT+12), DE
2093  5BC1              	; ending )
2094  5BC1 CD F2 54     	CALL CHKCHAR
2095  5BC4 29           	DB ')'
2096  5BC5
2097  5BC5 E5           	PUSH HL ; save position in BASIC buffer
2098  5BC6
2099  5BC6              	; calculate destination add to value
2100  5BC6 26 00        	LD H, 0
2101  5BC8 3A 5D 52     	LD A, (BLIT_TMP+0)
2102  5BCB 6F           	LD L, A
2103  5BCC CD E1 53     	CALL HLx8
2104  5BCF 22 69 52     	LD (BLIT_STRUCT+8), HL
2105  5BD2              	; calculate pointer to background location
2106  5BD2 21 00 00     	LD HL, 0
2107  5BD5 3A 60 52     	LD A,(BLIT_TMP+3)
2108  5BD8 B7           	OR A
2109  5BD9 28 08        	JR Z, .L1
2110  5BDB 47           	LD B,A
2111  5BDC ED 5B 69 52  	LD DE,(BLIT_STRUCT+8)
2112  5BE0              .L0:
2113  5BE0 19           	ADD HL, DE
2114  5BE1 10 FD        	DJNZ .L0
2115  5BE3              .L1:
2116  5BE3 EB           	EX DE,HL
2117  5BE4 26 00        	LD H,0
2118  5BE6 3A 5F 52     	LD A,(BLIT_TMP+2)
2119  5BE9 6F           	LD L,A
2120  5BEA CD E1 53     	CALL HLx8
2121  5BED 19           	ADD HL,DE
2122  5BEE ED 5B 67 52  	LD DE,(BLIT_STRUCT+6)
2123  5BF2 19           	ADD HL,DE
2124  5BF3 22 67 52     	LD (BLIT_STRUCT+6),HL
2125  5BF6
2126  5BF6 FD 21 FD 5B  	LD IY, .RET
2127  5BFA C3 A5 54     	JP ENABLE_PAGE0
2128  5BFD              .RET:
2129  5BFD FB           	EI
2130  5BFE              	; set RAM functions to call
2131  5BFE 21 18 5C     	LD HL, .TILECOPY
2132  5C01 22 0C 5B     	LD (TILE.CALL2+1), HL
2133  5C04 21 29 5C     	LD HL, .SETDESTROW
2134  5C07 22 FE 5A     	LD (TILE.CALL1+1), HL
2135  5C0A DD 21 61 52  	LD IX,BLIT_STRUCT
2136  5C0E CD E3 5A     	CALL TILE
2137  5C11
2138  5C11 D1               POP DE
2139  5C12 C1               POP BC
2140  5C13 CD 1C 54         CALL RESTORE_PAGE_INFO
2141  5C16
2142  5C16 E1           	POP HL
2143  5C17 C9           	RET
2144  5C18              .TILECOPY:
2145  5C18 ED A0       > LDI
2145  5C1A ED A0       > LDI
2145  5C1C ED A0       > LDI
2145  5C1E ED A0       > LDI
2145  5C20 ED A0       > LDI
2145  5C22 ED A0       > LDI
2145  5C24 ED A0       > LDI
2145  5C26 ED A0       > LDI
2146  5C28 C9           	RET
2147  5C29              .SETDESTROW:
2148  5C29 ED 5B 5D 52  	LD DE, (TILETMP1)
2149  5C2D C9           	RET
2150  5C2E              ; *******************************************************************************************************
2151  5C2E               ENDIF
2152  5C2E
2153  5C2E               IFDEF CMDS_WITH_PARAMETERS
2154  5C2E              ; *******************************************************************************************************
2155  5C2E              ; function to handle CALL TILEVRM basic extension
2156  5C2E              ; fills vram with tiles
2157  5C2E              ; TILEVRM ( INT tile_data_pointer,
2158  5C2E              ;			INT tile_columns,
2159  5C2E              ;			INT tile_rows,
2160  5C2E              ;			INT destination_begin_column,
2161  5C2E              ;			INT destination_begin_row,
2162  5C2E              ;			INT number_of_tiles_horizontally,
2163  5C2E              ;			INT	number_of_tiles_vertically )
2164  5C2E              ; will put ram in page 0 also, page 1 is already there
2165  5C2E              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2166  5C2E              TILEVRM:
2167  5C2E              	; opening (
2168  5C2E CD F2 54     	CALL CHKCHAR
2169  5C31 28           	DB '('
2170  5C32              	; get tile data pointer coordinate
2171  5C32 DD 21 2F 54  	LD IX, FRMQNT
2172  5C36 CD 59 01     	CALL CALBAS
2173  5C39 ED 53 61 52  	LD (BLIT_STRUCT+0), DE
2174  5C3D              	; comma
2175  5C3D CD F2 54     	CALL CHKCHAR
2176  5C40 2C           	DB ','
2177  5C41              	; get tile columns
2178  5C41 DD 21 2F 54  	LD IX, FRMQNT
2179  5C45 CD 59 01     	CALL CALBAS
2180  5C48 ED 53 65 52  	LD (BLIT_STRUCT+4), DE
2181  5C4C              	; comma
2182  5C4C CD F2 54     	CALL CHKCHAR
2183  5C4F 2C           	DB ','
2184  5C50              	; get tile columns
2185  5C50 DD 21 2F 54  	LD IX, FRMQNT
2186  5C54 CD 59 01     	CALL CALBAS
2187  5C57 ED 53 63 52  	LD (BLIT_STRUCT+2), DE
2188  5C5B              	; comma
2189  5C5B CD F2 54     	CALL CHKCHAR
2190  5C5E 2C           	DB ','
2191  5C5F              	; get destination begin column
2192  5C5F DD 21 2F 54  	LD IX, FRMQNT
2193  5C63 CD 59 01     	CALL CALBAS
2194  5C66 7B           	LD A, E
2195  5C67 32 5F 52     	LD (BLIT_TMP+2), A
2196  5C6A              	; comma
2197  5C6A CD F2 54     	CALL CHKCHAR
2198  5C6D 2C           	DB ','
2199  5C6E              	; get destination begin row
2200  5C6E DD 21 2F 54  	LD IX, FRMQNT
2201  5C72 CD 59 01     	CALL CALBAS
2202  5C75 7B           	LD A, E
2203  5C76 32 60 52     	LD (BLIT_TMP+3), A
2204  5C79              	; comma
2205  5C79 CD F2 54     	CALL CHKCHAR
2206  5C7C 2C           	DB ','
2207  5C7D              	; get number of tiles horizontally
2208  5C7D DD 21 2F 54  	LD IX, FRMQNT
2209  5C81 CD 59 01     	CALL CALBAS
2210  5C84 ED 53 6B 52  	LD (BLIT_STRUCT+10), DE
2211  5C88              	; comma
2212  5C88 CD F2 54     	CALL CHKCHAR
2213  5C8B 2C           	DB ','
2214  5C8C              	; get number of tiles vertically
2215  5C8C DD 21 2F 54  	LD IX, FRMQNT
2216  5C90 CD 59 01     	CALL CALBAS
2217  5C93 ED 53 6D 52  	LD (BLIT_STRUCT+12), DE
2218  5C97              	; ending )
2219  5C97 CD F2 54     	CALL CHKCHAR
2220  5C9A 29           	DB ')'
2221  5C9B
2222  5C9B E5           	PUSH HL ; save position in BASIC buffer
2223  5C9C
2224  5C9C              	; calculate destination add to value
2225  5C9C 21 00 01     	LD HL, 256
2226  5C9F 22 69 52     	LD (BLIT_STRUCT+8), HL
2227  5CA2              	; calculate pointer to background location
2228  5CA2 3A 60 52     	LD A,(BLIT_TMP+3)
2229  5CA5 67           	LD H,A
2230  5CA6 2E 00        	LD L,0
2231  5CA8 EB           	EX DE,HL
2232  5CA9 26 00        	LD H,0
2233  5CAB 3A 5F 52     	LD A,(BLIT_TMP+2)
2234  5CAE 6F           	LD L,A
2235  5CAF CD E1 53     	CALL HLx8
2236  5CB2 19           	ADD HL,DE
2237  5CB3 ED 5B CB F3  	LD DE,(GRPCGP)
2238  5CB7 19           	ADD HL,DE
2239  5CB8 22 67 52     	LD (BLIT_STRUCT+6),HL
2240  5CBB
2241  5CBB FD 21 C2 5C  	LD IY, .RET
2242  5CBF C3 A5 54     	JP ENABLE_PAGE0
2243  5CC2              .RET:
2244  5CC2 FB           	EI
2245  5CC3              	; set RAM functions to call
2246  5CC3 21 DD 5C     	LD HL, .TILECOPY
2247  5CC6 22 0C 5B     	LD (TILE.CALL2+1), HL
2248  5CC9 21 E3 5C     	LD HL, .SETDESTROW
2249  5CCC 22 FE 5A     	LD (TILE.CALL1+1), HL
2250  5CCF DD 21 61 52  	LD IX,BLIT_STRUCT
2251  5CD3 CD E3 5A     	CALL TILE
2252  5CD6
2253  5CD6 D1               POP DE
2254  5CD7 C1               POP BC
2255  5CD8 CD 1C 54         CALL RESTORE_PAGE_INFO
2256  5CDB
2257  5CDB E1           	POP HL
2258  5CDC C9           	RET
2259  5CDD              .TILECOPY:
2260  5CDD 01 98 08     	LD BC, #0898
2261  5CE0 C3 DA 53     	JP BBYTECOPY
2262  5CE3              .SETDESTROW:
2263  5CE3 2A 5D 52     	LD HL, (TILETMP1)
2264  5CE6 F3           	DI
2265  5CE7 CD CF 53     	CALL SETWRT_LOCAL
2266  5CEA FB           	EI
2267  5CEB C9           	RET
2268  5CEC              ; *******************************************************************************************************
2269  5CEC               ENDIF
2270  5CEC
2271  5CEC               IFNDEF CMDS_WITH_PARAMETERS
2272  5CEC ~            ; *******************************************************************************************************
2273  5CEC ~            ; function to handle CALL TILEVRM basic extension
2274  5CEC ~            ; fills vram with tiles
2275  5CEC ~            ; TILEVRM ( INT request_data_ptr )
2276  5CEC ~            ; request_data_ptr described in TILE
2277  5CEC ~            ; will put ram in page 0 also, page 1 is already there
2278  5CEC ~            TILEVRM:
2279  5CEC ~            	; opening (
2280  5CEC ~            	CALL CHKCHAR
2281  5CEC ~            	DB '('
2282  5CEC ~            	; get pointer to request struct
2283  5CEC ~            	LD IX, FRMQNT
2284  5CEC ~            	CALL CALBAS
2285  5CEC ~            	PUSH DE
2286  5CEC ~            	; ending )
2287  5CEC ~            	CALL CHKCHAR
2288  5CEC ~            	DB ')'
2289  5CEC ~
2290  5CEC ~            	POP IX ; pointer to request struct
2291  5CEC ~
2292  5CEC ~            	PUSH HL ; save position in BASIC buffer
2293  5CEC ~
2294  5CEC ~            	LD IY, .RET
2295  5CEC ~            	JP ENABLE_PAGE0
2296  5CEC ~            .RET:
2297  5CEC ~            	EI
2298  5CEC ~            	; set RAM functions to call
2299  5CEC ~            	LD HL, .TILECOPY
2300  5CEC ~            	LD (TILE.CALL2+1), HL
2301  5CEC ~            	LD HL, .SETDESTROW
2302  5CEC ~            	LD (TILE.CALL1+1), HL
2303  5CEC ~            	CALL TILE
2304  5CEC ~
2305  5CEC ~                POP DE
2306  5CEC ~                POP BC
2307  5CEC ~                CALL RESTORE_PAGE_INFO
2308  5CEC ~
2309  5CEC ~            	POP HL
2310  5CEC ~            	RET
2311  5CEC ~            .TILECOPY:
2312  5CEC ~            	LD BC, #0898
2313  5CEC ~            	JP BBYTECOPY
2314  5CEC ~            .SETDESTROW:
2315  5CEC ~            	LD HL, (TILETMP1)
2316  5CEC ~            	DI
2317  5CEC ~            	CALL SETWRT_LOCAL
2318  5CEC ~            	EI
2319  5CEC ~            	RET
2320  5CEC ~            ; *******************************************************************************************************
2321  5CEC               ENDIF
2322  5CEC               ENDIF
2323  5CEC
2324  5CEC               IF (BOX_CMDS == 1)
2325  5CEC              ; *******************************************************************************************************
2326  5CEC              ; generic function to implement rectangle data copy
2327  5CEC              ; should be modified to call appropriate function for memory or vram
2328  5CEC              ; input IX=pointer to following structure
2329  5CEC              ; +00 source data pointer
2330  5CEC              ; +02 num bytes in a row
2331  5CEC              ; +04 number of rows
2332  5CEC              ; +06 source add-to value till next row
2333  5CEC              ; +08 destination address
2334  5CEC              ; +10 destination add-to value till next row
2335  5CEC              ; modifies AF, BC, DE, HL
2336  5CEC              RECTANGLE_COPY:
2337  5CEC DD 6E 00     	LD L, (IX+0)
2338  5CEF DD 66 01     	LD H, (IX+1) ; source address
2339  5CF2 DD 5E 08     	LD E, (IX+8)
2340  5CF5 DD 56 09     	LD D, (IX+9) ; destination
2341  5CF8 DD 46 04     	LD B, (IX+4) ; row number
2342  5CFB              .L1:
2343  5CFB C5           	PUSH BC
2344  5CFC E5           		PUSH HL
2345  5CFD D5           			PUSH DE
2346  5CFE DD 4E 02     				LD C, (IX+2)
2347  5D01 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2348  5D04              .CALL1:
2349  5D04 CD 00 00     				CALL 0 ; set destination address from DE
2350  5D07              .CALL2:
2351  5D07 CD 00 00     				CALL 0 ; copy data fn
2352  5D0A E1           			POP HL
2353  5D0B DD 4E 0A     			LD C, (IX+10)
2354  5D0E DD 46 0B     			LD B, (IX+11) ; destination add-to
2355  5D11 09           			ADD HL, BC
2356  5D12 EB           			EX DE, HL
2357  5D13 E1           		POP HL
2358  5D14 DD 4E 06     		LD C, (IX+6)
2359  5D17 DD 46 07     		LD B, (IX+7) ; src add-to
2360  5D1A 09           		ADD HL, BC
2361  5D1B C1           	POP BC
2362  5D1C 10 DD        	DJNZ .L1
2363  5D1E C9           	RET
2364  5D1F              ; *******************************************************************************************************
2365  5D1F
2366  5D1F              ; *******************************************************************************************************
2367  5D1F              ; function to handle CALL BOXMEMCPY basic extension
2368  5D1F              ; copies data with window like boundaries to ram
2369  5D1F              ; BOXMEMCPY ( INT request_data_ptr )
2370  5D1F              ; request_data_ptr described in RECTANGLE_COPY
2371  5D1F              ; will put ram in page 0 also, page 1 is already there
2372  5D1F              BOXMEMCPY:
2373  5D1F              	; opening (
2374  5D1F CD F2 54     	CALL CHKCHAR
2375  5D22 28           	DB '('
2376  5D23              	; get pointer to request struct
2377  5D23 DD 21 2F 54  	LD IX, FRMQNT
2378  5D27 CD 59 01     	CALL CALBAS
2379  5D2A D5           	PUSH DE
2380  5D2B              	; ending )
2381  5D2B CD F2 54     	CALL CHKCHAR
2382  5D2E 29           	DB ')'
2383  5D2F
2384  5D2F DD E1        	POP IX ; pointer to request struct
2385  5D31
2386  5D31 E5           	PUSH HL ; save position in BASIC buffer
2387  5D32
2388  5D32 FD 21 39 5D  	LD IY, .RET
2389  5D36 C3 A5 54     	JP ENABLE_PAGE0
2390  5D39              .RET:
2391  5D39 FB           	EI
2392  5D3A              	; set RAM functions to call
2393  5D3A 21 00 00     	LD HL, 0
2394  5D3D 22 04 5D     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2395  5D40 22 06 5D     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2396  5D43 21 ED B0     	LD HL, #B0ED ; LDIR
2397  5D46 22 08 5D     	LD (RECTANGLE_COPY.CALL1+4), HL
2398  5D49 CD EC 5C     	CALL RECTANGLE_COPY
2399  5D4C
2400  5D4C D1               POP DE
2401  5D4D C1               POP BC
2402  5D4E CD 1C 54         CALL RESTORE_PAGE_INFO
2403  5D51
2404  5D51 E1           	POP HL
2405  5D52 C9           	RET
2406  5D53              ; *******************************************************************************************************
2407  5D53
2408  5D53              ; *******************************************************************************************************
2409  5D53              ; function to handle CALL BOXMEMVRM basic extension
2410  5D53              ; copies data with window like boundaries to ram
2411  5D53              ; BOXMEMVRM ( INT request_data_ptr )
2412  5D53              ; request_data_ptr described in RECTANGLE_COPY
2413  5D53              ; will put ram in page 0 also, page 1 is already there
2414  5D53              BOXMEMVRM:
2415  5D53              	; opening (
2416  5D53 CD F2 54     	CALL CHKCHAR
2417  5D56 28           	DB '('
2418  5D57              	; get pointer to request struct
2419  5D57 DD 21 2F 54  	LD IX, FRMQNT
2420  5D5B CD 59 01     	CALL CALBAS
2421  5D5E D5           	PUSH DE
2422  5D5F              	; ending )
2423  5D5F CD F2 54     	CALL CHKCHAR
2424  5D62 29           	DB ')'
2425  5D63
2426  5D63 DD E1        	POP IX ; pointer to request struct
2427  5D65
2428  5D65 E5           	PUSH HL ; save position in BASIC buffer
2429  5D66
2430  5D66 FD 21 6D 5D  	LD IY, .RET
2431  5D6A C3 A5 54     	JP ENABLE_PAGE0
2432  5D6D              .RET:
2433  5D6D FB           	EI
2434  5D6E              	; set RAM functions to call
2435  5D6E 21 8C 5D     	LD HL, .SETDEST
2436  5D71 22 05 5D     	LD (RECTANGLE_COPY.CALL1+1), HL
2437  5D74 21 94 5D     	LD HL, .COPYDATA
2438  5D77 22 08 5D     	LD (RECTANGLE_COPY.CALL2+1), HL
2439  5D7A 3E CD        	LD A, #CD ; CALL
2440  5D7C 32 04 5D     	LD (RECTANGLE_COPY.CALL1), A
2441  5D7F 32 07 5D     	LD (RECTANGLE_COPY.CALL2), A
2442  5D82 CD EC 5C     	CALL RECTANGLE_COPY
2443  5D85
2444  5D85 D1               POP DE
2445  5D86 C1               POP BC
2446  5D87 CD 1C 54         CALL RESTORE_PAGE_INFO
2447  5D8A
2448  5D8A E1           	POP HL
2449  5D8B C9           	RET
2450  5D8C              .SETDEST:
2451  5D8C EB           	EX DE, HL
2452  5D8D F3           	DI
2453  5D8E CD CF 53     	CALL SETWRT_LOCAL
2454  5D91 FB           	EI
2455  5D92 EB           	EX DE, HL
2456  5D93 C9           	RET
2457  5D94              .COPYDATA:
2458  5D94 41           	LD B, C
2459  5D95 0E 98        	LD C, #98
2460  5D97 C3 DA 53     	JP BBYTECOPY
2461  5D9A              ; *******************************************************************************************************
2462  5D9A               ENDIF
2463  5D9A
2464  5D9A              EXT_END:
2465  5D9A
# file closed: asm\main.asm
