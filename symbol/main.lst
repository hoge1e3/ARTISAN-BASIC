# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              SYNCHR		EQU		#558C
  33  4000              VALTYP  	EQU     #F663
  34  4000              USR     	EQU     #F7F8
  35  4000              PROCNM		EQU		#FD89
  36  4000              BIOS_FILVRM EQU     #0056
  37  4000              CLIKSW		EQU		#F3DB
  38  4000              ATRBAS		EQU		#F928
  39  4000              GRPCGP		EQU		#F3CB
  40  4000
  41  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  42  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  43  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  44  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  45  4000              EXPTBL	EQU #FCC1
  46  4000              SCRMOD	EQU #FCAF ; current screen mode
  47  4000              REG1SAV EQU #F3E0 ; VDP(1)
  48  4000
  49  4000              ; BASIC error codes
  50  4000              ;01 NEXT without FOR
  51  4000              ;02 Syntax error
  52  4000              ;03 RETURN without GOSUB
  53  4000              ;04 Out of DATA
  54  4000              ;05 Illegal function call
  55  4000              ;06 Overflow
  56  4000              ;07 Out of memory
  57  4000              ;08 Undefined line number
  58  4000              ;09 Subscript out of range
  59  4000              ;10 Redimensioned array
  60  4000              ;11 Division by zero
  61  4000              ;12 Illegal direct
  62  4000              ;13 Type mismatch
  63  4000              ;14 Out of string space
  64  4000              ;15 String too long
  65  4000              ;16 String formula too complex
  66  4000              ;17 Can't CONTINUE
  67  4000              ;18 Undefined user function
  68  4000              ;19 Device I/O error
  69  4000              ;20 Verify error
  70  4000              ;21 No RESUME
  71  4000              ;22 RESUME without error
  72  4000              ;23 Unprintable error
  73  4000              ;24 Missing operand
  74  4000              ;25 Line buffer overflow
  75  4000              ;50 FIELD overflow
  76  4000              ;51 Internal error
  77  4000              ;52 Bad file number
  78  4000              ;53 File not found
  79  4000              ;54 File already open
  80  4000              ;55 Input past end
  81  4000              ;56 Bad file name
  82  4000              ;57 Direct statement in file
  83  4000              ;58 Sequential I/O only
  84  4000              ;59 File not OPEN
  85  4000
  86  4000
  87  4000               ; simulate cartridge with BASIC extension
  88  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  88  4004 14 53 00 00
  88  4008 00 00 00 00
  88  400C 00 00 00 00
  89  4010
  90  4010              ; this location #4010 stores last location used by basic extension
  91  4010              ; free memory after that point
  92  4010              FREEMEMPTR:
  93  4010 F1 5B         DW EXT_END
  94  4012
  95  4012              ; this location #4012 stores extension version in DAA format
  96  4012              ; first byte is major version and second minor
  97  4012              VERSION:
  98  4012 00 70         DB #00, #70
  99  4014
 100  4014              ; binary included AKG player compiled at #4014
 101  4014               IF (SOUND_CMDS == 1)
 102  4014              	INCBIN "bin/AKG.bin"
 103  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 104  4CF0               ENDIF
 105  4CF0
 106  4CF0              ORIG.HTIMI:
 107  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 107  4CF4 00
 108  4CF5               EXPORT ORIG.HTIMI
 109  4CF5
 110  4CF5               IF (SOUND_CMDS == 1)
 111  4CF5              MUSIC_INIT_STATUS:
 112  4CF5 00            DB 0
 113  4CF6              SFX_INIT_STATUS:
 114  4CF6 00            DB 0
 115  4CF7              SOUND_ENABLED:
 116  4CF7 00            DB 0
 117  4CF8               ENDIF
 118  4CF8
 119  4CF8               IF (SPRITE_CMDS == 1)
 120  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 2F 52     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 51 53     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 51 53     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 51 53     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 51 53     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 69 53     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 69 53     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 69 53     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 51 53     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 51 53     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 51 53     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 51 53     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 51 53     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 51 53     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 69 53     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 69 53     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 51 53     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 51 53     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 51 53     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 51 53     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 51 53     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 44 52         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD 8B 52         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD 7B 52         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 121  4F4D               ENDIF
 122  4F4D
 123  4F4D               IF (ANIM_CMDS == 1)
 124  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E F1 5B         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 F1 5B         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 F1 5B         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; *******************************************************************************************************
  31+ 4F56              ; helper function HL=A*5
  32+ 4F56              ; changes HL,DE;
  33+ 4F56              Ax5:
  34+ 4F56 26 00            LD H,0
  35+ 4F58 6F               LD L,A
  36+ 4F59 54               LD D,H
  37+ 4F5A 5D               LD E,L
  38+ 4F5B 29               ADD HL,HL
  39+ 4F5C 29               ADD HL,HL
  40+ 4F5D 19               ADD HL,DE
  41+ 4F5E C9               RET
  42+ 4F5F              ; *******************************************************************************************************
  43+ 4F5F
  44+ 4F5F              ; *******************************************************************************************************
  45+ 4F5F              ; function to handle CALL MAXANIMITEMS basic extension
  46+ 4F5F              ; MAXANIMITEMS (BYTE number)
  47+ 4F5F              ; sets new number and moves memory buffers as needed
  48+ 4F5F              MAXANIMITEMS:
  49+ 4F5F              	; opening (
  50+ 4F5F CD 51 53     	CALL CHKCHAR
  51+ 4F62 28           	DB '('
  52+ 4F63              	; get value
  53+ 4F63 DD 21 1C 52  	LD IX, GETBYT
  54+ 4F67 CD 59 01     	CALL CALBAS
  55+ 4F6A F5               PUSH AF
  56+ 4F6B              	; ending )
  57+ 4F6B CD 51 53     	CALL CHKCHAR
  58+ 4F6E 29           	DB ')'
  59+ 4F6F F1               POP AF
  60+ 4F70
  61+ 4F70              	; save position
  62+ 4F70 E5           	PUSH HL
  63+ 4F71              MAXANIMITEMS.ENTRY:
  64+ 4F71 47               LD B,A
  65+ 4F72 3A 4D 4F         LD A,(ANIMITEMNUM)
  66+ 4F75 90               SUB B
  67+ 4F76 28 23            JR Z, .EXIT; same value as before
  68+ 4F78 DD 21 4E 4F      LD IX,ANIMITEMPTR
  69+ 4F7C FD 21 51 4F      LD IY,ANIMDEFPTR
  70+ 4F80 FA 9E 4F         JP M, .INCREASE
  71+ 4F83                  ; new value is lower than previous one
  72+ 4F83 CD B6 4F         CALL .SIZEDIFF
  73+ 4F86 CD D1 4F         CALL .DECREASE_COMMON
  74+ 4F89 2A 54 4F         LD HL,(ANIMSPRPTR)
  75+ 4F8C AF               XOR A
  76+ 4F8D ED 42            SBC HL,BC
  77+ 4F8F 22 54 4F         LD (ANIMSPRPTR),HL
  78+ 4F92 2A 10 40         LD HL,(FREEMEMPTR)
  79+ 4F95 AF               XOR A
  80+ 4F96 ED 42            SBC HL,BC
  81+ 4F98 22 10 40         LD (FREEMEMPTR),HL
  82+ 4F9B              .EXIT:
  83+ 4F9B FB               EI
  84+ 4F9C E1           	POP HL
  85+ 4F9D C9           	RET
  86+ 4F9E              .INCREASE:
  87+ 4F9E ED 44            NEG
  88+ 4FA0 CD B6 4F         CALL .SIZEDIFF
  89+ 4FA3 CD 03 50         CALL .INCREASE_COMMON
  90+ 4FA6 2A 54 4F         LD HL,(ANIMSPRPTR)
  91+ 4FA9 09               ADD HL,BC
  92+ 4FAA 22 54 4F         LD (ANIMSPRPTR),HL
  93+ 4FAD 2A 10 40         LD HL,(FREEMEMPTR)
  94+ 4FB0 09               ADD HL,BC
  95+ 4FB1 22 10 40         LD (FREEMEMPTR),HL
  96+ 4FB4 18 E5            JR .EXIT
  97+ 4FB6              .SIZEDIFF:
  98+ 4FB6 CD 56 4F         CALL Ax5
  99+ 4FB9 78               LD A,B
 100+ 4FBA 32 4D 4F         LD (ANIMITEMNUM),A
 101+ 4FBD 44               LD B,H
 102+ 4FBE 4D               LD C,L
 103+ 4FBF C9               RET ; BC=size difference in bytes
 104+ 4FC0              .SIZETOMOVE:
 105+ 4FC0 D5               PUSH DE
 106+ 4FC1 2A 10 40         LD HL,(FREEMEMPTR)
 107+ 4FC4 FD 5E 00         LD E,(IY)
 108+ 4FC7 FD 56 01         LD D,(IY+1)
 109+ 4FCA AF               XOR A
 110+ 4FCB ED 52            SBC HL,DE
 111+ 4FCD 44               LD B,H
 112+ 4FCE 4D               LD C,L
 113+ 4FCF D1               POP DE
 114+ 4FD0 C9               RET
 115+ 4FD1              .DECREASE_COMMON:
 116+ 4FD1 FD 6E 00         LD L,(IY)
 117+ 4FD4 FD 66 01         LD H,(IY+1)
 118+ 4FD7 AF               XOR A
 119+ 4FD8 ED 42            SBC HL,BC
 120+ 4FDA EB               EX DE,HL
 121+ 4FDB C5               PUSH BC
 122+ 4FDC CD C0 4F         CALL .SIZETOMOVE
 123+ 4FDF F3               DI
 124+ 4FE0 78               LD A,B
 125+ 4FE1 B1               OR C
 126+ 4FE2 28 0E            JR Z,.L1
 127+ 4FE4 FD 6E 00         LD L,(IY)
 128+ 4FE7 FD 66 01         LD H,(IY+1)
 129+ 4FEA DD 73 00         LD (IX),E
 130+ 4FED DD 72 01         LD (IX+1),D
 131+ 4FF0 ED B0            LDIR
 132+ 4FF2              .L1:
 133+ 4FF2 C1               POP BC
 134+ 4FF3 FD 6E 00         LD L,(IY)
 135+ 4FF6 FD 66 01         LD H,(IY+1)
 136+ 4FF9 AF               XOR A
 137+ 4FFA ED 42            SBC HL,BC
 138+ 4FFC FD 75 00         LD (IY),L
 139+ 4FFF FD 74 01         LD (IY+1),H
 140+ 5002 C9               RET
 141+ 5003              .INCREASE_COMMON:
 142+ 5003 2A 10 40         LD HL,(FREEMEMPTR)
 143+ 5006 2B               DEC HL
 144+ 5007 AF               XOR A
 145+ 5008 ED 42            SBC HL,BC
 146+ 500A EB               EX DE,HL
 147+ 500B C5               PUSH BC
 148+ 500C CD C0 4F         CALL .SIZETOMOVE
 149+ 500F F3               DI
 150+ 5010 78               LD A,B
 151+ 5011 B1               OR C
 152+ 5012 28 06            JR Z,.L2
 153+ 5014 2A 10 40         LD HL,(FREEMEMPTR)
 154+ 5017 2B               DEC HL
 155+ 5018 ED B8            LDDR
 156+ 501A              .L2:
 157+ 501A C1               POP BC
 158+ 501B FD 6E 00         LD L,(IY)
 159+ 501E FD 66 01         LD H,(IY+1)
 160+ 5021 09               ADD HL,BC
 161+ 5022 FD 75 00         LD (IY),L
 162+ 5025 FD 74 01         LD (IY+1),H
 163+ 5028 C9               RET
 164+ 5029              ; *******************************************************************************************************
 165+ 5029
 166+ 5029              ; *******************************************************************************************************
 167+ 5029              ; function to handle CALL ANIMITEMPAT basic extension
 168+ 5029              ; ANIMITEMPAT ( BYTE id,
 169+ 5029              ;               INT ticks,
 170+ 5029              ;               BYTE pattern,
 171+ 5029              ;               BYTE color )
 172+ 5029              ; fills animation item data, returns an error if out of bounds
 173+ 5029              ANIMITEMPAT:
 174+ 5029                  ; opening (
 175+ 5029 CD 51 53     	CALL CHKCHAR
 176+ 502C 28           	DB '('
 177+ 502D              	; get id
 178+ 502D DD 21 1C 52  	LD IX, GETBYT
 179+ 5031 CD 59 01     	CALL CALBAS
 180+ 5034 F5               PUSH AF
 181+ 5035                  ; check if out of bounds
 182+ 5035 3C               INC A
 183+ 5036 4F               LD C,A
 184+ 5037 3A 4D 4F         LD A,(ANIMITEMNUM)
 185+ 503A B9               CP C
 186+ 503B 30 05            JR NC, .L1
 187+ 503D 1E 09            LD E,9 ; subscript out of range
 188+ 503F C3 69 53         JP THROW_ERROR
 189+ 5042              .L1:
 190+ 5042              	; comma
 191+ 5042 CD 51 53     	CALL CHKCHAR
 192+ 5045 2C           	DB ','
 193+ 5046              	; get ticks
 194+ 5046 DD 21 2F 54  	LD IX, FRMQNT
 195+ 504A CD 59 01     	CALL CALBAS
 196+ 504D D5           	PUSH DE
 197+ 504E              	; comma
 198+ 504E CD 51 53     	CALL CHKCHAR
 199+ 5051 2C           	DB ','
 200+ 5052              	; get pattern
 201+ 5052 DD 21 1C 52  	LD IX, GETBYT
 202+ 5056 CD 59 01     	CALL CALBAS
 203+ 5059 F5               PUSH AF
 204+ 505A              	; comma
 205+ 505A CD 51 53     	CALL CHKCHAR
 206+ 505D 2C           	DB ','
 207+ 505E              	; get color
 208+ 505E DD 21 1C 52  	LD IX, GETBYT
 209+ 5062 CD 59 01     	CALL CALBAS
 210+ 5065 F5               PUSH AF
 211+ 5066              	; ending )
 212+ 5066 CD 51 53     	CALL CHKCHAR
 213+ 5069 29           	DB ')'
 214+ 506A              ANIMITEMPAT.ENTRY:
 215+ 506A E5               PUSH HL
 216+ 506B DD E1            POP IX
 217+ 506D D9               EXX
 218+ 506E C1               POP BC ; color
 219+ 506F D1               POP DE ; pattern
 220+ 5070 E1               POP HL ; ticks
 221+ 5071 D9               EXX
 222+ 5072 F1               POP AF
 223+ 5073 CD 56 4F         CALL Ax5
 224+ 5076 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 225+ 507A 19               ADD HL,DE
 226+ 507B E5               PUSH HL
 227+ 507C FD E1            POP IY
 228+ 507E D9               EXX
 229+ 507F FD 36 00 00      LD (IY),0 ; type=0
 230+ 5083 FD 75 01         LD (IY+1),L
 231+ 5086 FD 74 02         LD (IY+2),H
 232+ 5089 FD 72 03         LD (IY+3),D
 233+ 508C FD 70 04         LD (IY+4),B
 234+ 508F
 235+ 508F DD E5            PUSH IX
 236+ 5091 E1               POP HL
 237+ 5092 C9               RET
 238+ 5093              ; *******************************************************************************************************
 239+ 5093
 240+ 5093              ; *******************************************************************************************************
 241+ 5093              ; function to handle CALL ANIMITEMPTR basic extension
 242+ 5093              ; ANIMITEMPTR ( BYTE id,
 243+ 5093              ;               INT ticks,
 244+ 5093              ;               INT pointer,
 245+ 5093              ; fills animation item data, returns an error if out of bounds
 246+ 5093              ANIMITEMPTR_CMD:
 247+ 5093                  ; opening (
 248+ 5093 CD 51 53     	CALL CHKCHAR
 249+ 5096 28           	DB '('
 250+ 5097              	; get id
 251+ 5097 DD 21 1C 52  	LD IX, GETBYT
 252+ 509B CD 59 01     	CALL CALBAS
 253+ 509E F5               PUSH AF
 254+ 509F                  ; check if out of bounds
 255+ 509F 3C               INC A
 256+ 50A0 4F               LD C,A
 257+ 50A1 3A 4D 4F         LD A,(ANIMITEMNUM)
 258+ 50A4 B9               CP C
 259+ 50A5 30 05            JR NC, .L1
 260+ 50A7 1E 09            LD E,9 ; subscript out of range
 261+ 50A9 C3 69 53         JP THROW_ERROR
 262+ 50AC              .L1:
 263+ 50AC              	; comma
 264+ 50AC CD 51 53     	CALL CHKCHAR
 265+ 50AF 2C           	DB ','
 266+ 50B0              	; get ticks
 267+ 50B0 DD 21 2F 54  	LD IX, FRMQNT
 268+ 50B4 CD 59 01     	CALL CALBAS
 269+ 50B7 D5           	PUSH DE
 270+ 50B8              	; comma
 271+ 50B8 CD 51 53     	CALL CHKCHAR
 272+ 50BB 2C           	DB ','
 273+ 50BC              	; get pointer
 274+ 50BC DD 21 2F 54  	LD IX, FRMQNT
 275+ 50C0 CD 59 01     	CALL CALBAS
 276+ 50C3 D5           	PUSH DE
 277+ 50C4              	; ending )
 278+ 50C4 CD 51 53     	CALL CHKCHAR
 279+ 50C7 29           	DB ')'
 280+ 50C8              ANIMITEMPTR.ENTRY:
 281+ 50C8 E5               PUSH HL
 282+ 50C9 DD E1            POP IX
 283+ 50CB D9               EXX
 284+ 50CC D1               POP DE ; pointer
 285+ 50CD E1               POP HL ; ticks
 286+ 50CE D9               EXX
 287+ 50CF F1               POP AF
 288+ 50D0 CD 56 4F         CALL Ax5
 289+ 50D3 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 290+ 50D7 19               ADD HL,DE
 291+ 50D8 E5               PUSH HL
 292+ 50D9 FD E1            POP IY
 293+ 50DB D9               EXX
 294+ 50DC FD 36 00 01      LD (IY),1 ; type=1
 295+ 50E0 FD 75 01         LD (IY+1),L
 296+ 50E3 FD 74 02         LD (IY+2),H
 297+ 50E6 FD 73 03         LD (IY+3),E
 298+ 50E9 FD 72 04         LD (IY+4),D
 299+ 50EC
 300+ 50EC DD E5            PUSH IX
 301+ 50EE E1               POP HL
 302+ 50EF C9               RET
 303+ 50F0              ; *******************************************************************************************************
 304+ 50F0
# file closed: asm\ANIMATION.asm
 125  50F0               ENDIF
 126  50F0
 127  50F0              ; temp variables for BLIT, TILE functions
 128  50F0               IF (BLIT_CMDS + TILE_CMDS > 0)
 129  50F0              BLIT_TMP:
 130  50F0              TILETMP1:
 131  50F0              BLIT_TMP1:
 132  50F0 00 00         DW 0
 133  50F2              TILETMP2:
 134  50F2              BLIT_TMP2:
 135  50F2 00 00         DW 0
 136  50F4                IFDEF CMDS_WITH_PARAMETERS
 137  50F4              BLIT_STRUCT:
 138  50F4 00 00 00...   DS 17
 139  50F8                ENDIF
 140  50F8               ENDIF
 141  5105
 142  5105              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 143  5105              ; per starting letter, if no commands with this letter, NULL value
 144  5105              CMDS:
 145  5105               IF (ANIM_CMDS == 1)
 146  5105 12 52        	DW CMDS_A ;
 147  5107               ELSE
 148  5107 ~                DW 0 ; A
 149  5107               ENDIF
 150  5107               IF (BLIT_CMDS + BOX_CMDS > 0)
 151  5107 DD 51            DW CMDS_B ; B
 152  5109               ELSE
 153  5109 ~            	DW 0
 154  5109               ENDIF
 155  5109 00 00            DW 0 ; C
 156  510B 00 00            DW 0 ; D
 157  510D 00 00            DW 0 ; E
 158  510F               IF (VRAM_CMDS + RAM_CMDS > 0)
 159  510F 5B 51            DW CMDS_F; F
 160  5111               ELSE
 161  5111 ~            	DW 0
 162  5111               ENDIF
 163  5111               IF (GENCAL_CMD > 0)
 164  5111 6E 51            DW CMDS_G; G
 165  5113               ELSE
 166  5113 ~            	DW 0
 167  5113               ENDIF
 168  5113 00 00            DW 0 ; H
 169  5115 00 00            DW 0 ; I
 170  5117 00 00            DW 0 ; J
 171  5119 00 00            DW 0 ; K
 172  511B 00 00            DW 0 ; L
 173  511D               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 174  511D 39 51            DW CMDS_M ; M
 175  511F               ELSE
 176  511F ~            	DW 0
 177  511F               ENDIF
 178  511F 00 00            DW 0 ; N
 179  5121 00 00            DW 0 ; O
 180  5123 00 00            DW 0 ; P
 181  5125 00 00            DW 0 ; Q
 182  5127 00 00            DW 0 ; R
 183  5129               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 184  5129 82 51            DW CMDS_S ; S
 185  512B               ELSE
 186  512B ~            	DW 0
 187  512B               ENDIF
 188  512B               IF (TILE_CMDS > 0)
 189  512B FD 51            DW CMDS_T ; T
 190  512D               ELSE
 191  512D ~            	DW 0
 192  512D               ENDIF
 193  512D 00 00            DW 0 ; U
 194  512F               IF (VRAM_CMDS > 0)
 195  512F 78 51            DW CMDS_V ; V
 196  5131               ELSE
 197  5131 ~            	DW 0
 198  5131               ENDIF
 199  5131 00 00            DW 0 ; W
 200  5133 00 00            DW 0 ; X
 201  5135 00 00            DW 0 ; Y
 202  5137 00 00            DW 0 ; Z
 203  5139
 204  5139              CMDS_M:
 205  5139               IF (VRAM_CMDS == 1)
 206  5139 4D 45 4D 56      DB "MEMVRM", 0
 206  513D 52 4D 00
 207  5140 B1 54            DW MEMVRM
 208  5142               ENDIF
 209  5142               IF (RAM_CMDS == 1)
 210  5142 4D 45 4D 43  	DB "MEMCPY", 0
 210  5146 50 59 00
 211  5149 70 53        	DW MEMCPY
 212  514B               ENDIF
 213  514B               IF (ANIM_CMDS == 1)
 214  514B 4D 41 58 41  	DB "MAXANIMITEMS",0
 214  514F 4E 49 4D 49
 214  5153 54 45 4D 53
 214  5157 00
 215  5158 5F 4F        	DW MAXANIMITEMS
 216  515A               ENDIF
 217  515A               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 218  515A 00           	DB 0
 219  515B               ENDIF
 220  515B              CMDS_F:
 221  515B               IF (VRAM_CMDS == 1)
 222  515B 46 49 4C 56      DB "FILVRM", 0
 222  515F 52 4D 00
 223  5162 B3 53            DW FILVRM
 224  5164               ENDIF
 225  5164               IF (RAM_CMDS == 1)
 226  5164 46 49 4C 52      DB "FILRAM", 0
 226  5168 41 4D 00
 227  516B FA 53            DW FILRAM
 228  516D               ENDIF
 229  516D               IF (VRAM_CMDS + RAM_CMDS > 0)
 230  516D 00               DB 0
 231  516E               ENDIF
 232  516E              CMDS_G:
 233  516E               IF (GENCAL_CMD == 1)
 234  516E 47 45 4E 43      DB "GENCAL", 0
 234  5172 41 4C 00
 235  5175 58 54            DW GENCAL
 236  5177               ENDIF
 237  5177               IF (GENCAL_CMD > 0)
 238  5177 00           	DB	0
 239  5178               ENDIF
 240  5178              CMDS_V:
 241  5178               IF (VRAM_CMDS == 1)
 242  5178 56 52 4D 4D  	DB "VRMMEM", 0
 242  517C 45 4D 00
 243  517F 29 55        	DW VRMMEM
 244  5181               ENDIF
 245  5181               IF (VRAM_CMDS > 0)
 246  5181 00           	DB 0
 247  5182               ENDIF
 248  5182              CMDS_S:
 249  5182               IF (SPRITE_CMDS == 1)
 250  5182 53 50 52 53  	DB "SPRSET", 0
 250  5186 45 54 00
 251  5189 0E 4E        	DW SPRSET
 252  518B 53 50 52 47  	DB "SPRGRPMOV", 0
 252  518F 52 50 4D 4F
 252  5193 56 00
 253  5195 CC 4E        	DW SPRGRPMOV
 254  5197               ENDIF
 255  5197               IF (SOUND_CMDS == 1)
 256  5197 53 4E 44 53  	DB "SNDSFX", 0
 256  519B 46 58 00
 257  519E 67 56        	DW SNDSFX
 258  51A0 53 4E 44 50  	DB "SNDPLYON", 0
 258  51A4 4C 59 4F 4E
 258  51A8 00
 259  51A9 31 56        	DW SNDPLYON
 260  51AB 53 4E 44 50  	DB "SNDPLYOFF", 0
 260  51AF 4C 59 4F 46
 260  51B3 46 00
 261  51B5 44 56        	DW SNDPLYOFF
 262  51B7 53 4E 44 50  	DB "SNDPLYINI", 0
 262  51BB 4C 59 49 4E
 262  51BF 49 00
 263  51C1 E7 55        	DW SNDPLYINIT
 264  51C3               ENDIF
 265  51C3               IF (SPRITE_CMDS == 1)
 266  51C3 53 50 52 45  	DB "SPRENABLE", 0
 266  51C7 4E 41 42 4C
 266  51CB 45 00
 267  51CD B9 4D        	DW SPRENABLE
 268  51CF 53 50 52 44  	DB "SPRDISABLE", 0
 268  51D3 49 53 41 42
 268  51D7 4C 45 00
 269  51DA 09 4E        	DW SPRDISABLE
 270  51DC               ENDIF
 271  51DC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 272  51DC 00           	DB 0
 273  51DD               ENDIF
 274  51DD              CMDS_B:
 275  51DD               IF (BLIT_CMDS == 1)
 276  51DD 42 4C 49 54  	DB "BLIT", 0
 276  51E1 00
 277  51E2 3E 58        	DW BLIT
 278  51E4               ENDIF
 279  51E4               IF (BOX_CMDS == 1)
 280  51E4 42 4F 58 4D  	DB "BOXMEMCPY", 0
 280  51E8 45 4D 43 50
 280  51EC 59 00
 281  51EE 76 5B        	DW BOXMEMCPY
 282  51F0 42 4F 58 4D  	DB "BOXMEMVRM", 0
 282  51F4 45 4D 56 52
 282  51F8 4D 00
 283  51FA AA 5B        	DW BOXMEMVRM
 284  51FC               ENDIF
 285  51FC               IF (BLIT_CMDS + BOX_CMDS > 0)
 286  51FC 00           	DB 0
 287  51FD               ENDIF
 288  51FD              CMDS_T:
 289  51FD               IF (TILE_CMDS == 1)
 290  51FD 54 49 4C 45  	DB "TILERAM", 0
 290  5201 52 41 4D 00
 291  5205 82 59        	DW TILERAM
 292  5207 54 49 4C 45  	DB "TILEVRM", 0
 292  520B 56 52 4D 00
 293  520F 85 5A        	DW TILEVRM
 294  5211               ENDIF
 295  5211               IF (TILE_CMDS > 0)
 296  5211 00           	DB 0
 297  5212               ENDIF
 298  5212              CMDS_A:
 299  5212               IF (ANIM_CMDS == 1)
 300  5212 41 4E 49 4D  	DB "ANIMITEMPAT",0
 300  5216 49 54 45 4D
 300  521A 50 41 54 00
 301  521E 29 50        	DW ANIMITEMPAT
 302  5220 41 4E 49 4D  	DB "ANIMITEMPTR",0
 302  5224 49 54 45 4D
 302  5228 50 54 52 00
 303  522C 93 50        	DW ANIMITEMPTR_CMD
 304  522E 00           	DB 0
 305  522F               ENDIF
 306  522F
 307  522F               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 308  522F              ; ****************************************************************************************************
 309  522F              ; function sets VRAM address
 310  522F              ; input HL=address
 311  522F              ; modifies AF
 312  522F              SETWRT_LOCAL:
 313  522F 7D           	LD	A, L
 314  5230 D3 99        	OUT	(099H), A
 315  5232 7C           	LD	A, H
 316  5233 E6 3F        	AND	03FH
 317  5235 F6 40        	OR	040H
 318  5237 D3 99        	OUT	(099H), A
 319  5239 C9           	RET
 320  523A              ; ****************************************************************************************************
 321  523A               ENDIF
 322  523A
 323  523A               IF (VRAM_CMDS + TILE_CMDS > 0)
 324  523A              ; ****************************************************************************************************
 325  523A              ; function copies data from RAM to VRAM
 326  523A              ; input HL=address in RAM
 327  523A              ; input B=count
 328  523A              ; modifies AF
 329  523A              BBYTECOPY:
 330  523A ED A3        	OUTI
 331  523C C2 3A 52     	JP	NZ, BBYTECOPY
 332  523F C9           	RET
 333  5240              ; ****************************************************************************************************
 334  5240               ENDIF
 335  5240
 336  5240              ; ****************************************************************************************************
 337  5240              ; function multiplies HL by 8
 338  5240              HLx8:
 339  5240 29          > ADD HL, HL
 339  5241 29          > ADD HL, HL
 339  5242 29          > ADD HL, HL
 340  5243 C9           	RET
 341  5244              ; ****************************************************************************************************
 342  5244
 343  5244              ; ****************************************************************************************************
 344  5244              ; function gets slot and subslot data for specific page
 345  5244              ; input A=page (0, 1 or 2)
 346  5244              ; output B = 0A8H register value
 347  5244              ; output D = 0 is no subslots, 1 if yes
 348  5244              ; output C = 0A8H value when page 3 slot equals to requested page slot
 349  5244              ; output E = subslot value if present
 350  5244              ; modifies AF, BC, DE, HL
 351  5244              GET_PAGE_INFO:
 352  5244 6F               LD L, A
 353  5245 C6 C1            ADD A, low (EXPTBL)
 354  5247 32 51 52         LD (GET_PAGE_INFO_L1+1), A
 355  524A DB A8            IN A, (0A8H)
 356  524C 47               LD B, A
 357  524D E6 3F            AND 03FH
 358  524F 4F               LD C, A
 359  5250              GET_PAGE_INFO_L1:
 360  5250 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 361  5253 E6 80            AND 080H
 362  5255 28 1B            JR Z, GET_PAGE_INFO_L2
 363  5257                  ; expanded
 364  5257 2D               DEC L
 365  5258 FA 77 52         JP M, GET_PAGE_INFO_L3
 366  525B 2D               DEC L
 367  525C FA 75 52         JP M, GET_PAGE_INFO_L4
 368  525F                  ; page 2
 369  525F 07               RLCA
 370  5260 07               RLCA
 371  5261              GET_PAGE_INFO_L5:
 372  5261 E6 C0            AND 0C0H
 373  5263 B1               OR C
 374  5264 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 375  5266 4F               LD C, A
 376  5267 3A FF FF         LD A, (0FFFFH)
 377  526A 2F               CPL
 378  526B 5F               LD E, A
 379  526C 16 01            LD D, 1
 380  526E 78               LD A, B ; return stack
 381  526F D3 A8            OUT (0A8H), A
 382  5271 C9               RET
 383  5272              GET_PAGE_INFO_L2:
 384  5272                  ; not expanded
 385  5272 16 00            LD D, 0
 386  5274 C9               RET
 387  5275              GET_PAGE_INFO_L4:
 388  5275                  ; page 1
 389  5275 0F               RRCA
 390  5276 0F               RRCA
 391  5277              GET_PAGE_INFO_L3:
 392  5277                  ; page 0
 393  5277 0F               RRCA
 394  5278 0F               RRCA
 395  5279 18 E6            JR GET_PAGE_INFO_L5
 396  527B              ; ****************************************************************************************************
 397  527B
 398  527B              ; ****************************************************************************************************
 399  527B              ; function returns original slot and subslot info
 400  527B              ; input B = 0A8H register value
 401  527B              ; input D = 0 is no subslots, 1 if yes
 402  527B              ; input C = 0A8H value when page 3 slot equals to requested page slot
 403  527B              ; input E = subslot value if present
 404  527B              ; modifies AF, disables interrupts
 405  527B              RESTORE_PAGE_INFO:
 406  527B 7A               LD A, D
 407  527C B7               OR A
 408  527D 28 08            JR Z, RESTORE_PAGE_INFO_L1
 409  527F 79               LD A, C
 410  5280 F3           	DI
 411  5281 D3 A8            OUT (0A8H), A
 412  5283 7B               LD A, E
 413  5284 32 FF FF         LD (0FFFFH), A
 414  5287              RESTORE_PAGE_INFO_L1:
 415  5287 78               LD A, B
 416  5288 D3 A8            OUT (0A8H), A
 417  528A C9               RET
 418  528B              ; ****************************************************************************************************
 419  528B
 420  528B              ; *******************************************************************************************************
 421  528B              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 422  528B              ; INPUT:  A = SLOT ID: EXXXSSPP
 423  528B              ; E = EXPANDED FLAG
 424  528B              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 425  528B              ; PP = PRIMARY SLOT NUMBER
 426  528B              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 427  528B              ; CHANGES: AF, BC, DE
 428  528B
 429  528B              LOCAL_ENASLT:
 430  528B CD AB 52         CALL L0353
 431  528E FA 98 52         JP M, L0340
 432  5291 DB A8            IN A, (0A8H)
 433  5293 A1               AND C
 434  5294 B0               OR B
 435  5295 D3 A8            OUT (0A8H), A
 436  5297 C9               RET
 437  5298              L0340:
 438  5298 E5               PUSH HL
 439  5299 CD D0 52         CALL L0378
 440  529C 4F               LD C, A
 441  529D 06 00            LD B, 0
 442  529F 7D               LD A, L
 443  52A0 A4               AND H
 444  52A1 B2               OR D
 445  52A2 21 C5 FC         LD HL, 0FCC5H
 446  52A5 09               ADD HL, BC
 447  52A6 77               LD (HL), A
 448  52A7 E1               POP HL
 449  52A8 79               LD A, C
 450  52A9 18 E0            JR LOCAL_ENASLT
 451  52AB              L0353:
 452  52AB F3               DI
 453  52AC F5               PUSH AF
 454  52AD 7C               LD A, H
 455  52AE 07               RLCA
 456  52AF 07               RLCA
 457  52B0 E6 03            AND 3
 458  52B2 5F               LD E, A
 459  52B3 3E C0            LD A, 0C0H
 460  52B5              L035D:
 461  52B5 07               RLCA
 462  52B6 07               RLCA
 463  52B7 1D               DEC E
 464  52B8 F2 B5 52         JP P, L035D
 465  52BB 5F               LD E, A
 466  52BC 2F               CPL
 467  52BD 4F               LD C, A
 468  52BE F1               POP AF
 469  52BF F5               PUSH AF
 470  52C0 E6 03            AND 3
 471  52C2 3C               INC A
 472  52C3 47               LD B, A
 473  52C4 3E AB            LD A, 0ABH
 474  52C6              L036E:
 475  52C6 C6 55            ADD A, 055H
 476  52C8 10 FC            DJNZ L036E
 477  52CA 57               LD D, A
 478  52CB A3               AND E
 479  52CC 47               LD B, A
 480  52CD F1               POP AF
 481  52CE A7               AND A
 482  52CF C9               RET
 483  52D0              L0378:
 484  52D0 F5               PUSH AF
 485  52D1 7A               LD A, D
 486  52D2 E6 C0            AND 0C0H
 487  52D4 4F               LD C, A
 488  52D5 F1               POP AF
 489  52D6 F5               PUSH AF
 490  52D7 57               LD D, A
 491  52D8 DB A8            IN A, (0A8H)
 492  52DA 47               LD B, A
 493  52DB E6 3F            AND 03FH
 494  52DD B1               OR C
 495  52DE D3 A8            OUT (0A8H), A
 496  52E0 7A               LD A, D
 497  52E1 0F               RRCA
 498  52E2 0F               RRCA
 499  52E3 E6 03            AND 3
 500  52E5 57               LD D, A
 501  52E6 3E AB            LD A, 0ABH
 502  52E8              L0390:
 503  52E8 C6 55            ADD A, 055H
 504  52EA 15               DEC D
 505  52EB F2 E8 52         JP P, L0390
 506  52EE A3               AND E
 507  52EF 57               LD D, A
 508  52F0 7B               LD A, E
 509  52F1 2F               CPL
 510  52F2 67               LD H, A
 511  52F3 3A FF FF         LD A, (0FFFFH)
 512  52F6 2F               CPL
 513  52F7 6F               LD L, A
 514  52F8 A4               AND H
 515  52F9 B2               OR D
 516  52FA 32 FF FF         LD (0FFFFH), A
 517  52FD 78               LD A, B
 518  52FE D3 A8            OUT (0A8H), A
 519  5300 F1               POP AF
 520  5301 E6 03            AND 3
 521  5303 C9               RET
 522  5304              ; *******************************************************************************************************
 523  5304
 524  5304              ; *******************************************************************************************************
 525  5304              ; some common code to activate page 0 and place values needed to restore original page on stack
 526  5304              ; input IY=return address
 527  5304              ENABLE_PAGE0:
 528  5304 AF               XOR A
 529  5305 CD 44 52         CALL GET_PAGE_INFO
 530  5308 C5               PUSH BC
 531  5309 D5               PUSH DE
 532  530A 3A 41 F3         LD A, (RAMAD0)
 533  530D 26 00            LD H, 0
 534  530F CD 8B 52         CALL LOCAL_ENASLT
 535  5312 FD E9        	JP (IY)
 536  5314              ; *******************************************************************************************************
 537  5314
 538  5314              ; General BASIC CALL-instruction handler
 539  5314              CALLHAND:
 540  5314 E5           	PUSH HL
 541  5315 21 05 51     	LD	HL, CMDS ; pointer table based on starting letter
 542  5318 3A 89 FD         LD A, (PROCNM)
 543  531B D6 41            SUB 'A'
 544  531D 87               ADD A, A
 545  531E 16 00            LD D, 0
 546  5320 5F               LD E, A
 547  5321 19               ADD HL, DE
 548  5322 5E               LD E, (HL)
 549  5323 23               INC HL
 550  5324 56               LD D, (HL)
 551  5325 7A               LD A, D
 552  5326 B3               OR E
 553  5327 28 23            JR Z, .CMDNOTRECOGNIZED
 554  5329 EB               EX DE, HL
 555  532A              .CHKCMD:
 556  532A 11 89 FD     	LD	DE, PROCNM
 557  532D 1A           .LOOP:	LD	A,(DE)
 558  532E BE           	CP	(HL)
 559  532F 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 560  5331 13           	INC	DE
 561  5332 23           	INC	HL
 562  5333 A7           	AND	A
 563  5334 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 564  5336 5E           	LD	E,(HL)
 565  5337 23           	INC	HL
 566  5338 56           	LD	D,(HL)
 567  5339 E1           	POP	HL		; routine address
 568  533A CD 5B 53     	CALL	GETPREVCHAR
 569  533D CD 4F 53     	CALL	.CALLDE		; Call routine
 570  5340 A7           	AND	A
 571  5341 C9           	RET
 572  5342
 573  5342              .TONEXTCMD:
 574  5342 0E FF        	LD	C,0FFH
 575  5344 AF           	XOR	A
 576  5345 ED B1        	CPIR			; Skip to end of instruction name
 577  5347 23           	INC	HL
 578  5348 23           	INC	HL		; Skip address
 579  5349 BE           	CP	(HL)
 580  534A 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 581  534C              .CMDNOTRECOGNIZED:
 582  534C E1           	POP	HL
 583  534D 37               SCF
 584  534E C9           	RET
 585  534F
 586  534F              .CALLDE:
 587  534F D5           	PUSH	DE
 588  5350 C9           	RET
 589  5351
 590  5351              ;---------------------------
 591  5351
 592  5351              ;GETSTRPNT:
 593  5351              ; OUT:
 594  5351              ; HL = String Address
 595  5351              ; B  = Lenght
 596  5351              ;        LD      HL,(USR)
 597  5351              ;        LD      B,(HL)
 598  5351              ;        INC     HL
 599  5351              ;        LD      E,(HL)
 600  5351              ;        INC     HL
 601  5351              ;        LD      D,(HL)
 602  5351              ;        EX      DE,HL
 603  5351              ;        RET
 604  5351
 605  5351              ;EVALTXTPARAM:
 606  5351              ;	CALL	CHKCHAR
 607  5351              ;	DEFB	"("             ; Check for (
 608  5351              ;	LD	IX,FRMEVL
 609  5351              ;	CALL	CALBAS		; Evaluate expression
 610  5351              ;       LD      A,(VALTYP)
 611  5351              ;        CP      3               ; Text type?
 612  5351              ;        JP      NZ,TYPE_MISMATCH
 613  5351              ;        PUSH	HL
 614  5351              ;        LD	IX,FRESTR         ; Free the temporary string
 615  5351              ;        CALL	CALBAS
 616  5351              ;        POP	HL
 617  5351              ;	CALL	CHKCHAR
 618  5351              ;	DEFB	")"             ; Check for )
 619  5351              ;        RET
 620  5351
 621  5351
 622  5351              CHKCHAR:
 623  5351 CD 5B 53     	CALL	GETPREVCHAR	; Get previous basic char
 624  5354 E3           	EX	(SP),HL
 625  5355 BE           	CP	(HL) 	        ; Check if good char
 626  5356 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 627  5358 23           	INC	HL
 628  5359 E3           	EX	(SP),HL
 629  535A 23           	INC	HL		; Get next basic char
 630  535B
 631  535B              GETPREVCHAR:
 632  535B 2B           	DEC	HL
 633  535C DD 21 66 46  	LD	IX,CHRGTR
 634  5360 C3 59 01     	JP      CALBAS
 635  5363
 636  5363
 637  5363              TYPE_MISMATCH:
 638  5363 1E 0D            LD E, 13 ; Type mismatch
 639  5365 18 02            JR THROW_ERROR
 640  5367
 641  5367              SYNTAX_ERROR:
 642  5367 1E 02            LD E, 2 ; Syntax error
 643  5369              THROW_ERROR:
 644  5369 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 645  536D C3 59 01     	JP	CALBAS
 646  5370
 647  5370              ;---------------------------
 648  5370
 649  5370               IF (RAM_CMDS == 1)
 650  5370              ; *******************************************************************************************************
 651  5370              ; function to handle CALL MEMCPY basic extension
 652  5370              ; _MEMCPY ( INT source,
 653  5370              ;			INT destination,
 654  5370              ;			INT count,
 655  5370              ; will put ram in page 0 also, page 1 is already there
 656  5370              MEMCPY:
 657  5370              	; opening (
 658  5370 CD 51 53     	CALL CHKCHAR
 659  5373 28           	DB '('
 660  5374              	; get source address
 661  5374 DD 21 2F 54  	LD IX, FRMQNT
 662  5378 CD 59 01     	CALL CALBAS
 663  537B D5           	PUSH DE
 664  537C              	; comma
 665  537C CD 51 53     	CALL CHKCHAR
 666  537F 2C           	DB ','
 667  5380              	; get destination address
 668  5380 DD 21 2F 54  	LD IX, FRMQNT
 669  5384 CD 59 01     	CALL CALBAS
 670  5387 D5           	PUSH DE
 671  5388              	; comma
 672  5388 CD 51 53     	CALL CHKCHAR
 673  538B 2C           	DB ','
 674  538C              	; get length
 675  538C DD 21 2F 54  	LD IX, FRMQNT
 676  5390 CD 59 01     	CALL CALBAS
 677  5393 D5           	PUSH DE
 678  5394              	; ending )
 679  5394 CD 51 53     	CALL CHKCHAR
 680  5397 29           	DB ')'
 681  5398
 682  5398              	; save position
 683  5398 E5           	PUSH HL
 684  5399 DD E1        	POP IX
 685  539B
 686  539B C1           	POP BC ; count
 687  539C D1           	POP DE ; destination
 688  539D E1           	POP HL ; source
 689  539E D9           	EXX
 690  539F              	; enable page 0
 691  539F FD 21 A6 53  	LD IY, .RET
 692  53A3 C3 04 53     	JP ENABLE_PAGE0
 693  53A6              .RET:
 694  53A6 FB           	EI
 695  53A7 D9           	EXX
 696  53A8 ED B0        	LDIR
 697  53AA D1               POP DE
 698  53AB C1               POP BC
 699  53AC CD 7B 52         CALL RESTORE_PAGE_INFO
 700  53AF DD E5        	PUSH IX
 701  53B1 E1           	POP HL
 702  53B2 C9           	RET
 703  53B3              ; *******************************************************************************************************
 704  53B3               ENDIF
 705  53B3
 706  53B3               IF (VRAM_CMDS == 1)
 707  53B3              ; *******************************************************************************************************
 708  53B3              ; function to handle CALL FILVRM basic extension
 709  53B3              ; FILVRM ( INT offset,
 710  53B3              ;		   INT count,
 711  53B3              ;		   BYTE value,
 712  53B3              ;		   BYTE wait_vsync) >0 = true
 713  53B3              ; wait_vsync will issue HALT before copying
 714  53B3              FILVRM:
 715  53B3              	; opening (
 716  53B3 CD 51 53     	CALL CHKCHAR
 717  53B6 28           	DB '('
 718  53B7              	; get offset address
 719  53B7 DD 21 2F 54  	LD IX, FRMQNT
 720  53BB CD 59 01     	CALL CALBAS
 721  53BE D5           	PUSH DE
 722  53BF              	; comma
 723  53BF CD 51 53     	CALL CHKCHAR
 724  53C2 2C           	DB ','
 725  53C3              	; get count
 726  53C3 DD 21 2F 54  	LD IX, FRMQNT
 727  53C7 CD 59 01     	CALL CALBAS
 728  53CA D5           	PUSH DE
 729  53CB              	; comma
 730  53CB CD 51 53     	CALL CHKCHAR
 731  53CE 2C           	DB ','
 732  53CF              	; get value
 733  53CF DD 21 1C 52  	LD IX, GETBYT
 734  53D3 CD 59 01     	CALL CALBAS
 735  53D6 F5           	PUSH AF
 736  53D7              	; comma
 737  53D7 CD 51 53     	CALL CHKCHAR
 738  53DA 2C           	DB ','
 739  53DB              	; get vsync wait
 740  53DB DD 21 1C 52  	LD IX, GETBYT
 741  53DF CD 59 01     	CALL CALBAS
 742  53E2 F5           	PUSH AF
 743  53E3              	; ending )
 744  53E3 CD 51 53     	CALL CHKCHAR
 745  53E6 29           	DB ')'
 746  53E7
 747  53E7 FB               EI
 748  53E8              	; save position
 749  53E8 E5           	PUSH HL
 750  53E9 DD E1        	POP IX
 751  53EB
 752  53EB              	; syntax ok
 753  53EB              	; wait for vsync if needed
 754  53EB F1           	POP AF
 755  53EC B7           	OR A
 756  53ED 28 01        	JR Z, .L1
 757  53EF 76           	HALT
 758  53F0
 759  53F0              .L1:
 760  53F0 F1               POP AF ; value
 761  53F1 C1               POP BC ; count
 762  53F2 E1               POP HL ; offset
 763  53F3 CD 56 00         CALL BIOS_FILVRM
 764  53F6
 765  53F6              .L3:
 766  53F6 DD E5        	PUSH IX
 767  53F8 E1           	POP HL
 768  53F9 C9           	RET
 769  53FA              ; *******************************************************************************************************
 770  53FA               ENDIF
 771  53FA
 772  53FA               IF (RAM_CMDS == 1)
 773  53FA              ; *******************************************************************************************************
 774  53FA              ; function to handle CALL FILRAM basic extension
 775  53FA              ; FILRAM ( INT start address,
 776  53FA              ;		   INT count,
 777  53FA              ;		   BYTE value,
 778  53FA              ; will put ram in page 0 also, page 1 is already there
 779  53FA              FILRAM:
 780  53FA              	; opening (
 781  53FA CD 51 53     	CALL CHKCHAR
 782  53FD 28           	DB '('
 783  53FE              	; get start address
 784  53FE DD 21 2F 54  	LD IX, FRMQNT
 785  5402 CD 59 01     	CALL CALBAS
 786  5405 D5           	PUSH DE
 787  5406              	; comma
 788  5406 CD 51 53     	CALL CHKCHAR
 789  5409 2C           	DB ','
 790  540A              	; get count
 791  540A DD 21 2F 54  	LD IX, FRMQNT
 792  540E CD 59 01     	CALL CALBAS
 793  5411 D5           	PUSH DE
 794  5412              	; comma
 795  5412 CD 51 53     	CALL CHKCHAR
 796  5415 2C           	DB ','
 797  5416              	; get value
 798  5416 DD 21 1C 52  	LD IX, GETBYT
 799  541A CD 59 01     	CALL CALBAS
 800  541D F5           	PUSH AF
 801  541E              	; ending )
 802  541E CD 51 53     	CALL CHKCHAR
 803  5421 29           	DB ')'
 804  5422
 805  5422              	; save position
 806  5422 E5           	PUSH HL
 807  5423 DD E1        	POP IX
 808  5425
 809  5425 D1           	POP DE ; actually AF
 810  5426 C1           	POP BC ; count
 811  5427 E1           	POP HL ; start address
 812  5428 78           	LD A, B
 813  5429 B7           	OR A
 814  542A 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 815  542C B1           	OR C
 816  542D 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 817  542F 79           	LD A, C
 818  5430 3D           	DEC A
 819  5431 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 820  5433              	; one byte to fill
 821  5433 72           	LD (HL), D
 822  5434 18 12        	JR .EXIT
 823  5436              .L1:
 824  5436 D9           	EXX
 825  5437              	; enable page 0
 826  5437 FD 21 3E 54  	LD IY, .RET
 827  543B C3 04 53     	JP ENABLE_PAGE0
 828  543E              .RET:
 829  543E FB           	EI
 830  543F D9           	EXX
 831  5440 CD 4C 54     	CALL .FILLVALUE
 832  5443 D1               POP DE
 833  5444 C1               POP BC
 834  5445 CD 7B 52         CALL RESTORE_PAGE_INFO
 835  5448              .EXIT:
 836  5448 DD E5        	PUSH IX
 837  544A E1           	POP HL
 838  544B C9           	RET
 839  544C
 840  544C              .FILLVALUE:
 841  544C 72               LD (HL), D
 842  544D 54               LD D, H
 843  544E 5D               LD E, L
 844  544F 13               INC DE
 845  5450 0B               DEC BC
 846  5451 ED B0            LDIR
 847  5453 C9               RET
 848  5454              ; *******************************************************************************************************
 849  5454               ENDIF
 850  5454
 851  5454               IF (GENCAL_CMD == 1)
 852  5454              ; *******************************************************************************************************
 853  5454              ; function to handle CALL GENCAL basic extension
 854  5454              ; GENCAL ( INT fn_addr, = address of the function to call
 855  5454              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 856  5454              ; output values of reristers will also be stored at reg_list_ptr
 857  5454              GENCAL_VAR_SP:
 858  5454 00 00            DW 0
 859  5456              GENCAL_VAR_SP2:
 860  5456 00 00            DW 0
 861  5458              GENCAL:
 862  5458              	; opening (
 863  5458 CD 51 53     	CALL CHKCHAR
 864  545B 28           	DB '('
 865  545C              	; get function address
 866  545C DD 21 2F 54  	LD IX, FRMQNT
 867  5460 CD 59 01     	CALL CALBAS
 868  5463 D5           	PUSH DE
 869  5464              	; comma
 870  5464 CD 51 53     	CALL CHKCHAR
 871  5467 2C           	DB ','
 872  5468              	; get pointer to register list
 873  5468 DD 21 2F 54  	LD IX, FRMQNT
 874  546C CD 59 01     	CALL CALBAS
 875  546F D5           	PUSH DE
 876  5470              	; ending )
 877  5470 CD 51 53     	CALL CHKCHAR
 878  5473 29           	DB ')'
 879  5474
 880  5474              	; save BASIC token position
 881  5474 E5           	PUSH HL
 882  5475 D9               EXX
 883  5476 E1           	POP HL ; HL'=next basic token
 884  5477 D9               EXX
 885  5478
 886  5478 E1               POP HL ; get pointer to register values
 887  5479 F3           	DI
 888  547A ED 73 54 54      LD (GENCAL_VAR_SP), SP
 889  547E F9               LD SP, HL
 890  547F F1               POP AF
 891  5480 C1               POP BC
 892  5481 D1               POP DE
 893  5482 E1               POP HL
 894  5483 DD E1            POP IX
 895  5485 FD E1            POP IY
 896  5487 D9               EXX
 897  5488 ED 73 56 54      LD (GENCAL_VAR_SP2), SP
 898  548C ED 7B 54 54      LD SP, (GENCAL_VAR_SP)
 899  5490 FB               EI
 900  5491 D1               POP DE ; get function to call
 901  5492 E5               PUSH HL
 902  5493 CD AE 54         CALL .EXXDECALL
 903  5496 F3               DI
 904  5497 ED 73 54 54      LD (GENCAL_VAR_SP), SP
 905  549B ED 7B 56 54      LD SP, (GENCAL_VAR_SP2)
 906  549F FD E5            PUSH IY
 907  54A1 DD E5            PUSH IX
 908  54A3 E5               PUSH HL
 909  54A4 D5               PUSH DE
 910  54A5 C5               PUSH BC
 911  54A6 F5               PUSH AF
 912  54A7 ED 7B 54 54      LD SP, (GENCAL_VAR_SP)
 913  54AB FB               EI
 914  54AC E1               POP HL
 915  54AD C9           	RET
 916  54AE
 917  54AE              .EXXDECALL:
 918  54AE D5               PUSH DE
 919  54AF D9               EXX
 920  54B0 C9               RET
 921  54B1              ; *******************************************************************************************************
 922  54B1               ENDIF
 923  54B1
 924  54B1               IF (VRAM_CMDS == 1)
 925  54B1              ; *******************************************************************************************************
 926  54B1              ; function to handle CALL MEMVRM basic extension
 927  54B1              ; copies from RAM to VRAM
 928  54B1              ; _MEMVRM ( INT source,
 929  54B1              ;			INT destination,
 930  54B1              ;			INT count,
 931  54B1              ;			BYTE wait_vsync) >0 = true
 932  54B1              ; will put ram in page 0 also, page 1 is already there
 933  54B1              ; wait_vsync will issue HALT before copying
 934  54B1              MEMVRM:
 935  54B1              	; opening (
 936  54B1 CD 51 53     	CALL CHKCHAR
 937  54B4 28           	DB '('
 938  54B5              	; get source address
 939  54B5 DD 21 2F 54  	LD IX, FRMQNT
 940  54B9 CD 59 01     	CALL CALBAS
 941  54BC D5           	PUSH DE
 942  54BD              	; comma
 943  54BD CD 51 53     	CALL CHKCHAR
 944  54C0 2C           	DB ','
 945  54C1              	; get destination address
 946  54C1 DD 21 2F 54  	LD IX, FRMQNT
 947  54C5 CD 59 01     	CALL CALBAS
 948  54C8 D5           	PUSH DE
 949  54C9              	; comma
 950  54C9 CD 51 53     	CALL CHKCHAR
 951  54CC 2C           	DB ','
 952  54CD              	; get length
 953  54CD DD 21 2F 54  	LD IX, FRMQNT
 954  54D1 CD 59 01     	CALL CALBAS
 955  54D4 D5           	PUSH DE
 956  54D5              	; comma
 957  54D5 CD 51 53     	CALL CHKCHAR
 958  54D8 2C           	DB ','
 959  54D9              	; get vsync wait
 960  54D9 DD 21 1C 52  	LD IX, GETBYT
 961  54DD CD 59 01     	CALL CALBAS
 962  54E0 F5           	PUSH AF
 963  54E1              	; ending )
 964  54E1 CD 51 53     	CALL CHKCHAR
 965  54E4 29           	DB ')'
 966  54E5
 967  54E5                  ; save position in BASIC text
 968  54E5 E5           	PUSH HL
 969  54E6 DD E1        	POP IX
 970  54E8
 971  54E8 F1           	POP AF ; wait vsync
 972  54E9 B7           	OR A
 973  54EA 28 03        	JR Z, .L1
 974  54EC FB               EI
 975  54ED 76           	HALT
 976  54EE F3           	DI
 977  54EF              .L1:
 978  54EF              	; pop LDIR parameters and store away for later
 979  54EF C1           	POP BC ; count
 980  54F0 D1           	POP DE ; vram destination
 981  54F1 E1           	POP HL ; ram source
 982  54F2 D9           	EXX
 983  54F3 FD 21 FA 54   	LD IY, .RET
 984  54F7 C3 04 53     	JP ENABLE_PAGE0
 985  54FA              .RET:
 986  54FA FB           	EI
 987  54FB D9           	EXX
 988  54FC CD 08 55     	CALL .LDIRVM
 989  54FF D1               POP DE
 990  5500 C1               POP BC
 991  5501 CD 7B 52         CALL RESTORE_PAGE_INFO
 992  5504 DD E5        	PUSH IX
 993  5506 E1           	POP HL
 994  5507 C9           	RET
 995  5508
 996  5508              .LDIRVM:
 997  5508 EB           	EX DE, HL
 998  5509 F3           	DI
 999  550A CD 2F 52     	CALL SETWRT_LOCAL
1000  550D FB           	EI
1001  550E EB           	EX DE, HL
1002  550F 78           	LD A, B
1003  5510 B7           	OR A
1004  5511 28 0D        	JR Z, .L3
1005  5513 C5           	PUSH BC
1006  5514 0E 98        	LD C, #98
1007  5516              .L2:
1008  5516 50           	LD D, B
1009  5517 06 00        	LD B, 0
1010  5519 CD 3A 52     	CALL BBYTECOPY
1011  551C 42           	LD B, D
1012  551D 10 F7        	DJNZ .L2
1013  551F C1           	POP BC
1014  5520              .L3:
1015  5520 79           	LD A, C
1016  5521 B7           	OR A
1017  5522 C8           	RET Z
1018  5523 41           	LD B, C
1019  5524 0E 98        	LD C, #98
1020  5526 C3 3A 52     	JP BBYTECOPY
1021  5529              ; *******************************************************************************************************
1022  5529               ENDIF
1023  5529
1024  5529               IF (VRAM_CMDS == 1)
1025  5529              ; *******************************************************************************************************
1026  5529              ; function to handle CALL VRMMEM basic extension
1027  5529              ; copies from RAM to VRAM
1028  5529              ; _VRMMEM ( INT source,
1029  5529              ;			INT destination,
1030  5529              ;			INT count
1031  5529              ; will put ram in page 0 also, page 1 is already there
1032  5529              VRMMEM:
1033  5529              	; opening (
1034  5529 CD 51 53     	CALL CHKCHAR
1035  552C 28           	DB '('
1036  552D              	; get source address
1037  552D DD 21 2F 54  	LD IX, FRMQNT
1038  5531 CD 59 01     	CALL CALBAS
1039  5534 D5           	PUSH DE
1040  5535              	; comma
1041  5535 CD 51 53     	CALL CHKCHAR
1042  5538 2C           	DB ','
1043  5539              	; get destination address
1044  5539 DD 21 2F 54  	LD IX, FRMQNT
1045  553D CD 59 01     	CALL CALBAS
1046  5540 D5           	PUSH DE
1047  5541              	; comma
1048  5541 CD 51 53     	CALL CHKCHAR
1049  5544 2C           	DB ','
1050  5545              	; get length
1051  5545 DD 21 2F 54  	LD IX, FRMQNT
1052  5549 CD 59 01     	CALL CALBAS
1053  554C D5           	PUSH DE
1054  554D              	; ending )
1055  554D CD 51 53     	CALL CHKCHAR
1056  5550 29           	DB ')'
1057  5551
1058  5551                  ; save position in BASIC text
1059  5551 E5           	PUSH HL
1060  5552 DD E1        	POP IX
1061  5554
1062  5554 C1           	POP BC ; count
1063  5555 D1           	POP DE ; destination
1064  5556 E1           	POP HL ; source
1065  5557 D9           	EXX
1066  5558 FD 21 5F 55  	LD IY, .RET
1067  555C C3 04 53     	JP ENABLE_PAGE0
1068  555F              .RET:
1069  555F FB           	EI
1070  5560 D9           	EXX
1071  5561 CD 6D 55     	CALL .LDIRMV
1072  5564 D1               POP DE
1073  5565 C1               POP BC
1074  5566 CD 7B 52         CALL RESTORE_PAGE_INFO
1075  5569 DD E5        	PUSH IX
1076  556B E1           	POP HL
1077  556C C9           	RET
1078  556D
1079  556D              .LDIRMV:
1080  556D              	; set VRAM address *exactly* as in ROM, otherwise corruption
1081  556D 7D           	LD	A, L
1082  556E F3           	DI
1083  556F D3 99        	OUT	(099H), A
1084  5571 7C           	LD	A, H
1085  5572 E6 3F        	AND	03FH
1086  5574 D3 99        	OUT	(099H), A
1087  5576 FB           	EI
1088  5577              	;EX (SP), HL
1089  5577              	;EX (SP), HL
1090  5577              	;NOP
1091  5577              	;NOP
1092  5577              .L4:
1093  5577 DB 98            IN A, (#98)
1094  5579 12           	LD (DE), A
1095  557A 13               INC DE
1096  557B 0B               DEC BC
1097  557C 79               LD A, C
1098  557D B0               OR B
1099  557E 20 F7            JR NZ, .L4
1100  5580 C9               RET
1101  5581              ; *******************************************************************************************************
1102  5581               ENDIF
1103  5581
1104  5581              ; *******************************************************************************************************
1105  5581              ; H.TIMI function
1106  5581              MBGE_HTIMI:
1107  5581               EXPORT MBGE_HTIMI
1108  5581 F5           	PUSH AF
1109  5582
1110  5582               IF (SPRITE_CMDS == 1)
1111  5582 CD 01 4D     	CALL SPRATR_UPDATE
1112  5585               ENDIF
1113  5585
1114  5585               IF (SOUND_CMDS == 1)
1115  5585 3A F7 4C     	LD A, (SOUND_ENABLED)
1116  5588 B7           	OR A
1117  5589 28 2A        	JR Z, .EXIT
1118  558B
1119  558B              	; enable page 2
1120  558B 3E 02            LD A, 2
1121  558D CD 44 52         CALL GET_PAGE_INFO
1122  5590 C5               PUSH BC
1123  5591 D5               PUSH DE
1124  5592 3A 43 F3         LD A, (RAMAD2)
1125  5595 26 80            LD H, 080H
1126  5597 CD 8B 52         CALL LOCAL_ENASLT
1127  559A              	; enable page 0
1128  559A AF               XOR A
1129  559B CD 44 52         CALL GET_PAGE_INFO
1130  559E C5               PUSH BC
1131  559F D5               PUSH DE
1132  55A0 3A 41 F3         LD A, (RAMAD0)
1133  55A3 26 00            LD H, 0
1134  55A5 CD 8B 52         CALL LOCAL_ENASLT
1135  55A8
1136  55A8 CD 33 42     	CALL PLY_AKG_PLAY
1137  55AB
1138  55AB              	; restore page 0
1139  55AB D1               POP DE
1140  55AC C1               POP BC
1141  55AD CD 7B 52         CALL RESTORE_PAGE_INFO
1142  55B0              	; restore page 2
1143  55B0 D1               POP DE
1144  55B1 C1               POP BC
1145  55B2 CD 7B 52         CALL RESTORE_PAGE_INFO
1146  55B5               ENDIF
1147  55B5
1148  55B5              .EXIT:
1149  55B5 F1           	POP AF
1150  55B6 C3 F0 4C     	JP ORIG.HTIMI
1151  55B9              ; *******************************************************************************************************
1152  55B9
1153  55B9              ; *******************************************************************************************************
1154  55B9              ; interrupt handler when page 0 enabled
1155  55B9              VBLANK:
1156  55B9              	EXPORT VBLANK
1157  55B9
1158  55B9 F5               PUSH AF
1159  55BA              	; is VDP originator ?
1160  55BA DB 99        	IN	A, (099H)
1161  55BC A7           	AND	A
1162  55BD F2 E3 55     	JP P, .EXIT
1163  55C0
1164  55C0               IF (SOUND_CMDS == 1)
1165  55C0 3A F7 4C     	LD A, (SOUND_ENABLED)
1166  55C3 B7           	OR A
1167  55C4 28 1D        	JR Z, .EXIT
1168  55C6
1169  55C6 C5               PUSH BC
1170  55C7 D5               PUSH DE
1171  55C8 E5               PUSH HL
1172  55C9 08               EX AF, AF'
1173  55CA D9               EXX
1174  55CB F5               PUSH AF
1175  55CC C5               PUSH BC
1176  55CD D5               PUSH DE
1177  55CE E5               PUSH HL
1178  55CF DD E5            PUSH IX
1179  55D1 FD E5            PUSH IY
1180  55D3
1181  55D3 CD 33 42     	CALL PLY_AKG_PLAY
1182  55D6
1183  55D6 FD E1            POP IY
1184  55D8 DD E1            POP IX
1185  55DA E1               POP HL
1186  55DB D1               POP DE
1187  55DC C1               POP BC
1188  55DD F1               POP AF
1189  55DE 08               EX AF, AF'
1190  55DF D9               EXX
1191  55E0 E1               POP HL
1192  55E1 D1               POP DE
1193  55E2 C1               POP BC
1194  55E3               ENDIF
1195  55E3
1196  55E3              .EXIT:
1197  55E3 F1           	POP AF
1198  55E4 FB           	EI
1199  55E5 ED 4D        	RETI
1200  55E7              ; *******************************************************************************************************
1201  55E7
1202  55E7               IF (SOUND_CMDS == 1)
1203  55E7              ; *******************************************************************************************************
1204  55E7              ; function to handle CALL SNDPLYINIT basic extension
1205  55E7              ; initializes sound player
1206  55E7              ; _SNDPLYINIT ( INT music_offset,
1207  55E7              ;				INT sfx_offset, can be -1 if no SFX
1208  55E7              ; will put ram in page 0 also, page 1 is already there
1209  55E7              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1210  55E7              SNDPLYINIT:
1211  55E7              	; opening (
1212  55E7 CD 51 53     	CALL CHKCHAR
1213  55EA 28           	DB '('
1214  55EB              	; get music address
1215  55EB DD 21 2F 54  	LD IX, FRMQNT
1216  55EF CD 59 01     	CALL CALBAS
1217  55F2 D5           	PUSH DE
1218  55F3              	; comma
1219  55F3 CD 51 53     	CALL CHKCHAR
1220  55F6 2C           	DB ','
1221  55F7              	; get sfx address
1222  55F7 DD 21 2F 54  	LD IX, FRMQNT
1223  55FB CD 59 01     	CALL CALBAS
1224  55FE D5           	PUSH DE
1225  55FF              	; ending )
1226  55FF CD 51 53     	CALL CHKCHAR
1227  5602 29           	DB ')'
1228  5603
1229  5603                  ; save position in BASIC text
1230  5603 44           	LD B, H
1231  5604 4D           	LD C, L
1232  5605
1233  5605              	; pop LDIR parameters and store away for later
1234  5605 D1           	POP DE ; sfx address
1235  5606 E1           	POP HL ; music address
1236  5607 C5           	PUSH BC ; basic text location
1237  5608 D9           	EXX
1238  5609 FD 21 10 56  	LD IY, .RET
1239  560D C3 04 53     	JP ENABLE_PAGE0
1240  5610              .RET:
1241  5610 D9           	EXX
1242  5611
1243  5611 D5           	PUSH DE
1244  5612 AF           	XOR A
1245  5613              	; HL = music location
1246  5613 CD 62 41     	CALL PLY_AKG_INIT
1247  5616 3E 01        	LD A, 1
1248  5618 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1249  561B
1250  561B E1           	POP HL ; SFX
1251  561C              	; check if SFX address -1
1252  561C 23           	INC HL
1253  561D 7D           	LD A, L
1254  561E B4           	OR H
1255  561F 28 09        	JR Z,.L1
1256  5621 2B           	DEC HL
1257  5622 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1258  5625 3E 01        	LD A, 1
1259  5627 32 F6 4C     	LD (SFX_INIT_STATUS), A
1260  562A              .L1:
1261  562A D1               POP DE
1262  562B C1               POP BC
1263  562C CD 7B 52         CALL RESTORE_PAGE_INFO
1264  562F
1265  562F E1           	POP HL
1266  5630 C9           	RET
1267  5631              ; *******************************************************************************************************
1268  5631
1269  5631              ; *******************************************************************************************************
1270  5631              ; function to handle CALL SNDPLYON basic extension
1271  5631              ; enables sound player
1272  5631              ; _SNDPLYON
1273  5631              ; sets SOUND_ENABLED variable to 1 if init call was done
1274  5631              ; if not throws out of data error
1275  5631              SNDPLYON:
1276  5631 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1277  5634 B7           	OR A
1278  5635 20 05        	JR NZ, .L1
1279  5637              	; player not initialized, throw error
1280  5637 1E 04        	LD E, 04 ; Out of DATA
1281  5639 C3 69 53     	JP THROW_ERROR
1282  563C              .L1:
1283  563C 32 F7 4C     	LD (SOUND_ENABLED), A
1284  563F              	; disable key click
1285  563F AF           	XOR A
1286  5640 32 DB F3     	LD (CLIKSW), A
1287  5643 C9           	RET
1288  5644              ; *******************************************************************************************************
1289  5644
1290  5644              ; *******************************************************************************************************
1291  5644              ; function to handle CALL SNDPLYOFF basic extension
1292  5644              ; disables sound player
1293  5644              ; _SNDPLYOFF
1294  5644              ; sets SOUND_ENABLED variable to 0
1295  5644              ; calls AKG to stop music and SFX on all channels if initialized
1296  5644              SNDPLYOFF:
1297  5644 3A F7 4C     	LD A, (SOUND_ENABLED)
1298  5647 B7           	OR A
1299  5648 C8           	RET Z ; already stopped
1300  5649 AF           	XOR A
1301  564A 32 F7 4C     	LD (SOUND_ENABLED), A
1302  564D E5           	PUSH HL
1303  564E CD 21 42     	CALL PLY_AKG_STOP
1304  5651 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1305  5654 B7           	OR A
1306  5655 28 0E        	JR Z, .EXIT ; SFX not in use
1307  5657 AF           	XOR A
1308  5658 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1309  565B 3E 01        	LD A, 1
1310  565D CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1311  5660 3E 02        	LD A, 2
1312  5662 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1313  5665              .EXIT:
1314  5665 E1           	POP HL
1315  5666 C9           	RET
1316  5667              ; *******************************************************************************************************
1317  5667
1318  5667              ; *******************************************************************************************************
1319  5667              ; function to handle CALL SNDSFX basic extension
1320  5667              ; plays a sound effect
1321  5667              ; _SNDSFX ( BYTE sfx_number, >0
1322  5667              ;			BYTE channel, = 0,1 or 2
1323  5667              ;			BYTE inverted_volume = 0-16, 0 being full volume
1324  5667              ; will put ram in page 0 also, page 1 is already there
1325  5667              ; if sound off throws illegal function call
1326  5667              ; if sfx not initialized, throws out of data
1327  5667              SNDSFX:
1328  5667              	; opening (
1329  5667 CD 51 53     	CALL CHKCHAR
1330  566A 28           	DB '('
1331  566B              	; get sfx_number
1332  566B DD 21 1C 52  	LD IX, GETBYT
1333  566F CD 59 01     	CALL CALBAS
1334  5672 D5           	PUSH DE
1335  5673              	; comma
1336  5673 CD 51 53     	CALL CHKCHAR
1337  5676 2C           	DB ','
1338  5677              	; get sfx address
1339  5677 DD 21 1C 52  	LD IX, GETBYT
1340  567B CD 59 01     	CALL CALBAS
1341  567E D5           	PUSH DE
1342  567F              	; comma
1343  567F CD 51 53     	CALL CHKCHAR
1344  5682 2C           	DB ','
1345  5683              	; get inverted volume
1346  5683 DD 21 1C 52  	LD IX, GETBYT
1347  5687 CD 59 01     	CALL CALBAS
1348  568A D5           	PUSH DE
1349  568B              	; ending )
1350  568B CD 51 53     	CALL CHKCHAR
1351  568E 29           	DB ')'
1352  568F
1353  568F 3A F7 4C     	LD A, (SOUND_ENABLED)
1354  5692 B7           	OR A
1355  5693 20 05        	JR NZ, .L1
1356  5695              	; sound disabled, throw illegal function call
1357  5695 1E 05        	LD E, 5
1358  5697 C3 69 53     	JP THROW_ERROR
1359  569A              .L1:
1360  569A 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1361  569D B7           	OR A
1362  569E 20 05        	JR NZ, .L2
1363  56A0              	; sfx data not initialized, throw out of data
1364  56A0 1E 04        	LD E, 4
1365  56A2 C3 69 53     	JP THROW_ERROR
1366  56A5              .L2:
1367  56A5              	; pop  parameters and store away for later
1368  56A5 D1           	POP DE ; inverted volume
1369  56A6 43           	LD B, E
1370  56A7 D1           	POP DE ; channel
1371  56A8 4B           	LD C, E
1372  56A9 D1           	POP DE
1373  56AA 7B           	LD A, E
1374  56AB 08           	EX AF, AF'
1375  56AC E5           	PUSH HL ; basic text location
1376  56AD D9           	EXX
1377  56AE FD 21 B5 56  	LD IY, .RET
1378  56B2 C3 04 53     	JP ENABLE_PAGE0
1379  56B5              .RET:
1380  56B5 D9           	EXX
1381  56B6 08           	EX AF, AF'
1382  56B7 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1383  56BA
1384  56BA D1               POP DE
1385  56BB C1               POP BC
1386  56BC CD 7B 52         CALL RESTORE_PAGE_INFO
1387  56BF
1388  56BF E1           	POP HL
1389  56C0 C9           	RET
1390  56C1              ; *******************************************************************************************************
1391  56C1               ENDIF
1392  56C1
1393  56C1               IF (BLIT_CMDS == 1)
1394  56C1              ; *******************************************************************************************************
1395  56C1              ; function rotates mask and data of several characters and applies to background data
1396  56C1              ; this handles x-shift from 0 to 4
1397  56C1              ; contains self-modifying code that is set-up from external function
1398  56C1              ; input HL=pointer to mask data
1399  56C1              ; input HL'=pointer to character data
1400  56C1              ; input DE=output buffer containing background data
1401  56C1              ; input BC=DE+8
1402  56C1              ; input A=number of characters to process
1403  56C1              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1404  56C1              SHIFT04:
1405  56C1 08           	EX AF, AF'
1406  56C2 7E           	LD A, (HL) ; get mask
1407  56C3 D9           	EXX
1408  56C4 57           	LD D, A
1409  56C5 1E FF        	LD E, #FF
1410  56C7 37           	SCF
1411  56C8              .M1:
1412  56C8 18 FE        	JR .M1 ; this is self-modifying part
1413  56CA CB 1A        	RR D
1414  56CC CB 1B        	RR E
1415  56CE CB 1A        	RR D
1416  56D0 CB 1B        	RR E
1417  56D2 CB 1A        	RR D
1418  56D4 CB 1B        	RR E
1419  56D6 CB 1A        	RR D
1420  56D8 CB 1B        	RR E
1421  56DA
1422  56DA 46           	LD B, (HL) ; get data
1423  56DB 0E 00        	LD C, 0
1424  56DD              .M2:
1425  56DD 18 FE        	JR .M2 ; also self-modifying part
1426  56DF CB 38        	SRL B
1427  56E1 CB 19        	RR C
1428  56E3 CB 38        	SRL B
1429  56E5 CB 19        	RR C
1430  56E7 CB 38        	SRL B
1431  56E9 CB 19        	RR C
1432  56EB CB 38        	SRL B
1433  56ED CB 19        	RR C
1434  56EF
1435  56EF D9           	EXX
1436  56F0 1A           	LD A, (DE) ; background
1437  56F1 D9           	EXX
1438  56F2 A2           	AND D
1439  56F3 B0           	OR B
1440  56F4 D9           	EXX
1441  56F5 12           	LD (DE), A
1442  56F6
1443  56F6 0A           	LD A, (BC)
1444  56F7 D9           	EXX
1445  56F8 A3           	AND E
1446  56F9 B1           	OR C
1447  56FA 23           	INC HL
1448  56FB D9           	EXX
1449  56FC 02           	LD (BC), A
1450  56FD
1451  56FD 23           	INC HL
1452  56FE 13           	INC DE
1453  56FF 03           	INC BC
1454  5700
1455  5700 08           	EX AF, AF'
1456  5701 3D           	DEC A
1457  5702 C2 C1 56     	JP NZ, SHIFT04
1458  5705 C9           	RET
1459  5706              ; *******************************************************************************************************
1460  5706
1461  5706              ; *******************************************************************************************************
1462  5706              ; function rotates mask and data of several characters and applies to background data
1463  5706              ; this handles x-shift from 5 to 8
1464  5706              ; contains self-modifying code that is set-up from external function
1465  5706              ; input HL=pointer to mask data
1466  5706              ; input HL'=pointer to character data
1467  5706              ; input DE=output buffer containing background data
1468  5706              ; input BC=DE+8
1469  5706              ; input A=number of characters to process
1470  5706              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1471  5706              SHIFT58:
1472  5706 08           	EX AF, AF'
1473  5707 7E           	LD A, (HL) ; get mask
1474  5708 D9           	EXX
1475  5709 57           	LD D, A
1476  570A 1E FF        	LD E, #FF
1477  570C 37           	SCF
1478  570D              .M1:
1479  570D 18 FE        	JR .M1 ; this is self-modifying part
1480  570F CB 12        	RL D
1481  5711 CB 13        	RL E
1482  5713 CB 12        	RL D
1483  5715 CB 13        	RL E
1484  5717 CB 12        	RL D
1485  5719 CB 13        	RL E
1486  571B
1487  571B 46           	LD B, (HL)
1488  571C 0E 00        	LD C, 0
1489  571E              .M2:
1490  571E 18 FE        	JR .M2 ; also self-modifying part
1491  5720 CB 20        	SLA B
1492  5722 CB 11        	RL C
1493  5724 CB 20        	SLA B
1494  5726 CB 11        	RL C
1495  5728 CB 20        	SLA B
1496  572A CB 11        	RL C
1497  572C
1498  572C D9           	EXX
1499  572D 1A           	LD A, (DE) ; background
1500  572E D9           	EXX
1501  572F A3           	AND E
1502  5730 B1           	OR C
1503  5731 D9           	EXX
1504  5732 12           	LD (DE), A
1505  5733
1506  5733 0A           	LD A, (BC)
1507  5734 D9           	EXX
1508  5735 A2           	AND D
1509  5736 B0           	OR B
1510  5737 23           	INC HL
1511  5738 D9           	EXX
1512  5739 02           	LD (BC), A
1513  573A
1514  573A 23           	INC HL
1515  573B 13           	INC DE
1516  573C 03           	INC BC
1517  573D
1518  573D 08           	EX AF, AF'
1519  573E 3D           	DEC A
1520  573F C2 06 57     	JP NZ, SHIFT58
1521  5742 C9           	RET
1522  5743              ; *******************************************************************************************************
1523  5743
1524  5743              ; *******************************************************************************************************
1525  5743              ; routine that shifts one row of characters
1526  5743              ; contains self-modifying code that is set-up from external function
1527  5743              ; input HL=pointer to mask data
1528  5743              ; input HL'=pointer to character data
1529  5743              ; input DE=output buffer containing background data
1530  5743              ; input A=number of characters to process
1531  5743              ; input IX=pointer to structure describing input data
1532  5743              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1533  5743              SHIFT_ROW:
1534  5743 F5           	PUSH AF
1535  5744 ED 53 F0 50  		LD (BLIT_TMP1), DE
1536  5748 E5           		PUSH HL
1537  5749 CD 8C 57     			CALL .ADDYSHIFT
1538  574C E1           		POP HL
1539  574D ED 53 F2 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1540  5751              .L1:
1541  5751 3E 08        		LD A, 8
1542  5753 DD 96 02     		SUB (IX+2) ; y shift
1543  5756              .CALL1:
1544  5756 CD 00 00     		CALL 0
1545  5759 DD 7E 02     		LD A, (IX+2); y shift
1546  575C B7           		OR A
1547  575D 28 26        		JR Z, .DONE
1548  575F ED 5B F0 50  		LD DE, (BLIT_TMP1)
1549  5763 E5           		PUSH HL
1550  5764 CD 9A 57     			CALL .DETONEXTROW
1551  5767 E1           		POP HL
1552  5768              .CALL2:
1553  5768 CD 00 00     		CALL 0
1554  576B ED 5B F0 50  		LD DE, (BLIT_TMP1)
1555  576F E5           		PUSH HL
1556  5770 CD 94 57     			CALL .ADD8
1557  5773 E1           		POP HL
1558  5774 ED 53 F0 50  		LD (BLIT_TMP1), DE
1559  5778 ED 5B F2 50  		LD DE, (BLIT_TMP2)
1560  577C E5           		PUSH HL
1561  577D CD 94 57     			CALL .ADD8
1562  5780 E1           		POP HL
1563  5781 ED 53 F2 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1564  5785              .DONE:
1565  5785 F1           	POP AF
1566  5786 3D           	DEC A
1567  5787 C8           	RET Z
1568  5788 F5           	PUSH AF
1569  5789 C3 51 57     	JP .L1
1570  578C              .ADDYSHIFT:
1571  578C EB           	EX DE, HL
1572  578D 16 00        	LD D, 0
1573  578F DD 5E 02     	LD E, (IX+2); y shift
1574  5792 18 0C        	JR .MOVDEBC
1575  5794              .ADD8:
1576  5794 21 08 00     	LD HL, 8
1577  5797 C3 A0 57     	JP .MOVDEBC
1578  579A              .DETONEXTROW:
1579  579A DD 6E 06     	LD L, (IX+6)
1580  579D DD 66 07     	LD H, (IX+7) ; bkg add to value
1581  57A0              .MOVDEBC:
1582  57A0 19           	ADD HL, DE
1583  57A1 54           	LD D, H
1584  57A2 5D           	LD E, L
1585  57A3 01 08 00     	LD BC, 8
1586  57A6 09           	ADD HL, BC
1587  57A7 44           	LD B, H
1588  57A8 4D           	LD C, L
1589  57A9 C9           	RET
1590  57AA              ; *******************************************************************************************************
1591  57AA
1592  57AA              ; *******************************************************************************************************
1593  57AA              ; function rotates mask and character data and applies it to background
1594  57AA              ; input IX=pointer to structure describing input data
1595  57AA              ; +0  DW horizontal shift count 0-7 (low byte used)
1596  57AA              ; +2  DW vertical shift count 0-7 (low byte used)
1597  57AA              ; +4  DW background data start;
1598  57AA              ; +6  DW background add to value to next row of background data
1599  57AA              ; +8  DW mask data start;
1600  57AA              ; +10  DW character data start;
1601  57AA              ; +12 DW character&mask add to value to next row of data
1602  57AA              ; +14 DW columns (low byte used)
1603  57AA              ; +16 DW rows (low byte used)
1604  57AA              SHIFT_MERGE_CHARACTER:
1605  57AA DD 7E 00     	LD A, (IX) ; shift
1606  57AD FE 05        	CP 5
1607  57AF 38 25        	JR C, .RIGHT
1608  57B1              	; shifts 5-7, use rotate towards left 1-3
1609  57B1 21 06 57     	LD HL, SHIFT58
1610  57B4 22 57 57     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1611  57B7 22 69 57     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1612  57BA D6 05        	SUB 5
1613  57BC 28 0D        	JR Z, .L1
1614  57BE 87           	ADD A, A
1615  57BF 87           	ADD A, A
1616  57C0 67           	LD H, A
1617  57C1 2E 18        	LD L, #18 ; JR opcode
1618  57C3 22 0D 57     	LD (SHIFT58.M1), HL
1619  57C6 22 1E 57     	LD (SHIFT58.M2), HL
1620  57C9 18 32        	JR .DO
1621  57CB              .L1:
1622  57CB 21 00 00     	LD HL, 0 ; 2xNOP opcode
1623  57CE 22 0D 57     	LD (SHIFT58.M1), HL
1624  57D1 22 1E 57     	LD (SHIFT58.M2), HL
1625  57D4 18 27        	JR .DO
1626  57D6              .RIGHT:
1627  57D6              	; shifts 0-4, rotate towards right
1628  57D6 21 C1 56     	LD HL, SHIFT04
1629  57D9 22 57 57     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1630  57DC 22 69 57     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1631  57DF FE 04        	CP 4
1632  57E1 28 11        	JR Z, .R1
1633  57E3 D6 04        	SUB 4
1634  57E5 ED 44        	NEG
1635  57E7 87           	ADD A, A
1636  57E8 87           	ADD A, A
1637  57E9 67           	LD H, A
1638  57EA 2E 18        	LD L, #18 ; JR opcode
1639  57EC 22 C8 56     	LD (SHIFT04.M1), HL
1640  57EF 22 DD 56     	LD (SHIFT04.M2), HL
1641  57F2 18 09        	JR .DO
1642  57F4              .R1:
1643  57F4 21 00 00     	LD HL, 0 ; 2xNOP opcode
1644  57F7 22 C8 56     	LD (SHIFT04.M1), HL
1645  57FA 22 DD 56     	LD (SHIFT04.M2), HL
1646  57FD              .DO:
1647  57FD DD 46 10     	LD B, (IX+16) ; rows
1648  5800 DD 6E 08     	LD L, (IX+8)
1649  5803 DD 66 09     	LD H, (IX+9) ; mask data
1650  5806 DD 5E 04     	LD E, (IX+4)
1651  5809 DD 56 05     	LD D, (IX+5) ; background data
1652  580C D9           	EXX
1653  580D DD 6E 0A     	LD L, (IX+10)
1654  5810 DD 66 0B     	LD H, (IX+11) ; character data
1655  5813 D9           	EXX
1656  5814              .LOOP:
1657  5814 C5           	PUSH BC
1658  5815 E5           		PUSH HL
1659  5816 D5           			PUSH DE
1660  5817 D9           				EXX
1661  5818 E5           				PUSH HL
1662  5819 D9           					EXX
1663  581A DD 7E 0E     					LD A, (IX+14) ; columns
1664  581D              .CALL:
1665  581D CD 43 57     					CALL SHIFT_ROW
1666  5820 E1           				POP HL
1667  5821 DD 5E 0C     				LD E, (IX+12)
1668  5824 DD 56 0D     				LD D, (IX+13) ; char data to next row
1669  5827 19           				ADD HL, DE
1670  5828 D9           				EXX
1671  5829 E1           			POP HL
1672  582A DD 5E 06     			LD E, (IX+6)
1673  582D DD 56 07     			LD D, (IX+7) ; background to next row
1674  5830 19           			ADD HL, DE
1675  5831 EB           			EX DE, HL
1676  5832 E1           		POP HL
1677  5833 DD 4E 0C     		LD C, (IX+12)
1678  5836 DD 46 0D     		LD B, (IX+13) ; char data to next row
1679  5839 09           		ADD HL, BC
1680  583A C1           	POP BC
1681  583B 10 D7        	DJNZ .LOOP
1682  583D C9           	RET
1683  583E              ; *******************************************************************************************************
1684  583E
1685  583E               IFNDEF CMDS_WITH_PARAMETERS
1686  583E ~            ; *******************************************************************************************************
1687  583E ~            ; function to handle CALL BLIT basic extension
1688  583E ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1689  583E ~            ; fuses with background data and applies vertical shift too
1690  583E ~            ; BLIT ( INT request_data_ptr )
1691  583E ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1692  583E ~            ; will put ram in page 0 also, page 1 is already there
1693  583E ~            BLIT:
1694  583E ~            	; opening (
1695  583E ~            	CALL CHKCHAR
1696  583E ~            	DB '('
1697  583E ~            	; get pointer to request struct
1698  583E ~            	LD IX, FRMQNT
1699  583E ~            	CALL CALBAS
1700  583E ~            	PUSH DE
1701  583E ~            	; ending )
1702  583E ~            	CALL CHKCHAR
1703  583E ~            	DB ')'
1704  583E ~
1705  583E ~            	POP IX ; pointer to request struct
1706  583E ~
1707  583E ~            	PUSH HL ; save position in BASIC buffer
1708  583E ~
1709  583E ~            	LD IY, .RET
1710  583E ~            	JP ENABLE_PAGE0
1711  583E ~            .RET:
1712  583E ~            	EI
1713  583E ~            	CALL SHIFT_MERGE_CHARACTER
1714  583E ~
1715  583E ~                POP DE
1716  583E ~                POP BC
1717  583E ~                CALL RESTORE_PAGE_INFO
1718  583E ~
1719  583E ~            	POP HL
1720  583E ~            	RET
1721  583E ~            ; *******************************************************************************************************
1722  583E               ENDIF
1723  583E
1724  583E               IFDEF CMDS_WITH_PARAMETERS
1725  583E              ; *******************************************************************************************************
1726  583E              ; function to handle CALL BLIT basic extension
1727  583E              ; rotates 1-bit character drawing horizontally with mask and character data and
1728  583E              ; fuses with background data and applies vertical shift too
1729  583E              ; in form without pointers
1730  583E              ; BLIT ( INT x,
1731  583E              ;		 INT y,
1732  583E              ;		 INT char_data_pointer,
1733  583E              ;		 INT mask_data_pointer,
1734  583E              ;		 INT width (in characters),
1735  583E              ;		 INT height (in characters),
1736  583E              ;		 INT background_pointer (top left),
1737  583E              ;		 INT background_width (in characters),
1738  583E              ;		 INT background_height (in characters))
1739  583E              ; will put ram in page 0 also, page 1 is already there
1740  583E              BLIT:
1741  583E              	; opening (
1742  583E CD 51 53     	CALL CHKCHAR
1743  5841 28           	DB '('
1744  5842              	; get x coordinate
1745  5842 DD 21 2F 54  	LD IX, FRMQNT
1746  5846 CD 59 01     	CALL CALBAS
1747  5849 7B           	LD A, E
1748  584A E6 07        	AND 7
1749  584C 32 F4 50     	LD (BLIT_STRUCT+0), A
1750  584F CD 2C 59     	CALL .DAdiv8
1751  5852 32 F0 50     	LD (BLIT_TMP+0),A
1752  5855              	; comma
1753  5855 CD 51 53     	CALL CHKCHAR
1754  5858 2C           	DB ','
1755  5859              	; get y coordinate
1756  5859 DD 21 2F 54  	LD IX, FRMQNT
1757  585D CD 59 01     	CALL CALBAS
1758  5860 7B           	LD A, E
1759  5861 E6 07        	AND 7
1760  5863 32 F6 50     	LD (BLIT_STRUCT+2), A
1761  5866 CD 2C 59     	CALL .DAdiv8
1762  5869 32 F1 50     	LD (BLIT_TMP+1),A
1763  586C              	; comma
1764  586C CD 51 53     	CALL CHKCHAR
1765  586F 2C           	DB ','
1766  5870              	; get char data pointer
1767  5870 DD 21 2F 54  	LD IX, FRMQNT
1768  5874 CD 59 01     	CALL CALBAS
1769  5877 ED 53 FE 50  	LD (BLIT_STRUCT+10), DE
1770  587B              	; comma
1771  587B CD 51 53     	CALL CHKCHAR
1772  587E 2C           	DB ','
1773  587F              	; get mask data pointer
1774  587F DD 21 2F 54  	LD IX, FRMQNT
1775  5883 CD 59 01     	CALL CALBAS
1776  5886 ED 53 FC 50  	LD (BLIT_STRUCT+8), DE
1777  588A              	; comma
1778  588A CD 51 53     	CALL CHKCHAR
1779  588D 2C           	DB ','
1780  588E              	; get width
1781  588E DD 21 2F 54  	LD IX, FRMQNT
1782  5892 CD 59 01     	CALL CALBAS
1783  5895 7B           	LD A, E
1784  5896 32 02 51     	LD (BLIT_STRUCT+14), A
1785  5899              	; comma
1786  5899 CD 51 53     	CALL CHKCHAR
1787  589C 2C           	DB ','
1788  589D              	; get height
1789  589D DD 21 2F 54  	LD IX, FRMQNT
1790  58A1 CD 59 01     	CALL CALBAS
1791  58A4 7B           	LD A, E
1792  58A5 32 04 51     	LD (BLIT_STRUCT+16), A
1793  58A8              	; comma
1794  58A8 CD 51 53     	CALL CHKCHAR
1795  58AB 2C           	DB ','
1796  58AC              	; get background pointer
1797  58AC DD 21 2F 54  	LD IX, FRMQNT
1798  58B0 CD 59 01     	CALL CALBAS
1799  58B3 ED 53 F8 50  	LD (BLIT_STRUCT+4), DE
1800  58B7              	; comma
1801  58B7 CD 51 53     	CALL CHKCHAR
1802  58BA 2C           	DB ','
1803  58BB              	; get background width
1804  58BB DD 21 2F 54  	LD IX, FRMQNT
1805  58BF CD 59 01     	CALL CALBAS
1806  58C2 7B           	LD A, E
1807  58C3 32 F2 50     	LD (BLIT_TMP+2), A
1808  58C6              	; comma
1809  58C6 CD 51 53     	CALL CHKCHAR
1810  58C9 2C           	DB ','
1811  58CA              	; get background height
1812  58CA DD 21 2F 54  	LD IX, FRMQNT
1813  58CE CD 59 01     	CALL CALBAS
1814  58D1 7B           	LD A, E
1815  58D2 32 F3 50     	LD (BLIT_TMP+3), A
1816  58D5              	; ending )
1817  58D5 CD 51 53     	CALL CHKCHAR
1818  58D8 29           	DB ')'
1819  58D9
1820  58D9 E5           	PUSH HL ; save position in BASIC buffer
1821  58DA
1822  58DA              	; calculate char&mask add to value
1823  58DA 26 00        	LD H, 0
1824  58DC 3A 02 51     	LD A, (BLIT_STRUCT+14)
1825  58DF 6F           	LD L, A
1826  58E0 CD 40 52     	CALL HLx8
1827  58E3 22 00 51     	LD (BLIT_STRUCT+12), HL
1828  58E6              	; calculate background add to value
1829  58E6 26 00        	LD H, 0
1830  58E8 3A F2 50     	LD A, (BLIT_TMP+2)
1831  58EB 6F           	LD L, A
1832  58EC CD 40 52     	CALL HLx8
1833  58EF 22 FA 50     	LD (BLIT_STRUCT+6), HL
1834  58F2              	; calculate pointer to background location
1835  58F2 21 00 00     	LD HL, 0
1836  58F5 3A F1 50     	LD A,(BLIT_TMP+1)
1837  58F8 B7           	OR A
1838  58F9 28 08        	JR Z, .L1
1839  58FB 47           	LD B,A
1840  58FC ED 5B FA 50  	LD DE,(BLIT_STRUCT+6)
1841  5900              .L0:
1842  5900 19           	ADD HL, DE
1843  5901 10 FD        	DJNZ .L0
1844  5903              .L1:
1845  5903 EB           	EX DE,HL
1846  5904 26 00        	LD H,0
1847  5906 3A F0 50     	LD A,(BLIT_TMP+0)
1848  5909 6F           	LD L,A
1849  590A CD 40 52     	CALL HLx8
1850  590D 19           	ADD HL,DE
1851  590E ED 5B F8 50  	LD DE,(BLIT_STRUCT+4)
1852  5912 19           	ADD HL,DE
1853  5913 22 F8 50     	LD (BLIT_STRUCT+4),HL
1854  5916
1855  5916 FD 21 1D 59  	LD IY, .RET
1856  591A C3 04 53     	JP ENABLE_PAGE0
1857  591D              .RET:
1858  591D FB           	EI
1859  591E DD 21 F4 50  	LD IX, BLIT_STRUCT
1860  5922 CD AA 57     	CALL SHIFT_MERGE_CHARACTER
1861  5925
1862  5925 D1               POP DE
1863  5926 C1               POP BC
1864  5927 CD 7B 52         CALL RESTORE_PAGE_INFO
1865  592A
1866  592A E1           	POP HL
1867  592B C9           	RET
1868  592C              .DAdiv8:
1869  592C 7B           	LD A,E
1870  592D CB 2A        	SRA D
1871  592F CB 1F            RR  A
1872  5931 CB 2A            SRA D
1873  5933 CB 1F            RR  A
1874  5935 CB 2A            SRA D
1875  5937 CB 1F            RR  A
1876  5939 C9           	RET
1877  593A              ; *******************************************************************************************************
1878  593A               ENDIF
1879  593A               ENDIF
1880  593A
1881  593A               IF (TILE_CMDS == 1)
1882  593A              ; *******************************************************************************************************
1883  593A              ; generic function to implement tiling
1884  593A              ; should be modified to call appropriate function for memory or vram
1885  593A              ; input IX=pointer to following structure
1886  593A              ; +00 tile_data_ptr
1887  593A              ; +02 tile_rows
1888  593A              ; +04 tile_columns
1889  593A              ; +06 destination_address
1890  593A              ; +08 dest_to_next_row_add_to_value
1891  593A              ; +10 num_horizontal_tiles
1892  593A              ; +12 num_vertical_tiles
1893  593A              ; modifies AF, BC, DE, HL
1894  593A              TILE:
1895  593A DD 6E 06     	LD L, (IX+6)
1896  593D DD 66 07     	LD H, (IX+7) ; destination address
1897  5940 22 F0 50     	LD (TILETMP1), HL
1898  5943 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1899  5946              .L1:
1900  5946 C5           	PUSH BC
1901  5947 DD 6E 00     		LD L, (IX+0)
1902  594A DD 66 01     		LD H, (IX+1) ; tile address
1903  594D 22 F2 50     		LD (TILETMP2), HL
1904  5950 DD 46 02     		LD B, (IX+2) ; tile rows
1905  5953              .L2:
1906  5953 C5           		PUSH BC
1907  5954              .CALL1:
1908  5954 CD 00 00     			CALL 0
1909  5957 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1910  595A              .L3:
1911  595A C5           			PUSH BC
1912  595B 2A F2 50     				LD HL, (TILETMP2)
1913  595E DD 46 04     				LD B, (IX+4) ; tile columns
1914  5961              .L4:
1915  5961 C5           				PUSH BC
1916  5962              .CALL2:
1917  5962 CD 00 00     					CALL 0
1918  5965 C1           				POP BC
1919  5966 10 F9        				DJNZ .L4
1920  5968 C1           			POP BC
1921  5969 10 EF        			DJNZ .L3
1922  596B 22 F2 50     			LD (TILETMP2), HL
1923  596E 2A F0 50     			LD HL, (TILETMP1)
1924  5971 DD 5E 08     			LD E, (IX+8)
1925  5974 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1926  5977 19           			ADD HL, DE
1927  5978 22 F0 50     			LD (TILETMP1), HL
1928  597B C1           		POP BC
1929  597C 10 D5        		DJNZ .L2
1930  597E C1           	POP BC
1931  597F 10 C5        	DJNZ .L1
1932  5981 C9           	RET
1933  5982              ; *******************************************************************************************************
1934  5982
1935  5982               IFNDEF CMDS_WITH_PARAMETERS
1936  5982 ~            ; *******************************************************************************************************
1937  5982 ~            ; function to handle CALL TILERAM basic extension
1938  5982 ~            ; fills memory with tiles
1939  5982 ~            ; TILERAM ( INT request_data_ptr )
1940  5982 ~            ; request_data_ptr described in TILE
1941  5982 ~            ; will put ram in page 0 also, page 1 is already there
1942  5982 ~            TILERAM:
1943  5982 ~            	; opening (
1944  5982 ~            	CALL CHKCHAR
1945  5982 ~            	DB '('
1946  5982 ~            	; get pointer to request struct
1947  5982 ~            	LD IX, FRMQNT
1948  5982 ~            	CALL CALBAS
1949  5982 ~            	PUSH DE
1950  5982 ~            	; ending )
1951  5982 ~            	CALL CHKCHAR
1952  5982 ~            	DB ')'
1953  5982 ~
1954  5982 ~            	POP IX ; pointer to request struct
1955  5982 ~
1956  5982 ~            	PUSH HL ; save position in BASIC buffer
1957  5982 ~
1958  5982 ~            	LD IY, .RET
1959  5982 ~            	JP ENABLE_PAGE0
1960  5982 ~            .RET:
1961  5982 ~            	EI
1962  5982 ~            	; set RAM functions to call
1963  5982 ~            	LD HL, .TILECOPY
1964  5982 ~            	LD (TILE.CALL2+1), HL
1965  5982 ~            	LD HL, .SETDESTROW
1966  5982 ~            	LD (TILE.CALL1+1), HL
1967  5982 ~            	CALL TILE
1968  5982 ~
1969  5982 ~                POP DE
1970  5982 ~                POP BC
1971  5982 ~                CALL RESTORE_PAGE_INFO
1972  5982 ~
1973  5982 ~            	POP HL
1974  5982 ~            	RET
1975  5982 ~            .TILECOPY:
1976  5982 ~            	.8 LDI
1977  5982 ~            	RET
1978  5982 ~            .SETDESTROW:
1979  5982 ~            	LD DE, (TILETMP1)
1980  5982 ~            	RET
1981  5982 ~            ; *******************************************************************************************************
1982  5982               ENDIF
1983  5982
1984  5982               IFDEF CMDS_WITH_PARAMETERS
1985  5982              ; *******************************************************************************************************
1986  5982              ; function to handle CALL TILERAM basic extension
1987  5982              ; fills memory with tiles
1988  5982              ; TILERAM ( INT tile_data_pointer,
1989  5982              ;			INT tile_columns,
1990  5982              ;			INT tile_rows,
1991  5982              ;			INT destination_pointer,
1992  5982              ;			INT destination_columns,
1993  5982              ;			INT destination_rows,
1994  5982              ;			INT destination_begin_column,
1995  5982              ;			INT destination_begin_row,
1996  5982              ;			INT number_of_tiles_horizontally,
1997  5982              ;			INT	number_of_tiles_vertically )
1998  5982              ; will put ram in page 0 also, page 1 is already there
1999  5982              TILERAM:
2000  5982              	; opening (
2001  5982 CD 51 53     	CALL CHKCHAR
2002  5985 28           	DB '('
2003  5986              	; get tile data pointer coordinate
2004  5986 DD 21 2F 54  	LD IX, FRMQNT
2005  598A CD 59 01     	CALL CALBAS
2006  598D ED 53 F4 50  	LD (BLIT_STRUCT+0), DE
2007  5991              	; comma
2008  5991 CD 51 53     	CALL CHKCHAR
2009  5994 2C           	DB ','
2010  5995              	; get tile columns
2011  5995 DD 21 2F 54  	LD IX, FRMQNT
2012  5999 CD 59 01     	CALL CALBAS
2013  599C ED 53 F8 50  	LD (BLIT_STRUCT+4), DE
2014  59A0              	; comma
2015  59A0 CD 51 53     	CALL CHKCHAR
2016  59A3 2C           	DB ','
2017  59A4              	; get tile columns
2018  59A4 DD 21 2F 54  	LD IX, FRMQNT
2019  59A8 CD 59 01     	CALL CALBAS
2020  59AB ED 53 F6 50  	LD (BLIT_STRUCT+2), DE
2021  59AF              	; comma
2022  59AF CD 51 53     	CALL CHKCHAR
2023  59B2 2C           	DB ','
2024  59B3              	; get destintion pointer
2025  59B3 DD 21 2F 54  	LD IX, FRMQNT
2026  59B7 CD 59 01     	CALL CALBAS
2027  59BA ED 53 FA 50  	LD (BLIT_STRUCT+6), DE
2028  59BE              	; comma
2029  59BE CD 51 53     	CALL CHKCHAR
2030  59C1 2C           	DB ','
2031  59C2              	; get destination columns
2032  59C2 DD 21 2F 54  	LD IX, FRMQNT
2033  59C6 CD 59 01     	CALL CALBAS
2034  59C9 7B           	LD A, E
2035  59CA 32 F0 50     	LD (BLIT_TMP+0), A
2036  59CD              	; comma
2037  59CD CD 51 53     	CALL CHKCHAR
2038  59D0 2C           	DB ','
2039  59D1              	; get destination rows
2040  59D1 DD 21 2F 54  	LD IX, FRMQNT
2041  59D5 CD 59 01     	CALL CALBAS
2042  59D8 7B           	LD A, E
2043  59D9 32 F1 50     	LD (BLIT_TMP+1), A
2044  59DC              	; comma
2045  59DC CD 51 53     	CALL CHKCHAR
2046  59DF 2C           	DB ','
2047  59E0              	; get destination begin column
2048  59E0 DD 21 2F 54  	LD IX, FRMQNT
2049  59E4 CD 59 01     	CALL CALBAS
2050  59E7 7B           	LD A, E
2051  59E8 32 F2 50     	LD (BLIT_TMP+2), A
2052  59EB              	; comma
2053  59EB CD 51 53     	CALL CHKCHAR
2054  59EE 2C           	DB ','
2055  59EF              	; get destination begin row
2056  59EF DD 21 2F 54  	LD IX, FRMQNT
2057  59F3 CD 59 01     	CALL CALBAS
2058  59F6 7B           	LD A, E
2059  59F7 32 F3 50     	LD (BLIT_TMP+3), A
2060  59FA              	; comma
2061  59FA CD 51 53     	CALL CHKCHAR
2062  59FD 2C           	DB ','
2063  59FE              	; get number of tiles horizontally
2064  59FE DD 21 2F 54  	LD IX, FRMQNT
2065  5A02 CD 59 01     	CALL CALBAS
2066  5A05 ED 53 FE 50  	LD (BLIT_STRUCT+10), DE
2067  5A09              	; comma
2068  5A09 CD 51 53     	CALL CHKCHAR
2069  5A0C 2C           	DB ','
2070  5A0D              	; get number of tiles vertically
2071  5A0D DD 21 2F 54  	LD IX, FRMQNT
2072  5A11 CD 59 01     	CALL CALBAS
2073  5A14 ED 53 00 51  	LD (BLIT_STRUCT+12), DE
2074  5A18              	; ending )
2075  5A18 CD 51 53     	CALL CHKCHAR
2076  5A1B 29           	DB ')'
2077  5A1C
2078  5A1C E5           	PUSH HL ; save position in BASIC buffer
2079  5A1D
2080  5A1D              	; calculate destination add to value
2081  5A1D 26 00        	LD H, 0
2082  5A1F 3A F0 50     	LD A, (BLIT_TMP+0)
2083  5A22 6F           	LD L, A
2084  5A23 CD 40 52     	CALL HLx8
2085  5A26 22 FC 50     	LD (BLIT_STRUCT+8), HL
2086  5A29              	; calculate pointer to background location
2087  5A29 21 00 00     	LD HL, 0
2088  5A2C 3A F3 50     	LD A,(BLIT_TMP+3)
2089  5A2F B7           	OR A
2090  5A30 28 08        	JR Z, .L1
2091  5A32 47           	LD B,A
2092  5A33 ED 5B FC 50  	LD DE,(BLIT_STRUCT+8)
2093  5A37              .L0:
2094  5A37 19           	ADD HL, DE
2095  5A38 10 FD        	DJNZ .L0
2096  5A3A              .L1:
2097  5A3A EB           	EX DE,HL
2098  5A3B 26 00        	LD H,0
2099  5A3D 3A F2 50     	LD A,(BLIT_TMP+2)
2100  5A40 6F           	LD L,A
2101  5A41 CD 40 52     	CALL HLx8
2102  5A44 19           	ADD HL,DE
2103  5A45 ED 5B FA 50  	LD DE,(BLIT_STRUCT+6)
2104  5A49 19           	ADD HL,DE
2105  5A4A 22 FA 50     	LD (BLIT_STRUCT+6),HL
2106  5A4D
2107  5A4D FD 21 54 5A  	LD IY, .RET
2108  5A51 C3 04 53     	JP ENABLE_PAGE0
2109  5A54              .RET:
2110  5A54 FB           	EI
2111  5A55              	; set RAM functions to call
2112  5A55 21 6F 5A     	LD HL, .TILECOPY
2113  5A58 22 63 59     	LD (TILE.CALL2+1), HL
2114  5A5B 21 80 5A     	LD HL, .SETDESTROW
2115  5A5E 22 55 59     	LD (TILE.CALL1+1), HL
2116  5A61 DD 21 F4 50  	LD IX,BLIT_STRUCT
2117  5A65 CD 3A 59     	CALL TILE
2118  5A68
2119  5A68 D1               POP DE
2120  5A69 C1               POP BC
2121  5A6A CD 7B 52         CALL RESTORE_PAGE_INFO
2122  5A6D
2123  5A6D E1           	POP HL
2124  5A6E C9           	RET
2125  5A6F              .TILECOPY:
2126  5A6F ED A0       > LDI
2126  5A71 ED A0       > LDI
2126  5A73 ED A0       > LDI
2126  5A75 ED A0       > LDI
2126  5A77 ED A0       > LDI
2126  5A79 ED A0       > LDI
2126  5A7B ED A0       > LDI
2126  5A7D ED A0       > LDI
2127  5A7F C9           	RET
2128  5A80              .SETDESTROW:
2129  5A80 ED 5B F0 50  	LD DE, (TILETMP1)
2130  5A84 C9           	RET
2131  5A85              ; *******************************************************************************************************
2132  5A85               ENDIF
2133  5A85
2134  5A85               IFDEF CMDS_WITH_PARAMETERS
2135  5A85              ; *******************************************************************************************************
2136  5A85              ; function to handle CALL TILEVRM basic extension
2137  5A85              ; fills vram with tiles
2138  5A85              ; TILEVRM ( INT tile_data_pointer,
2139  5A85              ;			INT tile_columns,
2140  5A85              ;			INT tile_rows,
2141  5A85              ;			INT destination_begin_column,
2142  5A85              ;			INT destination_begin_row,
2143  5A85              ;			INT number_of_tiles_horizontally,
2144  5A85              ;			INT	number_of_tiles_vertically )
2145  5A85              ; will put ram in page 0 also, page 1 is already there
2146  5A85              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2147  5A85              TILEVRM:
2148  5A85              	; opening (
2149  5A85 CD 51 53     	CALL CHKCHAR
2150  5A88 28           	DB '('
2151  5A89              	; get tile data pointer coordinate
2152  5A89 DD 21 2F 54  	LD IX, FRMQNT
2153  5A8D CD 59 01     	CALL CALBAS
2154  5A90 ED 53 F4 50  	LD (BLIT_STRUCT+0), DE
2155  5A94              	; comma
2156  5A94 CD 51 53     	CALL CHKCHAR
2157  5A97 2C           	DB ','
2158  5A98              	; get tile columns
2159  5A98 DD 21 2F 54  	LD IX, FRMQNT
2160  5A9C CD 59 01     	CALL CALBAS
2161  5A9F ED 53 F8 50  	LD (BLIT_STRUCT+4), DE
2162  5AA3              	; comma
2163  5AA3 CD 51 53     	CALL CHKCHAR
2164  5AA6 2C           	DB ','
2165  5AA7              	; get tile columns
2166  5AA7 DD 21 2F 54  	LD IX, FRMQNT
2167  5AAB CD 59 01     	CALL CALBAS
2168  5AAE ED 53 F6 50  	LD (BLIT_STRUCT+2), DE
2169  5AB2              	; comma
2170  5AB2 CD 51 53     	CALL CHKCHAR
2171  5AB5 2C           	DB ','
2172  5AB6              	; get destination begin column
2173  5AB6 DD 21 2F 54  	LD IX, FRMQNT
2174  5ABA CD 59 01     	CALL CALBAS
2175  5ABD 7B           	LD A, E
2176  5ABE 32 F2 50     	LD (BLIT_TMP+2), A
2177  5AC1              	; comma
2178  5AC1 CD 51 53     	CALL CHKCHAR
2179  5AC4 2C           	DB ','
2180  5AC5              	; get destination begin row
2181  5AC5 DD 21 2F 54  	LD IX, FRMQNT
2182  5AC9 CD 59 01     	CALL CALBAS
2183  5ACC 7B           	LD A, E
2184  5ACD 32 F3 50     	LD (BLIT_TMP+3), A
2185  5AD0              	; comma
2186  5AD0 CD 51 53     	CALL CHKCHAR
2187  5AD3 2C           	DB ','
2188  5AD4              	; get number of tiles horizontally
2189  5AD4 DD 21 2F 54  	LD IX, FRMQNT
2190  5AD8 CD 59 01     	CALL CALBAS
2191  5ADB ED 53 FE 50  	LD (BLIT_STRUCT+10), DE
2192  5ADF              	; comma
2193  5ADF CD 51 53     	CALL CHKCHAR
2194  5AE2 2C           	DB ','
2195  5AE3              	; get number of tiles vertically
2196  5AE3 DD 21 2F 54  	LD IX, FRMQNT
2197  5AE7 CD 59 01     	CALL CALBAS
2198  5AEA ED 53 00 51  	LD (BLIT_STRUCT+12), DE
2199  5AEE              	; ending )
2200  5AEE CD 51 53     	CALL CHKCHAR
2201  5AF1 29           	DB ')'
2202  5AF2
2203  5AF2 E5           	PUSH HL ; save position in BASIC buffer
2204  5AF3
2205  5AF3              	; calculate destination add to value
2206  5AF3 21 00 01     	LD HL, 256
2207  5AF6 22 FC 50     	LD (BLIT_STRUCT+8), HL
2208  5AF9              	; calculate pointer to background location
2209  5AF9 3A F3 50     	LD A,(BLIT_TMP+3)
2210  5AFC 67           	LD H,A
2211  5AFD 2E 00        	LD L,0
2212  5AFF EB           	EX DE,HL
2213  5B00 26 00        	LD H,0
2214  5B02 3A F2 50     	LD A,(BLIT_TMP+2)
2215  5B05 6F           	LD L,A
2216  5B06 CD 40 52     	CALL HLx8
2217  5B09 19           	ADD HL,DE
2218  5B0A ED 5B CB F3  	LD DE,(GRPCGP)
2219  5B0E 19           	ADD HL,DE
2220  5B0F 22 FA 50     	LD (BLIT_STRUCT+6),HL
2221  5B12
2222  5B12 FD 21 19 5B  	LD IY, .RET
2223  5B16 C3 04 53     	JP ENABLE_PAGE0
2224  5B19              .RET:
2225  5B19 FB           	EI
2226  5B1A              	; set RAM functions to call
2227  5B1A 21 34 5B     	LD HL, .TILECOPY
2228  5B1D 22 63 59     	LD (TILE.CALL2+1), HL
2229  5B20 21 3A 5B     	LD HL, .SETDESTROW
2230  5B23 22 55 59     	LD (TILE.CALL1+1), HL
2231  5B26 DD 21 F4 50  	LD IX,BLIT_STRUCT
2232  5B2A CD 3A 59     	CALL TILE
2233  5B2D
2234  5B2D D1               POP DE
2235  5B2E C1               POP BC
2236  5B2F CD 7B 52         CALL RESTORE_PAGE_INFO
2237  5B32
2238  5B32 E1           	POP HL
2239  5B33 C9           	RET
2240  5B34              .TILECOPY:
2241  5B34 01 98 08     	LD BC, #0898
2242  5B37 C3 3A 52     	JP BBYTECOPY
2243  5B3A              .SETDESTROW:
2244  5B3A 2A F0 50     	LD HL, (TILETMP1)
2245  5B3D F3           	DI
2246  5B3E CD 2F 52     	CALL SETWRT_LOCAL
2247  5B41 FB           	EI
2248  5B42 C9           	RET
2249  5B43              ; *******************************************************************************************************
2250  5B43               ENDIF
2251  5B43
2252  5B43               IFNDEF CMDS_WITH_PARAMETERS
2253  5B43 ~            ; *******************************************************************************************************
2254  5B43 ~            ; function to handle CALL TILEVRM basic extension
2255  5B43 ~            ; fills vram with tiles
2256  5B43 ~            ; TILEVRM ( INT request_data_ptr )
2257  5B43 ~            ; request_data_ptr described in TILE
2258  5B43 ~            ; will put ram in page 0 also, page 1 is already there
2259  5B43 ~            TILEVRM:
2260  5B43 ~            	; opening (
2261  5B43 ~            	CALL CHKCHAR
2262  5B43 ~            	DB '('
2263  5B43 ~            	; get pointer to request struct
2264  5B43 ~            	LD IX, FRMQNT
2265  5B43 ~            	CALL CALBAS
2266  5B43 ~            	PUSH DE
2267  5B43 ~            	; ending )
2268  5B43 ~            	CALL CHKCHAR
2269  5B43 ~            	DB ')'
2270  5B43 ~
2271  5B43 ~            	POP IX ; pointer to request struct
2272  5B43 ~
2273  5B43 ~            	PUSH HL ; save position in BASIC buffer
2274  5B43 ~
2275  5B43 ~            	LD IY, .RET
2276  5B43 ~            	JP ENABLE_PAGE0
2277  5B43 ~            .RET:
2278  5B43 ~            	EI
2279  5B43 ~            	; set RAM functions to call
2280  5B43 ~            	LD HL, .TILECOPY
2281  5B43 ~            	LD (TILE.CALL2+1), HL
2282  5B43 ~            	LD HL, .SETDESTROW
2283  5B43 ~            	LD (TILE.CALL1+1), HL
2284  5B43 ~            	CALL TILE
2285  5B43 ~
2286  5B43 ~                POP DE
2287  5B43 ~                POP BC
2288  5B43 ~                CALL RESTORE_PAGE_INFO
2289  5B43 ~
2290  5B43 ~            	POP HL
2291  5B43 ~            	RET
2292  5B43 ~            .TILECOPY:
2293  5B43 ~            	LD BC, #0898
2294  5B43 ~            	JP BBYTECOPY
2295  5B43 ~            .SETDESTROW:
2296  5B43 ~            	LD HL, (TILETMP1)
2297  5B43 ~            	DI
2298  5B43 ~            	CALL SETWRT_LOCAL
2299  5B43 ~            	EI
2300  5B43 ~            	RET
2301  5B43 ~            ; *******************************************************************************************************
2302  5B43               ENDIF
2303  5B43               ENDIF
2304  5B43
2305  5B43               IF (BOX_CMDS == 1)
2306  5B43              ; *******************************************************************************************************
2307  5B43              ; generic function to implement rectangle data copy
2308  5B43              ; should be modified to call appropriate function for memory or vram
2309  5B43              ; input IX=pointer to following structure
2310  5B43              ; +00 source data pointer
2311  5B43              ; +02 num bytes in a row
2312  5B43              ; +04 number of rows
2313  5B43              ; +06 source add-to value till next row
2314  5B43              ; +08 destination address
2315  5B43              ; +10 destination add-to value till next row
2316  5B43              ; modifies AF, BC, DE, HL
2317  5B43              RECTANGLE_COPY:
2318  5B43 DD 6E 00     	LD L, (IX+0)
2319  5B46 DD 66 01     	LD H, (IX+1) ; source address
2320  5B49 DD 5E 08     	LD E, (IX+8)
2321  5B4C DD 56 09     	LD D, (IX+9) ; destination
2322  5B4F DD 46 04     	LD B, (IX+4) ; row number
2323  5B52              .L1:
2324  5B52 C5           	PUSH BC
2325  5B53 E5           		PUSH HL
2326  5B54 D5           			PUSH DE
2327  5B55 DD 4E 02     				LD C, (IX+2)
2328  5B58 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2329  5B5B              .CALL1:
2330  5B5B CD 00 00     				CALL 0 ; set destination address from DE
2331  5B5E              .CALL2:
2332  5B5E CD 00 00     				CALL 0 ; copy data fn
2333  5B61 E1           			POP HL
2334  5B62 DD 4E 0A     			LD C, (IX+10)
2335  5B65 DD 46 0B     			LD B, (IX+11) ; destination add-to
2336  5B68 09           			ADD HL, BC
2337  5B69 EB           			EX DE, HL
2338  5B6A E1           		POP HL
2339  5B6B DD 4E 06     		LD C, (IX+6)
2340  5B6E DD 46 07     		LD B, (IX+7) ; src add-to
2341  5B71 09           		ADD HL, BC
2342  5B72 C1           	POP BC
2343  5B73 10 DD        	DJNZ .L1
2344  5B75 C9           	RET
2345  5B76              ; *******************************************************************************************************
2346  5B76
2347  5B76              ; *******************************************************************************************************
2348  5B76              ; function to handle CALL BOXMEMCPY basic extension
2349  5B76              ; copies data with window like boundaries to ram
2350  5B76              ; BOXMEMCPY ( INT request_data_ptr )
2351  5B76              ; request_data_ptr described in RECTANGLE_COPY
2352  5B76              ; will put ram in page 0 also, page 1 is already there
2353  5B76              BOXMEMCPY:
2354  5B76              	; opening (
2355  5B76 CD 51 53     	CALL CHKCHAR
2356  5B79 28           	DB '('
2357  5B7A              	; get pointer to request struct
2358  5B7A DD 21 2F 54  	LD IX, FRMQNT
2359  5B7E CD 59 01     	CALL CALBAS
2360  5B81 D5           	PUSH DE
2361  5B82              	; ending )
2362  5B82 CD 51 53     	CALL CHKCHAR
2363  5B85 29           	DB ')'
2364  5B86
2365  5B86 DD E1        	POP IX ; pointer to request struct
2366  5B88
2367  5B88 E5           	PUSH HL ; save position in BASIC buffer
2368  5B89
2369  5B89 FD 21 90 5B  	LD IY, .RET
2370  5B8D C3 04 53     	JP ENABLE_PAGE0
2371  5B90              .RET:
2372  5B90 FB           	EI
2373  5B91              	; set RAM functions to call
2374  5B91 21 00 00     	LD HL, 0
2375  5B94 22 5B 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2376  5B97 22 5D 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2377  5B9A 21 ED B0     	LD HL, #B0ED ; LDIR
2378  5B9D 22 5F 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
2379  5BA0 CD 43 5B     	CALL RECTANGLE_COPY
2380  5BA3
2381  5BA3 D1               POP DE
2382  5BA4 C1               POP BC
2383  5BA5 CD 7B 52         CALL RESTORE_PAGE_INFO
2384  5BA8
2385  5BA8 E1           	POP HL
2386  5BA9 C9           	RET
2387  5BAA              ; *******************************************************************************************************
2388  5BAA
2389  5BAA              ; *******************************************************************************************************
2390  5BAA              ; function to handle CALL BOXMEMVRM basic extension
2391  5BAA              ; copies data with window like boundaries to ram
2392  5BAA              ; BOXMEMVRM ( INT request_data_ptr )
2393  5BAA              ; request_data_ptr described in RECTANGLE_COPY
2394  5BAA              ; will put ram in page 0 also, page 1 is already there
2395  5BAA              BOXMEMVRM:
2396  5BAA              	; opening (
2397  5BAA CD 51 53     	CALL CHKCHAR
2398  5BAD 28           	DB '('
2399  5BAE              	; get pointer to request struct
2400  5BAE DD 21 2F 54  	LD IX, FRMQNT
2401  5BB2 CD 59 01     	CALL CALBAS
2402  5BB5 D5           	PUSH DE
2403  5BB6              	; ending )
2404  5BB6 CD 51 53     	CALL CHKCHAR
2405  5BB9 29           	DB ')'
2406  5BBA
2407  5BBA DD E1        	POP IX ; pointer to request struct
2408  5BBC
2409  5BBC E5           	PUSH HL ; save position in BASIC buffer
2410  5BBD
2411  5BBD FD 21 C4 5B  	LD IY, .RET
2412  5BC1 C3 04 53     	JP ENABLE_PAGE0
2413  5BC4              .RET:
2414  5BC4 FB           	EI
2415  5BC5              	; set RAM functions to call
2416  5BC5 21 E3 5B     	LD HL, .SETDEST
2417  5BC8 22 5C 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
2418  5BCB 21 EB 5B     	LD HL, .COPYDATA
2419  5BCE 22 5F 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
2420  5BD1 3E CD        	LD A, #CD ; CALL
2421  5BD3 32 5B 5B     	LD (RECTANGLE_COPY.CALL1), A
2422  5BD6 32 5E 5B     	LD (RECTANGLE_COPY.CALL2), A
2423  5BD9 CD 43 5B     	CALL RECTANGLE_COPY
2424  5BDC
2425  5BDC D1               POP DE
2426  5BDD C1               POP BC
2427  5BDE CD 7B 52         CALL RESTORE_PAGE_INFO
2428  5BE1
2429  5BE1 E1           	POP HL
2430  5BE2 C9           	RET
2431  5BE3              .SETDEST:
2432  5BE3 EB           	EX DE, HL
2433  5BE4 F3           	DI
2434  5BE5 CD 2F 52     	CALL SETWRT_LOCAL
2435  5BE8 FB           	EI
2436  5BE9 EB           	EX DE, HL
2437  5BEA C9           	RET
2438  5BEB              .COPYDATA:
2439  5BEB 41           	LD B, C
2440  5BEC 0E 98        	LD C, #98
2441  5BEE C3 3A 52     	JP BBYTECOPY
2442  5BF1              ; *******************************************************************************************************
2443  5BF1               ENDIF
2444  5BF1
2445  5BF1              EXT_END:
2446  5BF1
# file closed: asm\main.asm
