# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		   EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000              BYTEOPS_CMDS   EQU 0
 14   4000              COLL_CMD       EQU 1
 15   4000
 16   4000               DEFINE CMDS_WITH_PARAMETERS
 17   4000
 18   4000              CHPUT   EQU    #A2
 19   4000              CALBAS  EQU		#159
 20   4000              ERRHAND EQU    #406F
 21   4000              FRMEVL  EQU    #4C64
 22   4000              FRESTR  EQU		#67D0
 23   4000              ; FRMQNT = formula quantificator
 24   4000              ; input HL=pointer to current program expression
 25   4000              ; output HL=next address
 26   4000              ; output DE=integer datum
 27   4000              FRMQNT	EQU		#542F
 28   4000              ; GETBYT = get byte parameter
 29   4000              ; input HL=pointer to current program expression
 30   4000              ; output HL=next address
 31   4000              ; output A=E=byte read
 32   4000              GETBYT		EQU	#521C
 33   4000              CHRGTR  	   EQU   #4666
 34   4000              PTRGET		EQU 	#5EA4
 35   4000              SUBFLG		EQU	#F6A5
 36   4000              SYNCHR		EQU	#558C
 37   4000              VALTYP  	   EQU   #F663
 38   4000              DAC         EQU   #F7F6
 39   4000              USR     	   EQU   #F7F8
 40   4000              PROCNM		EQU	#FD89
 41   4000              BIOS_FILVRM EQU   #0056
 42   4000              CLIKSW		EQU	#F3DB
 43   4000              ATRBAS		EQU	#F928
 44   4000              GRPCGP		EQU	#F3CB
 45   4000
 46   4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 47   4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 48   4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 49   4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 50   4000              EXPTBL	   EQU   #FCC1
 51   4000              SCRMOD	   EQU   #FCAF ; current screen mode
 52   4000              REG1SAV     EQU   #F3E0 ; VDP(1)
 53   4000              JIFFY	      EQU   #FC9E
 54   4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
 55   4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
 56   4000              PATBAS      EQU   #F926 ; current sprite generator table address
 57   4000              CGPBAS      EQU   #F924 ; current pattern generator table address
 58   4000
 59   4000              ; BASIC error codes
 60   4000              ;01 NEXT without FOR
 61   4000              ;02 Syntax error
 62   4000              ;03 RETURN without GOSUB
 63   4000              ;04 Out of DATA
 64   4000              ;05 Illegal function call
 65   4000              ;06 Overflow
 66   4000              ;07 Out of memory
 67   4000              ;08 Undefined line number
 68   4000              ;09 Subscript out of range
 69   4000              ;10 Redimensioned array
 70   4000              ;11 Division by zero
 71   4000              ;12 Illegal direct
 72   4000              ;13 Type mismatch
 73   4000              ;14 Out of string space
 74   4000              ;15 String too long
 75   4000              ;16 String formula too complex
 76   4000              ;17 Can't CONTINUE
 77   4000              ;18 Undefined user function
 78   4000              ;19 Device I/O error
 79   4000              ;20 Verify error
 80   4000              ;21 No RESUME
 81   4000              ;22 RESUME without error
 82   4000              ;23 Unprintable error
 83   4000              ;24 Missing operand
 84   4000              ;25 Line buffer overflow
 85   4000              ;50 FIELD overflow
 86   4000              ;51 Internal error
 87   4000              ;52 Bad file number
 88   4000              ;53 File not found
 89   4000              ;54 File already open
 90   4000              ;55 Input past end
 91   4000              ;56 Bad file name
 92   4000              ;57 Direct statement in file
 93   4000              ;58 Sequential I/O only
 94   4000              ;59 File not OPEN
 95   4000
 96   4000
 97   4000               ; simulate cartridge with BASIC extension
 98   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 98   4004 F4 61 00 00
 98   4008 00 00 00 00
 98   400C 00 00 00 00
 99   4010
100   4010              ; this location #4010 stores last location used by basic extension
101   4010              ; free memory after that point
102   4010              FREEMEMPTR:
103   4010 91 62         DW EXT_END
104   4012
105   4012              ; this location #4012 stores extension version in DAA format
106   4012              ; first byte is major version and second minor
107   4012              VERSION:
108   4012 00 70         DB #00, #70
109   4014
110   4014              ; binary included AKG player compiled at #4014
111   4014               IF (SOUND_CMDS == 1)
112   4014              	INCBIN "bin/AKG.bin"
113   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
114   4CF0               ENDIF
115   4CF0
116   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A 11 56     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD 24 61         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD 6B 61         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD 24 61         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD 6B 61         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A 11 56     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD 5B 61         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD 5B 61         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A 71 5F         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD C2 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
117   4D73
118   4D73               IF (SPRITE_CMDS == 1)
119   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD 20 61         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D95 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D98 B7           	OR A
 55+  4D99 28 03        	JR Z, .L3
 56+  4D9B 3A 79 4D     	LD A, (FLICKER)
 57+  4D9E              .L3:
 58+  4D9E 5F           	LD E, A
 59+  4D9F 08           	EX AF, AF'
 60+  4DA0 7B           	LD A, E
 61+  4DA1 87           	ADD A, A
 62+  4DA2 87           	ADD A, A
 63+  4DA3 16 00        	LD D, 0
 64+  4DA5 5F           	LD E, A
 65+  4DA6 19           	ADD HL, DE
 66+  4DA7 CD 0B 61     	CALL SETWRT_LOCAL
 67+  4DAA ED 73 7A 4D  	LD (TMPSP), SP
 68+  4DAE ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 69+  4DB2
 70+  4DB2              .LOOP:
 71+  4DB2 E1           	POP HL
 72+  4DB3 24           	INC H
 73+  4DB4 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DB6 25           	DEC H
 75+  4DB7 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DB9 7D           	LD A, L
 77+  4DBA FE C0        	CP 192
 78+  4DBC 30 10        	JR NC, .OUT3
 79+  4DBE 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DBF 57           	LD D, A
 81+  4DC0 C3 E7 4D     	JP .X
 82+  4DC3              .L1:
 83+  4DC3 7D           	LD A, L
 84+  4DC4 C6 10        	ADD 16
 85+  4DC6 FA CE 4D     	JP M, .OUT3 ; below -16
 86+  4DC9 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DCA 55           	LD D, L
 88+  4DCB C3 E7 4D     	JP .X
 89+  4DCE              .OUT3:
 90+  4DCE E1           	POP HL ; skip x value
 91+  4DCF              .OUT2:
 92+  4DCF E1           	POP HL ; skip pattern
 93+  4DD0 E1           	POP HL ; skip color
 94+  4DD1 3E D1        	LD A, #D1
 95+  4DD3 ED 79        	OUT (C), A ; sprite hidden
 96+  4DD5 00          > NOP
 96+  4DD6 00          > NOP
 96+  4DD7 00          > NOP
 97+  4DD8 ED 79        	OUT (C), A ; value unimportant
 98+  4DDA 00          > NOP
 98+  4DDB 00          > NOP
 98+  4DDC 00          > NOP
 99+  4DDD ED 79        	OUT (C), A ; value unimportant
100+  4DDF 00          > NOP
100+  4DE0 00          > NOP
100+  4DE1 00          > NOP
101+  4DE2 ED 79        	OUT (C), A ; value unimportant
102+  4DE4 C3 12 4E     	JP .NEXT
103+  4DE7              .X:
104+  4DE7 E1           	POP HL
105+  4DE8 24           	INC H
106+  4DE9 28 08        	JR Z, .L2
107+  4DEB 25           	DEC H
108+  4DEC 20 E1        	JR NZ, .OUT2
109+  4DEE 1E 00        	LD E, 0 ; EC bit
110+  4DF0 C3 FC 4D     	JP .XY
111+  4DF3              .L2:
112+  4DF3 7D           	LD A, L
113+  4DF4 C6 20        	ADD 32
114+  4DF6 FA CF 4D     	JP M, .OUT2
115+  4DF9 6F           	LD L, A
116+  4DFA 1E 80        	LD E, #80
117+  4DFC              .XY:
118+  4DFC ED 51        	OUT (C), D
119+  4DFE 3A E0 F3     	LD A, (REG1SAV)
120+  4E01 E6 02        	AND 2
121+  4E03 ED 69        	OUT (C), L
122+  4E05 E1           	POP HL ; pattern
123+  4E06 7D           	LD A, L
124+  4E07 28 02        	JR Z, .SMALLSPRITES
125+  4E09 87           	ADD A, A
126+  4E0A 87           	ADD A, A ; needs to go at 4x
127+  4E0B              .SMALLSPRITES:
128+  4E0B D3 98        	OUT (#98), A
129+  4E0D E1           	POP HL ; color
130+  4E0E 7D           	LD A, L
131+  4E0F B3           	OR E
132+  4E10 D3 98        	OUT (#98), A
133+  4E12              .NEXT:
134+  4E12 08           	EX AF, AF'
135+  4E13 3C           	INC A
136+  4E14 E6 1F        	AND 31
137+  4E16 C2 2A 4E     	JP NZ, .NEXT2
138+  4E19 08           	EX AF, AF'
139+  4E1A 2A 28 F9     	LD HL, (ATRBAS)
140+  4E1D              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E1D 7D           	LD	A, L
142+  4E1E D3 99        	OUT	(099H), A
143+  4E20 7C           	LD	A, H
144+  4E21 E6 3F        	AND	03FH
145+  4E23 F6 40        	OR	040H
146+  4E25 D3 99        	OUT	(099H), A
147+  4E27 C3 2B 4E     	JP .NEXT3
148+  4E2A              .NEXT2:
149+  4E2A 08           	EX AF, AF'
150+  4E2B              .NEXT3:
151+  4E2B 10 85        	DJNZ .LOOP
152+  4E2D 08           	EX AF, AF'
153+  4E2E 3C           	INC A
154+  4E2F 32 79 4D     	LD (FLICKER), A
155+  4E32
156+  4E32 ED 7B 7A 4D  	LD SP, (TMPSP)
157+  4E36 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E39 36 00        	LD (HL), 0 ; zero out update flag
159+  4E3B C9           	RET
160+  4E3C              ; *******************************************************************************************************
161+  4E3C
162+  4E3C              ; *******************************************************************************************************
163+  4E3C              ; function to handle CALL SPRENABLE basic extension
164+  4E3C              ; initializes sprites handler
165+  4E3C              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E3C              ;			   INT update_variable,
167+  4E3C              ;			   BYTE sprite_flicker_enabled )
168+  4E3C              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E3C              SPRENABLE:
170+  4E3C              	; opening (
171+  4E3C CD 31 62     	CALL CHKCHAR
172+  4E3F 28           	DB '('
173+  4E40              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E40 3E 02        	LD A,2
175+  4E42 06 02        	LD B,2
176+  4E44 11 20 04     	LD DE,#0420
177+  4E47 CD 5C 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E4A C5           	PUSH BC
179+  4E4B              	; comma
180+  4E4B CD 31 62     	CALL CHKCHAR
181+  4E4E 2C           	DB ','
182+  4E4F              	; get address of sprite update flag
183+  4E4F DD 21 A4 5E  	LD IX, PTRGET
184+  4E53 CD 59 01     	CALL CALBAS
185+  4E56 D5           	PUSH DE
186+  4E57              	; comma
187+  4E57 CD 31 62     	CALL CHKCHAR
188+  4E5A 2C           	DB ','
189+  4E5B              	; get flicker enabled flag
190+  4E5B DD 21 1C 52  	LD IX, GETBYT
191+  4E5F CD 59 01     	CALL CALBAS
192+  4E62 F5           	PUSH AF
193+  4E63              	; ending )
194+  4E63 CD 31 62     	CALL CHKCHAR
195+  4E66 29           	DB ')'
196+  4E67
197+  4E67 F1           	POP AF ; get flicker flag
198+  4E68 B7           	OR A
199+  4E69 32 78 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E6C
201+  4E6C D1           	POP DE ; update variable location
202+  4E6D ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E71 D1           	POP DE ; address of sprite attribute table
204+  4E72 ED 53 76 4D  	LD (SPRATR_DATA), DE
205+  4E76 3E 01        	LD A, 1
206+  4E78 32 73 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E7B C9           	RET
208+  4E7C              ; *******************************************************************************************************
209+  4E7C
210+  4E7C              ; *******************************************************************************************************
211+  4E7C              ; function to handle CALL SPRDISABLE basic extension
212+  4E7C              ; disables sprites handling
213+  4E7C              ; _SPRDISABLE
214+  4E7C              ; resets variable SPRATR_INIT_STATUS
215+  4E7C              SPRDISABLE:
216+  4E7C AF           	XOR A
217+  4E7D 32 73 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E80 C9           	RET
219+  4E81              ; *******************************************************************************************************
220+  4E81
221+  4E81              ; *******************************************************************************************************
222+  4E81              ; function to handle CALL SPRSET basic extension
223+  4E81              ; sets position, and optionally pattern and color of sprite
224+  4E81              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E81              ;			INT x,
226+  4E81              ;			INT y,
227+  4E81              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E81              ;			INT color, valid 0-15, otherwise ignored
229+  4E81              SPRSET:
230+  4E81 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E84 B7           	OR A
232+  4E85 20 05        	JR NZ, .L1
233+  4E87 1E 05        	LD E, 5 ; illegal function call
234+  4E89 C3 55 62     	JP THROW_ERROR
235+  4E8C              .L1:
236+  4E8C              	; opening (
237+  4E8C CD 31 62     	CALL CHKCHAR
238+  4E8F 28           	DB '('
239+  4E90              	; get sprite number
240+  4E90 DD 21 1C 52  	LD IX, GETBYT
241+  4E94 CD 59 01     	CALL CALBAS
242+  4E97 F5           	PUSH AF
243+  4E98              	; comma
244+  4E98 CD 31 62     	CALL CHKCHAR
245+  4E9B 2C           	DB ','
246+  4E9C              	; get x
247+  4E9C DD 21 2F 54  	LD IX, FRMQNT
248+  4EA0 CD 59 01     	CALL CALBAS
249+  4EA3 D5           	PUSH DE
250+  4EA4              	; comma
251+  4EA4 CD 31 62     	CALL CHKCHAR
252+  4EA7 2C           	DB ','
253+  4EA8              	; get y
254+  4EA8 DD 21 2F 54  	LD IX, FRMQNT
255+  4EAC CD 59 01     	CALL CALBAS
256+  4EAF D5           	PUSH DE
257+  4EB0              	; comma
258+  4EB0 CD 31 62     	CALL CHKCHAR
259+  4EB3 2C           	DB ','
260+  4EB4              	; get pattern
261+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
262+  4EB8 CD 59 01     	CALL CALBAS
263+  4EBB D5           	PUSH DE
264+  4EBC              	; comma
265+  4EBC CD 31 62     	CALL CHKCHAR
266+  4EBF 2C           	DB ','
267+  4EC0              	; get color
268+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
269+  4EC4 CD 59 01     	CALL CALBAS
270+  4EC7 D5           	PUSH DE
271+  4EC8              	; ending )
272+  4EC8 CD 31 62     	CALL CHKCHAR
273+  4ECB 29           	DB ')'
274+  4ECC
275+  4ECC                  ; save position in BASIC text
276+  4ECC E5           	PUSH HL
277+  4ECD DD E1        	POP IX
278+  4ECF
279+  4ECF C1           	POP BC ; color
280+  4ED0 D1           	POP DE ; pattern
281+  4ED1 D9           	EXX
282+  4ED2 C1           	POP BC ; y
283+  4ED3 D1           	POP DE ; x
284+  4ED4 F1           	POP AF ; sprite number
285+  4ED5 FE 20        	CP 32
286+  4ED7 38 05        	JR C, .L2
287+  4ED9 1E 05        	LD E, 5 ; illegal function call
288+  4EDB C3 55 62     	JP THROW_ERROR
289+  4EDE              .L2:
290+  4EDE              	; find location in sprite attributes table
291+  4EDE D5           	PUSH DE
292+  4EDF CD 7C 4D     	CALL GETnthSPRATTR
293+  4EE2 D1           	POP DE
294+  4EE3              	; set y
295+  4EE3 71           	LD (HL), C
296+  4EE4 23           	INC HL
297+  4EE5 70           	LD (HL), B
298+  4EE6 23           	INC HL
299+  4EE7              	; set x
300+  4EE7 73           	LD (HL), E
301+  4EE8 23           	INC HL
302+  4EE9 72           	LD (HL), D
303+  4EEA 23           	INC HL
304+  4EEB E5           	PUSH HL
305+  4EEC D9           	EXX
306+  4EED E1           	POP HL
307+  4EEE              	; check if 0<=pattern<64
308+  4EEE 7A           	LD A, D
309+  4EEF B7           	OR A
310+  4EF0 20 0B        	JR NZ, .L3
311+  4EF2 7B           	LD A, E
312+  4EF3 FE 40        	CP 64
313+  4EF5 30 06        	JR NC, .L3
314+  4EF7              	; set pattern
315+  4EF7              	;ADD A, A
316+  4EF7              	;ADD A, A
317+  4EF7              	;ADD A, A
318+  4EF7 77           	LD (HL), A
319+  4EF8 23           	INC HL
320+  4EF9 72           	LD (HL), D
321+  4EFA 23           	INC HL
322+  4EFB 18 02        	JR .L4
323+  4EFD              .L3:
324+  4EFD              	; skip pattern
325+  4EFD 23          > INC HL
325+  4EFE 23          > INC HL
326+  4EFF              .L4:
327+  4EFF              	; check if 0<=color<16
328+  4EFF 78           	LD A, B
329+  4F00 B7           	OR A
330+  4F01 20 08        	JR NZ, .L5
331+  4F03 79           	LD A, C
332+  4F04 FE 10        	CP 16
333+  4F06 30 03        	JR NC, .L5
334+  4F08              	; set color
335+  4F08 71           	LD (HL), C
336+  4F09 23           	INC HL
337+  4F0A 70           	LD (HL), B
338+  4F0B
339+  4F0B              .L5:
340+  4F0B DD E5        	PUSH IX
341+  4F0D E1           	POP HL
342+  4F0E C9           	RET
343+  4F0F              ; *******************************************************************************************************
344+  4F0F
345+  4F0F              ; *******************************************************************************************************
346+  4F0F              ; function sets sprite location based on initial coordinates and offset provided
347+  4F0F              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F0F              ; input DE=initial x
349+  4F0F              ; input BC=initial y
350+  4F0F              ; input IY=location where delta y,x are located
351+  4F0F              ; modifies AF, HL, IX
352+  4F0F              SPRSET_DELTA_POS:
353+  4F0F D5           	PUSH DE
354+  4F10 CD 7C 4D     	CALL GETnthSPRATTR
355+  4F13 E5           	PUSH HL
356+  4F14 DD E1        	POP IX
357+  4F16 D1           	POP DE
358+  4F17              	; IX=sprite's y location
359+  4F17 FD 6E 00     	LD L, (IY)
360+  4F1A FD 66 01     	LD H, (IY+1)
361+  4F1D 09           	ADD HL, BC
362+  4F1E DD 75 00     	LD (IX), L
363+  4F21 DD 74 01     	LD (IX+1), H
364+  4F24 FD 6E 02     	LD L, (IY+2)
365+  4F27 FD 66 03     	LD H, (IY+3)
366+  4F2A 19           	ADD HL, DE
367+  4F2B DD 75 02     	LD (IX+2), L
368+  4F2E DD 74 03     	LD (IX+3), H
369+  4F31 C9           	RET
370+  4F32              ; *******************************************************************************************************
371+  4F32
372+  4F32              ; *******************************************************************************************************
373+  4F32              ; function to handle CALL SPRGRPMOV basic extension
374+  4F32              ; sets position of a group of sprites described with
375+  4F32              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F32              ; _SPRGRPMOV ( INT x,
377+  4F32              ;			   INT y,
378+  4F32              ;			   BYTE count,
379+  4F32              ;			   INT[2][count] data_ptr
380+  4F32              ; will put ram in page 0 also, page 1 is already there
381+  4F32              SPRGRPMOV:
382+  4F32 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F35 B7           	OR A
384+  4F36 CA 4F 62     	JP Z,ILLEGAL_FUNCTION
385+  4F39              	; opening (
386+  4F39 CD 31 62     	CALL CHKCHAR
387+  4F3C 28           	DB '('
388+  4F3D              	; get x
389+  4F3D DD 21 2F 54  	LD IX, FRMQNT
390+  4F41 CD 59 01     	CALL CALBAS
391+  4F44 D5           	PUSH DE
392+  4F45              	; comma
393+  4F45 CD 31 62     	CALL CHKCHAR
394+  4F48 2C           	DB ','
395+  4F49              	; get y
396+  4F49 DD 21 2F 54  	LD IX, FRMQNT
397+  4F4D CD 59 01     	CALL CALBAS
398+  4F50 D5           	PUSH DE
399+  4F51              	; comma
400+  4F51 CD 31 62     	CALL CHKCHAR
401+  4F54 2C           	DB ','
402+  4F55              	; get count
403+  4F55 DD 21 1C 52  	LD IX, GETBYT
404+  4F59 CD 59 01     	CALL CALBAS
405+  4F5C F5           	PUSH AF
406+  4F5D              	; comma
407+  4F5D CD 31 62     	CALL CHKCHAR
408+  4F60 2C           	DB ','
409+  4F61              	; get sprite group definition array data pointer
410+  4F61 D1           	POP DE
411+  4F62 D5           	PUSH DE
412+  4F63 5A           	LD E,D
413+  4F64 16 03        	LD D,3
414+  4F66 3E 02        	LD A,2
415+  4F68 47           	LD B,A
416+  4F69 CD 5C 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
417+  4F6C C5           	PUSH BC
418+  4F6D              	; ending )
419+  4F6D CD 31 62     	CALL CHKCHAR
420+  4F70 29           	DB ')'
421+  4F71
422+  4F71 E5           	PUSH HL
423+  4F72 DD E1        	POP IX
424+  4F74
425+  4F74 E1           	POP HL ; data pointer
426+  4F75 C1           	POP BC ; count
427+  4F76 D9           	EXX
428+  4F77 C1           	POP BC ; y
429+  4F78 D1           	POP DE ; x
430+  4F79 D9           	EXX
431+  4F7A
432+  4F7A DD E5        	PUSH IX ; save position in BASIC buffer
433+  4F7C
434+  4F7C C5           	PUSH BC
435+  4F7D E5           	PUSH HL
436+  4F7E AF               XOR A
437+  4F7F CD 24 61         CALL GET_PAGE_INFO
438+  4F82 D9           	EXX
439+  4F83 E1           	POP HL
440+  4F84 F1           	POP AF
441+  4F85 D9           	EXX
442+  4F86 C5               PUSH BC
443+  4F87 D5               PUSH DE
444+  4F88 D9           	EXX
445+  4F89 F5           	PUSH AF
446+  4F8A E5           	PUSH HL
447+  4F8B D9           	EXX
448+  4F8C 3A 41 F3         LD A, (RAMAD0)
449+  4F8F 26 00            LD H, 0
450+  4F91 CD 6B 61         CALL LOCAL_ENASLT
451+  4F94 FB           	EI
452+  4F95 E1           	POP HL
453+  4F96 C1           	POP BC
454+  4F97 3E 01        	LD A,1
455+  4F99 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
456+  4F9C CD AA 4F     	CALL .UPDATE_LOC
457+  4F9F AF           	XOR A
458+  4FA0 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
459+  4FA3 D1               POP DE
460+  4FA4 C1               POP BC
461+  4FA5 CD 5B 61         CALL RESTORE_PAGE_INFO
462+  4FA8 E1           	POP HL
463+  4FA9 C9           	RET
464+  4FAA
465+  4FAA              .UPDATE_LOC:
466+  4FAA 7E           	LD A, (HL)
467+  4FAB 23           	INC HL
468+  4FAC 23           	INC HL
469+  4FAD E5           	PUSH HL
470+  4FAE FD E1        	POP IY
471+  4FB0 D9           	EXX
472+  4FB1 CD 0F 4F     	CALL SPRSET_DELTA_POS
473+  4FB4 D9           	EXX
474+  4FB5 23          > INC HL
474+  4FB6 23          > INC HL
474+  4FB7 23          > INC HL
474+  4FB8 23          > INC HL
475+  4FB9 10 EF        	DJNZ .UPDATE_LOC
476+  4FBB C9           	RET
477+  4FBC              ; *******************************************************************************************************
478+  4FBC
# file closed: asm\SPRITES.asm
120   4FBC               ENDIF
121   4FBC
122   4FBC               IF (ANIM_CMDS == 1)
123   4FBC               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FBC              ; sprite animation routines
  2+  4FBC
  3+  4FBC              ; number of animation items and pointer
  4+  4FBC              ANIMITEMNUM:
  5+  4FBC 00            DB 0
  6+  4FBD              ANIMITEMPTR:
  7+  4FBD 91 62         DW EXT_END
  8+  4FBF              ; number of animation definitions and pointer
  9+  4FBF              ANIMDEFNUM:
 10+  4FBF 00            DB 0
 11+  4FC0              ANIMDEFPTR:
 12+  4FC0 91 62         DW EXT_END
 13+  4FC2              ; number of links between sprite and animation definitions
 14+  4FC2              ANIMSPRNUM:
 15+  4FC2 00            DB 0
 16+  4FC3              ANIMSPRPTR:
 17+  4FC3 91 62         DW EXT_END
 18+  4FC5
 19+  4FC5              ; ANIMATION ITEM
 20+  4FC5              ; byte type = [0 - pattern and color change
 21+  4FC5              ;              1 - pattern definition change ]
 22+  4FC5              ; word ticks - number of ticks to hold this state
 23+  4FC5              ; for type = 0
 24+  4FC5              ;   byte pattern;
 25+  4FC5              ;   byte color;
 26+  4FC5              ; for type = 1
 27+  4FC5              ;   work data_pointer;
 28+  4FC5              ; total size = 5b
 29+  4FC5
 30+  4FC5              ; ANIMATION DEFINITION
 31+  4FC5              ; byte number of items 1-15
 32+  4FC5              ; byte[15] anim_item;
 33+  4FC5              ; total size = 16b
 34+  4FC5
 35+  4FC5              ; SPRITE/CHAR ANIMATION
 36+  4FC5              ; +00 byte sprite/char number;
 37+  4FC5              ; +01 word time;
 38+  4FC5              ; +03 byte current item;
 39+  4FC5              ; +04 byte animation definition;
 40+  4FC5              ; +05 byte cyclic;
 41+  4FC5              ; +06 byte active;
 42+  4FC5              ; +07 byte 0=sprite, 1-3 character bank
 43+  4FC5              ; total size = 8b
 44+  4FC5
 45+  4FC5              ; *******************************************************************************************************
 46+  4FC5              ; helper function HL=A*5
 47+  4FC5              ; changes HL,DE;
 48+  4FC5              Ax5:
 49+  4FC5 26 00            LD H,0
 50+  4FC7 6F               LD L,A
 51+  4FC8 54               LD D,H
 52+  4FC9 5D               LD E,L
 53+  4FCA 29               ADD HL,HL
 54+  4FCB 29               ADD HL,HL
 55+  4FCC 19               ADD HL,DE
 56+  4FCD C9               RET
 57+  4FCE              ; *******************************************************************************************************
 58+  4FCE
 59+  4FCE              ; *******************************************************************************************************
 60+  4FCE              ; helper function gets pointer to n-th animation item
 61+  4FCE              ; changes HL,DE;
 62+  4FCE              GETnthANIMITEM:
 63+  4FCE CD C5 4F         CALL Ax5
 64+  4FD1 ED 5B BD 4F      LD DE,(ANIMITEMPTR)
 65+  4FD5 19               ADD HL,DE
 66+  4FD6 C9               RET
 67+  4FD7              ; *******************************************************************************************************
 68+  4FD7
 69+  4FD7              ; *******************************************************************************************************
 70+  4FD7              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD7              ; changes HL,DE;
 72+  4FD7              GETnthANIMDEF:
 73+  4FD7 26 00            LD H,0
 74+  4FD9 6F               LD L,A
 75+  4FDA CD 1F 61         CALL HLx16
 76+  4FDD ED 5B C0 4F      LD DE,(ANIMDEFPTR)
 77+  4FE1 19               ADD HL,DE
 78+  4FE2 C9               RET
 79+  4FE3              ; *******************************************************************************************************
 80+  4FE3
 81+  4FE3              ; *******************************************************************************************************
 82+  4FE3              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FE3              ; changes HL,DE;
 84+  4FE3              GETnthSPRANIM:
 85+  4FE3 26 00            LD H,0
 86+  4FE5 6F               LD L,A
 87+  4FE6 CD 20 61         CALL HLx8
 88+  4FE9 ED 5B C3 4F      LD DE,(ANIMSPRPTR)
 89+  4FED 19               ADD HL,DE
 90+  4FEE C9               RET
 91+  4FEF              ; *******************************************************************************************************
 92+  4FEF
 93+  4FEF              ; *******************************************************************************************************
 94+  4FEF              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FEF              ; MAXANIMITEMS (BYTE number)
 96+  4FEF              ; sets new number and moves memory buffers as needed
 97+  4FEF              MAXANIMITEMS:
 98+  4FEF              	; opening (
 99+  4FEF CD 31 62     	CALL CHKCHAR
100+  4FF2 28           	DB '('
101+  4FF3              	; get value
102+  4FF3 DD 21 1C 52  	LD IX, GETBYT
103+  4FF7 CD 59 01     	CALL CALBAS
104+  4FFA F5               PUSH AF
105+  4FFB              	; ending )
106+  4FFB CD 31 62     	CALL CHKCHAR
107+  4FFE 29           	DB ')'
108+  4FFF F1               POP AF
109+  5000
110+  5000              	; save position
111+  5000 E5           	PUSH HL
112+  5001              .ENTRY:
113+  5001 47               LD B,A
114+  5002 3A BC 4F         LD A,(ANIMITEMNUM)
115+  5005 90               SUB B
116+  5006 28 1F            JR Z, .EXIT; same value as before
117+  5008 FD 21 C0 4F      LD IY,ANIMDEFPTR
118+  500C FA 2A 50         JP M, .INCREASE
119+  500F                  ; new value is lower than previous one
120+  500F CD 42 50         CALL .SIZEDIFF
121+  5012 CD 5D 50         CALL .DECREASE_COMMON
122+  5015 2A C3 4F         LD HL,(ANIMSPRPTR)
123+  5018 AF               XOR A
124+  5019 ED 42            SBC HL,BC
125+  501B 22 C3 4F         LD (ANIMSPRPTR),HL
126+  501E              .E1:
127+  501E 2A 10 40         LD HL,(FREEMEMPTR)
128+  5021 AF               XOR A
129+  5022 ED 42            SBC HL,BC
130+  5024 22 10 40         LD (FREEMEMPTR),HL
131+  5027              .EXIT:
132+  5027 FB               EI
133+  5028 E1           	POP HL
134+  5029 C9           	RET
135+  502A              .INCREASE:
136+  502A ED 44            NEG
137+  502C CD 42 50         CALL .SIZEDIFF
138+  502F CD 89 50         CALL .INCREASE_COMMON
139+  5032 2A C3 4F         LD HL,(ANIMSPRPTR)
140+  5035 09               ADD HL,BC
141+  5036 22 C3 4F         LD (ANIMSPRPTR),HL
142+  5039              .E2:
143+  5039 2A 10 40         LD HL,(FREEMEMPTR)
144+  503C 09               ADD HL,BC
145+  503D 22 10 40         LD (FREEMEMPTR),HL
146+  5040 18 E5            JR .EXIT
147+  5042              .SIZEDIFF:
148+  5042 CD C5 4F         CALL Ax5
149+  5045 78               LD A,B
150+  5046 32 BC 4F         LD (ANIMITEMNUM),A
151+  5049 44               LD B,H
152+  504A 4D               LD C,L
153+  504B C9               RET ; BC=size difference in bytes
154+  504C              .SIZETOMOVE:
155+  504C D5               PUSH DE
156+  504D 2A 10 40         LD HL,(FREEMEMPTR)
157+  5050 FD 5E 00         LD E,(IY)
158+  5053 FD 56 01         LD D,(IY+1)
159+  5056 AF               XOR A
160+  5057 ED 52            SBC HL,DE
161+  5059 44               LD B,H
162+  505A 4D               LD C,L
163+  505B D1               POP DE
164+  505C C9               RET
165+  505D              .DECREASE_COMMON:
166+  505D FD 6E 00         LD L,(IY)
167+  5060 FD 66 01         LD H,(IY+1)
168+  5063 AF               XOR A
169+  5064 ED 42            SBC HL,BC
170+  5066 EB               EX DE,HL
171+  5067 C5               PUSH BC
172+  5068 CD 4C 50         CALL .SIZETOMOVE
173+  506B F3               DI
174+  506C 78               LD A,B
175+  506D B1               OR C
176+  506E 28 08            JR Z,.L1
177+  5070 FD 6E 00         LD L,(IY)
178+  5073 FD 66 01         LD H,(IY+1)
179+  5076 ED B0            LDIR
180+  5078              .L1:
181+  5078 C1               POP BC
182+  5079 FD 6E 00         LD L,(IY)
183+  507C FD 66 01         LD H,(IY+1)
184+  507F AF               XOR A
185+  5080 ED 42            SBC HL,BC
186+  5082 FD 75 00         LD (IY),L
187+  5085 FD 74 01         LD (IY+1),H
188+  5088 C9               RET
189+  5089              .INCREASE_COMMON:
190+  5089 2A 10 40         LD HL,(FREEMEMPTR)
191+  508C 2B               DEC HL
192+  508D AF               XOR A
193+  508E ED 42            SBC HL,BC
194+  5090 EB               EX DE,HL
195+  5091 C5               PUSH BC
196+  5092 CD 4C 50         CALL .SIZETOMOVE
197+  5095 F3               DI
198+  5096 78               LD A,B
199+  5097 B1               OR C
200+  5098 28 06            JR Z,.L2
201+  509A 2A 10 40         LD HL,(FREEMEMPTR)
202+  509D 2B               DEC HL
203+  509E ED B8            LDDR
204+  50A0              .L2:
205+  50A0 C1               POP BC
206+  50A1 FD 6E 00         LD L,(IY)
207+  50A4 FD 66 01         LD H,(IY+1)
208+  50A7 09               ADD HL,BC
209+  50A8 FD 75 00         LD (IY),L
210+  50AB FD 74 01         LD (IY+1),H
211+  50AE C9               RET
212+  50AF              ; *******************************************************************************************************
213+  50AF
214+  50AF              ; *******************************************************************************************************
215+  50AF              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AF              ; ANIMITEMPAT ( BYTE id,
217+  50AF              ;               INT ticks,
218+  50AF              ;               BYTE pattern,
219+  50AF              ;               BYTE color )
220+  50AF              ; fills animation item data, returns an error if out of bounds
221+  50AF              ANIMITEMPAT:
222+  50AF                  ; opening (
223+  50AF CD 31 62     	CALL CHKCHAR
224+  50B2 28           	DB '('
225+  50B3              	; get id
226+  50B3 DD 21 1C 52  	LD IX, GETBYT
227+  50B7 CD 59 01     	CALL CALBAS
228+  50BA F5               PUSH AF
229+  50BB                  ; check if out of bounds
230+  50BB 3C               INC A
231+  50BC 4F               LD C,A
232+  50BD 3A BC 4F         LD A,(ANIMITEMNUM)
233+  50C0 B9               CP C
234+  50C1 DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50C4              	; comma
236+  50C4 CD 31 62     	CALL CHKCHAR
237+  50C7 2C           	DB ','
238+  50C8              	; get ticks
239+  50C8 DD 21 2F 54  	LD IX, FRMQNT
240+  50CC CD 59 01     	CALL CALBAS
241+  50CF D5           	PUSH DE
242+  50D0              	; comma
243+  50D0 CD 31 62     	CALL CHKCHAR
244+  50D3 2C           	DB ','
245+  50D4              	; get pattern
246+  50D4 DD 21 1C 52  	LD IX, GETBYT
247+  50D8 CD 59 01     	CALL CALBAS
248+  50DB F5               PUSH AF
249+  50DC              	; comma
250+  50DC CD 31 62     	CALL CHKCHAR
251+  50DF 2C           	DB ','
252+  50E0              	; get color
253+  50E0 DD 21 1C 52  	LD IX, GETBYT
254+  50E4 CD 59 01     	CALL CALBAS
255+  50E7 F5               PUSH AF
256+  50E8              	; ending )
257+  50E8 CD 31 62     	CALL CHKCHAR
258+  50EB 29           	DB ')'
259+  50EC              .ENTRY:
260+  50EC E5               PUSH HL
261+  50ED DD E1            POP IX
262+  50EF D9               EXX
263+  50F0 C1               POP BC ; color
264+  50F1 D1               POP DE ; pattern
265+  50F2 E1               POP HL ; ticks
266+  50F3 D9               EXX
267+  50F4 F1               POP AF
268+  50F5 CD CE 4F         CALL GETnthANIMITEM
269+  50F8 E5               PUSH HL
270+  50F9 FD E1            POP IY
271+  50FB D9               EXX
272+  50FC FD 36 00 00      LD (IY),0 ; type=0
273+  5100 FD 75 01         LD (IY+1),L
274+  5103 FD 74 02         LD (IY+2),H
275+  5106 FD 72 03         LD (IY+3),D
276+  5109 FD 70 04         LD (IY+4),B
277+  510C
278+  510C DD E5            PUSH IX
279+  510E E1               POP HL
280+  510F C9               RET
281+  5110              ; *******************************************************************************************************
282+  5110
283+  5110              ; *******************************************************************************************************
284+  5110              ; function to handle CALL ANIMITEMPTR basic extension
285+  5110              ; ANIMITEMPTR ( BYTE id,
286+  5110              ;               INT ticks,
287+  5110              ;               INT pointer,
288+  5110              ; fills animation item data, returns an error if out of bounds
289+  5110              ANIMITEMPTR_CMD:
290+  5110                  ; opening (
291+  5110 CD 31 62     	CALL CHKCHAR
292+  5113 28           	DB '('
293+  5114              	; get id
294+  5114 DD 21 1C 52  	LD IX, GETBYT
295+  5118 CD 59 01     	CALL CALBAS
296+  511B F5               PUSH AF
297+  511C                  ; check if out of bounds
298+  511C 3C               INC A
299+  511D 4F               LD C,A
300+  511E 3A BC 4F         LD A,(ANIMITEMNUM)
301+  5121 B9               CP C
302+  5122 DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5125              	; comma
304+  5125 CD 31 62     	CALL CHKCHAR
305+  5128 2C           	DB ','
306+  5129              	; get ticks
307+  5129 DD 21 2F 54  	LD IX, FRMQNT
308+  512D CD 59 01     	CALL CALBAS
309+  5130 D5           	PUSH DE
310+  5131              	; comma
311+  5131 CD 31 62     	CALL CHKCHAR
312+  5134 2C           	DB ','
313+  5135              	; get pointer
314+  5135 DD 21 2F 54  	LD IX, FRMQNT
315+  5139 CD 59 01     	CALL CALBAS
316+  513C D5           	PUSH DE
317+  513D              	; ending )
318+  513D CD 31 62     	CALL CHKCHAR
319+  5140 29           	DB ')'
320+  5141              .ENTRY:
321+  5141 E5               PUSH HL
322+  5142 DD E1            POP IX
323+  5144 D9               EXX
324+  5145 D1               POP DE ; pointer
325+  5146 E1               POP HL ; ticks
326+  5147 D9               EXX
327+  5148 F1               POP AF
328+  5149 CD CE 4F         CALL GETnthANIMITEM
329+  514C E5               PUSH HL
330+  514D FD E1            POP IY
331+  514F D9               EXX
332+  5150 FD 36 00 01      LD (IY),1 ; type=1
333+  5154 FD 75 01         LD (IY+1),L
334+  5157 FD 74 02         LD (IY+2),H
335+  515A FD 73 03         LD (IY+3),E
336+  515D FD 72 04         LD (IY+4),D
337+  5160
338+  5160 DD E5            PUSH IX
339+  5162 E1               POP HL
340+  5163 C9               RET
341+  5164              ; *******************************************************************************************************
342+  5164
343+  5164              ; *******************************************************************************************************
344+  5164              ; function to handle CALL MAXANIMDEFS basic extension
345+  5164              ; MAXANIMDEFS (BYTE number)
346+  5164              ; sets new number and moves memory buffers as needed
347+  5164              MAXANIMDEFS:
348+  5164              	; opening (
349+  5164 CD 31 62     	CALL CHKCHAR
350+  5167 28           	DB '('
351+  5168              	; get value
352+  5168 DD 21 1C 52  	LD IX, GETBYT
353+  516C CD 59 01     	CALL CALBAS
354+  516F F5               PUSH AF
355+  5170              	; ending )
356+  5170 CD 31 62     	CALL CHKCHAR
357+  5173 29           	DB ')'
358+  5174 F1               POP AF
359+  5175
360+  5175              	; save position
361+  5175 E5           	PUSH HL
362+  5176              .ENTRY:
363+  5176 47               LD B,A
364+  5177 3A BF 4F         LD A,(ANIMDEFNUM)
365+  517A 90               SUB B
366+  517B CA 27 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  517E FD 21 C3 4F      LD IY,ANIMSPRPTR
368+  5182 FA 8E 51         JP M, .INCREASE
369+  5185                  ; new value is lower than previous one
370+  5185 CD 99 51         CALL .SIZEDIFF
371+  5188 CD 5D 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  518B C3 1E 50         JP MAXANIMITEMS.E1
373+  518E              .INCREASE:
374+  518E ED 44            NEG
375+  5190 CD 99 51         CALL .SIZEDIFF
376+  5193 CD 89 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5196 C3 39 50         JP MAXANIMITEMS.E2
378+  5199              .SIZEDIFF:
379+  5199 26 00            LD H,0
380+  519B 6F               LD L,A
381+  519C CD 1F 61         CALL HLx16
382+  519F 78               LD A,B
383+  51A0 32 BF 4F         LD (ANIMDEFNUM),A
384+  51A3 44               LD B,H
385+  51A4 4D               LD C,L
386+  51A5 C9               RET ; BC=size difference in bytes
387+  51A6              ; *******************************************************************************************************
388+  51A6
389+  51A6              ; *******************************************************************************************************
390+  51A6              ; function to handle CALL ANIMDEF basic extension
391+  51A6              ; ANIMITEMPAT ( BYTE id,
392+  51A6              ;               BYTE size,
393+  51A6              ;               INT[] list )
394+  51A6              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A6              ANIMDEF:
396+  51A6                  ; opening (
397+  51A6 CD 31 62     	CALL CHKCHAR
398+  51A9 28           	DB '('
399+  51AA              	; get id
400+  51AA DD 21 1C 52  	LD IX, GETBYT
401+  51AE CD 59 01     	CALL CALBAS
402+  51B1 F5               PUSH AF
403+  51B2                  ; check if out of bounds
404+  51B2 3C               INC A
405+  51B3 4F               LD C,A
406+  51B4 3A BF 4F         LD A,(ANIMDEFNUM)
407+  51B7 B9               CP C
408+  51B8 DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51BB              	; comma
410+  51BB CD 31 62     	CALL CHKCHAR
411+  51BE 2C           	DB ','
412+  51BF              	; get size
413+  51BF DD 21 1C 52  	LD IX, GETBYT
414+  51C3 CD 59 01     	CALL CALBAS
415+  51C6 FE 10            CP 16
416+  51C8 D2 4B 62         JP NC, OVERFLOW
417+  51CB B7               OR A
418+  51CC CA 4B 62         JP Z, OVERFLOW
419+  51CF F5           	PUSH AF
420+  51D0              	; comma
421+  51D0 CD 31 62     	CALL CHKCHAR
422+  51D3 2C           	DB ','
423+  51D4              	; get pointer to a list of animation items in integer array format
424+  51D4                  ; get array pointer
425+  51D4 D1               POP DE
426+  51D5 D5               PUSH DE
427+  51D6 3E 02            LD A,2
428+  51D8 06 01            LD B,1
429+  51DA CD 5C 62         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51DD C5               PUSH BC
431+  51DE              	; ending )
432+  51DE CD 31 62     	CALL CHKCHAR
433+  51E1 29           	DB ')'
434+  51E2              .ENTRY:
435+  51E2 E5               PUSH HL
436+  51E3 DD E1            POP IX
437+  51E5 D1               POP DE ; pointer to INT array
438+  51E6 C1               POP BC ; B=item number
439+  51E7 F1               POP AF ; id
440+  51E8 D5               PUSH DE
441+  51E9 CD D7 4F         CALL GETnthANIMDEF
442+  51EC D1               POP DE
443+  51ED 70               LD (HL),B
444+  51EE              .L1:
445+  51EE 23               INC HL
446+  51EF 1A               LD A,(DE)
447+  51F0 13          > INC DE
447+  51F1 13          > INC DE
448+  51F2 77               LD (HL),A
449+  51F3 10 F9            DJNZ .L1
450+  51F5 DD E5            PUSH IX
451+  51F7 E1               POP HL
452+  51F8 C9               RET
453+  51F9              ; *******************************************************************************************************
454+  51F9
455+  51F9              ; *******************************************************************************************************
456+  51F9              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F9              ; MAXANIMSPRS (BYTE number)
458+  51F9              ; sets new number and moves memory buffers as needed
459+  51F9              MAXANIMSPRS:
460+  51F9              	; opening (
461+  51F9 CD 31 62     	CALL CHKCHAR
462+  51FC 28           	DB '('
463+  51FD              	; get value
464+  51FD DD 21 1C 52  	LD IX, GETBYT
465+  5201 CD 59 01     	CALL CALBAS
466+  5204 F5               PUSH AF
467+  5205              	; ending )
468+  5205 CD 31 62     	CALL CHKCHAR
469+  5208 29           	DB ')'
470+  5209 F1               POP AF
471+  520A
472+  520A              	; save position
473+  520A E5           	PUSH HL
474+  520B              .ENTRY:
475+  520B 47               LD B,A
476+  520C 3A C2 4F         LD A,(ANIMSPRNUM)
477+  520F 90               SUB B
478+  5210 CA 27 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  5213 FD 21 10 40      LD IY,FREEMEMPTR
480+  5217 FA 23 52         JP M, .INCREASE
481+  521A                  ; new value is lower than previous one
482+  521A CD 42 52         CALL .SIZEDIFF
483+  521D CD 5D 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  5220 C3 27 50         JP MAXANIMITEMS.EXIT
485+  5223              .INCREASE:
486+  5223 ED 44            NEG
487+  5225 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5226 CD 42 52         CALL .SIZEDIFF
489+  5229 CD 89 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  522C AF               XOR A
491+  522D ED 42            SBC HL,BC ; location of new stuff
492+  522F F1               POP AF
493+  5230 47               LD B,A
494+  5231 11 08 00         LD DE,8
495+  5234 E5               PUSH HL
496+  5235 DD E1            POP IX
497+  5237              .L1:
498+  5237 DD 36 06 00      LD (IX+6),0
499+  523B DD 19            ADD IX,DE
500+  523D 10 F8            DJNZ .L1
501+  523F C3 27 50         JP MAXANIMITEMS.EXIT
502+  5242              .SIZEDIFF:
503+  5242 26 00            LD H,0
504+  5244 6F               LD L,A
505+  5245 CD 20 61         CALL HLx8
506+  5248 78               LD A,B
507+  5249 32 C2 4F         LD (ANIMSPRNUM),A
508+  524C 44               LD B,H
509+  524D 4D               LD C,L
510+  524E C9               RET ; BC=size difference in bytes
511+  524F              ; *******************************************************************************************************
512+  524F
513+  524F              ; *******************************************************************************************************
514+  524F              ; function to handle CALL ANIMSPRITE basic extension
515+  524F              ; ANIMSPRITE ( BYTE id,
516+  524F              ;              BYTE sprite_number,
517+  524F              ;              BYTE animation_definition_id,
518+  524F              ;              BYTE cyclic_flag )
519+  524F              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524F              ANIMSPRITE:
521+  524F                  ; opening (
522+  524F CD 31 62     	CALL CHKCHAR
523+  5252 28           	DB '('
524+  5253              	; get sprite animation id
525+  5253 DD 21 1C 52  	LD IX, GETBYT
526+  5257 CD 59 01     	CALL CALBAS
527+  525A F5               PUSH AF
528+  525B 3C               INC A
529+  525C 4F               LD C,A
530+  525D 3A C2 4F         LD A,(ANIMSPRNUM)
531+  5260 B9               CP C
532+  5261 DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  5264              	; comma
534+  5264 CD 31 62     	CALL CHKCHAR
535+  5267 2C           	DB ','
536+  5268              	; get sprite number
537+  5268 DD 21 1C 52  	LD IX, GETBYT
538+  526C CD 59 01     	CALL CALBAS
539+  526F F5               PUSH AF
540+  5270                  ; check if out of bounds
541+  5270 FE 20            CP 32
542+  5272 D2 47 62         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5275              	; comma
544+  5275 CD 31 62     	CALL CHKCHAR
545+  5278 2C           	DB ','
546+  5279              	; get animation definition id
547+  5279 DD 21 1C 52  	LD IX, GETBYT
548+  527D CD 59 01     	CALL CALBAS
549+  5280 F5               PUSH AF
550+  5281 3C               INC A
551+  5282 4F               LD C,A
552+  5283 3A BF 4F         LD A,(ANIMDEFNUM)
553+  5286 B9               CP C
554+  5287 DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  528A              	; comma
556+  528A CD 31 62     	CALL CHKCHAR
557+  528D 2C           	DB ','
558+  528E              	; get cyclic flag
559+  528E DD 21 1C 52  	LD IX, GETBYT
560+  5292 CD 59 01         CALL CALBAS
561+  5295 F5           	PUSH AF
562+  5296              	; ending )
563+  5296 CD 31 62     	CALL CHKCHAR
564+  5299 29           	DB ')'
565+  529A              .ENTRY:
566+  529A E5               PUSH HL
567+  529B DD E1            POP IX
568+  529D D9               EXX
569+  529E D1               POP DE ; cyclic
570+  529F C1               POP BC ; animation definition id
571+  52A0 E1               POP HL ; sprite number
572+  52A1 D9               EXX
573+  52A2 F1               POP AF ; sprite animation id
574+  52A3 CD E3 4F         CALL GETnthSPRANIM
575+  52A6 E5               PUSH HL
576+  52A7 FD E1            POP IY
577+  52A9 D9               EXX
578+  52AA FD 74 00         LD (IY),H
579+  52AD FD 70 04         LD (IY+4),B
580+  52B0 FD 72 05         LD (IY+5),D
581+  52B3                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
582+  52B3                  ; following will do preparation for ANIMSTEP situation
583+  52B3                  ; current item set to above limit and timer to 1
584+  52B3                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
585+  52B3 FD 36 03 FF      LD (IY+3),255
586+  52B7 FD 36 01 01      LD (IY+1),1
587+  52BB FD 36 02 00      LD (IY+2),0
588+  52BF                  ; mark as sprite animation
589+  52BF FD 36 07 00      LD (IY+7),0
590+  52C3 DD E5            PUSH IX
591+  52C5 E1               POP HL
592+  52C6 C9               RET
593+  52C7              ; *******************************************************************************************************
594+  52C7
595+  52C7              ; *******************************************************************************************************
596+  52C7              ; function to handle CALL ANIMCHAR basic extension
597+  52C7              ; ANIMCHAR ( BYTE id,
598+  52C7              ;            INT character number 0-767,
599+  52C7              ;            BYTE animation_definition_id,
600+  52C7              ;            BYTE cyclic_flag )
601+  52C7              ; fills sprite animation data, returns an error if out of bounds, or invalid type
602+  52C7              ANIMCHAR:
603+  52C7                  ; opening (
604+  52C7 CD 31 62     	CALL CHKCHAR
605+  52CA 28           	DB '('
606+  52CB              	; get sprite animation id
607+  52CB DD 21 1C 52  	LD IX, GETBYT
608+  52CF CD 59 01     	CALL CALBAS
609+  52D2 F5               PUSH AF
610+  52D3 3C               INC A
611+  52D4 4F               LD C,A
612+  52D5 3A C2 4F         LD A,(ANIMSPRNUM)
613+  52D8 B9               CP C
614+  52D9 DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
615+  52DC              	; comma
616+  52DC CD 31 62     	CALL CHKCHAR
617+  52DF 2C           	DB ','
618+  52E0              	; get character number
619+  52E0 DD 21 2F 54  	LD IX, FRMQNT
620+  52E4 CD 59 01     	CALL CALBAS
621+  52E7 D5               PUSH DE
622+  52E8                  ; check if out of bounds
623+  52E8 7A               LD A,D
624+  52E9 FE 03            CP 3
625+  52EB D2 47 62         JP NC, SUBSCRIPT_OUT_OF_RANGE
626+  52EE              	; comma
627+  52EE CD 31 62     	CALL CHKCHAR
628+  52F1 2C           	DB ','
629+  52F2              	; get animation definition id
630+  52F2 DD 21 1C 52  	LD IX, GETBYT
631+  52F6 CD 59 01     	CALL CALBAS
632+  52F9 F5               PUSH AF
633+  52FA 3C               INC A
634+  52FB 4F               LD C,A
635+  52FC 3A BF 4F         LD A,(ANIMDEFNUM)
636+  52FF B9               CP C
637+  5300 DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
638+  5303              	; comma
639+  5303 CD 31 62     	CALL CHKCHAR
640+  5306 2C           	DB ','
641+  5307              	; get cyclic flag
642+  5307 DD 21 1C 52  	LD IX, GETBYT
643+  530B CD 59 01         CALL CALBAS
644+  530E F5           	PUSH AF
645+  530F              	; ending )
646+  530F CD 31 62     	CALL CHKCHAR
647+  5312 29           	DB ')'
648+  5313              .ENTRY:
649+  5313 E5               PUSH HL
650+  5314 DD E1            POP IX
651+  5316 D9               EXX
652+  5317 D1               POP DE ; cyclic
653+  5318 C1               POP BC ; animation definition id
654+  5319 E1               POP HL ; character number
655+  531A D9               EXX
656+  531B F1               POP AF ; sprite animation id
657+  531C CD E3 4F         CALL GETnthSPRANIM
658+  531F E5               PUSH HL
659+  5320 FD E1            POP IY
660+  5322 D9               EXX
661+  5323 FD 75 00         LD (IY),L
662+  5326 24               INC H ; save character bank+1
663+  5327 FD 74 07         LD (IY+7),H
664+  532A FD 70 04         LD (IY+4),B
665+  532D FD 72 05         LD (IY+5),D
666+  5330                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
667+  5330                  ; following will do preparation for ANIMSTEP situation
668+  5330                  ; current item set to above limit and timer to 1
669+  5330                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
670+  5330 FD 36 03 FF      LD (IY+3),255
671+  5334 FD 36 01 01      LD (IY+1),1
672+  5338 FD 36 02 00      LD (IY+2),0
673+  533C DD E5            PUSH IX
674+  533E E1               POP HL
675+  533F C9               RET
676+  5340              ; *******************************************************************************************************
677+  5340
678+  5340              ; *******************************************************************************************************
679+  5340              ; function to handle CALL ANIMSTEP basic extension
680+  5340              ; two forms
681+  5340              ; ANIMSTEP ( BYTE id )
682+  5340              ; or
683+  5340              ; ANIMSTEP ( BYTE item_number,
684+  5340              ;            INT[] sprite_animations )
685+  5340              ; sets active flag to 1
686+  5340              ANIMSTEP:
687+  5340 11 BD 53         LD DE,ANIMSTARTSTOP_COMMON.STEP
688+  5343 18 08            JR ANIMSTARTSTOP_COMMON
689+  5345              ; *******************************************************************************************************
690+  5345              ; *******************************************************************************************************
691+  5345              ; function to handle CALL ANIMSTART basic extension
692+  5345              ; two forms
693+  5345              ; ANIMSTART ( BYTE id )
694+  5345              ; or
695+  5345              ; ANIMSTART ( BYTE item_number,
696+  5345              ;             INT[] sprite_animations )
697+  5345              ; sets active flag to 1
698+  5345              ANIMSTART:
699+  5345 11 AB 53         LD DE,ANIMSTARTSTOP_COMMON.START
700+  5348 18 03            JR ANIMSTARTSTOP_COMMON
701+  534A              ; *******************************************************************************************************
702+  534A              ; *******************************************************************************************************
703+  534A              ; function to handle CALL ANIMSTOP basic extension
704+  534A              ; two forms
705+  534A              ; ANIMSTOP ( BYTE id )
706+  534A              ; or
707+  534A              ; ANIMSTOP ( BYTE item_number,
708+  534A              ;            INT[] sprite_animations )
709+  534A              ; sets active flag to 1
710+  534A              ANIMSTOP:
711+  534A 11 B8 53         LD DE,ANIMSTARTSTOP_COMMON.STOP
712+  534D              ; *******************************************************************************************************
713+  534D              ANIMSTARTSTOP_COMMON:
714+  534D ED 53 A9 53      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
715+  5351                  ; opening (
716+  5351 CD 31 62     	CALL CHKCHAR
717+  5354 28           	DB '('
718+  5355              	; get sprite animation id or array size
719+  5355 DD 21 1C 52  	LD IX,GETBYT
720+  5359 CD 59 01     	CALL CALBAS
721+  535C F5               PUSH AF
722+  535D                  ; check if comma present
723+  535D CD 3B 62         CALL GETPREVCHAR
724+  5360 23               INC HL
725+  5361 FE 2C            CP ','
726+  5363 28 0C            JR Z,.L1
727+  5365 FE 29            CP ')'
728+  5367 C2 53 62         JP NZ,SYNTAX_ERROR
729+  536A                  ; ok so single argument variant
730+  536A F1               POP AF
731+  536B E5               PUSH HL
732+  536C CD 97 53         CALL .SETVALUE
733+  536F E1               POP HL
734+  5370 C9               RET
735+  5371              .L1:
736+  5371                  ; get array pointer
737+  5371 D1               POP DE
738+  5372 D5               PUSH DE
739+  5373 3E 02            LD A,2
740+  5375 06 01            LD B,1
741+  5377 CD 5C 62         CALL GET_BASIC_ARRAY_DATA_POINTER
742+  537A C5               PUSH BC
743+  537B              	; ending )
744+  537B CD 31 62     	CALL CHKCHAR
745+  537E 29           	DB ')'
746+  537F D1               POP DE ; array pointer
747+  5380 C1               POP BC ; number of items
748+  5381 78               LD A,B
749+  5382 B7               OR A
750+  5383 CA 47 62         JP Z,SUBSCRIPT_OUT_OF_RANGE
751+  5386 E5               PUSH HL
752+  5387 F3               DI
753+  5388              .L2:
754+  5388 C5               PUSH BC
755+  5389 1A               LD A,(DE)
756+  538A 13          > INC DE
756+  538B 13          > INC DE
757+  538C D5               PUSH DE
758+  538D CD 97 53         CALL .SETVALUE
759+  5390 D1               POP DE
760+  5391 C1               POP BC
761+  5392 10 F4            DJNZ .L2
762+  5394 FB               EI
763+  5395 E1               POP HL
764+  5396 C9               RET
765+  5397
766+  5397              .SETVALUE:
767+  5397 47               LD B,A
768+  5398 3C               INC A
769+  5399 4F               LD C,A
770+  539A 3A C2 4F         LD A,(ANIMSPRNUM)
771+  539D B9               CP C
772+  539E DA 47 62         JP C,SUBSCRIPT_OUT_OF_RANGE
773+  53A1 78               LD A,B
774+  53A2 CD E3 4F         CALL GETnthSPRANIM
775+  53A5 E5               PUSH HL
776+  53A6 DD E1            POP IX
777+  53A8              .FN:
778+  53A8 C3 00 00         JP 0
779+  53AB              .START:
780+  53AB DD 36 06 01      LD (IX+6),1 ; active flag
781+  53AF DD 36 03 00      LD (IX+3),0 ; current item
782+  53B3 06 00            LD B,0 ; setup timer
783+  53B5 C3 3C 54         JP SETUP_ANIM_STEP
784+  53B8              .STOP:
785+  53B8 DD 36 06 00      LD (IX+6),0 ; active flag
786+  53BC C9               RET
787+  53BD              .STEP:
788+  53BD 06 00            LD B,0
789+  53BF C3 E0 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
790+  53C2              ; *******************************************************************************************************
791+  53C2
792+  53C2              ; *******************************************************************************************************
793+  53C2              ; function processes animations during vblank period
794+  53C2              PROCESS_ANIMATIONS:
795+  53C2 3A C2 4F         LD A,(ANIMSPRNUM)
796+  53C5 B7               OR A
797+  53C6 C8               RET Z; no animations defined
798+  53C7 47               LD B,A
799+  53C8 DD 2A C3 4F      LD IX,(ANIMSPRPTR)
800+  53CC              .L1:
801+  53CC C5               PUSH BC
802+  53CD 06 00            LD B,0 ; normal mode, change on timer expiry only
803+  53CF CD DB 53         CALL PROCESS_SINGLE_ANIMATION
804+  53D2 11 08 00         LD DE,8
805+  53D5 DD 19            ADD IX,DE
806+  53D7 C1               POP BC
807+  53D8 10 F2            DJNZ .L1
808+  53DA C9               RET
809+  53DB              ; *******************************************************************************************************
810+  53DB
811+  53DB              ; *******************************************************************************************************
812+  53DB              ; processes single sprite animation
813+  53DB              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
814+  53DB              ; on timer expiry goes to next animation item
815+  53DB              ; input IX=sprite animation pointer
816+  53DB              ; input B=1 force mode, activate animation action regardless of expired timer
817+  53DB              PROCESS_SINGLE_ANIMATION:
818+  53DB DD 7E 06         LD A,(IX+6); active
819+  53DE B7               OR A
820+  53DF C8               RET Z ; inactive animation
821+  53E0              .INACTIVE_TOO:
822+  53E0 DD 6E 01         LD L,(IX+1)
823+  53E3 DD 66 02         LD H,(IX+2) ; HL=end time
824+  53E6 2B               DEC HL
825+  53E7 DD 75 01         LD (IX+1),L
826+  53EA DD 74 02         LD (IX+2),H
827+  53ED 7D               LD A,L
828+  53EE B4               OR H
829+  53EF 28 06            JR Z,.STEP
830+  53F1 05               DEC B
831+  53F2 04               INC B
832+  53F3 C8               RET Z ; not forced mode, return
833+  53F4 C3 3C 54         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
834+  53F7              .STEP:
835+  53F7 06 00            LD B,0; setup timer
836+  53F9 DD 34 03         INC (IX+3) ; current animation item
837+  53FC C3 3C 54         JP SETUP_ANIM_STEP
838+  53FF              ; *******************************************************************************************************
839+  53FF
840+  53FF              ; *******************************************************************************************************
841+  53FF              ; function will setup sprite animation after current item change
842+  53FF              ; input A=current animation definition
843+  53FF              ; input IX=pointer to sprite animation
844+  53FF              ; input B=1 skip timer setup
845+  53FF              ; output IY=pointer to animation item
846+  53FF              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
847+  53FF              ; basically sets new end time for current animation
848+  53FF              INIT_CURRENT_ANIMATION:
849+  53FF CD D7 4F         CALL GETnthANIMDEF
850+  5402 DD 7E 03         LD A,(IX+3) ; current animation item
851+  5405 BE               CP (HL) ; number of animation items in the animation definition
852+  5406 38 0A            JR C,.L3 ; last item not reached
853+  5408                  ; last item reached
854+  5408 DD 7E 05         LD A,(IX+5) ; cyclic flag
855+  540B B7               OR A
856+  540C 28 2C            JR Z,.ERROR ; non-cyclic animation
857+  540E                  ; cyclic animation, restart
858+  540E DD 36 03 00      LD (IX+3),0; current item
859+  5412              .L3:
860+  5412                  ; HL = animation definition
861+  5412 23               INC HL ; skip animation definition size field
862+  5413 16 00            LD D,0
863+  5415 DD 5E 03         LD E,(IX+3); current item
864+  5418 19               ADD HL,DE
865+  5419 4E               LD C,(HL) ; current animation item
866+  541A 0C               INC C
867+  541B 3A BC 4F         LD A,(ANIMITEMNUM)
868+  541E B9               CP C
869+  541F 38 19            JR C,.ERROR ; invalid animation item, stop animation
870+  5421 0D               DEC C
871+  5422 79               LD A,C
872+  5423 CD CE 4F         CALL GETnthANIMITEM
873+  5426 E5               PUSH HL
874+  5427 FD E1            POP IY ; IY=animation item
875+  5429 05               DEC B
876+  542A 28 0C            JR Z,.EXIT
877+  542C FD 5E 01         LD E,(IY+1)
878+  542F FD 56 02         LD D,(IY+2) ; duration
879+  5432 DD 73 01         LD (IX+1),E
880+  5435 DD 72 02         LD (IX+2),D
881+  5438              .EXIT:
882+  5438 AF               XOR A
883+  5439 C9               RET
884+  543A              .ERROR:
885+  543A 37               SCF
886+  543B C9               RET
887+  543C              ; *******************************************************************************************************
888+  543C
889+  543C              ; *******************************************************************************************************
890+  543C              ; function will display currect item and set up expiry time
891+  543C              ; it will also stop the animation if expired
892+  543C              ; sets sprite update flag if any changes in sprite data made
893+  543C              ; input IX=current sprite animation
894+  543C              ; input B=1 skip timer setup
895+  543C              SETUP_ANIM_STEP:
896+  543C DD 4E 04         LD C,(IX+4) ; animation definition ID
897+  543F 0C               INC C
898+  5440 3A BF 4F         LD A,(ANIMDEFNUM)
899+  5443 B9               CP C
900+  5444 30 05            JR NC,.L2
901+  5446                  ; given animation item is outside of bounds, deactivate animation
902+  5446              .STOPANIM:
903+  5446 DD 36 06 00      LD (IX+6),0
904+  544A C9               RET
905+  544B              .L2:
906+  544B 0D               DEC C
907+  544C 79               LD A,C
908+  544D CD FF 53         CALL INIT_CURRENT_ANIMATION
909+  5450 38 F4            JR C, .STOPANIM
910+  5452 FD 7E 00         LD A,(IY) ; type of animation item
911+  5455 B7               OR A
912+  5456 28 38            JR Z,.L4 ; change pattern and/or color
913+  5458              .PAT:
914+  5458                  ; change pattern definition
915+  5458                  ; check if sprite or character
916+  5458 DD 7E 07         LD A,(IX+7)
917+  545B B7               OR A
918+  545C 20 4C            JR NZ,.CHAR
919+  545E DD 7E 00         LD A,(IX) ; sprite number
920+  5461 CD 7C 4D         CALL GETnthSPRATTR
921+  5464 23          > INC HL ; skip y and x
921+  5465 23          > INC HL
921+  5466 23          > INC HL
921+  5467 23          > INC HL
922+  5468 7E               LD A,(HL); current pattern
923+  5469 26 00            LD H,0
924+  546B 6F               LD L,A
925+  546C 3A E0 F3         LD A,(REG1SAV)
926+  546F E6 02            AND 2
927+  5471 20 07            JR NZ,.L6
928+  5473                  ; 8x8 sprite
929+  5473 CD 20 61         CALL HLx8
930+  5476 06 08            LD B,8
931+  5478 18 05            JR .L5
932+  547A              .L6:
933+  547A CD 1E 61         CALL HLx32
934+  547D 06 20            LD B,32
935+  547F              .L5:
936+  547F ED 5B 26 F9      LD DE,(PATBAS)
937+  5483              .L7:
938+  5483 19               ADD HL,DE
939+  5484 CD 0B 61         CALL SETWRT_LOCAL
940+  5487 FD 6E 03         LD L,(IY+3)
941+  548A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
942+  548D C3 16 61         JP BBYTECOPY
943+  5490              .L4:
944+  5490                  ; change pattern and color in sprite attributes table
945+  5490 DD 7E 00         LD A,(IX) ; sprite number
946+  5493 CD 7C 4D         CALL GETnthSPRATTR
947+  5496 23          > INC HL ; skip y and x
947+  5497 23          > INC HL
947+  5498 23          > INC HL
947+  5499 23          > INC HL
948+  549A FD 7E 03         LD A,(IY+3) ; new pattern
949+  549D 77               LD (HL),A
950+  549E 23          > INC HL
950+  549F 23          > INC HL
951+  54A0 FD 7E 04         LD A,(IY+4) ; new color
952+  54A3 77               LD (HL),A
953+  54A4 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
954+  54A7 36 01            LD (HL),1
955+  54A9 C9               RET
956+  54AA              .CHAR:
957+  54AA DD 6E 00         LD L,(IX)
958+  54AD 3D               DEC A
959+  54AE 67               LD H,A
960+  54AF CD 20 61         CALL HLx8
961+  54B2 ED 5B 24 F9      LD DE,(CGPBAS)
962+  54B6 06 08            LD B,8
963+  54B8 18 C9            JR .L7
964+  54BA              ; *******************************************************************************************************
965+  54BA
# file closed: asm\ANIMATION.asm
124   54BA               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
  1+  54BA              ; Sprite Group Animate and Move
  2+  54BA
  3+  54BA              ; *******************************************************************************************************
  4+  54BA              ; function to handle CALL SGAM basic extension
  5+  54BA              ; sets position of a group of sprites as described in SPRGRPMOV
  6+  54BA              ; and manually animate a list of animations
  7+  54BA              ; _SGAM ( INT x,
  8+  54BA              ;	      INT y,
  9+  54BA              ;		  BYTE count,
 10+  54BA              ;		  INT[2][count] data_ptr,
 11+  54BA              ;         BYTE item_number,
 12+  54BA              ;         INT[] sprite_animations )
 13+  54BA              ; will put ram in page 0 also, page 1 is already there
 14+  54BA              SGAM:
 15+  54BA 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
 16+  54BD B7           	OR A
 17+  54BE CA 4F 62     	JP Z,ILLEGAL_FUNCTION
 18+  54C1              	; opening (
 19+  54C1 CD 31 62     	CALL CHKCHAR
 20+  54C4 28           	DB '('
 21+  54C5              	; get x
 22+  54C5 DD 21 2F 54  	LD IX, FRMQNT
 23+  54C9 CD 59 01     	CALL CALBAS
 24+  54CC ED 53 60 5F  	LD (BLIT_STRUCT),DE
 25+  54D0              	; comma
 26+  54D0 CD 31 62     	CALL CHKCHAR
 27+  54D3 2C           	DB ','
 28+  54D4              	; get y
 29+  54D4 DD 21 2F 54  	LD IX, FRMQNT
 30+  54D8 CD 59 01     	CALL CALBAS
 31+  54DB ED 53 62 5F  	LD (BLIT_STRUCT+2),DE
 32+  54DF              	; comma
 33+  54DF CD 31 62     	CALL CHKCHAR
 34+  54E2 2C           	DB ','
 35+  54E3              	; get count
 36+  54E3 DD 21 1C 52  	LD IX, GETBYT
 37+  54E7 CD 59 01     	CALL CALBAS
 38+  54EA B7               OR A
 39+  54EB CA 47 62         JP Z,SUBSCRIPT_OUT_OF_RANGE
 40+  54EE 32 64 5F     	LD (BLIT_STRUCT+4),A
 41+  54F1              	; comma
 42+  54F1 CD 31 62     	CALL CHKCHAR
 43+  54F4 2C           	DB ','
 44+  54F5              	; get sprite group definition array data pointer
 45+  54F5 3A 64 5F         LD A,(BLIT_STRUCT+4)
 46+  54F8 5F           	LD E,A
 47+  54F9 16 03        	LD D,3
 48+  54FB 3E 02        	LD A,2
 49+  54FD 47           	LD B,A
 50+  54FE CD 5C 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
 51+  5501 ED 43 65 5F  	LD (BLIT_STRUCT+5),BC
 52+  5505              	; comma
 53+  5505 CD 31 62     	CALL CHKCHAR
 54+  5508 2C           	DB ','
 55+  5509              	; get sprite animation array size
 56+  5509 DD 21 1C 52  	LD IX,GETBYT
 57+  550D CD 59 01     	CALL CALBAS
 58+  5510 32 67 5F         LD (BLIT_STRUCT+7),A
 59+  5513 B7               OR A
 60+  5514 CA 47 62         JP Z,SUBSCRIPT_OUT_OF_RANGE
 61+  5517              	; comma
 62+  5517 CD 31 62     	CALL CHKCHAR
 63+  551A 2C           	DB ','
 64+  551B                  ; get array pointer
 65+  551B 3A 67 5F         LD A,(BLIT_STRUCT+7)
 66+  551E 57               LD D,A
 67+  551F 3E 02            LD A,2
 68+  5521 06 01            LD B,1
 69+  5523 CD 5C 62         CALL GET_BASIC_ARRAY_DATA_POINTER
 70+  5526 ED 43 68 5F      LD (BLIT_STRUCT+8),BC
 71+  552A              	; ending )
 72+  552A CD 31 62     	CALL CHKCHAR
 73+  552D 29           	DB ')'
 74+  552E
 75+  552E E5               PUSH HL
 76+  552F F3               DI
 77+  5530
 78+  5530              	; enable page 0
 79+  5530 FD 21 37 55  	LD IY, .RET
 80+  5534 C3 E4 61     	JP ENABLE_PAGE0
 81+  5537              .RET:
 82+  5537 D9               EXX
 83+  5538 ED 5B 60 5F      LD DE,(BLIT_STRUCT) ; initial x
 84+  553C ED 4B 62 5F      LD BC,(BLIT_STRUCT+2) ; initial y
 85+  5540 D9               EXX
 86+  5541 2A 65 5F         LD HL,(BLIT_STRUCT+5) ; pointer to data
 87+  5544 3A 64 5F         LD A,(BLIT_STRUCT+4) ; number of entries
 88+  5547 47               LD B,A
 89+  5548 CD AA 4F         CALL SPRGRPMOV.UPDATE_LOC
 90+  554B
 91+  554B 21 6D 55         LD HL,.STEP
 92+  554E 22 A9 53         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
 93+  5551 3A 67 5F         LD A,(BLIT_STRUCT+7) ; anim number
 94+  5554 47               LD B,A
 95+  5555 ED 5B 68 5F      LD DE,(BLIT_STRUCT+8) ; anim list
 96+  5559              .L1:
 97+  5559 C5               PUSH BC
 98+  555A 1A               LD A,(DE)
 99+  555B 13          > INC DE
 99+  555C 13          > INC DE
100+  555D D5               PUSH DE
101+  555E CD 97 53         CALL ANIMSTARTSTOP_COMMON.SETVALUE
102+  5561 D1               POP DE
103+  5562 C1               POP BC
104+  5563 10 F4            DJNZ .L1
105+  5565
106+  5565 D1               POP DE
107+  5566 C1               POP BC
108+  5567 CD 5B 61         CALL RESTORE_PAGE_INFO
109+  556A FB               EI
110+  556B E1               POP HL
111+  556C C9               RET
112+  556D              .STEP:
113+  556D 06 01            LD B,1
114+  556F C3 E0 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
115+  5572              ; *******************************************************************************************************
116+  5572
# file closed: asm\SGAM.asm
125   5572               ENDIF
126   5572
127   5572               IF (RAM_CMDS == 1)
128   5572               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  5572              ; *******************************************************************************************************
  2+  5572              ; function to handle CALL MEMCPY basic extension
  3+  5572              ; _MEMCPY ( INT source,
  4+  5572              ;			INT destination,
  5+  5572              ;			INT count,
  6+  5572              ; will put ram in page 0 also, page 1 is already there
  7+  5572              MEMCPY:
  8+  5572              	; opening (
  9+  5572 CD 31 62     	CALL CHKCHAR
 10+  5575 28           	DB '('
 11+  5576              	; get source address
 12+  5576 DD 21 2F 54  	LD IX, FRMQNT
 13+  557A CD 59 01     	CALL CALBAS
 14+  557D D5           	PUSH DE
 15+  557E              	; comma
 16+  557E CD 31 62     	CALL CHKCHAR
 17+  5581 2C           	DB ','
 18+  5582              	; get destination address
 19+  5582 DD 21 2F 54  	LD IX, FRMQNT
 20+  5586 CD 59 01     	CALL CALBAS
 21+  5589 D5           	PUSH DE
 22+  558A              	; comma
 23+  558A CD 31 62     	CALL CHKCHAR
 24+  558D 2C           	DB ','
 25+  558E              	; get length
 26+  558E DD 21 2F 54  	LD IX, FRMQNT
 27+  5592 CD 59 01     	CALL CALBAS
 28+  5595 D5           	PUSH DE
 29+  5596              	; ending )
 30+  5596 CD 31 62     	CALL CHKCHAR
 31+  5599 29           	DB ')'
 32+  559A
 33+  559A              	; save position
 34+  559A E5           	PUSH HL
 35+  559B DD E1        	POP IX
 36+  559D
 37+  559D C1           	POP BC ; count
 38+  559E D1           	POP DE ; destination
 39+  559F E1           	POP HL ; source
 40+  55A0 D9           	EXX
 41+  55A1              	; enable page 0
 42+  55A1 FD 21 A8 55  	LD IY, .RET
 43+  55A5 C3 E4 61     	JP ENABLE_PAGE0
 44+  55A8              .RET:
 45+  55A8 FB           	EI
 46+  55A9 D9           	EXX
 47+  55AA ED B0        	LDIR
 48+  55AC D1               POP DE
 49+  55AD C1               POP BC
 50+  55AE CD 5B 61         CALL RESTORE_PAGE_INFO
 51+  55B1 DD E5        	PUSH IX
 52+  55B3 E1           	POP HL
 53+  55B4 C9           	RET
 54+  55B5              ; *******************************************************************************************************
 55+  55B5
 56+  55B5              ; *******************************************************************************************************
 57+  55B5              ; function to handle CALL FILRAM basic extension
 58+  55B5              ; FILRAM ( INT start address,
 59+  55B5              ;		   INT count,
 60+  55B5              ;		   BYTE value,
 61+  55B5              ; will put ram in page 0 also, page 1 is already there
 62+  55B5              FILRAM:
 63+  55B5              	; opening (
 64+  55B5 CD 31 62     	CALL CHKCHAR
 65+  55B8 28           	DB '('
 66+  55B9              	; get start address
 67+  55B9 DD 21 2F 54  	LD IX, FRMQNT
 68+  55BD CD 59 01     	CALL CALBAS
 69+  55C0 D5           	PUSH DE
 70+  55C1              	; comma
 71+  55C1 CD 31 62     	CALL CHKCHAR
 72+  55C4 2C           	DB ','
 73+  55C5              	; get count
 74+  55C5 DD 21 2F 54  	LD IX, FRMQNT
 75+  55C9 CD 59 01     	CALL CALBAS
 76+  55CC D5           	PUSH DE
 77+  55CD              	; comma
 78+  55CD CD 31 62     	CALL CHKCHAR
 79+  55D0 2C           	DB ','
 80+  55D1              	; get value
 81+  55D1 DD 21 1C 52  	LD IX, GETBYT
 82+  55D5 CD 59 01     	CALL CALBAS
 83+  55D8 F5           	PUSH AF
 84+  55D9              	; ending )
 85+  55D9 CD 31 62     	CALL CHKCHAR
 86+  55DC 29           	DB ')'
 87+  55DD
 88+  55DD              	; save position
 89+  55DD E5           	PUSH HL
 90+  55DE DD E1        	POP IX
 91+  55E0
 92+  55E0 D1           	POP DE ; actually AF
 93+  55E1 C1           	POP BC ; count
 94+  55E2 E1           	POP HL ; start address
 95+  55E3 78           	LD A, B
 96+  55E4 B7           	OR A
 97+  55E5 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  55E7 B1           	OR C
 99+  55E8 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  55EA 79           	LD A, C
101+  55EB 3D           	DEC A
102+  55EC 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  55EE              	; one byte to fill
104+  55EE 72           	LD (HL), D
105+  55EF 18 12        	JR .EXIT
106+  55F1              .L1:
107+  55F1 D9           	EXX
108+  55F2              	; enable page 0
109+  55F2 FD 21 F9 55  	LD IY, .RET
110+  55F6 C3 E4 61     	JP ENABLE_PAGE0
111+  55F9              .RET:
112+  55F9 FB           	EI
113+  55FA D9           	EXX
114+  55FB CD 07 56     	CALL .FILLVALUE
115+  55FE D1               POP DE
116+  55FF C1               POP BC
117+  5600 CD 5B 61         CALL RESTORE_PAGE_INFO
118+  5603              .EXIT:
119+  5603 DD E5        	PUSH IX
120+  5605 E1           	POP HL
121+  5606 C9           	RET
122+  5607
123+  5607              .FILLVALUE:
124+  5607 72               LD (HL), D
125+  5608 54               LD D, H
126+  5609 5D               LD E, L
127+  560A 13               INC DE
128+  560B 0B               DEC BC
129+  560C ED B0            LDIR
130+  560E C9               RET
131+  560F              ; *******************************************************************************************************
132+  560F
# file closed: asm\MEMORY.asm
129   560F               ENDIF
130   560F
131   560F               IF (SOUND_CMDS == 1)
132   560F               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  560F              MUSIC_INIT_STATUS:
  2+  560F 00            DB 0
  3+  5610              SFX_INIT_STATUS:
  4+  5610 00            DB 0
  5+  5611              SOUND_ENABLED:
  6+  5611 00            DB 0
  7+  5612
  8+  5612              ; *******************************************************************************************************
  9+  5612              ; function to handle CALL SNDPLYINIT basic extension
 10+  5612              ; initializes sound player
 11+  5612              ; _SNDPLYINIT ( INT music_offset,
 12+  5612              ;				INT sfx_offset, can be -1 if no SFX
 13+  5612              ; will put ram in page 0 also, page 1 is already there
 14+  5612              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  5612              SNDPLYINIT:
 16+  5612              	; opening (
 17+  5612 CD 31 62     	CALL CHKCHAR
 18+  5615 28           	DB '('
 19+  5616              	; get music address
 20+  5616 DD 21 2F 54  	LD IX, FRMQNT
 21+  561A CD 59 01     	CALL CALBAS
 22+  561D D5           	PUSH DE
 23+  561E              	; comma
 24+  561E CD 31 62     	CALL CHKCHAR
 25+  5621 2C           	DB ','
 26+  5622              	; get sfx address
 27+  5622 DD 21 2F 54  	LD IX, FRMQNT
 28+  5626 CD 59 01     	CALL CALBAS
 29+  5629 D5           	PUSH DE
 30+  562A              	; ending )
 31+  562A CD 31 62     	CALL CHKCHAR
 32+  562D 29           	DB ')'
 33+  562E
 34+  562E                  ; save position in BASIC text
 35+  562E 44           	LD B, H
 36+  562F 4D           	LD C, L
 37+  5630
 38+  5630              	; pop LDIR parameters and store away for later
 39+  5630 D1           	POP DE ; sfx address
 40+  5631 E1           	POP HL ; music address
 41+  5632 C5           	PUSH BC ; basic text location
 42+  5633 D9           	EXX
 43+  5634 FD 21 3B 56  	LD IY, .RET
 44+  5638 C3 E4 61     	JP ENABLE_PAGE0
 45+  563B              .RET:
 46+  563B D9           	EXX
 47+  563C
 48+  563C D5           	PUSH DE
 49+  563D AF           	XOR A
 50+  563E              	; HL = music location
 51+  563E CD 62 41     	CALL PLY_AKG_INIT
 52+  5641 3E 01        	LD A, 1
 53+  5643 32 0F 56     	LD (MUSIC_INIT_STATUS), A
 54+  5646
 55+  5646 E1           	POP HL ; SFX
 56+  5647              	; check if SFX address -1
 57+  5647 23           	INC HL
 58+  5648 7D           	LD A, L
 59+  5649 B4           	OR H
 60+  564A 28 09        	JR Z,.L1
 61+  564C 2B           	DEC HL
 62+  564D CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  5650 3E 01        	LD A, 1
 64+  5652 32 10 56     	LD (SFX_INIT_STATUS), A
 65+  5655              .L1:
 66+  5655 D1               POP DE
 67+  5656 C1               POP BC
 68+  5657 CD 5B 61         CALL RESTORE_PAGE_INFO
 69+  565A
 70+  565A E1           	POP HL
 71+  565B C9           	RET
 72+  565C              ; *******************************************************************************************************
 73+  565C
 74+  565C              ; *******************************************************************************************************
 75+  565C              ; function to handle CALL SNDPLYON basic extension
 76+  565C              ; enables sound player
 77+  565C              ; _SNDPLYON
 78+  565C              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  565C              ; if not throws out of data error
 80+  565C              SNDPLYON:
 81+  565C 3A 0F 56     	LD A, (MUSIC_INIT_STATUS)
 82+  565F B7           	OR A
 83+  5660 20 05        	JR NZ, .L1
 84+  5662              	; player not initialized, throw error
 85+  5662 1E 04        	LD E, 04 ; Out of DATA
 86+  5664 C3 55 62     	JP THROW_ERROR
 87+  5667              .L1:
 88+  5667 32 11 56     	LD (SOUND_ENABLED), A
 89+  566A              	; disable key click
 90+  566A AF           	XOR A
 91+  566B 32 DB F3     	LD (CLIKSW), A
 92+  566E C9           	RET
 93+  566F              ; *******************************************************************************************************
 94+  566F
 95+  566F              ; *******************************************************************************************************
 96+  566F              ; function to handle CALL SNDPLYOFF basic extension
 97+  566F              ; disables sound player
 98+  566F              ; _SNDPLYOFF
 99+  566F              ; sets SOUND_ENABLED variable to 0
100+  566F              ; calls AKG to stop music and SFX on all channels if initialized
101+  566F              SNDPLYOFF:
102+  566F 3A 11 56     	LD A, (SOUND_ENABLED)
103+  5672 B7           	OR A
104+  5673 C8           	RET Z ; already stopped
105+  5674 AF           	XOR A
106+  5675 32 11 56     	LD (SOUND_ENABLED), A
107+  5678 E5           	PUSH HL
108+  5679 CD 21 42     	CALL PLY_AKG_STOP
109+  567C 3A 10 56     	LD A, (SFX_INIT_STATUS)
110+  567F B7           	OR A
111+  5680 28 0E        	JR Z, .EXIT ; SFX not in use
112+  5682 AF           	XOR A
113+  5683 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  5686 3E 01        	LD A, 1
115+  5688 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  568B 3E 02        	LD A, 2
117+  568D CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  5690              .EXIT:
119+  5690 E1           	POP HL
120+  5691 C9           	RET
121+  5692              ; *******************************************************************************************************
122+  5692
123+  5692              ; *******************************************************************************************************
124+  5692              ; function to handle CALL SNDSFX basic extension
125+  5692              ; plays a sound effect
126+  5692              ; _SNDSFX ( BYTE sfx_number, >0
127+  5692              ;			BYTE channel, = 0,1 or 2
128+  5692              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  5692              ; will put ram in page 0 also, page 1 is already there
130+  5692              ; if sound off throws illegal function call
131+  5692              ; if sfx not initialized, throws out of data
132+  5692              SNDSFX:
133+  5692              	; opening (
134+  5692 CD 31 62     	CALL CHKCHAR
135+  5695 28           	DB '('
136+  5696              	; get sfx_number
137+  5696 DD 21 1C 52  	LD IX, GETBYT
138+  569A CD 59 01     	CALL CALBAS
139+  569D D5           	PUSH DE
140+  569E              	; comma
141+  569E CD 31 62     	CALL CHKCHAR
142+  56A1 2C           	DB ','
143+  56A2              	; get sfx address
144+  56A2 DD 21 1C 52  	LD IX, GETBYT
145+  56A6 CD 59 01     	CALL CALBAS
146+  56A9 D5           	PUSH DE
147+  56AA              	; comma
148+  56AA CD 31 62     	CALL CHKCHAR
149+  56AD 2C           	DB ','
150+  56AE              	; get inverted volume
151+  56AE DD 21 1C 52  	LD IX, GETBYT
152+  56B2 CD 59 01     	CALL CALBAS
153+  56B5 D5           	PUSH DE
154+  56B6              	; ending )
155+  56B6 CD 31 62     	CALL CHKCHAR
156+  56B9 29           	DB ')'
157+  56BA
158+  56BA 3A 11 56     	LD A, (SOUND_ENABLED)
159+  56BD B7           	OR A
160+  56BE 20 05        	JR NZ, .L1
161+  56C0              	; sound disabled, throw illegal function call
162+  56C0 1E 05        	LD E, 5
163+  56C2 C3 55 62     	JP THROW_ERROR
164+  56C5              .L1:
165+  56C5 3A 10 56     	LD A, (SFX_INIT_STATUS)
166+  56C8 B7           	OR A
167+  56C9 20 05        	JR NZ, .L2
168+  56CB              	; sfx data not initialized, throw out of data
169+  56CB 1E 04        	LD E, 4
170+  56CD C3 55 62     	JP THROW_ERROR
171+  56D0              .L2:
172+  56D0              	; pop  parameters and store away for later
173+  56D0 D1           	POP DE ; inverted volume
174+  56D1 43           	LD B, E
175+  56D2 D1           	POP DE ; channel
176+  56D3 4B           	LD C, E
177+  56D4 D1           	POP DE
178+  56D5 7B           	LD A, E
179+  56D6 08           	EX AF, AF'
180+  56D7 E5           	PUSH HL ; basic text location
181+  56D8 D9           	EXX
182+  56D9 FD 21 E0 56  	LD IY, .RET
183+  56DD C3 E4 61     	JP ENABLE_PAGE0
184+  56E0              .RET:
185+  56E0 D9           	EXX
186+  56E1 08           	EX AF, AF'
187+  56E2 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  56E5
189+  56E5 D1               POP DE
190+  56E6 C1               POP BC
191+  56E7 CD 5B 61         CALL RESTORE_PAGE_INFO
192+  56EA
193+  56EA E1           	POP HL
194+  56EB C9           	RET
195+  56EC              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
133   56EC               ENDIF
134   56EC
135   56EC               IF (VRAM_CMDS == 1)
136   56EC               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  56EC              ; *******************************************************************************************************
  2+  56EC              ; function to handle CALL FILVRM basic extension
  3+  56EC              ; FILVRM ( INT offset,
  4+  56EC              ;		   INT count,
  5+  56EC              ;		   BYTE value,
  6+  56EC              ;		   BYTE wait_vsync) >0 = true
  7+  56EC              ; wait_vsync will issue HALT before copying
  8+  56EC              FILVRM:
  9+  56EC              	; opening (
 10+  56EC CD 31 62     	CALL CHKCHAR
 11+  56EF 28           	DB '('
 12+  56F0              	; get offset address
 13+  56F0 DD 21 2F 54  	LD IX, FRMQNT
 14+  56F4 CD 59 01     	CALL CALBAS
 15+  56F7 D5           	PUSH DE
 16+  56F8              	; comma
 17+  56F8 CD 31 62     	CALL CHKCHAR
 18+  56FB 2C           	DB ','
 19+  56FC              	; get count
 20+  56FC DD 21 2F 54  	LD IX, FRMQNT
 21+  5700 CD 59 01     	CALL CALBAS
 22+  5703 D5           	PUSH DE
 23+  5704              	; comma
 24+  5704 CD 31 62     	CALL CHKCHAR
 25+  5707 2C           	DB ','
 26+  5708              	; get value
 27+  5708 DD 21 1C 52  	LD IX, GETBYT
 28+  570C CD 59 01     	CALL CALBAS
 29+  570F F5           	PUSH AF
 30+  5710              	; comma
 31+  5710 CD 31 62     	CALL CHKCHAR
 32+  5713 2C           	DB ','
 33+  5714              	; get vsync wait
 34+  5714 DD 21 1C 52  	LD IX, GETBYT
 35+  5718 CD 59 01     	CALL CALBAS
 36+  571B F5           	PUSH AF
 37+  571C              	; ending )
 38+  571C CD 31 62     	CALL CHKCHAR
 39+  571F 29           	DB ')'
 40+  5720
 41+  5720 FB               EI
 42+  5721              	; save position
 43+  5721 E5           	PUSH HL
 44+  5722 DD E1        	POP IX
 45+  5724
 46+  5724              	; syntax ok
 47+  5724              	; wait for vsync if needed
 48+  5724 F1           	POP AF
 49+  5725 B7           	OR A
 50+  5726 28 01        	JR Z, .L1
 51+  5728 76           	HALT
 52+  5729
 53+  5729              .L1:
 54+  5729 3E 01        	LD A,1
 55+  572B 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  572E F1               POP AF ; value
 57+  572F C1               POP BC ; count
 58+  5730 E1               POP HL ; offset
 59+  5731 CD 56 00         CALL BIOS_FILVRM
 60+  5734 AF           	XOR A
 61+  5735 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  5738
 63+  5738              .L3:
 64+  5738 DD E5        	PUSH IX
 65+  573A E1           	POP HL
 66+  573B C9           	RET
 67+  573C              ; *******************************************************************************************************
 68+  573C
 69+  573C              ; *******************************************************************************************************
 70+  573C              ; function to handle CALL MEMVRM basic extension
 71+  573C              ; copies from RAM to VRAM
 72+  573C              ; _MEMVRM ( INT source,
 73+  573C              ;			INT destination,
 74+  573C              ;			INT count,
 75+  573C              ;			BYTE wait_vsync) >0 = true
 76+  573C              ; will put ram in page 0 also, page 1 is already there
 77+  573C              ; wait_vsync will issue HALT before copying
 78+  573C              MEMVRM:
 79+  573C              	; opening (
 80+  573C CD 31 62     	CALL CHKCHAR
 81+  573F 28           	DB '('
 82+  5740              	; get source address
 83+  5740 DD 21 2F 54  	LD IX, FRMQNT
 84+  5744 CD 59 01     	CALL CALBAS
 85+  5747 D5           	PUSH DE
 86+  5748              	; comma
 87+  5748 CD 31 62     	CALL CHKCHAR
 88+  574B 2C           	DB ','
 89+  574C              	; get destination address
 90+  574C DD 21 2F 54  	LD IX, FRMQNT
 91+  5750 CD 59 01     	CALL CALBAS
 92+  5753 D5           	PUSH DE
 93+  5754              	; comma
 94+  5754 CD 31 62     	CALL CHKCHAR
 95+  5757 2C           	DB ','
 96+  5758              	; get length
 97+  5758 DD 21 2F 54  	LD IX, FRMQNT
 98+  575C CD 59 01     	CALL CALBAS
 99+  575F D5           	PUSH DE
100+  5760              	; comma
101+  5760 CD 31 62     	CALL CHKCHAR
102+  5763 2C           	DB ','
103+  5764              	; get vsync wait
104+  5764 DD 21 1C 52  	LD IX, GETBYT
105+  5768 CD 59 01     	CALL CALBAS
106+  576B F5           	PUSH AF
107+  576C              	; ending )
108+  576C CD 31 62     	CALL CHKCHAR
109+  576F 29           	DB ')'
110+  5770
111+  5770                  ; save position in BASIC text
112+  5770 E5           	PUSH HL
113+  5771 DD E1        	POP IX
114+  5773
115+  5773 F1           	POP AF ; wait vsync
116+  5774 B7           	OR A
117+  5775 28 03        	JR Z, .L1
118+  5777 FB               EI
119+  5778 76           	HALT
120+  5779 F3           	DI
121+  577A              .L1:
122+  577A              	; pop LDIR parameters and store away for later
123+  577A C1           	POP BC ; count
124+  577B D1           	POP DE ; vram destination
125+  577C E1           	POP HL ; ram source
126+  577D D9           	EXX
127+  577E FD 21 85 57   	LD IY, .RET
128+  5782 C3 E4 61     	JP ENABLE_PAGE0
129+  5785              .RET:
130+  5785 FB           	EI
131+  5786 D9           	EXX
132+  5787 3E 01        	LD A,1
133+  5789 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  578C CD 9C 57     	CALL .LDIRVM
135+  578F AF           	XOR A
136+  5790 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  5793 D1               POP DE
138+  5794 C1               POP BC
139+  5795 CD 5B 61         CALL RESTORE_PAGE_INFO
140+  5798 DD E5        	PUSH IX
141+  579A E1           	POP HL
142+  579B C9           	RET
143+  579C
144+  579C              .LDIRVM:
145+  579C EB           	EX DE, HL
146+  579D F3           	DI
147+  579E CD 0B 61     	CALL SETWRT_LOCAL
148+  57A1 FB           	EI
149+  57A2 EB           	EX DE, HL
150+  57A3 78           	LD A, B
151+  57A4 B7           	OR A
152+  57A5 28 0D        	JR Z, .L3
153+  57A7 C5           	PUSH BC
154+  57A8 0E 98        	LD C, #98
155+  57AA              .L2:
156+  57AA 50           	LD D, B
157+  57AB 06 00        	LD B, 0
158+  57AD CD 18 61     	CALL BBYTECOPY_NO_C
159+  57B0 42           	LD B, D
160+  57B1 10 F7        	DJNZ .L2
161+  57B3 C1           	POP BC
162+  57B4              .L3:
163+  57B4 79           	LD A, C
164+  57B5 B7           	OR A
165+  57B6 C8           	RET Z
166+  57B7 41           	LD B, C
167+  57B8 C3 16 61     	JP BBYTECOPY
168+  57BB              ; *******************************************************************************************************
169+  57BB
170+  57BB              ; *******************************************************************************************************
171+  57BB              ; function to handle CALL VRMMEM basic extension
172+  57BB              ; copies from RAM to VRAM
173+  57BB              ; _VRMMEM ( INT source,
174+  57BB              ;			INT destination,
175+  57BB              ;			INT count
176+  57BB              ; will put ram in page 0 also, page 1 is already there
177+  57BB              VRMMEM:
178+  57BB              	; opening (
179+  57BB CD 31 62     	CALL CHKCHAR
180+  57BE 28           	DB '('
181+  57BF              	; get source address
182+  57BF DD 21 2F 54  	LD IX, FRMQNT
183+  57C3 CD 59 01     	CALL CALBAS
184+  57C6 D5           	PUSH DE
185+  57C7              	; comma
186+  57C7 CD 31 62     	CALL CHKCHAR
187+  57CA 2C           	DB ','
188+  57CB              	; get destination address
189+  57CB DD 21 2F 54  	LD IX, FRMQNT
190+  57CF CD 59 01     	CALL CALBAS
191+  57D2 D5           	PUSH DE
192+  57D3              	; comma
193+  57D3 CD 31 62     	CALL CHKCHAR
194+  57D6 2C           	DB ','
195+  57D7              	; get length
196+  57D7 DD 21 2F 54  	LD IX, FRMQNT
197+  57DB CD 59 01     	CALL CALBAS
198+  57DE D5           	PUSH DE
199+  57DF              	; ending )
200+  57DF CD 31 62     	CALL CHKCHAR
201+  57E2 29           	DB ')'
202+  57E3
203+  57E3                  ; save position in BASIC text
204+  57E3 E5           	PUSH HL
205+  57E4 DD E1        	POP IX
206+  57E6
207+  57E6 C1           	POP BC ; count
208+  57E7 D1           	POP DE ; destination
209+  57E8 E1           	POP HL ; source
210+  57E9 D9           	EXX
211+  57EA FD 21 F1 57  	LD IY, .RET
212+  57EE C3 E4 61     	JP ENABLE_PAGE0
213+  57F1              .RET:
214+  57F1 FB           	EI
215+  57F2 D9           	EXX
216+  57F3 3E 01        	LD A,1
217+  57F5 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  57F8 CD 08 58     	CALL .LDIRMV
219+  57FB AF           	XOR A
220+  57FC 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  57FF D1               POP DE
222+  5800 C1               POP BC
223+  5801 CD 5B 61         CALL RESTORE_PAGE_INFO
224+  5804 DD E5        	PUSH IX
225+  5806 E1           	POP HL
226+  5807 C9           	RET
227+  5808
228+  5808              .LDIRMV:
229+  5808              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  5808 7D           	LD	A, L
231+  5809 F3           	DI
232+  580A D3 99        	OUT	(099H), A
233+  580C 7C           	LD	A, H
234+  580D E6 3F        	AND	03FH
235+  580F D3 99        	OUT	(099H), A
236+  5811 FB           	EI
237+  5812              	;EX (SP), HL
238+  5812              	;EX (SP), HL
239+  5812              	;NOP
240+  5812              	;NOP
241+  5812              .L4:
242+  5812 DB 98            IN A, (#98)
243+  5814 12           	LD (DE), A
244+  5815 13               INC DE
245+  5816 0B               DEC BC
246+  5817 79               LD A, C
247+  5818 B0               OR B
248+  5819 20 F7            JR NZ, .L4
249+  581B C9               RET
250+  581C              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
137   581C               ENDIF
138   581C
139   581C               IF (GENCAL_CMD == 1)
140   581C               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  581C              ; *******************************************************************************************************
  2+  581C              ; function to handle CALL GENCAL basic extension
  3+  581C              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  581C              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  581C              ; output values of registers will also be stored at reg_list_ptr
  6+  581C              GENCAL_VAR_SP:
  7+  581C 00 00            DW 0
  8+  581E              GENCAL_VAR_SP2:
  9+  581E 00 00            DW 0
 10+  5820              GENCAL:
 11+  5820              	; opening (
 12+  5820 CD 31 62     	CALL CHKCHAR
 13+  5823 28           	DB '('
 14+  5824              	; get function address
 15+  5824 DD 21 2F 54  	LD IX, FRMQNT
 16+  5828 CD 59 01     	CALL CALBAS
 17+  582B D5           	PUSH DE
 18+  582C              	; comma
 19+  582C CD 31 62     	CALL CHKCHAR
 20+  582F 2C           	DB ','
 21+  5830              	; get pointer to register list
 22+  5830 3E 02            LD A,2
 23+  5832 06 01            LD B,1
 24+  5834 11 00 05         LD DE,#0500
 25+  5837 CD 5C 62         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  583A C5           	PUSH BC
 27+  583B              	; ending )
 28+  583B CD 31 62     	CALL CHKCHAR
 29+  583E 29           	DB ')'
 30+  583F
 31+  583F              	; save BASIC token position
 32+  583F E5           	PUSH HL
 33+  5840 D9               EXX
 34+  5841 E1           	POP HL ; HL'=next basic token
 35+  5842 D9               EXX
 36+  5843
 37+  5843 E1               POP HL ; get pointer to register values
 38+  5844 F3           	DI
 39+  5845 ED 73 1C 58      LD (GENCAL_VAR_SP), SP
 40+  5849 F9               LD SP, HL
 41+  584A F1               POP AF
 42+  584B C1               POP BC
 43+  584C D1               POP DE
 44+  584D E1               POP HL
 45+  584E DD E1            POP IX
 46+  5850 FD E1            POP IY
 47+  5852 D9               EXX
 48+  5853 ED 73 1E 58      LD (GENCAL_VAR_SP2), SP
 49+  5857 ED 7B 1C 58      LD SP, (GENCAL_VAR_SP)
 50+  585B FB               EI
 51+  585C D1               POP DE ; get function to call
 52+  585D E5               PUSH HL
 53+  585E CD 79 58         CALL .EXXDECALL
 54+  5861 F3               DI
 55+  5862 ED 73 1C 58      LD (GENCAL_VAR_SP), SP
 56+  5866 ED 7B 1E 58      LD SP, (GENCAL_VAR_SP2)
 57+  586A FD E5            PUSH IY
 58+  586C DD E5            PUSH IX
 59+  586E E5               PUSH HL
 60+  586F D5               PUSH DE
 61+  5870 C5               PUSH BC
 62+  5871 F5               PUSH AF
 63+  5872 ED 7B 1C 58      LD SP, (GENCAL_VAR_SP)
 64+  5876 FB               EI
 65+  5877 E1               POP HL
 66+  5878 C9           	RET
 67+  5879
 68+  5879              .EXXDECALL:
 69+  5879 D5               PUSH DE
 70+  587A D9               EXX
 71+  587B C9               RET
 72+  587C              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
141   587C               ENDIF
142   587C
143   587C               IF (BOX_CMDS == 1)
144   587C               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  587C              ; *******************************************************************************************************
  2+  587C              ; generic function to implement rectangle data copy
  3+  587C              ; should be modified to call appropriate function for memory or vram
  4+  587C              ; input IX=pointer to following structure
  5+  587C              ; +00 source data pointer
  6+  587C              ; +02 num bytes in a row
  7+  587C              ; +04 number of rows
  8+  587C              ; +06 source add-to value till next row
  9+  587C              ; +08 destination address
 10+  587C              ; +10 destination add-to value till next row
 11+  587C              ; modifies AF, BC, DE, HL
 12+  587C              RECTANGLE_COPY:
 13+  587C DD 6E 00     	LD L, (IX+0)
 14+  587F DD 66 01     	LD H, (IX+1) ; source address
 15+  5882 DD 5E 08     	LD E, (IX+8)
 16+  5885 DD 56 09     	LD D, (IX+9) ; destination
 17+  5888 DD 46 04     	LD B, (IX+4) ; row number
 18+  588B              .L1:
 19+  588B C5           	PUSH BC
 20+  588C E5           		PUSH HL
 21+  588D D5           			PUSH DE
 22+  588E DD 4E 02     				LD C, (IX+2)
 23+  5891 DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  5894              .CALL1:
 25+  5894 CD 00 00     				CALL 0 ; set destination address from DE
 26+  5897              .CALL2:
 27+  5897 CD 00 00     				CALL 0 ; copy data fn
 28+  589A E1           			POP HL
 29+  589B DD 4E 0A     			LD C, (IX+10)
 30+  589E DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  58A1 09           			ADD HL, BC
 32+  58A2 EB           			EX DE, HL
 33+  58A3 E1           		POP HL
 34+  58A4 DD 4E 06     		LD C, (IX+6)
 35+  58A7 DD 46 07     		LD B, (IX+7) ; src add-to
 36+  58AA 09           		ADD HL, BC
 37+  58AB C1           	POP BC
 38+  58AC 10 DD        	DJNZ .L1
 39+  58AE C9           	RET
 40+  58AF              ; *******************************************************************************************************
 41+  58AF
 42+  58AF              ; *******************************************************************************************************
 43+  58AF              ; function to handle CALL BOXMEMCPY basic extension
 44+  58AF              ; copies data with window like boundaries within ram
 45+  58AF              ; BOXMEMCPY ( INT source data pointer,
 46+  58AF              ;			  INT source number of bytes in a row,
 47+  58AF              ;			  INT number of rows,
 48+  58AF              ;			  INT source add-to value till next row,
 49+  58AF              ; 			  INT destination pointer,
 50+  58AF              ;			  INT destination add-to value till next row )
 51+  58AF              ; request_data_ptr described in RECTANGLE_COPY
 52+  58AF              ; will put ram in page 0 also, page 1 is already there
 53+  58AF              BOXMEMCPY:
 54+  58AF 11 B9 58     	LD DE,BOXMEMCPY.RET
 55+  58B2 ED 53 2D 59  	LD (BOXCOMMON.ADDR+2), DE
 56+  58B6 C3 CC 58     	JP BOXCOMMON
 57+  58B9              .RET:
 58+  58B9 FB           	EI
 59+  58BA              	; set RAM functions to call
 60+  58BA 21 00 00     	LD HL, 0
 61+  58BD 22 94 58     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 62+  58C0 22 96 58     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 63+  58C3 21 ED B0     	LD HL, #B0ED ; LDIR
 64+  58C6 22 98 58     	LD (RECTANGLE_COPY.CALL1+4), HL
 65+  58C9 C3 32 59     	JP BOXCOMMON.CALL
 66+  58CC              ; *******************************************************************************************************
 67+  58CC
 68+  58CC              ; *******************************************************************************************************
 69+  58CC              ; common parts of BOX commands
 70+  58CC              BOXCOMMON:
 71+  58CC              	; opening (
 72+  58CC CD 31 62     	CALL CHKCHAR
 73+  58CF 28           	DB '('
 74+  58D0              	; get source data pointer
 75+  58D0 DD 21 2F 54  	LD IX, FRMQNT
 76+  58D4 CD 59 01     	CALL CALBAS
 77+  58D7 ED 53 60 5F  	LD (BLIT_STRUCT+0), DE
 78+  58DB              	; comma
 79+  58DB CD 31 62     	CALL CHKCHAR
 80+  58DE 2C           	DB ','
 81+  58DF              	; source number of bytes in a row
 82+  58DF DD 21 2F 54  	LD IX, FRMQNT
 83+  58E3 CD 59 01     	CALL CALBAS
 84+  58E6 ED 53 62 5F  	LD (BLIT_STRUCT+2), DE
 85+  58EA              	; comma
 86+  58EA CD 31 62     	CALL CHKCHAR
 87+  58ED 2C           	DB ','
 88+  58EE              	; number of rows
 89+  58EE DD 21 2F 54  	LD IX, FRMQNT
 90+  58F2 CD 59 01     	CALL CALBAS
 91+  58F5 ED 53 64 5F  	LD (BLIT_STRUCT+4), DE
 92+  58F9              	; comma
 93+  58F9 CD 31 62     	CALL CHKCHAR
 94+  58FC 2C           	DB ','
 95+  58FD              	; source add-to value till next row
 96+  58FD DD 21 2F 54  	LD IX, FRMQNT
 97+  5901 CD 59 01     	CALL CALBAS
 98+  5904 ED 53 66 5F  	LD (BLIT_STRUCT+6), DE
 99+  5908              	; comma
100+  5908 CD 31 62     	CALL CHKCHAR
101+  590B 2C           	DB ','
102+  590C              	; destination pointer
103+  590C DD 21 2F 54  	LD IX, FRMQNT
104+  5910 CD 59 01     	CALL CALBAS
105+  5913 ED 53 68 5F  	LD (BLIT_STRUCT+8), DE
106+  5917              	; comma
107+  5917 CD 31 62     	CALL CHKCHAR
108+  591A 2C           	DB ','
109+  591B              	; destination add-to value till next row
110+  591B DD 21 2F 54  	LD IX, FRMQNT
111+  591F CD 59 01     	CALL CALBAS
112+  5922 ED 53 6A 5F  	LD (BLIT_STRUCT+10), DE
113+  5926              	; ending )
114+  5926 CD 31 62     	CALL CHKCHAR
115+  5929 29           	DB ')'
116+  592A
117+  592A E5           	PUSH HL ; save position in BASIC buffer
118+  592B              .ADDR:
119+  592B FD 21 00 00  	LD IY, 0
120+  592F C3 E4 61     	JP ENABLE_PAGE0
121+  5932              .CALL:
122+  5932 DD 21 60 5F  	LD IX,BLIT_STRUCT
123+  5936 CD 7C 58     	CALL RECTANGLE_COPY
124+  5939 AF           	XOR A
125+  593A 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
126+  593D
127+  593D D1               POP DE
128+  593E C1               POP BC
129+  593F CD 5B 61         CALL RESTORE_PAGE_INFO
130+  5942
131+  5942 E1           	POP HL
132+  5943 C9           	RET
133+  5944              ; *******************************************************************************************************
134+  5944
135+  5944              ; *******************************************************************************************************
136+  5944              ; function to handle CALL BOXMEMVRM basic extension
137+  5944              ; copies data with window like boundaries from ram to Vram
138+  5944              ; BOXMEMVRM ( INT source data pointer,
139+  5944              ;			  INT source number of bytes in a row,
140+  5944              ;			  INT number of rows,
141+  5944              ;			  INT source add-to value till next row,
142+  5944              ; 			  INT destination pointer,
143+  5944              ;			  INT destination add-to value till next row )
144+  5944              ; request_data_ptr described in RECTANGLE_COPY
145+  5944              ; will put ram in page 0 also, page 1 is already there
146+  5944              BOXMEMVRM:
147+  5944 11 4E 59     	LD DE,BOXMEMVRM.RET
148+  5947 ED 53 2D 59  	LD (BOXCOMMON.ADDR+2), DE
149+  594B C3 CC 58     	JP BOXCOMMON
150+  594E              .RET:
151+  594E FB           	EI
152+  594F              	; set RAM functions to call
153+  594F 21 69 59     	LD HL, .SETDEST
154+  5952 22 95 58     	LD (RECTANGLE_COPY.CALL1+1), HL
155+  5955 21 71 59     	LD HL, .COPYDATA
156+  5958 22 98 58     	LD (RECTANGLE_COPY.CALL2+1), HL
157+  595B 3E CD        	LD A, #CD ; CALL
158+  595D 32 94 58     	LD (RECTANGLE_COPY.CALL1), A
159+  5960 32 97 58     	LD (RECTANGLE_COPY.CALL2), A
160+  5963              	;LD A,1
161+  5963 32 71 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
162+  5966 C3 32 59     	JP BOXCOMMON.CALL
163+  5969              .SETDEST:
164+  5969 EB           	EX DE, HL
165+  596A F3           	DI
166+  596B CD 0B 61     	CALL SETWRT_LOCAL
167+  596E FB           	EI
168+  596F EB           	EX DE, HL
169+  5970 C9           	RET
170+  5971              .COPYDATA:
171+  5971 41           	LD B, C
172+  5972 C3 16 61     	JP BBYTECOPY
173+  5975              ; *******************************************************************************************************
# file closed: asm\BOX.asm
145   5975               ENDIF
146   5975
147   5975               IF (BLIT_CMDS == 1)
148   5975               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  5975              ; *******************************************************************************************************
  2+  5975              ; function rotates mask and data of several characters and applies to background data
  3+  5975              ; this handles x-shift from 0 to 4
  4+  5975              ; contains self-modifying code that is set-up from external function
  5+  5975              ; input HL=pointer to mask data
  6+  5975              ; input HL'=pointer to character data
  7+  5975              ; input DE=output buffer containing background data
  8+  5975              ; input BC=DE+8
  9+  5975              ; input A=number of characters to process
 10+  5975              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  5975              SHIFT04:
 12+  5975 08           	EX AF, AF'
 13+  5976 7E           	LD A, (HL) ; get mask
 14+  5977 D9           	EXX
 15+  5978 57           	LD D, A
 16+  5979 1E FF        	LD E, #FF
 17+  597B 37           	SCF
 18+  597C              .M1:
 19+  597C 18 FE        	JR .M1 ; this is self-modifying part
 20+  597E CB 1A        	RR D
 21+  5980 CB 1B        	RR E
 22+  5982 CB 1A        	RR D
 23+  5984 CB 1B        	RR E
 24+  5986 CB 1A        	RR D
 25+  5988 CB 1B        	RR E
 26+  598A CB 1A        	RR D
 27+  598C CB 1B        	RR E
 28+  598E
 29+  598E 46           	LD B, (HL) ; get data
 30+  598F 0E 00        	LD C, 0
 31+  5991              .M2:
 32+  5991 18 FE        	JR .M2 ; also self-modifying part
 33+  5993 CB 38        	SRL B
 34+  5995 CB 19        	RR C
 35+  5997 CB 38        	SRL B
 36+  5999 CB 19        	RR C
 37+  599B CB 38        	SRL B
 38+  599D CB 19        	RR C
 39+  599F CB 38        	SRL B
 40+  59A1 CB 19        	RR C
 41+  59A3
 42+  59A3 D9           	EXX
 43+  59A4 1A           	LD A, (DE) ; background
 44+  59A5 D9           	EXX
 45+  59A6 A2           	AND D
 46+  59A7 B0           	OR B
 47+  59A8 D9           	EXX
 48+  59A9 12           	LD (DE), A
 49+  59AA
 50+  59AA 0A           	LD A, (BC)
 51+  59AB D9           	EXX
 52+  59AC A3           	AND E
 53+  59AD B1           	OR C
 54+  59AE 23           	INC HL
 55+  59AF D9           	EXX
 56+  59B0 02           	LD (BC), A
 57+  59B1
 58+  59B1 23           	INC HL
 59+  59B2 13           	INC DE
 60+  59B3 03           	INC BC
 61+  59B4
 62+  59B4 08           	EX AF, AF'
 63+  59B5 3D           	DEC A
 64+  59B6 C2 75 59     	JP NZ, SHIFT04
 65+  59B9 C9           	RET
 66+  59BA              ; *******************************************************************************************************
 67+  59BA
 68+  59BA              ; *******************************************************************************************************
 69+  59BA              ; function rotates mask and data of several characters and applies to background data
 70+  59BA              ; this handles x-shift from 5 to 8
 71+  59BA              ; contains self-modifying code that is set-up from external function
 72+  59BA              ; input HL=pointer to mask data
 73+  59BA              ; input HL'=pointer to character data
 74+  59BA              ; input DE=output buffer containing background data
 75+  59BA              ; input BC=DE+8
 76+  59BA              ; input A=number of characters to process
 77+  59BA              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  59BA              SHIFT58:
 79+  59BA 08           	EX AF, AF'
 80+  59BB 7E           	LD A, (HL) ; get mask
 81+  59BC D9           	EXX
 82+  59BD 57           	LD D, A
 83+  59BE 1E FF        	LD E, #FF
 84+  59C0 37           	SCF
 85+  59C1              .M1:
 86+  59C1 18 FE        	JR .M1 ; this is self-modifying part
 87+  59C3 CB 12        	RL D
 88+  59C5 CB 13        	RL E
 89+  59C7 CB 12        	RL D
 90+  59C9 CB 13        	RL E
 91+  59CB CB 12        	RL D
 92+  59CD CB 13        	RL E
 93+  59CF
 94+  59CF 46           	LD B, (HL)
 95+  59D0 0E 00        	LD C, 0
 96+  59D2              .M2:
 97+  59D2 18 FE        	JR .M2 ; also self-modifying part
 98+  59D4 CB 20        	SLA B
 99+  59D6 CB 11        	RL C
100+  59D8 CB 20        	SLA B
101+  59DA CB 11        	RL C
102+  59DC CB 20        	SLA B
103+  59DE CB 11        	RL C
104+  59E0
105+  59E0 D9           	EXX
106+  59E1 1A           	LD A, (DE) ; background
107+  59E2 D9           	EXX
108+  59E3 A3           	AND E
109+  59E4 B1           	OR C
110+  59E5 D9           	EXX
111+  59E6 12           	LD (DE), A
112+  59E7
113+  59E7 0A           	LD A, (BC)
114+  59E8 D9           	EXX
115+  59E9 A2           	AND D
116+  59EA B0           	OR B
117+  59EB 23           	INC HL
118+  59EC D9           	EXX
119+  59ED 02           	LD (BC), A
120+  59EE
121+  59EE 23           	INC HL
122+  59EF 13           	INC DE
123+  59F0 03           	INC BC
124+  59F1
125+  59F1 08           	EX AF, AF'
126+  59F2 3D           	DEC A
127+  59F3 C2 BA 59     	JP NZ, SHIFT58
128+  59F6 C9           	RET
129+  59F7              ; *******************************************************************************************************
130+  59F7
131+  59F7              ; *******************************************************************************************************
132+  59F7              ; routine that shifts one row of characters
133+  59F7              ; contains self-modifying code that is set-up from external function
134+  59F7              ; input HL=pointer to mask data
135+  59F7              ; input HL'=pointer to character data
136+  59F7              ; input DE=output buffer containing background data
137+  59F7              ; input A=number of characters to process
138+  59F7              ; input IX=pointer to structure describing input data
139+  59F7              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  59F7              SHIFT_ROW:
141+  59F7 F5           	PUSH AF
142+  59F8 ED 53 5C 5F  		LD (BLIT_TMP1), DE
143+  59FC E5           		PUSH HL
144+  59FD CD 40 5A     			CALL .ADDYSHIFT
145+  5A00 E1           		POP HL
146+  5A01 ED 53 5E 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  5A05              .L1:
148+  5A05 3E 08        		LD A, 8
149+  5A07 DD 96 02     		SUB (IX+2) ; y shift
150+  5A0A              .CALL1:
151+  5A0A CD 00 00     		CALL 0
152+  5A0D DD 7E 02     		LD A, (IX+2); y shift
153+  5A10 B7           		OR A
154+  5A11 28 26        		JR Z, .DONE
155+  5A13 ED 5B 5C 5F  		LD DE, (BLIT_TMP1)
156+  5A17 E5           		PUSH HL
157+  5A18 CD 4E 5A     			CALL .DETONEXTROW
158+  5A1B E1           		POP HL
159+  5A1C              .CALL2:
160+  5A1C CD 00 00     		CALL 0
161+  5A1F ED 5B 5C 5F  		LD DE, (BLIT_TMP1)
162+  5A23 E5           		PUSH HL
163+  5A24 CD 48 5A     			CALL .ADD8
164+  5A27 E1           		POP HL
165+  5A28 ED 53 5C 5F  		LD (BLIT_TMP1), DE
166+  5A2C ED 5B 5E 5F  		LD DE, (BLIT_TMP2)
167+  5A30 E5           		PUSH HL
168+  5A31 CD 48 5A     			CALL .ADD8
169+  5A34 E1           		POP HL
170+  5A35 ED 53 5E 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  5A39              .DONE:
172+  5A39 F1           	POP AF
173+  5A3A 3D           	DEC A
174+  5A3B C8           	RET Z
175+  5A3C F5           	PUSH AF
176+  5A3D C3 05 5A     	JP .L1
177+  5A40              .ADDYSHIFT:
178+  5A40 EB           	EX DE, HL
179+  5A41 16 00        	LD D, 0
180+  5A43 DD 5E 02     	LD E, (IX+2); y shift
181+  5A46 18 0C        	JR .MOVDEBC
182+  5A48              .ADD8:
183+  5A48 21 08 00     	LD HL, 8
184+  5A4B C3 54 5A     	JP .MOVDEBC
185+  5A4E              .DETONEXTROW:
186+  5A4E DD 6E 06     	LD L, (IX+6)
187+  5A51 DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5A54              .MOVDEBC:
189+  5A54 19           	ADD HL, DE
190+  5A55 54           	LD D, H
191+  5A56 5D           	LD E, L
192+  5A57 01 08 00     	LD BC, 8
193+  5A5A 09           	ADD HL, BC
194+  5A5B 44           	LD B, H
195+  5A5C 4D           	LD C, L
196+  5A5D C9           	RET
197+  5A5E              ; *******************************************************************************************************
198+  5A5E
199+  5A5E              ; *******************************************************************************************************
200+  5A5E              ; function rotates mask and character data and applies it to background
201+  5A5E              ; input IX=pointer to structure describing input data
202+  5A5E              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  5A5E              ; +2  DW vertical shift count 0-7 (low byte used)
204+  5A5E              ; +4  DW background data start;
205+  5A5E              ; +6  DW background add to value to next row of background data
206+  5A5E              ; +8  DW mask data start;
207+  5A5E              ; +10  DW character data start;
208+  5A5E              ; +12 DW character&mask add to value to next row of data
209+  5A5E              ; +14 DW columns (low byte used)
210+  5A5E              ; +16 DW rows (low byte used)
211+  5A5E              SHIFT_MERGE_CHARACTER:
212+  5A5E DD 7E 00     	LD A, (IX) ; shift
213+  5A61 FE 05        	CP 5
214+  5A63 38 25        	JR C, .RIGHT
215+  5A65              	; shifts 5-7, use rotate towards left 1-3
216+  5A65 21 BA 59     	LD HL, SHIFT58
217+  5A68 22 0B 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  5A6B 22 1D 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  5A6E D6 05        	SUB 5
220+  5A70 28 0D        	JR Z, .L1
221+  5A72 87           	ADD A, A
222+  5A73 87           	ADD A, A
223+  5A74 67           	LD H, A
224+  5A75 2E 18        	LD L, #18 ; JR opcode
225+  5A77 22 C1 59     	LD (SHIFT58.M1), HL
226+  5A7A 22 D2 59     	LD (SHIFT58.M2), HL
227+  5A7D 18 32        	JR .DO
228+  5A7F              .L1:
229+  5A7F 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  5A82 22 C1 59     	LD (SHIFT58.M1), HL
231+  5A85 22 D2 59     	LD (SHIFT58.M2), HL
232+  5A88 18 27        	JR .DO
233+  5A8A              .RIGHT:
234+  5A8A              	; shifts 0-4, rotate towards right
235+  5A8A 21 75 59     	LD HL, SHIFT04
236+  5A8D 22 0B 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  5A90 22 1D 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  5A93 FE 04        	CP 4
239+  5A95 28 11        	JR Z, .R1
240+  5A97 D6 04        	SUB 4
241+  5A99 ED 44        	NEG
242+  5A9B 87           	ADD A, A
243+  5A9C 87           	ADD A, A
244+  5A9D 67           	LD H, A
245+  5A9E 2E 18        	LD L, #18 ; JR opcode
246+  5AA0 22 7C 59     	LD (SHIFT04.M1), HL
247+  5AA3 22 91 59     	LD (SHIFT04.M2), HL
248+  5AA6 18 09        	JR .DO
249+  5AA8              .R1:
250+  5AA8 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  5AAB 22 7C 59     	LD (SHIFT04.M1), HL
252+  5AAE 22 91 59     	LD (SHIFT04.M2), HL
253+  5AB1              .DO:
254+  5AB1 DD 46 10     	LD B, (IX+16) ; rows
255+  5AB4 DD 6E 08     	LD L, (IX+8)
256+  5AB7 DD 66 09     	LD H, (IX+9) ; mask data
257+  5ABA DD 5E 04     	LD E, (IX+4)
258+  5ABD DD 56 05     	LD D, (IX+5) ; background data
259+  5AC0 D9           	EXX
260+  5AC1 DD 6E 0A     	LD L, (IX+10)
261+  5AC4 DD 66 0B     	LD H, (IX+11) ; character data
262+  5AC7 D9           	EXX
263+  5AC8              .LOOP:
264+  5AC8 C5           	PUSH BC
265+  5AC9 E5           		PUSH HL
266+  5ACA D5           			PUSH DE
267+  5ACB D9           				EXX
268+  5ACC E5           				PUSH HL
269+  5ACD D9           					EXX
270+  5ACE DD 7E 0E     					LD A, (IX+14) ; columns
271+  5AD1              .CALL:
272+  5AD1 CD F7 59     					CALL SHIFT_ROW
273+  5AD4 E1           				POP HL
274+  5AD5 DD 5E 0C     				LD E, (IX+12)
275+  5AD8 DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  5ADB 19           				ADD HL, DE
277+  5ADC D9           				EXX
278+  5ADD E1           			POP HL
279+  5ADE DD 5E 06     			LD E, (IX+6)
280+  5AE1 DD 56 07     			LD D, (IX+7) ; background to next row
281+  5AE4 19           			ADD HL, DE
282+  5AE5 EB           			EX DE, HL
283+  5AE6 E1           		POP HL
284+  5AE7 DD 4E 0C     		LD C, (IX+12)
285+  5AEA DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  5AED 09           		ADD HL, BC
287+  5AEE C1           	POP BC
288+  5AEF 10 D7        	DJNZ .LOOP
289+  5AF1 C9           	RET
290+  5AF2              ; *******************************************************************************************************
291+  5AF2
292+  5AF2               IFNDEF CMDS_WITH_PARAMETERS
293+  5AF2 ~            ; *******************************************************************************************************
294+  5AF2 ~            ; function to handle CALL BLIT basic extension
295+  5AF2 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  5AF2 ~            ; fuses with background data and applies vertical shift too
297+  5AF2 ~            ; BLIT ( INT request_data_ptr )
298+  5AF2 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  5AF2 ~            ; will put ram in page 0 also, page 1 is already there
300+  5AF2 ~            BLIT:
301+  5AF2 ~            	; opening (
302+  5AF2 ~            	CALL CHKCHAR
303+  5AF2 ~            	DB '('
304+  5AF2 ~            	; get pointer to request struct
305+  5AF2 ~            	LD IX, FRMQNT
306+  5AF2 ~            	CALL CALBAS
307+  5AF2 ~            	PUSH DE
308+  5AF2 ~            	; ending )
309+  5AF2 ~            	CALL CHKCHAR
310+  5AF2 ~            	DB ')'
311+  5AF2 ~
312+  5AF2 ~            	POP IX ; pointer to request struct
313+  5AF2 ~
314+  5AF2 ~            	PUSH HL ; save position in BASIC buffer
315+  5AF2 ~
316+  5AF2 ~            	LD IY, .RET
317+  5AF2 ~            	JP ENABLE_PAGE0
318+  5AF2 ~            .RET:
319+  5AF2 ~            	EI
320+  5AF2 ~            	CALL SHIFT_MERGE_CHARACTER
321+  5AF2 ~
322+  5AF2 ~                POP DE
323+  5AF2 ~                POP BC
324+  5AF2 ~                CALL RESTORE_PAGE_INFO
325+  5AF2 ~
326+  5AF2 ~            	POP HL
327+  5AF2 ~            	RET
328+  5AF2 ~            ; *******************************************************************************************************
329+  5AF2               ENDIF
330+  5AF2
331+  5AF2               IFDEF CMDS_WITH_PARAMETERS
332+  5AF2              ; *******************************************************************************************************
333+  5AF2              ; function to handle CALL BLIT basic extension
334+  5AF2              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  5AF2              ; fuses with background data and applies vertical shift too
336+  5AF2              ; in form without pointers
337+  5AF2              ; BLIT ( INT x,
338+  5AF2              ;		 INT y,
339+  5AF2              ;		 INT char_data_pointer,
340+  5AF2              ;		 INT mask_data_pointer,
341+  5AF2              ;		 INT width (in characters),
342+  5AF2              ;		 INT height (in characters),
343+  5AF2              ;		 INT background_pointer (top left),
344+  5AF2              ;		 INT background_width (in characters),
345+  5AF2              ;		 INT background_height (in characters))
346+  5AF2              ; will put ram in page 0 also, page 1 is already there
347+  5AF2              BLIT:
348+  5AF2              	; opening (
349+  5AF2 CD 31 62     	CALL CHKCHAR
350+  5AF5 28           	DB '('
351+  5AF6              	; get x coordinate
352+  5AF6 DD 21 2F 54  	LD IX, FRMQNT
353+  5AFA CD 59 01     	CALL CALBAS
354+  5AFD 7B           	LD A, E
355+  5AFE E6 07        	AND 7
356+  5B00 32 60 5F     	LD (BLIT_STRUCT+0), A
357+  5B03 CD E0 5B     	CALL .DAdiv8
358+  5B06 32 5C 5F     	LD (BLIT_TMP+0),A
359+  5B09              	; comma
360+  5B09 CD 31 62     	CALL CHKCHAR
361+  5B0C 2C           	DB ','
362+  5B0D              	; get y coordinate
363+  5B0D DD 21 2F 54  	LD IX, FRMQNT
364+  5B11 CD 59 01     	CALL CALBAS
365+  5B14 7B           	LD A, E
366+  5B15 E6 07        	AND 7
367+  5B17 32 62 5F     	LD (BLIT_STRUCT+2), A
368+  5B1A CD E0 5B     	CALL .DAdiv8
369+  5B1D 32 5D 5F     	LD (BLIT_TMP+1),A
370+  5B20              	; comma
371+  5B20 CD 31 62     	CALL CHKCHAR
372+  5B23 2C           	DB ','
373+  5B24              	; get char data pointer
374+  5B24 DD 21 2F 54  	LD IX, FRMQNT
375+  5B28 CD 59 01     	CALL CALBAS
376+  5B2B ED 53 6A 5F  	LD (BLIT_STRUCT+10), DE
377+  5B2F              	; comma
378+  5B2F CD 31 62     	CALL CHKCHAR
379+  5B32 2C           	DB ','
380+  5B33              	; get mask data pointer
381+  5B33 DD 21 2F 54  	LD IX, FRMQNT
382+  5B37 CD 59 01     	CALL CALBAS
383+  5B3A ED 53 68 5F  	LD (BLIT_STRUCT+8), DE
384+  5B3E              	; comma
385+  5B3E CD 31 62     	CALL CHKCHAR
386+  5B41 2C           	DB ','
387+  5B42              	; get width
388+  5B42 DD 21 2F 54  	LD IX, FRMQNT
389+  5B46 CD 59 01     	CALL CALBAS
390+  5B49 7B           	LD A, E
391+  5B4A 32 6E 5F     	LD (BLIT_STRUCT+14), A
392+  5B4D              	; comma
393+  5B4D CD 31 62     	CALL CHKCHAR
394+  5B50 2C           	DB ','
395+  5B51              	; get height
396+  5B51 DD 21 2F 54  	LD IX, FRMQNT
397+  5B55 CD 59 01     	CALL CALBAS
398+  5B58 7B           	LD A, E
399+  5B59 32 70 5F     	LD (BLIT_STRUCT+16), A
400+  5B5C              	; comma
401+  5B5C CD 31 62     	CALL CHKCHAR
402+  5B5F 2C           	DB ','
403+  5B60              	; get background pointer
404+  5B60 DD 21 2F 54  	LD IX, FRMQNT
405+  5B64 CD 59 01     	CALL CALBAS
406+  5B67 ED 53 64 5F  	LD (BLIT_STRUCT+4), DE
407+  5B6B              	; comma
408+  5B6B CD 31 62     	CALL CHKCHAR
409+  5B6E 2C           	DB ','
410+  5B6F              	; get background width
411+  5B6F DD 21 2F 54  	LD IX, FRMQNT
412+  5B73 CD 59 01     	CALL CALBAS
413+  5B76 7B           	LD A, E
414+  5B77 32 5E 5F     	LD (BLIT_TMP+2), A
415+  5B7A              	; comma
416+  5B7A CD 31 62     	CALL CHKCHAR
417+  5B7D 2C           	DB ','
418+  5B7E              	; get background height
419+  5B7E DD 21 2F 54  	LD IX, FRMQNT
420+  5B82 CD 59 01     	CALL CALBAS
421+  5B85 7B           	LD A, E
422+  5B86 32 5F 5F     	LD (BLIT_TMP+3), A
423+  5B89              	; ending )
424+  5B89 CD 31 62     	CALL CHKCHAR
425+  5B8C 29           	DB ')'
426+  5B8D
427+  5B8D E5           	PUSH HL ; save position in BASIC buffer
428+  5B8E
429+  5B8E              	; calculate char&mask add to value
430+  5B8E 26 00        	LD H, 0
431+  5B90 3A 6E 5F     	LD A, (BLIT_STRUCT+14)
432+  5B93 6F           	LD L, A
433+  5B94 CD 20 61     	CALL HLx8
434+  5B97 22 6C 5F     	LD (BLIT_STRUCT+12), HL
435+  5B9A              	; calculate background add to value
436+  5B9A 26 00        	LD H, 0
437+  5B9C 3A 5E 5F     	LD A, (BLIT_TMP+2)
438+  5B9F 6F           	LD L, A
439+  5BA0 CD 20 61     	CALL HLx8
440+  5BA3 22 66 5F     	LD (BLIT_STRUCT+6), HL
441+  5BA6              	; calculate pointer to background location
442+  5BA6 21 00 00     	LD HL, 0
443+  5BA9 3A 5D 5F     	LD A,(BLIT_TMP+1)
444+  5BAC B7           	OR A
445+  5BAD 28 08        	JR Z, .L1
446+  5BAF 47           	LD B,A
447+  5BB0 ED 5B 66 5F  	LD DE,(BLIT_STRUCT+6)
448+  5BB4              .L0:
449+  5BB4 19           	ADD HL, DE
450+  5BB5 10 FD        	DJNZ .L0
451+  5BB7              .L1:
452+  5BB7 EB           	EX DE,HL
453+  5BB8 26 00        	LD H,0
454+  5BBA 3A 5C 5F     	LD A,(BLIT_TMP+0)
455+  5BBD 6F           	LD L,A
456+  5BBE CD 20 61     	CALL HLx8
457+  5BC1 19           	ADD HL,DE
458+  5BC2 ED 5B 64 5F  	LD DE,(BLIT_STRUCT+4)
459+  5BC6 19           	ADD HL,DE
460+  5BC7 22 64 5F     	LD (BLIT_STRUCT+4),HL
461+  5BCA
462+  5BCA FD 21 D1 5B  	LD IY, .RET
463+  5BCE C3 E4 61     	JP ENABLE_PAGE0
464+  5BD1              .RET:
465+  5BD1 FB           	EI
466+  5BD2 DD 21 60 5F  	LD IX, BLIT_STRUCT
467+  5BD6 CD 5E 5A     	CALL SHIFT_MERGE_CHARACTER
468+  5BD9
469+  5BD9 D1               POP DE
470+  5BDA C1               POP BC
471+  5BDB CD 5B 61         CALL RESTORE_PAGE_INFO
472+  5BDE
473+  5BDE E1           	POP HL
474+  5BDF C9           	RET
475+  5BE0              .DAdiv8:
476+  5BE0 7B           	LD A,E
477+  5BE1 CB 2A        	SRA D
478+  5BE3 CB 1F            RR  A
479+  5BE5 CB 2A            SRA D
480+  5BE7 CB 1F            RR  A
481+  5BE9 CB 2A            SRA D
482+  5BEB CB 1F            RR  A
483+  5BED C9           	RET
484+  5BEE              ; *******************************************************************************************************
485+  5BEE               ENDIF
# file closed: asm\BLIT.asm
149   5BEE               ENDIF
150   5BEE
151   5BEE               IF (TILE_CMDS == 1)
152   5BEE               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5BEE              ; *******************************************************************************************************
  2+  5BEE              ; generic function to implement tiling
  3+  5BEE              ; should be modified to call appropriate function for memory or vram
  4+  5BEE              ; input IX=pointer to following structure
  5+  5BEE              ; +00 tile_data_ptr
  6+  5BEE              ; +02 tile_rows
  7+  5BEE              ; +04 tile_columns
  8+  5BEE              ; +06 destination_address
  9+  5BEE              ; +08 dest_to_next_row_add_to_value
 10+  5BEE              ; +10 num_horizontal_tiles
 11+  5BEE              ; +12 num_vertical_tiles
 12+  5BEE              ; modifies AF, BC, DE, HL
 13+  5BEE              TILE:
 14+  5BEE DD 6E 06     	LD L, (IX+6)
 15+  5BF1 DD 66 07     	LD H, (IX+7) ; destination address
 16+  5BF4 22 5C 5F     	LD (TILETMP1), HL
 17+  5BF7 DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5BFA              .L1:
 19+  5BFA C5           	PUSH BC
 20+  5BFB DD 6E 00     		LD L, (IX+0)
 21+  5BFE DD 66 01     		LD H, (IX+1) ; tile address
 22+  5C01 22 5E 5F     		LD (TILETMP2), HL
 23+  5C04 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5C07              .L2:
 25+  5C07 C5           		PUSH BC
 26+  5C08 CD 00 00     .CALL1:		CALL 0
 27+  5C0B DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5C0E              .L3:
 29+  5C0E C5           			PUSH BC
 30+  5C0F 2A 5E 5F     				LD HL, (TILETMP2)
 31+  5C12 DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5C15              .L4:
 33+  5C15 C5           				PUSH BC
 34+  5C16              .CALL2:
 35+  5C16 CD 00 00     					CALL 0
 36+  5C19 C1           				POP BC
 37+  5C1A 10 F9        				DJNZ .L4
 38+  5C1C C1           			POP BC
 39+  5C1D 10 EF        			DJNZ .L3
 40+  5C1F 22 5E 5F     			LD (TILETMP2), HL
 41+  5C22 2A 5C 5F     			LD HL, (TILETMP1)
 42+  5C25 DD 5E 08     			LD E, (IX+8)
 43+  5C28 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5C2B 19           			ADD HL, DE
 45+  5C2C 22 5C 5F     			LD (TILETMP1), HL
 46+  5C2F C1           		POP BC
 47+  5C30 10 D5        		DJNZ .L2
 48+  5C32 C1           	POP BC
 49+  5C33 10 C5        	DJNZ .L1
 50+  5C35 C9           	RET
 51+  5C36              ; *******************************************************************************************************
 52+  5C36
 53+  5C36               IFNDEF CMDS_WITH_PARAMETERS
 54+  5C36 ~            ; *******************************************************************************************************
 55+  5C36 ~            ; function to handle CALL TILERAM basic extension
 56+  5C36 ~            ; fills memory with tiles
 57+  5C36 ~            ; TILERAM ( INT request_data_ptr )
 58+  5C36 ~            ; request_data_ptr described in TILE
 59+  5C36 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5C36 ~            TILERAM:
 61+  5C36 ~            	; opening (
 62+  5C36 ~            	CALL CHKCHAR
 63+  5C36 ~            	DB '('
 64+  5C36 ~            	; get pointer to request struct
 65+  5C36 ~            	LD IX, FRMQNT
 66+  5C36 ~            	CALL CALBAS
 67+  5C36 ~            	PUSH DE
 68+  5C36 ~            	; ending )
 69+  5C36 ~            	CALL CHKCHAR
 70+  5C36 ~            	DB ')'
 71+  5C36 ~
 72+  5C36 ~            	POP IX ; pointer to request struct
 73+  5C36 ~
 74+  5C36 ~            	PUSH HL ; save position in BASIC buffer
 75+  5C36 ~
 76+  5C36 ~            	LD IY, .RET
 77+  5C36 ~            	JP ENABLE_PAGE0
 78+  5C36 ~            .RET:
 79+  5C36 ~            	EI
 80+  5C36 ~            	; set RAM functions to call
 81+  5C36 ~            	LD HL, .TILECOPY
 82+  5C36 ~            	LD (TILE.CALL2+1), HL
 83+  5C36 ~            	LD HL, .SETDESTROW
 84+  5C36 ~            	LD (TILE.CALL1+1), HL
 85+  5C36 ~            	LD A,1
 86+  5C36 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5C36 ~            	CALL TILE
 88+  5C36 ~            	XOR A
 89+  5C36 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5C36 ~
 91+  5C36 ~                POP DE
 92+  5C36 ~                POP BC
 93+  5C36 ~                CALL RESTORE_PAGE_INFO
 94+  5C36 ~
 95+  5C36 ~            	POP HL
 96+  5C36 ~            	RET
 97+  5C36 ~            .TILECOPY:
 98+  5C36 ~            	.8 LDI
 99+  5C36 ~            	RET
100+  5C36 ~            .SETDESTROW:
101+  5C36 ~            	LD DE, (TILETMP1)
102+  5C36 ~            	RET
103+  5C36 ~            ; *******************************************************************************************************
104+  5C36               ENDIF
105+  5C36
106+  5C36               IFDEF CMDS_WITH_PARAMETERS
107+  5C36              ; *******************************************************************************************************
108+  5C36              ; function to handle CALL TILERAM basic extension
109+  5C36              ; fills memory with tiles
110+  5C36              ; TILERAM ( INT tile_data_pointer,
111+  5C36              ;			INT tile_columns,
112+  5C36              ;			INT tile_rows,
113+  5C36              ;			INT destination_pointer,
114+  5C36              ;			INT destination_columns,
115+  5C36              ;			INT destination_rows,
116+  5C36              ;			INT destination_begin_column,
117+  5C36              ;			INT destination_begin_row,
118+  5C36              ;			INT number_of_tiles_horizontally,
119+  5C36              ;			INT	number_of_tiles_vertically )
120+  5C36              ; will put ram in page 0 also, page 1 is already there
121+  5C36              TILERAM:
122+  5C36              	; opening (
123+  5C36 CD 31 62     	CALL CHKCHAR
124+  5C39 28           	DB '('
125+  5C3A              	; get tile data pointer coordinate
126+  5C3A DD 21 2F 54  	LD IX, FRMQNT
127+  5C3E CD 59 01     	CALL CALBAS
128+  5C41 ED 53 60 5F  	LD (BLIT_STRUCT+0), DE
129+  5C45              	; comma
130+  5C45 CD 31 62     	CALL CHKCHAR
131+  5C48 2C           	DB ','
132+  5C49              	; get tile columns
133+  5C49 DD 21 2F 54  	LD IX, FRMQNT
134+  5C4D CD 59 01     	CALL CALBAS
135+  5C50 ED 53 64 5F  	LD (BLIT_STRUCT+4), DE
136+  5C54              	; comma
137+  5C54 CD 31 62     	CALL CHKCHAR
138+  5C57 2C           	DB ','
139+  5C58              	; get tile columns
140+  5C58 DD 21 2F 54  	LD IX, FRMQNT
141+  5C5C CD 59 01     	CALL CALBAS
142+  5C5F ED 53 62 5F  	LD (BLIT_STRUCT+2), DE
143+  5C63              	; comma
144+  5C63 CD 31 62     	CALL CHKCHAR
145+  5C66 2C           	DB ','
146+  5C67              	; get destintion pointer
147+  5C67 DD 21 2F 54  	LD IX, FRMQNT
148+  5C6B CD 59 01     	CALL CALBAS
149+  5C6E ED 53 66 5F  	LD (BLIT_STRUCT+6), DE
150+  5C72              	; comma
151+  5C72 CD 31 62     	CALL CHKCHAR
152+  5C75 2C           	DB ','
153+  5C76              	; get destination columns
154+  5C76 DD 21 2F 54  	LD IX, FRMQNT
155+  5C7A CD 59 01     	CALL CALBAS
156+  5C7D 7B           	LD A, E
157+  5C7E 32 5C 5F     	LD (BLIT_TMP+0), A
158+  5C81              	; comma
159+  5C81 CD 31 62     	CALL CHKCHAR
160+  5C84 2C           	DB ','
161+  5C85              	; get destination rows
162+  5C85 DD 21 2F 54  	LD IX, FRMQNT
163+  5C89 CD 59 01     	CALL CALBAS
164+  5C8C 7B           	LD A, E
165+  5C8D 32 5D 5F     	LD (BLIT_TMP+1), A
166+  5C90              	; comma
167+  5C90 CD 31 62     	CALL CHKCHAR
168+  5C93 2C           	DB ','
169+  5C94              	; get destination begin column
170+  5C94 DD 21 2F 54  	LD IX, FRMQNT
171+  5C98 CD 59 01     	CALL CALBAS
172+  5C9B 7B           	LD A, E
173+  5C9C 32 5E 5F     	LD (BLIT_TMP+2), A
174+  5C9F              	; comma
175+  5C9F CD 31 62     	CALL CHKCHAR
176+  5CA2 2C           	DB ','
177+  5CA3              	; get destination begin row
178+  5CA3 DD 21 2F 54  	LD IX, FRMQNT
179+  5CA7 CD 59 01     	CALL CALBAS
180+  5CAA 7B           	LD A, E
181+  5CAB 32 5F 5F     	LD (BLIT_TMP+3), A
182+  5CAE              	; comma
183+  5CAE CD 31 62     	CALL CHKCHAR
184+  5CB1 2C           	DB ','
185+  5CB2              	; get number of tiles horizontally
186+  5CB2 DD 21 2F 54  	LD IX, FRMQNT
187+  5CB6 CD 59 01     	CALL CALBAS
188+  5CB9 ED 53 6A 5F  	LD (BLIT_STRUCT+10), DE
189+  5CBD              	; comma
190+  5CBD CD 31 62     	CALL CHKCHAR
191+  5CC0 2C           	DB ','
192+  5CC1              	; get number of tiles vertically
193+  5CC1 DD 21 2F 54  	LD IX, FRMQNT
194+  5CC5 CD 59 01     	CALL CALBAS
195+  5CC8 ED 53 6C 5F  	LD (BLIT_STRUCT+12), DE
196+  5CCC              	; ending )
197+  5CCC CD 31 62     	CALL CHKCHAR
198+  5CCF 29           	DB ')'
199+  5CD0
200+  5CD0 E5           	PUSH HL ; save position in BASIC buffer
201+  5CD1
202+  5CD1              	; calculate destination add to value
203+  5CD1 26 00        	LD H, 0
204+  5CD3 3A 5C 5F     	LD A, (BLIT_TMP+0)
205+  5CD6 6F           	LD L, A
206+  5CD7 CD 20 61     	CALL HLx8
207+  5CDA 22 68 5F     	LD (BLIT_STRUCT+8), HL
208+  5CDD              	; calculate pointer to background location
209+  5CDD 21 00 00     	LD HL, 0
210+  5CE0 3A 5F 5F     	LD A,(BLIT_TMP+3)
211+  5CE3 B7           	OR A
212+  5CE4 28 08        	JR Z, .L1
213+  5CE6 47           	LD B,A
214+  5CE7 ED 5B 68 5F  	LD DE,(BLIT_STRUCT+8)
215+  5CEB              .L0:
216+  5CEB 19           	ADD HL, DE
217+  5CEC 10 FD        	DJNZ .L0
218+  5CEE              .L1:
219+  5CEE EB           	EX DE,HL
220+  5CEF 26 00        	LD H,0
221+  5CF1 3A 5E 5F     	LD A,(BLIT_TMP+2)
222+  5CF4 6F           	LD L,A
223+  5CF5 CD 20 61     	CALL HLx8
224+  5CF8 19           	ADD HL,DE
225+  5CF9 ED 5B 66 5F  	LD DE,(BLIT_STRUCT+6)
226+  5CFD 19           	ADD HL,DE
227+  5CFE 22 66 5F     	LD (BLIT_STRUCT+6),HL
228+  5D01
229+  5D01 FD 21 08 5D  	LD IY, .RET
230+  5D05 C3 E4 61     	JP ENABLE_PAGE0
231+  5D08              .RET:
232+  5D08 FB           	EI
233+  5D09              	; set RAM functions to call
234+  5D09 21 23 5D     	LD HL, .TILECOPY
235+  5D0C 22 17 5C     	LD (TILE.CALL2+1), HL
236+  5D0F 21 34 5D     	LD HL, .SETDESTROW
237+  5D12 22 09 5C     	LD (TILE.CALL1+1), HL
238+  5D15 DD 21 60 5F  	LD IX,BLIT_STRUCT
239+  5D19 CD EE 5B     	CALL TILE
240+  5D1C
241+  5D1C D1               POP DE
242+  5D1D C1               POP BC
243+  5D1E CD 5B 61         CALL RESTORE_PAGE_INFO
244+  5D21
245+  5D21 E1           	POP HL
246+  5D22 C9           	RET
247+  5D23              .TILECOPY:
248+  5D23 ED A0       > LDI
248+  5D25 ED A0       > LDI
248+  5D27 ED A0       > LDI
248+  5D29 ED A0       > LDI
248+  5D2B ED A0       > LDI
248+  5D2D ED A0       > LDI
248+  5D2F ED A0       > LDI
248+  5D31 ED A0       > LDI
249+  5D33 C9           	RET
250+  5D34              .SETDESTROW:
251+  5D34 ED 5B 5C 5F  	LD DE, (TILETMP1)
252+  5D38 C9           	RET
253+  5D39              ; *******************************************************************************************************
254+  5D39               ENDIF
255+  5D39
256+  5D39               IFDEF CMDS_WITH_PARAMETERS
257+  5D39              ; *******************************************************************************************************
258+  5D39              ; function to handle CALL TILEVRM basic extension
259+  5D39              ; fills vram with tiles
260+  5D39              ; TILEVRM ( INT tile_data_pointer,
261+  5D39              ;			INT tile_columns,
262+  5D39              ;			INT tile_rows,
263+  5D39              ;			INT destination_begin_column,
264+  5D39              ;			INT destination_begin_row,
265+  5D39              ;			INT number_of_tiles_horizontally,
266+  5D39              ;			INT	number_of_tiles_vertically )
267+  5D39              ; will put ram in page 0 also, page 1 is already there
268+  5D39              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5D39              TILEVRM:
270+  5D39              	; opening (
271+  5D39 CD 31 62     	CALL CHKCHAR
272+  5D3C 28           	DB '('
273+  5D3D              	; get tile data pointer coordinate
274+  5D3D DD 21 2F 54  	LD IX, FRMQNT
275+  5D41 CD 59 01     	CALL CALBAS
276+  5D44 ED 53 60 5F  	LD (BLIT_STRUCT+0), DE
277+  5D48              	; comma
278+  5D48 CD 31 62     	CALL CHKCHAR
279+  5D4B 2C           	DB ','
280+  5D4C              	; get tile columns
281+  5D4C DD 21 2F 54  	LD IX, FRMQNT
282+  5D50 CD 59 01     	CALL CALBAS
283+  5D53 ED 53 64 5F  	LD (BLIT_STRUCT+4), DE
284+  5D57              	; comma
285+  5D57 CD 31 62     	CALL CHKCHAR
286+  5D5A 2C           	DB ','
287+  5D5B              	; get tile columns
288+  5D5B DD 21 2F 54  	LD IX, FRMQNT
289+  5D5F CD 59 01     	CALL CALBAS
290+  5D62 ED 53 62 5F  	LD (BLIT_STRUCT+2), DE
291+  5D66              	; comma
292+  5D66 CD 31 62     	CALL CHKCHAR
293+  5D69 2C           	DB ','
294+  5D6A              	; get destination begin column
295+  5D6A DD 21 2F 54  	LD IX, FRMQNT
296+  5D6E CD 59 01     	CALL CALBAS
297+  5D71 7B           	LD A, E
298+  5D72 32 5E 5F     	LD (BLIT_TMP+2), A
299+  5D75              	; comma
300+  5D75 CD 31 62     	CALL CHKCHAR
301+  5D78 2C           	DB ','
302+  5D79              	; get destination begin row
303+  5D79 DD 21 2F 54  	LD IX, FRMQNT
304+  5D7D CD 59 01     	CALL CALBAS
305+  5D80 7B           	LD A, E
306+  5D81 32 5F 5F     	LD (BLIT_TMP+3), A
307+  5D84              	; comma
308+  5D84 CD 31 62     	CALL CHKCHAR
309+  5D87 2C           	DB ','
310+  5D88              	; get number of tiles horizontally
311+  5D88 DD 21 2F 54  	LD IX, FRMQNT
312+  5D8C CD 59 01     	CALL CALBAS
313+  5D8F ED 53 6A 5F  	LD (BLIT_STRUCT+10), DE
314+  5D93              	; comma
315+  5D93 CD 31 62     	CALL CHKCHAR
316+  5D96 2C           	DB ','
317+  5D97              	; get number of tiles vertically
318+  5D97 DD 21 2F 54  	LD IX, FRMQNT
319+  5D9B CD 59 01     	CALL CALBAS
320+  5D9E ED 53 6C 5F  	LD (BLIT_STRUCT+12), DE
321+  5DA2              	; ending )
322+  5DA2 CD 31 62     	CALL CHKCHAR
323+  5DA5 29           	DB ')'
324+  5DA6
325+  5DA6 E5           	PUSH HL ; save position in BASIC buffer
326+  5DA7
327+  5DA7              	; calculate destination add to value
328+  5DA7 21 00 01     	LD HL, 256
329+  5DAA 22 68 5F     	LD (BLIT_STRUCT+8), HL
330+  5DAD              	; calculate pointer to background location
331+  5DAD 3A 5F 5F     	LD A,(BLIT_TMP+3)
332+  5DB0 67           	LD H,A
333+  5DB1 2E 00        	LD L,0
334+  5DB3 EB           	EX DE,HL
335+  5DB4 26 00        	LD H,0
336+  5DB6 3A 5E 5F     	LD A,(BLIT_TMP+2)
337+  5DB9 6F           	LD L,A
338+  5DBA CD 20 61     	CALL HLx8
339+  5DBD 19           	ADD HL,DE
340+  5DBE ED 5B CB F3  	LD DE,(GRPCGP)
341+  5DC2 19           	ADD HL,DE
342+  5DC3 22 66 5F     	LD (BLIT_STRUCT+6),HL
343+  5DC6
344+  5DC6 FD 21 CD 5D  	LD IY, .RET
345+  5DCA C3 E4 61     	JP ENABLE_PAGE0
346+  5DCD              .RET:
347+  5DCD FB           	EI
348+  5DCE              	; set RAM functions to call
349+  5DCE 21 E8 5D     	LD HL, .TILECOPY
350+  5DD1 22 17 5C     	LD (TILE.CALL2+1), HL
351+  5DD4 21 EE 5D     	LD HL, .SETDESTROW
352+  5DD7 22 09 5C     	LD (TILE.CALL1+1), HL
353+  5DDA DD 21 60 5F  	LD IX,BLIT_STRUCT
354+  5DDE CD EE 5B     	CALL TILE
355+  5DE1
356+  5DE1 D1               POP DE
357+  5DE2 C1               POP BC
358+  5DE3 CD 5B 61         CALL RESTORE_PAGE_INFO
359+  5DE6
360+  5DE6 E1           	POP HL
361+  5DE7 C9           	RET
362+  5DE8              .TILECOPY:
363+  5DE8 01 98 08     	LD BC, #0898
364+  5DEB C3 18 61     	JP BBYTECOPY_NO_C
365+  5DEE              .SETDESTROW:
366+  5DEE 2A 5C 5F     	LD HL, (TILETMP1)
367+  5DF1 F3           	DI
368+  5DF2 CD 0B 61     	CALL SETWRT_LOCAL
369+  5DF5 FB           	EI
370+  5DF6 C9           	RET
371+  5DF7              ; *******************************************************************************************************
372+  5DF7               ENDIF
373+  5DF7
374+  5DF7               IFNDEF CMDS_WITH_PARAMETERS
375+  5DF7 ~            ; *******************************************************************************************************
376+  5DF7 ~            ; function to handle CALL TILEVRM basic extension
377+  5DF7 ~            ; fills vram with tiles
378+  5DF7 ~            ; TILEVRM ( INT request_data_ptr )
379+  5DF7 ~            ; request_data_ptr described in TILE
380+  5DF7 ~            ; will put ram in page 0 also, page 1 is already there
381+  5DF7 ~            TILEVRM:
382+  5DF7 ~            	; opening (
383+  5DF7 ~            	CALL CHKCHAR
384+  5DF7 ~            	DB '('
385+  5DF7 ~            	; get pointer to request struct
386+  5DF7 ~            	LD IX, FRMQNT
387+  5DF7 ~            	CALL CALBAS
388+  5DF7 ~            	PUSH DE
389+  5DF7 ~            	; ending )
390+  5DF7 ~            	CALL CHKCHAR
391+  5DF7 ~            	DB ')'
392+  5DF7 ~
393+  5DF7 ~            	POP IX ; pointer to request struct
394+  5DF7 ~
395+  5DF7 ~            	PUSH HL ; save position in BASIC buffer
396+  5DF7 ~
397+  5DF7 ~            	LD IY, .RET
398+  5DF7 ~            	JP ENABLE_PAGE0
399+  5DF7 ~            .RET:
400+  5DF7 ~            	EI
401+  5DF7 ~            	; set RAM functions to call
402+  5DF7 ~            	LD HL, .TILECOPY
403+  5DF7 ~            	LD (TILE.CALL2+1), HL
404+  5DF7 ~            	LD HL, .SETDESTROW
405+  5DF7 ~            	LD (TILE.CALL1+1), HL
406+  5DF7 ~            	CALL TILE
407+  5DF7 ~
408+  5DF7 ~                POP DE
409+  5DF7 ~                POP BC
410+  5DF7 ~                CALL RESTORE_PAGE_INFO
411+  5DF7 ~
412+  5DF7 ~            	POP HL
413+  5DF7 ~            	RET
414+  5DF7 ~            .TILECOPY:
415+  5DF7 ~            	LD BC, #0898
416+  5DF7 ~            	JP BBYTECOPY_NO_C
417+  5DF7 ~            .SETDESTROW:
418+  5DF7 ~            	LD HL, (TILETMP1)
419+  5DF7 ~            	DI
420+  5DF7 ~            	CALL SETWRT_LOCAL
421+  5DF7 ~            	EI
422+  5DF7 ~            	RET
423+  5DF7 ~            ; *******************************************************************************************************
424+  5DF7               ENDIF
# file closed: asm\TILE.asm
153   5DF7               ENDIF
154   5DF7
155   5DF7               IF (BYTEOPS_CMDS == 1)
156   5DF7 ~             INCLUDE "BYTEOPS.asm"
157   5DF7               ENDIF
158   5DF7
159   5DF7               IF (COLL_CMD == 1)
160   5DF7               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
  1+  5DF7              ; ************************************************************************************************
  2+  5DF7              ; quick test if HL<=DE<=HL+BC
  3+  5DF7              ; input BC=width, DE=x, HL=min
  4+  5DF7              ; if not true flag C set
  5+  5DF7              ; modifies AF
  6+  5DF7              GENERIC_INNER_CHECK:
  7+  5DF7 E5               PUSH HL
  8+  5DF8 A7               AND A
  9+  5DF9 ED 52            SBC HL, DE
 10+  5DFB F2 07 5E         JP P, .GENERIC_INNER_CHECK_NOT
 11+  5DFE A7               AND A
 12+  5DFF ED 4A            ADC HL, BC
 13+  5E01 FA 07 5E         JP M, .GENERIC_INNER_CHECK_NOT
 14+  5E04 A7               AND A
 15+  5E05 18 01            JR .EXIT
 16+  5E07              .GENERIC_INNER_CHECK_NOT:
 17+  5E07 37               SCF
 18+  5E08              .EXIT:
 19+  5E08 E1               POP HL
 20+  5E09 C9               RET
 21+  5E0A              ; ************************************************************************************************
 22+  5E0A
 23+  5E0A              ; ************************************************************************************************
 24+  5E0A              ; function to check if rectangles are overlapping
 25+  5E0A              ; input IX=pointer to struct
 26+  5E0A              ;  +00 active flag
 27+  5E0A              ;  +02 x coordinate
 28+  5E0A              ;  +04 y coordinate
 29+  5E0A              ;  +06 x offset where rectangle begins
 30+  5E0A              ;  +08 y offset where rectangle begins
 31+  5E0A              ;  +10 width
 32+  5E0A              ;  +12 height
 33+  5E0A              ; input BLIT_STRUCT data
 34+  5E0A              ;  +00 x coordinate
 35+  5E0A              ;  +02 y coordinate
 36+  5E0A              ;  +04 width
 37+  5E0A              ;  +06 height
 38+  5E0A              ; returns CF=1 if not overlapping, CF=0 if overlapping
 39+  5E0A              RECTANGLE_OVERLAP_CHECK:
 40+  5E0A                  ; first check which rectanlge is higher
 41+  5E0A DD 6E 0C         LD L,(IX+12)
 42+  5E0D DD 66 0D         LD H,(IX+13)
 43+  5E10 ED 5B 66 5F      LD DE,(BLIT_STRUCT+6)
 44+  5E14 A7               AND A
 45+  5E15 ED 52            SBC HL,DE
 46+  5E17 DD 6E 04         LD L,(IX+4)
 47+  5E1A DD 66 05         LD H,(IX+5)
 48+  5E1D DD 5E 08         LD E,(IX+8)
 49+  5E20 DD 56 09         LD D,(IX+9)
 50+  5E23 FA 43 5E         JP M,.L1
 51+  5E26                  ; equally high or IX defined one higher
 52+  5E26                  ; check upper boundary
 53+  5E26 19               ADD HL,DE
 54+  5E27 ED 5B 62 5F      LD DE,(BLIT_STRUCT+2)
 55+  5E2B DD 4E 0C         LD C,(IX+12)
 56+  5E2E DD 46 0D         LD B,(IX+13)
 57+  5E31 CD F7 5D         CALL GENERIC_INNER_CHECK
 58+  5E34 30 29            JR NC,.INSIDE
 59+  5E36                  ; check lower boundary
 60+  5E36 E5               PUSH HL
 61+  5E37 2A 66 5F         LD HL,(BLIT_STRUCT+6)
 62+  5E3A 19               ADD HL,DE
 63+  5E3B EB               EX DE,HL
 64+  5E3C E1               POP HL
 65+  5E3D CD F7 5D         CALL GENERIC_INNER_CHECK
 66+  5E40 30 1D            JR NC,.INSIDE
 67+  5E42 C9               RET ; not overlapping
 68+  5E43              .L1:
 69+  5E43                  ; rectangle defined in BLIT_STRUCT is higher
 70+  5E43 19               ADD HL,DE
 71+  5E44 EB               EX DE,HL
 72+  5E45 2A 62 5F         LD HL,(BLIT_STRUCT+2)
 73+  5E48 ED 4B 66 5F      LD BC,(BLIT_STRUCT+6)
 74+  5E4C CD F7 5D         CALL GENERIC_INNER_CHECK
 75+  5E4F 30 0E            JR NC,.INSIDE
 76+  5E51 E5               PUSH HL
 77+  5E52 DD 6E 0C         LD L,(IX+12)
 78+  5E55 DD 66 0D         LD H,(IX+13)
 79+  5E58 19               ADD HL,DE
 80+  5E59 EB               EX DE,HL
 81+  5E5A E1               POP HL
 82+  5E5B CD F7 5D         CALL GENERIC_INNER_CHECK
 83+  5E5E D8               RET C
 84+  5E5F              .INSIDE:
 85+  5E5F                  ; check x coordinate
 86+  5E5F                  ; first check which rectangle is wider
 87+  5E5F DD 6E 0A         LD L,(IX+10)
 88+  5E62 DD 66 0B         LD H,(IX+11)
 89+  5E65 ED 5B 64 5F      LD DE,(BLIT_STRUCT+4)
 90+  5E69 A7               AND A
 91+  5E6A ED 52            SBC HL,DE
 92+  5E6C DD 6E 02         LD L,(IX+2)
 93+  5E6F DD 66 03         LD H,(IX+3)
 94+  5E72 DD 5E 06         LD E,(IX+6)
 95+  5E75 DD 56 07         LD D,(IX+7)
 96+  5E78 FA 94 5E         JP M,.L2
 97+  5E7B                  ; equally wide or IX defined one wider
 98+  5E7B                  ; check left boundary
 99+  5E7B 19               ADD HL,DE
100+  5E7C ED 5B 60 5F      LD DE,(BLIT_STRUCT+0)
101+  5E80 DD 4E 0A         LD C,(IX+10)
102+  5E83 DD 46 0B         LD B,(IX+11)
103+  5E86 CD F7 5D         CALL GENERIC_INNER_CHECK
104+  5E89 D0               RET NC ; overlap
105+  5E8A                  ; check right boundary
106+  5E8A E5               PUSH HL
107+  5E8B 2A 64 5F         LD HL,(BLIT_STRUCT+4)
108+  5E8E 19               ADD HL,DE
109+  5E8F EB               EX DE,HL
110+  5E90 E1               POP HL
111+  5E91 C3 F7 5D         JP GENERIC_INNER_CHECK ; CF and result set by fn call
112+  5E94              .L2:
113+  5E94                  ; rectangle defined in BLIT_STRUCT is higher
114+  5E94 19               ADD HL,DE
115+  5E95 EB               EX DE,HL
116+  5E96 2A 60 5F         LD HL,(BLIT_STRUCT+0)
117+  5E99 ED 4B 64 5F      LD BC,(BLIT_STRUCT+4)
118+  5E9D CD F7 5D         CALL GENERIC_INNER_CHECK
119+  5EA0 D0               RET NC ; overlap
120+  5EA1 E5               PUSH HL
121+  5EA2 DD 6E 0A         LD L,(IX+10)
122+  5EA5 DD 66 0B         LD H,(IX+11)
123+  5EA8 19               ADD HL,DE
124+  5EA9 EB               EX DE,HL
125+  5EAA E1               POP HL
126+  5EAB C3 F7 5D         JP GENERIC_INNER_CHECK
127+  5EAE              ; ************************************************************************************************
128+  5EAE
129+  5EAE              ; ************************************************************************************************
130+  5EAE              ; function tries to find rectangle overlap and returns an index if found
131+  5EAE              ; input BLIT_STRUCT data
132+  5EAE              ;  +00 x coordinate
133+  5EAE              ;  +02 y coordinate
134+  5EAE              ;  +04 width
135+  5EAE              ;  +06 height
136+  5EAE              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
137+  5EAE              ;  +09 pointer to first element
138+  5EAE              ;  +11 pointer to INT result variable
139+  5EAE              ; returns CF=1 if not overlapping
140+  5EAE              ; returns A=list index and CF=0 if overlapping
141+  5EAE              FIND_OVERLAP:
142+  5EAE 3A 68 5F         LD A,(BLIT_STRUCT+8)
143+  5EB1 47               LD B,A
144+  5EB2 DD 2A 69 5F      LD IX,(BLIT_STRUCT+9)
145+  5EB6              .L1:
146+  5EB6 C5               PUSH BC
147+  5EB7 DD 7E 00         LD A,(IX)
148+  5EBA DD B6 01         OR (IX+1)
149+  5EBD 28 0C            JR Z,.NEXT
150+  5EBF CD 0A 5E         CALL RECTANGLE_OVERLAP_CHECK
151+  5EC2 38 07            JR C,.NEXT
152+  5EC4                  ; found
153+  5EC4 C1               POP BC
154+  5EC5 3A 68 5F         LD A,(BLIT_STRUCT+8)
155+  5EC8 90               SUB B
156+  5EC9 A7               AND A
157+  5ECA C9               RET
158+  5ECB              .NEXT:
159+  5ECB 11 0E 00         LD DE,14
160+  5ECE DD 19            ADD IX,DE
161+  5ED0 C1               POP BC
162+  5ED1 10 E3            DJNZ .L1
163+  5ED3 37               SCF
164+  5ED4 C9               RET
165+  5ED5              ; ************************************************************************************************
166+  5ED5
167+  5ED5              ; ************************************************************************************************
168+  5ED5              ; function to handle CALL COLL basic extension
169+  5ED5              ; checks for collision between player and other rectangles
170+  5ED5              ; COLL ( INT result variable,
171+  5ED5              ;	     INT player x value,
172+  5ED5              ;	     INT player y value,
173+  5ED5              ;	     INT player width,
174+  5ED5              ;	     INT player height,
175+  5ED5              ;	     INT number of items in a list,
176+  5ED5              ;		 INT[6][n] rectangle struct )
177+  5ED5              ; will fill result variable with index or -1 if no collision
178+  5ED5              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
179+  5ED5              COLL:
180+  5ED5              	; opening (
181+  5ED5 CD 31 62     	CALL CHKCHAR
182+  5ED8 28           	DB '('
183+  5ED9              	; get address of result variable
184+  5ED9 DD 21 A4 5E  	LD IX, PTRGET
185+  5EDD CD 59 01     	CALL CALBAS
186+  5EE0 ED 53 6B 5F  	LD (BLIT_STRUCT+11),DE
187+  5EE4              	; comma
188+  5EE4 CD 31 62     	CALL CHKCHAR
189+  5EE7 2C           	DB ','
190+  5EE8              	; get x
191+  5EE8 DD 21 2F 54  	LD IX, FRMQNT
192+  5EEC CD 59 01     	CALL CALBAS
193+  5EEF ED 53 60 5F  	LD (BLIT_STRUCT+0),DE
194+  5EF3              	; comma
195+  5EF3 CD 31 62     	CALL CHKCHAR
196+  5EF6 2C           	DB ','
197+  5EF7              	; get y
198+  5EF7 DD 21 2F 54  	LD IX, FRMQNT
199+  5EFB CD 59 01     	CALL CALBAS
200+  5EFE ED 53 62 5F  	LD (BLIT_STRUCT+2),DE
201+  5F02              	; comma
202+  5F02 CD 31 62     	CALL CHKCHAR
203+  5F05 2C           	DB ','
204+  5F06              	; get width
205+  5F06 DD 21 2F 54  	LD IX, FRMQNT
206+  5F0A CD 59 01     	CALL CALBAS
207+  5F0D ED 53 64 5F  	LD (BLIT_STRUCT+4),DE
208+  5F11              	; comma
209+  5F11 CD 31 62     	CALL CHKCHAR
210+  5F14 2C           	DB ','
211+  5F15              	; get height
212+  5F15 DD 21 2F 54  	LD IX, FRMQNT
213+  5F19 CD 59 01     	CALL CALBAS
214+  5F1C ED 53 66 5F  	LD (BLIT_STRUCT+6),DE
215+  5F20              	; comma
216+  5F20 CD 31 62     	CALL CHKCHAR
217+  5F23 2C           	DB ','
218+  5F24              	; get number of items in a list
219+  5F24 DD 21 1C 52  	LD IX, GETBYT
220+  5F28 CD 59 01     	CALL CALBAS
221+  5F2B 32 68 5F     	LD (BLIT_STRUCT+8),A
222+  5F2E              	; comma
223+  5F2E CD 31 62     	CALL CHKCHAR
224+  5F31 2C           	DB ','
225+  5F32              	; get address of rectangle structure array DIM R%(6,n)
226+  5F32 3A 68 5F     	LD A,(BLIT_STRUCT+8)
227+  5F35 5F               LD E,A
228+  5F36 3E 02            LD A,2
229+  5F38 47           	LD B,A
230+  5F39 16 07        	LD D,7
231+  5F3B CD 5C 62     	CALL GET_BASIC_ARRAY_DATA_POINTER
232+  5F3E ED 43 69 5F  	LD (BLIT_STRUCT+9),BC
233+  5F42              	; ending )
234+  5F42 CD 31 62     	CALL CHKCHAR
235+  5F45 29           	DB ')'
236+  5F46
237+  5F46 E5               PUSH HL
238+  5F47 CD AE 5E         CALL FIND_OVERLAP
239+  5F4A 2A 6B 5F         LD HL,(BLIT_STRUCT+11)
240+  5F4D 38 06            JR C,.NOTFOUND
241+  5F4F 77               LD (HL),A
242+  5F50 23               INC HL
243+  5F51 36 00            LD (HL),0
244+  5F53 E1               POP HL
245+  5F54 C9               RET
246+  5F55              .NOTFOUND:
247+  5F55 36 FF            LD (HL),#FF
248+  5F57 23               INC HL
249+  5F58 36 FF            LD (HL),#FF
250+  5F5A E1               POP HL
251+  5F5B C9               RET
252+  5F5C              ; ************************************************************************************************
253+  5F5C
# file closed: asm\COLLISION.asm
161   5F5C               ENDIF
162   5F5C
163   5F5C              ; temp variables for BLIT, TILE functions
164   5F5C               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
165   5F5C              BLIT_TMP:
166   5F5C              TILETMP1:
167   5F5C              BLIT_TMP1:
168   5F5C 00 00         DW 0
169   5F5E              TILETMP2:
170   5F5E              BLIT_TMP2:
171   5F5E 00 00         DW 0
172   5F60                IFDEF CMDS_WITH_PARAMETERS
173   5F60              BLIT_STRUCT:
174   5F60 00 00 00...   DS 17
175   5F64                ENDIF
176   5F64               ENDIF
177   5F71
178   5F71               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
179   5F71              VRAM_UPDATE_IN_PROGRESS:
180   5F71 00            DB 0
181   5F72               ENDIF
182   5F72
183   5F72              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
184   5F72              ; per starting letter, if no commands with this letter, NULL value
185   5F72              CMDS:
186   5F72               IF (ANIM_CMDS == 1)
187   5F72 A2 60        	DW CMDS_A ;
188   5F74               ELSE
189   5F74 ~                DW 0 ; A
190   5F74               ENDIF
191   5F74               IF (BLIT_CMDS + BOX_CMDS > 0)
192   5F74 6D 60            DW CMDS_B ; B
193   5F76               ELSE
194   5F76 ~            	DW 0
195   5F76               ENDIF
196   5F76               IF (COLL_CMD == 1)
197   5F76 03 61        	DW CMDS_C ;
198   5F78               ELSE
199   5F78 ~                DW 0 ; C
200   5F78               ENDIF
201   5F78 00 00            DW 0 ; D
202   5F7A 00 00            DW 0 ; E
203   5F7C               IF (VRAM_CMDS + RAM_CMDS > 0)
204   5F7C E4 5F            DW CMDS_F; F
205   5F7E               ELSE
206   5F7E ~            	DW 0
207   5F7E               ENDIF
208   5F7E               IF (GENCAL_CMD > 0)
209   5F7E F7 5F            DW CMDS_G; G
210   5F80               ELSE
211   5F80 ~            	DW 0
212   5F80               ENDIF
213   5F80               IF (BYTEOPS_CMDS == 1)
214   5F80 ~                DW CMDS_H; H
215   5F80               ELSE
216   5F80 00 00            DW 0
217   5F82               ENDIF
218   5F82 00 00            DW 0 ; I
219   5F84 00 00            DW 0 ; J
220   5F86 00 00            DW 0 ; K
221   5F88               IF (BYTEOPS_CMDS == 1)
222   5F88 ~                DW CMDS_L; L
223   5F88               ELSE
224   5F88 00 00            DW 0
225   5F8A               ENDIF
226   5F8A               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
227   5F8A A6 5F            DW CMDS_M ; M
228   5F8C               ELSE
229   5F8C ~            	DW 0
230   5F8C               ENDIF
231   5F8C 00 00            DW 0 ; N
232   5F8E 00 00            DW 0 ; O
233   5F90 00 00            DW 0 ; P
234   5F92 00 00            DW 0 ; Q
235   5F94               IF (BYTEOPS_CMDS == 1)
236   5F94 ~                DW CMDS_R; R
237   5F94               ELSE
238   5F94 00 00            DW 0
239   5F96               ENDIF
240   5F96               IF (SOUND_CMDS + SPRITE_CMDS > 0)
241   5F96 0B 60            DW CMDS_S ; S
242   5F98               ELSE
243   5F98 ~            	DW 0
244   5F98               ENDIF
245   5F98               IF (TILE_CMDS > 0)
246   5F98 8D 60            DW CMDS_T ; T
247   5F9A               ELSE
248   5F9A ~            	DW 0
249   5F9A               ENDIF
250   5F9A 00 00            DW 0 ; U
251   5F9C               IF (VRAM_CMDS > 0)
252   5F9C 01 60            DW CMDS_V ; V
253   5F9E               ELSE
254   5F9E ~            	DW 0
255   5F9E               ENDIF
256   5F9E               IF (BYTEOPS_CMDS == 1)
257   5F9E ~                DW CMDS_W; W
258   5F9E               ELSE
259   5F9E 00 00            DW 0
260   5FA0               ENDIF
261   5FA0 00 00            DW 0 ; X
262   5FA2 00 00            DW 0 ; Y
263   5FA4 00 00            DW 0 ; Z
264   5FA6
265   5FA6              CMDS_M:
266   5FA6               IF (VRAM_CMDS == 1)
267   5FA6 4D 45 4D 56      DB "MEMVRM", 0
267   5FAA 52 4D 00
268   5FAD 3C 57            DW MEMVRM
269   5FAF               ENDIF
270   5FAF               IF (RAM_CMDS == 1)
271   5FAF 4D 45 4D 43  	DB "MEMCPY", 0
271   5FB3 50 59 00
272   5FB6 72 55        	DW MEMCPY
273   5FB8               ENDIF
274   5FB8               IF (ANIM_CMDS == 1)
275   5FB8 4D 41 58 41  	DB "MAXANIMITEMS",0
275   5FBC 4E 49 4D 49
275   5FC0 54 45 4D 53
275   5FC4 00
276   5FC5 EF 4F        	DW MAXANIMITEMS
277   5FC7 4D 41 58 41  	DB "MAXANIMDEFS",0
277   5FCB 4E 49 4D 44
277   5FCF 45 46 53 00
278   5FD3 64 51        	DW MAXANIMDEFS
279   5FD5 4D 41 58 41  	DB "MAXANIMSPRS",0
279   5FD9 4E 49 4D 53
279   5FDD 50 52 53 00
280   5FE1 F9 51        	DW MAXANIMSPRS
281   5FE3               ENDIF
282   5FE3               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
283   5FE3 00           	DB 0
284   5FE4               ENDIF
285   5FE4              CMDS_F:
286   5FE4               IF (VRAM_CMDS == 1)
287   5FE4 46 49 4C 56      DB "FILVRM", 0
287   5FE8 52 4D 00
288   5FEB EC 56            DW FILVRM
289   5FED               ENDIF
290   5FED               IF (RAM_CMDS == 1)
291   5FED 46 49 4C 52      DB "FILRAM", 0
291   5FF1 41 4D 00
292   5FF4 B5 55            DW FILRAM
293   5FF6               ENDIF
294   5FF6               IF (VRAM_CMDS + RAM_CMDS > 0)
295   5FF6 00               DB 0
296   5FF7               ENDIF
297   5FF7              CMDS_G:
298   5FF7               IF (GENCAL_CMD == 1)
299   5FF7 47 45 4E 43      DB "GENCAL", 0
299   5FFB 41 4C 00
300   5FFE 20 58            DW GENCAL
301   6000               ENDIF
302   6000               IF (GENCAL_CMD > 0)
303   6000 00           	DB	0
304   6001               ENDIF
305   6001              CMDS_V:
306   6001               IF (VRAM_CMDS == 1)
307   6001 56 52 4D 4D  	DB "VRMMEM", 0
307   6005 45 4D 00
308   6008 BB 57        	DW VRMMEM
309   600A               ENDIF
310   600A               IF (VRAM_CMDS > 0)
311   600A 00           	DB 0
312   600B               ENDIF
313   600B              CMDS_S:
314   600B               IF (SPRITE_CMDS + ANIM_CMDS > 0)
315   600B 53 47 41 4D      DB "SGAM",0
315   600F 00
316   6010 BA 54            DW SGAM
317   6012               ENDIF
318   6012               IF (SPRITE_CMDS == 1)
319   6012 53 50 52 53   	DB "SPRSET", 0
319   6016 45 54 00
320   6019 81 4E        	DW SPRSET
321   601B 53 50 52 47  	DB "SPRGRPMOV", 0
321   601F 52 50 4D 4F
321   6023 56 00
322   6025 32 4F        	DW SPRGRPMOV
323   6027               ENDIF
324   6027               IF (SOUND_CMDS == 1)
325   6027 53 4E 44 53  	DB "SNDSFX", 0
325   602B 46 58 00
326   602E 92 56        	DW SNDSFX
327   6030 53 4E 44 50  	DB "SNDPLYON", 0
327   6034 4C 59 4F 4E
327   6038 00
328   6039 5C 56        	DW SNDPLYON
329   603B 53 4E 44 50  	DB "SNDPLYOFF", 0
329   603F 4C 59 4F 46
329   6043 46 00
330   6045 6F 56        	DW SNDPLYOFF
331   6047 53 4E 44 50  	DB "SNDPLYINI", 0
331   604B 4C 59 49 4E
331   604F 49 00
332   6051 12 56        	DW SNDPLYINIT
333   6053               ENDIF
334   6053               IF (SPRITE_CMDS == 1)
335   6053 53 50 52 45  	DB "SPRENABLE", 0
335   6057 4E 41 42 4C
335   605B 45 00
336   605D 3C 4E        	DW SPRENABLE
337   605F 53 50 52 44  	DB "SPRDISABLE", 0
337   6063 49 53 41 42
337   6067 4C 45 00
338   606A 7C 4E        	DW SPRDISABLE
339   606C               ENDIF
340   606C               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
341   606C 00           	DB 0
342   606D               ENDIF
343   606D              CMDS_B:
344   606D               IF (BLIT_CMDS == 1)
345   606D 42 4C 49 54  	DB "BLIT", 0
345   6071 00
346   6072 F2 5A        	DW BLIT
347   6074               ENDIF
348   6074               IF (BOX_CMDS == 1)
349   6074 42 4F 58 4D  	DB "BOXMEMCPY", 0
349   6078 45 4D 43 50
349   607C 59 00
350   607E AF 58        	DW BOXMEMCPY
351   6080 42 4F 58 4D  	DB "BOXMEMVRM", 0
351   6084 45 4D 56 52
351   6088 4D 00
352   608A 44 59        	DW BOXMEMVRM
353   608C               ENDIF
354   608C               IF (BLIT_CMDS + BOX_CMDS > 0)
355   608C 00           	DB 0
356   608D               ENDIF
357   608D              CMDS_T:
358   608D               IF (TILE_CMDS == 1)
359   608D 54 49 4C 45  	DB "TILERAM", 0
359   6091 52 41 4D 00
360   6095 36 5C        	DW TILERAM
361   6097 54 49 4C 45  	DB "TILEVRM", 0
361   609B 56 52 4D 00
362   609F 39 5D        	DW TILEVRM
363   60A1               ENDIF
364   60A1               IF (TILE_CMDS > 0)
365   60A1 00           	DB 0
366   60A2               ENDIF
367   60A2              CMDS_A:
368   60A2               IF (ANIM_CMDS == 1)
369   60A2 41 4E 49 4D      DB "ANIMSTEP",0
369   60A6 53 54 45 50
369   60AA 00
370   60AB 40 53            DW ANIMSTEP
371   60AD 41 4E 49 4D  	DB "ANIMSTART",0
371   60B1 53 54 41 52
371   60B5 54 00
372   60B7 45 53        	DW ANIMSTART
373   60B9 41 4E 49 4D  	DB "ANIMSTOP",0
373   60BD 53 54 4F 50
373   60C1 00
374   60C2 4A 53        	DW ANIMSTOP
375   60C4 41 4E 49 4D  	DB "ANIMITEMPAT",0
375   60C8 49 54 45 4D
375   60CC 50 41 54 00
376   60D0 AF 50        	DW ANIMITEMPAT
377   60D2 41 4E 49 4D  	DB "ANIMITEMPTR",0
377   60D6 49 54 45 4D
377   60DA 50 54 52 00
378   60DE 10 51        	DW ANIMITEMPTR_CMD
379   60E0 41 4E 49 4D  	DB "ANIMDEF",0
379   60E4 44 45 46 00
380   60E8 A6 51        	DW ANIMDEF
381   60EA 41 4E 49 4D  	DB "ANIMSPRITE",0
381   60EE 53 50 52 49
381   60F2 54 45 00
382   60F5 4F 52        	DW ANIMSPRITE
383   60F7 41 4E 49 4D      DB "ANIMCHAR",0
383   60FB 43 48 41 52
383   60FF 00
384   6100 C7 52            DW ANIMCHAR
385   6102 00           	DB 0
386   6103               ENDIF
387   6103              CMDS_H:
388   6103               IF (BYTEOPS_CMDS == 1)
389   6103 ~                DB "HI", 0
390   6103 ~                DW HI
391   6103               ENDIF
392   6103               IF (BYTEOPS_CMDS > 0)
393   6103 ~            	DB	0
394   6103               ENDIF
395   6103              CMDS_L:
396   6103               IF (BYTEOPS_CMDS == 1)
397   6103 ~                DB "LO", 0
398   6103 ~                DW LO
399   6103               ENDIF
400   6103               IF (BYTEOPS_CMDS > 0)
401   6103 ~            	DB	0
402   6103               ENDIF
403   6103              CMDS_W:
404   6103               IF (BYTEOPS_CMDS == 1)
405   6103 ~                DB "W", 0
406   6103 ~                DW WORD
407   6103               ENDIF
408   6103               IF (BYTEOPS_CMDS > 0)
409   6103 ~            	DB	0
410   6103               ENDIF
411   6103              CMDS_R:
412   6103               IF (BYTEOPS_CMDS == 1)
413   6103 ~                DB "RANGE", 0
414   6103 ~                DW RANGE
415   6103               ENDIF
416   6103               IF (BYTEOPS_CMDS > 0)
417   6103 ~            	DB	0
418   6103               ENDIF
419   6103              CMDS_C:
420   6103               IF (COLL_CMD == 1)
421   6103 43 4F 4C 4C      DB "COLL", 0
421   6107 00
422   6108 D5 5E            DW COLL
423   610A               ENDIF
424   610A               IF (COLL_CMD > 0)
425   610A 00           	DB	0
426   610B               ENDIF
427   610B
428   610B               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
429   610B              ; ****************************************************************************************************
430   610B              ; function sets VRAM address
431   610B              ; input HL=address
432   610B              ; modifies AF
433   610B              SETWRT_LOCAL:
434   610B 7D           	LD	A, L
435   610C D3 99        	OUT	(099H), A
436   610E 7C           	LD	A, H
437   610F E6 3F        	AND	03FH
438   6111 F6 40        	OR	040H
439   6113 D3 99        	OUT	(099H), A
440   6115 C9           	RET
441   6116              ; ****************************************************************************************************
442   6116               ENDIF
443   6116
444   6116               IF (VRAM_CMDS + TILE_CMDS > 0)
445   6116              ; ****************************************************************************************************
446   6116              ; function copies data from RAM to VRAM
447   6116              ; input HL=address in RAM
448   6116              ; input B=count
449   6116              ; modifies AF, BC, HL
450   6116              BBYTECOPY:
451   6116 0E 98        	LD C,#98
452   6118              BBYTECOPY_NO_C:
453   6118 ED A3        	OUTI
454   611A C2 18 61     	JP	NZ, BBYTECOPY_NO_C
455   611D C9           	RET
456   611E              ; ****************************************************************************************************
457   611E               ENDIF
458   611E
459   611E              ; ****************************************************************************************************
460   611E              ; function multiplies HL by 32
461   611E              HLx32:
462   611E 29           	ADD HL,HL
463   611F              ; ****************************************************************************************************
464   611F              ; function multiplies HL by 16
465   611F              HLx16:
466   611F 29           	ADD HL,HL
467   6120              ; ****************************************************************************************************
468   6120              ; function multiplies HL by 8
469   6120              HLx8:
470   6120 29          > ADD HL, HL
470   6121 29          > ADD HL, HL
470   6122 29          > ADD HL, HL
471   6123 C9           	RET
472   6124              ; ****************************************************************************************************
473   6124
474   6124              ; ****************************************************************************************************
475   6124              ; function gets slot and subslot data for specific page
476   6124              ; input A=page (0, 1 or 2)
477   6124              ; output B = 0A8H register value
478   6124              ; output D = 0 is no subslots, 1 if yes
479   6124              ; output C = 0A8H value when page 3 slot equals to requested page slot
480   6124              ; output E = subslot value if present
481   6124              ; modifies AF, BC, DE, HL
482   6124              GET_PAGE_INFO:
483   6124 6F               LD L, A
484   6125 C6 C1            ADD A, low (EXPTBL)
485   6127 32 31 61         LD (GET_PAGE_INFO_L1+1), A
486   612A DB A8            IN A, (0A8H)
487   612C 47               LD B, A
488   612D E6 3F            AND 03FH
489   612F 4F               LD C, A
490   6130              GET_PAGE_INFO_L1:
491   6130 3A C1 FC         LD A, (EXPTBL) ; modified by code above
492   6133 E6 80            AND 080H
493   6135 28 1B            JR Z, GET_PAGE_INFO_L2
494   6137                  ; expanded
495   6137 2D               DEC L
496   6138 FA 57 61         JP M, GET_PAGE_INFO_L3
497   613B 2D               DEC L
498   613C FA 55 61         JP M, GET_PAGE_INFO_L4
499   613F                  ; page 2
500   613F 07               RLCA
501   6140 07               RLCA
502   6141              GET_PAGE_INFO_L5:
503   6141 E6 C0            AND 0C0H
504   6143 B1               OR C
505   6144 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
506   6146 4F               LD C, A
507   6147 3A FF FF         LD A, (0FFFFH)
508   614A 2F               CPL
509   614B 5F               LD E, A
510   614C 16 01            LD D, 1
511   614E 78               LD A, B ; return stack
512   614F D3 A8            OUT (0A8H), A
513   6151 C9               RET
514   6152              GET_PAGE_INFO_L2:
515   6152                  ; not expanded
516   6152 16 00            LD D, 0
517   6154 C9               RET
518   6155              GET_PAGE_INFO_L4:
519   6155                  ; page 1
520   6155 0F               RRCA
521   6156 0F               RRCA
522   6157              GET_PAGE_INFO_L3:
523   6157                  ; page 0
524   6157 0F               RRCA
525   6158 0F               RRCA
526   6159 18 E6            JR GET_PAGE_INFO_L5
527   615B              ; ****************************************************************************************************
528   615B
529   615B              ; ****************************************************************************************************
530   615B              ; function returns original slot and subslot info
531   615B              ; input B = 0A8H register value
532   615B              ; input D = 0 is no subslots, 1 if yes
533   615B              ; input C = 0A8H value when page 3 slot equals to requested page slot
534   615B              ; input E = subslot value if present
535   615B              ; modifies AF, disables interrupts
536   615B              RESTORE_PAGE_INFO:
537   615B 7A               LD A, D
538   615C B7               OR A
539   615D 28 08            JR Z, RESTORE_PAGE_INFO_L1
540   615F 79               LD A, C
541   6160 F3           	DI
542   6161 D3 A8            OUT (0A8H), A
543   6163 7B               LD A, E
544   6164 32 FF FF         LD (0FFFFH), A
545   6167              RESTORE_PAGE_INFO_L1:
546   6167 78               LD A, B
547   6168 D3 A8            OUT (0A8H), A
548   616A C9               RET
549   616B              ; ****************************************************************************************************
550   616B
551   616B              ; *******************************************************************************************************
552   616B              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
553   616B              ; INPUT:  A = SLOT ID: EXXXSSPP
554   616B              ; E = EXPANDED FLAG
555   616B              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
556   616B              ; PP = PRIMARY SLOT NUMBER
557   616B              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
558   616B              ; CHANGES: AF, BC, DE
559   616B
560   616B              LOCAL_ENASLT:
561   616B CD 8B 61         CALL L0353
562   616E FA 78 61         JP M, L0340
563   6171 DB A8            IN A, (0A8H)
564   6173 A1               AND C
565   6174 B0               OR B
566   6175 D3 A8            OUT (0A8H), A
567   6177 C9               RET
568   6178              L0340:
569   6178 E5               PUSH HL
570   6179 CD B0 61         CALL L0378
571   617C 4F               LD C, A
572   617D 06 00            LD B, 0
573   617F 7D               LD A, L
574   6180 A4               AND H
575   6181 B2               OR D
576   6182 21 C5 FC         LD HL, 0FCC5H
577   6185 09               ADD HL, BC
578   6186 77               LD (HL), A
579   6187 E1               POP HL
580   6188 79               LD A, C
581   6189 18 E0            JR LOCAL_ENASLT
582   618B              L0353:
583   618B F3               DI
584   618C F5               PUSH AF
585   618D 7C               LD A, H
586   618E 07               RLCA
587   618F 07               RLCA
588   6190 E6 03            AND 3
589   6192 5F               LD E, A
590   6193 3E C0            LD A, 0C0H
591   6195              L035D:
592   6195 07               RLCA
593   6196 07               RLCA
594   6197 1D               DEC E
595   6198 F2 95 61         JP P, L035D
596   619B 5F               LD E, A
597   619C 2F               CPL
598   619D 4F               LD C, A
599   619E F1               POP AF
600   619F F5               PUSH AF
601   61A0 E6 03            AND 3
602   61A2 3C               INC A
603   61A3 47               LD B, A
604   61A4 3E AB            LD A, 0ABH
605   61A6              L036E:
606   61A6 C6 55            ADD A, 055H
607   61A8 10 FC            DJNZ L036E
608   61AA 57               LD D, A
609   61AB A3               AND E
610   61AC 47               LD B, A
611   61AD F1               POP AF
612   61AE A7               AND A
613   61AF C9               RET
614   61B0              L0378:
615   61B0 F5               PUSH AF
616   61B1 7A               LD A, D
617   61B2 E6 C0            AND 0C0H
618   61B4 4F               LD C, A
619   61B5 F1               POP AF
620   61B6 F5               PUSH AF
621   61B7 57               LD D, A
622   61B8 DB A8            IN A, (0A8H)
623   61BA 47               LD B, A
624   61BB E6 3F            AND 03FH
625   61BD B1               OR C
626   61BE D3 A8            OUT (0A8H), A
627   61C0 7A               LD A, D
628   61C1 0F               RRCA
629   61C2 0F               RRCA
630   61C3 E6 03            AND 3
631   61C5 57               LD D, A
632   61C6 3E AB            LD A, 0ABH
633   61C8              L0390:
634   61C8 C6 55            ADD A, 055H
635   61CA 15               DEC D
636   61CB F2 C8 61         JP P, L0390
637   61CE A3               AND E
638   61CF 57               LD D, A
639   61D0 7B               LD A, E
640   61D1 2F               CPL
641   61D2 67               LD H, A
642   61D3 3A FF FF         LD A, (0FFFFH)
643   61D6 2F               CPL
644   61D7 6F               LD L, A
645   61D8 A4               AND H
646   61D9 B2               OR D
647   61DA 32 FF FF         LD (0FFFFH), A
648   61DD 78               LD A, B
649   61DE D3 A8            OUT (0A8H), A
650   61E0 F1               POP AF
651   61E1 E6 03            AND 3
652   61E3 C9               RET
653   61E4              ; *******************************************************************************************************
654   61E4
655   61E4              ; *******************************************************************************************************
656   61E4              ; some common code to activate page 0 and place values needed to restore original page on stack
657   61E4              ; input IY=return address
658   61E4              ENABLE_PAGE0:
659   61E4 AF               XOR A
660   61E5 CD 24 61         CALL GET_PAGE_INFO
661   61E8 C5               PUSH BC
662   61E9 D5               PUSH DE
663   61EA 3A 41 F3         LD A, (RAMAD0)
664   61ED 26 00            LD H, 0
665   61EF CD 6B 61         CALL LOCAL_ENASLT
666   61F2 FD E9        	JP (IY)
667   61F4              ; *******************************************************************************************************
668   61F4
669   61F4              ; General BASIC CALL-instruction handler
670   61F4              CALLHAND:
671   61F4 E5           	PUSH HL
672   61F5 21 72 5F     	LD	HL, CMDS ; pointer table based on starting letter
673   61F8 3A 89 FD         LD A, (PROCNM)
674   61FB D6 41            SUB 'A'
675   61FD 87               ADD A, A
676   61FE 16 00            LD D, 0
677   6200 5F               LD E, A
678   6201 19               ADD HL, DE
679   6202 5E               LD E, (HL)
680   6203 23               INC HL
681   6204 56               LD D, (HL)
682   6205 7A               LD A, D
683   6206 B3               OR E
684   6207 28 23            JR Z, .CMDNOTRECOGNIZED
685   6209 EB               EX DE, HL
686   620A              .CHKCMD:
687   620A 11 89 FD     	LD	DE, PROCNM
688   620D 1A           .LOOP:	LD	A,(DE)
689   620E BE           	CP	(HL)
690   620F 20 11        	JR	NZ,.TONEXTCMD	; Not equal
691   6211 13           	INC	DE
692   6212 23           	INC	HL
693   6213 A7           	AND	A
694   6214 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
695   6216 5E           	LD	E,(HL)
696   6217 23           	INC	HL
697   6218 56           	LD	D,(HL)
698   6219 E1           	POP	HL		; routine address
699   621A CD 3B 62     	CALL	GETPREVCHAR
700   621D CD 2F 62     	CALL	.CALLDE		; Call routine
701   6220 A7           	AND	A
702   6221 C9           	RET
703   6222
704   6222              .TONEXTCMD:
705   6222 0E FF        	LD	C,0FFH
706   6224 AF           	XOR	A
707   6225 ED B1        	CPIR			; Skip to end of instruction name
708   6227 23           	INC	HL
709   6228 23           	INC	HL		; Skip address
710   6229 BE           	CP	(HL)
711   622A 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
712   622C              .CMDNOTRECOGNIZED:
713   622C E1           	POP	HL
714   622D 37               SCF
715   622E C9           	RET
716   622F
717   622F              .CALLDE:
718   622F D5           	PUSH	DE
719   6230 C9           	RET
720   6231
721   6231              ;---------------------------
722   6231
723   6231              ;GETSTRPNT:
724   6231              ; OUT:
725   6231              ; HL = String Address
726   6231              ; B  = Lenght
727   6231              ;        LD      HL,(USR)
728   6231              ;        LD      B,(HL)
729   6231              ;        INC     HL
730   6231              ;        LD      E,(HL)
731   6231              ;        INC     HL
732   6231              ;        LD      D,(HL)
733   6231              ;        EX      DE,HL
734   6231              ;        RET
735   6231
736   6231              ;EVALTXTPARAM:
737   6231              ;	CALL	CHKCHAR
738   6231              ;	DEFB	"("             ; Check for (
739   6231              ;	LD	IX,FRMEVL
740   6231              ;	CALL	CALBAS		; Evaluate expression
741   6231              ;       LD      A,(VALTYP)
742   6231              ;        CP      3               ; Text type?
743   6231              ;        JP      NZ,TYPE_MISMATCH
744   6231              ;        PUSH	HL
745   6231              ;        LD	IX,FRESTR         ; Free the temporary string
746   6231              ;        CALL	CALBAS
747   6231              ;        POP	HL
748   6231              ;	CALL	CHKCHAR
749   6231              ;	DEFB	")"             ; Check for )
750   6231              ;        RET
751   6231
752   6231
753   6231              CHKCHAR:
754   6231 CD 3B 62     	CALL	GETPREVCHAR	; Get previous basic char
755   6234 E3           	EX	(SP),HL
756   6235 BE           	CP	(HL) 	        ; Check if good char
757   6236 20 1B        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
758   6238 23           	INC	HL
759   6239 E3           	EX	(SP),HL
760   623A 23           	INC	HL		; Get next basic char
761   623B
762   623B              GETPREVCHAR:
763   623B 2B           	DEC	HL
764   623C DD 21 66 46  	LD	IX,CHRGTR
765   6240 C3 59 01     	JP      CALBAS
766   6243
767   6243
768   6243              TYPE_MISMATCH:
769   6243 1E 0D            LD E, 13 ; Type mismatch
770   6245 18 0E            JR THROW_ERROR
771   6247              SUBSCRIPT_OUT_OF_RANGE:
772   6247 1E 09            LD E,9 ; subscript out of range
773   6249 18 0A        	JR THROW_ERROR
774   624B              OVERFLOW:
775   624B 1E 06        	LD E,6
776   624D 18 06        	JR THROW_ERROR
777   624F              ILLEGAL_FUNCTION:
778   624F 1E 05            LD E, 5 ; illegal function call
779   6251 18 02            JR THROW_ERROR
780   6253              SYNTAX_ERROR:
781   6253 1E 02            LD E, 2 ; Syntax error
782   6255              THROW_ERROR:
783   6255 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
784   6259 C3 59 01     	JP	CALBAS
785   625C
786   625C              ;---------------------------
787   625C
788   625C              ; *******************************************************************************************************
789   625C              ; helper function to get pointer to BASIC array data
790   625C              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
791   625C              ; input B=dimensions (1 or 2)
792   625C              ; input D=minimal first dimension
793   625C              ; input E=minimal second dimension, if applicable
794   625C              ; returns BC=pointer to first data element
795   625C              ; throws BASIC error if invalid type
796   625C              GET_BASIC_ARRAY_DATA_POINTER:
797   625C D5           	PUSH DE
798   625D C5           	PUSH BC
799   625E F5           	PUSH AF
800   625F 3E 01           LD A,1
801   6261 32 A5 F6        LD (SUBFLG),A ; search for arrays only
802   6264 DD 21 A4 5E  	LD IX, PTRGET
803   6268 CD 59 01     	CALL CALBAS
804   626B AF              XOR A
805   626C 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
806   626F 3A 63 F6     	LD A,(VALTYP)
807   6272 D1           	POP DE ; required type
808   6273 BA           	CP D
809   6274 C2 43 62     	JP NZ,TYPE_MISMATCH
810   6277 0A           	LD A,(BC)
811   6278 03           	INC BC
812   6279 D1           	POP DE ; required number of dimensions
813   627A BA           	CP D
814   627B C2 43 62     	JP NZ,TYPE_MISMATCH
815   627E D1           	POP DE ; required minimal array dimensions
816   627F 3D           	DEC A
817   6280 28 07        	JR Z,.ONE_DIMENSION
818   6282              	; 2-dimension array
819   6282 0A           	LD A,(BC)
820   6283 03          > INC BC
820   6284 03          > INC BC
821   6285 BB           	CP E
822   6286 DA 47 62     	JP C,SUBSCRIPT_OUT_OF_RANGE
823   6289              .ONE_DIMENSION:
824   6289 0A           	LD A,(BC)
825   628A 03          > INC BC
825   628B 03          > INC BC
826   628C BA           	CP D
827   628D DA 47 62     	JP C,SUBSCRIPT_OUT_OF_RANGE
828   6290 C9           	RET
829   6291              ; *******************************************************************************************************
830   6291
831   6291              EXT_END:
832   6291
# file closed: asm\main.asm
