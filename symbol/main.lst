# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              SYNCHR		EQU		#558C
  33  4000              VALTYP  	EQU     #F663
  34  4000              USR     	EQU     #F7F8
  35  4000              PROCNM		EQU		#FD89
  36  4000              BIOS_FILVRM EQU     #0056
  37  4000              CLIKSW		EQU		#F3DB
  38  4000              ATRBAS		EQU		#F928
  39  4000              GRPCGP		EQU		#F3CB
  40  4000
  41  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  42  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  43  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  44  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  45  4000              EXPTBL	EQU #FCC1
  46  4000              SCRMOD	EQU #FCAF ; current screen mode
  47  4000              REG1SAV EQU #F3E0 ; VDP(1)
  48  4000
  49  4000              ; BASIC error codes
  50  4000              ;01 NEXT without FOR
  51  4000              ;02 Syntax error
  52  4000              ;03 RETURN without GOSUB
  53  4000              ;04 Out of DATA
  54  4000              ;05 Illegal function call
  55  4000              ;06 Overflow
  56  4000              ;07 Out of memory
  57  4000              ;08 Undefined line number
  58  4000              ;09 Subscript out of range
  59  4000              ;10 Redimensioned array
  60  4000              ;11 Division by zero
  61  4000              ;12 Illegal direct
  62  4000              ;13 Type mismatch
  63  4000              ;14 Out of string space
  64  4000              ;15 String too long
  65  4000              ;16 String formula too complex
  66  4000              ;17 Can't CONTINUE
  67  4000              ;18 Undefined user function
  68  4000              ;19 Device I/O error
  69  4000              ;20 Verify error
  70  4000              ;21 No RESUME
  71  4000              ;22 RESUME without error
  72  4000              ;23 Unprintable error
  73  4000              ;24 Missing operand
  74  4000              ;25 Line buffer overflow
  75  4000              ;50 FIELD overflow
  76  4000              ;51 Internal error
  77  4000              ;52 Bad file number
  78  4000              ;53 File not found
  79  4000              ;54 File already open
  80  4000              ;55 Input past end
  81  4000              ;56 Bad file name
  82  4000              ;57 Direct statement in file
  83  4000              ;58 Sequential I/O only
  84  4000              ;59 File not OPEN
  85  4000
  86  4000
  87  4000               ; simulate cartridge with BASIC extension
  88  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  88  4004 A9 52 00 00
  88  4008 00 00 00 00
  88  400C 00 00 00 00
  89  4010
  90  4010              ; this location #4010 stores last location used by basic extension
  91  4010              ; free memory after that point
  92  4010              FREEMEMPTR:
  93  4010 86 5B         DW EXT_END
  94  4012
  95  4012              ; this location #4012 stores extension version in DAA format
  96  4012              ; first byte is major version and second minor
  97  4012              VERSION:
  98  4012 00 70         DB #00, #70
  99  4014
 100  4014              ; binary included AKG player compiled at #4014
 101  4014               IF (SOUND_CMDS == 1)
 102  4014              	INCBIN "bin/AKG.bin"
 103  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 104  4CF0               ENDIF
 105  4CF0
 106  4CF0              ORIG.HTIMI:
 107  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 107  4CF4 00
 108  4CF5               EXPORT ORIG.HTIMI
 109  4CF5
 110  4CF5               IF (SOUND_CMDS == 1)
 111  4CF5              MUSIC_INIT_STATUS:
 112  4CF5 00            DB 0
 113  4CF6              SFX_INIT_STATUS:
 114  4CF6 00            DB 0
 115  4CF7              SOUND_ENABLED:
 116  4CF7 00            DB 0
 117  4CF8               ENDIF
 118  4CF8
 119  4CF8               IF (SPRITE_CMDS == 1)
 120  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD C4 51     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD E6 52     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD E6 52     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD E6 52     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD E6 52     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 FE 52     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 FE 52     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 FE 52     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD E6 52     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD E6 52     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD E6 52     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD E6 52     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD E6 52     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD E6 52     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 FE 52     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 FE 52     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD E6 52     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD E6 52     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD E6 52     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD E6 52     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD E6 52     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD D9 51         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD 20 52         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD 10 52         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 121  4F4D               ENDIF
 122  4F4D
 123  4F4D               IF (ANIM_CMDS == 1)
 124  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E 86 5B         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 86 5B         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 86 5B         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; *******************************************************************************************************
  31+ 4F56              ; helper function HL=A*5
  32+ 4F56              ; changes HL,DE;
  33+ 4F56              Ax5:
  34+ 4F56 26 00            LD H,0
  35+ 4F58 6F               LD L,A
  36+ 4F59 54               LD D,H
  37+ 4F5A 5D               LD E,L
  38+ 4F5B 29               ADD HL,HL
  39+ 4F5C 29               ADD HL,HL
  40+ 4F5D 19               ADD HL,DE
  41+ 4F5E C9               RET
  42+ 4F5F              ; *******************************************************************************************************
  43+ 4F5F
  44+ 4F5F              ; *******************************************************************************************************
  45+ 4F5F              ; function to handle CALL MAXANIMITEMS basic extension
  46+ 4F5F              ; MAXANIMITEMS (BYTE number)
  47+ 4F5F              ; sets new number and moves memory buffers as needed
  48+ 4F5F              MAXANIMITEMS:
  49+ 4F5F              	; opening (
  50+ 4F5F CD E6 52     	CALL CHKCHAR
  51+ 4F62 28           	DB '('
  52+ 4F63              	; get value
  53+ 4F63 DD 21 1C 52  	LD IX, GETBYT
  54+ 4F67 CD 59 01     	CALL CALBAS
  55+ 4F6A F5               PUSH AF
  56+ 4F6B              	; ending )
  57+ 4F6B CD E6 52     	CALL CHKCHAR
  58+ 4F6E 29           	DB ')'
  59+ 4F6F F1               POP AF
  60+ 4F70
  61+ 4F70              	; save position
  62+ 4F70 E5           	PUSH HL
  63+ 4F71              MAXANIMITEMS.ENTRY:
  64+ 4F71 47               LD B,A
  65+ 4F72 3A 4D 4F         LD A,(ANIMITEMNUM)
  66+ 4F75 90               SUB B
  67+ 4F76 28 23            JR Z, .EXIT; same value as before
  68+ 4F78 DD 21 4E 4F      LD IX,ANIMITEMPTR
  69+ 4F7C FD 21 51 4F      LD IY,ANIMDEFPTR
  70+ 4F80 FA 9E 4F         JP M, .INCREASE
  71+ 4F83                  ; new value is lower than previous one
  72+ 4F83 CD B6 4F         CALL .SIZEDIFF
  73+ 4F86 CD D1 4F         CALL .DECREASE_COMMON
  74+ 4F89 2A 54 4F         LD HL,(ANIMSPRPTR)
  75+ 4F8C AF               XOR A
  76+ 4F8D ED 42            SBC HL,BC
  77+ 4F8F 22 54 4F         LD (ANIMSPRPTR),HL
  78+ 4F92 2A 10 40         LD HL,(FREEMEMPTR)
  79+ 4F95 AF               XOR A
  80+ 4F96 ED 42            SBC HL,BC
  81+ 4F98 22 10 40         LD (FREEMEMPTR),HL
  82+ 4F9B              .EXIT:
  83+ 4F9B FB               EI
  84+ 4F9C E1           	POP HL
  85+ 4F9D C9           	RET
  86+ 4F9E              .INCREASE:
  87+ 4F9E ED 44            NEG
  88+ 4FA0 CD B6 4F         CALL .SIZEDIFF
  89+ 4FA3 CD 03 50         CALL .INCREASE_COMMON
  90+ 4FA6 2A 54 4F         LD HL,(ANIMSPRPTR)
  91+ 4FA9 09               ADD HL,BC
  92+ 4FAA 22 54 4F         LD (ANIMSPRPTR),HL
  93+ 4FAD 2A 10 40         LD HL,(FREEMEMPTR)
  94+ 4FB0 09               ADD HL,BC
  95+ 4FB1 22 10 40         LD (FREEMEMPTR),HL
  96+ 4FB4 18 E5            JR .EXIT
  97+ 4FB6              .SIZEDIFF:
  98+ 4FB6 CD 56 4F         CALL Ax5
  99+ 4FB9 78               LD A,B
 100+ 4FBA 32 4D 4F         LD (ANIMITEMNUM),A
 101+ 4FBD 44               LD B,H
 102+ 4FBE 4D               LD C,L
 103+ 4FBF C9               RET ; BC=size difference in bytes
 104+ 4FC0              .SIZETOMOVE:
 105+ 4FC0 D5               PUSH DE
 106+ 4FC1 2A 10 40         LD HL,(FREEMEMPTR)
 107+ 4FC4 FD 5E 00         LD E,(IY)
 108+ 4FC7 FD 56 01         LD D,(IY+1)
 109+ 4FCA AF               XOR A
 110+ 4FCB ED 52            SBC HL,DE
 111+ 4FCD 44               LD B,H
 112+ 4FCE 4D               LD C,L
 113+ 4FCF D1               POP DE
 114+ 4FD0 C9               RET
 115+ 4FD1              .DECREASE_COMMON:
 116+ 4FD1 FD 6E 00         LD L,(IY)
 117+ 4FD4 FD 66 01         LD H,(IY+1)
 118+ 4FD7 AF               XOR A
 119+ 4FD8 ED 42            SBC HL,BC
 120+ 4FDA EB               EX DE,HL
 121+ 4FDB C5               PUSH BC
 122+ 4FDC CD C0 4F         CALL .SIZETOMOVE
 123+ 4FDF F3               DI
 124+ 4FE0 78               LD A,B
 125+ 4FE1 B1               OR C
 126+ 4FE2 28 0E            JR Z,.L1
 127+ 4FE4 FD 6E 00         LD L,(IY)
 128+ 4FE7 FD 66 01         LD H,(IY+1)
 129+ 4FEA DD 73 00         LD (IX),E
 130+ 4FED DD 72 01         LD (IX+1),D
 131+ 4FF0 ED B0            LDIR
 132+ 4FF2              .L1:
 133+ 4FF2 C1               POP BC
 134+ 4FF3 FD 6E 00         LD L,(IY)
 135+ 4FF6 FD 66 01         LD H,(IY+1)
 136+ 4FF9 AF               XOR A
 137+ 4FFA ED 42            SBC HL,BC
 138+ 4FFC FD 75 00         LD (IY),L
 139+ 4FFF FD 74 01         LD (IY+1),H
 140+ 5002 C9               RET
 141+ 5003              .INCREASE_COMMON:
 142+ 5003 2A 10 40         LD HL,(FREEMEMPTR)
 143+ 5006 2B               DEC HL
 144+ 5007 AF               XOR A
 145+ 5008 ED 42            SBC HL,BC
 146+ 500A EB               EX DE,HL
 147+ 500B C5               PUSH BC
 148+ 500C CD C0 4F         CALL .SIZETOMOVE
 149+ 500F F3               DI
 150+ 5010 78               LD A,B
 151+ 5011 B1               OR C
 152+ 5012 28 06            JR Z,.L2
 153+ 5014 2A 10 40         LD HL,(FREEMEMPTR)
 154+ 5017 2B               DEC HL
 155+ 5018 ED B8            LDDR
 156+ 501A              .L2:
 157+ 501A C1               POP BC
 158+ 501B FD 6E 00         LD L,(IY)
 159+ 501E FD 66 01         LD H,(IY+1)
 160+ 5021 09               ADD HL,BC
 161+ 5022 FD 75 00         LD (IY),L
 162+ 5025 FD 74 01         LD (IY+1),H
 163+ 5028 C9               RET
 164+ 5029              ; *******************************************************************************************************
 165+ 5029
 166+ 5029              ; *******************************************************************************************************
 167+ 5029              ; function to handle CALL ANIMITEMPAT basic extension
 168+ 5029              ; ANIMITEMPAT ( BYTE id,
 169+ 5029              ;               INT ticks,
 170+ 5029              ;               BYTE pattern,
 171+ 5029              ;               BYTE color )
 172+ 5029              ; fills animation item data, returns an error if out of bounds
 173+ 5029              ANIMITEMPAT:
 174+ 5029                  ; opening (
 175+ 5029 CD E6 52     	CALL CHKCHAR
 176+ 502C 28           	DB '('
 177+ 502D              	; get id
 178+ 502D DD 21 1C 52  	LD IX, GETBYT
 179+ 5031 CD 59 01     	CALL CALBAS
 180+ 5034 F5               PUSH AF
 181+ 5035                  ; check if out of bounds
 182+ 5035 3C               INC A
 183+ 5036 4F               LD C,A
 184+ 5037 3A 4D 4F         LD A,(ANIMITEMNUM)
 185+ 503A B9               CP C
 186+ 503B 30 05            JR NC, .L1
 187+ 503D 1E 09            LD E,9 ; subscript out of range
 188+ 503F C3 FE 52         JP THROW_ERROR
 189+ 5042              .L1:
 190+ 5042              	; comma
 191+ 5042 CD E6 52     	CALL CHKCHAR
 192+ 5045 2C           	DB ','
 193+ 5046              	; get ticks
 194+ 5046 DD 21 2F 54  	LD IX, FRMQNT
 195+ 504A CD 59 01     	CALL CALBAS
 196+ 504D D5           	PUSH DE
 197+ 504E              	; comma
 198+ 504E CD E6 52     	CALL CHKCHAR
 199+ 5051 2C           	DB ','
 200+ 5052              	; get pattern
 201+ 5052 DD 21 1C 52  	LD IX, GETBYT
 202+ 5056 CD 59 01     	CALL CALBAS
 203+ 5059 F5               PUSH AF
 204+ 505A              	; comma
 205+ 505A CD E6 52     	CALL CHKCHAR
 206+ 505D 2C           	DB ','
 207+ 505E              	; get color
 208+ 505E DD 21 1C 52  	LD IX, GETBYT
 209+ 5062 CD 59 01     	CALL CALBAS
 210+ 5065 F5               PUSH AF
 211+ 5066              	; ending )
 212+ 5066 CD E6 52     	CALL CHKCHAR
 213+ 5069 29           	DB ')'
 214+ 506A
 215+ 506A E5               PUSH HL
 216+ 506B DD E1            POP IX
 217+ 506D D9               EXX
 218+ 506E C1               POP BC ; color
 219+ 506F D1               POP DE ; pattern
 220+ 5070 E1               POP HL ; ticks
 221+ 5071 D9               EXX
 222+ 5072 F1               POP AF
 223+ 5073 CD 56 4F         CALL Ax5
 224+ 5076 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 225+ 507A 19               ADD HL,DE
 226+ 507B E5               PUSH HL
 227+ 507C FD E1            POP IY
 228+ 507E D9               EXX
 229+ 507F FD 36 00 00      LD (IY),0 ; type=0
 230+ 5083 FD 75 01         LD (IY+1),L
 231+ 5086 FD 74 02         LD (IY+2),H
 232+ 5089 FD 72 03         LD (IY+3),D
 233+ 508C FD 70 04         LD (IY+4),B
 234+ 508F
 235+ 508F DD E5            PUSH IX
 236+ 5091 E1               POP HL
 237+ 5092 C9               RET
 238+ 5093              ; *******************************************************************************************************
 239+ 5093
# file closed: asm\ANIMATION.asm
 125  5093               ENDIF
 126  5093
 127  5093              ; temp variables for BLIT, TILE functions
 128  5093               IF (BLIT_CMDS + TILE_CMDS > 0)
 129  5093              BLIT_TMP:
 130  5093              TILETMP1:
 131  5093              BLIT_TMP1:
 132  5093 00 00         DW 0
 133  5095              TILETMP2:
 134  5095              BLIT_TMP2:
 135  5095 00 00         DW 0
 136  5097                IFDEF CMDS_WITH_PARAMETERS
 137  5097              BLIT_STRUCT:
 138  5097 00 00 00...   DS 17
 139  509B                ENDIF
 140  509B               ENDIF
 141  50A8
 142  50A8              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 143  50A8              ; per starting letter, if no commands with this letter, NULL value
 144  50A8              CMDS:
 145  50A8               IF (ANIM_CMDS == 1)
 146  50A8 B5 51        	DW CMDS_A ;
 147  50AA               ELSE
 148  50AA ~                DW 0 ; A
 149  50AA               ENDIF
 150  50AA               IF (BLIT_CMDS + BOX_CMDS > 0)
 151  50AA 80 51            DW CMDS_B ; B
 152  50AC               ELSE
 153  50AC ~            	DW 0
 154  50AC               ENDIF
 155  50AC 00 00            DW 0 ; C
 156  50AE 00 00            DW 0 ; D
 157  50B0 00 00            DW 0 ; E
 158  50B2               IF (VRAM_CMDS + RAM_CMDS > 0)
 159  50B2 FE 50            DW CMDS_F; F
 160  50B4               ELSE
 161  50B4 ~            	DW 0
 162  50B4               ENDIF
 163  50B4               IF (GENCAL_CMD > 0)
 164  50B4 11 51            DW CMDS_G; G
 165  50B6               ELSE
 166  50B6 ~            	DW 0
 167  50B6               ENDIF
 168  50B6 00 00            DW 0 ; H
 169  50B8 00 00            DW 0 ; I
 170  50BA 00 00            DW 0 ; J
 171  50BC 00 00            DW 0 ; K
 172  50BE 00 00            DW 0 ; L
 173  50C0               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 174  50C0 DC 50            DW CMDS_M ; M
 175  50C2               ELSE
 176  50C2 ~            	DW 0
 177  50C2               ENDIF
 178  50C2 00 00            DW 0 ; N
 179  50C4 00 00            DW 0 ; O
 180  50C6 00 00            DW 0 ; P
 181  50C8 00 00            DW 0 ; Q
 182  50CA 00 00            DW 0 ; R
 183  50CC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 184  50CC 25 51            DW CMDS_S ; S
 185  50CE               ELSE
 186  50CE ~            	DW 0
 187  50CE               ENDIF
 188  50CE               IF (TILE_CMDS > 0)
 189  50CE A0 51            DW CMDS_T ; T
 190  50D0               ELSE
 191  50D0 ~            	DW 0
 192  50D0               ENDIF
 193  50D0 00 00            DW 0 ; U
 194  50D2               IF (VRAM_CMDS > 0)
 195  50D2 1B 51            DW CMDS_V ; V
 196  50D4               ELSE
 197  50D4 ~            	DW 0
 198  50D4               ENDIF
 199  50D4 00 00            DW 0 ; W
 200  50D6 00 00            DW 0 ; X
 201  50D8 00 00            DW 0 ; Y
 202  50DA 00 00            DW 0 ; Z
 203  50DC
 204  50DC              CMDS_M:
 205  50DC               IF (VRAM_CMDS == 1)
 206  50DC 4D 45 4D 56      DB "MEMVRM", 0
 206  50E0 52 4D 00
 207  50E3 46 54            DW MEMVRM
 208  50E5               ENDIF
 209  50E5               IF (RAM_CMDS == 1)
 210  50E5 4D 45 4D 43  	DB "MEMCPY", 0
 210  50E9 50 59 00
 211  50EC 05 53        	DW MEMCPY
 212  50EE               ENDIF
 213  50EE               IF (ANIM_CMDS == 1)
 214  50EE 4D 41 58 41  	DB "MAXANIMITEMS",0
 214  50F2 4E 49 4D 49
 214  50F6 54 45 4D 53
 214  50FA 00
 215  50FB 5F 4F        	DW MAXANIMITEMS
 216  50FD               ENDIF
 217  50FD               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 218  50FD 00           	DB 0
 219  50FE               ENDIF
 220  50FE              CMDS_F:
 221  50FE               IF (VRAM_CMDS == 1)
 222  50FE 46 49 4C 56      DB "FILVRM", 0
 222  5102 52 4D 00
 223  5105 48 53            DW FILVRM
 224  5107               ENDIF
 225  5107               IF (RAM_CMDS == 1)
 226  5107 46 49 4C 52      DB "FILRAM", 0
 226  510B 41 4D 00
 227  510E 8F 53            DW FILRAM
 228  5110               ENDIF
 229  5110               IF (VRAM_CMDS + RAM_CMDS > 0)
 230  5110 00               DB 0
 231  5111               ENDIF
 232  5111              CMDS_G:
 233  5111               IF (GENCAL_CMD == 1)
 234  5111 47 45 4E 43      DB "GENCAL", 0
 234  5115 41 4C 00
 235  5118 ED 53            DW GENCAL
 236  511A               ENDIF
 237  511A               IF (GENCAL_CMD > 0)
 238  511A 00           	DB	0
 239  511B               ENDIF
 240  511B              CMDS_V:
 241  511B               IF (VRAM_CMDS == 1)
 242  511B 56 52 4D 4D  	DB "VRMMEM", 0
 242  511F 45 4D 00
 243  5122 BE 54        	DW VRMMEM
 244  5124               ENDIF
 245  5124               IF (VRAM_CMDS > 0)
 246  5124 00           	DB 0
 247  5125               ENDIF
 248  5125              CMDS_S:
 249  5125               IF (SPRITE_CMDS == 1)
 250  5125 53 50 52 53  	DB "SPRSET", 0
 250  5129 45 54 00
 251  512C 0E 4E        	DW SPRSET
 252  512E 53 50 52 47  	DB "SPRGRPMOV", 0
 252  5132 52 50 4D 4F
 252  5136 56 00
 253  5138 CC 4E        	DW SPRGRPMOV
 254  513A               ENDIF
 255  513A               IF (SOUND_CMDS == 1)
 256  513A 53 4E 44 53  	DB "SNDSFX", 0
 256  513E 46 58 00
 257  5141 FC 55        	DW SNDSFX
 258  5143 53 4E 44 50  	DB "SNDPLYON", 0
 258  5147 4C 59 4F 4E
 258  514B 00
 259  514C C6 55        	DW SNDPLYON
 260  514E 53 4E 44 50  	DB "SNDPLYOFF", 0
 260  5152 4C 59 4F 46
 260  5156 46 00
 261  5158 D9 55        	DW SNDPLYOFF
 262  515A 53 4E 44 50  	DB "SNDPLYINI", 0
 262  515E 4C 59 49 4E
 262  5162 49 00
 263  5164 7C 55        	DW SNDPLYINIT
 264  5166               ENDIF
 265  5166               IF (SPRITE_CMDS == 1)
 266  5166 53 50 52 45  	DB "SPRENABLE", 0
 266  516A 4E 41 42 4C
 266  516E 45 00
 267  5170 B9 4D        	DW SPRENABLE
 268  5172 53 50 52 44  	DB "SPRDISABLE", 0
 268  5176 49 53 41 42
 268  517A 4C 45 00
 269  517D 09 4E        	DW SPRDISABLE
 270  517F               ENDIF
 271  517F               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 272  517F 00           	DB 0
 273  5180               ENDIF
 274  5180              CMDS_B:
 275  5180               IF (BLIT_CMDS == 1)
 276  5180 42 4C 49 54  	DB "BLIT", 0
 276  5184 00
 277  5185 D3 57        	DW BLIT
 278  5187               ENDIF
 279  5187               IF (BOX_CMDS == 1)
 280  5187 42 4F 58 4D  	DB "BOXMEMCPY", 0
 280  518B 45 4D 43 50
 280  518F 59 00
 281  5191 0B 5B        	DW BOXMEMCPY
 282  5193 42 4F 58 4D  	DB "BOXMEMVRM", 0
 282  5197 45 4D 56 52
 282  519B 4D 00
 283  519D 3F 5B        	DW BOXMEMVRM
 284  519F               ENDIF
 285  519F               IF (BLIT_CMDS + BOX_CMDS > 0)
 286  519F 00           	DB 0
 287  51A0               ENDIF
 288  51A0              CMDS_T:
 289  51A0               IF (TILE_CMDS == 1)
 290  51A0 54 49 4C 45  	DB "TILERAM", 0
 290  51A4 52 41 4D 00
 291  51A8 17 59        	DW TILERAM
 292  51AA 54 49 4C 45  	DB "TILEVRM", 0
 292  51AE 56 52 4D 00
 293  51B2 1A 5A        	DW TILEVRM
 294  51B4               ENDIF
 295  51B4               IF (TILE_CMDS > 0)
 296  51B4 00           	DB 0
 297  51B5               ENDIF
 298  51B5              CMDS_A:
 299  51B5               IF (ANIM_CMDS == 1)
 300  51B5 41 4E 49 4D  	DB "ANIMITEMPAT",0
 300  51B9 49 54 45 4D
 300  51BD 50 41 54 00
 301  51C1 29 50        	DW ANIMITEMPAT
 302  51C3 00           	DB 0
 303  51C4               ENDIF
 304  51C4
 305  51C4               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 306  51C4              ; ****************************************************************************************************
 307  51C4              ; function sets VRAM address
 308  51C4              ; input HL=address
 309  51C4              ; modifies AF
 310  51C4              SETWRT_LOCAL:
 311  51C4 7D           	LD	A, L
 312  51C5 D3 99        	OUT	(099H), A
 313  51C7 7C           	LD	A, H
 314  51C8 E6 3F        	AND	03FH
 315  51CA F6 40        	OR	040H
 316  51CC D3 99        	OUT	(099H), A
 317  51CE C9           	RET
 318  51CF              ; ****************************************************************************************************
 319  51CF               ENDIF
 320  51CF
 321  51CF               IF (VRAM_CMDS + TILE_CMDS > 0)
 322  51CF              ; ****************************************************************************************************
 323  51CF              ; function copies data from RAM to VRAM
 324  51CF              ; input HL=address in RAM
 325  51CF              ; input B=count
 326  51CF              ; modifies AF
 327  51CF              BBYTECOPY:
 328  51CF ED A3        	OUTI
 329  51D1 C2 CF 51     	JP	NZ, BBYTECOPY
 330  51D4 C9           	RET
 331  51D5              ; ****************************************************************************************************
 332  51D5               ENDIF
 333  51D5
 334  51D5              ; ****************************************************************************************************
 335  51D5              ; function multiplies HL by 8
 336  51D5              HLx8:
 337  51D5 29          > ADD HL, HL
 337  51D6 29          > ADD HL, HL
 337  51D7 29          > ADD HL, HL
 338  51D8 C9           	RET
 339  51D9              ; ****************************************************************************************************
 340  51D9
 341  51D9              ; ****************************************************************************************************
 342  51D9              ; function gets slot and subslot data for specific page
 343  51D9              ; input A=page (0, 1 or 2)
 344  51D9              ; output B = 0A8H register value
 345  51D9              ; output D = 0 is no subslots, 1 if yes
 346  51D9              ; output C = 0A8H value when page 3 slot equals to requested page slot
 347  51D9              ; output E = subslot value if present
 348  51D9              ; modifies AF, BC, DE, HL
 349  51D9              GET_PAGE_INFO:
 350  51D9 6F               LD L, A
 351  51DA C6 C1            ADD A, low (EXPTBL)
 352  51DC 32 E6 51         LD (GET_PAGE_INFO_L1+1), A
 353  51DF DB A8            IN A, (0A8H)
 354  51E1 47               LD B, A
 355  51E2 E6 3F            AND 03FH
 356  51E4 4F               LD C, A
 357  51E5              GET_PAGE_INFO_L1:
 358  51E5 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 359  51E8 E6 80            AND 080H
 360  51EA 28 1B            JR Z, GET_PAGE_INFO_L2
 361  51EC                  ; expanded
 362  51EC 2D               DEC L
 363  51ED FA 0C 52         JP M, GET_PAGE_INFO_L3
 364  51F0 2D               DEC L
 365  51F1 FA 0A 52         JP M, GET_PAGE_INFO_L4
 366  51F4                  ; page 2
 367  51F4 07               RLCA
 368  51F5 07               RLCA
 369  51F6              GET_PAGE_INFO_L5:
 370  51F6 E6 C0            AND 0C0H
 371  51F8 B1               OR C
 372  51F9 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 373  51FB 4F               LD C, A
 374  51FC 3A FF FF         LD A, (0FFFFH)
 375  51FF 2F               CPL
 376  5200 5F               LD E, A
 377  5201 16 01            LD D, 1
 378  5203 78               LD A, B ; return stack
 379  5204 D3 A8            OUT (0A8H), A
 380  5206 C9               RET
 381  5207              GET_PAGE_INFO_L2:
 382  5207                  ; not expanded
 383  5207 16 00            LD D, 0
 384  5209 C9               RET
 385  520A              GET_PAGE_INFO_L4:
 386  520A                  ; page 1
 387  520A 0F               RRCA
 388  520B 0F               RRCA
 389  520C              GET_PAGE_INFO_L3:
 390  520C                  ; page 0
 391  520C 0F               RRCA
 392  520D 0F               RRCA
 393  520E 18 E6            JR GET_PAGE_INFO_L5
 394  5210              ; ****************************************************************************************************
 395  5210
 396  5210              ; ****************************************************************************************************
 397  5210              ; function returns original slot and subslot info
 398  5210              ; input B = 0A8H register value
 399  5210              ; input D = 0 is no subslots, 1 if yes
 400  5210              ; input C = 0A8H value when page 3 slot equals to requested page slot
 401  5210              ; input E = subslot value if present
 402  5210              ; modifies AF, disables interrupts
 403  5210              RESTORE_PAGE_INFO:
 404  5210 7A               LD A, D
 405  5211 B7               OR A
 406  5212 28 08            JR Z, RESTORE_PAGE_INFO_L1
 407  5214 79               LD A, C
 408  5215 F3           	DI
 409  5216 D3 A8            OUT (0A8H), A
 410  5218 7B               LD A, E
 411  5219 32 FF FF         LD (0FFFFH), A
 412  521C              RESTORE_PAGE_INFO_L1:
 413  521C 78               LD A, B
 414  521D D3 A8            OUT (0A8H), A
 415  521F C9               RET
 416  5220              ; ****************************************************************************************************
 417  5220
 418  5220              ; *******************************************************************************************************
 419  5220              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 420  5220              ; INPUT:  A = SLOT ID: EXXXSSPP
 421  5220              ; E = EXPANDED FLAG
 422  5220              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 423  5220              ; PP = PRIMARY SLOT NUMBER
 424  5220              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 425  5220              ; CHANGES: AF, BC, DE
 426  5220
 427  5220              LOCAL_ENASLT:
 428  5220 CD 40 52         CALL L0353
 429  5223 FA 2D 52         JP M, L0340
 430  5226 DB A8            IN A, (0A8H)
 431  5228 A1               AND C
 432  5229 B0               OR B
 433  522A D3 A8            OUT (0A8H), A
 434  522C C9               RET
 435  522D              L0340:
 436  522D E5               PUSH HL
 437  522E CD 65 52         CALL L0378
 438  5231 4F               LD C, A
 439  5232 06 00            LD B, 0
 440  5234 7D               LD A, L
 441  5235 A4               AND H
 442  5236 B2               OR D
 443  5237 21 C5 FC         LD HL, 0FCC5H
 444  523A 09               ADD HL, BC
 445  523B 77               LD (HL), A
 446  523C E1               POP HL
 447  523D 79               LD A, C
 448  523E 18 E0            JR LOCAL_ENASLT
 449  5240              L0353:
 450  5240 F3               DI
 451  5241 F5               PUSH AF
 452  5242 7C               LD A, H
 453  5243 07               RLCA
 454  5244 07               RLCA
 455  5245 E6 03            AND 3
 456  5247 5F               LD E, A
 457  5248 3E C0            LD A, 0C0H
 458  524A              L035D:
 459  524A 07               RLCA
 460  524B 07               RLCA
 461  524C 1D               DEC E
 462  524D F2 4A 52         JP P, L035D
 463  5250 5F               LD E, A
 464  5251 2F               CPL
 465  5252 4F               LD C, A
 466  5253 F1               POP AF
 467  5254 F5               PUSH AF
 468  5255 E6 03            AND 3
 469  5257 3C               INC A
 470  5258 47               LD B, A
 471  5259 3E AB            LD A, 0ABH
 472  525B              L036E:
 473  525B C6 55            ADD A, 055H
 474  525D 10 FC            DJNZ L036E
 475  525F 57               LD D, A
 476  5260 A3               AND E
 477  5261 47               LD B, A
 478  5262 F1               POP AF
 479  5263 A7               AND A
 480  5264 C9               RET
 481  5265              L0378:
 482  5265 F5               PUSH AF
 483  5266 7A               LD A, D
 484  5267 E6 C0            AND 0C0H
 485  5269 4F               LD C, A
 486  526A F1               POP AF
 487  526B F5               PUSH AF
 488  526C 57               LD D, A
 489  526D DB A8            IN A, (0A8H)
 490  526F 47               LD B, A
 491  5270 E6 3F            AND 03FH
 492  5272 B1               OR C
 493  5273 D3 A8            OUT (0A8H), A
 494  5275 7A               LD A, D
 495  5276 0F               RRCA
 496  5277 0F               RRCA
 497  5278 E6 03            AND 3
 498  527A 57               LD D, A
 499  527B 3E AB            LD A, 0ABH
 500  527D              L0390:
 501  527D C6 55            ADD A, 055H
 502  527F 15               DEC D
 503  5280 F2 7D 52         JP P, L0390
 504  5283 A3               AND E
 505  5284 57               LD D, A
 506  5285 7B               LD A, E
 507  5286 2F               CPL
 508  5287 67               LD H, A
 509  5288 3A FF FF         LD A, (0FFFFH)
 510  528B 2F               CPL
 511  528C 6F               LD L, A
 512  528D A4               AND H
 513  528E B2               OR D
 514  528F 32 FF FF         LD (0FFFFH), A
 515  5292 78               LD A, B
 516  5293 D3 A8            OUT (0A8H), A
 517  5295 F1               POP AF
 518  5296 E6 03            AND 3
 519  5298 C9               RET
 520  5299              ; *******************************************************************************************************
 521  5299
 522  5299              ; *******************************************************************************************************
 523  5299              ; some common code to activate page 0 and place values needed to restore original page on stack
 524  5299              ; input IY=return address
 525  5299              ENABLE_PAGE0:
 526  5299 AF               XOR A
 527  529A CD D9 51         CALL GET_PAGE_INFO
 528  529D C5               PUSH BC
 529  529E D5               PUSH DE
 530  529F 3A 41 F3         LD A, (RAMAD0)
 531  52A2 26 00            LD H, 0
 532  52A4 CD 20 52         CALL LOCAL_ENASLT
 533  52A7 FD E9        	JP (IY)
 534  52A9              ; *******************************************************************************************************
 535  52A9
 536  52A9              ; General BASIC CALL-instruction handler
 537  52A9              CALLHAND:
 538  52A9 E5           	PUSH HL
 539  52AA 21 A8 50     	LD	HL, CMDS ; pointer table based on starting letter
 540  52AD 3A 89 FD         LD A, (PROCNM)
 541  52B0 D6 41            SUB 'A'
 542  52B2 87               ADD A, A
 543  52B3 16 00            LD D, 0
 544  52B5 5F               LD E, A
 545  52B6 19               ADD HL, DE
 546  52B7 5E               LD E, (HL)
 547  52B8 23               INC HL
 548  52B9 56               LD D, (HL)
 549  52BA 7A               LD A, D
 550  52BB B3               OR E
 551  52BC 28 23            JR Z, .CMDNOTRECOGNIZED
 552  52BE EB               EX DE, HL
 553  52BF              .CHKCMD:
 554  52BF 11 89 FD     	LD	DE, PROCNM
 555  52C2 1A           .LOOP:	LD	A,(DE)
 556  52C3 BE           	CP	(HL)
 557  52C4 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 558  52C6 13           	INC	DE
 559  52C7 23           	INC	HL
 560  52C8 A7           	AND	A
 561  52C9 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 562  52CB 5E           	LD	E,(HL)
 563  52CC 23           	INC	HL
 564  52CD 56           	LD	D,(HL)
 565  52CE E1           	POP	HL		; routine address
 566  52CF CD F0 52     	CALL	GETPREVCHAR
 567  52D2 CD E4 52     	CALL	.CALLDE		; Call routine
 568  52D5 A7           	AND	A
 569  52D6 C9           	RET
 570  52D7
 571  52D7              .TONEXTCMD:
 572  52D7 0E FF        	LD	C,0FFH
 573  52D9 AF           	XOR	A
 574  52DA ED B1        	CPIR			; Skip to end of instruction name
 575  52DC 23           	INC	HL
 576  52DD 23           	INC	HL		; Skip address
 577  52DE BE           	CP	(HL)
 578  52DF 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 579  52E1              .CMDNOTRECOGNIZED:
 580  52E1 E1           	POP	HL
 581  52E2 37               SCF
 582  52E3 C9           	RET
 583  52E4
 584  52E4              .CALLDE:
 585  52E4 D5           	PUSH	DE
 586  52E5 C9           	RET
 587  52E6
 588  52E6              ;---------------------------
 589  52E6
 590  52E6              ;GETSTRPNT:
 591  52E6              ; OUT:
 592  52E6              ; HL = String Address
 593  52E6              ; B  = Lenght
 594  52E6              ;        LD      HL,(USR)
 595  52E6              ;        LD      B,(HL)
 596  52E6              ;        INC     HL
 597  52E6              ;        LD      E,(HL)
 598  52E6              ;        INC     HL
 599  52E6              ;        LD      D,(HL)
 600  52E6              ;        EX      DE,HL
 601  52E6              ;        RET
 602  52E6
 603  52E6              ;EVALTXTPARAM:
 604  52E6              ;	CALL	CHKCHAR
 605  52E6              ;	DEFB	"("             ; Check for (
 606  52E6              ;	LD	IX,FRMEVL
 607  52E6              ;	CALL	CALBAS		; Evaluate expression
 608  52E6              ;       LD      A,(VALTYP)
 609  52E6              ;        CP      3               ; Text type?
 610  52E6              ;        JP      NZ,TYPE_MISMATCH
 611  52E6              ;        PUSH	HL
 612  52E6              ;        LD	IX,FRESTR         ; Free the temporary string
 613  52E6              ;        CALL	CALBAS
 614  52E6              ;        POP	HL
 615  52E6              ;	CALL	CHKCHAR
 616  52E6              ;	DEFB	")"             ; Check for )
 617  52E6              ;        RET
 618  52E6
 619  52E6
 620  52E6              CHKCHAR:
 621  52E6 CD F0 52     	CALL	GETPREVCHAR	; Get previous basic char
 622  52E9 E3           	EX	(SP),HL
 623  52EA BE           	CP	(HL) 	        ; Check if good char
 624  52EB 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 625  52ED 23           	INC	HL
 626  52EE E3           	EX	(SP),HL
 627  52EF 23           	INC	HL		; Get next basic char
 628  52F0
 629  52F0              GETPREVCHAR:
 630  52F0 2B           	DEC	HL
 631  52F1 DD 21 66 46  	LD	IX,CHRGTR
 632  52F5 C3 59 01     	JP      CALBAS
 633  52F8
 634  52F8
 635  52F8              TYPE_MISMATCH:
 636  52F8 1E 0D            LD E, 13 ; Type mismatch
 637  52FA 18 02            JR THROW_ERROR
 638  52FC
 639  52FC              SYNTAX_ERROR:
 640  52FC 1E 02            LD E, 2 ; Syntax error
 641  52FE              THROW_ERROR:
 642  52FE DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 643  5302 C3 59 01     	JP	CALBAS
 644  5305
 645  5305              ;---------------------------
 646  5305
 647  5305               IF (RAM_CMDS == 1)
 648  5305              ; *******************************************************************************************************
 649  5305              ; function to handle CALL MEMCPY basic extension
 650  5305              ; _MEMCPY ( INT source,
 651  5305              ;			INT destination,
 652  5305              ;			INT count,
 653  5305              ; will put ram in page 0 also, page 1 is already there
 654  5305              MEMCPY:
 655  5305              	; opening (
 656  5305 CD E6 52     	CALL CHKCHAR
 657  5308 28           	DB '('
 658  5309              	; get source address
 659  5309 DD 21 2F 54  	LD IX, FRMQNT
 660  530D CD 59 01     	CALL CALBAS
 661  5310 D5           	PUSH DE
 662  5311              	; comma
 663  5311 CD E6 52     	CALL CHKCHAR
 664  5314 2C           	DB ','
 665  5315              	; get destination address
 666  5315 DD 21 2F 54  	LD IX, FRMQNT
 667  5319 CD 59 01     	CALL CALBAS
 668  531C D5           	PUSH DE
 669  531D              	; comma
 670  531D CD E6 52     	CALL CHKCHAR
 671  5320 2C           	DB ','
 672  5321              	; get length
 673  5321 DD 21 2F 54  	LD IX, FRMQNT
 674  5325 CD 59 01     	CALL CALBAS
 675  5328 D5           	PUSH DE
 676  5329              	; ending )
 677  5329 CD E6 52     	CALL CHKCHAR
 678  532C 29           	DB ')'
 679  532D
 680  532D              	; save position
 681  532D E5           	PUSH HL
 682  532E DD E1        	POP IX
 683  5330
 684  5330 C1           	POP BC ; count
 685  5331 D1           	POP DE ; destination
 686  5332 E1           	POP HL ; source
 687  5333 D9           	EXX
 688  5334              	; enable page 0
 689  5334 FD 21 3B 53  	LD IY, .RET
 690  5338 C3 99 52     	JP ENABLE_PAGE0
 691  533B              .RET:
 692  533B FB           	EI
 693  533C D9           	EXX
 694  533D ED B0        	LDIR
 695  533F D1               POP DE
 696  5340 C1               POP BC
 697  5341 CD 10 52         CALL RESTORE_PAGE_INFO
 698  5344 DD E5        	PUSH IX
 699  5346 E1           	POP HL
 700  5347 C9           	RET
 701  5348              ; *******************************************************************************************************
 702  5348               ENDIF
 703  5348
 704  5348               IF (VRAM_CMDS == 1)
 705  5348              ; *******************************************************************************************************
 706  5348              ; function to handle CALL FILVRM basic extension
 707  5348              ; FILVRM ( INT offset,
 708  5348              ;		   INT count,
 709  5348              ;		   BYTE value,
 710  5348              ;		   BYTE wait_vsync) >0 = true
 711  5348              ; wait_vsync will issue HALT before copying
 712  5348              FILVRM:
 713  5348              	; opening (
 714  5348 CD E6 52     	CALL CHKCHAR
 715  534B 28           	DB '('
 716  534C              	; get offset address
 717  534C DD 21 2F 54  	LD IX, FRMQNT
 718  5350 CD 59 01     	CALL CALBAS
 719  5353 D5           	PUSH DE
 720  5354              	; comma
 721  5354 CD E6 52     	CALL CHKCHAR
 722  5357 2C           	DB ','
 723  5358              	; get count
 724  5358 DD 21 2F 54  	LD IX, FRMQNT
 725  535C CD 59 01     	CALL CALBAS
 726  535F D5           	PUSH DE
 727  5360              	; comma
 728  5360 CD E6 52     	CALL CHKCHAR
 729  5363 2C           	DB ','
 730  5364              	; get value
 731  5364 DD 21 1C 52  	LD IX, GETBYT
 732  5368 CD 59 01     	CALL CALBAS
 733  536B F5           	PUSH AF
 734  536C              	; comma
 735  536C CD E6 52     	CALL CHKCHAR
 736  536F 2C           	DB ','
 737  5370              	; get vsync wait
 738  5370 DD 21 1C 52  	LD IX, GETBYT
 739  5374 CD 59 01     	CALL CALBAS
 740  5377 F5           	PUSH AF
 741  5378              	; ending )
 742  5378 CD E6 52     	CALL CHKCHAR
 743  537B 29           	DB ')'
 744  537C
 745  537C FB               EI
 746  537D              	; save position
 747  537D E5           	PUSH HL
 748  537E DD E1        	POP IX
 749  5380
 750  5380              	; syntax ok
 751  5380              	; wait for vsync if needed
 752  5380 F1           	POP AF
 753  5381 B7           	OR A
 754  5382 28 01        	JR Z, .L1
 755  5384 76           	HALT
 756  5385
 757  5385              .L1:
 758  5385 F1               POP AF ; value
 759  5386 C1               POP BC ; count
 760  5387 E1               POP HL ; offset
 761  5388 CD 56 00         CALL BIOS_FILVRM
 762  538B
 763  538B              .L3:
 764  538B DD E5        	PUSH IX
 765  538D E1           	POP HL
 766  538E C9           	RET
 767  538F              ; *******************************************************************************************************
 768  538F               ENDIF
 769  538F
 770  538F               IF (RAM_CMDS == 1)
 771  538F              ; *******************************************************************************************************
 772  538F              ; function to handle CALL FILRAM basic extension
 773  538F              ; FILRAM ( INT start address,
 774  538F              ;		   INT count,
 775  538F              ;		   BYTE value,
 776  538F              ; will put ram in page 0 also, page 1 is already there
 777  538F              FILRAM:
 778  538F              	; opening (
 779  538F CD E6 52     	CALL CHKCHAR
 780  5392 28           	DB '('
 781  5393              	; get start address
 782  5393 DD 21 2F 54  	LD IX, FRMQNT
 783  5397 CD 59 01     	CALL CALBAS
 784  539A D5           	PUSH DE
 785  539B              	; comma
 786  539B CD E6 52     	CALL CHKCHAR
 787  539E 2C           	DB ','
 788  539F              	; get count
 789  539F DD 21 2F 54  	LD IX, FRMQNT
 790  53A3 CD 59 01     	CALL CALBAS
 791  53A6 D5           	PUSH DE
 792  53A7              	; comma
 793  53A7 CD E6 52     	CALL CHKCHAR
 794  53AA 2C           	DB ','
 795  53AB              	; get value
 796  53AB DD 21 1C 52  	LD IX, GETBYT
 797  53AF CD 59 01     	CALL CALBAS
 798  53B2 F5           	PUSH AF
 799  53B3              	; ending )
 800  53B3 CD E6 52     	CALL CHKCHAR
 801  53B6 29           	DB ')'
 802  53B7
 803  53B7              	; save position
 804  53B7 E5           	PUSH HL
 805  53B8 DD E1        	POP IX
 806  53BA
 807  53BA D1           	POP DE ; actually AF
 808  53BB C1           	POP BC ; count
 809  53BC E1           	POP HL ; start address
 810  53BD 78           	LD A, B
 811  53BE B7           	OR A
 812  53BF 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 813  53C1 B1           	OR C
 814  53C2 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 815  53C4 79           	LD A, C
 816  53C5 3D           	DEC A
 817  53C6 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 818  53C8              	; one byte to fill
 819  53C8 72           	LD (HL), D
 820  53C9 18 12        	JR .EXIT
 821  53CB              .L1:
 822  53CB D9           	EXX
 823  53CC              	; enable page 0
 824  53CC FD 21 D3 53  	LD IY, .RET
 825  53D0 C3 99 52     	JP ENABLE_PAGE0
 826  53D3              .RET:
 827  53D3 FB           	EI
 828  53D4 D9           	EXX
 829  53D5 CD E1 53     	CALL .FILLVALUE
 830  53D8 D1               POP DE
 831  53D9 C1               POP BC
 832  53DA CD 10 52         CALL RESTORE_PAGE_INFO
 833  53DD              .EXIT:
 834  53DD DD E5        	PUSH IX
 835  53DF E1           	POP HL
 836  53E0 C9           	RET
 837  53E1
 838  53E1              .FILLVALUE:
 839  53E1 72               LD (HL), D
 840  53E2 54               LD D, H
 841  53E3 5D               LD E, L
 842  53E4 13               INC DE
 843  53E5 0B               DEC BC
 844  53E6 ED B0            LDIR
 845  53E8 C9               RET
 846  53E9              ; *******************************************************************************************************
 847  53E9               ENDIF
 848  53E9
 849  53E9               IF (GENCAL_CMD == 1)
 850  53E9              ; *******************************************************************************************************
 851  53E9              ; function to handle CALL GENCAL basic extension
 852  53E9              ; GENCAL ( INT fn_addr, = address of the function to call
 853  53E9              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 854  53E9              ; output values of reristers will also be stored at reg_list_ptr
 855  53E9              GENCAL_VAR_SP:
 856  53E9 00 00            DW 0
 857  53EB              GENCAL_VAR_SP2:
 858  53EB 00 00            DW 0
 859  53ED              GENCAL:
 860  53ED              	; opening (
 861  53ED CD E6 52     	CALL CHKCHAR
 862  53F0 28           	DB '('
 863  53F1              	; get function address
 864  53F1 DD 21 2F 54  	LD IX, FRMQNT
 865  53F5 CD 59 01     	CALL CALBAS
 866  53F8 D5           	PUSH DE
 867  53F9              	; comma
 868  53F9 CD E6 52     	CALL CHKCHAR
 869  53FC 2C           	DB ','
 870  53FD              	; get pointer to register list
 871  53FD DD 21 2F 54  	LD IX, FRMQNT
 872  5401 CD 59 01     	CALL CALBAS
 873  5404 D5           	PUSH DE
 874  5405              	; ending )
 875  5405 CD E6 52     	CALL CHKCHAR
 876  5408 29           	DB ')'
 877  5409
 878  5409              	; save BASIC token position
 879  5409 E5           	PUSH HL
 880  540A D9               EXX
 881  540B E1           	POP HL ; HL'=next basic token
 882  540C D9               EXX
 883  540D
 884  540D E1               POP HL ; get pointer to register values
 885  540E F3           	DI
 886  540F ED 73 E9 53      LD (GENCAL_VAR_SP), SP
 887  5413 F9               LD SP, HL
 888  5414 F1               POP AF
 889  5415 C1               POP BC
 890  5416 D1               POP DE
 891  5417 E1               POP HL
 892  5418 DD E1            POP IX
 893  541A FD E1            POP IY
 894  541C D9               EXX
 895  541D ED 73 EB 53      LD (GENCAL_VAR_SP2), SP
 896  5421 ED 7B E9 53      LD SP, (GENCAL_VAR_SP)
 897  5425 FB               EI
 898  5426 D1               POP DE ; get function to call
 899  5427 E5               PUSH HL
 900  5428 CD 43 54         CALL .EXXDECALL
 901  542B F3               DI
 902  542C ED 73 E9 53      LD (GENCAL_VAR_SP), SP
 903  5430 ED 7B EB 53      LD SP, (GENCAL_VAR_SP2)
 904  5434 FD E5            PUSH IY
 905  5436 DD E5            PUSH IX
 906  5438 E5               PUSH HL
 907  5439 D5               PUSH DE
 908  543A C5               PUSH BC
 909  543B F5               PUSH AF
 910  543C ED 7B E9 53      LD SP, (GENCAL_VAR_SP)
 911  5440 FB               EI
 912  5441 E1               POP HL
 913  5442 C9           	RET
 914  5443
 915  5443              .EXXDECALL:
 916  5443 D5               PUSH DE
 917  5444 D9               EXX
 918  5445 C9               RET
 919  5446              ; *******************************************************************************************************
 920  5446               ENDIF
 921  5446
 922  5446               IF (VRAM_CMDS == 1)
 923  5446              ; *******************************************************************************************************
 924  5446              ; function to handle CALL MEMVRM basic extension
 925  5446              ; copies from RAM to VRAM
 926  5446              ; _MEMVRM ( INT source,
 927  5446              ;			INT destination,
 928  5446              ;			INT count,
 929  5446              ;			BYTE wait_vsync) >0 = true
 930  5446              ; will put ram in page 0 also, page 1 is already there
 931  5446              ; wait_vsync will issue HALT before copying
 932  5446              MEMVRM:
 933  5446              	; opening (
 934  5446 CD E6 52     	CALL CHKCHAR
 935  5449 28           	DB '('
 936  544A              	; get source address
 937  544A DD 21 2F 54  	LD IX, FRMQNT
 938  544E CD 59 01     	CALL CALBAS
 939  5451 D5           	PUSH DE
 940  5452              	; comma
 941  5452 CD E6 52     	CALL CHKCHAR
 942  5455 2C           	DB ','
 943  5456              	; get destination address
 944  5456 DD 21 2F 54  	LD IX, FRMQNT
 945  545A CD 59 01     	CALL CALBAS
 946  545D D5           	PUSH DE
 947  545E              	; comma
 948  545E CD E6 52     	CALL CHKCHAR
 949  5461 2C           	DB ','
 950  5462              	; get length
 951  5462 DD 21 2F 54  	LD IX, FRMQNT
 952  5466 CD 59 01     	CALL CALBAS
 953  5469 D5           	PUSH DE
 954  546A              	; comma
 955  546A CD E6 52     	CALL CHKCHAR
 956  546D 2C           	DB ','
 957  546E              	; get vsync wait
 958  546E DD 21 1C 52  	LD IX, GETBYT
 959  5472 CD 59 01     	CALL CALBAS
 960  5475 F5           	PUSH AF
 961  5476              	; ending )
 962  5476 CD E6 52     	CALL CHKCHAR
 963  5479 29           	DB ')'
 964  547A
 965  547A                  ; save position in BASIC text
 966  547A E5           	PUSH HL
 967  547B DD E1        	POP IX
 968  547D
 969  547D F1           	POP AF ; wait vsync
 970  547E B7           	OR A
 971  547F 28 03        	JR Z, .L1
 972  5481 FB               EI
 973  5482 76           	HALT
 974  5483 F3           	DI
 975  5484              .L1:
 976  5484              	; pop LDIR parameters and store away for later
 977  5484 C1           	POP BC ; count
 978  5485 D1           	POP DE ; vram destination
 979  5486 E1           	POP HL ; ram source
 980  5487 D9           	EXX
 981  5488 FD 21 8F 54   	LD IY, .RET
 982  548C C3 99 52     	JP ENABLE_PAGE0
 983  548F              .RET:
 984  548F FB           	EI
 985  5490 D9           	EXX
 986  5491 CD 9D 54     	CALL .LDIRVM
 987  5494 D1               POP DE
 988  5495 C1               POP BC
 989  5496 CD 10 52         CALL RESTORE_PAGE_INFO
 990  5499 DD E5        	PUSH IX
 991  549B E1           	POP HL
 992  549C C9           	RET
 993  549D
 994  549D              .LDIRVM:
 995  549D EB           	EX DE, HL
 996  549E F3           	DI
 997  549F CD C4 51     	CALL SETWRT_LOCAL
 998  54A2 FB           	EI
 999  54A3 EB           	EX DE, HL
1000  54A4 78           	LD A, B
1001  54A5 B7           	OR A
1002  54A6 28 0D        	JR Z, .L3
1003  54A8 C5           	PUSH BC
1004  54A9 0E 98        	LD C, #98
1005  54AB              .L2:
1006  54AB 50           	LD D, B
1007  54AC 06 00        	LD B, 0
1008  54AE CD CF 51     	CALL BBYTECOPY
1009  54B1 42           	LD B, D
1010  54B2 10 F7        	DJNZ .L2
1011  54B4 C1           	POP BC
1012  54B5              .L3:
1013  54B5 79           	LD A, C
1014  54B6 B7           	OR A
1015  54B7 C8           	RET Z
1016  54B8 41           	LD B, C
1017  54B9 0E 98        	LD C, #98
1018  54BB C3 CF 51     	JP BBYTECOPY
1019  54BE              ; *******************************************************************************************************
1020  54BE               ENDIF
1021  54BE
1022  54BE               IF (VRAM_CMDS == 1)
1023  54BE              ; *******************************************************************************************************
1024  54BE              ; function to handle CALL VRMMEM basic extension
1025  54BE              ; copies from RAM to VRAM
1026  54BE              ; _VRMMEM ( INT source,
1027  54BE              ;			INT destination,
1028  54BE              ;			INT count
1029  54BE              ; will put ram in page 0 also, page 1 is already there
1030  54BE              VRMMEM:
1031  54BE              	; opening (
1032  54BE CD E6 52     	CALL CHKCHAR
1033  54C1 28           	DB '('
1034  54C2              	; get source address
1035  54C2 DD 21 2F 54  	LD IX, FRMQNT
1036  54C6 CD 59 01     	CALL CALBAS
1037  54C9 D5           	PUSH DE
1038  54CA              	; comma
1039  54CA CD E6 52     	CALL CHKCHAR
1040  54CD 2C           	DB ','
1041  54CE              	; get destination address
1042  54CE DD 21 2F 54  	LD IX, FRMQNT
1043  54D2 CD 59 01     	CALL CALBAS
1044  54D5 D5           	PUSH DE
1045  54D6              	; comma
1046  54D6 CD E6 52     	CALL CHKCHAR
1047  54D9 2C           	DB ','
1048  54DA              	; get length
1049  54DA DD 21 2F 54  	LD IX, FRMQNT
1050  54DE CD 59 01     	CALL CALBAS
1051  54E1 D5           	PUSH DE
1052  54E2              	; ending )
1053  54E2 CD E6 52     	CALL CHKCHAR
1054  54E5 29           	DB ')'
1055  54E6
1056  54E6                  ; save position in BASIC text
1057  54E6 E5           	PUSH HL
1058  54E7 DD E1        	POP IX
1059  54E9
1060  54E9 C1           	POP BC ; count
1061  54EA D1           	POP DE ; destination
1062  54EB E1           	POP HL ; source
1063  54EC D9           	EXX
1064  54ED FD 21 F4 54  	LD IY, .RET
1065  54F1 C3 99 52     	JP ENABLE_PAGE0
1066  54F4              .RET:
1067  54F4 FB           	EI
1068  54F5 D9           	EXX
1069  54F6 CD 02 55     	CALL .LDIRMV
1070  54F9 D1               POP DE
1071  54FA C1               POP BC
1072  54FB CD 10 52         CALL RESTORE_PAGE_INFO
1073  54FE DD E5        	PUSH IX
1074  5500 E1           	POP HL
1075  5501 C9           	RET
1076  5502
1077  5502              .LDIRMV:
1078  5502              	; set VRAM address *exactly* as in ROM, otherwise corruption
1079  5502 7D           	LD	A, L
1080  5503 F3           	DI
1081  5504 D3 99        	OUT	(099H), A
1082  5506 7C           	LD	A, H
1083  5507 E6 3F        	AND	03FH
1084  5509 D3 99        	OUT	(099H), A
1085  550B FB           	EI
1086  550C              	;EX (SP), HL
1087  550C              	;EX (SP), HL
1088  550C              	;NOP
1089  550C              	;NOP
1090  550C              .L4:
1091  550C DB 98            IN A, (#98)
1092  550E 12           	LD (DE), A
1093  550F 13               INC DE
1094  5510 0B               DEC BC
1095  5511 79               LD A, C
1096  5512 B0               OR B
1097  5513 20 F7            JR NZ, .L4
1098  5515 C9               RET
1099  5516              ; *******************************************************************************************************
1100  5516               ENDIF
1101  5516
1102  5516              ; *******************************************************************************************************
1103  5516              ; H.TIMI function
1104  5516              MBGE_HTIMI:
1105  5516               EXPORT MBGE_HTIMI
1106  5516 F5           	PUSH AF
1107  5517
1108  5517               IF (SPRITE_CMDS == 1)
1109  5517 CD 01 4D     	CALL SPRATR_UPDATE
1110  551A               ENDIF
1111  551A
1112  551A               IF (SOUND_CMDS == 1)
1113  551A 3A F7 4C     	LD A, (SOUND_ENABLED)
1114  551D B7           	OR A
1115  551E 28 2A        	JR Z, .EXIT
1116  5520
1117  5520              	; enable page 2
1118  5520 3E 02            LD A, 2
1119  5522 CD D9 51         CALL GET_PAGE_INFO
1120  5525 C5               PUSH BC
1121  5526 D5               PUSH DE
1122  5527 3A 43 F3         LD A, (RAMAD2)
1123  552A 26 80            LD H, 080H
1124  552C CD 20 52         CALL LOCAL_ENASLT
1125  552F              	; enable page 0
1126  552F AF               XOR A
1127  5530 CD D9 51         CALL GET_PAGE_INFO
1128  5533 C5               PUSH BC
1129  5534 D5               PUSH DE
1130  5535 3A 41 F3         LD A, (RAMAD0)
1131  5538 26 00            LD H, 0
1132  553A CD 20 52         CALL LOCAL_ENASLT
1133  553D
1134  553D CD 33 42     	CALL PLY_AKG_PLAY
1135  5540
1136  5540              	; restore page 0
1137  5540 D1               POP DE
1138  5541 C1               POP BC
1139  5542 CD 10 52         CALL RESTORE_PAGE_INFO
1140  5545              	; restore page 2
1141  5545 D1               POP DE
1142  5546 C1               POP BC
1143  5547 CD 10 52         CALL RESTORE_PAGE_INFO
1144  554A               ENDIF
1145  554A
1146  554A              .EXIT:
1147  554A F1           	POP AF
1148  554B C3 F0 4C     	JP ORIG.HTIMI
1149  554E              ; *******************************************************************************************************
1150  554E
1151  554E              ; *******************************************************************************************************
1152  554E              ; interrupt handler when page 0 enabled
1153  554E              VBLANK:
1154  554E              	EXPORT VBLANK
1155  554E
1156  554E F5               PUSH AF
1157  554F              	; is VDP originator ?
1158  554F DB 99        	IN	A, (099H)
1159  5551 A7           	AND	A
1160  5552 F2 78 55     	JP P, .EXIT
1161  5555
1162  5555               IF (SOUND_CMDS == 1)
1163  5555 3A F7 4C     	LD A, (SOUND_ENABLED)
1164  5558 B7           	OR A
1165  5559 28 1D        	JR Z, .EXIT
1166  555B
1167  555B C5               PUSH BC
1168  555C D5               PUSH DE
1169  555D E5               PUSH HL
1170  555E 08               EX AF, AF'
1171  555F D9               EXX
1172  5560 F5               PUSH AF
1173  5561 C5               PUSH BC
1174  5562 D5               PUSH DE
1175  5563 E5               PUSH HL
1176  5564 DD E5            PUSH IX
1177  5566 FD E5            PUSH IY
1178  5568
1179  5568 CD 33 42     	CALL PLY_AKG_PLAY
1180  556B
1181  556B FD E1            POP IY
1182  556D DD E1            POP IX
1183  556F E1               POP HL
1184  5570 D1               POP DE
1185  5571 C1               POP BC
1186  5572 F1               POP AF
1187  5573 08               EX AF, AF'
1188  5574 D9               EXX
1189  5575 E1               POP HL
1190  5576 D1               POP DE
1191  5577 C1               POP BC
1192  5578               ENDIF
1193  5578
1194  5578              .EXIT:
1195  5578 F1           	POP AF
1196  5579 FB           	EI
1197  557A ED 4D        	RETI
1198  557C              ; *******************************************************************************************************
1199  557C
1200  557C               IF (SOUND_CMDS == 1)
1201  557C              ; *******************************************************************************************************
1202  557C              ; function to handle CALL SNDPLYINIT basic extension
1203  557C              ; initializes sound player
1204  557C              ; _SNDPLYINIT ( INT music_offset,
1205  557C              ;				INT sfx_offset, can be -1 if no SFX
1206  557C              ; will put ram in page 0 also, page 1 is already there
1207  557C              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1208  557C              SNDPLYINIT:
1209  557C              	; opening (
1210  557C CD E6 52     	CALL CHKCHAR
1211  557F 28           	DB '('
1212  5580              	; get music address
1213  5580 DD 21 2F 54  	LD IX, FRMQNT
1214  5584 CD 59 01     	CALL CALBAS
1215  5587 D5           	PUSH DE
1216  5588              	; comma
1217  5588 CD E6 52     	CALL CHKCHAR
1218  558B 2C           	DB ','
1219  558C              	; get sfx address
1220  558C DD 21 2F 54  	LD IX, FRMQNT
1221  5590 CD 59 01     	CALL CALBAS
1222  5593 D5           	PUSH DE
1223  5594              	; ending )
1224  5594 CD E6 52     	CALL CHKCHAR
1225  5597 29           	DB ')'
1226  5598
1227  5598                  ; save position in BASIC text
1228  5598 44           	LD B, H
1229  5599 4D           	LD C, L
1230  559A
1231  559A              	; pop LDIR parameters and store away for later
1232  559A D1           	POP DE ; sfx address
1233  559B E1           	POP HL ; music address
1234  559C C5           	PUSH BC ; basic text location
1235  559D D9           	EXX
1236  559E FD 21 A5 55  	LD IY, .RET
1237  55A2 C3 99 52     	JP ENABLE_PAGE0
1238  55A5              .RET:
1239  55A5 D9           	EXX
1240  55A6
1241  55A6 D5           	PUSH DE
1242  55A7 AF           	XOR A
1243  55A8              	; HL = music location
1244  55A8 CD 62 41     	CALL PLY_AKG_INIT
1245  55AB 3E 01        	LD A, 1
1246  55AD 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1247  55B0
1248  55B0 E1           	POP HL ; SFX
1249  55B1              	; check if SFX address -1
1250  55B1 23           	INC HL
1251  55B2 7D           	LD A, L
1252  55B3 B4           	OR H
1253  55B4 28 09        	JR Z,.L1
1254  55B6 2B           	DEC HL
1255  55B7 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1256  55BA 3E 01        	LD A, 1
1257  55BC 32 F6 4C     	LD (SFX_INIT_STATUS), A
1258  55BF              .L1:
1259  55BF D1               POP DE
1260  55C0 C1               POP BC
1261  55C1 CD 10 52         CALL RESTORE_PAGE_INFO
1262  55C4
1263  55C4 E1           	POP HL
1264  55C5 C9           	RET
1265  55C6              ; *******************************************************************************************************
1266  55C6
1267  55C6              ; *******************************************************************************************************
1268  55C6              ; function to handle CALL SNDPLYON basic extension
1269  55C6              ; enables sound player
1270  55C6              ; _SNDPLYON
1271  55C6              ; sets SOUND_ENABLED variable to 1 if init call was done
1272  55C6              ; if not throws out of data error
1273  55C6              SNDPLYON:
1274  55C6 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1275  55C9 B7           	OR A
1276  55CA 20 05        	JR NZ, .L1
1277  55CC              	; player not initialized, throw error
1278  55CC 1E 04        	LD E, 04 ; Out of DATA
1279  55CE C3 FE 52     	JP THROW_ERROR
1280  55D1              .L1:
1281  55D1 32 F7 4C     	LD (SOUND_ENABLED), A
1282  55D4              	; disable key click
1283  55D4 AF           	XOR A
1284  55D5 32 DB F3     	LD (CLIKSW), A
1285  55D8 C9           	RET
1286  55D9              ; *******************************************************************************************************
1287  55D9
1288  55D9              ; *******************************************************************************************************
1289  55D9              ; function to handle CALL SNDPLYOFF basic extension
1290  55D9              ; disables sound player
1291  55D9              ; _SNDPLYOFF
1292  55D9              ; sets SOUND_ENABLED variable to 0
1293  55D9              ; calls AKG to stop music and SFX on all channels if initialized
1294  55D9              SNDPLYOFF:
1295  55D9 3A F7 4C     	LD A, (SOUND_ENABLED)
1296  55DC B7           	OR A
1297  55DD C8           	RET Z ; already stopped
1298  55DE AF           	XOR A
1299  55DF 32 F7 4C     	LD (SOUND_ENABLED), A
1300  55E2 E5           	PUSH HL
1301  55E3 CD 21 42     	CALL PLY_AKG_STOP
1302  55E6 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1303  55E9 B7           	OR A
1304  55EA 28 0E        	JR Z, .EXIT ; SFX not in use
1305  55EC AF           	XOR A
1306  55ED CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1307  55F0 3E 01        	LD A, 1
1308  55F2 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1309  55F5 3E 02        	LD A, 2
1310  55F7 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1311  55FA              .EXIT:
1312  55FA E1           	POP HL
1313  55FB C9           	RET
1314  55FC              ; *******************************************************************************************************
1315  55FC
1316  55FC              ; *******************************************************************************************************
1317  55FC              ; function to handle CALL SNDSFX basic extension
1318  55FC              ; plays a sound effect
1319  55FC              ; _SNDSFX ( BYTE sfx_number, >0
1320  55FC              ;			BYTE channel, = 0,1 or 2
1321  55FC              ;			BYTE inverted_volume = 0-16, 0 being full volume
1322  55FC              ; will put ram in page 0 also, page 1 is already there
1323  55FC              ; if sound off throws illegal function call
1324  55FC              ; if sfx not initialized, throws out of data
1325  55FC              SNDSFX:
1326  55FC              	; opening (
1327  55FC CD E6 52     	CALL CHKCHAR
1328  55FF 28           	DB '('
1329  5600              	; get sfx_number
1330  5600 DD 21 1C 52  	LD IX, GETBYT
1331  5604 CD 59 01     	CALL CALBAS
1332  5607 D5           	PUSH DE
1333  5608              	; comma
1334  5608 CD E6 52     	CALL CHKCHAR
1335  560B 2C           	DB ','
1336  560C              	; get sfx address
1337  560C DD 21 1C 52  	LD IX, GETBYT
1338  5610 CD 59 01     	CALL CALBAS
1339  5613 D5           	PUSH DE
1340  5614              	; comma
1341  5614 CD E6 52     	CALL CHKCHAR
1342  5617 2C           	DB ','
1343  5618              	; get inverted volume
1344  5618 DD 21 1C 52  	LD IX, GETBYT
1345  561C CD 59 01     	CALL CALBAS
1346  561F D5           	PUSH DE
1347  5620              	; ending )
1348  5620 CD E6 52     	CALL CHKCHAR
1349  5623 29           	DB ')'
1350  5624
1351  5624 3A F7 4C     	LD A, (SOUND_ENABLED)
1352  5627 B7           	OR A
1353  5628 20 05        	JR NZ, .L1
1354  562A              	; sound disabled, throw illegal function call
1355  562A 1E 05        	LD E, 5
1356  562C C3 FE 52     	JP THROW_ERROR
1357  562F              .L1:
1358  562F 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1359  5632 B7           	OR A
1360  5633 20 05        	JR NZ, .L2
1361  5635              	; sfx data not initialized, throw out of data
1362  5635 1E 04        	LD E, 4
1363  5637 C3 FE 52     	JP THROW_ERROR
1364  563A              .L2:
1365  563A              	; pop  parameters and store away for later
1366  563A D1           	POP DE ; inverted volume
1367  563B 43           	LD B, E
1368  563C D1           	POP DE ; channel
1369  563D 4B           	LD C, E
1370  563E D1           	POP DE
1371  563F 7B           	LD A, E
1372  5640 08           	EX AF, AF'
1373  5641 E5           	PUSH HL ; basic text location
1374  5642 D9           	EXX
1375  5643 FD 21 4A 56  	LD IY, .RET
1376  5647 C3 99 52     	JP ENABLE_PAGE0
1377  564A              .RET:
1378  564A D9           	EXX
1379  564B 08           	EX AF, AF'
1380  564C CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1381  564F
1382  564F D1               POP DE
1383  5650 C1               POP BC
1384  5651 CD 10 52         CALL RESTORE_PAGE_INFO
1385  5654
1386  5654 E1           	POP HL
1387  5655 C9           	RET
1388  5656              ; *******************************************************************************************************
1389  5656               ENDIF
1390  5656
1391  5656               IF (BLIT_CMDS == 1)
1392  5656              ; *******************************************************************************************************
1393  5656              ; function rotates mask and data of several characters and applies to background data
1394  5656              ; this handles x-shift from 0 to 4
1395  5656              ; contains self-modifying code that is set-up from external function
1396  5656              ; input HL=pointer to mask data
1397  5656              ; input HL'=pointer to character data
1398  5656              ; input DE=output buffer containing background data
1399  5656              ; input BC=DE+8
1400  5656              ; input A=number of characters to process
1401  5656              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1402  5656              SHIFT04:
1403  5656 08           	EX AF, AF'
1404  5657 7E           	LD A, (HL) ; get mask
1405  5658 D9           	EXX
1406  5659 57           	LD D, A
1407  565A 1E FF        	LD E, #FF
1408  565C 37           	SCF
1409  565D              .M1:
1410  565D 18 FE        	JR .M1 ; this is self-modifying part
1411  565F CB 1A        	RR D
1412  5661 CB 1B        	RR E
1413  5663 CB 1A        	RR D
1414  5665 CB 1B        	RR E
1415  5667 CB 1A        	RR D
1416  5669 CB 1B        	RR E
1417  566B CB 1A        	RR D
1418  566D CB 1B        	RR E
1419  566F
1420  566F 46           	LD B, (HL) ; get data
1421  5670 0E 00        	LD C, 0
1422  5672              .M2:
1423  5672 18 FE        	JR .M2 ; also self-modifying part
1424  5674 CB 38        	SRL B
1425  5676 CB 19        	RR C
1426  5678 CB 38        	SRL B
1427  567A CB 19        	RR C
1428  567C CB 38        	SRL B
1429  567E CB 19        	RR C
1430  5680 CB 38        	SRL B
1431  5682 CB 19        	RR C
1432  5684
1433  5684 D9           	EXX
1434  5685 1A           	LD A, (DE) ; background
1435  5686 D9           	EXX
1436  5687 A2           	AND D
1437  5688 B0           	OR B
1438  5689 D9           	EXX
1439  568A 12           	LD (DE), A
1440  568B
1441  568B 0A           	LD A, (BC)
1442  568C D9           	EXX
1443  568D A3           	AND E
1444  568E B1           	OR C
1445  568F 23           	INC HL
1446  5690 D9           	EXX
1447  5691 02           	LD (BC), A
1448  5692
1449  5692 23           	INC HL
1450  5693 13           	INC DE
1451  5694 03           	INC BC
1452  5695
1453  5695 08           	EX AF, AF'
1454  5696 3D           	DEC A
1455  5697 C2 56 56     	JP NZ, SHIFT04
1456  569A C9           	RET
1457  569B              ; *******************************************************************************************************
1458  569B
1459  569B              ; *******************************************************************************************************
1460  569B              ; function rotates mask and data of several characters and applies to background data
1461  569B              ; this handles x-shift from 5 to 8
1462  569B              ; contains self-modifying code that is set-up from external function
1463  569B              ; input HL=pointer to mask data
1464  569B              ; input HL'=pointer to character data
1465  569B              ; input DE=output buffer containing background data
1466  569B              ; input BC=DE+8
1467  569B              ; input A=number of characters to process
1468  569B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1469  569B              SHIFT58:
1470  569B 08           	EX AF, AF'
1471  569C 7E           	LD A, (HL) ; get mask
1472  569D D9           	EXX
1473  569E 57           	LD D, A
1474  569F 1E FF        	LD E, #FF
1475  56A1 37           	SCF
1476  56A2              .M1:
1477  56A2 18 FE        	JR .M1 ; this is self-modifying part
1478  56A4 CB 12        	RL D
1479  56A6 CB 13        	RL E
1480  56A8 CB 12        	RL D
1481  56AA CB 13        	RL E
1482  56AC CB 12        	RL D
1483  56AE CB 13        	RL E
1484  56B0
1485  56B0 46           	LD B, (HL)
1486  56B1 0E 00        	LD C, 0
1487  56B3              .M2:
1488  56B3 18 FE        	JR .M2 ; also self-modifying part
1489  56B5 CB 20        	SLA B
1490  56B7 CB 11        	RL C
1491  56B9 CB 20        	SLA B
1492  56BB CB 11        	RL C
1493  56BD CB 20        	SLA B
1494  56BF CB 11        	RL C
1495  56C1
1496  56C1 D9           	EXX
1497  56C2 1A           	LD A, (DE) ; background
1498  56C3 D9           	EXX
1499  56C4 A3           	AND E
1500  56C5 B1           	OR C
1501  56C6 D9           	EXX
1502  56C7 12           	LD (DE), A
1503  56C8
1504  56C8 0A           	LD A, (BC)
1505  56C9 D9           	EXX
1506  56CA A2           	AND D
1507  56CB B0           	OR B
1508  56CC 23           	INC HL
1509  56CD D9           	EXX
1510  56CE 02           	LD (BC), A
1511  56CF
1512  56CF 23           	INC HL
1513  56D0 13           	INC DE
1514  56D1 03           	INC BC
1515  56D2
1516  56D2 08           	EX AF, AF'
1517  56D3 3D           	DEC A
1518  56D4 C2 9B 56     	JP NZ, SHIFT58
1519  56D7 C9           	RET
1520  56D8              ; *******************************************************************************************************
1521  56D8
1522  56D8              ; *******************************************************************************************************
1523  56D8              ; routine that shifts one row of characters
1524  56D8              ; contains self-modifying code that is set-up from external function
1525  56D8              ; input HL=pointer to mask data
1526  56D8              ; input HL'=pointer to character data
1527  56D8              ; input DE=output buffer containing background data
1528  56D8              ; input A=number of characters to process
1529  56D8              ; input IX=pointer to structure describing input data
1530  56D8              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1531  56D8              SHIFT_ROW:
1532  56D8 F5           	PUSH AF
1533  56D9 ED 53 93 50  		LD (BLIT_TMP1), DE
1534  56DD E5           		PUSH HL
1535  56DE CD 21 57     			CALL .ADDYSHIFT
1536  56E1 E1           		POP HL
1537  56E2 ED 53 95 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1538  56E6              .L1:
1539  56E6 3E 08        		LD A, 8
1540  56E8 DD 96 02     		SUB (IX+2) ; y shift
1541  56EB              .CALL1:
1542  56EB CD 00 00     		CALL 0
1543  56EE DD 7E 02     		LD A, (IX+2); y shift
1544  56F1 B7           		OR A
1545  56F2 28 26        		JR Z, .DONE
1546  56F4 ED 5B 93 50  		LD DE, (BLIT_TMP1)
1547  56F8 E5           		PUSH HL
1548  56F9 CD 2F 57     			CALL .DETONEXTROW
1549  56FC E1           		POP HL
1550  56FD              .CALL2:
1551  56FD CD 00 00     		CALL 0
1552  5700 ED 5B 93 50  		LD DE, (BLIT_TMP1)
1553  5704 E5           		PUSH HL
1554  5705 CD 29 57     			CALL .ADD8
1555  5708 E1           		POP HL
1556  5709 ED 53 93 50  		LD (BLIT_TMP1), DE
1557  570D ED 5B 95 50  		LD DE, (BLIT_TMP2)
1558  5711 E5           		PUSH HL
1559  5712 CD 29 57     			CALL .ADD8
1560  5715 E1           		POP HL
1561  5716 ED 53 95 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1562  571A              .DONE:
1563  571A F1           	POP AF
1564  571B 3D           	DEC A
1565  571C C8           	RET Z
1566  571D F5           	PUSH AF
1567  571E C3 E6 56     	JP .L1
1568  5721              .ADDYSHIFT:
1569  5721 EB           	EX DE, HL
1570  5722 16 00        	LD D, 0
1571  5724 DD 5E 02     	LD E, (IX+2); y shift
1572  5727 18 0C        	JR .MOVDEBC
1573  5729              .ADD8:
1574  5729 21 08 00     	LD HL, 8
1575  572C C3 35 57     	JP .MOVDEBC
1576  572F              .DETONEXTROW:
1577  572F DD 6E 06     	LD L, (IX+6)
1578  5732 DD 66 07     	LD H, (IX+7) ; bkg add to value
1579  5735              .MOVDEBC:
1580  5735 19           	ADD HL, DE
1581  5736 54           	LD D, H
1582  5737 5D           	LD E, L
1583  5738 01 08 00     	LD BC, 8
1584  573B 09           	ADD HL, BC
1585  573C 44           	LD B, H
1586  573D 4D           	LD C, L
1587  573E C9           	RET
1588  573F              ; *******************************************************************************************************
1589  573F
1590  573F              ; *******************************************************************************************************
1591  573F              ; function rotates mask and character data and applies it to background
1592  573F              ; input IX=pointer to structure describing input data
1593  573F              ; +0  DW horizontal shift count 0-7 (low byte used)
1594  573F              ; +2  DW vertical shift count 0-7 (low byte used)
1595  573F              ; +4  DW background data start;
1596  573F              ; +6  DW background add to value to next row of background data
1597  573F              ; +8  DW mask data start;
1598  573F              ; +10  DW character data start;
1599  573F              ; +12 DW character&mask add to value to next row of data
1600  573F              ; +14 DW columns (low byte used)
1601  573F              ; +16 DW rows (low byte used)
1602  573F              SHIFT_MERGE_CHARACTER:
1603  573F DD 7E 00     	LD A, (IX) ; shift
1604  5742 FE 05        	CP 5
1605  5744 38 25        	JR C, .RIGHT
1606  5746              	; shifts 5-7, use rotate towards left 1-3
1607  5746 21 9B 56     	LD HL, SHIFT58
1608  5749 22 EC 56     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1609  574C 22 FE 56     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1610  574F D6 05        	SUB 5
1611  5751 28 0D        	JR Z, .L1
1612  5753 87           	ADD A, A
1613  5754 87           	ADD A, A
1614  5755 67           	LD H, A
1615  5756 2E 18        	LD L, #18 ; JR opcode
1616  5758 22 A2 56     	LD (SHIFT58.M1), HL
1617  575B 22 B3 56     	LD (SHIFT58.M2), HL
1618  575E 18 32        	JR .DO
1619  5760              .L1:
1620  5760 21 00 00     	LD HL, 0 ; 2xNOP opcode
1621  5763 22 A2 56     	LD (SHIFT58.M1), HL
1622  5766 22 B3 56     	LD (SHIFT58.M2), HL
1623  5769 18 27        	JR .DO
1624  576B              .RIGHT:
1625  576B              	; shifts 0-4, rotate towards right
1626  576B 21 56 56     	LD HL, SHIFT04
1627  576E 22 EC 56     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1628  5771 22 FE 56     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1629  5774 FE 04        	CP 4
1630  5776 28 11        	JR Z, .R1
1631  5778 D6 04        	SUB 4
1632  577A ED 44        	NEG
1633  577C 87           	ADD A, A
1634  577D 87           	ADD A, A
1635  577E 67           	LD H, A
1636  577F 2E 18        	LD L, #18 ; JR opcode
1637  5781 22 5D 56     	LD (SHIFT04.M1), HL
1638  5784 22 72 56     	LD (SHIFT04.M2), HL
1639  5787 18 09        	JR .DO
1640  5789              .R1:
1641  5789 21 00 00     	LD HL, 0 ; 2xNOP opcode
1642  578C 22 5D 56     	LD (SHIFT04.M1), HL
1643  578F 22 72 56     	LD (SHIFT04.M2), HL
1644  5792              .DO:
1645  5792 DD 46 10     	LD B, (IX+16) ; rows
1646  5795 DD 6E 08     	LD L, (IX+8)
1647  5798 DD 66 09     	LD H, (IX+9) ; mask data
1648  579B DD 5E 04     	LD E, (IX+4)
1649  579E DD 56 05     	LD D, (IX+5) ; background data
1650  57A1 D9           	EXX
1651  57A2 DD 6E 0A     	LD L, (IX+10)
1652  57A5 DD 66 0B     	LD H, (IX+11) ; character data
1653  57A8 D9           	EXX
1654  57A9              .LOOP:
1655  57A9 C5           	PUSH BC
1656  57AA E5           		PUSH HL
1657  57AB D5           			PUSH DE
1658  57AC D9           				EXX
1659  57AD E5           				PUSH HL
1660  57AE D9           					EXX
1661  57AF DD 7E 0E     					LD A, (IX+14) ; columns
1662  57B2              .CALL:
1663  57B2 CD D8 56     					CALL SHIFT_ROW
1664  57B5 E1           				POP HL
1665  57B6 DD 5E 0C     				LD E, (IX+12)
1666  57B9 DD 56 0D     				LD D, (IX+13) ; char data to next row
1667  57BC 19           				ADD HL, DE
1668  57BD D9           				EXX
1669  57BE E1           			POP HL
1670  57BF DD 5E 06     			LD E, (IX+6)
1671  57C2 DD 56 07     			LD D, (IX+7) ; background to next row
1672  57C5 19           			ADD HL, DE
1673  57C6 EB           			EX DE, HL
1674  57C7 E1           		POP HL
1675  57C8 DD 4E 0C     		LD C, (IX+12)
1676  57CB DD 46 0D     		LD B, (IX+13) ; char data to next row
1677  57CE 09           		ADD HL, BC
1678  57CF C1           	POP BC
1679  57D0 10 D7        	DJNZ .LOOP
1680  57D2 C9           	RET
1681  57D3              ; *******************************************************************************************************
1682  57D3
1683  57D3               IFNDEF CMDS_WITH_PARAMETERS
1684  57D3 ~            ; *******************************************************************************************************
1685  57D3 ~            ; function to handle CALL BLIT basic extension
1686  57D3 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1687  57D3 ~            ; fuses with background data and applies vertical shift too
1688  57D3 ~            ; BLIT ( INT request_data_ptr )
1689  57D3 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1690  57D3 ~            ; will put ram in page 0 also, page 1 is already there
1691  57D3 ~            BLIT:
1692  57D3 ~            	; opening (
1693  57D3 ~            	CALL CHKCHAR
1694  57D3 ~            	DB '('
1695  57D3 ~            	; get pointer to request struct
1696  57D3 ~            	LD IX, FRMQNT
1697  57D3 ~            	CALL CALBAS
1698  57D3 ~            	PUSH DE
1699  57D3 ~            	; ending )
1700  57D3 ~            	CALL CHKCHAR
1701  57D3 ~            	DB ')'
1702  57D3 ~
1703  57D3 ~            	POP IX ; pointer to request struct
1704  57D3 ~
1705  57D3 ~            	PUSH HL ; save position in BASIC buffer
1706  57D3 ~
1707  57D3 ~            	LD IY, .RET
1708  57D3 ~            	JP ENABLE_PAGE0
1709  57D3 ~            .RET:
1710  57D3 ~            	EI
1711  57D3 ~            	CALL SHIFT_MERGE_CHARACTER
1712  57D3 ~
1713  57D3 ~                POP DE
1714  57D3 ~                POP BC
1715  57D3 ~                CALL RESTORE_PAGE_INFO
1716  57D3 ~
1717  57D3 ~            	POP HL
1718  57D3 ~            	RET
1719  57D3 ~            ; *******************************************************************************************************
1720  57D3               ENDIF
1721  57D3
1722  57D3               IFDEF CMDS_WITH_PARAMETERS
1723  57D3              ; *******************************************************************************************************
1724  57D3              ; function to handle CALL BLIT basic extension
1725  57D3              ; rotates 1-bit character drawing horizontally with mask and character data and
1726  57D3              ; fuses with background data and applies vertical shift too
1727  57D3              ; in form without pointers
1728  57D3              ; BLIT ( INT x,
1729  57D3              ;		 INT y,
1730  57D3              ;		 INT char_data_pointer,
1731  57D3              ;		 INT mask_data_pointer,
1732  57D3              ;		 INT width (in characters),
1733  57D3              ;		 INT height (in characters),
1734  57D3              ;		 INT background_pointer (top left),
1735  57D3              ;		 INT background_width (in characters),
1736  57D3              ;		 INT background_height (in characters))
1737  57D3              ; will put ram in page 0 also, page 1 is already there
1738  57D3              BLIT:
1739  57D3              	; opening (
1740  57D3 CD E6 52     	CALL CHKCHAR
1741  57D6 28           	DB '('
1742  57D7              	; get x coordinate
1743  57D7 DD 21 2F 54  	LD IX, FRMQNT
1744  57DB CD 59 01     	CALL CALBAS
1745  57DE 7B           	LD A, E
1746  57DF E6 07        	AND 7
1747  57E1 32 97 50     	LD (BLIT_STRUCT+0), A
1748  57E4 CD C1 58     	CALL .DAdiv8
1749  57E7 32 93 50     	LD (BLIT_TMP+0),A
1750  57EA              	; comma
1751  57EA CD E6 52     	CALL CHKCHAR
1752  57ED 2C           	DB ','
1753  57EE              	; get y coordinate
1754  57EE DD 21 2F 54  	LD IX, FRMQNT
1755  57F2 CD 59 01     	CALL CALBAS
1756  57F5 7B           	LD A, E
1757  57F6 E6 07        	AND 7
1758  57F8 32 99 50     	LD (BLIT_STRUCT+2), A
1759  57FB CD C1 58     	CALL .DAdiv8
1760  57FE 32 94 50     	LD (BLIT_TMP+1),A
1761  5801              	; comma
1762  5801 CD E6 52     	CALL CHKCHAR
1763  5804 2C           	DB ','
1764  5805              	; get char data pointer
1765  5805 DD 21 2F 54  	LD IX, FRMQNT
1766  5809 CD 59 01     	CALL CALBAS
1767  580C ED 53 A1 50  	LD (BLIT_STRUCT+10), DE
1768  5810              	; comma
1769  5810 CD E6 52     	CALL CHKCHAR
1770  5813 2C           	DB ','
1771  5814              	; get mask data pointer
1772  5814 DD 21 2F 54  	LD IX, FRMQNT
1773  5818 CD 59 01     	CALL CALBAS
1774  581B ED 53 9F 50  	LD (BLIT_STRUCT+8), DE
1775  581F              	; comma
1776  581F CD E6 52     	CALL CHKCHAR
1777  5822 2C           	DB ','
1778  5823              	; get width
1779  5823 DD 21 2F 54  	LD IX, FRMQNT
1780  5827 CD 59 01     	CALL CALBAS
1781  582A 7B           	LD A, E
1782  582B 32 A5 50     	LD (BLIT_STRUCT+14), A
1783  582E              	; comma
1784  582E CD E6 52     	CALL CHKCHAR
1785  5831 2C           	DB ','
1786  5832              	; get height
1787  5832 DD 21 2F 54  	LD IX, FRMQNT
1788  5836 CD 59 01     	CALL CALBAS
1789  5839 7B           	LD A, E
1790  583A 32 A7 50     	LD (BLIT_STRUCT+16), A
1791  583D              	; comma
1792  583D CD E6 52     	CALL CHKCHAR
1793  5840 2C           	DB ','
1794  5841              	; get background pointer
1795  5841 DD 21 2F 54  	LD IX, FRMQNT
1796  5845 CD 59 01     	CALL CALBAS
1797  5848 ED 53 9B 50  	LD (BLIT_STRUCT+4), DE
1798  584C              	; comma
1799  584C CD E6 52     	CALL CHKCHAR
1800  584F 2C           	DB ','
1801  5850              	; get background width
1802  5850 DD 21 2F 54  	LD IX, FRMQNT
1803  5854 CD 59 01     	CALL CALBAS
1804  5857 7B           	LD A, E
1805  5858 32 95 50     	LD (BLIT_TMP+2), A
1806  585B              	; comma
1807  585B CD E6 52     	CALL CHKCHAR
1808  585E 2C           	DB ','
1809  585F              	; get background height
1810  585F DD 21 2F 54  	LD IX, FRMQNT
1811  5863 CD 59 01     	CALL CALBAS
1812  5866 7B           	LD A, E
1813  5867 32 96 50     	LD (BLIT_TMP+3), A
1814  586A              	; ending )
1815  586A CD E6 52     	CALL CHKCHAR
1816  586D 29           	DB ')'
1817  586E
1818  586E E5           	PUSH HL ; save position in BASIC buffer
1819  586F
1820  586F              	; calculate char&mask add to value
1821  586F 26 00        	LD H, 0
1822  5871 3A A5 50     	LD A, (BLIT_STRUCT+14)
1823  5874 6F           	LD L, A
1824  5875 CD D5 51     	CALL HLx8
1825  5878 22 A3 50     	LD (BLIT_STRUCT+12), HL
1826  587B              	; calculate background add to value
1827  587B 26 00        	LD H, 0
1828  587D 3A 95 50     	LD A, (BLIT_TMP+2)
1829  5880 6F           	LD L, A
1830  5881 CD D5 51     	CALL HLx8
1831  5884 22 9D 50     	LD (BLIT_STRUCT+6), HL
1832  5887              	; calculate pointer to background location
1833  5887 21 00 00     	LD HL, 0
1834  588A 3A 94 50     	LD A,(BLIT_TMP+1)
1835  588D B7           	OR A
1836  588E 28 08        	JR Z, .L1
1837  5890 47           	LD B,A
1838  5891 ED 5B 9D 50  	LD DE,(BLIT_STRUCT+6)
1839  5895              .L0:
1840  5895 19           	ADD HL, DE
1841  5896 10 FD        	DJNZ .L0
1842  5898              .L1:
1843  5898 EB           	EX DE,HL
1844  5899 26 00        	LD H,0
1845  589B 3A 93 50     	LD A,(BLIT_TMP+0)
1846  589E 6F           	LD L,A
1847  589F CD D5 51     	CALL HLx8
1848  58A2 19           	ADD HL,DE
1849  58A3 ED 5B 9B 50  	LD DE,(BLIT_STRUCT+4)
1850  58A7 19           	ADD HL,DE
1851  58A8 22 9B 50     	LD (BLIT_STRUCT+4),HL
1852  58AB
1853  58AB FD 21 B2 58  	LD IY, .RET
1854  58AF C3 99 52     	JP ENABLE_PAGE0
1855  58B2              .RET:
1856  58B2 FB           	EI
1857  58B3 DD 21 97 50  	LD IX, BLIT_STRUCT
1858  58B7 CD 3F 57     	CALL SHIFT_MERGE_CHARACTER
1859  58BA
1860  58BA D1               POP DE
1861  58BB C1               POP BC
1862  58BC CD 10 52         CALL RESTORE_PAGE_INFO
1863  58BF
1864  58BF E1           	POP HL
1865  58C0 C9           	RET
1866  58C1              .DAdiv8:
1867  58C1 7B           	LD A,E
1868  58C2 CB 2A        	SRA D
1869  58C4 CB 1F            RR  A
1870  58C6 CB 2A            SRA D
1871  58C8 CB 1F            RR  A
1872  58CA CB 2A            SRA D
1873  58CC CB 1F            RR  A
1874  58CE C9           	RET
1875  58CF              ; *******************************************************************************************************
1876  58CF               ENDIF
1877  58CF               ENDIF
1878  58CF
1879  58CF               IF (TILE_CMDS == 1)
1880  58CF              ; *******************************************************************************************************
1881  58CF              ; generic function to implement tiling
1882  58CF              ; should be modified to call appropriate function for memory or vram
1883  58CF              ; input IX=pointer to following structure
1884  58CF              ; +00 tile_data_ptr
1885  58CF              ; +02 tile_rows
1886  58CF              ; +04 tile_columns
1887  58CF              ; +06 destination_address
1888  58CF              ; +08 dest_to_next_row_add_to_value
1889  58CF              ; +10 num_horizontal_tiles
1890  58CF              ; +12 num_vertical_tiles
1891  58CF              ; modifies AF, BC, DE, HL
1892  58CF              TILE:
1893  58CF DD 6E 06     	LD L, (IX+6)
1894  58D2 DD 66 07     	LD H, (IX+7) ; destination address
1895  58D5 22 93 50     	LD (TILETMP1), HL
1896  58D8 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1897  58DB              .L1:
1898  58DB C5           	PUSH BC
1899  58DC DD 6E 00     		LD L, (IX+0)
1900  58DF DD 66 01     		LD H, (IX+1) ; tile address
1901  58E2 22 95 50     		LD (TILETMP2), HL
1902  58E5 DD 46 02     		LD B, (IX+2) ; tile rows
1903  58E8              .L2:
1904  58E8 C5           		PUSH BC
1905  58E9              .CALL1:
1906  58E9 CD 00 00     			CALL 0
1907  58EC DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1908  58EF              .L3:
1909  58EF C5           			PUSH BC
1910  58F0 2A 95 50     				LD HL, (TILETMP2)
1911  58F3 DD 46 04     				LD B, (IX+4) ; tile columns
1912  58F6              .L4:
1913  58F6 C5           				PUSH BC
1914  58F7              .CALL2:
1915  58F7 CD 00 00     					CALL 0
1916  58FA C1           				POP BC
1917  58FB 10 F9        				DJNZ .L4
1918  58FD C1           			POP BC
1919  58FE 10 EF        			DJNZ .L3
1920  5900 22 95 50     			LD (TILETMP2), HL
1921  5903 2A 93 50     			LD HL, (TILETMP1)
1922  5906 DD 5E 08     			LD E, (IX+8)
1923  5909 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1924  590C 19           			ADD HL, DE
1925  590D 22 93 50     			LD (TILETMP1), HL
1926  5910 C1           		POP BC
1927  5911 10 D5        		DJNZ .L2
1928  5913 C1           	POP BC
1929  5914 10 C5        	DJNZ .L1
1930  5916 C9           	RET
1931  5917              ; *******************************************************************************************************
1932  5917
1933  5917               IFNDEF CMDS_WITH_PARAMETERS
1934  5917 ~            ; *******************************************************************************************************
1935  5917 ~            ; function to handle CALL TILERAM basic extension
1936  5917 ~            ; fills memory with tiles
1937  5917 ~            ; TILERAM ( INT request_data_ptr )
1938  5917 ~            ; request_data_ptr described in TILE
1939  5917 ~            ; will put ram in page 0 also, page 1 is already there
1940  5917 ~            TILERAM:
1941  5917 ~            	; opening (
1942  5917 ~            	CALL CHKCHAR
1943  5917 ~            	DB '('
1944  5917 ~            	; get pointer to request struct
1945  5917 ~            	LD IX, FRMQNT
1946  5917 ~            	CALL CALBAS
1947  5917 ~            	PUSH DE
1948  5917 ~            	; ending )
1949  5917 ~            	CALL CHKCHAR
1950  5917 ~            	DB ')'
1951  5917 ~
1952  5917 ~            	POP IX ; pointer to request struct
1953  5917 ~
1954  5917 ~            	PUSH HL ; save position in BASIC buffer
1955  5917 ~
1956  5917 ~            	LD IY, .RET
1957  5917 ~            	JP ENABLE_PAGE0
1958  5917 ~            .RET:
1959  5917 ~            	EI
1960  5917 ~            	; set RAM functions to call
1961  5917 ~            	LD HL, .TILECOPY
1962  5917 ~            	LD (TILE.CALL2+1), HL
1963  5917 ~            	LD HL, .SETDESTROW
1964  5917 ~            	LD (TILE.CALL1+1), HL
1965  5917 ~            	CALL TILE
1966  5917 ~
1967  5917 ~                POP DE
1968  5917 ~                POP BC
1969  5917 ~                CALL RESTORE_PAGE_INFO
1970  5917 ~
1971  5917 ~            	POP HL
1972  5917 ~            	RET
1973  5917 ~            .TILECOPY:
1974  5917 ~            	.8 LDI
1975  5917 ~            	RET
1976  5917 ~            .SETDESTROW:
1977  5917 ~            	LD DE, (TILETMP1)
1978  5917 ~            	RET
1979  5917 ~            ; *******************************************************************************************************
1980  5917               ENDIF
1981  5917
1982  5917               IFDEF CMDS_WITH_PARAMETERS
1983  5917              ; *******************************************************************************************************
1984  5917              ; function to handle CALL TILERAM basic extension
1985  5917              ; fills memory with tiles
1986  5917              ; TILERAM ( INT tile_data_pointer,
1987  5917              ;			INT tile_columns,
1988  5917              ;			INT tile_rows,
1989  5917              ;			INT destination_pointer,
1990  5917              ;			INT destination_columns,
1991  5917              ;			INT destination_rows,
1992  5917              ;			INT destination_begin_column,
1993  5917              ;			INT destination_begin_row,
1994  5917              ;			INT number_of_tiles_horizontally,
1995  5917              ;			INT	number_of_tiles_vertically )
1996  5917              ; will put ram in page 0 also, page 1 is already there
1997  5917              TILERAM:
1998  5917              	; opening (
1999  5917 CD E6 52     	CALL CHKCHAR
2000  591A 28           	DB '('
2001  591B              	; get tile data pointer coordinate
2002  591B DD 21 2F 54  	LD IX, FRMQNT
2003  591F CD 59 01     	CALL CALBAS
2004  5922 ED 53 97 50  	LD (BLIT_STRUCT+0), DE
2005  5926              	; comma
2006  5926 CD E6 52     	CALL CHKCHAR
2007  5929 2C           	DB ','
2008  592A              	; get tile columns
2009  592A DD 21 2F 54  	LD IX, FRMQNT
2010  592E CD 59 01     	CALL CALBAS
2011  5931 ED 53 9B 50  	LD (BLIT_STRUCT+4), DE
2012  5935              	; comma
2013  5935 CD E6 52     	CALL CHKCHAR
2014  5938 2C           	DB ','
2015  5939              	; get tile columns
2016  5939 DD 21 2F 54  	LD IX, FRMQNT
2017  593D CD 59 01     	CALL CALBAS
2018  5940 ED 53 99 50  	LD (BLIT_STRUCT+2), DE
2019  5944              	; comma
2020  5944 CD E6 52     	CALL CHKCHAR
2021  5947 2C           	DB ','
2022  5948              	; get destintion pointer
2023  5948 DD 21 2F 54  	LD IX, FRMQNT
2024  594C CD 59 01     	CALL CALBAS
2025  594F ED 53 9D 50  	LD (BLIT_STRUCT+6), DE
2026  5953              	; comma
2027  5953 CD E6 52     	CALL CHKCHAR
2028  5956 2C           	DB ','
2029  5957              	; get destination columns
2030  5957 DD 21 2F 54  	LD IX, FRMQNT
2031  595B CD 59 01     	CALL CALBAS
2032  595E 7B           	LD A, E
2033  595F 32 93 50     	LD (BLIT_TMP+0), A
2034  5962              	; comma
2035  5962 CD E6 52     	CALL CHKCHAR
2036  5965 2C           	DB ','
2037  5966              	; get destination rows
2038  5966 DD 21 2F 54  	LD IX, FRMQNT
2039  596A CD 59 01     	CALL CALBAS
2040  596D 7B           	LD A, E
2041  596E 32 94 50     	LD (BLIT_TMP+1), A
2042  5971              	; comma
2043  5971 CD E6 52     	CALL CHKCHAR
2044  5974 2C           	DB ','
2045  5975              	; get destination begin column
2046  5975 DD 21 2F 54  	LD IX, FRMQNT
2047  5979 CD 59 01     	CALL CALBAS
2048  597C 7B           	LD A, E
2049  597D 32 95 50     	LD (BLIT_TMP+2), A
2050  5980              	; comma
2051  5980 CD E6 52     	CALL CHKCHAR
2052  5983 2C           	DB ','
2053  5984              	; get destination begin row
2054  5984 DD 21 2F 54  	LD IX, FRMQNT
2055  5988 CD 59 01     	CALL CALBAS
2056  598B 7B           	LD A, E
2057  598C 32 96 50     	LD (BLIT_TMP+3), A
2058  598F              	; comma
2059  598F CD E6 52     	CALL CHKCHAR
2060  5992 2C           	DB ','
2061  5993              	; get number of tiles horizontally
2062  5993 DD 21 2F 54  	LD IX, FRMQNT
2063  5997 CD 59 01     	CALL CALBAS
2064  599A ED 53 A1 50  	LD (BLIT_STRUCT+10), DE
2065  599E              	; comma
2066  599E CD E6 52     	CALL CHKCHAR
2067  59A1 2C           	DB ','
2068  59A2              	; get number of tiles vertically
2069  59A2 DD 21 2F 54  	LD IX, FRMQNT
2070  59A6 CD 59 01     	CALL CALBAS
2071  59A9 ED 53 A3 50  	LD (BLIT_STRUCT+12), DE
2072  59AD              	; ending )
2073  59AD CD E6 52     	CALL CHKCHAR
2074  59B0 29           	DB ')'
2075  59B1
2076  59B1 E5           	PUSH HL ; save position in BASIC buffer
2077  59B2
2078  59B2              	; calculate destination add to value
2079  59B2 26 00        	LD H, 0
2080  59B4 3A 93 50     	LD A, (BLIT_TMP+0)
2081  59B7 6F           	LD L, A
2082  59B8 CD D5 51     	CALL HLx8
2083  59BB 22 9F 50     	LD (BLIT_STRUCT+8), HL
2084  59BE              	; calculate pointer to background location
2085  59BE 21 00 00     	LD HL, 0
2086  59C1 3A 96 50     	LD A,(BLIT_TMP+3)
2087  59C4 B7           	OR A
2088  59C5 28 08        	JR Z, .L1
2089  59C7 47           	LD B,A
2090  59C8 ED 5B 9F 50  	LD DE,(BLIT_STRUCT+8)
2091  59CC              .L0:
2092  59CC 19           	ADD HL, DE
2093  59CD 10 FD        	DJNZ .L0
2094  59CF              .L1:
2095  59CF EB           	EX DE,HL
2096  59D0 26 00        	LD H,0
2097  59D2 3A 95 50     	LD A,(BLIT_TMP+2)
2098  59D5 6F           	LD L,A
2099  59D6 CD D5 51     	CALL HLx8
2100  59D9 19           	ADD HL,DE
2101  59DA ED 5B 9D 50  	LD DE,(BLIT_STRUCT+6)
2102  59DE 19           	ADD HL,DE
2103  59DF 22 9D 50     	LD (BLIT_STRUCT+6),HL
2104  59E2
2105  59E2 FD 21 E9 59  	LD IY, .RET
2106  59E6 C3 99 52     	JP ENABLE_PAGE0
2107  59E9              .RET:
2108  59E9 FB           	EI
2109  59EA              	; set RAM functions to call
2110  59EA 21 04 5A     	LD HL, .TILECOPY
2111  59ED 22 F8 58     	LD (TILE.CALL2+1), HL
2112  59F0 21 15 5A     	LD HL, .SETDESTROW
2113  59F3 22 EA 58     	LD (TILE.CALL1+1), HL
2114  59F6 DD 21 97 50  	LD IX,BLIT_STRUCT
2115  59FA CD CF 58     	CALL TILE
2116  59FD
2117  59FD D1               POP DE
2118  59FE C1               POP BC
2119  59FF CD 10 52         CALL RESTORE_PAGE_INFO
2120  5A02
2121  5A02 E1           	POP HL
2122  5A03 C9           	RET
2123  5A04              .TILECOPY:
2124  5A04 ED A0       > LDI
2124  5A06 ED A0       > LDI
2124  5A08 ED A0       > LDI
2124  5A0A ED A0       > LDI
2124  5A0C ED A0       > LDI
2124  5A0E ED A0       > LDI
2124  5A10 ED A0       > LDI
2124  5A12 ED A0       > LDI
2125  5A14 C9           	RET
2126  5A15              .SETDESTROW:
2127  5A15 ED 5B 93 50  	LD DE, (TILETMP1)
2128  5A19 C9           	RET
2129  5A1A              ; *******************************************************************************************************
2130  5A1A               ENDIF
2131  5A1A
2132  5A1A               IFDEF CMDS_WITH_PARAMETERS
2133  5A1A              ; *******************************************************************************************************
2134  5A1A              ; function to handle CALL TILEVRM basic extension
2135  5A1A              ; fills vram with tiles
2136  5A1A              ; TILEVRM ( INT tile_data_pointer,
2137  5A1A              ;			INT tile_columns,
2138  5A1A              ;			INT tile_rows,
2139  5A1A              ;			INT destination_begin_column,
2140  5A1A              ;			INT destination_begin_row,
2141  5A1A              ;			INT number_of_tiles_horizontally,
2142  5A1A              ;			INT	number_of_tiles_vertically )
2143  5A1A              ; will put ram in page 0 also, page 1 is already there
2144  5A1A              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2145  5A1A              TILEVRM:
2146  5A1A              	; opening (
2147  5A1A CD E6 52     	CALL CHKCHAR
2148  5A1D 28           	DB '('
2149  5A1E              	; get tile data pointer coordinate
2150  5A1E DD 21 2F 54  	LD IX, FRMQNT
2151  5A22 CD 59 01     	CALL CALBAS
2152  5A25 ED 53 97 50  	LD (BLIT_STRUCT+0), DE
2153  5A29              	; comma
2154  5A29 CD E6 52     	CALL CHKCHAR
2155  5A2C 2C           	DB ','
2156  5A2D              	; get tile columns
2157  5A2D DD 21 2F 54  	LD IX, FRMQNT
2158  5A31 CD 59 01     	CALL CALBAS
2159  5A34 ED 53 9B 50  	LD (BLIT_STRUCT+4), DE
2160  5A38              	; comma
2161  5A38 CD E6 52     	CALL CHKCHAR
2162  5A3B 2C           	DB ','
2163  5A3C              	; get tile columns
2164  5A3C DD 21 2F 54  	LD IX, FRMQNT
2165  5A40 CD 59 01     	CALL CALBAS
2166  5A43 ED 53 99 50  	LD (BLIT_STRUCT+2), DE
2167  5A47              	; comma
2168  5A47 CD E6 52     	CALL CHKCHAR
2169  5A4A 2C           	DB ','
2170  5A4B              	; get destination begin column
2171  5A4B DD 21 2F 54  	LD IX, FRMQNT
2172  5A4F CD 59 01     	CALL CALBAS
2173  5A52 7B           	LD A, E
2174  5A53 32 95 50     	LD (BLIT_TMP+2), A
2175  5A56              	; comma
2176  5A56 CD E6 52     	CALL CHKCHAR
2177  5A59 2C           	DB ','
2178  5A5A              	; get destination begin row
2179  5A5A DD 21 2F 54  	LD IX, FRMQNT
2180  5A5E CD 59 01     	CALL CALBAS
2181  5A61 7B           	LD A, E
2182  5A62 32 96 50     	LD (BLIT_TMP+3), A
2183  5A65              	; comma
2184  5A65 CD E6 52     	CALL CHKCHAR
2185  5A68 2C           	DB ','
2186  5A69              	; get number of tiles horizontally
2187  5A69 DD 21 2F 54  	LD IX, FRMQNT
2188  5A6D CD 59 01     	CALL CALBAS
2189  5A70 ED 53 A1 50  	LD (BLIT_STRUCT+10), DE
2190  5A74              	; comma
2191  5A74 CD E6 52     	CALL CHKCHAR
2192  5A77 2C           	DB ','
2193  5A78              	; get number of tiles vertically
2194  5A78 DD 21 2F 54  	LD IX, FRMQNT
2195  5A7C CD 59 01     	CALL CALBAS
2196  5A7F ED 53 A3 50  	LD (BLIT_STRUCT+12), DE
2197  5A83              	; ending )
2198  5A83 CD E6 52     	CALL CHKCHAR
2199  5A86 29           	DB ')'
2200  5A87
2201  5A87 E5           	PUSH HL ; save position in BASIC buffer
2202  5A88
2203  5A88              	; calculate destination add to value
2204  5A88 21 00 01     	LD HL, 256
2205  5A8B 22 9F 50     	LD (BLIT_STRUCT+8), HL
2206  5A8E              	; calculate pointer to background location
2207  5A8E 3A 96 50     	LD A,(BLIT_TMP+3)
2208  5A91 67           	LD H,A
2209  5A92 2E 00        	LD L,0
2210  5A94 EB           	EX DE,HL
2211  5A95 26 00        	LD H,0
2212  5A97 3A 95 50     	LD A,(BLIT_TMP+2)
2213  5A9A 6F           	LD L,A
2214  5A9B CD D5 51     	CALL HLx8
2215  5A9E 19           	ADD HL,DE
2216  5A9F ED 5B CB F3  	LD DE,(GRPCGP)
2217  5AA3 19           	ADD HL,DE
2218  5AA4 22 9D 50     	LD (BLIT_STRUCT+6),HL
2219  5AA7
2220  5AA7 FD 21 AE 5A  	LD IY, .RET
2221  5AAB C3 99 52     	JP ENABLE_PAGE0
2222  5AAE              .RET:
2223  5AAE FB           	EI
2224  5AAF              	; set RAM functions to call
2225  5AAF 21 C9 5A     	LD HL, .TILECOPY
2226  5AB2 22 F8 58     	LD (TILE.CALL2+1), HL
2227  5AB5 21 CF 5A     	LD HL, .SETDESTROW
2228  5AB8 22 EA 58     	LD (TILE.CALL1+1), HL
2229  5ABB DD 21 97 50  	LD IX,BLIT_STRUCT
2230  5ABF CD CF 58     	CALL TILE
2231  5AC2
2232  5AC2 D1               POP DE
2233  5AC3 C1               POP BC
2234  5AC4 CD 10 52         CALL RESTORE_PAGE_INFO
2235  5AC7
2236  5AC7 E1           	POP HL
2237  5AC8 C9           	RET
2238  5AC9              .TILECOPY:
2239  5AC9 01 98 08     	LD BC, #0898
2240  5ACC C3 CF 51     	JP BBYTECOPY
2241  5ACF              .SETDESTROW:
2242  5ACF 2A 93 50     	LD HL, (TILETMP1)
2243  5AD2 F3           	DI
2244  5AD3 CD C4 51     	CALL SETWRT_LOCAL
2245  5AD6 FB           	EI
2246  5AD7 C9           	RET
2247  5AD8              ; *******************************************************************************************************
2248  5AD8               ENDIF
2249  5AD8
2250  5AD8               IFNDEF CMDS_WITH_PARAMETERS
2251  5AD8 ~            ; *******************************************************************************************************
2252  5AD8 ~            ; function to handle CALL TILEVRM basic extension
2253  5AD8 ~            ; fills vram with tiles
2254  5AD8 ~            ; TILEVRM ( INT request_data_ptr )
2255  5AD8 ~            ; request_data_ptr described in TILE
2256  5AD8 ~            ; will put ram in page 0 also, page 1 is already there
2257  5AD8 ~            TILEVRM:
2258  5AD8 ~            	; opening (
2259  5AD8 ~            	CALL CHKCHAR
2260  5AD8 ~            	DB '('
2261  5AD8 ~            	; get pointer to request struct
2262  5AD8 ~            	LD IX, FRMQNT
2263  5AD8 ~            	CALL CALBAS
2264  5AD8 ~            	PUSH DE
2265  5AD8 ~            	; ending )
2266  5AD8 ~            	CALL CHKCHAR
2267  5AD8 ~            	DB ')'
2268  5AD8 ~
2269  5AD8 ~            	POP IX ; pointer to request struct
2270  5AD8 ~
2271  5AD8 ~            	PUSH HL ; save position in BASIC buffer
2272  5AD8 ~
2273  5AD8 ~            	LD IY, .RET
2274  5AD8 ~            	JP ENABLE_PAGE0
2275  5AD8 ~            .RET:
2276  5AD8 ~            	EI
2277  5AD8 ~            	; set RAM functions to call
2278  5AD8 ~            	LD HL, .TILECOPY
2279  5AD8 ~            	LD (TILE.CALL2+1), HL
2280  5AD8 ~            	LD HL, .SETDESTROW
2281  5AD8 ~            	LD (TILE.CALL1+1), HL
2282  5AD8 ~            	CALL TILE
2283  5AD8 ~
2284  5AD8 ~                POP DE
2285  5AD8 ~                POP BC
2286  5AD8 ~                CALL RESTORE_PAGE_INFO
2287  5AD8 ~
2288  5AD8 ~            	POP HL
2289  5AD8 ~            	RET
2290  5AD8 ~            .TILECOPY:
2291  5AD8 ~            	LD BC, #0898
2292  5AD8 ~            	JP BBYTECOPY
2293  5AD8 ~            .SETDESTROW:
2294  5AD8 ~            	LD HL, (TILETMP1)
2295  5AD8 ~            	DI
2296  5AD8 ~            	CALL SETWRT_LOCAL
2297  5AD8 ~            	EI
2298  5AD8 ~            	RET
2299  5AD8 ~            ; *******************************************************************************************************
2300  5AD8               ENDIF
2301  5AD8               ENDIF
2302  5AD8
2303  5AD8               IF (BOX_CMDS == 1)
2304  5AD8              ; *******************************************************************************************************
2305  5AD8              ; generic function to implement rectangle data copy
2306  5AD8              ; should be modified to call appropriate function for memory or vram
2307  5AD8              ; input IX=pointer to following structure
2308  5AD8              ; +00 source data pointer
2309  5AD8              ; +02 num bytes in a row
2310  5AD8              ; +04 number of rows
2311  5AD8              ; +06 source add-to value till next row
2312  5AD8              ; +08 destination address
2313  5AD8              ; +10 destination add-to value till next row
2314  5AD8              ; modifies AF, BC, DE, HL
2315  5AD8              RECTANGLE_COPY:
2316  5AD8 DD 6E 00     	LD L, (IX+0)
2317  5ADB DD 66 01     	LD H, (IX+1) ; source address
2318  5ADE DD 5E 08     	LD E, (IX+8)
2319  5AE1 DD 56 09     	LD D, (IX+9) ; destination
2320  5AE4 DD 46 04     	LD B, (IX+4) ; row number
2321  5AE7              .L1:
2322  5AE7 C5           	PUSH BC
2323  5AE8 E5           		PUSH HL
2324  5AE9 D5           			PUSH DE
2325  5AEA DD 4E 02     				LD C, (IX+2)
2326  5AED DD 46 03     				LD B, (IX+3) ; num bytes in a row
2327  5AF0              .CALL1:
2328  5AF0 CD 00 00     				CALL 0 ; set destination address from DE
2329  5AF3              .CALL2:
2330  5AF3 CD 00 00     				CALL 0 ; copy data fn
2331  5AF6 E1           			POP HL
2332  5AF7 DD 4E 0A     			LD C, (IX+10)
2333  5AFA DD 46 0B     			LD B, (IX+11) ; destination add-to
2334  5AFD 09           			ADD HL, BC
2335  5AFE EB           			EX DE, HL
2336  5AFF E1           		POP HL
2337  5B00 DD 4E 06     		LD C, (IX+6)
2338  5B03 DD 46 07     		LD B, (IX+7) ; src add-to
2339  5B06 09           		ADD HL, BC
2340  5B07 C1           	POP BC
2341  5B08 10 DD        	DJNZ .L1
2342  5B0A C9           	RET
2343  5B0B              ; *******************************************************************************************************
2344  5B0B
2345  5B0B              ; *******************************************************************************************************
2346  5B0B              ; function to handle CALL BOXMEMCPY basic extension
2347  5B0B              ; copies data with window like boundaries to ram
2348  5B0B              ; BOXMEMCPY ( INT request_data_ptr )
2349  5B0B              ; request_data_ptr described in RECTANGLE_COPY
2350  5B0B              ; will put ram in page 0 also, page 1 is already there
2351  5B0B              BOXMEMCPY:
2352  5B0B              	; opening (
2353  5B0B CD E6 52     	CALL CHKCHAR
2354  5B0E 28           	DB '('
2355  5B0F              	; get pointer to request struct
2356  5B0F DD 21 2F 54  	LD IX, FRMQNT
2357  5B13 CD 59 01     	CALL CALBAS
2358  5B16 D5           	PUSH DE
2359  5B17              	; ending )
2360  5B17 CD E6 52     	CALL CHKCHAR
2361  5B1A 29           	DB ')'
2362  5B1B
2363  5B1B DD E1        	POP IX ; pointer to request struct
2364  5B1D
2365  5B1D E5           	PUSH HL ; save position in BASIC buffer
2366  5B1E
2367  5B1E FD 21 25 5B  	LD IY, .RET
2368  5B22 C3 99 52     	JP ENABLE_PAGE0
2369  5B25              .RET:
2370  5B25 FB           	EI
2371  5B26              	; set RAM functions to call
2372  5B26 21 00 00     	LD HL, 0
2373  5B29 22 F0 5A     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2374  5B2C 22 F2 5A     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2375  5B2F 21 ED B0     	LD HL, #B0ED ; LDIR
2376  5B32 22 F4 5A     	LD (RECTANGLE_COPY.CALL1+4), HL
2377  5B35 CD D8 5A     	CALL RECTANGLE_COPY
2378  5B38
2379  5B38 D1               POP DE
2380  5B39 C1               POP BC
2381  5B3A CD 10 52         CALL RESTORE_PAGE_INFO
2382  5B3D
2383  5B3D E1           	POP HL
2384  5B3E C9           	RET
2385  5B3F              ; *******************************************************************************************************
2386  5B3F
2387  5B3F              ; *******************************************************************************************************
2388  5B3F              ; function to handle CALL BOXMEMVRM basic extension
2389  5B3F              ; copies data with window like boundaries to ram
2390  5B3F              ; BOXMEMVRM ( INT request_data_ptr )
2391  5B3F              ; request_data_ptr described in RECTANGLE_COPY
2392  5B3F              ; will put ram in page 0 also, page 1 is already there
2393  5B3F              BOXMEMVRM:
2394  5B3F              	; opening (
2395  5B3F CD E6 52     	CALL CHKCHAR
2396  5B42 28           	DB '('
2397  5B43              	; get pointer to request struct
2398  5B43 DD 21 2F 54  	LD IX, FRMQNT
2399  5B47 CD 59 01     	CALL CALBAS
2400  5B4A D5           	PUSH DE
2401  5B4B              	; ending )
2402  5B4B CD E6 52     	CALL CHKCHAR
2403  5B4E 29           	DB ')'
2404  5B4F
2405  5B4F DD E1        	POP IX ; pointer to request struct
2406  5B51
2407  5B51 E5           	PUSH HL ; save position in BASIC buffer
2408  5B52
2409  5B52 FD 21 59 5B  	LD IY, .RET
2410  5B56 C3 99 52     	JP ENABLE_PAGE0
2411  5B59              .RET:
2412  5B59 FB           	EI
2413  5B5A              	; set RAM functions to call
2414  5B5A 21 78 5B     	LD HL, .SETDEST
2415  5B5D 22 F1 5A     	LD (RECTANGLE_COPY.CALL1+1), HL
2416  5B60 21 80 5B     	LD HL, .COPYDATA
2417  5B63 22 F4 5A     	LD (RECTANGLE_COPY.CALL2+1), HL
2418  5B66 3E CD        	LD A, #CD ; CALL
2419  5B68 32 F0 5A     	LD (RECTANGLE_COPY.CALL1), A
2420  5B6B 32 F3 5A     	LD (RECTANGLE_COPY.CALL2), A
2421  5B6E CD D8 5A     	CALL RECTANGLE_COPY
2422  5B71
2423  5B71 D1               POP DE
2424  5B72 C1               POP BC
2425  5B73 CD 10 52         CALL RESTORE_PAGE_INFO
2426  5B76
2427  5B76 E1           	POP HL
2428  5B77 C9           	RET
2429  5B78              .SETDEST:
2430  5B78 EB           	EX DE, HL
2431  5B79 F3           	DI
2432  5B7A CD C4 51     	CALL SETWRT_LOCAL
2433  5B7D FB           	EI
2434  5B7E EB           	EX DE, HL
2435  5B7F C9           	RET
2436  5B80              .COPYDATA:
2437  5B80 41           	LD B, C
2438  5B81 0E 98        	LD C, #98
2439  5B83 C3 CF 51     	JP BBYTECOPY
2440  5B86              ; *******************************************************************************************************
2441  5B86               ENDIF
2442  5B86
2443  5B86              EXT_END:
2444  5B86
# file closed: asm\main.asm
