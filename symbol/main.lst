# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; DEFINE EXCLUDE_SOUND_PLAYER
   4  4000              ; DEFINE EXCLUDE_RAM_CMDS
   5  4000              ; DEFINE EXCLUDE_VRAM_CMDS
   6  4000              ; DEFINE EXCLUDE_BLIT_CMDS
   7  4000              ; DEFINE EXCLUDE_SPRITE_CMDS
   8  4000              ; DEFINE EXCLUDE_GENCAL
   9  4000
  10  4000              CHPUT   EQU     #A2
  11  4000              CALBAS	EQU		#159
  12  4000              ERRHAND EQU     #406F
  13  4000              FRMEVL  EQU     #4C64
  14  4000              FRESTR	EQU		#67D0
  15  4000              ; FRMQNT = formula quantificator
  16  4000              ; input HL=pointer to current program expression
  17  4000              ; output HL=next address
  18  4000              ; output DE=integer datum
  19  4000              FRMQNT	EQU		#542F
  20  4000              ; GETBYT = get byte parameter
  21  4000              ; input HL=pointer to current program expression
  22  4000              ; output HL=next address
  23  4000              ; output A=E=byte read
  24  4000              GETBYT	EQU		#521C
  25  4000              CHRGTR  EQU     #4666
  26  4000              SYNCHR	EQU		#558C
  27  4000              VALTYP  EQU     #F663
  28  4000              USR     EQU     #F7F8
  29  4000              PROCNM	EQU		#FD89
  30  4000              BIOS_FILVRM  EQU     #56
  31  4000              CLIKSW	EQU		#F3DB
  32  4000              ATRBAS	EQU		#F928
  33  4000
  34  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  35  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  36  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  37  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  38  4000              EXPTBL	EQU #FCC1
  39  4000              SCRMOD	EQU #FCAF ; current screen mode
  40  4000
  41  4000              ; BASIC error codes
  42  4000              ;01 NEXT without FOR
  43  4000              ;02 Syntax error
  44  4000              ;03 RETURN without GOSUB
  45  4000              ;04 Out of DATA
  46  4000              ;05 Illegal function call
  47  4000              ;06 Overflow
  48  4000              ;07 Out of memory
  49  4000              ;08 Undefined line number
  50  4000              ;09 Subscript out of range
  51  4000              ;10 Redimensioned array
  52  4000              ;11 Division by zero
  53  4000              ;12 Illegal direct
  54  4000              ;13 Type mismatch
  55  4000              ;14 Out of string space
  56  4000              ;15 String too long
  57  4000              ;16 String formula too complex
  58  4000              ;17 Can't CONTINUE
  59  4000              ;18 Undefined user function
  60  4000              ;19 Device I/O error
  61  4000              ;20 Verify error
  62  4000              ;21 No RESUME
  63  4000              ;22 RESUME without error
  64  4000              ;23 Unprintable error
  65  4000              ;24 Missing operand
  66  4000              ;25 Line buffer overflow
  67  4000              ;50 FIELD overflow
  68  4000              ;51 Internal error
  69  4000              ;52 Bad file number
  70  4000              ;53 File not found
  71  4000              ;54 File already open
  72  4000              ;55 Input past end
  73  4000              ;56 Bad file name
  74  4000              ;57 Direct statement in file
  75  4000              ;58 Sequential I/O only
  76  4000              ;59 File not OPEN
  77  4000
  78  4000
  79  4000               ; simulate cartridge with BASIC extension
  80  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  80  4004 8F 4F 00 00
  80  4008 00 00 00 00
  80  400C 00 00 00 00
  81  4010
  82  4010              ; this location #4010 stores last location used by basic extension
  83  4010              ; free memory after that point
  84  4010 F2 57         DW EXT_END
  85  4012
  86  4012              ; this location #4012 stores extension version in DAA format
  87  4012              ; first byte is major version and second minor
  88  4012 00 70         DB #00, #70
  89  4014
  90  4014              ; binary included AKG player compiled at #4014
  91  4014               IFNDEF EXCLUDE_SOUND_PLAYER
  92  4014              	INCBIN "bin/AKG.bin"
  93  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
  94  4CF0               ENDIF
  95  4CF0
  96  4CF0              ORIG.HTIMI:
  97  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  97  4CF4 00
  98  4CF5               EXPORT ORIG.HTIMI
  99  4CF5
 100  4CF5               IFNDEF EXCLUDE_SOUND_PLAYER
 101  4CF5              MUSIC_INIT_STATUS:
 102  4CF5 00            DB 0
 103  4CF6              SFX_INIT_STATUS:
 104  4CF6 00            DB 0
 105  4CF7              SOUND_ENABLED:
 106  4CF7 00            DB 0
 107  4CF8               ENDIF
 108  4CF8
 109  4CF8               IFNDEF EXCLUDE_SPRITE_CMDS
 110  4CF8              SPRATR_INIT_STATUS:
 111  4CF8 00            DB 0
 112  4CF9              SPRATR_UPDATE_FLAG:
 113  4CF9 00 00         DW 0
 114  4CFB              SPRATR_DATA:
 115  4CFB 00 00         DW 0
 116  4CFD              SPRFLICKER_ENABLED:
 117  4CFD 00            DB 0
 118  4CFE              ; to support sprite flicker
 119  4CFE              FLICKER:
 120  4CFE 00            DB 0
 121  4CFF               ENDIF
 122  4CFF
 123  4CFF              ; to temporarily store stack pointer
 124  4CFF              TMPSP:
 125  4CFF 00 00         DW 0
 126  4D01
 127  4D01              ; temp variables for BLIT, TILE functions
 128  4D01               IFNDEF EXCLUDE_BLIT_CMDS
 129  4D01              TILETMP1:
 130  4D01              BLIT_TMP1:
 131  4D01 00 00         DW 0
 132  4D03              TILETMP2:
 133  4D03              BLIT_TMP2:
 134  4D03 00 00         DW 0
 135  4D05               ENDIF
 136  4D05
 137  4D05              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 138  4D05              ; per starting letter, if no commands with this letter, NULL value
 139  4D05              CMDS:
 140  4D05 00 00            DW 0 ; A
 141  4D07 CE 4D            DW CMDS_B ; B
 142  4D09 00 00            DW 0 ; C
 143  4D0B 00 00            DW 0 ; D
 144  4D0D 00 00            DW 0 ; E
 145  4D0F 4C 4D            DW CMDS_F; F
 146  4D11 5F 4D            DW CMDS_G; G
 147  4D13 00 00            DW 0 ; H
 148  4D15 00 00            DW 0 ; I
 149  4D17 00 00            DW 0 ; J
 150  4D19 00 00            DW 0 ; K
 151  4D1B 00 00            DW 0 ; L
 152  4D1D 39 4D            DW CMDS_M ; M
 153  4D1F 00 00            DW 0 ; N
 154  4D21 00 00            DW 0 ; O
 155  4D23 00 00            DW 0 ; P
 156  4D25 00 00            DW 0 ; Q
 157  4D27 00 00            DW 0 ; R
 158  4D29 73 4D            DW CMDS_S ; S
 159  4D2B EE 4D            DW CMDS_T ; T
 160  4D2D 00 00            DW 0 ; U
 161  4D2F 69 4D            DW CMDS_V ; V
 162  4D31 00 00            DW 0 ; W
 163  4D33 00 00            DW 0 ; X
 164  4D35 00 00            DW 0 ; Y
 165  4D37 00 00            DW 0 ; Z
 166  4D39
 167  4D39              CMDS_M:
 168  4D39               IFNDEF EXCLUDE_VRAM_CMDS
 169  4D39 4D 45 4D 56      DB "MEMVRM", 0
 169  4D3D 52 4D 00
 170  4D40 2C 51            DW MEMVRM
 171  4D42               ENDIF
 172  4D42               IFNDEF EXCLUDE_RAM_CMDS
 173  4D42 4D 45 4D 43  	DB "MEMCPY", 0
 173  4D46 50 59 00
 174  4D49 EB 4F        	DW MEMCPY
 175  4D4B               ENDIF
 176  4D4B 00           	DB 0
 177  4D4C              CMDS_F:
 178  4D4C               IFNDEF EXCLUDE_VRAM_CMDS
 179  4D4C 46 49 4C 56      DB "FILVRM", 0
 179  4D50 52 4D 00
 180  4D53 2E 50            DW FILVRM
 181  4D55               ENDIF
 182  4D55               IFNDEF EXCLUDE_RAM_CMDS
 183  4D55 46 49 4C 52      DB "FILRAM", 0
 183  4D59 41 4D 00
 184  4D5C 75 50            DW FILRAM
 185  4D5E               ENDIF
 186  4D5E 00               DB 0
 187  4D5F              CMDS_G:
 188  4D5F               IFNDEF EXCLUDE_GENCAL
 189  4D5F 47 45 4E 43      DB "GENCAL", 0
 189  4D63 41 4C 00
 190  4D66 D3 50            DW GENCAL
 191  4D68               ENDIF
 192  4D68 00           	DB	0
 193  4D69              CMDS_V:
 194  4D69               IFNDEF EXCLUDE_VRAM_CMDS
 195  4D69 56 52 4D 4D  	DB "VRMMEM", 0
 195  4D6D 45 4D 00
 196  4D70 A7 51        	DW VRMMEM
 197  4D72               ENDIF
 198  4D72 00           	DB 0
 199  4D73              CMDS_S:
 200  4D73               IFNDEF EXCLUDE_SPRITE_CMDS
 201  4D73 53 50 52 53  	DB "SPRSET", 0
 201  4D77 45 54 00
 202  4D7A 94 53        	DW SPRSET
 203  4D7C 53 50 52 47  	DB "SPRGRPMOV", 0
 203  4D80 52 50 4D 4F
 203  4D84 56 00
 204  4D86 52 54        	DW SPRGRPMOV
 205  4D88               ENDIF
 206  4D88               IFNDEF EXCLUDE_SOUND_PLAYER
 207  4D88 53 4E 44 53  	DB "SNDSFX", 0
 207  4D8C 46 58 00
 208  4D8F E5 52        	DW SNDSFX
 209  4D91 53 4E 44 50  	DB "SNDPLYON", 0
 209  4D95 4C 59 4F 4E
 209  4D99 00
 210  4D9A AF 52        	DW SNDPLYON
 211  4D9C 53 4E 44 50  	DB "SNDPLYOFF", 0
 211  4DA0 4C 59 4F 46
 211  4DA4 46 00
 212  4DA6 C2 52        	DW SNDPLYOFF
 213  4DA8 53 4E 44 50  	DB "SNDPLYINI", 0
 213  4DAC 4C 59 49 4E
 213  4DB0 49 00
 214  4DB2 65 52        	DW SNDPLYINIT
 215  4DB4               ENDIF
 216  4DB4               IFNDEF EXCLUDE_SPRITE_CMDS
 217  4DB4 53 50 52 45  	DB "SPRENABLE", 0
 217  4DB8 4E 41 42 4C
 217  4DBC 45 00
 218  4DBE 3F 53        	DW SPRENABLE
 219  4DC0 53 50 52 44  	DB "SPRDISABLE", 0
 219  4DC4 49 53 41 42
 219  4DC8 4C 45 00
 220  4DCB 8F 53        	DW SPRDISABLE
 221  4DCD               ENDIF
 222  4DCD 00           	DB 0
 223  4DCE              CMDS_B:
 224  4DCE               IFNDEF EXCLUDE_BLIT_CMDS
 225  4DCE 42 4C 49 54  	DB "BLIT", 0
 225  4DD2 00
 226  4DD3 50 56        	DW BLIT
 227  4DD5 42 4F 58 4D  	DB "BOXMEMCPY", 0
 227  4DD9 45 4D 43 50
 227  4DDD 59 00
 228  4DDF 77 57        	DW BOXMEMCPY
 229  4DE1 42 4F 58 4D  	DB "BOXMEMVRM", 0
 229  4DE5 45 4D 56 52
 229  4DE9 4D 00
 230  4DEB AB 57        	DW BOXMEMVRM
 231  4DED               ENDIF
 232  4DED 00           	DB 0
 233  4DEE              CMDS_T:
 234  4DEE               IFNDEF EXCLUDE_BLIT_CMDS
 235  4DEE 54 49 4C 45  	DB "TILERAM", 0
 235  4DF2 52 41 4D 00
 236  4DF6 BD 56        	DW TILERAM
 237  4DF8 54 49 4C 45  	DB "TILEVRM", 0
 237  4DFC 56 52 4D 00
 238  4E00 04 57        	DW TILEVRM
 239  4E02               ENDIF
 240  4E02 00           	DB 0
 241  4E03
 242  4E03              ; ****************************************************************************************************
 243  4E03              ; function sets VRAM address
 244  4E03              ; input HL=address
 245  4E03              ; modifies AF
 246  4E03              SETWRT_LOCAL:
 247  4E03 7D           	LD	A, L
 248  4E04 D3 99        	OUT	(099H), A
 249  4E06 7C           	LD	A, H
 250  4E07 E6 3F        	AND	03FH
 251  4E09 F6 40        	OR	040H
 252  4E0B D3 99        	OUT	(099H), A
 253  4E0D C9           	RET
 254  4E0E              ; ****************************************************************************************************
 255  4E0E
 256  4E0E              ; ****************************************************************************************************
 257  4E0E              ; function gets slot and subslot data for specific page
 258  4E0E              ; input A=page (0, 1 or 2)
 259  4E0E              ; output B = 0A8H register value
 260  4E0E              ; output D = 0 is no subslots, 1 if yes
 261  4E0E              ; output C = 0A8H value when page 3 slot equals to requested page slot
 262  4E0E              ; output E = subslot value if present
 263  4E0E              ; modifies AF, BC, DE, HL
 264  4E0E              GET_PAGE_INFO:
 265  4E0E 6F               LD L, A
 266  4E0F C6 C1            ADD A, low (EXPTBL)
 267  4E11 32 1B 4E         LD (GET_PAGE_INFO_L1+1), A
 268  4E14 DB A8            IN A, (0A8H)
 269  4E16 47               LD B, A
 270  4E17 E6 3F            AND 03FH
 271  4E19 4F               LD C, A
 272  4E1A              GET_PAGE_INFO_L1:
 273  4E1A 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 274  4E1D E6 80            AND 080H
 275  4E1F 28 1B            JR Z, GET_PAGE_INFO_L2
 276  4E21                  ; expanded
 277  4E21 2D               DEC L
 278  4E22 FA 41 4E         JP M, GET_PAGE_INFO_L3
 279  4E25 2D               DEC L
 280  4E26 FA 3F 4E         JP M, GET_PAGE_INFO_L4
 281  4E29                  ; page 2
 282  4E29 07               RLCA
 283  4E2A 07               RLCA
 284  4E2B              GET_PAGE_INFO_L5:
 285  4E2B E6 C0            AND 0C0H
 286  4E2D B1               OR C
 287  4E2E D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 288  4E30 4F               LD C, A
 289  4E31 3A FF FF         LD A, (0FFFFH)
 290  4E34 2F               CPL
 291  4E35 5F               LD E, A
 292  4E36 16 01            LD D, 1
 293  4E38 78               LD A, B ; return stack
 294  4E39 D3 A8            OUT (0A8H), A
 295  4E3B C9               RET
 296  4E3C              GET_PAGE_INFO_L2:
 297  4E3C                  ; not expanded
 298  4E3C 16 00            LD D, 0
 299  4E3E C9               RET
 300  4E3F              GET_PAGE_INFO_L4:
 301  4E3F                  ; page 1
 302  4E3F 0F               RRCA
 303  4E40 0F               RRCA
 304  4E41              GET_PAGE_INFO_L3:
 305  4E41                  ; page 0
 306  4E41 0F               RRCA
 307  4E42 0F               RRCA
 308  4E43 18 E6            JR GET_PAGE_INFO_L5
 309  4E45              ; ****************************************************************************************************
 310  4E45
 311  4E45              ; ****************************************************************************************************
 312  4E45              ; function returns original slot and subslot info
 313  4E45              ; input B = 0A8H register value
 314  4E45              ; input D = 0 is no subslots, 1 if yes
 315  4E45              ; input C = 0A8H value when page 3 slot equals to requested page slot
 316  4E45              ; input E = subslot value if present
 317  4E45              ; modifies AF, disables interrupts
 318  4E45              RESTORE_PAGE_INFO:
 319  4E45 7A               LD A, D
 320  4E46 B7               OR A
 321  4E47 28 08            JR Z, RESTORE_PAGE_INFO_L1
 322  4E49 79               LD A, C
 323  4E4A F3           	DI
 324  4E4B D3 A8            OUT (0A8H), A
 325  4E4D 7B               LD A, E
 326  4E4E 32 FF FF         LD (0FFFFH), A
 327  4E51              RESTORE_PAGE_INFO_L1:
 328  4E51 78               LD A, B
 329  4E52 D3 A8            OUT (0A8H), A
 330  4E54 C9               RET
 331  4E55              ; ****************************************************************************************************
 332  4E55
 333  4E55              ; *******************************************************************************************************
 334  4E55              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 335  4E55              ; INPUT:  A = SLOT ID: EXXXSSPP
 336  4E55              ; E = EXPANDED FLAG
 337  4E55              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 338  4E55              ; PP = PRIMARY SLOT NUMBER
 339  4E55              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 340  4E55              ; CHANGES: AF, BC, DE
 341  4E55
 342  4E55              LOCAL_ENASLT:
 343  4E55 CD 75 4E         CALL L0353
 344  4E58 FA 62 4E         JP M, L0340
 345  4E5B DB A8            IN A, (0A8H)
 346  4E5D A1               AND C
 347  4E5E B0               OR B
 348  4E5F D3 A8            OUT (0A8H), A
 349  4E61 C9               RET
 350  4E62              L0340:
 351  4E62 E5               PUSH HL
 352  4E63 CD 9A 4E         CALL L0378
 353  4E66 4F               LD C, A
 354  4E67 06 00            LD B, 0
 355  4E69 7D               LD A, L
 356  4E6A A4               AND H
 357  4E6B B2               OR D
 358  4E6C 21 C5 FC         LD HL, 0FCC5H
 359  4E6F 09               ADD HL, BC
 360  4E70 77               LD (HL), A
 361  4E71 E1               POP HL
 362  4E72 79               LD A, C
 363  4E73 18 E0            JR LOCAL_ENASLT
 364  4E75              L0353:
 365  4E75 F3               DI
 366  4E76 F5               PUSH AF
 367  4E77 7C               LD A, H
 368  4E78 07               RLCA
 369  4E79 07               RLCA
 370  4E7A E6 03            AND 3
 371  4E7C 5F               LD E, A
 372  4E7D 3E C0            LD A, 0C0H
 373  4E7F              L035D:
 374  4E7F 07               RLCA
 375  4E80 07               RLCA
 376  4E81 1D               DEC E
 377  4E82 F2 7F 4E         JP P, L035D
 378  4E85 5F               LD E, A
 379  4E86 2F               CPL
 380  4E87 4F               LD C, A
 381  4E88 F1               POP AF
 382  4E89 F5               PUSH AF
 383  4E8A E6 03            AND 3
 384  4E8C 3C               INC A
 385  4E8D 47               LD B, A
 386  4E8E 3E AB            LD A, 0ABH
 387  4E90              L036E:
 388  4E90 C6 55            ADD A, 055H
 389  4E92 10 FC            DJNZ L036E
 390  4E94 57               LD D, A
 391  4E95 A3               AND E
 392  4E96 47               LD B, A
 393  4E97 F1               POP AF
 394  4E98 A7               AND A
 395  4E99 C9               RET
 396  4E9A              L0378:
 397  4E9A F5               PUSH AF
 398  4E9B 7A               LD A, D
 399  4E9C E6 C0            AND 0C0H
 400  4E9E 4F               LD C, A
 401  4E9F F1               POP AF
 402  4EA0 F5               PUSH AF
 403  4EA1 57               LD D, A
 404  4EA2 DB A8            IN A, (0A8H)
 405  4EA4 47               LD B, A
 406  4EA5 E6 3F            AND 03FH
 407  4EA7 B1               OR C
 408  4EA8 D3 A8            OUT (0A8H), A
 409  4EAA 7A               LD A, D
 410  4EAB 0F               RRCA
 411  4EAC 0F               RRCA
 412  4EAD E6 03            AND 3
 413  4EAF 57               LD D, A
 414  4EB0 3E AB            LD A, 0ABH
 415  4EB2              L0390:
 416  4EB2 C6 55            ADD A, 055H
 417  4EB4 15               DEC D
 418  4EB5 F2 B2 4E         JP P, L0390
 419  4EB8 A3               AND E
 420  4EB9 57               LD D, A
 421  4EBA 7B               LD A, E
 422  4EBB 2F               CPL
 423  4EBC 67               LD H, A
 424  4EBD 3A FF FF         LD A, (0FFFFH)
 425  4EC0 2F               CPL
 426  4EC1 6F               LD L, A
 427  4EC2 A4               AND H
 428  4EC3 B2               OR D
 429  4EC4 32 FF FF         LD (0FFFFH), A
 430  4EC7 78               LD A, B
 431  4EC8 D3 A8            OUT (0A8H), A
 432  4ECA F1               POP AF
 433  4ECB E6 03            AND 3
 434  4ECD C9               RET
 435  4ECE              ; *******************************************************************************************************
 436  4ECE
 437  4ECE              ; *******************************************************************************************************
 438  4ECE              ; some common code to activate page 0 and place values needed to restore original page on stack
 439  4ECE              ; input IY=return address
 440  4ECE              ENABLE_PAGE0:
 441  4ECE AF               XOR A
 442  4ECF CD 0E 4E         CALL GET_PAGE_INFO
 443  4ED2 C5               PUSH BC
 444  4ED3 D5               PUSH DE
 445  4ED4 3A 41 F3         LD A, (RAMAD0)
 446  4ED7 26 00            LD H, 0
 447  4ED9 CD 55 4E         CALL LOCAL_ENASLT
 448  4EDC FD E9        	JP (IY)
 449  4EDE              ; *******************************************************************************************************
 450  4EDE
 451  4EDE               IFNDEF EXCLUDE_SPRITE_CMDS
 452  4EDE              ; *******************************************************************************************************
 453  4EDE              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 454  4EDE              ; struct {
 455  4EDE              ; DW y
 456  4EDE              ; DW x
 457  4EDE              ; DW pattern (0-63)
 458  4EDE              ; DW color
 459  4EDE              ; } [32]
 460  4EDE              ; will hide sprites whose location is outside of visible area
 461  4EDE              ; works in screen 1 and 2
 462  4EDE              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 463  4EDE              ; modifies AF, AF', BC, DE, HL
 464  4EDE              SPRATR_UPDATE:
 465  4EDE              	; check if initialized
 466  4EDE 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 467  4EE1 B7           	OR A
 468  4EE2 C8           	RET Z
 469  4EE3              	; check if update requested
 470  4EE3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 471  4EE6 7E           	LD A, (HL)
 472  4EE7 B7           	OR A
 473  4EE8 C8           	RET Z
 474  4EE9              	; check screen mode
 475  4EE9 3A AF FC     	LD A, (SCRMOD)
 476  4EEC 3D           	DEC A
 477  4EED 28 02        	JR Z, .L0 ; screen 1
 478  4EEF 3D           	DEC A
 479  4EF0 C0           	RET NZ ; not screen 2
 480  4EF1              .L0:
 481  4EF1 06 20        	LD B, 32 ; sprite number
 482  4EF3 0E 98        	LD C, #98 ; register for vdp data output
 483  4EF5              	; set VDP address
 484  4EF5 2A 28 F9     	LD HL, (ATRBAS)
 485  4EF8 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
 486  4EFB B7           	OR A
 487  4EFC 28 03        	JR Z, .L3
 488  4EFE 3A FE 4C     	LD A, (FLICKER)
 489  4F01              .L3:
 490  4F01 5F           	LD E, A
 491  4F02 08           	EX AF, AF'
 492  4F03 7B           	LD A, E
 493  4F04 87           	ADD A, A
 494  4F05 87           	ADD A, A
 495  4F06 16 00        	LD D, 0
 496  4F08 5F           	LD E, A
 497  4F09 19           	ADD HL, DE
 498  4F0A CD 03 4E     	CALL SETWRT_LOCAL
 499  4F0D ED 73 FF 4C  	LD (TMPSP), SP
 500  4F11 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
 501  4F15
 502  4F15              .LOOP:
 503  4F15 E1           	POP HL
 504  4F16 24           	INC H
 505  4F17 28 0D        	JR Z, .L1 ; negative number above -256
 506  4F19 25           	DEC H
 507  4F1A 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 508  4F1C 7D           	LD A, L
 509  4F1D FE C0        	CP 192
 510  4F1F 30 10        	JR NC, .OUT3
 511  4F21 3D           	DEC A ; due to VDP rule that top of screen is -1
 512  4F22 57           	LD D, A
 513  4F23 C3 41 4F     	JP .X
 514  4F26              .L1:
 515  4F26 7D           	LD A, L
 516  4F27 C6 10        	ADD 16
 517  4F29 FA 31 4F     	JP M, .OUT3 ; below -16
 518  4F2C 2D           	DEC L ; due to VDP rule that top of screen is -1
 519  4F2D 55           	LD D, L
 520  4F2E C3 41 4F     	JP .X
 521  4F31              .OUT3:
 522  4F31 E1           	POP HL ; skip x value
 523  4F32              .OUT2:
 524  4F32 E1           	POP HL ; skip pattern
 525  4F33 E1           	POP HL ; skip color
 526  4F34 3E D1        	LD A, #D1
 527  4F36 D3 98        	OUT (#98), A ; sprite hidden
 528  4F38 D3 98        	OUT (#98), A ; value unimportant
 529  4F3A D3 98        	OUT (#98), A ; value unimportant
 530  4F3C D3 98        	OUT (#98), A ; value unimportant
 531  4F3E C3 65 4F     	JP .NEXT
 532  4F41              .X:
 533  4F41 E1           	POP HL
 534  4F42 24           	INC H
 535  4F43 28 08        	JR Z, .L2
 536  4F45 25           	DEC H
 537  4F46 20 EA        	JR NZ, .OUT2
 538  4F48 1E 00        	LD E, 0 ; EC bit
 539  4F4A C3 56 4F     	JP .XY
 540  4F4D              .L2:
 541  4F4D 7D           	LD A, L
 542  4F4E C6 20        	ADD 32
 543  4F50 FA 32 4F     	JP M, .OUT2
 544  4F53 6F           	LD L, A
 545  4F54 1E 80        	LD E, #80
 546  4F56              .XY:
 547  4F56 ED 51        	OUT (C), D
 548  4F58 ED 69        	OUT (C), L
 549  4F5A E1           	POP HL ; pattern
 550  4F5B 7D           	LD A, L
 551  4F5C 87           	ADD A, A
 552  4F5D 87           	ADD A, A ; needs to go at 4x
 553  4F5E D3 98        	OUT (#98), A
 554  4F60 E1           	POP HL ; color
 555  4F61 7D           	LD A, L
 556  4F62 B3           	OR E
 557  4F63 D3 98        	OUT (#98), A
 558  4F65              .NEXT:
 559  4F65 08           	EX AF, AF'
 560  4F66 3C           	INC A
 561  4F67 E6 1F        	AND 31
 562  4F69 C2 7D 4F     	JP NZ, .NEXT2
 563  4F6C 08           	EX AF, AF'
 564  4F6D 2A 28 F9     	LD HL, (ATRBAS)
 565  4F70              	; CALL SETWRT_LOCAL not allowed as SP modified
 566  4F70 7D           	LD	A, L
 567  4F71 D3 99        	OUT	(099H), A
 568  4F73 7C           	LD	A, H
 569  4F74 E6 3F        	AND	03FH
 570  4F76 F6 40        	OR	040H
 571  4F78 D3 99        	OUT	(099H), A
 572  4F7A C3 7E 4F     	JP .NEXT3
 573  4F7D              .NEXT2:
 574  4F7D 08           	EX AF, AF'
 575  4F7E              .NEXT3:
 576  4F7E 10 95        	DJNZ .LOOP
 577  4F80 08           	EX AF, AF'
 578  4F81 3C           	INC A
 579  4F82 32 FE 4C     	LD (FLICKER), A
 580  4F85
 581  4F85 ED 7B FF 4C  	LD SP, (TMPSP)
 582  4F89 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 583  4F8C 36 00        	LD (HL), 0 ; zero out update flag
 584  4F8E C9           	RET
 585  4F8F              ; *******************************************************************************************************
 586  4F8F               ENDIF
 587  4F8F
 588  4F8F              ; General BASIC CALL-instruction handler
 589  4F8F              CALLHAND:
 590  4F8F E5           	PUSH HL
 591  4F90 21 05 4D     	LD	HL, CMDS ; pointer table based on starting letter
 592  4F93 3A 89 FD         LD A, (PROCNM)
 593  4F96 D6 41            SUB 'A'
 594  4F98 87               ADD A, A
 595  4F99 16 00            LD D, 0
 596  4F9B 5F               LD E, A
 597  4F9C 19               ADD HL, DE
 598  4F9D 5E               LD E, (HL)
 599  4F9E 23               INC HL
 600  4F9F 56               LD D, (HL)
 601  4FA0 7A               LD A, D
 602  4FA1 B3               OR E
 603  4FA2 28 24            JR Z, .CMDNOTRECOGNIZED
 604  4FA4 EB               EX DE, HL
 605  4FA5              .CHKCMD:
 606  4FA5 11 89 FD     	LD	DE, PROCNM
 607  4FA8 1A           .LOOP:	LD	A,(DE)
 608  4FA9 BE           	CP	(HL)
 609  4FAA 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 610  4FAC 13           	INC	DE
 611  4FAD 23           	INC	HL
 612  4FAE A7           	AND	A
 613  4FAF 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 614  4FB1 5E           	LD	E,(HL)
 615  4FB2 23           	INC	HL
 616  4FB3 56           	LD	D,(HL)
 617  4FB4 E1           	POP	HL		; routine address
 618  4FB5 CD D6 4F     	CALL	GETPREVCHAR
 619  4FB8 CD CA 4F     	CALL	.CALLDE		; Call routine
 620  4FBB A7           	AND	A
 621  4FBC C9           	RET
 622  4FBD
 623  4FBD              .TONEXTCMD:
 624  4FBD 0E FF        	LD	C,0FFH
 625  4FBF AF           	XOR	A
 626  4FC0 ED B1        	CPIR			; Skip to end of instruction name
 627  4FC2 23           	INC	HL
 628  4FC3 23           	INC	HL		; Skip address
 629  4FC4 BE           	CP	(HL)
 630  4FC5 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 631  4FC7 E1           	POP	HL
 632  4FC8              .CMDNOTRECOGNIZED:
 633  4FC8 37               SCF
 634  4FC9 C9           	RET
 635  4FCA
 636  4FCA              .CALLDE:
 637  4FCA D5           	PUSH	DE
 638  4FCB C9           	RET
 639  4FCC
 640  4FCC              ;---------------------------
 641  4FCC
 642  4FCC              ;GETSTRPNT:
 643  4FCC              ; OUT:
 644  4FCC              ; HL = String Address
 645  4FCC              ; B  = Lenght
 646  4FCC              ;        LD      HL,(USR)
 647  4FCC              ;        LD      B,(HL)
 648  4FCC              ;        INC     HL
 649  4FCC              ;        LD      E,(HL)
 650  4FCC              ;        INC     HL
 651  4FCC              ;        LD      D,(HL)
 652  4FCC              ;        EX      DE,HL
 653  4FCC              ;        RET
 654  4FCC
 655  4FCC              ;EVALTXTPARAM:
 656  4FCC              ;	CALL	CHKCHAR
 657  4FCC              ;	DEFB	"("             ; Check for (
 658  4FCC              ;	LD	IX,FRMEVL
 659  4FCC              ;	CALL	CALBAS		; Evaluate expression
 660  4FCC              ;       LD      A,(VALTYP)
 661  4FCC              ;        CP      3               ; Text type?
 662  4FCC              ;        JP      NZ,TYPE_MISMATCH
 663  4FCC              ;        PUSH	HL
 664  4FCC              ;        LD	IX,FRESTR         ; Free the temporary string
 665  4FCC              ;        CALL	CALBAS
 666  4FCC              ;        POP	HL
 667  4FCC              ;	CALL	CHKCHAR
 668  4FCC              ;	DEFB	")"             ; Check for )
 669  4FCC              ;        RET
 670  4FCC
 671  4FCC
 672  4FCC              CHKCHAR:
 673  4FCC CD D6 4F     	CALL	GETPREVCHAR	; Get previous basic char
 674  4FCF E3           	EX	(SP),HL
 675  4FD0 BE           	CP	(HL) 	        ; Check if good char
 676  4FD1 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 677  4FD3 23           	INC	HL
 678  4FD4 E3           	EX	(SP),HL
 679  4FD5 23           	INC	HL		; Get next basic char
 680  4FD6
 681  4FD6              GETPREVCHAR:
 682  4FD6 2B           	DEC	HL
 683  4FD7 DD 21 66 46  	LD	IX,CHRGTR
 684  4FDB C3 59 01     	JP      CALBAS
 685  4FDE
 686  4FDE
 687  4FDE              TYPE_MISMATCH:
 688  4FDE 1E 0D            LD E, 13 ; Type mismatch
 689  4FE0 18 02            JR THROW_ERROR
 690  4FE2
 691  4FE2              SYNTAX_ERROR:
 692  4FE2 1E 02            LD E, 2 ; Syntax error
 693  4FE4              THROW_ERROR:
 694  4FE4 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 695  4FE8 C3 59 01     	JP	CALBAS
 696  4FEB
 697  4FEB              ;---------------------------
 698  4FEB
 699  4FEB               IFNDEF EXCLUDE_RAM_CMDS
 700  4FEB              ; *******************************************************************************************************
 701  4FEB              ; function to handle CALL MEMCPY basic extension
 702  4FEB              ; _MEMCPY ( INT source,
 703  4FEB              ;			INT destination,
 704  4FEB              ;			INT count,
 705  4FEB              ; will put ram in page 0 also, page 1 is already there
 706  4FEB              MEMCPY:
 707  4FEB              	; opening (
 708  4FEB CD CC 4F     	CALL CHKCHAR
 709  4FEE 28           	DB '('
 710  4FEF              	; get source address
 711  4FEF DD 21 2F 54  	LD IX, FRMQNT
 712  4FF3 CD 59 01     	CALL CALBAS
 713  4FF6 D5           	PUSH DE
 714  4FF7              	; comma
 715  4FF7 CD CC 4F     	CALL CHKCHAR
 716  4FFA 2C           	DB ','
 717  4FFB              	; get destination address
 718  4FFB DD 21 2F 54  	LD IX, FRMQNT
 719  4FFF CD 59 01     	CALL CALBAS
 720  5002 D5           	PUSH DE
 721  5003              	; comma
 722  5003 CD CC 4F     	CALL CHKCHAR
 723  5006 2C           	DB ','
 724  5007              	; get length
 725  5007 DD 21 2F 54  	LD IX, FRMQNT
 726  500B CD 59 01     	CALL CALBAS
 727  500E D5           	PUSH DE
 728  500F              	; ending )
 729  500F CD CC 4F     	CALL CHKCHAR
 730  5012 29           	DB ')'
 731  5013
 732  5013              	; save position
 733  5013 E5           	PUSH HL
 734  5014 DD E1        	POP IX
 735  5016
 736  5016 C1           	POP BC ; count
 737  5017 D1           	POP DE ; destination
 738  5018 E1           	POP HL ; source
 739  5019 D9           	EXX
 740  501A              	; enable page 0
 741  501A FD 21 21 50  	LD IY, .RET
 742  501E C3 CE 4E     	JP ENABLE_PAGE0
 743  5021              .RET:
 744  5021 FB           	EI
 745  5022 D9           	EXX
 746  5023 ED B0        	LDIR
 747  5025 D1               POP DE
 748  5026 C1               POP BC
 749  5027 CD 45 4E         CALL RESTORE_PAGE_INFO
 750  502A DD E5        	PUSH IX
 751  502C E1           	POP HL
 752  502D C9           	RET
 753  502E              ; *******************************************************************************************************
 754  502E               ENDIF
 755  502E               IFNDEF EXCLUDE_VRAM_CMDS
 756  502E              ; *******************************************************************************************************
 757  502E              ; function to handle CALL FILVRM basic extension
 758  502E              ; FILVRM ( INT offset,
 759  502E              ;		   INT count,
 760  502E              ;		   BYTE value,
 761  502E              ;		   BYTE wait_vsync) >0 = true
 762  502E              ; wait_vsync will issue HALT before copying
 763  502E              FILVRM:
 764  502E              	; opening (
 765  502E CD CC 4F     	CALL CHKCHAR
 766  5031 28           	DB '('
 767  5032              	; get offset address
 768  5032 DD 21 2F 54  	LD IX, FRMQNT
 769  5036 CD 59 01     	CALL CALBAS
 770  5039 D5           	PUSH DE
 771  503A              	; comma
 772  503A CD CC 4F     	CALL CHKCHAR
 773  503D 2C           	DB ','
 774  503E              	; get count
 775  503E DD 21 2F 54  	LD IX, FRMQNT
 776  5042 CD 59 01     	CALL CALBAS
 777  5045 D5           	PUSH DE
 778  5046              	; comma
 779  5046 CD CC 4F     	CALL CHKCHAR
 780  5049 2C           	DB ','
 781  504A              	; get value
 782  504A DD 21 1C 52  	LD IX, GETBYT
 783  504E CD 59 01     	CALL CALBAS
 784  5051 F5           	PUSH AF
 785  5052              	; comma
 786  5052 CD CC 4F     	CALL CHKCHAR
 787  5055 2C           	DB ','
 788  5056              	; get vsync wait
 789  5056 DD 21 1C 52  	LD IX, GETBYT
 790  505A CD 59 01     	CALL CALBAS
 791  505D F5           	PUSH AF
 792  505E              	; ending )
 793  505E CD CC 4F     	CALL CHKCHAR
 794  5061 29           	DB ')'
 795  5062
 796  5062 FB               EI
 797  5063              	; save position
 798  5063 E5           	PUSH HL
 799  5064 DD E1        	POP IX
 800  5066
 801  5066              	; syntax ok
 802  5066              	; wait for vsync if needed
 803  5066 F1           	POP AF
 804  5067 B7           	OR A
 805  5068 28 01        	JR Z, .L1
 806  506A 76           	HALT
 807  506B
 808  506B              .L1:
 809  506B F1               POP AF ; value
 810  506C C1               POP BC ; count
 811  506D E1               POP HL ; offset
 812  506E CD 56 00         CALL BIOS_FILVRM
 813  5071
 814  5071              .L3:
 815  5071 DD E5        	PUSH IX
 816  5073 E1           	POP HL
 817  5074 C9           	RET
 818  5075              ; *******************************************************************************************************
 819  5075               ENDIF
 820  5075
 821  5075               IFNDEF EXCLUDE_RAM_CMDS
 822  5075              ; *******************************************************************************************************
 823  5075              ; function to handle CALL FILRAM basic extension
 824  5075              ; FILRAM ( INT start address,
 825  5075              ;		   INT count,
 826  5075              ;		   BYTE value,
 827  5075              ; will put ram in page 0 also, page 1 is already there
 828  5075              FILRAM:
 829  5075              	; opening (
 830  5075 CD CC 4F     	CALL CHKCHAR
 831  5078 28           	DB '('
 832  5079              	; get start address
 833  5079 DD 21 2F 54  	LD IX, FRMQNT
 834  507D CD 59 01     	CALL CALBAS
 835  5080 D5           	PUSH DE
 836  5081              	; comma
 837  5081 CD CC 4F     	CALL CHKCHAR
 838  5084 2C           	DB ','
 839  5085              	; get count
 840  5085 DD 21 2F 54  	LD IX, FRMQNT
 841  5089 CD 59 01     	CALL CALBAS
 842  508C D5           	PUSH DE
 843  508D              	; comma
 844  508D CD CC 4F     	CALL CHKCHAR
 845  5090 2C           	DB ','
 846  5091              	; get value
 847  5091 DD 21 1C 52  	LD IX, GETBYT
 848  5095 CD 59 01     	CALL CALBAS
 849  5098 F5           	PUSH AF
 850  5099              	; ending )
 851  5099 CD CC 4F     	CALL CHKCHAR
 852  509C 29           	DB ')'
 853  509D
 854  509D              	; save position
 855  509D E5           	PUSH HL
 856  509E DD E1        	POP IX
 857  50A0
 858  50A0 D1           	POP DE ; actually AF
 859  50A1 C1           	POP BC ; count
 860  50A2 E1           	POP HL ; start address
 861  50A3 78           	LD A, B
 862  50A4 B7           	OR A
 863  50A5 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 864  50A7 B1           	OR C
 865  50A8 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 866  50AA 79           	LD A, C
 867  50AB 3D           	DEC A
 868  50AC 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 869  50AE              	; one byte to fill
 870  50AE 72           	LD (HL), D
 871  50AF 18 12        	JR .EXIT
 872  50B1              .L1:
 873  50B1 D9           	EXX
 874  50B2              	; enable page 0
 875  50B2 FD 21 B9 50  	LD IY, .RET
 876  50B6 C3 CE 4E     	JP ENABLE_PAGE0
 877  50B9              .RET:
 878  50B9 FB           	EI
 879  50BA D9           	EXX
 880  50BB CD C7 50     	CALL .FILLVALUE
 881  50BE D1               POP DE
 882  50BF C1               POP BC
 883  50C0 CD 45 4E         CALL RESTORE_PAGE_INFO
 884  50C3              .EXIT:
 885  50C3 DD E5        	PUSH IX
 886  50C5 E1           	POP HL
 887  50C6 C9           	RET
 888  50C7
 889  50C7              .FILLVALUE:
 890  50C7 72               LD (HL), D
 891  50C8 54               LD D, H
 892  50C9 5D               LD E, L
 893  50CA 13               INC DE
 894  50CB 0B               DEC BC
 895  50CC ED B0            LDIR
 896  50CE C9               RET
 897  50CF              ; *******************************************************************************************************
 898  50CF               ENDIF
 899  50CF
 900  50CF               IFNDEF EXCLUDE_GENCAL
 901  50CF              ; *******************************************************************************************************
 902  50CF              ; function to handle CALL GENCAL basic extension
 903  50CF              ; GENCAL ( INT fn_addr, = address of the function to call
 904  50CF              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 905  50CF              ; output values of reristers will also be stored at reg_list_ptr
 906  50CF              GENCAL_VAR_SP:
 907  50CF 00 00            DW 0
 908  50D1              GENCAL_VAR_SP2:
 909  50D1 00 00            DW 0
 910  50D3              GENCAL:
 911  50D3              	; opening (
 912  50D3 CD CC 4F     	CALL CHKCHAR
 913  50D6 28           	DB '('
 914  50D7              	; get function address
 915  50D7 DD 21 2F 54  	LD IX, FRMQNT
 916  50DB CD 59 01     	CALL CALBAS
 917  50DE D5           	PUSH DE
 918  50DF              	; comma
 919  50DF CD CC 4F     	CALL CHKCHAR
 920  50E2 2C           	DB ','
 921  50E3              	; get pointer to register list
 922  50E3 DD 21 2F 54  	LD IX, FRMQNT
 923  50E7 CD 59 01     	CALL CALBAS
 924  50EA D5           	PUSH DE
 925  50EB              	; ending )
 926  50EB CD CC 4F     	CALL CHKCHAR
 927  50EE 29           	DB ')'
 928  50EF
 929  50EF              	; save BASIC token position
 930  50EF E5           	PUSH HL
 931  50F0 D9               EXX
 932  50F1 E1           	POP HL ; HL'=next basic token
 933  50F2 D9               EXX
 934  50F3
 935  50F3 E1               POP HL ; get pointer to register values
 936  50F4 ED 73 CF 50      LD (GENCAL_VAR_SP), SP
 937  50F8 F3               DI
 938  50F9 F9               LD SP, HL
 939  50FA F1               POP AF
 940  50FB C1               POP BC
 941  50FC D1               POP DE
 942  50FD E1               POP HL
 943  50FE DD E1            POP IX
 944  5100 FD E1            POP IY
 945  5102 D9               EXX
 946  5103 ED 73 D1 50      LD (GENCAL_VAR_SP2), SP
 947  5107 ED 7B CF 50      LD SP, (GENCAL_VAR_SP)
 948  510B FB               EI
 949  510C D1               POP DE ; get function to call
 950  510D E5               PUSH HL
 951  510E CD 29 51         CALL .EXXDECALL
 952  5111 F3               DI
 953  5112 ED 73 CF 50      LD (GENCAL_VAR_SP), SP
 954  5116 ED 7B D1 50      LD SP, (GENCAL_VAR_SP2)
 955  511A FD E5            PUSH IY
 956  511C DD E5            PUSH IX
 957  511E E5               PUSH HL
 958  511F D5               PUSH DE
 959  5120 C5               PUSH BC
 960  5121 F5               PUSH AF
 961  5122 ED 7B CF 50      LD SP, (GENCAL_VAR_SP)
 962  5126 FB               EI
 963  5127 E1               POP HL
 964  5128 C9           	RET
 965  5129
 966  5129              .EXXDECALL:
 967  5129 D5               PUSH DE
 968  512A D9               EXX
 969  512B C9               RET
 970  512C              ; *******************************************************************************************************
 971  512C               ENDIF
 972  512C
 973  512C               IFNDEF EXCLUDE_VRAM_CMDS
 974  512C              ; *******************************************************************************************************
 975  512C              ; function to handle CALL MEMVRM basic extension
 976  512C              ; copies from RAM to VRAM
 977  512C              ; _MEMVRM ( INT source,
 978  512C              ;			INT destination,
 979  512C              ;			INT count,
 980  512C              ;			BYTE wait_vsync) >0 = true
 981  512C              ; will put ram in page 0 also, page 1 is already there
 982  512C              ; wait_vsync will issue HALT before copying
 983  512C              MEMVRM:
 984  512C              	; opening (
 985  512C CD CC 4F     	CALL CHKCHAR
 986  512F 28           	DB '('
 987  5130              	; get source address
 988  5130 DD 21 2F 54  	LD IX, FRMQNT
 989  5134 CD 59 01     	CALL CALBAS
 990  5137 D5           	PUSH DE
 991  5138              	; comma
 992  5138 CD CC 4F     	CALL CHKCHAR
 993  513B 2C           	DB ','
 994  513C              	; get destination address
 995  513C DD 21 2F 54  	LD IX, FRMQNT
 996  5140 CD 59 01     	CALL CALBAS
 997  5143 D5           	PUSH DE
 998  5144              	; comma
 999  5144 CD CC 4F     	CALL CHKCHAR
1000  5147 2C           	DB ','
1001  5148              	; get length
1002  5148 DD 21 2F 54  	LD IX, FRMQNT
1003  514C CD 59 01     	CALL CALBAS
1004  514F D5           	PUSH DE
1005  5150              	; comma
1006  5150 CD CC 4F     	CALL CHKCHAR
1007  5153 2C           	DB ','
1008  5154              	; get vsync wait
1009  5154 DD 21 1C 52  	LD IX, GETBYT
1010  5158 CD 59 01     	CALL CALBAS
1011  515B F5           	PUSH AF
1012  515C              	; ending )
1013  515C CD CC 4F     	CALL CHKCHAR
1014  515F 29           	DB ')'
1015  5160
1016  5160                  ; save position in BASIC text
1017  5160 E5           	PUSH HL
1018  5161 DD E1        	POP IX
1019  5163
1020  5163 F1           	POP AF ; wait vsync
1021  5164 B7           	OR A
1022  5165 28 03        	JR Z, .L1
1023  5167 FB               EI
1024  5168 76           	HALT
1025  5169 F3           	DI
1026  516A              .L1:
1027  516A              	; pop LDIR parameters and store away for later
1028  516A C1           	POP BC ; count
1029  516B D1           	POP DE ; vram destination
1030  516C E1           	POP HL ; ram source
1031  516D D9           	EXX
1032  516E FD 21 75 51   	LD IY, .RET
1033  5172 C3 CE 4E     	JP ENABLE_PAGE0
1034  5175              .RET:
1035  5175 FB           	EI
1036  5176 D9           	EXX
1037  5177 CD 83 51     	CALL .LDIRVM
1038  517A D1               POP DE
1039  517B C1               POP BC
1040  517C CD 45 4E         CALL RESTORE_PAGE_INFO
1041  517F DD E5        	PUSH IX
1042  5181 E1           	POP HL
1043  5182 C9           	RET
1044  5183
1045  5183              .LDIRVM:
1046  5183 EB           	EX DE, HL
1047  5184 F3           	DI
1048  5185 CD 03 4E     	CALL SETWRT_LOCAL
1049  5188 FB           	EI
1050  5189 EB           	EX DE, HL
1051  518A 78           	LD A, B
1052  518B B7           	OR A
1053  518C 28 0D        	JR Z, .L3
1054  518E C5           	PUSH BC
1055  518F 0E 98        	LD C, #98
1056  5191              .L2:
1057  5191 50           	LD D, B
1058  5192 06 00        	LD B, 0
1059  5194 CD A1 51     	CALL .BBYTECOPY
1060  5197 42           	LD B, D
1061  5198 10 F7        	DJNZ .L2
1062  519A C1           	POP BC
1063  519B              .L3:
1064  519B 79           	LD A, C
1065  519C B7           	OR A
1066  519D C8           	RET Z
1067  519E 41           	LD B, C
1068  519F 0E 98        	LD C, #98
1069  51A1              .BBYTECOPY:
1070  51A1 ED A3        	OUTI
1071  51A3 C2 A1 51     	JP	NZ, .BBYTECOPY
1072  51A6 C9           	RET
1073  51A7              ; *******************************************************************************************************
1074  51A7               ENDIF
1075  51A7
1076  51A7               IFNDEF EXCLUDE_VRAM_CMDS
1077  51A7              ; *******************************************************************************************************
1078  51A7              ; function to handle CALL VRMMEM basic extension
1079  51A7              ; copies from RAM to VRAM
1080  51A7              ; _VRMMEM ( INT source,
1081  51A7              ;			INT destination,
1082  51A7              ;			INT count
1083  51A7              ; will put ram in page 0 also, page 1 is already there
1084  51A7              VRMMEM:
1085  51A7              	; opening (
1086  51A7 CD CC 4F     	CALL CHKCHAR
1087  51AA 28           	DB '('
1088  51AB              	; get source address
1089  51AB DD 21 2F 54  	LD IX, FRMQNT
1090  51AF CD 59 01     	CALL CALBAS
1091  51B2 D5           	PUSH DE
1092  51B3              	; comma
1093  51B3 CD CC 4F     	CALL CHKCHAR
1094  51B6 2C           	DB ','
1095  51B7              	; get destination address
1096  51B7 DD 21 2F 54  	LD IX, FRMQNT
1097  51BB CD 59 01     	CALL CALBAS
1098  51BE D5           	PUSH DE
1099  51BF              	; comma
1100  51BF CD CC 4F     	CALL CHKCHAR
1101  51C2 2C           	DB ','
1102  51C3              	; get length
1103  51C3 DD 21 2F 54  	LD IX, FRMQNT
1104  51C7 CD 59 01     	CALL CALBAS
1105  51CA D5           	PUSH DE
1106  51CB              	; ending )
1107  51CB CD CC 4F     	CALL CHKCHAR
1108  51CE 29           	DB ')'
1109  51CF
1110  51CF                  ; save position in BASIC text
1111  51CF E5           	PUSH HL
1112  51D0 DD E1        	POP IX
1113  51D2
1114  51D2 C1           	POP BC ; count
1115  51D3 D1           	POP DE ; destination
1116  51D4 E1           	POP HL ; source
1117  51D5 D9           	EXX
1118  51D6 FD 21 DD 51  	LD IY, .RET
1119  51DA C3 CE 4E     	JP ENABLE_PAGE0
1120  51DD              .RET:
1121  51DD FB           	EI
1122  51DE D9           	EXX
1123  51DF CD EB 51     	CALL .LDIRMV
1124  51E2 D1               POP DE
1125  51E3 C1               POP BC
1126  51E4 CD 45 4E         CALL RESTORE_PAGE_INFO
1127  51E7 DD E5        	PUSH IX
1128  51E9 E1           	POP HL
1129  51EA C9           	RET
1130  51EB
1131  51EB              .LDIRMV:
1132  51EB              	; set VRAM address *exactly* as in ROM, otherwise corruption
1133  51EB 7D           	LD	A, L
1134  51EC F3           	DI
1135  51ED D3 99        	OUT	(099H), A
1136  51EF 7C           	LD	A, H
1137  51F0 E6 3F        	AND	03FH
1138  51F2 D3 99        	OUT	(099H), A
1139  51F4 FB           	EI
1140  51F5              	;EX (SP), HL
1141  51F5              	;EX (SP), HL
1142  51F5              	;NOP
1143  51F5              	;NOP
1144  51F5              .L4:
1145  51F5 DB 98            IN A, (#98)
1146  51F7 12           	LD (DE), A
1147  51F8 13               INC DE
1148  51F9 0B               DEC BC
1149  51FA 79               LD A, C
1150  51FB B0               OR B
1151  51FC 20 F7            JR NZ, .L4
1152  51FE C9               RET
1153  51FF              ; *******************************************************************************************************
1154  51FF               ENDIF
1155  51FF
1156  51FF              ; *******************************************************************************************************
1157  51FF              ; H.TIMI function
1158  51FF              MBGE_HTIMI:
1159  51FF               EXPORT MBGE_HTIMI
1160  51FF F5           	PUSH AF
1161  5200
1162  5200               IFNDEF EXCLUDE_SPRITE_CMDS
1163  5200 CD DE 4E     	CALL SPRATR_UPDATE
1164  5203               ENDIF
1165  5203
1166  5203               IFNDEF EXCLUDE_SOUND_PLAYER
1167  5203 3A F7 4C     	LD A, (SOUND_ENABLED)
1168  5206 B7           	OR A
1169  5207 28 2A        	JR Z, .EXIT
1170  5209
1171  5209              	; enable page 2
1172  5209 3E 02            LD A, 2
1173  520B CD 0E 4E         CALL GET_PAGE_INFO
1174  520E C5               PUSH BC
1175  520F D5               PUSH DE
1176  5210 3A 43 F3         LD A, (RAMAD2)
1177  5213 26 80            LD H, 080H
1178  5215 CD 55 4E         CALL LOCAL_ENASLT
1179  5218              	; enable page 0
1180  5218 AF               XOR A
1181  5219 CD 0E 4E         CALL GET_PAGE_INFO
1182  521C C5               PUSH BC
1183  521D D5               PUSH DE
1184  521E 3A 41 F3         LD A, (RAMAD0)
1185  5221 26 00            LD H, 0
1186  5223 CD 55 4E         CALL LOCAL_ENASLT
1187  5226
1188  5226 CD 33 42     	CALL PLY_AKG_PLAY
1189  5229
1190  5229              	; restore page 0
1191  5229 D1               POP DE
1192  522A C1               POP BC
1193  522B CD 45 4E         CALL RESTORE_PAGE_INFO
1194  522E              	; restore page 2
1195  522E D1               POP DE
1196  522F C1               POP BC
1197  5230 CD 45 4E         CALL RESTORE_PAGE_INFO
1198  5233               ENDIF
1199  5233
1200  5233              .EXIT:
1201  5233 F1           	POP AF
1202  5234 C3 F0 4C     	JP ORIG.HTIMI
1203  5237              ; *******************************************************************************************************
1204  5237
1205  5237              ; *******************************************************************************************************
1206  5237              ; interrupt handler when page 0 enabled
1207  5237              VBLANK:
1208  5237              	EXPORT VBLANK
1209  5237
1210  5237 F5               PUSH AF
1211  5238              	; is VDP originator ?
1212  5238 DB 99        	IN	A, (099H)
1213  523A A7           	AND	A
1214  523B F2 61 52     	JP P, .EXIT
1215  523E
1216  523E               IFNDEF EXCLUDE_SOUND_PLAYER
1217  523E 3A F7 4C     	LD A, (SOUND_ENABLED)
1218  5241 B7           	OR A
1219  5242 28 1D        	JR Z, .EXIT
1220  5244
1221  5244 C5               PUSH BC
1222  5245 D5               PUSH DE
1223  5246 E5               PUSH HL
1224  5247 08               EX AF, AF'
1225  5248 D9               EXX
1226  5249 F5               PUSH AF
1227  524A C5               PUSH BC
1228  524B D5               PUSH DE
1229  524C E5               PUSH HL
1230  524D DD E5            PUSH IX
1231  524F FD E5            PUSH IY
1232  5251
1233  5251 CD 33 42     	CALL PLY_AKG_PLAY
1234  5254
1235  5254 FD E1            POP IY
1236  5256 DD E1            POP IX
1237  5258 E1               POP HL
1238  5259 D1               POP DE
1239  525A C1               POP BC
1240  525B F1               POP AF
1241  525C 08               EX AF, AF'
1242  525D D9               EXX
1243  525E E1               POP HL
1244  525F D1               POP DE
1245  5260 C1               POP BC
1246  5261               ENDIF
1247  5261
1248  5261              .EXIT:
1249  5261 F1           	POP AF
1250  5262 FB           	EI
1251  5263 ED 4D        	RETI
1252  5265              ; *******************************************************************************************************
1253  5265
1254  5265               IFNDEF EXCLUDE_SOUND_PLAYER
1255  5265              ; *******************************************************************************************************
1256  5265              ; function to handle CALL SNDPLYINIT basic extension
1257  5265              ; initializes sound player
1258  5265              ; _SNDPLYINIT ( INT music_offset,
1259  5265              ;				INT sfx_offset, can be -1 if no SFX
1260  5265              ; will put ram in page 0 also, page 1 is already there
1261  5265              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1262  5265              SNDPLYINIT:
1263  5265              	; opening (
1264  5265 CD CC 4F     	CALL CHKCHAR
1265  5268 28           	DB '('
1266  5269              	; get music address
1267  5269 DD 21 2F 54  	LD IX, FRMQNT
1268  526D CD 59 01     	CALL CALBAS
1269  5270 D5           	PUSH DE
1270  5271              	; comma
1271  5271 CD CC 4F     	CALL CHKCHAR
1272  5274 2C           	DB ','
1273  5275              	; get sfx address
1274  5275 DD 21 2F 54  	LD IX, FRMQNT
1275  5279 CD 59 01     	CALL CALBAS
1276  527C D5           	PUSH DE
1277  527D              	; ending )
1278  527D CD CC 4F     	CALL CHKCHAR
1279  5280 29           	DB ')'
1280  5281
1281  5281                  ; save position in BASIC text
1282  5281 44           	LD B, H
1283  5282 4D           	LD C, L
1284  5283
1285  5283              	; pop LDIR parameters and store away for later
1286  5283 D1           	POP DE ; sfx address
1287  5284 E1           	POP HL ; music address
1288  5285 C5           	PUSH BC ; basic text location
1289  5286 D9           	EXX
1290  5287 FD 21 8E 52  	LD IY, .RET
1291  528B C3 CE 4E     	JP ENABLE_PAGE0
1292  528E              .RET:
1293  528E D9           	EXX
1294  528F
1295  528F D5           	PUSH DE
1296  5290 AF           	XOR A
1297  5291              	; HL = music location
1298  5291 CD 62 41     	CALL PLY_AKG_INIT
1299  5294 3E 01        	LD A, 1
1300  5296 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1301  5299
1302  5299 E1           	POP HL ; SFX
1303  529A              	; check if SFX address -1
1304  529A 23           	INC HL
1305  529B 7D           	LD A, L
1306  529C B4           	OR H
1307  529D 28 09        	JR Z,.L1
1308  529F 2B           	DEC HL
1309  52A0 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1310  52A3 3E 01        	LD A, 1
1311  52A5 32 F6 4C     	LD (SFX_INIT_STATUS), A
1312  52A8              .L1:
1313  52A8 D1               POP DE
1314  52A9 C1               POP BC
1315  52AA CD 45 4E         CALL RESTORE_PAGE_INFO
1316  52AD
1317  52AD E1           	POP HL
1318  52AE C9           	RET
1319  52AF              ; *******************************************************************************************************
1320  52AF
1321  52AF              ; *******************************************************************************************************
1322  52AF              ; function to handle CALL SNDPLYON basic extension
1323  52AF              ; enables sound player
1324  52AF              ; _SNDPLYON
1325  52AF              ; sets SOUND_ENABLED variable to 1 if init call was done
1326  52AF              ; if not throws out of data error
1327  52AF              SNDPLYON:
1328  52AF 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1329  52B2 B7           	OR A
1330  52B3 20 05        	JR NZ, .L1
1331  52B5              	; player not initialized, throw error
1332  52B5 1E 04        	LD E, 04 ; Out of DATA
1333  52B7 C3 E4 4F     	JP THROW_ERROR
1334  52BA              .L1:
1335  52BA 32 F7 4C     	LD (SOUND_ENABLED), A
1336  52BD              	; disable key click
1337  52BD AF           	XOR A
1338  52BE 32 DB F3     	LD (CLIKSW), A
1339  52C1 C9           	RET
1340  52C2              ; *******************************************************************************************************
1341  52C2
1342  52C2              ; *******************************************************************************************************
1343  52C2              ; function to handle CALL SNDPLYOFF basic extension
1344  52C2              ; disables sound player
1345  52C2              ; _SNDPLYOFF
1346  52C2              ; sets SOUND_ENABLED variable to 0
1347  52C2              ; calls AKG to stop music and SFX on all channels if initialized
1348  52C2              SNDPLYOFF:
1349  52C2 3A F7 4C     	LD A, (SOUND_ENABLED)
1350  52C5 B7           	OR A
1351  52C6 C8           	RET Z ; already stopped
1352  52C7 AF           	XOR A
1353  52C8 32 F7 4C     	LD (SOUND_ENABLED), A
1354  52CB E5           	PUSH HL
1355  52CC CD 21 42     	CALL PLY_AKG_STOP
1356  52CF 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1357  52D2 B7           	OR A
1358  52D3 28 0E        	JR Z, .EXIT ; SFX not in use
1359  52D5 AF           	XOR A
1360  52D6 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1361  52D9 3E 01        	LD A, 1
1362  52DB CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1363  52DE 3E 02        	LD A, 2
1364  52E0 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1365  52E3              .EXIT:
1366  52E3 E1           	POP HL
1367  52E4 C9           	RET
1368  52E5              ; *******************************************************************************************************
1369  52E5
1370  52E5              ; *******************************************************************************************************
1371  52E5              ; function to handle CALL SNDSFX basic extension
1372  52E5              ; plays a sound effect
1373  52E5              ; _SNDSFX ( BYTE sfx_number, >0
1374  52E5              ;			BYTE channel, = 0,1 or 2
1375  52E5              ;			BYTE inverted_volume = 0-16, 0 being full volume
1376  52E5              ; will put ram in page 0 also, page 1 is already there
1377  52E5              ; if sound off throws illegal function call
1378  52E5              ; if sfx not initialized, throws out of data
1379  52E5              SNDSFX:
1380  52E5              	; opening (
1381  52E5 CD CC 4F     	CALL CHKCHAR
1382  52E8 28           	DB '('
1383  52E9              	; get sfx_number
1384  52E9 DD 21 1C 52  	LD IX, GETBYT
1385  52ED CD 59 01     	CALL CALBAS
1386  52F0 D5           	PUSH DE
1387  52F1              	; comma
1388  52F1 CD CC 4F     	CALL CHKCHAR
1389  52F4 2C           	DB ','
1390  52F5              	; get sfx address
1391  52F5 DD 21 1C 52  	LD IX, GETBYT
1392  52F9 CD 59 01     	CALL CALBAS
1393  52FC D5           	PUSH DE
1394  52FD              	; comma
1395  52FD CD CC 4F     	CALL CHKCHAR
1396  5300 2C           	DB ','
1397  5301              	; get inverted volume
1398  5301 DD 21 1C 52  	LD IX, GETBYT
1399  5305 CD 59 01     	CALL CALBAS
1400  5308 D5           	PUSH DE
1401  5309              	; ending )
1402  5309 CD CC 4F     	CALL CHKCHAR
1403  530C 29           	DB ')'
1404  530D
1405  530D 3A F7 4C     	LD A, (SOUND_ENABLED)
1406  5310 B7           	OR A
1407  5311 20 05        	JR NZ, .L1
1408  5313              	; sound disabled, throw illegal function call
1409  5313 1E 05        	LD E, 5
1410  5315 C3 E4 4F     	JP THROW_ERROR
1411  5318              .L1:
1412  5318 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1413  531B B7           	OR A
1414  531C 20 05        	JR NZ, .L2
1415  531E              	; sfx data not initialized, throw out of data
1416  531E 1E 04        	LD E, 4
1417  5320 C3 E4 4F     	JP THROW_ERROR
1418  5323              .L2:
1419  5323              	; pop  parameters and store away for later
1420  5323 D1           	POP DE ; inverted volume
1421  5324 43           	LD B, E
1422  5325 D1           	POP DE ; channel
1423  5326 4B           	LD C, E
1424  5327 D1           	POP DE
1425  5328 7B           	LD A, E
1426  5329 08           	EX AF, AF'
1427  532A E5           	PUSH HL ; basic text location
1428  532B D9           	EXX
1429  532C FD 21 33 53  	LD IY, .RET
1430  5330 C3 CE 4E     	JP ENABLE_PAGE0
1431  5333              .RET:
1432  5333 D9           	EXX
1433  5334 08           	EX AF, AF'
1434  5335 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1435  5338
1436  5338 D1               POP DE
1437  5339 C1               POP BC
1438  533A CD 45 4E         CALL RESTORE_PAGE_INFO
1439  533D
1440  533D E1           	POP HL
1441  533E C9           	RET
1442  533F              ; *******************************************************************************************************
1443  533F               ENDIF
1444  533F
1445  533F               IFNDEF EXCLUDE_SPRITE_CMDS
1446  533F              ; *******************************************************************************************************
1447  533F              ; function to handle CALL SPRENABLE basic extension
1448  533F              ; initializes sprites handler
1449  533F              ; _SPRENABLE ( INT sprites_attributes_data,
1450  533F              ;			   INT update_variable_location,
1451  533F              ;			   INT sprite_flicker_enabled )
1452  533F              ; expects both locations to be in range #8000+ or throws an error
1453  533F              ; since these should be BASIC variables
1454  533F              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
1455  533F              SPRENABLE:
1456  533F              	; opening (
1457  533F CD CC 4F     	CALL CHKCHAR
1458  5342 28           	DB '('
1459  5343              	; get address of sprite attribute table DIM SA%(3,31)
1460  5343 DD 21 2F 54  	LD IX, FRMQNT
1461  5347 CD 59 01     	CALL CALBAS
1462  534A D5           	PUSH DE
1463  534B              	; comma
1464  534B CD CC 4F     	CALL CHKCHAR
1465  534E 2C           	DB ','
1466  534F              	; get address of sprite update flag location
1467  534F DD 21 2F 54  	LD IX, FRMQNT
1468  5353 CD 59 01     	CALL CALBAS
1469  5356 D5           	PUSH DE
1470  5357              	; comma
1471  5357 CD CC 4F     	CALL CHKCHAR
1472  535A 2C           	DB ','
1473  535B              	; get flicker enabled flag
1474  535B DD 21 2F 54  	LD IX, FRMQNT
1475  535F CD 59 01     	CALL CALBAS
1476  5362 D5           	PUSH DE
1477  5363              	; ending )
1478  5363 CD CC 4F     	CALL CHKCHAR
1479  5366 29           	DB ')'
1480  5367
1481  5367 D1           	POP DE ; get flicker flag
1482  5368 7A           	LD A, D
1483  5369 B3           	OR E
1484  536A 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
1485  536D
1486  536D D1           	POP DE ; update variable location
1487  536E CB 7A        	BIT 7, D ; is address >= &h8000
1488  5370 20 05        	JR NZ, .L1
1489  5372 1E 05        	LD E, 5 ; illegal function call
1490  5374 C3 E4 4F     	JP THROW_ERROR
1491  5377              .L1:
1492  5377 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
1493  537B D1           	POP DE ; address of sprite attribute table
1494  537C CB 7A        	BIT 7, D ; is address >= &h8000
1495  537E 20 05        	JR NZ, .L2
1496  5380 1E 05        	LD E, 5 ; illegal function call
1497  5382 C3 E4 4F     	JP THROW_ERROR
1498  5385              .L2:
1499  5385 ED 53 FB 4C  	LD (SPRATR_DATA), DE
1500  5389 3E 01        	LD A, 1
1501  538B 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1502  538E C9           	RET
1503  538F              ; *******************************************************************************************************
1504  538F
1505  538F              ; *******************************************************************************************************
1506  538F              ; function to handle CALL SPRDISABLE basic extension
1507  538F              ; disables sprites handling
1508  538F              ; _SPRDISABLE
1509  538F              ; resets variable SPRATR_INIT_STATUS
1510  538F              SPRDISABLE:
1511  538F AF           	XOR A
1512  5390 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1513  5393 C9           	RET
1514  5394              ; *******************************************************************************************************
1515  5394
1516  5394              ; *******************************************************************************************************
1517  5394              ; function to handle CALL SPRSET basic extension
1518  5394              ; sets position, and optionally pattern and color of sprite
1519  5394              ; _SPRSET ( BYTE sprite_num , valid 0-31
1520  5394              ;			INT x,
1521  5394              ;			INT y,
1522  5394              ;			INT pattern, valid 0-63, otherwise ignored
1523  5394              ;			INT color, valid 0-15, otherwise ignored
1524  5394              SPRSET:
1525  5394 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1526  5397 B7           	OR A
1527  5398 20 05        	JR NZ, .L1
1528  539A 1E 05        	LD E, 5 ; illegal function call
1529  539C C3 E4 4F     	JP THROW_ERROR
1530  539F              .L1:
1531  539F              	; opening (
1532  539F CD CC 4F     	CALL CHKCHAR
1533  53A2 28           	DB '('
1534  53A3              	; get sprite number
1535  53A3 DD 21 1C 52  	LD IX, GETBYT
1536  53A7 CD 59 01     	CALL CALBAS
1537  53AA F5           	PUSH AF
1538  53AB              	; comma
1539  53AB CD CC 4F     	CALL CHKCHAR
1540  53AE 2C           	DB ','
1541  53AF              	; get x
1542  53AF DD 21 2F 54  	LD IX, FRMQNT
1543  53B3 CD 59 01     	CALL CALBAS
1544  53B6 D5           	PUSH DE
1545  53B7              	; comma
1546  53B7 CD CC 4F     	CALL CHKCHAR
1547  53BA 2C           	DB ','
1548  53BB              	; get y
1549  53BB DD 21 2F 54  	LD IX, FRMQNT
1550  53BF CD 59 01     	CALL CALBAS
1551  53C2 D5           	PUSH DE
1552  53C3              	; comma
1553  53C3 CD CC 4F     	CALL CHKCHAR
1554  53C6 2C           	DB ','
1555  53C7              	; get pattern
1556  53C7 DD 21 2F 54  	LD IX, FRMQNT
1557  53CB CD 59 01     	CALL CALBAS
1558  53CE D5           	PUSH DE
1559  53CF              	; comma
1560  53CF CD CC 4F     	CALL CHKCHAR
1561  53D2 2C           	DB ','
1562  53D3              	; get color
1563  53D3 DD 21 2F 54  	LD IX, FRMQNT
1564  53D7 CD 59 01     	CALL CALBAS
1565  53DA D5           	PUSH DE
1566  53DB              	; ending )
1567  53DB CD CC 4F     	CALL CHKCHAR
1568  53DE 29           	DB ')'
1569  53DF
1570  53DF                  ; save position in BASIC text
1571  53DF E5           	PUSH HL
1572  53E0 DD E1        	POP IX
1573  53E2
1574  53E2 C1           	POP BC ; color
1575  53E3 D1           	POP DE ; pattern
1576  53E4 D9           	EXX
1577  53E5 C1           	POP BC ; y
1578  53E6 D1           	POP DE ; x
1579  53E7 F1           	POP AF ; sprite number
1580  53E8 FE 20        	CP 32
1581  53EA 38 05        	JR C, .L2
1582  53EC 1E 05        	LD E, 5 ; illegal function call
1583  53EE C3 E4 4F     	JP THROW_ERROR
1584  53F1              .L2:
1585  53F1              	; find location in sprite attributes table
1586  53F1 87          > ADD A, A
1586  53F2 87          > ADD A, A
1586  53F3 87          > ADD A, A
1587  53F4 D5           	PUSH DE
1588  53F5 16 00        	LD D, 0
1589  53F7 5F           	LD E, A
1590  53F8 2A FB 4C     	LD HL, (SPRATR_DATA)
1591  53FB 19           	ADD HL, DE
1592  53FC D1           	POP DE
1593  53FD              	; set y
1594  53FD 71           	LD (HL), C
1595  53FE 23           	INC HL
1596  53FF 70           	LD (HL), B
1597  5400 23           	INC HL
1598  5401              	; set x
1599  5401 73           	LD (HL), E
1600  5402 23           	INC HL
1601  5403 72           	LD (HL), D
1602  5404 23           	INC HL
1603  5405 E5           	PUSH HL
1604  5406 D9           	EXX
1605  5407 E1           	POP HL
1606  5408              	; check if 0<=pattern<64
1607  5408 7A           	LD A, D
1608  5409 B7           	OR A
1609  540A 20 0B        	JR NZ, .L3
1610  540C 7B           	LD A, E
1611  540D FE 40        	CP 64
1612  540F 30 06        	JR NC, .L3
1613  5411              	; set pattern
1614  5411              	;ADD A, A
1615  5411              	;ADD A, A
1616  5411              	;ADD A, A
1617  5411 77           	LD (HL), A
1618  5412 23           	INC HL
1619  5413 72           	LD (HL), D
1620  5414 23           	INC HL
1621  5415 18 02        	JR .L4
1622  5417              .L3:
1623  5417              	; skip pattern
1624  5417 23          > INC HL
1624  5418 23          > INC HL
1625  5419              .L4:
1626  5419              	; check if 0<=color<16
1627  5419 78           	LD A, B
1628  541A B7           	OR A
1629  541B 20 08        	JR NZ, .L5
1630  541D 79           	LD A, C
1631  541E FE 10        	CP 16
1632  5420 30 03        	JR NC, .L5
1633  5422              	; set color
1634  5422 71           	LD (HL), C
1635  5423 23           	INC HL
1636  5424 70           	LD (HL), B
1637  5425
1638  5425              .L5:
1639  5425 DD E5        	PUSH IX
1640  5427 E1           	POP HL
1641  5428 C9           	RET
1642  5429              ; *******************************************************************************************************
1643  5429
1644  5429              ; *******************************************************************************************************
1645  5429              ; function sets sprite location based on initial coordinates and offset provided
1646  5429              ; input A=sprite number in SPRATR_DATA , 0-31
1647  5429              ; input DE=initial x
1648  5429              ; input BC=initial y
1649  5429              ; input IY=location where delta y,x are located
1650  5429              ; modifies AF, HL, IX
1651  5429              SPRSET_DELTA_POS:
1652  5429 87          > ADD A, A
1652  542A 87          > ADD A, A
1652  542B 87          > ADD A, A
1653  542C D5           	PUSH DE
1654  542D 16 00        	LD D, 0
1655  542F 5F           	LD E, A
1656  5430 DD 2A FB 4C  	LD IX, (SPRATR_DATA)
1657  5434 DD 19        	ADD IX, DE
1658  5436 D1           	POP DE
1659  5437              	; IX=sprite's y location
1660  5437 FD 6E 00     	LD L, (IY)
1661  543A FD 66 01     	LD H, (IY+1)
1662  543D 09           	ADD HL, BC
1663  543E DD 75 00     	LD (IX), L
1664  5441 DD 74 01     	LD (IX+1), H
1665  5444 FD 6E 02     	LD L, (IY+2)
1666  5447 FD 66 03     	LD H, (IY+3)
1667  544A 19           	ADD HL, DE
1668  544B DD 75 02     	LD (IX+2), L
1669  544E DD 74 03     	LD (IX+3), H
1670  5451 C9           	RET
1671  5452              ; *******************************************************************************************************
1672  5452
1673  5452              ; *******************************************************************************************************
1674  5452              ; function to handle CALL SPRGRPMOV basic extension
1675  5452              ; sets position of a group of sprites described with
1676  5452              ; { int sprite_num, int delta_y, int delta_x } [count]
1677  5452              ; _SPRGRPMOV ( INT x,
1678  5452              ;			   INT y,
1679  5452              ;			   INT data_ptr,
1680  5452              ;			   BYTE count,
1681  5452              ; will put ram in page 0 also, page 1 is already there
1682  5452              SPRGRPMOV:
1683  5452 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1684  5455 B7           	OR A
1685  5456 20 05        	JR NZ, .L1
1686  5458 1E 05        	LD E, 5 ; illegal function call
1687  545A C3 E4 4F     	JP THROW_ERROR
1688  545D              .L1:
1689  545D              	; opening (
1690  545D CD CC 4F     	CALL CHKCHAR
1691  5460 28           	DB '('
1692  5461              	; get x
1693  5461 DD 21 2F 54  	LD IX, FRMQNT
1694  5465 CD 59 01     	CALL CALBAS
1695  5468 D5           	PUSH DE
1696  5469              	; comma
1697  5469 CD CC 4F     	CALL CHKCHAR
1698  546C 2C           	DB ','
1699  546D              	; get y
1700  546D DD 21 2F 54  	LD IX, FRMQNT
1701  5471 CD 59 01     	CALL CALBAS
1702  5474 D5           	PUSH DE
1703  5475              	; comma
1704  5475 CD CC 4F     	CALL CHKCHAR
1705  5478 2C           	DB ','
1706  5479              	; get data pointer
1707  5479 DD 21 2F 54  	LD IX, FRMQNT
1708  547D CD 59 01     	CALL CALBAS
1709  5480 D5           	PUSH DE
1710  5481              	; comma
1711  5481 CD CC 4F     	CALL CHKCHAR
1712  5484 2C           	DB ','
1713  5485              	; get count
1714  5485 DD 21 1C 52  	LD IX, GETBYT
1715  5489 CD 59 01     	CALL CALBAS
1716  548C F5           	PUSH AF
1717  548D              	; ending )
1718  548D CD CC 4F     	CALL CHKCHAR
1719  5490 29           	DB ')'
1720  5491
1721  5491 E5           	PUSH HL
1722  5492 DD E1        	POP IX
1723  5494
1724  5494 C1           	POP BC ; count
1725  5495 E1           	POP HL ; data pointer
1726  5496 D9           	EXX
1727  5497 C1           	POP BC ; y
1728  5498 D1           	POP DE ; x
1729  5499 D9           	EXX
1730  549A
1731  549A DD E5        	PUSH IX ; save position in BASIC buffer
1732  549C
1733  549C C5           	PUSH BC
1734  549D E5           	PUSH HL
1735  549E AF               XOR A
1736  549F CD 0E 4E         CALL GET_PAGE_INFO
1737  54A2 D9           	EXX
1738  54A3 E1           	POP HL
1739  54A4 F1           	POP AF
1740  54A5 D9           	EXX
1741  54A6 C5               PUSH BC
1742  54A7 D5               PUSH DE
1743  54A8 D9           	EXX
1744  54A9 F5           	PUSH AF
1745  54AA E5           	PUSH HL
1746  54AB D9           	EXX
1747  54AC 3A 41 F3         LD A, (RAMAD0)
1748  54AF 26 00            LD H, 0
1749  54B1 CD 55 4E         CALL LOCAL_ENASLT
1750  54B4 FB           	EI
1751  54B5 E1           	POP HL
1752  54B6 C1           	POP BC
1753  54B7 CD C1 54     	CALL .UPDATE_LOC
1754  54BA D1               POP DE
1755  54BB C1               POP BC
1756  54BC CD 45 4E         CALL RESTORE_PAGE_INFO
1757  54BF E1           	POP HL
1758  54C0 C9           	RET
1759  54C1
1760  54C1              .UPDATE_LOC:
1761  54C1              .L4:
1762  54C1 7E           	LD A, (HL)
1763  54C2 23           	INC HL
1764  54C3 23           	INC HL
1765  54C4 E5           	PUSH HL
1766  54C5 FD E1        	POP IY
1767  54C7 D9           	EXX
1768  54C8 CD 29 54     	CALL SPRSET_DELTA_POS
1769  54CB D9           	EXX
1770  54CC 23          > INC HL
1770  54CD 23          > INC HL
1770  54CE 23          > INC HL
1770  54CF 23          > INC HL
1771  54D0 10 EF        	DJNZ .L4
1772  54D2 C9           	RET
1773  54D3              ; *******************************************************************************************************
1774  54D3               ENDIF
1775  54D3
1776  54D3               IFNDEF EXCLUDE_BLIT_CMDS
1777  54D3              ; *******************************************************************************************************
1778  54D3              ; function rotates mask and data of several characters and applies to background data
1779  54D3              ; this handles x-shift from 0 to 4
1780  54D3              ; contains self-modifying code that is set-up from external function
1781  54D3              ; input HL=pointer to mask data
1782  54D3              ; input HL'=pointer to character data
1783  54D3              ; input DE=output buffer containing background data
1784  54D3              ; input BC=DE+8
1785  54D3              ; input A=number of characters to process
1786  54D3              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1787  54D3              SHIFT04:
1788  54D3 08           	EX AF, AF'
1789  54D4 7E           	LD A, (HL) ; get mask
1790  54D5 D9           	EXX
1791  54D6 57           	LD D, A
1792  54D7 1E FF        	LD E, #FF
1793  54D9 37           	SCF
1794  54DA              .M1:
1795  54DA 18 FE        	JR .M1 ; this is self-modifying part
1796  54DC CB 1A        	RR D
1797  54DE CB 1B        	RR E
1798  54E0 CB 1A        	RR D
1799  54E2 CB 1B        	RR E
1800  54E4 CB 1A        	RR D
1801  54E6 CB 1B        	RR E
1802  54E8 CB 1A        	RR D
1803  54EA CB 1B        	RR E
1804  54EC
1805  54EC 46           	LD B, (HL) ; get data
1806  54ED 0E 00        	LD C, 0
1807  54EF              .M2:
1808  54EF 18 FE        	JR .M2 ; also self-modifying part
1809  54F1 CB 38        	SRL B
1810  54F3 CB 19        	RR C
1811  54F5 CB 38        	SRL B
1812  54F7 CB 19        	RR C
1813  54F9 CB 38        	SRL B
1814  54FB CB 19        	RR C
1815  54FD CB 38        	SRL B
1816  54FF CB 19        	RR C
1817  5501
1818  5501 D9           	EXX
1819  5502 1A           	LD A, (DE) ; background
1820  5503 D9           	EXX
1821  5504 A2           	AND D
1822  5505 B0           	OR B
1823  5506 D9           	EXX
1824  5507 12           	LD (DE), A
1825  5508
1826  5508 0A           	LD A, (BC)
1827  5509 D9           	EXX
1828  550A A3           	AND E
1829  550B B1           	OR C
1830  550C 23           	INC HL
1831  550D D9           	EXX
1832  550E 02           	LD (BC), A
1833  550F
1834  550F 23           	INC HL
1835  5510 13           	INC DE
1836  5511 03           	INC BC
1837  5512
1838  5512 08           	EX AF, AF'
1839  5513 3D           	DEC A
1840  5514 C2 D3 54     	JP NZ, SHIFT04
1841  5517 C9           	RET
1842  5518              ; *******************************************************************************************************
1843  5518
1844  5518              ; *******************************************************************************************************
1845  5518              ; function rotates mask and data of several characters and applies to background data
1846  5518              ; this handles x-shift from 5 to 8
1847  5518              ; contains self-modifying code that is set-up from external function
1848  5518              ; input HL=pointer to mask data
1849  5518              ; input HL'=pointer to character data
1850  5518              ; input DE=output buffer containing background data
1851  5518              ; input BC=DE+8
1852  5518              ; input A=number of characters to process
1853  5518              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1854  5518              SHIFT58:
1855  5518 08           	EX AF, AF'
1856  5519 7E           	LD A, (HL) ; get mask
1857  551A D9           	EXX
1858  551B 57           	LD D, A
1859  551C 1E FF        	LD E, #FF
1860  551E 37           	SCF
1861  551F              .M1:
1862  551F 18 FE        	JR .M1 ; this is self-modifying part
1863  5521 CB 12        	RL D
1864  5523 CB 13        	RL E
1865  5525 CB 12        	RL D
1866  5527 CB 13        	RL E
1867  5529 CB 12        	RL D
1868  552B CB 13        	RL E
1869  552D
1870  552D 46           	LD B, (HL)
1871  552E 0E 00        	LD C, 0
1872  5530              .M2:
1873  5530 18 FE        	JR .M2 ; also self-modifying part
1874  5532 CB 20        	SLA B
1875  5534 CB 11        	RL C
1876  5536 CB 20        	SLA B
1877  5538 CB 11        	RL C
1878  553A CB 20        	SLA B
1879  553C CB 11        	RL C
1880  553E
1881  553E D9           	EXX
1882  553F 1A           	LD A, (DE) ; background
1883  5540 D9           	EXX
1884  5541 A3           	AND E
1885  5542 B1           	OR C
1886  5543 D9           	EXX
1887  5544 12           	LD (DE), A
1888  5545
1889  5545 0A           	LD A, (BC)
1890  5546 D9           	EXX
1891  5547 A2           	AND D
1892  5548 B0           	OR B
1893  5549 23           	INC HL
1894  554A D9           	EXX
1895  554B 02           	LD (BC), A
1896  554C
1897  554C 23           	INC HL
1898  554D 13           	INC DE
1899  554E 03           	INC BC
1900  554F
1901  554F 08           	EX AF, AF'
1902  5550 3D           	DEC A
1903  5551 C2 18 55     	JP NZ, SHIFT58
1904  5554 C9           	RET
1905  5555              ; *******************************************************************************************************
1906  5555
1907  5555              ; *******************************************************************************************************
1908  5555              ; routine that shifts one row of characters
1909  5555              ; contains self-modifying code that is set-up from external function
1910  5555              ; input HL=pointer to mask data
1911  5555              ; input HL'=pointer to character data
1912  5555              ; input DE=output buffer containing background data
1913  5555              ; input A=number of characters to process
1914  5555              ; input IX=pointer to structure describing input data
1915  5555              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1916  5555              SHIFT_ROW:
1917  5555 F5           	PUSH AF
1918  5556 ED 53 01 4D  		LD (BLIT_TMP1), DE
1919  555A E5           		PUSH HL
1920  555B CD 9E 55     			CALL .ADDYSHIFT
1921  555E E1           		POP HL
1922  555F ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1923  5563              .L1:
1924  5563 3E 08        		LD A, 8
1925  5565 DD 96 02     		SUB (IX+2) ; y shift
1926  5568              .CALL1:
1927  5568 CD 00 00     		CALL 0
1928  556B DD 7E 02     		LD A, (IX+2); y shift
1929  556E B7           		OR A
1930  556F 28 26        		JR Z, .DONE
1931  5571 ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1932  5575 E5           		PUSH HL
1933  5576 CD AC 55     			CALL .DETONEXTROW
1934  5579 E1           		POP HL
1935  557A              .CALL2:
1936  557A CD 00 00     		CALL 0
1937  557D ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1938  5581 E5           		PUSH HL
1939  5582 CD A6 55     			CALL .ADD8
1940  5585 E1           		POP HL
1941  5586 ED 53 01 4D  		LD (BLIT_TMP1), DE
1942  558A ED 5B 03 4D  		LD DE, (BLIT_TMP2)
1943  558E E5           		PUSH HL
1944  558F CD A6 55     			CALL .ADD8
1945  5592 E1           		POP HL
1946  5593 ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1947  5597              .DONE:
1948  5597 F1           	POP AF
1949  5598 3D           	DEC A
1950  5599 C8           	RET Z
1951  559A F5           	PUSH AF
1952  559B C3 63 55     	JP .L1
1953  559E              .ADDYSHIFT:
1954  559E EB           	EX DE, HL
1955  559F 16 00        	LD D, 0
1956  55A1 DD 5E 02     	LD E, (IX+2); y shift
1957  55A4 18 0C        	JR .MOVDEBC
1958  55A6              .ADD8:
1959  55A6 21 08 00     	LD HL, 8
1960  55A9 C3 B2 55     	JP .MOVDEBC
1961  55AC              .DETONEXTROW:
1962  55AC DD 6E 06     	LD L, (IX+6)
1963  55AF DD 66 07     	LD H, (IX+7) ; bkg add to value
1964  55B2              .MOVDEBC:
1965  55B2 19           	ADD HL, DE
1966  55B3 54           	LD D, H
1967  55B4 5D           	LD E, L
1968  55B5 01 08 00     	LD BC, 8
1969  55B8 09           	ADD HL, BC
1970  55B9 44           	LD B, H
1971  55BA 4D           	LD C, L
1972  55BB C9           	RET
1973  55BC              ; *******************************************************************************************************
1974  55BC
1975  55BC              ; *******************************************************************************************************
1976  55BC              ; function rotates mask and character data and applies it to background
1977  55BC              ; input IX=pointer to structure describing input data
1978  55BC              ; +0  DW horizontal shift count 0-7
1979  55BC              ; +2  DW vertical shift count 0-7
1980  55BC              ; +4  DW background data start;
1981  55BC              ; +6  DW background add to value to next row of background data
1982  55BC              ; +8  DW mask data start;
1983  55BC              ; +10  DW character data start;
1984  55BC              ; +12 DW character&mask add to value to next row of data
1985  55BC              ; +14 DW columns (low byte used)
1986  55BC              ; +16 DW rows (low byte used)
1987  55BC              SHIFT_MERGE_CHARACTER:
1988  55BC DD 7E 00     	LD A, (IX) ; shift
1989  55BF FE 05        	CP 5
1990  55C1 38 25        	JR C, .RIGHT
1991  55C3              	; shifts 5-7, use rotate towards left 1-3
1992  55C3 21 18 55     	LD HL, SHIFT58
1993  55C6 22 69 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1994  55C9 22 7B 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1995  55CC D6 05        	SUB 5
1996  55CE 28 0D        	JR Z, .L1
1997  55D0 87           	ADD A, A
1998  55D1 87           	ADD A, A
1999  55D2 67           	LD H, A
2000  55D3 2E 18        	LD L, #18 ; JR opcode
2001  55D5 22 1F 55     	LD (SHIFT58.M1), HL
2002  55D8 22 30 55     	LD (SHIFT58.M2), HL
2003  55DB 18 32        	JR .DO
2004  55DD              .L1:
2005  55DD 21 00 00     	LD HL, 0 ; 2xNOP opcode
2006  55E0 22 1F 55     	LD (SHIFT58.M1), HL
2007  55E3 22 30 55     	LD (SHIFT58.M2), HL
2008  55E6 18 27        	JR .DO
2009  55E8              .RIGHT:
2010  55E8              	; shifts 0-4, rotate towards right
2011  55E8 21 D3 54     	LD HL, SHIFT04
2012  55EB 22 69 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2013  55EE 22 7B 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2014  55F1 FE 04        	CP 4
2015  55F3 28 11        	JR Z, .R1
2016  55F5 D6 04        	SUB 4
2017  55F7 ED 44        	NEG
2018  55F9 87           	ADD A, A
2019  55FA 87           	ADD A, A
2020  55FB 67           	LD H, A
2021  55FC 2E 18        	LD L, #18 ; JR opcode
2022  55FE 22 DA 54     	LD (SHIFT04.M1), HL
2023  5601 22 EF 54     	LD (SHIFT04.M2), HL
2024  5604 18 09        	JR .DO
2025  5606              .R1:
2026  5606 21 00 00     	LD HL, 0 ; 2xNOP opcode
2027  5609 22 DA 54     	LD (SHIFT04.M1), HL
2028  560C 22 EF 54     	LD (SHIFT04.M2), HL
2029  560F              .DO:
2030  560F DD 46 10     	LD B, (IX+16) ; rows
2031  5612 DD 6E 08     	LD L, (IX+8)
2032  5615 DD 66 09     	LD H, (IX+9) ; mask data
2033  5618 DD 5E 04     	LD E, (IX+4)
2034  561B DD 56 05     	LD D, (IX+5) ; background data
2035  561E D9           	EXX
2036  561F DD 6E 0A     	LD L, (IX+10)
2037  5622 DD 66 0B     	LD H, (IX+11) ; character data
2038  5625 D9           	EXX
2039  5626              .LOOP:
2040  5626 C5           	PUSH BC
2041  5627 E5           		PUSH HL
2042  5628 D5           			PUSH DE
2043  5629 D9           				EXX
2044  562A E5           				PUSH HL
2045  562B D9           					EXX
2046  562C DD 7E 0E     					LD A, (IX+14) ; columns
2047  562F              .CALL:
2048  562F CD 55 55     					CALL SHIFT_ROW
2049  5632 E1           				POP HL
2050  5633 DD 5E 0C     				LD E, (IX+12)
2051  5636 DD 56 0D     				LD D, (IX+13) ; char data to next row
2052  5639 19           				ADD HL, DE
2053  563A D9           				EXX
2054  563B E1           			POP HL
2055  563C DD 5E 06     			LD E, (IX+6)
2056  563F DD 56 07     			LD D, (IX+7) ; background to next row
2057  5642 19           			ADD HL, DE
2058  5643 EB           			EX DE, HL
2059  5644 E1           		POP HL
2060  5645 DD 4E 0C     		LD C, (IX+12)
2061  5648 DD 46 0D     		LD B, (IX+13) ; char data to next row
2062  564B 09           		ADD HL, BC
2063  564C C1           	POP BC
2064  564D 10 D7        	DJNZ .LOOP
2065  564F C9           	RET
2066  5650              ; *******************************************************************************************************
2067  5650
2068  5650              ; *******************************************************************************************************
2069  5650              ; function to handle CALL BLIT basic extension
2070  5650              ; rotates 1-bit character drawing horizontally with mask and character data and
2071  5650              ; fuses with background data and applies vertical shift too
2072  5650              ; BLIT ( INT request_data_ptr )
2073  5650              ; request_data_ptr described in SHIFT_MERGE_CHARACTER
2074  5650              ; will put ram in page 0 also, page 1 is already there
2075  5650              BLIT:
2076  5650              	; opening (
2077  5650 CD CC 4F     	CALL CHKCHAR
2078  5653 28           	DB '('
2079  5654              	; get pointer to request struct
2080  5654 DD 21 2F 54  	LD IX, FRMQNT
2081  5658 CD 59 01     	CALL CALBAS
2082  565B D5           	PUSH DE
2083  565C              	; ending )
2084  565C CD CC 4F     	CALL CHKCHAR
2085  565F 29           	DB ')'
2086  5660
2087  5660 DD E1        	POP IX ; pointer to request struct
2088  5662
2089  5662 E5           	PUSH HL ; save position in BASIC buffer
2090  5663
2091  5663 FD 21 6A 56  	LD IY, .RET
2092  5667 C3 CE 4E     	JP ENABLE_PAGE0
2093  566A              .RET:
2094  566A FB           	EI
2095  566B CD BC 55     	CALL SHIFT_MERGE_CHARACTER
2096  566E
2097  566E D1               POP DE
2098  566F C1               POP BC
2099  5670 CD 45 4E         CALL RESTORE_PAGE_INFO
2100  5673
2101  5673 E1           	POP HL
2102  5674 C9           	RET
2103  5675              ; *******************************************************************************************************
2104  5675
2105  5675              ; *******************************************************************************************************
2106  5675              ; generic function to implement tiling
2107  5675              ; should be modified to call appropriate function for memory or vram
2108  5675              ; input IX=pointer to following structure
2109  5675              ; +00 tile_data_ptr
2110  5675              ; +02 tile_rows
2111  5675              ; +04 tile_columns
2112  5675              ; +06 destination_address
2113  5675              ; +08 dest_to_next_row_add_to_value
2114  5675              ; +10 num_horizontal_tiles
2115  5675              ; +12 num_vertical_tiles
2116  5675              ; modifies AF, BC, DE, HL
2117  5675              TILE:
2118  5675 DD 6E 06     	LD L, (IX+6)
2119  5678 DD 66 07     	LD H, (IX+7) ; destination address
2120  567B 22 01 4D     	LD (TILETMP1), HL
2121  567E DD 46 0C     	LD B, (IX+12) ; vertical tile number
2122  5681              .L1:
2123  5681 C5           	PUSH BC
2124  5682 DD 6E 00     		LD L, (IX+0)
2125  5685 DD 66 01     		LD H, (IX+1) ; tile address
2126  5688 22 03 4D     		LD (TILETMP2), HL
2127  568B DD 46 02     		LD B, (IX+2) ; tile rows
2128  568E              .L2:
2129  568E C5           		PUSH BC
2130  568F              .CALL1:
2131  568F CD 00 00     			CALL 0
2132  5692 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
2133  5695              .L3:
2134  5695 C5           			PUSH BC
2135  5696 2A 03 4D     				LD HL, (TILETMP2)
2136  5699 DD 46 04     				LD B, (IX+4) ; tile columns
2137  569C              .L4:
2138  569C C5           				PUSH BC
2139  569D              .CALL2:
2140  569D CD 00 00     					CALL 0
2141  56A0 C1           				POP BC
2142  56A1 10 F9        				DJNZ .L4
2143  56A3 C1           			POP BC
2144  56A4 10 EF        			DJNZ .L3
2145  56A6 22 03 4D     			LD (TILETMP2), HL
2146  56A9 2A 01 4D     			LD HL, (TILETMP1)
2147  56AC DD 5E 08     			LD E, (IX+8)
2148  56AF DD 56 09     			LD D, (IX+9) ; add to value for dest next row
2149  56B2 19           			ADD HL, DE
2150  56B3 22 01 4D     			LD (TILETMP1), HL
2151  56B6 C1           		POP BC
2152  56B7 10 D5        		DJNZ .L2
2153  56B9 C1           	POP BC
2154  56BA 10 C5        	DJNZ .L1
2155  56BC C9           	RET
2156  56BD              ; *******************************************************************************************************
2157  56BD
2158  56BD              ; *******************************************************************************************************
2159  56BD              ; function to handle CALL TILERAM basic extension
2160  56BD              ; fills memory with tiles
2161  56BD              ; fuses with background data and applies vertical shift too
2162  56BD              ; TILERAM ( INT request_data_ptr )
2163  56BD              ; request_data_ptr described in TILE
2164  56BD              ; will put ram in page 0 also, page 1 is already there
2165  56BD              TILERAM:
2166  56BD              	; opening (
2167  56BD CD CC 4F     	CALL CHKCHAR
2168  56C0 28           	DB '('
2169  56C1              	; get pointer to request struct
2170  56C1 DD 21 2F 54  	LD IX, FRMQNT
2171  56C5 CD 59 01     	CALL CALBAS
2172  56C8 D5           	PUSH DE
2173  56C9              	; ending )
2174  56C9 CD CC 4F     	CALL CHKCHAR
2175  56CC 29           	DB ')'
2176  56CD
2177  56CD DD E1        	POP IX ; pointer to request struct
2178  56CF
2179  56CF E5           	PUSH HL ; save position in BASIC buffer
2180  56D0
2181  56D0 FD 21 D7 56  	LD IY, .RET
2182  56D4 C3 CE 4E     	JP ENABLE_PAGE0
2183  56D7              .RET:
2184  56D7 FB           	EI
2185  56D8              	; set RAM functions to call
2186  56D8 21 EE 56     	LD HL, .TILECOPY
2187  56DB 22 9E 56     	LD (TILE.CALL2+1), HL
2188  56DE 21 FF 56     	LD HL, .SETDESTROW
2189  56E1 22 90 56     	LD (TILE.CALL1+1), HL
2190  56E4 CD 75 56     	CALL TILE
2191  56E7
2192  56E7 D1               POP DE
2193  56E8 C1               POP BC
2194  56E9 CD 45 4E         CALL RESTORE_PAGE_INFO
2195  56EC
2196  56EC E1           	POP HL
2197  56ED C9           	RET
2198  56EE              .TILECOPY:
2199  56EE ED A0       > LDI
2199  56F0 ED A0       > LDI
2199  56F2 ED A0       > LDI
2199  56F4 ED A0       > LDI
2199  56F6 ED A0       > LDI
2199  56F8 ED A0       > LDI
2199  56FA ED A0       > LDI
2199  56FC ED A0       > LDI
2200  56FE C9           	RET
2201  56FF              .SETDESTROW:
2202  56FF ED 5B 01 4D  	LD DE, (TILETMP1)
2203  5703 C9           	RET
2204  5704              ; *******************************************************************************************************
2205  5704
2206  5704              ; *******************************************************************************************************
2207  5704              ; function to handle CALL TILEVRM basic extension
2208  5704              ; fills vram with tiles
2209  5704              ; fuses with background data and applies vertical shift too
2210  5704              ; TILEVRM ( INT request_data_ptr )
2211  5704              ; request_data_ptr described in TILE
2212  5704              ; will put ram in page 0 also, page 1 is already there
2213  5704              TILEVRM:
2214  5704              	; opening (
2215  5704 CD CC 4F     	CALL CHKCHAR
2216  5707 28           	DB '('
2217  5708              	; get pointer to request struct
2218  5708 DD 21 2F 54  	LD IX, FRMQNT
2219  570C CD 59 01     	CALL CALBAS
2220  570F D5           	PUSH DE
2221  5710              	; ending )
2222  5710 CD CC 4F     	CALL CHKCHAR
2223  5713 29           	DB ')'
2224  5714
2225  5714 DD E1        	POP IX ; pointer to request struct
2226  5716
2227  5716 E5           	PUSH HL ; save position in BASIC buffer
2228  5717
2229  5717 FD 21 1E 57  	LD IY, .RET
2230  571B C3 CE 4E     	JP ENABLE_PAGE0
2231  571E              .RET:
2232  571E FB           	EI
2233  571F              	; set RAM functions to call
2234  571F 21 35 57     	LD HL, .TILECOPY
2235  5722 22 9E 56     	LD (TILE.CALL2+1), HL
2236  5725 21 3B 57     	LD HL, .SETDESTROW
2237  5728 22 90 56     	LD (TILE.CALL1+1), HL
2238  572B CD 75 56     	CALL TILE
2239  572E
2240  572E D1               POP DE
2241  572F C1               POP BC
2242  5730 CD 45 4E         CALL RESTORE_PAGE_INFO
2243  5733
2244  5733 E1           	POP HL
2245  5734 C9           	RET
2246  5735              .TILECOPY:
2247  5735 01 98 08     	LD BC, #0898
2248  5738               IFNDEF EXCLUDE_VRAM_CMDS
2249  5738 C3 A1 51     	JP MEMVRM.BBYTECOPY
2250  573B               ELSE
2251  573B ~            .BBYTECOPY:
2252  573B ~            	OUTI
2253  573B ~            	JP	NZ, .BBYTECOPY
2254  573B ~            	RET
2255  573B               ENDIF
2256  573B              .SETDESTROW:
2257  573B 2A 01 4D     	LD HL, (TILETMP1)
2258  573E F3           	DI
2259  573F CD 03 4E     	CALL SETWRT_LOCAL
2260  5742 FB           	EI
2261  5743 C9           	RET
2262  5744              ; *******************************************************************************************************
2263  5744
2264  5744              ; *******************************************************************************************************
2265  5744              ; generic function to implement rectangle data copy
2266  5744              ; should be modified to call appropriate function for memory or vram
2267  5744              ; input IX=pointer to following structure
2268  5744              ; +00 source data pointer
2269  5744              ; +02 num bytes in a row
2270  5744              ; +04 number of rows
2271  5744              ; +06 source add-to value till next row
2272  5744              ; +08 destination address
2273  5744              ; +10 destination add-to value till next row
2274  5744              ; modifies AF, BC, DE, HL
2275  5744              RECTANGLE_COPY:
2276  5744 DD 6E 00     	LD L, (IX+0)
2277  5747 DD 66 01     	LD H, (IX+1) ; source address
2278  574A DD 5E 08     	LD E, (IX+8)
2279  574D DD 56 09     	LD D, (IX+9) ; destination
2280  5750 DD 46 04     	LD B, (IX+4) ; row number
2281  5753              .L1:
2282  5753 C5           	PUSH BC
2283  5754 E5           		PUSH HL
2284  5755 D5           			PUSH DE
2285  5756 DD 4E 02     				LD C, (IX+2)
2286  5759 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2287  575C              .CALL1:
2288  575C CD 00 00     				CALL 0 ; set destination address from DE
2289  575F              .CALL2:
2290  575F CD 00 00     				CALL 0 ; copy data fn
2291  5762 E1           			POP HL
2292  5763 DD 4E 0A     			LD C, (IX+10)
2293  5766 DD 46 0B     			LD B, (IX+11) ; destination add-to
2294  5769 09           			ADD HL, BC
2295  576A EB           			EX DE, HL
2296  576B E1           		POP HL
2297  576C DD 4E 06     		LD C, (IX+6)
2298  576F DD 46 07     		LD B, (IX+7) ; src add-to
2299  5772 09           		ADD HL, BC
2300  5773 C1           	POP BC
2301  5774 10 DD        	DJNZ .L1
2302  5776 C9           	RET
2303  5777              ; *******************************************************************************************************
2304  5777
2305  5777              ; *******************************************************************************************************
2306  5777              ; function to handle CALL BOXMEMCPY basic extension
2307  5777              ; copies data with window like boundaries to ram
2308  5777              ; BOXMEMCPY ( INT request_data_ptr )
2309  5777              ; request_data_ptr described in RECTANGLE_COPY
2310  5777              ; will put ram in page 0 also, page 1 is already there
2311  5777              BOXMEMCPY:
2312  5777              	; opening (
2313  5777 CD CC 4F     	CALL CHKCHAR
2314  577A 28           	DB '('
2315  577B              	; get pointer to request struct
2316  577B DD 21 2F 54  	LD IX, FRMQNT
2317  577F CD 59 01     	CALL CALBAS
2318  5782 D5           	PUSH DE
2319  5783              	; ending )
2320  5783 CD CC 4F     	CALL CHKCHAR
2321  5786 29           	DB ')'
2322  5787
2323  5787 DD E1        	POP IX ; pointer to request struct
2324  5789
2325  5789 E5           	PUSH HL ; save position in BASIC buffer
2326  578A
2327  578A FD 21 91 57  	LD IY, .RET
2328  578E C3 CE 4E     	JP ENABLE_PAGE0
2329  5791              .RET:
2330  5791 FB           	EI
2331  5792              	; set RAM functions to call
2332  5792 21 00 00     	LD HL, 0
2333  5795 22 5C 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2334  5798 22 5E 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2335  579B 21 ED B0     	LD HL, #B0ED ; LDIR
2336  579E 22 60 57     	LD (RECTANGLE_COPY.CALL1+4), HL
2337  57A1 CD 44 57     	CALL RECTANGLE_COPY
2338  57A4
2339  57A4 D1               POP DE
2340  57A5 C1               POP BC
2341  57A6 CD 45 4E         CALL RESTORE_PAGE_INFO
2342  57A9
2343  57A9 E1           	POP HL
2344  57AA C9           	RET
2345  57AB              ; *******************************************************************************************************
2346  57AB
2347  57AB              ; *******************************************************************************************************
2348  57AB              ; function to handle CALL BOXMEMVRM basic extension
2349  57AB              ; copies data with window like boundaries to ram
2350  57AB              ; BOXMEMVRM ( INT request_data_ptr )
2351  57AB              ; request_data_ptr described in RECTANGLE_COPY
2352  57AB              ; will put ram in page 0 also, page 1 is already there
2353  57AB              BOXMEMVRM:
2354  57AB              	; opening (
2355  57AB CD CC 4F     	CALL CHKCHAR
2356  57AE 28           	DB '('
2357  57AF              	; get pointer to request struct
2358  57AF DD 21 2F 54  	LD IX, FRMQNT
2359  57B3 CD 59 01     	CALL CALBAS
2360  57B6 D5           	PUSH DE
2361  57B7              	; ending )
2362  57B7 CD CC 4F     	CALL CHKCHAR
2363  57BA 29           	DB ')'
2364  57BB
2365  57BB DD E1        	POP IX ; pointer to request struct
2366  57BD
2367  57BD E5           	PUSH HL ; save position in BASIC buffer
2368  57BE
2369  57BE FD 21 C5 57  	LD IY, .RET
2370  57C2 C3 CE 4E     	JP ENABLE_PAGE0
2371  57C5              .RET:
2372  57C5 FB           	EI
2373  57C6              	; set RAM functions to call
2374  57C6 21 E4 57     	LD HL, .SETDEST
2375  57C9 22 5D 57     	LD (RECTANGLE_COPY.CALL1+1), HL
2376  57CC 21 EC 57     	LD HL, .COPYDATA
2377  57CF 22 60 57     	LD (RECTANGLE_COPY.CALL2+1), HL
2378  57D2 3E CD        	LD A, #CD ; CALL
2379  57D4 32 5C 57     	LD (RECTANGLE_COPY.CALL1), A
2380  57D7 32 5F 57     	LD (RECTANGLE_COPY.CALL2), A
2381  57DA CD 44 57     	CALL RECTANGLE_COPY
2382  57DD
2383  57DD D1               POP DE
2384  57DE C1               POP BC
2385  57DF CD 45 4E         CALL RESTORE_PAGE_INFO
2386  57E2
2387  57E2 E1           	POP HL
2388  57E3 C9           	RET
2389  57E4              .SETDEST:
2390  57E4 EB           	EX DE, HL
2391  57E5 F3           	DI
2392  57E6 CD 03 4E     	CALL SETWRT_LOCAL
2393  57E9 FB           	EI
2394  57EA EB           	EX DE, HL
2395  57EB C9           	RET
2396  57EC              .COPYDATA:
2397  57EC 41           	LD B, C
2398  57ED 0E 98        	LD C, #98
2399  57EF               IFNDEF EXCLUDE_VRAM_CMDS
2400  57EF C3 A1 51     	JP MEMVRM.BBYTECOPY
2401  57F2               ELSE
2402  57F2 ~            	JP TILEVRM.BBYTECOPY
2403  57F2               ENDIF
2404  57F2              ; *******************************************************************************************************
2405  57F2               ENDIF
2406  57F2
2407  57F2              EXT_END:
2408  57F2
# file closed: asm\main.asm
