# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; DEFINE EXCLUDE_SOUND_PLAYER
   4  4000              ; DEFINE EXCLUDE_RAM_CMDS
   5  4000              ; DEFINE EXCLUDE_VRAM_CMDS
   6  4000              ; DEFINE EXCLUDE_BLIT_CMDS
   7  4000              ; DEFINE EXCLUDE_SPRITE_CMDS
   8  4000              ; DEFINE EXCLUDE_GENCAL
   9  4000
  10  4000               DEFINE BLIT_WITH_STRUCT_POINTER
  11  4000
  12  4000              CHPUT   EQU     #A2
  13  4000              CALBAS	EQU		#159
  14  4000              ERRHAND EQU     #406F
  15  4000              FRMEVL  EQU     #4C64
  16  4000              FRESTR	EQU		#67D0
  17  4000              ; FRMQNT = formula quantificator
  18  4000              ; input HL=pointer to current program expression
  19  4000              ; output HL=next address
  20  4000              ; output DE=integer datum
  21  4000              FRMQNT	EQU		#542F
  22  4000              ; GETBYT = get byte parameter
  23  4000              ; input HL=pointer to current program expression
  24  4000              ; output HL=next address
  25  4000              ; output A=E=byte read
  26  4000              GETBYT	EQU		#521C
  27  4000              CHRGTR  EQU     #4666
  28  4000              SYNCHR	EQU		#558C
  29  4000              VALTYP  EQU     #F663
  30  4000              USR     EQU     #F7F8
  31  4000              PROCNM	EQU		#FD89
  32  4000              BIOS_FILVRM  EQU     #56
  33  4000              CLIKSW	EQU		#F3DB
  34  4000              ATRBAS	EQU		#F928
  35  4000
  36  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  37  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  38  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  39  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  40  4000              EXPTBL	EQU #FCC1
  41  4000              SCRMOD	EQU #FCAF ; current screen mode
  42  4000              REG1SAV EQU #F3E0 ; VDP(1)
  43  4000
  44  4000              ; BASIC error codes
  45  4000              ;01 NEXT without FOR
  46  4000              ;02 Syntax error
  47  4000              ;03 RETURN without GOSUB
  48  4000              ;04 Out of DATA
  49  4000              ;05 Illegal function call
  50  4000              ;06 Overflow
  51  4000              ;07 Out of memory
  52  4000              ;08 Undefined line number
  53  4000              ;09 Subscript out of range
  54  4000              ;10 Redimensioned array
  55  4000              ;11 Division by zero
  56  4000              ;12 Illegal direct
  57  4000              ;13 Type mismatch
  58  4000              ;14 Out of string space
  59  4000              ;15 String too long
  60  4000              ;16 String formula too complex
  61  4000              ;17 Can't CONTINUE
  62  4000              ;18 Undefined user function
  63  4000              ;19 Device I/O error
  64  4000              ;20 Verify error
  65  4000              ;21 No RESUME
  66  4000              ;22 RESUME without error
  67  4000              ;23 Unprintable error
  68  4000              ;24 Missing operand
  69  4000              ;25 Line buffer overflow
  70  4000              ;50 FIELD overflow
  71  4000              ;51 Internal error
  72  4000              ;52 Bad file number
  73  4000              ;53 File not found
  74  4000              ;54 File already open
  75  4000              ;55 Input past end
  76  4000              ;56 Bad file name
  77  4000              ;57 Direct statement in file
  78  4000              ;58 Sequential I/O only
  79  4000              ;59 File not OPEN
  80  4000
  81  4000
  82  4000               ; simulate cartridge with BASIC extension
  83  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  83  4004 96 4F 00 00
  83  4008 00 00 00 00
  83  400C 00 00 00 00
  84  4010
  85  4010              ; this location #4010 stores last location used by basic extension
  86  4010              ; free memory after that point
  87  4010 F9 57         DW EXT_END
  88  4012
  89  4012              ; this location #4012 stores extension version in DAA format
  90  4012              ; first byte is major version and second minor
  91  4012 00 70         DB #00, #70
  92  4014
  93  4014              ; binary included AKG player compiled at #4014
  94  4014               IFNDEF EXCLUDE_SOUND_PLAYER
  95  4014              	INCBIN "bin/AKG.bin"
  96  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
  97  4CF0               ENDIF
  98  4CF0
  99  4CF0              ORIG.HTIMI:
 100  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 100  4CF4 00
 101  4CF5               EXPORT ORIG.HTIMI
 102  4CF5
 103  4CF5               IFNDEF EXCLUDE_SOUND_PLAYER
 104  4CF5              MUSIC_INIT_STATUS:
 105  4CF5 00            DB 0
 106  4CF6              SFX_INIT_STATUS:
 107  4CF6 00            DB 0
 108  4CF7              SOUND_ENABLED:
 109  4CF7 00            DB 0
 110  4CF8               ENDIF
 111  4CF8
 112  4CF8               IFNDEF EXCLUDE_SPRITE_CMDS
 113  4CF8              SPRATR_INIT_STATUS:
 114  4CF8 00            DB 0
 115  4CF9              SPRATR_UPDATE_FLAG:
 116  4CF9 00 00         DW 0
 117  4CFB              SPRATR_DATA:
 118  4CFB 00 00         DW 0
 119  4CFD              SPRFLICKER_ENABLED:
 120  4CFD 00            DB 0
 121  4CFE              ; to support sprite flicker
 122  4CFE              FLICKER:
 123  4CFE 00            DB 0
 124  4CFF               ENDIF
 125  4CFF
 126  4CFF              ; to temporarily store stack pointer
 127  4CFF              TMPSP:
 128  4CFF 00 00         DW 0
 129  4D01
 130  4D01              ; temp variables for BLIT, TILE functions
 131  4D01               IFNDEF EXCLUDE_BLIT_CMDS
 132  4D01              TILETMP1:
 133  4D01              BLIT_TMP1:
 134  4D01 00 00         DW 0
 135  4D03              TILETMP2:
 136  4D03              BLIT_TMP2:
 137  4D03 00 00         DW 0
 138  4D05               ENDIF
 139  4D05
 140  4D05              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 141  4D05              ; per starting letter, if no commands with this letter, NULL value
 142  4D05              CMDS:
 143  4D05 00 00            DW 0 ; A
 144  4D07 CE 4D            DW CMDS_B ; B
 145  4D09 00 00            DW 0 ; C
 146  4D0B 00 00            DW 0 ; D
 147  4D0D 00 00            DW 0 ; E
 148  4D0F 4C 4D            DW CMDS_F; F
 149  4D11 5F 4D            DW CMDS_G; G
 150  4D13 00 00            DW 0 ; H
 151  4D15 00 00            DW 0 ; I
 152  4D17 00 00            DW 0 ; J
 153  4D19 00 00            DW 0 ; K
 154  4D1B 00 00            DW 0 ; L
 155  4D1D 39 4D            DW CMDS_M ; M
 156  4D1F 00 00            DW 0 ; N
 157  4D21 00 00            DW 0 ; O
 158  4D23 00 00            DW 0 ; P
 159  4D25 00 00            DW 0 ; Q
 160  4D27 00 00            DW 0 ; R
 161  4D29 73 4D            DW CMDS_S ; S
 162  4D2B EE 4D            DW CMDS_T ; T
 163  4D2D 00 00            DW 0 ; U
 164  4D2F 69 4D            DW CMDS_V ; V
 165  4D31 00 00            DW 0 ; W
 166  4D33 00 00            DW 0 ; X
 167  4D35 00 00            DW 0 ; Y
 168  4D37 00 00            DW 0 ; Z
 169  4D39
 170  4D39              CMDS_M:
 171  4D39               IFNDEF EXCLUDE_VRAM_CMDS
 172  4D39 4D 45 4D 56      DB "MEMVRM", 0
 172  4D3D 52 4D 00
 173  4D40 33 51            DW MEMVRM
 174  4D42               ENDIF
 175  4D42               IFNDEF EXCLUDE_RAM_CMDS
 176  4D42 4D 45 4D 43  	DB "MEMCPY", 0
 176  4D46 50 59 00
 177  4D49 F2 4F        	DW MEMCPY
 178  4D4B               ENDIF
 179  4D4B 00           	DB 0
 180  4D4C              CMDS_F:
 181  4D4C               IFNDEF EXCLUDE_VRAM_CMDS
 182  4D4C 46 49 4C 56      DB "FILVRM", 0
 182  4D50 52 4D 00
 183  4D53 35 50            DW FILVRM
 184  4D55               ENDIF
 185  4D55               IFNDEF EXCLUDE_RAM_CMDS
 186  4D55 46 49 4C 52      DB "FILRAM", 0
 186  4D59 41 4D 00
 187  4D5C 7C 50            DW FILRAM
 188  4D5E               ENDIF
 189  4D5E 00               DB 0
 190  4D5F              CMDS_G:
 191  4D5F               IFNDEF EXCLUDE_GENCAL
 192  4D5F 47 45 4E 43      DB "GENCAL", 0
 192  4D63 41 4C 00
 193  4D66 DA 50            DW GENCAL
 194  4D68               ENDIF
 195  4D68 00           	DB	0
 196  4D69              CMDS_V:
 197  4D69               IFNDEF EXCLUDE_VRAM_CMDS
 198  4D69 56 52 4D 4D  	DB "VRMMEM", 0
 198  4D6D 45 4D 00
 199  4D70 AE 51        	DW VRMMEM
 200  4D72               ENDIF
 201  4D72 00           	DB 0
 202  4D73              CMDS_S:
 203  4D73               IFNDEF EXCLUDE_SPRITE_CMDS
 204  4D73 53 50 52 53  	DB "SPRSET", 0
 204  4D77 45 54 00
 205  4D7A 9B 53        	DW SPRSET
 206  4D7C 53 50 52 47  	DB "SPRGRPMOV", 0
 206  4D80 52 50 4D 4F
 206  4D84 56 00
 207  4D86 59 54        	DW SPRGRPMOV
 208  4D88               ENDIF
 209  4D88               IFNDEF EXCLUDE_SOUND_PLAYER
 210  4D88 53 4E 44 53  	DB "SNDSFX", 0
 210  4D8C 46 58 00
 211  4D8F EC 52        	DW SNDSFX
 212  4D91 53 4E 44 50  	DB "SNDPLYON", 0
 212  4D95 4C 59 4F 4E
 212  4D99 00
 213  4D9A B6 52        	DW SNDPLYON
 214  4D9C 53 4E 44 50  	DB "SNDPLYOFF", 0
 214  4DA0 4C 59 4F 46
 214  4DA4 46 00
 215  4DA6 C9 52        	DW SNDPLYOFF
 216  4DA8 53 4E 44 50  	DB "SNDPLYINI", 0
 216  4DAC 4C 59 49 4E
 216  4DB0 49 00
 217  4DB2 6C 52        	DW SNDPLYINIT
 218  4DB4               ENDIF
 219  4DB4               IFNDEF EXCLUDE_SPRITE_CMDS
 220  4DB4 53 50 52 45  	DB "SPRENABLE", 0
 220  4DB8 4E 41 42 4C
 220  4DBC 45 00
 221  4DBE 46 53        	DW SPRENABLE
 222  4DC0 53 50 52 44  	DB "SPRDISABLE", 0
 222  4DC4 49 53 41 42
 222  4DC8 4C 45 00
 223  4DCB 96 53        	DW SPRDISABLE
 224  4DCD               ENDIF
 225  4DCD 00           	DB 0
 226  4DCE              CMDS_B:
 227  4DCE               IFNDEF EXCLUDE_BLIT_CMDS
 228  4DCE 42 4C 49 54  	DB "BLIT", 0
 228  4DD2 00
 229  4DD3 57 56        	DW BLIT
 230  4DD5 42 4F 58 4D  	DB "BOXMEMCPY", 0
 230  4DD9 45 4D 43 50
 230  4DDD 59 00
 231  4DDF 7E 57        	DW BOXMEMCPY
 232  4DE1 42 4F 58 4D  	DB "BOXMEMVRM", 0
 232  4DE5 45 4D 56 52
 232  4DE9 4D 00
 233  4DEB B2 57        	DW BOXMEMVRM
 234  4DED               ENDIF
 235  4DED 00           	DB 0
 236  4DEE              CMDS_T:
 237  4DEE               IFNDEF EXCLUDE_BLIT_CMDS
 238  4DEE 54 49 4C 45  	DB "TILERAM", 0
 238  4DF2 52 41 4D 00
 239  4DF6 C4 56        	DW TILERAM
 240  4DF8 54 49 4C 45  	DB "TILEVRM", 0
 240  4DFC 56 52 4D 00
 241  4E00 0B 57        	DW TILEVRM
 242  4E02               ENDIF
 243  4E02 00           	DB 0
 244  4E03
 245  4E03              ; ****************************************************************************************************
 246  4E03              ; function sets VRAM address
 247  4E03              ; input HL=address
 248  4E03              ; modifies AF
 249  4E03              SETWRT_LOCAL:
 250  4E03 7D           	LD	A, L
 251  4E04 D3 99        	OUT	(099H), A
 252  4E06 7C           	LD	A, H
 253  4E07 E6 3F        	AND	03FH
 254  4E09 F6 40        	OR	040H
 255  4E0B D3 99        	OUT	(099H), A
 256  4E0D C9           	RET
 257  4E0E              ; ****************************************************************************************************
 258  4E0E
 259  4E0E              ; ****************************************************************************************************
 260  4E0E              ; function gets slot and subslot data for specific page
 261  4E0E              ; input A=page (0, 1 or 2)
 262  4E0E              ; output B = 0A8H register value
 263  4E0E              ; output D = 0 is no subslots, 1 if yes
 264  4E0E              ; output C = 0A8H value when page 3 slot equals to requested page slot
 265  4E0E              ; output E = subslot value if present
 266  4E0E              ; modifies AF, BC, DE, HL
 267  4E0E              GET_PAGE_INFO:
 268  4E0E 6F               LD L, A
 269  4E0F C6 C1            ADD A, low (EXPTBL)
 270  4E11 32 1B 4E         LD (GET_PAGE_INFO_L1+1), A
 271  4E14 DB A8            IN A, (0A8H)
 272  4E16 47               LD B, A
 273  4E17 E6 3F            AND 03FH
 274  4E19 4F               LD C, A
 275  4E1A              GET_PAGE_INFO_L1:
 276  4E1A 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 277  4E1D E6 80            AND 080H
 278  4E1F 28 1B            JR Z, GET_PAGE_INFO_L2
 279  4E21                  ; expanded
 280  4E21 2D               DEC L
 281  4E22 FA 41 4E         JP M, GET_PAGE_INFO_L3
 282  4E25 2D               DEC L
 283  4E26 FA 3F 4E         JP M, GET_PAGE_INFO_L4
 284  4E29                  ; page 2
 285  4E29 07               RLCA
 286  4E2A 07               RLCA
 287  4E2B              GET_PAGE_INFO_L5:
 288  4E2B E6 C0            AND 0C0H
 289  4E2D B1               OR C
 290  4E2E D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 291  4E30 4F               LD C, A
 292  4E31 3A FF FF         LD A, (0FFFFH)
 293  4E34 2F               CPL
 294  4E35 5F               LD E, A
 295  4E36 16 01            LD D, 1
 296  4E38 78               LD A, B ; return stack
 297  4E39 D3 A8            OUT (0A8H), A
 298  4E3B C9               RET
 299  4E3C              GET_PAGE_INFO_L2:
 300  4E3C                  ; not expanded
 301  4E3C 16 00            LD D, 0
 302  4E3E C9               RET
 303  4E3F              GET_PAGE_INFO_L4:
 304  4E3F                  ; page 1
 305  4E3F 0F               RRCA
 306  4E40 0F               RRCA
 307  4E41              GET_PAGE_INFO_L3:
 308  4E41                  ; page 0
 309  4E41 0F               RRCA
 310  4E42 0F               RRCA
 311  4E43 18 E6            JR GET_PAGE_INFO_L5
 312  4E45              ; ****************************************************************************************************
 313  4E45
 314  4E45              ; ****************************************************************************************************
 315  4E45              ; function returns original slot and subslot info
 316  4E45              ; input B = 0A8H register value
 317  4E45              ; input D = 0 is no subslots, 1 if yes
 318  4E45              ; input C = 0A8H value when page 3 slot equals to requested page slot
 319  4E45              ; input E = subslot value if present
 320  4E45              ; modifies AF, disables interrupts
 321  4E45              RESTORE_PAGE_INFO:
 322  4E45 7A               LD A, D
 323  4E46 B7               OR A
 324  4E47 28 08            JR Z, RESTORE_PAGE_INFO_L1
 325  4E49 79               LD A, C
 326  4E4A F3           	DI
 327  4E4B D3 A8            OUT (0A8H), A
 328  4E4D 7B               LD A, E
 329  4E4E 32 FF FF         LD (0FFFFH), A
 330  4E51              RESTORE_PAGE_INFO_L1:
 331  4E51 78               LD A, B
 332  4E52 D3 A8            OUT (0A8H), A
 333  4E54 C9               RET
 334  4E55              ; ****************************************************************************************************
 335  4E55
 336  4E55              ; *******************************************************************************************************
 337  4E55              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 338  4E55              ; INPUT:  A = SLOT ID: EXXXSSPP
 339  4E55              ; E = EXPANDED FLAG
 340  4E55              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 341  4E55              ; PP = PRIMARY SLOT NUMBER
 342  4E55              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 343  4E55              ; CHANGES: AF, BC, DE
 344  4E55
 345  4E55              LOCAL_ENASLT:
 346  4E55 CD 75 4E         CALL L0353
 347  4E58 FA 62 4E         JP M, L0340
 348  4E5B DB A8            IN A, (0A8H)
 349  4E5D A1               AND C
 350  4E5E B0               OR B
 351  4E5F D3 A8            OUT (0A8H), A
 352  4E61 C9               RET
 353  4E62              L0340:
 354  4E62 E5               PUSH HL
 355  4E63 CD 9A 4E         CALL L0378
 356  4E66 4F               LD C, A
 357  4E67 06 00            LD B, 0
 358  4E69 7D               LD A, L
 359  4E6A A4               AND H
 360  4E6B B2               OR D
 361  4E6C 21 C5 FC         LD HL, 0FCC5H
 362  4E6F 09               ADD HL, BC
 363  4E70 77               LD (HL), A
 364  4E71 E1               POP HL
 365  4E72 79               LD A, C
 366  4E73 18 E0            JR LOCAL_ENASLT
 367  4E75              L0353:
 368  4E75 F3               DI
 369  4E76 F5               PUSH AF
 370  4E77 7C               LD A, H
 371  4E78 07               RLCA
 372  4E79 07               RLCA
 373  4E7A E6 03            AND 3
 374  4E7C 5F               LD E, A
 375  4E7D 3E C0            LD A, 0C0H
 376  4E7F              L035D:
 377  4E7F 07               RLCA
 378  4E80 07               RLCA
 379  4E81 1D               DEC E
 380  4E82 F2 7F 4E         JP P, L035D
 381  4E85 5F               LD E, A
 382  4E86 2F               CPL
 383  4E87 4F               LD C, A
 384  4E88 F1               POP AF
 385  4E89 F5               PUSH AF
 386  4E8A E6 03            AND 3
 387  4E8C 3C               INC A
 388  4E8D 47               LD B, A
 389  4E8E 3E AB            LD A, 0ABH
 390  4E90              L036E:
 391  4E90 C6 55            ADD A, 055H
 392  4E92 10 FC            DJNZ L036E
 393  4E94 57               LD D, A
 394  4E95 A3               AND E
 395  4E96 47               LD B, A
 396  4E97 F1               POP AF
 397  4E98 A7               AND A
 398  4E99 C9               RET
 399  4E9A              L0378:
 400  4E9A F5               PUSH AF
 401  4E9B 7A               LD A, D
 402  4E9C E6 C0            AND 0C0H
 403  4E9E 4F               LD C, A
 404  4E9F F1               POP AF
 405  4EA0 F5               PUSH AF
 406  4EA1 57               LD D, A
 407  4EA2 DB A8            IN A, (0A8H)
 408  4EA4 47               LD B, A
 409  4EA5 E6 3F            AND 03FH
 410  4EA7 B1               OR C
 411  4EA8 D3 A8            OUT (0A8H), A
 412  4EAA 7A               LD A, D
 413  4EAB 0F               RRCA
 414  4EAC 0F               RRCA
 415  4EAD E6 03            AND 3
 416  4EAF 57               LD D, A
 417  4EB0 3E AB            LD A, 0ABH
 418  4EB2              L0390:
 419  4EB2 C6 55            ADD A, 055H
 420  4EB4 15               DEC D
 421  4EB5 F2 B2 4E         JP P, L0390
 422  4EB8 A3               AND E
 423  4EB9 57               LD D, A
 424  4EBA 7B               LD A, E
 425  4EBB 2F               CPL
 426  4EBC 67               LD H, A
 427  4EBD 3A FF FF         LD A, (0FFFFH)
 428  4EC0 2F               CPL
 429  4EC1 6F               LD L, A
 430  4EC2 A4               AND H
 431  4EC3 B2               OR D
 432  4EC4 32 FF FF         LD (0FFFFH), A
 433  4EC7 78               LD A, B
 434  4EC8 D3 A8            OUT (0A8H), A
 435  4ECA F1               POP AF
 436  4ECB E6 03            AND 3
 437  4ECD C9               RET
 438  4ECE              ; *******************************************************************************************************
 439  4ECE
 440  4ECE              ; *******************************************************************************************************
 441  4ECE              ; some common code to activate page 0 and place values needed to restore original page on stack
 442  4ECE              ; input IY=return address
 443  4ECE              ENABLE_PAGE0:
 444  4ECE AF               XOR A
 445  4ECF CD 0E 4E         CALL GET_PAGE_INFO
 446  4ED2 C5               PUSH BC
 447  4ED3 D5               PUSH DE
 448  4ED4 3A 41 F3         LD A, (RAMAD0)
 449  4ED7 26 00            LD H, 0
 450  4ED9 CD 55 4E         CALL LOCAL_ENASLT
 451  4EDC FD E9        	JP (IY)
 452  4EDE              ; *******************************************************************************************************
 453  4EDE
 454  4EDE               IFNDEF EXCLUDE_SPRITE_CMDS
 455  4EDE              ; *******************************************************************************************************
 456  4EDE              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 457  4EDE              ; struct {
 458  4EDE              ; DW y
 459  4EDE              ; DW x
 460  4EDE              ; DW pattern (0-63)
 461  4EDE              ; DW color
 462  4EDE              ; } [32]
 463  4EDE              ; will hide sprites whose location is outside of visible area
 464  4EDE              ; works in screen 1 and 2
 465  4EDE              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 466  4EDE              ; modifies AF, AF', BC, DE, HL
 467  4EDE              SPRATR_UPDATE:
 468  4EDE              	; check if initialized
 469  4EDE 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 470  4EE1 B7           	OR A
 471  4EE2 C8           	RET Z
 472  4EE3              	; check if update requested
 473  4EE3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 474  4EE6 7E           	LD A, (HL)
 475  4EE7 B7           	OR A
 476  4EE8 C8           	RET Z
 477  4EE9              	; check screen mode
 478  4EE9 3A AF FC     	LD A, (SCRMOD)
 479  4EEC 3D           	DEC A
 480  4EED 28 02        	JR Z, .L0 ; screen 1
 481  4EEF 3D           	DEC A
 482  4EF0 C0           	RET NZ ; not screen 2
 483  4EF1              .L0:
 484  4EF1 06 20        	LD B, 32 ; sprite number
 485  4EF3 0E 98        	LD C, #98 ; register for vdp data output
 486  4EF5              	; set VDP address
 487  4EF5 2A 28 F9     	LD HL, (ATRBAS)
 488  4EF8 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
 489  4EFB B7           	OR A
 490  4EFC 28 03        	JR Z, .L3
 491  4EFE 3A FE 4C     	LD A, (FLICKER)
 492  4F01              .L3:
 493  4F01 5F           	LD E, A
 494  4F02 08           	EX AF, AF'
 495  4F03 7B           	LD A, E
 496  4F04 87           	ADD A, A
 497  4F05 87           	ADD A, A
 498  4F06 16 00        	LD D, 0
 499  4F08 5F           	LD E, A
 500  4F09 19           	ADD HL, DE
 501  4F0A CD 03 4E     	CALL SETWRT_LOCAL
 502  4F0D ED 73 FF 4C  	LD (TMPSP), SP
 503  4F11 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
 504  4F15
 505  4F15              .LOOP:
 506  4F15 E1           	POP HL
 507  4F16 24           	INC H
 508  4F17 28 0D        	JR Z, .L1 ; negative number above -256
 509  4F19 25           	DEC H
 510  4F1A 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 511  4F1C 7D           	LD A, L
 512  4F1D FE C0        	CP 192
 513  4F1F 30 10        	JR NC, .OUT3
 514  4F21 3D           	DEC A ; due to VDP rule that top of screen is -1
 515  4F22 57           	LD D, A
 516  4F23 C3 41 4F     	JP .X
 517  4F26              .L1:
 518  4F26 7D           	LD A, L
 519  4F27 C6 10        	ADD 16
 520  4F29 FA 31 4F     	JP M, .OUT3 ; below -16
 521  4F2C 2D           	DEC L ; due to VDP rule that top of screen is -1
 522  4F2D 55           	LD D, L
 523  4F2E C3 41 4F     	JP .X
 524  4F31              .OUT3:
 525  4F31 E1           	POP HL ; skip x value
 526  4F32              .OUT2:
 527  4F32 E1           	POP HL ; skip pattern
 528  4F33 E1           	POP HL ; skip color
 529  4F34 3E D1        	LD A, #D1
 530  4F36 D3 98        	OUT (#98), A ; sprite hidden
 531  4F38 D3 98        	OUT (#98), A ; value unimportant
 532  4F3A D3 98        	OUT (#98), A ; value unimportant
 533  4F3C D3 98        	OUT (#98), A ; value unimportant
 534  4F3E C3 6C 4F     	JP .NEXT
 535  4F41              .X:
 536  4F41 E1           	POP HL
 537  4F42 24           	INC H
 538  4F43 28 08        	JR Z, .L2
 539  4F45 25           	DEC H
 540  4F46 20 EA        	JR NZ, .OUT2
 541  4F48 1E 00        	LD E, 0 ; EC bit
 542  4F4A C3 56 4F     	JP .XY
 543  4F4D              .L2:
 544  4F4D 7D           	LD A, L
 545  4F4E C6 20        	ADD 32
 546  4F50 FA 32 4F     	JP M, .OUT2
 547  4F53 6F           	LD L, A
 548  4F54 1E 80        	LD E, #80
 549  4F56              .XY:
 550  4F56 ED 51        	OUT (C), D
 551  4F58 ED 69        	OUT (C), L
 552  4F5A E1           	POP HL ; pattern
 553  4F5B 3A E0 F3     	LD A, (REG1SAV)
 554  4F5E E6 02        	AND 2
 555  4F60 7D           	LD A, L
 556  4F61 28 02        	JR Z, .SMALLSPRITES
 557  4F63 87           	ADD A, A
 558  4F64 87           	ADD A, A ; needs to go at 4x
 559  4F65              .SMALLSPRITES:
 560  4F65 D3 98        	OUT (#98), A
 561  4F67 E1           	POP HL ; color
 562  4F68 7D           	LD A, L
 563  4F69 B3           	OR E
 564  4F6A D3 98        	OUT (#98), A
 565  4F6C              .NEXT:
 566  4F6C 08           	EX AF, AF'
 567  4F6D 3C           	INC A
 568  4F6E E6 1F        	AND 31
 569  4F70 C2 84 4F     	JP NZ, .NEXT2
 570  4F73 08           	EX AF, AF'
 571  4F74 2A 28 F9     	LD HL, (ATRBAS)
 572  4F77              	; CALL SETWRT_LOCAL not allowed as SP modified
 573  4F77 7D           	LD	A, L
 574  4F78 D3 99        	OUT	(099H), A
 575  4F7A 7C           	LD	A, H
 576  4F7B E6 3F        	AND	03FH
 577  4F7D F6 40        	OR	040H
 578  4F7F D3 99        	OUT	(099H), A
 579  4F81 C3 85 4F     	JP .NEXT3
 580  4F84              .NEXT2:
 581  4F84 08           	EX AF, AF'
 582  4F85              .NEXT3:
 583  4F85 10 8E        	DJNZ .LOOP
 584  4F87 08           	EX AF, AF'
 585  4F88 3C           	INC A
 586  4F89 32 FE 4C     	LD (FLICKER), A
 587  4F8C
 588  4F8C ED 7B FF 4C  	LD SP, (TMPSP)
 589  4F90 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 590  4F93 36 00        	LD (HL), 0 ; zero out update flag
 591  4F95 C9           	RET
 592  4F96              ; *******************************************************************************************************
 593  4F96               ENDIF
 594  4F96
 595  4F96              ; General BASIC CALL-instruction handler
 596  4F96              CALLHAND:
 597  4F96 E5           	PUSH HL
 598  4F97 21 05 4D     	LD	HL, CMDS ; pointer table based on starting letter
 599  4F9A 3A 89 FD         LD A, (PROCNM)
 600  4F9D D6 41            SUB 'A'
 601  4F9F 87               ADD A, A
 602  4FA0 16 00            LD D, 0
 603  4FA2 5F               LD E, A
 604  4FA3 19               ADD HL, DE
 605  4FA4 5E               LD E, (HL)
 606  4FA5 23               INC HL
 607  4FA6 56               LD D, (HL)
 608  4FA7 7A               LD A, D
 609  4FA8 B3               OR E
 610  4FA9 28 24            JR Z, .CMDNOTRECOGNIZED
 611  4FAB EB               EX DE, HL
 612  4FAC              .CHKCMD:
 613  4FAC 11 89 FD     	LD	DE, PROCNM
 614  4FAF 1A           .LOOP:	LD	A,(DE)
 615  4FB0 BE           	CP	(HL)
 616  4FB1 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 617  4FB3 13           	INC	DE
 618  4FB4 23           	INC	HL
 619  4FB5 A7           	AND	A
 620  4FB6 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 621  4FB8 5E           	LD	E,(HL)
 622  4FB9 23           	INC	HL
 623  4FBA 56           	LD	D,(HL)
 624  4FBB E1           	POP	HL		; routine address
 625  4FBC CD DD 4F     	CALL	GETPREVCHAR
 626  4FBF CD D1 4F     	CALL	.CALLDE		; Call routine
 627  4FC2 A7           	AND	A
 628  4FC3 C9           	RET
 629  4FC4
 630  4FC4              .TONEXTCMD:
 631  4FC4 0E FF        	LD	C,0FFH
 632  4FC6 AF           	XOR	A
 633  4FC7 ED B1        	CPIR			; Skip to end of instruction name
 634  4FC9 23           	INC	HL
 635  4FCA 23           	INC	HL		; Skip address
 636  4FCB BE           	CP	(HL)
 637  4FCC 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 638  4FCE E1           	POP	HL
 639  4FCF              .CMDNOTRECOGNIZED:
 640  4FCF 37               SCF
 641  4FD0 C9           	RET
 642  4FD1
 643  4FD1              .CALLDE:
 644  4FD1 D5           	PUSH	DE
 645  4FD2 C9           	RET
 646  4FD3
 647  4FD3              ;---------------------------
 648  4FD3
 649  4FD3              ;GETSTRPNT:
 650  4FD3              ; OUT:
 651  4FD3              ; HL = String Address
 652  4FD3              ; B  = Lenght
 653  4FD3              ;        LD      HL,(USR)
 654  4FD3              ;        LD      B,(HL)
 655  4FD3              ;        INC     HL
 656  4FD3              ;        LD      E,(HL)
 657  4FD3              ;        INC     HL
 658  4FD3              ;        LD      D,(HL)
 659  4FD3              ;        EX      DE,HL
 660  4FD3              ;        RET
 661  4FD3
 662  4FD3              ;EVALTXTPARAM:
 663  4FD3              ;	CALL	CHKCHAR
 664  4FD3              ;	DEFB	"("             ; Check for (
 665  4FD3              ;	LD	IX,FRMEVL
 666  4FD3              ;	CALL	CALBAS		; Evaluate expression
 667  4FD3              ;       LD      A,(VALTYP)
 668  4FD3              ;        CP      3               ; Text type?
 669  4FD3              ;        JP      NZ,TYPE_MISMATCH
 670  4FD3              ;        PUSH	HL
 671  4FD3              ;        LD	IX,FRESTR         ; Free the temporary string
 672  4FD3              ;        CALL	CALBAS
 673  4FD3              ;        POP	HL
 674  4FD3              ;	CALL	CHKCHAR
 675  4FD3              ;	DEFB	")"             ; Check for )
 676  4FD3              ;        RET
 677  4FD3
 678  4FD3
 679  4FD3              CHKCHAR:
 680  4FD3 CD DD 4F     	CALL	GETPREVCHAR	; Get previous basic char
 681  4FD6 E3           	EX	(SP),HL
 682  4FD7 BE           	CP	(HL) 	        ; Check if good char
 683  4FD8 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 684  4FDA 23           	INC	HL
 685  4FDB E3           	EX	(SP),HL
 686  4FDC 23           	INC	HL		; Get next basic char
 687  4FDD
 688  4FDD              GETPREVCHAR:
 689  4FDD 2B           	DEC	HL
 690  4FDE DD 21 66 46  	LD	IX,CHRGTR
 691  4FE2 C3 59 01     	JP      CALBAS
 692  4FE5
 693  4FE5
 694  4FE5              TYPE_MISMATCH:
 695  4FE5 1E 0D            LD E, 13 ; Type mismatch
 696  4FE7 18 02            JR THROW_ERROR
 697  4FE9
 698  4FE9              SYNTAX_ERROR:
 699  4FE9 1E 02            LD E, 2 ; Syntax error
 700  4FEB              THROW_ERROR:
 701  4FEB DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 702  4FEF C3 59 01     	JP	CALBAS
 703  4FF2
 704  4FF2              ;---------------------------
 705  4FF2
 706  4FF2               IFNDEF EXCLUDE_RAM_CMDS
 707  4FF2              ; *******************************************************************************************************
 708  4FF2              ; function to handle CALL MEMCPY basic extension
 709  4FF2              ; _MEMCPY ( INT source,
 710  4FF2              ;			INT destination,
 711  4FF2              ;			INT count,
 712  4FF2              ; will put ram in page 0 also, page 1 is already there
 713  4FF2              MEMCPY:
 714  4FF2              	; opening (
 715  4FF2 CD D3 4F     	CALL CHKCHAR
 716  4FF5 28           	DB '('
 717  4FF6              	; get source address
 718  4FF6 DD 21 2F 54  	LD IX, FRMQNT
 719  4FFA CD 59 01     	CALL CALBAS
 720  4FFD D5           	PUSH DE
 721  4FFE              	; comma
 722  4FFE CD D3 4F     	CALL CHKCHAR
 723  5001 2C           	DB ','
 724  5002              	; get destination address
 725  5002 DD 21 2F 54  	LD IX, FRMQNT
 726  5006 CD 59 01     	CALL CALBAS
 727  5009 D5           	PUSH DE
 728  500A              	; comma
 729  500A CD D3 4F     	CALL CHKCHAR
 730  500D 2C           	DB ','
 731  500E              	; get length
 732  500E DD 21 2F 54  	LD IX, FRMQNT
 733  5012 CD 59 01     	CALL CALBAS
 734  5015 D5           	PUSH DE
 735  5016              	; ending )
 736  5016 CD D3 4F     	CALL CHKCHAR
 737  5019 29           	DB ')'
 738  501A
 739  501A              	; save position
 740  501A E5           	PUSH HL
 741  501B DD E1        	POP IX
 742  501D
 743  501D C1           	POP BC ; count
 744  501E D1           	POP DE ; destination
 745  501F E1           	POP HL ; source
 746  5020 D9           	EXX
 747  5021              	; enable page 0
 748  5021 FD 21 28 50  	LD IY, .RET
 749  5025 C3 CE 4E     	JP ENABLE_PAGE0
 750  5028              .RET:
 751  5028 FB           	EI
 752  5029 D9           	EXX
 753  502A ED B0        	LDIR
 754  502C D1               POP DE
 755  502D C1               POP BC
 756  502E CD 45 4E         CALL RESTORE_PAGE_INFO
 757  5031 DD E5        	PUSH IX
 758  5033 E1           	POP HL
 759  5034 C9           	RET
 760  5035              ; *******************************************************************************************************
 761  5035               ENDIF
 762  5035               IFNDEF EXCLUDE_VRAM_CMDS
 763  5035              ; *******************************************************************************************************
 764  5035              ; function to handle CALL FILVRM basic extension
 765  5035              ; FILVRM ( INT offset,
 766  5035              ;		   INT count,
 767  5035              ;		   BYTE value,
 768  5035              ;		   BYTE wait_vsync) >0 = true
 769  5035              ; wait_vsync will issue HALT before copying
 770  5035              FILVRM:
 771  5035              	; opening (
 772  5035 CD D3 4F     	CALL CHKCHAR
 773  5038 28           	DB '('
 774  5039              	; get offset address
 775  5039 DD 21 2F 54  	LD IX, FRMQNT
 776  503D CD 59 01     	CALL CALBAS
 777  5040 D5           	PUSH DE
 778  5041              	; comma
 779  5041 CD D3 4F     	CALL CHKCHAR
 780  5044 2C           	DB ','
 781  5045              	; get count
 782  5045 DD 21 2F 54  	LD IX, FRMQNT
 783  5049 CD 59 01     	CALL CALBAS
 784  504C D5           	PUSH DE
 785  504D              	; comma
 786  504D CD D3 4F     	CALL CHKCHAR
 787  5050 2C           	DB ','
 788  5051              	; get value
 789  5051 DD 21 1C 52  	LD IX, GETBYT
 790  5055 CD 59 01     	CALL CALBAS
 791  5058 F5           	PUSH AF
 792  5059              	; comma
 793  5059 CD D3 4F     	CALL CHKCHAR
 794  505C 2C           	DB ','
 795  505D              	; get vsync wait
 796  505D DD 21 1C 52  	LD IX, GETBYT
 797  5061 CD 59 01     	CALL CALBAS
 798  5064 F5           	PUSH AF
 799  5065              	; ending )
 800  5065 CD D3 4F     	CALL CHKCHAR
 801  5068 29           	DB ')'
 802  5069
 803  5069 FB               EI
 804  506A              	; save position
 805  506A E5           	PUSH HL
 806  506B DD E1        	POP IX
 807  506D
 808  506D              	; syntax ok
 809  506D              	; wait for vsync if needed
 810  506D F1           	POP AF
 811  506E B7           	OR A
 812  506F 28 01        	JR Z, .L1
 813  5071 76           	HALT
 814  5072
 815  5072              .L1:
 816  5072 F1               POP AF ; value
 817  5073 C1               POP BC ; count
 818  5074 E1               POP HL ; offset
 819  5075 CD 56 00         CALL BIOS_FILVRM
 820  5078
 821  5078              .L3:
 822  5078 DD E5        	PUSH IX
 823  507A E1           	POP HL
 824  507B C9           	RET
 825  507C              ; *******************************************************************************************************
 826  507C               ENDIF
 827  507C
 828  507C               IFNDEF EXCLUDE_RAM_CMDS
 829  507C              ; *******************************************************************************************************
 830  507C              ; function to handle CALL FILRAM basic extension
 831  507C              ; FILRAM ( INT start address,
 832  507C              ;		   INT count,
 833  507C              ;		   BYTE value,
 834  507C              ; will put ram in page 0 also, page 1 is already there
 835  507C              FILRAM:
 836  507C              	; opening (
 837  507C CD D3 4F     	CALL CHKCHAR
 838  507F 28           	DB '('
 839  5080              	; get start address
 840  5080 DD 21 2F 54  	LD IX, FRMQNT
 841  5084 CD 59 01     	CALL CALBAS
 842  5087 D5           	PUSH DE
 843  5088              	; comma
 844  5088 CD D3 4F     	CALL CHKCHAR
 845  508B 2C           	DB ','
 846  508C              	; get count
 847  508C DD 21 2F 54  	LD IX, FRMQNT
 848  5090 CD 59 01     	CALL CALBAS
 849  5093 D5           	PUSH DE
 850  5094              	; comma
 851  5094 CD D3 4F     	CALL CHKCHAR
 852  5097 2C           	DB ','
 853  5098              	; get value
 854  5098 DD 21 1C 52  	LD IX, GETBYT
 855  509C CD 59 01     	CALL CALBAS
 856  509F F5           	PUSH AF
 857  50A0              	; ending )
 858  50A0 CD D3 4F     	CALL CHKCHAR
 859  50A3 29           	DB ')'
 860  50A4
 861  50A4              	; save position
 862  50A4 E5           	PUSH HL
 863  50A5 DD E1        	POP IX
 864  50A7
 865  50A7 D1           	POP DE ; actually AF
 866  50A8 C1           	POP BC ; count
 867  50A9 E1           	POP HL ; start address
 868  50AA 78           	LD A, B
 869  50AB B7           	OR A
 870  50AC 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 871  50AE B1           	OR C
 872  50AF 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 873  50B1 79           	LD A, C
 874  50B2 3D           	DEC A
 875  50B3 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 876  50B5              	; one byte to fill
 877  50B5 72           	LD (HL), D
 878  50B6 18 12        	JR .EXIT
 879  50B8              .L1:
 880  50B8 D9           	EXX
 881  50B9              	; enable page 0
 882  50B9 FD 21 C0 50  	LD IY, .RET
 883  50BD C3 CE 4E     	JP ENABLE_PAGE0
 884  50C0              .RET:
 885  50C0 FB           	EI
 886  50C1 D9           	EXX
 887  50C2 CD CE 50     	CALL .FILLVALUE
 888  50C5 D1               POP DE
 889  50C6 C1               POP BC
 890  50C7 CD 45 4E         CALL RESTORE_PAGE_INFO
 891  50CA              .EXIT:
 892  50CA DD E5        	PUSH IX
 893  50CC E1           	POP HL
 894  50CD C9           	RET
 895  50CE
 896  50CE              .FILLVALUE:
 897  50CE 72               LD (HL), D
 898  50CF 54               LD D, H
 899  50D0 5D               LD E, L
 900  50D1 13               INC DE
 901  50D2 0B               DEC BC
 902  50D3 ED B0            LDIR
 903  50D5 C9               RET
 904  50D6              ; *******************************************************************************************************
 905  50D6               ENDIF
 906  50D6
 907  50D6               IFNDEF EXCLUDE_GENCAL
 908  50D6              ; *******************************************************************************************************
 909  50D6              ; function to handle CALL GENCAL basic extension
 910  50D6              ; GENCAL ( INT fn_addr, = address of the function to call
 911  50D6              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 912  50D6              ; output values of reristers will also be stored at reg_list_ptr
 913  50D6              GENCAL_VAR_SP:
 914  50D6 00 00            DW 0
 915  50D8              GENCAL_VAR_SP2:
 916  50D8 00 00            DW 0
 917  50DA              GENCAL:
 918  50DA              	; opening (
 919  50DA CD D3 4F     	CALL CHKCHAR
 920  50DD 28           	DB '('
 921  50DE              	; get function address
 922  50DE DD 21 2F 54  	LD IX, FRMQNT
 923  50E2 CD 59 01     	CALL CALBAS
 924  50E5 D5           	PUSH DE
 925  50E6              	; comma
 926  50E6 CD D3 4F     	CALL CHKCHAR
 927  50E9 2C           	DB ','
 928  50EA              	; get pointer to register list
 929  50EA DD 21 2F 54  	LD IX, FRMQNT
 930  50EE CD 59 01     	CALL CALBAS
 931  50F1 D5           	PUSH DE
 932  50F2              	; ending )
 933  50F2 CD D3 4F     	CALL CHKCHAR
 934  50F5 29           	DB ')'
 935  50F6
 936  50F6              	; save BASIC token position
 937  50F6 E5           	PUSH HL
 938  50F7 D9               EXX
 939  50F8 E1           	POP HL ; HL'=next basic token
 940  50F9 D9               EXX
 941  50FA
 942  50FA E1               POP HL ; get pointer to register values
 943  50FB ED 73 D6 50      LD (GENCAL_VAR_SP), SP
 944  50FF F3               DI
 945  5100 F9               LD SP, HL
 946  5101 F1               POP AF
 947  5102 C1               POP BC
 948  5103 D1               POP DE
 949  5104 E1               POP HL
 950  5105 DD E1            POP IX
 951  5107 FD E1            POP IY
 952  5109 D9               EXX
 953  510A ED 73 D8 50      LD (GENCAL_VAR_SP2), SP
 954  510E ED 7B D6 50      LD SP, (GENCAL_VAR_SP)
 955  5112 FB               EI
 956  5113 D1               POP DE ; get function to call
 957  5114 E5               PUSH HL
 958  5115 CD 30 51         CALL .EXXDECALL
 959  5118 F3               DI
 960  5119 ED 73 D6 50      LD (GENCAL_VAR_SP), SP
 961  511D ED 7B D8 50      LD SP, (GENCAL_VAR_SP2)
 962  5121 FD E5            PUSH IY
 963  5123 DD E5            PUSH IX
 964  5125 E5               PUSH HL
 965  5126 D5               PUSH DE
 966  5127 C5               PUSH BC
 967  5128 F5               PUSH AF
 968  5129 ED 7B D6 50      LD SP, (GENCAL_VAR_SP)
 969  512D FB               EI
 970  512E E1               POP HL
 971  512F C9           	RET
 972  5130
 973  5130              .EXXDECALL:
 974  5130 D5               PUSH DE
 975  5131 D9               EXX
 976  5132 C9               RET
 977  5133              ; *******************************************************************************************************
 978  5133               ENDIF
 979  5133
 980  5133               IFNDEF EXCLUDE_VRAM_CMDS
 981  5133              ; *******************************************************************************************************
 982  5133              ; function to handle CALL MEMVRM basic extension
 983  5133              ; copies from RAM to VRAM
 984  5133              ; _MEMVRM ( INT source,
 985  5133              ;			INT destination,
 986  5133              ;			INT count,
 987  5133              ;			BYTE wait_vsync) >0 = true
 988  5133              ; will put ram in page 0 also, page 1 is already there
 989  5133              ; wait_vsync will issue HALT before copying
 990  5133              MEMVRM:
 991  5133              	; opening (
 992  5133 CD D3 4F     	CALL CHKCHAR
 993  5136 28           	DB '('
 994  5137              	; get source address
 995  5137 DD 21 2F 54  	LD IX, FRMQNT
 996  513B CD 59 01     	CALL CALBAS
 997  513E D5           	PUSH DE
 998  513F              	; comma
 999  513F CD D3 4F     	CALL CHKCHAR
1000  5142 2C           	DB ','
1001  5143              	; get destination address
1002  5143 DD 21 2F 54  	LD IX, FRMQNT
1003  5147 CD 59 01     	CALL CALBAS
1004  514A D5           	PUSH DE
1005  514B              	; comma
1006  514B CD D3 4F     	CALL CHKCHAR
1007  514E 2C           	DB ','
1008  514F              	; get length
1009  514F DD 21 2F 54  	LD IX, FRMQNT
1010  5153 CD 59 01     	CALL CALBAS
1011  5156 D5           	PUSH DE
1012  5157              	; comma
1013  5157 CD D3 4F     	CALL CHKCHAR
1014  515A 2C           	DB ','
1015  515B              	; get vsync wait
1016  515B DD 21 1C 52  	LD IX, GETBYT
1017  515F CD 59 01     	CALL CALBAS
1018  5162 F5           	PUSH AF
1019  5163              	; ending )
1020  5163 CD D3 4F     	CALL CHKCHAR
1021  5166 29           	DB ')'
1022  5167
1023  5167                  ; save position in BASIC text
1024  5167 E5           	PUSH HL
1025  5168 DD E1        	POP IX
1026  516A
1027  516A F1           	POP AF ; wait vsync
1028  516B B7           	OR A
1029  516C 28 03        	JR Z, .L1
1030  516E FB               EI
1031  516F 76           	HALT
1032  5170 F3           	DI
1033  5171              .L1:
1034  5171              	; pop LDIR parameters and store away for later
1035  5171 C1           	POP BC ; count
1036  5172 D1           	POP DE ; vram destination
1037  5173 E1           	POP HL ; ram source
1038  5174 D9           	EXX
1039  5175 FD 21 7C 51   	LD IY, .RET
1040  5179 C3 CE 4E     	JP ENABLE_PAGE0
1041  517C              .RET:
1042  517C FB           	EI
1043  517D D9           	EXX
1044  517E CD 8A 51     	CALL .LDIRVM
1045  5181 D1               POP DE
1046  5182 C1               POP BC
1047  5183 CD 45 4E         CALL RESTORE_PAGE_INFO
1048  5186 DD E5        	PUSH IX
1049  5188 E1           	POP HL
1050  5189 C9           	RET
1051  518A
1052  518A              .LDIRVM:
1053  518A EB           	EX DE, HL
1054  518B F3           	DI
1055  518C CD 03 4E     	CALL SETWRT_LOCAL
1056  518F FB           	EI
1057  5190 EB           	EX DE, HL
1058  5191 78           	LD A, B
1059  5192 B7           	OR A
1060  5193 28 0D        	JR Z, .L3
1061  5195 C5           	PUSH BC
1062  5196 0E 98        	LD C, #98
1063  5198              .L2:
1064  5198 50           	LD D, B
1065  5199 06 00        	LD B, 0
1066  519B CD A8 51     	CALL .BBYTECOPY
1067  519E 42           	LD B, D
1068  519F 10 F7        	DJNZ .L2
1069  51A1 C1           	POP BC
1070  51A2              .L3:
1071  51A2 79           	LD A, C
1072  51A3 B7           	OR A
1073  51A4 C8           	RET Z
1074  51A5 41           	LD B, C
1075  51A6 0E 98        	LD C, #98
1076  51A8              .BBYTECOPY:
1077  51A8 ED A3        	OUTI
1078  51AA C2 A8 51     	JP	NZ, .BBYTECOPY
1079  51AD C9           	RET
1080  51AE              ; *******************************************************************************************************
1081  51AE               ENDIF
1082  51AE
1083  51AE               IFNDEF EXCLUDE_VRAM_CMDS
1084  51AE              ; *******************************************************************************************************
1085  51AE              ; function to handle CALL VRMMEM basic extension
1086  51AE              ; copies from RAM to VRAM
1087  51AE              ; _VRMMEM ( INT source,
1088  51AE              ;			INT destination,
1089  51AE              ;			INT count
1090  51AE              ; will put ram in page 0 also, page 1 is already there
1091  51AE              VRMMEM:
1092  51AE              	; opening (
1093  51AE CD D3 4F     	CALL CHKCHAR
1094  51B1 28           	DB '('
1095  51B2              	; get source address
1096  51B2 DD 21 2F 54  	LD IX, FRMQNT
1097  51B6 CD 59 01     	CALL CALBAS
1098  51B9 D5           	PUSH DE
1099  51BA              	; comma
1100  51BA CD D3 4F     	CALL CHKCHAR
1101  51BD 2C           	DB ','
1102  51BE              	; get destination address
1103  51BE DD 21 2F 54  	LD IX, FRMQNT
1104  51C2 CD 59 01     	CALL CALBAS
1105  51C5 D5           	PUSH DE
1106  51C6              	; comma
1107  51C6 CD D3 4F     	CALL CHKCHAR
1108  51C9 2C           	DB ','
1109  51CA              	; get length
1110  51CA DD 21 2F 54  	LD IX, FRMQNT
1111  51CE CD 59 01     	CALL CALBAS
1112  51D1 D5           	PUSH DE
1113  51D2              	; ending )
1114  51D2 CD D3 4F     	CALL CHKCHAR
1115  51D5 29           	DB ')'
1116  51D6
1117  51D6                  ; save position in BASIC text
1118  51D6 E5           	PUSH HL
1119  51D7 DD E1        	POP IX
1120  51D9
1121  51D9 C1           	POP BC ; count
1122  51DA D1           	POP DE ; destination
1123  51DB E1           	POP HL ; source
1124  51DC D9           	EXX
1125  51DD FD 21 E4 51  	LD IY, .RET
1126  51E1 C3 CE 4E     	JP ENABLE_PAGE0
1127  51E4              .RET:
1128  51E4 FB           	EI
1129  51E5 D9           	EXX
1130  51E6 CD F2 51     	CALL .LDIRMV
1131  51E9 D1               POP DE
1132  51EA C1               POP BC
1133  51EB CD 45 4E         CALL RESTORE_PAGE_INFO
1134  51EE DD E5        	PUSH IX
1135  51F0 E1           	POP HL
1136  51F1 C9           	RET
1137  51F2
1138  51F2              .LDIRMV:
1139  51F2              	; set VRAM address *exactly* as in ROM, otherwise corruption
1140  51F2 7D           	LD	A, L
1141  51F3 F3           	DI
1142  51F4 D3 99        	OUT	(099H), A
1143  51F6 7C           	LD	A, H
1144  51F7 E6 3F        	AND	03FH
1145  51F9 D3 99        	OUT	(099H), A
1146  51FB FB           	EI
1147  51FC              	;EX (SP), HL
1148  51FC              	;EX (SP), HL
1149  51FC              	;NOP
1150  51FC              	;NOP
1151  51FC              .L4:
1152  51FC DB 98            IN A, (#98)
1153  51FE 12           	LD (DE), A
1154  51FF 13               INC DE
1155  5200 0B               DEC BC
1156  5201 79               LD A, C
1157  5202 B0               OR B
1158  5203 20 F7            JR NZ, .L4
1159  5205 C9               RET
1160  5206              ; *******************************************************************************************************
1161  5206               ENDIF
1162  5206
1163  5206              ; *******************************************************************************************************
1164  5206              ; H.TIMI function
1165  5206              MBGE_HTIMI:
1166  5206               EXPORT MBGE_HTIMI
1167  5206 F5           	PUSH AF
1168  5207
1169  5207               IFNDEF EXCLUDE_SPRITE_CMDS
1170  5207 CD DE 4E     	CALL SPRATR_UPDATE
1171  520A               ENDIF
1172  520A
1173  520A               IFNDEF EXCLUDE_SOUND_PLAYER
1174  520A 3A F7 4C     	LD A, (SOUND_ENABLED)
1175  520D B7           	OR A
1176  520E 28 2A        	JR Z, .EXIT
1177  5210
1178  5210              	; enable page 2
1179  5210 3E 02            LD A, 2
1180  5212 CD 0E 4E         CALL GET_PAGE_INFO
1181  5215 C5               PUSH BC
1182  5216 D5               PUSH DE
1183  5217 3A 43 F3         LD A, (RAMAD2)
1184  521A 26 80            LD H, 080H
1185  521C CD 55 4E         CALL LOCAL_ENASLT
1186  521F              	; enable page 0
1187  521F AF               XOR A
1188  5220 CD 0E 4E         CALL GET_PAGE_INFO
1189  5223 C5               PUSH BC
1190  5224 D5               PUSH DE
1191  5225 3A 41 F3         LD A, (RAMAD0)
1192  5228 26 00            LD H, 0
1193  522A CD 55 4E         CALL LOCAL_ENASLT
1194  522D
1195  522D CD 33 42     	CALL PLY_AKG_PLAY
1196  5230
1197  5230              	; restore page 0
1198  5230 D1               POP DE
1199  5231 C1               POP BC
1200  5232 CD 45 4E         CALL RESTORE_PAGE_INFO
1201  5235              	; restore page 2
1202  5235 D1               POP DE
1203  5236 C1               POP BC
1204  5237 CD 45 4E         CALL RESTORE_PAGE_INFO
1205  523A               ENDIF
1206  523A
1207  523A              .EXIT:
1208  523A F1           	POP AF
1209  523B C3 F0 4C     	JP ORIG.HTIMI
1210  523E              ; *******************************************************************************************************
1211  523E
1212  523E              ; *******************************************************************************************************
1213  523E              ; interrupt handler when page 0 enabled
1214  523E              VBLANK:
1215  523E              	EXPORT VBLANK
1216  523E
1217  523E F5               PUSH AF
1218  523F              	; is VDP originator ?
1219  523F DB 99        	IN	A, (099H)
1220  5241 A7           	AND	A
1221  5242 F2 68 52     	JP P, .EXIT
1222  5245
1223  5245               IFNDEF EXCLUDE_SOUND_PLAYER
1224  5245 3A F7 4C     	LD A, (SOUND_ENABLED)
1225  5248 B7           	OR A
1226  5249 28 1D        	JR Z, .EXIT
1227  524B
1228  524B C5               PUSH BC
1229  524C D5               PUSH DE
1230  524D E5               PUSH HL
1231  524E 08               EX AF, AF'
1232  524F D9               EXX
1233  5250 F5               PUSH AF
1234  5251 C5               PUSH BC
1235  5252 D5               PUSH DE
1236  5253 E5               PUSH HL
1237  5254 DD E5            PUSH IX
1238  5256 FD E5            PUSH IY
1239  5258
1240  5258 CD 33 42     	CALL PLY_AKG_PLAY
1241  525B
1242  525B FD E1            POP IY
1243  525D DD E1            POP IX
1244  525F E1               POP HL
1245  5260 D1               POP DE
1246  5261 C1               POP BC
1247  5262 F1               POP AF
1248  5263 08               EX AF, AF'
1249  5264 D9               EXX
1250  5265 E1               POP HL
1251  5266 D1               POP DE
1252  5267 C1               POP BC
1253  5268               ENDIF
1254  5268
1255  5268              .EXIT:
1256  5268 F1           	POP AF
1257  5269 FB           	EI
1258  526A ED 4D        	RETI
1259  526C              ; *******************************************************************************************************
1260  526C
1261  526C               IFNDEF EXCLUDE_SOUND_PLAYER
1262  526C              ; *******************************************************************************************************
1263  526C              ; function to handle CALL SNDPLYINIT basic extension
1264  526C              ; initializes sound player
1265  526C              ; _SNDPLYINIT ( INT music_offset,
1266  526C              ;				INT sfx_offset, can be -1 if no SFX
1267  526C              ; will put ram in page 0 also, page 1 is already there
1268  526C              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1269  526C              SNDPLYINIT:
1270  526C              	; opening (
1271  526C CD D3 4F     	CALL CHKCHAR
1272  526F 28           	DB '('
1273  5270              	; get music address
1274  5270 DD 21 2F 54  	LD IX, FRMQNT
1275  5274 CD 59 01     	CALL CALBAS
1276  5277 D5           	PUSH DE
1277  5278              	; comma
1278  5278 CD D3 4F     	CALL CHKCHAR
1279  527B 2C           	DB ','
1280  527C              	; get sfx address
1281  527C DD 21 2F 54  	LD IX, FRMQNT
1282  5280 CD 59 01     	CALL CALBAS
1283  5283 D5           	PUSH DE
1284  5284              	; ending )
1285  5284 CD D3 4F     	CALL CHKCHAR
1286  5287 29           	DB ')'
1287  5288
1288  5288                  ; save position in BASIC text
1289  5288 44           	LD B, H
1290  5289 4D           	LD C, L
1291  528A
1292  528A              	; pop LDIR parameters and store away for later
1293  528A D1           	POP DE ; sfx address
1294  528B E1           	POP HL ; music address
1295  528C C5           	PUSH BC ; basic text location
1296  528D D9           	EXX
1297  528E FD 21 95 52  	LD IY, .RET
1298  5292 C3 CE 4E     	JP ENABLE_PAGE0
1299  5295              .RET:
1300  5295 D9           	EXX
1301  5296
1302  5296 D5           	PUSH DE
1303  5297 AF           	XOR A
1304  5298              	; HL = music location
1305  5298 CD 62 41     	CALL PLY_AKG_INIT
1306  529B 3E 01        	LD A, 1
1307  529D 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1308  52A0
1309  52A0 E1           	POP HL ; SFX
1310  52A1              	; check if SFX address -1
1311  52A1 23           	INC HL
1312  52A2 7D           	LD A, L
1313  52A3 B4           	OR H
1314  52A4 28 09        	JR Z,.L1
1315  52A6 2B           	DEC HL
1316  52A7 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1317  52AA 3E 01        	LD A, 1
1318  52AC 32 F6 4C     	LD (SFX_INIT_STATUS), A
1319  52AF              .L1:
1320  52AF D1               POP DE
1321  52B0 C1               POP BC
1322  52B1 CD 45 4E         CALL RESTORE_PAGE_INFO
1323  52B4
1324  52B4 E1           	POP HL
1325  52B5 C9           	RET
1326  52B6              ; *******************************************************************************************************
1327  52B6
1328  52B6              ; *******************************************************************************************************
1329  52B6              ; function to handle CALL SNDPLYON basic extension
1330  52B6              ; enables sound player
1331  52B6              ; _SNDPLYON
1332  52B6              ; sets SOUND_ENABLED variable to 1 if init call was done
1333  52B6              ; if not throws out of data error
1334  52B6              SNDPLYON:
1335  52B6 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1336  52B9 B7           	OR A
1337  52BA 20 05        	JR NZ, .L1
1338  52BC              	; player not initialized, throw error
1339  52BC 1E 04        	LD E, 04 ; Out of DATA
1340  52BE C3 EB 4F     	JP THROW_ERROR
1341  52C1              .L1:
1342  52C1 32 F7 4C     	LD (SOUND_ENABLED), A
1343  52C4              	; disable key click
1344  52C4 AF           	XOR A
1345  52C5 32 DB F3     	LD (CLIKSW), A
1346  52C8 C9           	RET
1347  52C9              ; *******************************************************************************************************
1348  52C9
1349  52C9              ; *******************************************************************************************************
1350  52C9              ; function to handle CALL SNDPLYOFF basic extension
1351  52C9              ; disables sound player
1352  52C9              ; _SNDPLYOFF
1353  52C9              ; sets SOUND_ENABLED variable to 0
1354  52C9              ; calls AKG to stop music and SFX on all channels if initialized
1355  52C9              SNDPLYOFF:
1356  52C9 3A F7 4C     	LD A, (SOUND_ENABLED)
1357  52CC B7           	OR A
1358  52CD C8           	RET Z ; already stopped
1359  52CE AF           	XOR A
1360  52CF 32 F7 4C     	LD (SOUND_ENABLED), A
1361  52D2 E5           	PUSH HL
1362  52D3 CD 21 42     	CALL PLY_AKG_STOP
1363  52D6 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1364  52D9 B7           	OR A
1365  52DA 28 0E        	JR Z, .EXIT ; SFX not in use
1366  52DC AF           	XOR A
1367  52DD CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1368  52E0 3E 01        	LD A, 1
1369  52E2 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1370  52E5 3E 02        	LD A, 2
1371  52E7 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1372  52EA              .EXIT:
1373  52EA E1           	POP HL
1374  52EB C9           	RET
1375  52EC              ; *******************************************************************************************************
1376  52EC
1377  52EC              ; *******************************************************************************************************
1378  52EC              ; function to handle CALL SNDSFX basic extension
1379  52EC              ; plays a sound effect
1380  52EC              ; _SNDSFX ( BYTE sfx_number, >0
1381  52EC              ;			BYTE channel, = 0,1 or 2
1382  52EC              ;			BYTE inverted_volume = 0-16, 0 being full volume
1383  52EC              ; will put ram in page 0 also, page 1 is already there
1384  52EC              ; if sound off throws illegal function call
1385  52EC              ; if sfx not initialized, throws out of data
1386  52EC              SNDSFX:
1387  52EC              	; opening (
1388  52EC CD D3 4F     	CALL CHKCHAR
1389  52EF 28           	DB '('
1390  52F0              	; get sfx_number
1391  52F0 DD 21 1C 52  	LD IX, GETBYT
1392  52F4 CD 59 01     	CALL CALBAS
1393  52F7 D5           	PUSH DE
1394  52F8              	; comma
1395  52F8 CD D3 4F     	CALL CHKCHAR
1396  52FB 2C           	DB ','
1397  52FC              	; get sfx address
1398  52FC DD 21 1C 52  	LD IX, GETBYT
1399  5300 CD 59 01     	CALL CALBAS
1400  5303 D5           	PUSH DE
1401  5304              	; comma
1402  5304 CD D3 4F     	CALL CHKCHAR
1403  5307 2C           	DB ','
1404  5308              	; get inverted volume
1405  5308 DD 21 1C 52  	LD IX, GETBYT
1406  530C CD 59 01     	CALL CALBAS
1407  530F D5           	PUSH DE
1408  5310              	; ending )
1409  5310 CD D3 4F     	CALL CHKCHAR
1410  5313 29           	DB ')'
1411  5314
1412  5314 3A F7 4C     	LD A, (SOUND_ENABLED)
1413  5317 B7           	OR A
1414  5318 20 05        	JR NZ, .L1
1415  531A              	; sound disabled, throw illegal function call
1416  531A 1E 05        	LD E, 5
1417  531C C3 EB 4F     	JP THROW_ERROR
1418  531F              .L1:
1419  531F 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1420  5322 B7           	OR A
1421  5323 20 05        	JR NZ, .L2
1422  5325              	; sfx data not initialized, throw out of data
1423  5325 1E 04        	LD E, 4
1424  5327 C3 EB 4F     	JP THROW_ERROR
1425  532A              .L2:
1426  532A              	; pop  parameters and store away for later
1427  532A D1           	POP DE ; inverted volume
1428  532B 43           	LD B, E
1429  532C D1           	POP DE ; channel
1430  532D 4B           	LD C, E
1431  532E D1           	POP DE
1432  532F 7B           	LD A, E
1433  5330 08           	EX AF, AF'
1434  5331 E5           	PUSH HL ; basic text location
1435  5332 D9           	EXX
1436  5333 FD 21 3A 53  	LD IY, .RET
1437  5337 C3 CE 4E     	JP ENABLE_PAGE0
1438  533A              .RET:
1439  533A D9           	EXX
1440  533B 08           	EX AF, AF'
1441  533C CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1442  533F
1443  533F D1               POP DE
1444  5340 C1               POP BC
1445  5341 CD 45 4E         CALL RESTORE_PAGE_INFO
1446  5344
1447  5344 E1           	POP HL
1448  5345 C9           	RET
1449  5346              ; *******************************************************************************************************
1450  5346               ENDIF
1451  5346
1452  5346               IFNDEF EXCLUDE_SPRITE_CMDS
1453  5346              ; *******************************************************************************************************
1454  5346              ; function to handle CALL SPRENABLE basic extension
1455  5346              ; initializes sprites handler
1456  5346              ; _SPRENABLE ( INT sprites_attributes_data,
1457  5346              ;			   INT update_variable_location,
1458  5346              ;			   INT sprite_flicker_enabled )
1459  5346              ; expects both locations to be in range #8000+ or throws an error
1460  5346              ; since these should be BASIC variables
1461  5346              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
1462  5346              SPRENABLE:
1463  5346              	; opening (
1464  5346 CD D3 4F     	CALL CHKCHAR
1465  5349 28           	DB '('
1466  534A              	; get address of sprite attribute table DIM SA%(3,31)
1467  534A DD 21 2F 54  	LD IX, FRMQNT
1468  534E CD 59 01     	CALL CALBAS
1469  5351 D5           	PUSH DE
1470  5352              	; comma
1471  5352 CD D3 4F     	CALL CHKCHAR
1472  5355 2C           	DB ','
1473  5356              	; get address of sprite update flag location
1474  5356 DD 21 2F 54  	LD IX, FRMQNT
1475  535A CD 59 01     	CALL CALBAS
1476  535D D5           	PUSH DE
1477  535E              	; comma
1478  535E CD D3 4F     	CALL CHKCHAR
1479  5361 2C           	DB ','
1480  5362              	; get flicker enabled flag
1481  5362 DD 21 2F 54  	LD IX, FRMQNT
1482  5366 CD 59 01     	CALL CALBAS
1483  5369 D5           	PUSH DE
1484  536A              	; ending )
1485  536A CD D3 4F     	CALL CHKCHAR
1486  536D 29           	DB ')'
1487  536E
1488  536E D1           	POP DE ; get flicker flag
1489  536F 7A           	LD A, D
1490  5370 B3           	OR E
1491  5371 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
1492  5374
1493  5374 D1           	POP DE ; update variable location
1494  5375 CB 7A        	BIT 7, D ; is address >= &h8000
1495  5377 20 05        	JR NZ, .L1
1496  5379 1E 05        	LD E, 5 ; illegal function call
1497  537B C3 EB 4F     	JP THROW_ERROR
1498  537E              .L1:
1499  537E ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
1500  5382 D1           	POP DE ; address of sprite attribute table
1501  5383 CB 7A        	BIT 7, D ; is address >= &h8000
1502  5385 20 05        	JR NZ, .L2
1503  5387 1E 05        	LD E, 5 ; illegal function call
1504  5389 C3 EB 4F     	JP THROW_ERROR
1505  538C              .L2:
1506  538C ED 53 FB 4C  	LD (SPRATR_DATA), DE
1507  5390 3E 01        	LD A, 1
1508  5392 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1509  5395 C9           	RET
1510  5396              ; *******************************************************************************************************
1511  5396
1512  5396              ; *******************************************************************************************************
1513  5396              ; function to handle CALL SPRDISABLE basic extension
1514  5396              ; disables sprites handling
1515  5396              ; _SPRDISABLE
1516  5396              ; resets variable SPRATR_INIT_STATUS
1517  5396              SPRDISABLE:
1518  5396 AF           	XOR A
1519  5397 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1520  539A C9           	RET
1521  539B              ; *******************************************************************************************************
1522  539B
1523  539B              ; *******************************************************************************************************
1524  539B              ; function to handle CALL SPRSET basic extension
1525  539B              ; sets position, and optionally pattern and color of sprite
1526  539B              ; _SPRSET ( BYTE sprite_num , valid 0-31
1527  539B              ;			INT x,
1528  539B              ;			INT y,
1529  539B              ;			INT pattern, valid 0-63, otherwise ignored
1530  539B              ;			INT color, valid 0-15, otherwise ignored
1531  539B              SPRSET:
1532  539B 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1533  539E B7           	OR A
1534  539F 20 05        	JR NZ, .L1
1535  53A1 1E 05        	LD E, 5 ; illegal function call
1536  53A3 C3 EB 4F     	JP THROW_ERROR
1537  53A6              .L1:
1538  53A6              	; opening (
1539  53A6 CD D3 4F     	CALL CHKCHAR
1540  53A9 28           	DB '('
1541  53AA              	; get sprite number
1542  53AA DD 21 1C 52  	LD IX, GETBYT
1543  53AE CD 59 01     	CALL CALBAS
1544  53B1 F5           	PUSH AF
1545  53B2              	; comma
1546  53B2 CD D3 4F     	CALL CHKCHAR
1547  53B5 2C           	DB ','
1548  53B6              	; get x
1549  53B6 DD 21 2F 54  	LD IX, FRMQNT
1550  53BA CD 59 01     	CALL CALBAS
1551  53BD D5           	PUSH DE
1552  53BE              	; comma
1553  53BE CD D3 4F     	CALL CHKCHAR
1554  53C1 2C           	DB ','
1555  53C2              	; get y
1556  53C2 DD 21 2F 54  	LD IX, FRMQNT
1557  53C6 CD 59 01     	CALL CALBAS
1558  53C9 D5           	PUSH DE
1559  53CA              	; comma
1560  53CA CD D3 4F     	CALL CHKCHAR
1561  53CD 2C           	DB ','
1562  53CE              	; get pattern
1563  53CE DD 21 2F 54  	LD IX, FRMQNT
1564  53D2 CD 59 01     	CALL CALBAS
1565  53D5 D5           	PUSH DE
1566  53D6              	; comma
1567  53D6 CD D3 4F     	CALL CHKCHAR
1568  53D9 2C           	DB ','
1569  53DA              	; get color
1570  53DA DD 21 2F 54  	LD IX, FRMQNT
1571  53DE CD 59 01     	CALL CALBAS
1572  53E1 D5           	PUSH DE
1573  53E2              	; ending )
1574  53E2 CD D3 4F     	CALL CHKCHAR
1575  53E5 29           	DB ')'
1576  53E6
1577  53E6                  ; save position in BASIC text
1578  53E6 E5           	PUSH HL
1579  53E7 DD E1        	POP IX
1580  53E9
1581  53E9 C1           	POP BC ; color
1582  53EA D1           	POP DE ; pattern
1583  53EB D9           	EXX
1584  53EC C1           	POP BC ; y
1585  53ED D1           	POP DE ; x
1586  53EE F1           	POP AF ; sprite number
1587  53EF FE 20        	CP 32
1588  53F1 38 05        	JR C, .L2
1589  53F3 1E 05        	LD E, 5 ; illegal function call
1590  53F5 C3 EB 4F     	JP THROW_ERROR
1591  53F8              .L2:
1592  53F8              	; find location in sprite attributes table
1593  53F8 87          > ADD A, A
1593  53F9 87          > ADD A, A
1593  53FA 87          > ADD A, A
1594  53FB D5           	PUSH DE
1595  53FC 16 00        	LD D, 0
1596  53FE 5F           	LD E, A
1597  53FF 2A FB 4C     	LD HL, (SPRATR_DATA)
1598  5402 19           	ADD HL, DE
1599  5403 D1           	POP DE
1600  5404              	; set y
1601  5404 71           	LD (HL), C
1602  5405 23           	INC HL
1603  5406 70           	LD (HL), B
1604  5407 23           	INC HL
1605  5408              	; set x
1606  5408 73           	LD (HL), E
1607  5409 23           	INC HL
1608  540A 72           	LD (HL), D
1609  540B 23           	INC HL
1610  540C E5           	PUSH HL
1611  540D D9           	EXX
1612  540E E1           	POP HL
1613  540F              	; check if 0<=pattern<64
1614  540F 7A           	LD A, D
1615  5410 B7           	OR A
1616  5411 20 0B        	JR NZ, .L3
1617  5413 7B           	LD A, E
1618  5414 FE 40        	CP 64
1619  5416 30 06        	JR NC, .L3
1620  5418              	; set pattern
1621  5418              	;ADD A, A
1622  5418              	;ADD A, A
1623  5418              	;ADD A, A
1624  5418 77           	LD (HL), A
1625  5419 23           	INC HL
1626  541A 72           	LD (HL), D
1627  541B 23           	INC HL
1628  541C 18 02        	JR .L4
1629  541E              .L3:
1630  541E              	; skip pattern
1631  541E 23          > INC HL
1631  541F 23          > INC HL
1632  5420              .L4:
1633  5420              	; check if 0<=color<16
1634  5420 78           	LD A, B
1635  5421 B7           	OR A
1636  5422 20 08        	JR NZ, .L5
1637  5424 79           	LD A, C
1638  5425 FE 10        	CP 16
1639  5427 30 03        	JR NC, .L5
1640  5429              	; set color
1641  5429 71           	LD (HL), C
1642  542A 23           	INC HL
1643  542B 70           	LD (HL), B
1644  542C
1645  542C              .L5:
1646  542C DD E5        	PUSH IX
1647  542E E1           	POP HL
1648  542F C9           	RET
1649  5430              ; *******************************************************************************************************
1650  5430
1651  5430              ; *******************************************************************************************************
1652  5430              ; function sets sprite location based on initial coordinates and offset provided
1653  5430              ; input A=sprite number in SPRATR_DATA , 0-31
1654  5430              ; input DE=initial x
1655  5430              ; input BC=initial y
1656  5430              ; input IY=location where delta y,x are located
1657  5430              ; modifies AF, HL, IX
1658  5430              SPRSET_DELTA_POS:
1659  5430 87          > ADD A, A
1659  5431 87          > ADD A, A
1659  5432 87          > ADD A, A
1660  5433 D5           	PUSH DE
1661  5434 16 00        	LD D, 0
1662  5436 5F           	LD E, A
1663  5437 DD 2A FB 4C  	LD IX, (SPRATR_DATA)
1664  543B DD 19        	ADD IX, DE
1665  543D D1           	POP DE
1666  543E              	; IX=sprite's y location
1667  543E FD 6E 00     	LD L, (IY)
1668  5441 FD 66 01     	LD H, (IY+1)
1669  5444 09           	ADD HL, BC
1670  5445 DD 75 00     	LD (IX), L
1671  5448 DD 74 01     	LD (IX+1), H
1672  544B FD 6E 02     	LD L, (IY+2)
1673  544E FD 66 03     	LD H, (IY+3)
1674  5451 19           	ADD HL, DE
1675  5452 DD 75 02     	LD (IX+2), L
1676  5455 DD 74 03     	LD (IX+3), H
1677  5458 C9           	RET
1678  5459              ; *******************************************************************************************************
1679  5459
1680  5459              ; *******************************************************************************************************
1681  5459              ; function to handle CALL SPRGRPMOV basic extension
1682  5459              ; sets position of a group of sprites described with
1683  5459              ; { int sprite_num, int delta_y, int delta_x } [count]
1684  5459              ; _SPRGRPMOV ( INT x,
1685  5459              ;			   INT y,
1686  5459              ;			   INT data_ptr,
1687  5459              ;			   BYTE count,
1688  5459              ; will put ram in page 0 also, page 1 is already there
1689  5459              SPRGRPMOV:
1690  5459 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1691  545C B7           	OR A
1692  545D 20 05        	JR NZ, .L1
1693  545F 1E 05        	LD E, 5 ; illegal function call
1694  5461 C3 EB 4F     	JP THROW_ERROR
1695  5464              .L1:
1696  5464              	; opening (
1697  5464 CD D3 4F     	CALL CHKCHAR
1698  5467 28           	DB '('
1699  5468              	; get x
1700  5468 DD 21 2F 54  	LD IX, FRMQNT
1701  546C CD 59 01     	CALL CALBAS
1702  546F D5           	PUSH DE
1703  5470              	; comma
1704  5470 CD D3 4F     	CALL CHKCHAR
1705  5473 2C           	DB ','
1706  5474              	; get y
1707  5474 DD 21 2F 54  	LD IX, FRMQNT
1708  5478 CD 59 01     	CALL CALBAS
1709  547B D5           	PUSH DE
1710  547C              	; comma
1711  547C CD D3 4F     	CALL CHKCHAR
1712  547F 2C           	DB ','
1713  5480              	; get data pointer
1714  5480 DD 21 2F 54  	LD IX, FRMQNT
1715  5484 CD 59 01     	CALL CALBAS
1716  5487 D5           	PUSH DE
1717  5488              	; comma
1718  5488 CD D3 4F     	CALL CHKCHAR
1719  548B 2C           	DB ','
1720  548C              	; get count
1721  548C DD 21 1C 52  	LD IX, GETBYT
1722  5490 CD 59 01     	CALL CALBAS
1723  5493 F5           	PUSH AF
1724  5494              	; ending )
1725  5494 CD D3 4F     	CALL CHKCHAR
1726  5497 29           	DB ')'
1727  5498
1728  5498 E5           	PUSH HL
1729  5499 DD E1        	POP IX
1730  549B
1731  549B C1           	POP BC ; count
1732  549C E1           	POP HL ; data pointer
1733  549D D9           	EXX
1734  549E C1           	POP BC ; y
1735  549F D1           	POP DE ; x
1736  54A0 D9           	EXX
1737  54A1
1738  54A1 DD E5        	PUSH IX ; save position in BASIC buffer
1739  54A3
1740  54A3 C5           	PUSH BC
1741  54A4 E5           	PUSH HL
1742  54A5 AF               XOR A
1743  54A6 CD 0E 4E         CALL GET_PAGE_INFO
1744  54A9 D9           	EXX
1745  54AA E1           	POP HL
1746  54AB F1           	POP AF
1747  54AC D9           	EXX
1748  54AD C5               PUSH BC
1749  54AE D5               PUSH DE
1750  54AF D9           	EXX
1751  54B0 F5           	PUSH AF
1752  54B1 E5           	PUSH HL
1753  54B2 D9           	EXX
1754  54B3 3A 41 F3         LD A, (RAMAD0)
1755  54B6 26 00            LD H, 0
1756  54B8 CD 55 4E         CALL LOCAL_ENASLT
1757  54BB FB           	EI
1758  54BC E1           	POP HL
1759  54BD C1           	POP BC
1760  54BE CD C8 54     	CALL .UPDATE_LOC
1761  54C1 D1               POP DE
1762  54C2 C1               POP BC
1763  54C3 CD 45 4E         CALL RESTORE_PAGE_INFO
1764  54C6 E1           	POP HL
1765  54C7 C9           	RET
1766  54C8
1767  54C8              .UPDATE_LOC:
1768  54C8              .L4:
1769  54C8 7E           	LD A, (HL)
1770  54C9 23           	INC HL
1771  54CA 23           	INC HL
1772  54CB E5           	PUSH HL
1773  54CC FD E1        	POP IY
1774  54CE D9           	EXX
1775  54CF CD 30 54     	CALL SPRSET_DELTA_POS
1776  54D2 D9           	EXX
1777  54D3 23          > INC HL
1777  54D4 23          > INC HL
1777  54D5 23          > INC HL
1777  54D6 23          > INC HL
1778  54D7 10 EF        	DJNZ .L4
1779  54D9 C9           	RET
1780  54DA              ; *******************************************************************************************************
1781  54DA               ENDIF
1782  54DA
1783  54DA               IFNDEF EXCLUDE_BLIT_CMDS
1784  54DA              ; *******************************************************************************************************
1785  54DA              ; function rotates mask and data of several characters and applies to background data
1786  54DA              ; this handles x-shift from 0 to 4
1787  54DA              ; contains self-modifying code that is set-up from external function
1788  54DA              ; input HL=pointer to mask data
1789  54DA              ; input HL'=pointer to character data
1790  54DA              ; input DE=output buffer containing background data
1791  54DA              ; input BC=DE+8
1792  54DA              ; input A=number of characters to process
1793  54DA              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1794  54DA              SHIFT04:
1795  54DA 08           	EX AF, AF'
1796  54DB 7E           	LD A, (HL) ; get mask
1797  54DC D9           	EXX
1798  54DD 57           	LD D, A
1799  54DE 1E FF        	LD E, #FF
1800  54E0 37           	SCF
1801  54E1              .M1:
1802  54E1 18 FE        	JR .M1 ; this is self-modifying part
1803  54E3 CB 1A        	RR D
1804  54E5 CB 1B        	RR E
1805  54E7 CB 1A        	RR D
1806  54E9 CB 1B        	RR E
1807  54EB CB 1A        	RR D
1808  54ED CB 1B        	RR E
1809  54EF CB 1A        	RR D
1810  54F1 CB 1B        	RR E
1811  54F3
1812  54F3 46           	LD B, (HL) ; get data
1813  54F4 0E 00        	LD C, 0
1814  54F6              .M2:
1815  54F6 18 FE        	JR .M2 ; also self-modifying part
1816  54F8 CB 38        	SRL B
1817  54FA CB 19        	RR C
1818  54FC CB 38        	SRL B
1819  54FE CB 19        	RR C
1820  5500 CB 38        	SRL B
1821  5502 CB 19        	RR C
1822  5504 CB 38        	SRL B
1823  5506 CB 19        	RR C
1824  5508
1825  5508 D9           	EXX
1826  5509 1A           	LD A, (DE) ; background
1827  550A D9           	EXX
1828  550B A2           	AND D
1829  550C B0           	OR B
1830  550D D9           	EXX
1831  550E 12           	LD (DE), A
1832  550F
1833  550F 0A           	LD A, (BC)
1834  5510 D9           	EXX
1835  5511 A3           	AND E
1836  5512 B1           	OR C
1837  5513 23           	INC HL
1838  5514 D9           	EXX
1839  5515 02           	LD (BC), A
1840  5516
1841  5516 23           	INC HL
1842  5517 13           	INC DE
1843  5518 03           	INC BC
1844  5519
1845  5519 08           	EX AF, AF'
1846  551A 3D           	DEC A
1847  551B C2 DA 54     	JP NZ, SHIFT04
1848  551E C9           	RET
1849  551F              ; *******************************************************************************************************
1850  551F
1851  551F              ; *******************************************************************************************************
1852  551F              ; function rotates mask and data of several characters and applies to background data
1853  551F              ; this handles x-shift from 5 to 8
1854  551F              ; contains self-modifying code that is set-up from external function
1855  551F              ; input HL=pointer to mask data
1856  551F              ; input HL'=pointer to character data
1857  551F              ; input DE=output buffer containing background data
1858  551F              ; input BC=DE+8
1859  551F              ; input A=number of characters to process
1860  551F              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1861  551F              SHIFT58:
1862  551F 08           	EX AF, AF'
1863  5520 7E           	LD A, (HL) ; get mask
1864  5521 D9           	EXX
1865  5522 57           	LD D, A
1866  5523 1E FF        	LD E, #FF
1867  5525 37           	SCF
1868  5526              .M1:
1869  5526 18 FE        	JR .M1 ; this is self-modifying part
1870  5528 CB 12        	RL D
1871  552A CB 13        	RL E
1872  552C CB 12        	RL D
1873  552E CB 13        	RL E
1874  5530 CB 12        	RL D
1875  5532 CB 13        	RL E
1876  5534
1877  5534 46           	LD B, (HL)
1878  5535 0E 00        	LD C, 0
1879  5537              .M2:
1880  5537 18 FE        	JR .M2 ; also self-modifying part
1881  5539 CB 20        	SLA B
1882  553B CB 11        	RL C
1883  553D CB 20        	SLA B
1884  553F CB 11        	RL C
1885  5541 CB 20        	SLA B
1886  5543 CB 11        	RL C
1887  5545
1888  5545 D9           	EXX
1889  5546 1A           	LD A, (DE) ; background
1890  5547 D9           	EXX
1891  5548 A3           	AND E
1892  5549 B1           	OR C
1893  554A D9           	EXX
1894  554B 12           	LD (DE), A
1895  554C
1896  554C 0A           	LD A, (BC)
1897  554D D9           	EXX
1898  554E A2           	AND D
1899  554F B0           	OR B
1900  5550 23           	INC HL
1901  5551 D9           	EXX
1902  5552 02           	LD (BC), A
1903  5553
1904  5553 23           	INC HL
1905  5554 13           	INC DE
1906  5555 03           	INC BC
1907  5556
1908  5556 08           	EX AF, AF'
1909  5557 3D           	DEC A
1910  5558 C2 1F 55     	JP NZ, SHIFT58
1911  555B C9           	RET
1912  555C              ; *******************************************************************************************************
1913  555C
1914  555C              ; *******************************************************************************************************
1915  555C              ; routine that shifts one row of characters
1916  555C              ; contains self-modifying code that is set-up from external function
1917  555C              ; input HL=pointer to mask data
1918  555C              ; input HL'=pointer to character data
1919  555C              ; input DE=output buffer containing background data
1920  555C              ; input A=number of characters to process
1921  555C              ; input IX=pointer to structure describing input data
1922  555C              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1923  555C              SHIFT_ROW:
1924  555C F5           	PUSH AF
1925  555D ED 53 01 4D  		LD (BLIT_TMP1), DE
1926  5561 E5           		PUSH HL
1927  5562 CD A5 55     			CALL .ADDYSHIFT
1928  5565 E1           		POP HL
1929  5566 ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1930  556A              .L1:
1931  556A 3E 08        		LD A, 8
1932  556C DD 96 02     		SUB (IX+2) ; y shift
1933  556F              .CALL1:
1934  556F CD 00 00     		CALL 0
1935  5572 DD 7E 02     		LD A, (IX+2); y shift
1936  5575 B7           		OR A
1937  5576 28 26        		JR Z, .DONE
1938  5578 ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1939  557C E5           		PUSH HL
1940  557D CD B3 55     			CALL .DETONEXTROW
1941  5580 E1           		POP HL
1942  5581              .CALL2:
1943  5581 CD 00 00     		CALL 0
1944  5584 ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1945  5588 E5           		PUSH HL
1946  5589 CD AD 55     			CALL .ADD8
1947  558C E1           		POP HL
1948  558D ED 53 01 4D  		LD (BLIT_TMP1), DE
1949  5591 ED 5B 03 4D  		LD DE, (BLIT_TMP2)
1950  5595 E5           		PUSH HL
1951  5596 CD AD 55     			CALL .ADD8
1952  5599 E1           		POP HL
1953  559A ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1954  559E              .DONE:
1955  559E F1           	POP AF
1956  559F 3D           	DEC A
1957  55A0 C8           	RET Z
1958  55A1 F5           	PUSH AF
1959  55A2 C3 6A 55     	JP .L1
1960  55A5              .ADDYSHIFT:
1961  55A5 EB           	EX DE, HL
1962  55A6 16 00        	LD D, 0
1963  55A8 DD 5E 02     	LD E, (IX+2); y shift
1964  55AB 18 0C        	JR .MOVDEBC
1965  55AD              .ADD8:
1966  55AD 21 08 00     	LD HL, 8
1967  55B0 C3 B9 55     	JP .MOVDEBC
1968  55B3              .DETONEXTROW:
1969  55B3 DD 6E 06     	LD L, (IX+6)
1970  55B6 DD 66 07     	LD H, (IX+7) ; bkg add to value
1971  55B9              .MOVDEBC:
1972  55B9 19           	ADD HL, DE
1973  55BA 54           	LD D, H
1974  55BB 5D           	LD E, L
1975  55BC 01 08 00     	LD BC, 8
1976  55BF 09           	ADD HL, BC
1977  55C0 44           	LD B, H
1978  55C1 4D           	LD C, L
1979  55C2 C9           	RET
1980  55C3              ; *******************************************************************************************************
1981  55C3
1982  55C3              ; *******************************************************************************************************
1983  55C3              ; function rotates mask and character data and applies it to background
1984  55C3              ; input IX=pointer to structure describing input data
1985  55C3              ; +0  DW horizontal shift count 0-7 (low byte used)
1986  55C3              ; +2  DW vertical shift count 0-7 (low byte used)
1987  55C3              ; +4  DW background data start;
1988  55C3              ; +6  DW background add to value to next row of background data
1989  55C3              ; +8  DW mask data start;
1990  55C3              ; +10  DW character data start;
1991  55C3              ; +12 DW character&mask add to value to next row of data
1992  55C3              ; +14 DW columns (low byte used)
1993  55C3              ; +16 DW rows (low byte used)
1994  55C3              SHIFT_MERGE_CHARACTER:
1995  55C3 DD 7E 00     	LD A, (IX) ; shift
1996  55C6 FE 05        	CP 5
1997  55C8 38 25        	JR C, .RIGHT
1998  55CA              	; shifts 5-7, use rotate towards left 1-3
1999  55CA 21 1F 55     	LD HL, SHIFT58
2000  55CD 22 70 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2001  55D0 22 82 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2002  55D3 D6 05        	SUB 5
2003  55D5 28 0D        	JR Z, .L1
2004  55D7 87           	ADD A, A
2005  55D8 87           	ADD A, A
2006  55D9 67           	LD H, A
2007  55DA 2E 18        	LD L, #18 ; JR opcode
2008  55DC 22 26 55     	LD (SHIFT58.M1), HL
2009  55DF 22 37 55     	LD (SHIFT58.M2), HL
2010  55E2 18 32        	JR .DO
2011  55E4              .L1:
2012  55E4 21 00 00     	LD HL, 0 ; 2xNOP opcode
2013  55E7 22 26 55     	LD (SHIFT58.M1), HL
2014  55EA 22 37 55     	LD (SHIFT58.M2), HL
2015  55ED 18 27        	JR .DO
2016  55EF              .RIGHT:
2017  55EF              	; shifts 0-4, rotate towards right
2018  55EF 21 DA 54     	LD HL, SHIFT04
2019  55F2 22 70 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2020  55F5 22 82 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2021  55F8 FE 04        	CP 4
2022  55FA 28 11        	JR Z, .R1
2023  55FC D6 04        	SUB 4
2024  55FE ED 44        	NEG
2025  5600 87           	ADD A, A
2026  5601 87           	ADD A, A
2027  5602 67           	LD H, A
2028  5603 2E 18        	LD L, #18 ; JR opcode
2029  5605 22 E1 54     	LD (SHIFT04.M1), HL
2030  5608 22 F6 54     	LD (SHIFT04.M2), HL
2031  560B 18 09        	JR .DO
2032  560D              .R1:
2033  560D 21 00 00     	LD HL, 0 ; 2xNOP opcode
2034  5610 22 E1 54     	LD (SHIFT04.M1), HL
2035  5613 22 F6 54     	LD (SHIFT04.M2), HL
2036  5616              .DO:
2037  5616 DD 46 10     	LD B, (IX+16) ; rows
2038  5619 DD 6E 08     	LD L, (IX+8)
2039  561C DD 66 09     	LD H, (IX+9) ; mask data
2040  561F DD 5E 04     	LD E, (IX+4)
2041  5622 DD 56 05     	LD D, (IX+5) ; background data
2042  5625 D9           	EXX
2043  5626 DD 6E 0A     	LD L, (IX+10)
2044  5629 DD 66 0B     	LD H, (IX+11) ; character data
2045  562C D9           	EXX
2046  562D              .LOOP:
2047  562D C5           	PUSH BC
2048  562E E5           		PUSH HL
2049  562F D5           			PUSH DE
2050  5630 D9           				EXX
2051  5631 E5           				PUSH HL
2052  5632 D9           					EXX
2053  5633 DD 7E 0E     					LD A, (IX+14) ; columns
2054  5636              .CALL:
2055  5636 CD 5C 55     					CALL SHIFT_ROW
2056  5639 E1           				POP HL
2057  563A DD 5E 0C     				LD E, (IX+12)
2058  563D DD 56 0D     				LD D, (IX+13) ; char data to next row
2059  5640 19           				ADD HL, DE
2060  5641 D9           				EXX
2061  5642 E1           			POP HL
2062  5643 DD 5E 06     			LD E, (IX+6)
2063  5646 DD 56 07     			LD D, (IX+7) ; background to next row
2064  5649 19           			ADD HL, DE
2065  564A EB           			EX DE, HL
2066  564B E1           		POP HL
2067  564C DD 4E 0C     		LD C, (IX+12)
2068  564F DD 46 0D     		LD B, (IX+13) ; char data to next row
2069  5652 09           		ADD HL, BC
2070  5653 C1           	POP BC
2071  5654 10 D7        	DJNZ .LOOP
2072  5656 C9           	RET
2073  5657              ; *******************************************************************************************************
2074  5657
2075  5657               IFDEF BLIT_WITH_STRUCT_POINTER
2076  5657              ; *******************************************************************************************************
2077  5657              ; function to handle CALL BLIT basic extension
2078  5657              ; rotates 1-bit character drawing horizontally with mask and character data and
2079  5657              ; fuses with background data and applies vertical shift too
2080  5657              ; BLIT ( INT request_data_ptr )
2081  5657              ; request_data_ptr described in SHIFT_MERGE_CHARACTER
2082  5657              ; will put ram in page 0 also, page 1 is already there
2083  5657              BLIT:
2084  5657              	; opening (
2085  5657 CD D3 4F     	CALL CHKCHAR
2086  565A 28           	DB '('
2087  565B              	; get pointer to request struct
2088  565B DD 21 2F 54  	LD IX, FRMQNT
2089  565F CD 59 01     	CALL CALBAS
2090  5662 D5           	PUSH DE
2091  5663              	; ending )
2092  5663 CD D3 4F     	CALL CHKCHAR
2093  5666 29           	DB ')'
2094  5667
2095  5667 DD E1        	POP IX ; pointer to request struct
2096  5669
2097  5669 E5           	PUSH HL ; save position in BASIC buffer
2098  566A
2099  566A FD 21 71 56  	LD IY, .RET
2100  566E C3 CE 4E     	JP ENABLE_PAGE0
2101  5671              .RET:
2102  5671 FB           	EI
2103  5672 CD C3 55     	CALL SHIFT_MERGE_CHARACTER
2104  5675
2105  5675 D1               POP DE
2106  5676 C1               POP BC
2107  5677 CD 45 4E         CALL RESTORE_PAGE_INFO
2108  567A
2109  567A E1           	POP HL
2110  567B C9           	RET
2111  567C              ; *******************************************************************************************************
2112  567C               ENDIF
2113  567C
2114  567C              ; *******************************************************************************************************
2115  567C              ; generic function to implement tiling
2116  567C              ; should be modified to call appropriate function for memory or vram
2117  567C              ; input IX=pointer to following structure
2118  567C              ; +00 tile_data_ptr
2119  567C              ; +02 tile_rows
2120  567C              ; +04 tile_columns
2121  567C              ; +06 destination_address
2122  567C              ; +08 dest_to_next_row_add_to_value
2123  567C              ; +10 num_horizontal_tiles
2124  567C              ; +12 num_vertical_tiles
2125  567C              ; modifies AF, BC, DE, HL
2126  567C              TILE:
2127  567C DD 6E 06     	LD L, (IX+6)
2128  567F DD 66 07     	LD H, (IX+7) ; destination address
2129  5682 22 01 4D     	LD (TILETMP1), HL
2130  5685 DD 46 0C     	LD B, (IX+12) ; vertical tile number
2131  5688              .L1:
2132  5688 C5           	PUSH BC
2133  5689 DD 6E 00     		LD L, (IX+0)
2134  568C DD 66 01     		LD H, (IX+1) ; tile address
2135  568F 22 03 4D     		LD (TILETMP2), HL
2136  5692 DD 46 02     		LD B, (IX+2) ; tile rows
2137  5695              .L2:
2138  5695 C5           		PUSH BC
2139  5696              .CALL1:
2140  5696 CD 00 00     			CALL 0
2141  5699 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
2142  569C              .L3:
2143  569C C5           			PUSH BC
2144  569D 2A 03 4D     				LD HL, (TILETMP2)
2145  56A0 DD 46 04     				LD B, (IX+4) ; tile columns
2146  56A3              .L4:
2147  56A3 C5           				PUSH BC
2148  56A4              .CALL2:
2149  56A4 CD 00 00     					CALL 0
2150  56A7 C1           				POP BC
2151  56A8 10 F9        				DJNZ .L4
2152  56AA C1           			POP BC
2153  56AB 10 EF        			DJNZ .L3
2154  56AD 22 03 4D     			LD (TILETMP2), HL
2155  56B0 2A 01 4D     			LD HL, (TILETMP1)
2156  56B3 DD 5E 08     			LD E, (IX+8)
2157  56B6 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
2158  56B9 19           			ADD HL, DE
2159  56BA 22 01 4D     			LD (TILETMP1), HL
2160  56BD C1           		POP BC
2161  56BE 10 D5        		DJNZ .L2
2162  56C0 C1           	POP BC
2163  56C1 10 C5        	DJNZ .L1
2164  56C3 C9           	RET
2165  56C4              ; *******************************************************************************************************
2166  56C4
2167  56C4              ; *******************************************************************************************************
2168  56C4              ; function to handle CALL TILERAM basic extension
2169  56C4              ; fills memory with tiles
2170  56C4              ; fuses with background data and applies vertical shift too
2171  56C4              ; TILERAM ( INT request_data_ptr )
2172  56C4              ; request_data_ptr described in TILE
2173  56C4              ; will put ram in page 0 also, page 1 is already there
2174  56C4              TILERAM:
2175  56C4              	; opening (
2176  56C4 CD D3 4F     	CALL CHKCHAR
2177  56C7 28           	DB '('
2178  56C8              	; get pointer to request struct
2179  56C8 DD 21 2F 54  	LD IX, FRMQNT
2180  56CC CD 59 01     	CALL CALBAS
2181  56CF D5           	PUSH DE
2182  56D0              	; ending )
2183  56D0 CD D3 4F     	CALL CHKCHAR
2184  56D3 29           	DB ')'
2185  56D4
2186  56D4 DD E1        	POP IX ; pointer to request struct
2187  56D6
2188  56D6 E5           	PUSH HL ; save position in BASIC buffer
2189  56D7
2190  56D7 FD 21 DE 56  	LD IY, .RET
2191  56DB C3 CE 4E     	JP ENABLE_PAGE0
2192  56DE              .RET:
2193  56DE FB           	EI
2194  56DF              	; set RAM functions to call
2195  56DF 21 F5 56     	LD HL, .TILECOPY
2196  56E2 22 A5 56     	LD (TILE.CALL2+1), HL
2197  56E5 21 06 57     	LD HL, .SETDESTROW
2198  56E8 22 97 56     	LD (TILE.CALL1+1), HL
2199  56EB CD 7C 56     	CALL TILE
2200  56EE
2201  56EE D1               POP DE
2202  56EF C1               POP BC
2203  56F0 CD 45 4E         CALL RESTORE_PAGE_INFO
2204  56F3
2205  56F3 E1           	POP HL
2206  56F4 C9           	RET
2207  56F5              .TILECOPY:
2208  56F5 ED A0       > LDI
2208  56F7 ED A0       > LDI
2208  56F9 ED A0       > LDI
2208  56FB ED A0       > LDI
2208  56FD ED A0       > LDI
2208  56FF ED A0       > LDI
2208  5701 ED A0       > LDI
2208  5703 ED A0       > LDI
2209  5705 C9           	RET
2210  5706              .SETDESTROW:
2211  5706 ED 5B 01 4D  	LD DE, (TILETMP1)
2212  570A C9           	RET
2213  570B              ; *******************************************************************************************************
2214  570B
2215  570B              ; *******************************************************************************************************
2216  570B              ; function to handle CALL TILEVRM basic extension
2217  570B              ; fills vram with tiles
2218  570B              ; fuses with background data and applies vertical shift too
2219  570B              ; TILEVRM ( INT request_data_ptr )
2220  570B              ; request_data_ptr described in TILE
2221  570B              ; will put ram in page 0 also, page 1 is already there
2222  570B              TILEVRM:
2223  570B              	; opening (
2224  570B CD D3 4F     	CALL CHKCHAR
2225  570E 28           	DB '('
2226  570F              	; get pointer to request struct
2227  570F DD 21 2F 54  	LD IX, FRMQNT
2228  5713 CD 59 01     	CALL CALBAS
2229  5716 D5           	PUSH DE
2230  5717              	; ending )
2231  5717 CD D3 4F     	CALL CHKCHAR
2232  571A 29           	DB ')'
2233  571B
2234  571B DD E1        	POP IX ; pointer to request struct
2235  571D
2236  571D E5           	PUSH HL ; save position in BASIC buffer
2237  571E
2238  571E FD 21 25 57  	LD IY, .RET
2239  5722 C3 CE 4E     	JP ENABLE_PAGE0
2240  5725              .RET:
2241  5725 FB           	EI
2242  5726              	; set RAM functions to call
2243  5726 21 3C 57     	LD HL, .TILECOPY
2244  5729 22 A5 56     	LD (TILE.CALL2+1), HL
2245  572C 21 42 57     	LD HL, .SETDESTROW
2246  572F 22 97 56     	LD (TILE.CALL1+1), HL
2247  5732 CD 7C 56     	CALL TILE
2248  5735
2249  5735 D1               POP DE
2250  5736 C1               POP BC
2251  5737 CD 45 4E         CALL RESTORE_PAGE_INFO
2252  573A
2253  573A E1           	POP HL
2254  573B C9           	RET
2255  573C              .TILECOPY:
2256  573C 01 98 08     	LD BC, #0898
2257  573F               IFNDEF EXCLUDE_VRAM_CMDS
2258  573F C3 A8 51     	JP MEMVRM.BBYTECOPY
2259  5742               ELSE
2260  5742 ~            .BBYTECOPY:
2261  5742 ~            	OUTI
2262  5742 ~            	JP	NZ, .BBYTECOPY
2263  5742 ~            	RET
2264  5742               ENDIF
2265  5742              .SETDESTROW:
2266  5742 2A 01 4D     	LD HL, (TILETMP1)
2267  5745 F3           	DI
2268  5746 CD 03 4E     	CALL SETWRT_LOCAL
2269  5749 FB           	EI
2270  574A C9           	RET
2271  574B              ; *******************************************************************************************************
2272  574B
2273  574B              ; *******************************************************************************************************
2274  574B              ; generic function to implement rectangle data copy
2275  574B              ; should be modified to call appropriate function for memory or vram
2276  574B              ; input IX=pointer to following structure
2277  574B              ; +00 source data pointer
2278  574B              ; +02 num bytes in a row
2279  574B              ; +04 number of rows
2280  574B              ; +06 source add-to value till next row
2281  574B              ; +08 destination address
2282  574B              ; +10 destination add-to value till next row
2283  574B              ; modifies AF, BC, DE, HL
2284  574B              RECTANGLE_COPY:
2285  574B DD 6E 00     	LD L, (IX+0)
2286  574E DD 66 01     	LD H, (IX+1) ; source address
2287  5751 DD 5E 08     	LD E, (IX+8)
2288  5754 DD 56 09     	LD D, (IX+9) ; destination
2289  5757 DD 46 04     	LD B, (IX+4) ; row number
2290  575A              .L1:
2291  575A C5           	PUSH BC
2292  575B E5           		PUSH HL
2293  575C D5           			PUSH DE
2294  575D DD 4E 02     				LD C, (IX+2)
2295  5760 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2296  5763              .CALL1:
2297  5763 CD 00 00     				CALL 0 ; set destination address from DE
2298  5766              .CALL2:
2299  5766 CD 00 00     				CALL 0 ; copy data fn
2300  5769 E1           			POP HL
2301  576A DD 4E 0A     			LD C, (IX+10)
2302  576D DD 46 0B     			LD B, (IX+11) ; destination add-to
2303  5770 09           			ADD HL, BC
2304  5771 EB           			EX DE, HL
2305  5772 E1           		POP HL
2306  5773 DD 4E 06     		LD C, (IX+6)
2307  5776 DD 46 07     		LD B, (IX+7) ; src add-to
2308  5779 09           		ADD HL, BC
2309  577A C1           	POP BC
2310  577B 10 DD        	DJNZ .L1
2311  577D C9           	RET
2312  577E              ; *******************************************************************************************************
2313  577E
2314  577E              ; *******************************************************************************************************
2315  577E              ; function to handle CALL BOXMEMCPY basic extension
2316  577E              ; copies data with window like boundaries to ram
2317  577E              ; BOXMEMCPY ( INT request_data_ptr )
2318  577E              ; request_data_ptr described in RECTANGLE_COPY
2319  577E              ; will put ram in page 0 also, page 1 is already there
2320  577E              BOXMEMCPY:
2321  577E              	; opening (
2322  577E CD D3 4F     	CALL CHKCHAR
2323  5781 28           	DB '('
2324  5782              	; get pointer to request struct
2325  5782 DD 21 2F 54  	LD IX, FRMQNT
2326  5786 CD 59 01     	CALL CALBAS
2327  5789 D5           	PUSH DE
2328  578A              	; ending )
2329  578A CD D3 4F     	CALL CHKCHAR
2330  578D 29           	DB ')'
2331  578E
2332  578E DD E1        	POP IX ; pointer to request struct
2333  5790
2334  5790 E5           	PUSH HL ; save position in BASIC buffer
2335  5791
2336  5791 FD 21 98 57  	LD IY, .RET
2337  5795 C3 CE 4E     	JP ENABLE_PAGE0
2338  5798              .RET:
2339  5798 FB           	EI
2340  5799              	; set RAM functions to call
2341  5799 21 00 00     	LD HL, 0
2342  579C 22 63 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2343  579F 22 65 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2344  57A2 21 ED B0     	LD HL, #B0ED ; LDIR
2345  57A5 22 67 57     	LD (RECTANGLE_COPY.CALL1+4), HL
2346  57A8 CD 4B 57     	CALL RECTANGLE_COPY
2347  57AB
2348  57AB D1               POP DE
2349  57AC C1               POP BC
2350  57AD CD 45 4E         CALL RESTORE_PAGE_INFO
2351  57B0
2352  57B0 E1           	POP HL
2353  57B1 C9           	RET
2354  57B2              ; *******************************************************************************************************
2355  57B2
2356  57B2              ; *******************************************************************************************************
2357  57B2              ; function to handle CALL BOXMEMVRM basic extension
2358  57B2              ; copies data with window like boundaries to ram
2359  57B2              ; BOXMEMVRM ( INT request_data_ptr )
2360  57B2              ; request_data_ptr described in RECTANGLE_COPY
2361  57B2              ; will put ram in page 0 also, page 1 is already there
2362  57B2              BOXMEMVRM:
2363  57B2              	; opening (
2364  57B2 CD D3 4F     	CALL CHKCHAR
2365  57B5 28           	DB '('
2366  57B6              	; get pointer to request struct
2367  57B6 DD 21 2F 54  	LD IX, FRMQNT
2368  57BA CD 59 01     	CALL CALBAS
2369  57BD D5           	PUSH DE
2370  57BE              	; ending )
2371  57BE CD D3 4F     	CALL CHKCHAR
2372  57C1 29           	DB ')'
2373  57C2
2374  57C2 DD E1        	POP IX ; pointer to request struct
2375  57C4
2376  57C4 E5           	PUSH HL ; save position in BASIC buffer
2377  57C5
2378  57C5 FD 21 CC 57  	LD IY, .RET
2379  57C9 C3 CE 4E     	JP ENABLE_PAGE0
2380  57CC              .RET:
2381  57CC FB           	EI
2382  57CD              	; set RAM functions to call
2383  57CD 21 EB 57     	LD HL, .SETDEST
2384  57D0 22 64 57     	LD (RECTANGLE_COPY.CALL1+1), HL
2385  57D3 21 F3 57     	LD HL, .COPYDATA
2386  57D6 22 67 57     	LD (RECTANGLE_COPY.CALL2+1), HL
2387  57D9 3E CD        	LD A, #CD ; CALL
2388  57DB 32 63 57     	LD (RECTANGLE_COPY.CALL1), A
2389  57DE 32 66 57     	LD (RECTANGLE_COPY.CALL2), A
2390  57E1 CD 4B 57     	CALL RECTANGLE_COPY
2391  57E4
2392  57E4 D1               POP DE
2393  57E5 C1               POP BC
2394  57E6 CD 45 4E         CALL RESTORE_PAGE_INFO
2395  57E9
2396  57E9 E1           	POP HL
2397  57EA C9           	RET
2398  57EB              .SETDEST:
2399  57EB EB           	EX DE, HL
2400  57EC F3           	DI
2401  57ED CD 03 4E     	CALL SETWRT_LOCAL
2402  57F0 FB           	EI
2403  57F1 EB           	EX DE, HL
2404  57F2 C9           	RET
2405  57F3              .COPYDATA:
2406  57F3 41           	LD B, C
2407  57F4 0E 98        	LD C, #98
2408  57F6               IFNDEF EXCLUDE_VRAM_CMDS
2409  57F6 C3 A8 51     	JP MEMVRM.BBYTECOPY
2410  57F9               ELSE
2411  57F9 ~            	JP TILEVRM.BBYTECOPY
2412  57F9               ENDIF
2413  57F9              ; *******************************************************************************************************
2414  57F9               ENDIF
2415  57F9
2416  57F9              EXT_END:
2417  57F9
# file closed: asm\main.asm
