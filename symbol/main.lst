# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; DEFINE EXCLUDE_SOUND_PLAYER
   4  4000              ; DEFINE EXCLUDE_RAM_CMDS
   5  4000              ; DEFINE EXCLUDE_VRAM_CMDS
   6  4000              ; DEFINE EXCLUDE_BLIT_CMDS
   7  4000              ; DEFINE EXCLUDE_SPRITE_CMDS
   8  4000              ; DEFINE EXCLUDE_GENCAL
   9  4000
  10  4000              CHPUT   EQU     #A2
  11  4000              CALBAS	EQU		#159
  12  4000              ERRHAND EQU     #406F
  13  4000              FRMEVL  EQU     #4C64
  14  4000              FRESTR	EQU		#67D0
  15  4000              ; FRMQNT = formula quantificator
  16  4000              ; input HL=pointer to current program expression
  17  4000              ; output HL=next address
  18  4000              ; output DE=integer datum
  19  4000              FRMQNT	EQU		#542F
  20  4000              ; GETBYT = get byte parameter
  21  4000              ; input HL=pointer to current program expression
  22  4000              ; output HL=next address
  23  4000              ; output A=E=byte read
  24  4000              GETBYT	EQU		#521C
  25  4000              CHRGTR  EQU     #4666
  26  4000              SYNCHR	EQU		#558C
  27  4000              VALTYP  EQU     #F663
  28  4000              USR     EQU     #F7F8
  29  4000              PROCNM	EQU		#FD89
  30  4000              BIOS_FILVRM  EQU     #56
  31  4000              CLIKSW	EQU		#F3DB
  32  4000              ATRBAS	EQU		#F928
  33  4000
  34  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  35  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  36  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  37  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  38  4000              EXPTBL	EQU #FCC1
  39  4000              SCRMOD	EQU #FCAF ; current screen mode
  40  4000
  41  4000              ; BASIC error codes
  42  4000              ;01 NEXT without FOR
  43  4000              ;02 Syntax error
  44  4000              ;03 RETURN without GOSUB
  45  4000              ;04 Out of DATA
  46  4000              ;05 Illegal function call
  47  4000              ;06 Overflow
  48  4000              ;07 Out of memory
  49  4000              ;08 Undefined line number
  50  4000              ;09 Subscript out of range
  51  4000              ;10 Redimensioned array
  52  4000              ;11 Division by zero
  53  4000              ;12 Illegal direct
  54  4000              ;13 Type mismatch
  55  4000              ;14 Out of string space
  56  4000              ;15 String too long
  57  4000              ;16 String formula too complex
  58  4000              ;17 Can't CONTINUE
  59  4000              ;18 Undefined user function
  60  4000              ;19 Device I/O error
  61  4000              ;20 Verify error
  62  4000              ;21 No RESUME
  63  4000              ;22 RESUME without error
  64  4000              ;23 Unprintable error
  65  4000              ;24 Missing operand
  66  4000              ;25 Line buffer overflow
  67  4000              ;50 FIELD overflow
  68  4000              ;51 Internal error
  69  4000              ;52 Bad file number
  70  4000              ;53 File not found
  71  4000              ;54 File already open
  72  4000              ;55 Input past end
  73  4000              ;56 Bad file name
  74  4000              ;57 Direct statement in file
  75  4000              ;58 Sequential I/O only
  76  4000              ;59 File not OPEN
  77  4000
  78  4000
  79  4000               ; simulate cartridge with BASIC extension
  80  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  80  4004 82 4F 00 00
  80  4008 00 00 00 00
  80  400C 00 00 00 00
  81  4010
  82  4010              ; this location #4010 stores last location used by basic extension
  83  4010              ; free memory after that point
  84  4010 E0 57         DW EXT_END
  85  4012
  86  4012              ; this location #4012 stores extension version in DAA format
  87  4012              ; first byte is major version and second minor
  88  4012 00 70         DB #00, #70
  89  4014
  90  4014              ; binary included AKG player compiled at #4014
  91  4014               IFNDEF EXCLUDE_SOUND_PLAYER
  92  4014              	INCBIN "bin/AKG.bin"
  93  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
  94  4CF0               ENDIF
  95  4CF0
  96  4CF0              ORIG.HTIMI:
  97  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  97  4CF4 00
  98  4CF5               EXPORT ORIG.HTIMI
  99  4CF5
 100  4CF5               IFNDEF EXCLUDE_SOUND_PLAYER
 101  4CF5              MUSIC_INIT_STATUS:
 102  4CF5 00            DB 0
 103  4CF6              SFX_INIT_STATUS:
 104  4CF6 00            DB 0
 105  4CF7              SOUND_ENABLED:
 106  4CF7 00            DB 0
 107  4CF8               ENDIF
 108  4CF8
 109  4CF8               IFNDEF EXCLUDE_SPRITE_CMDS
 110  4CF8              SPRATR_INIT_STATUS:
 111  4CF8 00            DB 0
 112  4CF9              SPRATR_UPDATE_FLAG:
 113  4CF9 00 00         DW 0
 114  4CFB              SPRATR_DATA:
 115  4CFB 00 00         DW 0
 116  4CFD              SPRFLICKER_ENABLED:
 117  4CFD 00            DB 0
 118  4CFE              ; to support sprite flicker
 119  4CFE              FLICKER:
 120  4CFE 00            DB 0
 121  4CFF               ENDIF
 122  4CFF
 123  4CFF              ; to temporarily store stack pointer
 124  4CFF              TMPSP:
 125  4CFF 00 00         DW 0
 126  4D01
 127  4D01              ; temp variables for BLIT, TILE functions
 128  4D01               IFNDEF EXCLUDE_BLIT_CMDS
 129  4D01              TILETMP1:
 130  4D01              BLIT_TMP1:
 131  4D01 00 00         DW 0
 132  4D03              TILETMP2:
 133  4D03              BLIT_TMP2:
 134  4D03 00 00         DW 0
 135  4D05               ENDIF
 136  4D05
 137  4D05              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 138  4D05              ; per starting letter, if no commands with this letter, NULL value
 139  4D05              CMDS:
 140  4D05 00 00            DW 0 ; A
 141  4D07 C1 4D            DW CMDS_B ; B
 142  4D09 00 00            DW 0 ; C
 143  4D0B 00 00            DW 0 ; D
 144  4D0D 00 00            DW 0 ; E
 145  4D0F 4C 4D            DW CMDS_F; F
 146  4D11 5F 4D            DW CMDS_G; G
 147  4D13 00 00            DW 0 ; H
 148  4D15 00 00            DW 0 ; I
 149  4D17 00 00            DW 0 ; J
 150  4D19 00 00            DW 0 ; K
 151  4D1B 00 00            DW 0 ; L
 152  4D1D 39 4D            DW CMDS_M ; M
 153  4D1F 00 00            DW 0 ; N
 154  4D21 00 00            DW 0 ; O
 155  4D23 00 00            DW 0 ; P
 156  4D25 00 00            DW 0 ; Q
 157  4D27 00 00            DW 0 ; R
 158  4D29 73 4D            DW CMDS_S ; S
 159  4D2B E1 4D            DW CMDS_T ; T
 160  4D2D 00 00            DW 0 ; U
 161  4D2F 69 4D            DW CMDS_V ; V
 162  4D31 00 00            DW 0 ; W
 163  4D33 00 00            DW 0 ; X
 164  4D35 00 00            DW 0 ; Y
 165  4D37 00 00            DW 0 ; Z
 166  4D39
 167  4D39              CMDS_M:
 168  4D39               IFNDEF EXCLUDE_VRAM_CMDS
 169  4D39 4D 45 4D 56      DB "MEMVRM", 0
 169  4D3D 52 4D 00
 170  4D40 1F 51            DW MEMVRM
 171  4D42               ENDIF
 172  4D42               IFNDEF EXCLUDE_RAM_CMDS
 173  4D42 4D 45 4D 43  	DB "MEMCPY", 0
 173  4D46 50 59 00
 174  4D49 DE 4F        	DW MEMCPY
 175  4D4B               ENDIF
 176  4D4B 00           	DB 0
 177  4D4C              CMDS_F:
 178  4D4C               IFNDEF EXCLUDE_VRAM_CMDS
 179  4D4C 46 49 4C 56      DB "FILVRM", 0
 179  4D50 52 4D 00
 180  4D53 21 50            DW FILVRM
 181  4D55               ENDIF
 182  4D55               IFNDEF EXCLUDE_RAM_CMDS
 183  4D55 46 49 4C 52      DB "FILRAM", 0
 183  4D59 41 4D 00
 184  4D5C 68 50            DW FILRAM
 185  4D5E               ENDIF
 186  4D5E 00               DB 0
 187  4D5F              CMDS_G:
 188  4D5F               IFNDEF EXCLUDE_GENCAL
 189  4D5F 47 45 4E 43      DB "GENCAL", 0
 189  4D63 41 4C 00
 190  4D66 C6 50            DW GENCAL
 191  4D68               ENDIF
 192  4D68 00           	DB	0
 193  4D69              CMDS_V:
 194  4D69               IFNDEF EXCLUDE_VRAM_CMDS
 195  4D69 56 52 4D 4D  	DB "VRMMEM", 0
 195  4D6D 45 4D 00
 196  4D70 9A 51        	DW VRMMEM
 197  4D72               ENDIF
 198  4D72 00           	DB 0
 199  4D73              CMDS_S:
 200  4D73               IFNDEF EXCLUDE_SPRITE_CMDS
 201  4D73 53 50 52 53  	DB "SPRSET", 0
 201  4D77 45 54 00
 202  4D7A 82 53        	DW SPRSET
 203  4D7C 53 50 52 47  	DB "SPRGRPMOV", 0
 203  4D80 52 50 4D 4F
 203  4D84 56 00
 204  4D86 40 54        	DW SPRGRPMOV
 205  4D88               ENDIF
 206  4D88               IFNDEF EXCLUDE_SOUND_PLAYER
 207  4D88 53 4E 44 53  	DB "SNDSFX", 0
 207  4D8C 46 58 00
 208  4D8F D8 52        	DW SNDSFX
 209  4D91 53 4E 44 50  	DB "SNDPLYON", 0
 209  4D95 4C 59 4F 4E
 209  4D99 00
 210  4D9A A2 52        	DW SNDPLYON
 211  4D9C 53 4E 44 50  	DB "SNDPLYOFF", 0
 211  4DA0 4C 59 4F 46
 211  4DA4 46 00
 212  4DA6 B5 52        	DW SNDPLYOFF
 213  4DA8 53 4E 44 50  	DB "SNDPLYINI", 0
 213  4DAC 4C 59 49 4E
 213  4DB0 49 00
 214  4DB2 58 52        	DW SNDPLYINIT
 215  4DB4               ENDIF
 216  4DB4               IFNDEF EXCLUDE_SPRITE_CMDS
 217  4DB4 53 50 52 41  	DB "SPRATRINI", 0
 217  4DB8 54 52 49 4E
 217  4DBC 49 00
 218  4DBE 32 53        	DW SPRATRINI
 219  4DC0               ENDIF
 220  4DC0 00           	DB 0
 221  4DC1              CMDS_B:
 222  4DC1               IFNDEF EXCLUDE_BLIT_CMDS
 223  4DC1 42 4C 49 54  	DB "BLIT", 0
 223  4DC5 00
 224  4DC6 3E 56        	DW BLIT
 225  4DC8 42 4F 58 4D  	DB "BOXMEMCPY", 0
 225  4DCC 45 4D 43 50
 225  4DD0 59 00
 226  4DD2 65 57        	DW BOXMEMCPY
 227  4DD4 42 4F 58 4D  	DB "BOXMEMVRM", 0
 227  4DD8 45 4D 56 52
 227  4DDC 4D 00
 228  4DDE 99 57        	DW BOXMEMVRM
 229  4DE0               ENDIF
 230  4DE0 00           	DB 0
 231  4DE1              CMDS_T:
 232  4DE1               IFNDEF EXCLUDE_BLIT_CMDS
 233  4DE1 54 49 4C 45  	DB "TILERAM", 0
 233  4DE5 52 41 4D 00
 234  4DE9 AB 56        	DW TILERAM
 235  4DEB 54 49 4C 45  	DB "TILEVRM", 0
 235  4DEF 56 52 4D 00
 236  4DF3 F2 56        	DW TILEVRM
 237  4DF5               ENDIF
 238  4DF5 00           	DB 0
 239  4DF6
 240  4DF6              ; ****************************************************************************************************
 241  4DF6              ; function sets VRAM address
 242  4DF6              ; input HL=address
 243  4DF6              ; modifies AF
 244  4DF6              SETWRT_LOCAL:
 245  4DF6 7D           	LD	A, L
 246  4DF7 D3 99        	OUT	(099H), A
 247  4DF9 7C           	LD	A, H
 248  4DFA E6 3F        	AND	03FH
 249  4DFC F6 40        	OR	040H
 250  4DFE D3 99        	OUT	(099H), A
 251  4E00 C9           	RET
 252  4E01              ; ****************************************************************************************************
 253  4E01
 254  4E01              ; ****************************************************************************************************
 255  4E01              ; function gets slot and subslot data for specific page
 256  4E01              ; input A=page (0, 1 or 2)
 257  4E01              ; output B = 0A8H register value
 258  4E01              ; output D = 0 is no subslots, 1 if yes
 259  4E01              ; output C = 0A8H value when page 3 slot equals to requested page slot
 260  4E01              ; output E = subslot value if present
 261  4E01              ; modifies AF, BC, DE, HL
 262  4E01              GET_PAGE_INFO:
 263  4E01 6F               LD L, A
 264  4E02 C6 C1            ADD A, low (EXPTBL)
 265  4E04 32 0E 4E         LD (GET_PAGE_INFO_L1+1), A
 266  4E07 DB A8            IN A, (0A8H)
 267  4E09 47               LD B, A
 268  4E0A E6 3F            AND 03FH
 269  4E0C 4F               LD C, A
 270  4E0D              GET_PAGE_INFO_L1:
 271  4E0D 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 272  4E10 E6 80            AND 080H
 273  4E12 28 1B            JR Z, GET_PAGE_INFO_L2
 274  4E14                  ; expanded
 275  4E14 2D               DEC L
 276  4E15 FA 34 4E         JP M, GET_PAGE_INFO_L3
 277  4E18 2D               DEC L
 278  4E19 FA 32 4E         JP M, GET_PAGE_INFO_L4
 279  4E1C                  ; page 2
 280  4E1C 07               RLCA
 281  4E1D 07               RLCA
 282  4E1E              GET_PAGE_INFO_L5:
 283  4E1E E6 C0            AND 0C0H
 284  4E20 B1               OR C
 285  4E21 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 286  4E23 4F               LD C, A
 287  4E24 3A FF FF         LD A, (0FFFFH)
 288  4E27 2F               CPL
 289  4E28 5F               LD E, A
 290  4E29 16 01            LD D, 1
 291  4E2B 78               LD A, B ; return stack
 292  4E2C D3 A8            OUT (0A8H), A
 293  4E2E C9               RET
 294  4E2F              GET_PAGE_INFO_L2:
 295  4E2F                  ; not expanded
 296  4E2F 16 00            LD D, 0
 297  4E31 C9               RET
 298  4E32              GET_PAGE_INFO_L4:
 299  4E32                  ; page 1
 300  4E32 0F               RRCA
 301  4E33 0F               RRCA
 302  4E34              GET_PAGE_INFO_L3:
 303  4E34                  ; page 0
 304  4E34 0F               RRCA
 305  4E35 0F               RRCA
 306  4E36 18 E6            JR GET_PAGE_INFO_L5
 307  4E38              ; ****************************************************************************************************
 308  4E38
 309  4E38              ; ****************************************************************************************************
 310  4E38              ; function returns original slot and subslot info
 311  4E38              ; input B = 0A8H register value
 312  4E38              ; input D = 0 is no subslots, 1 if yes
 313  4E38              ; input C = 0A8H value when page 3 slot equals to requested page slot
 314  4E38              ; input E = subslot value if present
 315  4E38              ; modifies AF, disables interrupts
 316  4E38              RESTORE_PAGE_INFO:
 317  4E38 7A               LD A, D
 318  4E39 B7               OR A
 319  4E3A 28 08            JR Z, RESTORE_PAGE_INFO_L1
 320  4E3C 79               LD A, C
 321  4E3D F3           	DI
 322  4E3E D3 A8            OUT (0A8H), A
 323  4E40 7B               LD A, E
 324  4E41 32 FF FF         LD (0FFFFH), A
 325  4E44              RESTORE_PAGE_INFO_L1:
 326  4E44 78               LD A, B
 327  4E45 D3 A8            OUT (0A8H), A
 328  4E47 C9               RET
 329  4E48              ; ****************************************************************************************************
 330  4E48
 331  4E48              ; *******************************************************************************************************
 332  4E48              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 333  4E48              ; INPUT:  A = SLOT ID: EXXXSSPP
 334  4E48              ; E = EXPANDED FLAG
 335  4E48              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 336  4E48              ; PP = PRIMARY SLOT NUMBER
 337  4E48              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 338  4E48              ; CHANGES: AF, BC, DE
 339  4E48
 340  4E48              LOCAL_ENASLT:
 341  4E48 CD 68 4E         CALL L0353
 342  4E4B FA 55 4E         JP M, L0340
 343  4E4E DB A8            IN A, (0A8H)
 344  4E50 A1               AND C
 345  4E51 B0               OR B
 346  4E52 D3 A8            OUT (0A8H), A
 347  4E54 C9               RET
 348  4E55              L0340:
 349  4E55 E5               PUSH HL
 350  4E56 CD 8D 4E         CALL L0378
 351  4E59 4F               LD C, A
 352  4E5A 06 00            LD B, 0
 353  4E5C 7D               LD A, L
 354  4E5D A4               AND H
 355  4E5E B2               OR D
 356  4E5F 21 C5 FC         LD HL, 0FCC5H
 357  4E62 09               ADD HL, BC
 358  4E63 77               LD (HL), A
 359  4E64 E1               POP HL
 360  4E65 79               LD A, C
 361  4E66 18 E0            JR LOCAL_ENASLT
 362  4E68              L0353:
 363  4E68 F3               DI
 364  4E69 F5               PUSH AF
 365  4E6A 7C               LD A, H
 366  4E6B 07               RLCA
 367  4E6C 07               RLCA
 368  4E6D E6 03            AND 3
 369  4E6F 5F               LD E, A
 370  4E70 3E C0            LD A, 0C0H
 371  4E72              L035D:
 372  4E72 07               RLCA
 373  4E73 07               RLCA
 374  4E74 1D               DEC E
 375  4E75 F2 72 4E         JP P, L035D
 376  4E78 5F               LD E, A
 377  4E79 2F               CPL
 378  4E7A 4F               LD C, A
 379  4E7B F1               POP AF
 380  4E7C F5               PUSH AF
 381  4E7D E6 03            AND 3
 382  4E7F 3C               INC A
 383  4E80 47               LD B, A
 384  4E81 3E AB            LD A, 0ABH
 385  4E83              L036E:
 386  4E83 C6 55            ADD A, 055H
 387  4E85 10 FC            DJNZ L036E
 388  4E87 57               LD D, A
 389  4E88 A3               AND E
 390  4E89 47               LD B, A
 391  4E8A F1               POP AF
 392  4E8B A7               AND A
 393  4E8C C9               RET
 394  4E8D              L0378:
 395  4E8D F5               PUSH AF
 396  4E8E 7A               LD A, D
 397  4E8F E6 C0            AND 0C0H
 398  4E91 4F               LD C, A
 399  4E92 F1               POP AF
 400  4E93 F5               PUSH AF
 401  4E94 57               LD D, A
 402  4E95 DB A8            IN A, (0A8H)
 403  4E97 47               LD B, A
 404  4E98 E6 3F            AND 03FH
 405  4E9A B1               OR C
 406  4E9B D3 A8            OUT (0A8H), A
 407  4E9D 7A               LD A, D
 408  4E9E 0F               RRCA
 409  4E9F 0F               RRCA
 410  4EA0 E6 03            AND 3
 411  4EA2 57               LD D, A
 412  4EA3 3E AB            LD A, 0ABH
 413  4EA5              L0390:
 414  4EA5 C6 55            ADD A, 055H
 415  4EA7 15               DEC D
 416  4EA8 F2 A5 4E         JP P, L0390
 417  4EAB A3               AND E
 418  4EAC 57               LD D, A
 419  4EAD 7B               LD A, E
 420  4EAE 2F               CPL
 421  4EAF 67               LD H, A
 422  4EB0 3A FF FF         LD A, (0FFFFH)
 423  4EB3 2F               CPL
 424  4EB4 6F               LD L, A
 425  4EB5 A4               AND H
 426  4EB6 B2               OR D
 427  4EB7 32 FF FF         LD (0FFFFH), A
 428  4EBA 78               LD A, B
 429  4EBB D3 A8            OUT (0A8H), A
 430  4EBD F1               POP AF
 431  4EBE E6 03            AND 3
 432  4EC0 C9               RET
 433  4EC1              ; *******************************************************************************************************
 434  4EC1
 435  4EC1              ; *******************************************************************************************************
 436  4EC1              ; some common code to activate page 0 and place values needed to restore original page on stack
 437  4EC1              ; input IY=return address
 438  4EC1              ENABLE_PAGE0:
 439  4EC1 AF               XOR A
 440  4EC2 CD 01 4E         CALL GET_PAGE_INFO
 441  4EC5 C5               PUSH BC
 442  4EC6 D5               PUSH DE
 443  4EC7 3A 41 F3         LD A, (RAMAD0)
 444  4ECA 26 00            LD H, 0
 445  4ECC CD 48 4E         CALL LOCAL_ENASLT
 446  4ECF FD E9        	JP (IY)
 447  4ED1              ; *******************************************************************************************************
 448  4ED1
 449  4ED1               IFNDEF EXCLUDE_SPRITE_CMDS
 450  4ED1              ; *******************************************************************************************************
 451  4ED1              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 452  4ED1              ; struct {
 453  4ED1              ; DW y
 454  4ED1              ; DW x
 455  4ED1              ; DW pattern (0-31)
 456  4ED1              ; DW color
 457  4ED1              ; } [32]
 458  4ED1              ; will hide sprites whose location is outside of visible area
 459  4ED1              ; works in screen 1 and 2
 460  4ED1              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 461  4ED1              ; modifies AF, AF', BC, DE, HL
 462  4ED1              SPRATR_UPDATE:
 463  4ED1              	; check if initialized
 464  4ED1 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 465  4ED4 B7           	OR A
 466  4ED5 C8           	RET Z
 467  4ED6              	; check if update requested
 468  4ED6 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 469  4ED9 7E           	LD A, (HL)
 470  4EDA B7           	OR A
 471  4EDB C8           	RET Z
 472  4EDC              	; check screen mode
 473  4EDC 3A AF FC     	LD A, (SCRMOD)
 474  4EDF 3D           	DEC A
 475  4EE0 28 02        	JR Z, .L0 ; screen 1
 476  4EE2 3D           	DEC A
 477  4EE3 C0           	RET NZ ; not screen 2
 478  4EE4              .L0:
 479  4EE4 06 20        	LD B, 32 ; sprite number
 480  4EE6 0E 98        	LD C, #98 ; register for vdp data output
 481  4EE8              	; set VDP address
 482  4EE8 2A 28 F9     	LD HL, (ATRBAS)
 483  4EEB 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
 484  4EEE B7           	OR A
 485  4EEF 28 03        	JR Z, .L3
 486  4EF1 3A FE 4C     	LD A, (FLICKER)
 487  4EF4              .L3:
 488  4EF4 5F           	LD E, A
 489  4EF5 08           	EX AF, AF'
 490  4EF6 7B           	LD A, E
 491  4EF7 87           	ADD A, A
 492  4EF8 87           	ADD A, A
 493  4EF9 16 00        	LD D, 0
 494  4EFB 5F           	LD E, A
 495  4EFC 19           	ADD HL, DE
 496  4EFD CD F6 4D     	CALL SETWRT_LOCAL
 497  4F00 ED 73 FF 4C  	LD (TMPSP), SP
 498  4F04 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
 499  4F08
 500  4F08              .LOOP:
 501  4F08 E1           	POP HL
 502  4F09 24           	INC H
 503  4F0A 28 0D        	JR Z, .L1 ; negative number above -256
 504  4F0C 25           	DEC H
 505  4F0D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 506  4F0F 7D           	LD A, L
 507  4F10 FE C0        	CP 192
 508  4F12 30 10        	JR NC, .OUT3
 509  4F14 3D           	DEC A ; due to VDP rule that top of screen is -1
 510  4F15 57           	LD D, A
 511  4F16 C3 34 4F     	JP .X
 512  4F19              .L1:
 513  4F19 7D           	LD A, L
 514  4F1A C6 10        	ADD 16
 515  4F1C FA 24 4F     	JP M, .OUT3 ; below -16
 516  4F1F 2D           	DEC L ; due to VDP rule that top of screen is -1
 517  4F20 55           	LD D, L
 518  4F21 C3 34 4F     	JP .X
 519  4F24              .OUT3:
 520  4F24 E1           	POP HL ; skip x value
 521  4F25              .OUT2:
 522  4F25 E1           	POP HL ; skip pattern
 523  4F26 E1           	POP HL ; skip color
 524  4F27 3E D1        	LD A, #D1
 525  4F29 D3 98        	OUT (#98), A ; sprite hidden
 526  4F2B D3 98        	OUT (#98), A ; value unimportant
 527  4F2D D3 98        	OUT (#98), A ; value unimportant
 528  4F2F D3 98        	OUT (#98), A ; value unimportant
 529  4F31 C3 58 4F     	JP .NEXT
 530  4F34              .X:
 531  4F34 E1           	POP HL
 532  4F35 24           	INC H
 533  4F36 28 08        	JR Z, .L2
 534  4F38 25           	DEC H
 535  4F39 20 EA        	JR NZ, .OUT2
 536  4F3B 1E 00        	LD E, 0 ; EC bit
 537  4F3D C3 49 4F     	JP .XY
 538  4F40              .L2:
 539  4F40 7D           	LD A, L
 540  4F41 C6 20        	ADD 32
 541  4F43 FA 25 4F     	JP M, .OUT2
 542  4F46 6F           	LD L, A
 543  4F47 1E 80        	LD E, #80
 544  4F49              .XY:
 545  4F49 ED 51        	OUT (C), D
 546  4F4B ED 69        	OUT (C), L
 547  4F4D E1           	POP HL ; pattern
 548  4F4E 7D           	LD A, L
 549  4F4F 87           	ADD A, A
 550  4F50 87           	ADD A, A ; needs to go at 4x
 551  4F51 D3 98        	OUT (#98), A
 552  4F53 E1           	POP HL ; color
 553  4F54 7D           	LD A, L
 554  4F55 B3           	OR E
 555  4F56 D3 98        	OUT (#98), A
 556  4F58              .NEXT:
 557  4F58 08           	EX AF, AF'
 558  4F59 3C           	INC A
 559  4F5A E6 1F        	AND 31
 560  4F5C C2 70 4F     	JP NZ, .NEXT2
 561  4F5F 08           	EX AF, AF'
 562  4F60 2A 28 F9     	LD HL, (ATRBAS)
 563  4F63              	; CALL SETWRT_LOCAL not allowed as SP modified
 564  4F63 7D           	LD	A, L
 565  4F64 D3 99        	OUT	(099H), A
 566  4F66 7C           	LD	A, H
 567  4F67 E6 3F        	AND	03FH
 568  4F69 F6 40        	OR	040H
 569  4F6B D3 99        	OUT	(099H), A
 570  4F6D C3 71 4F     	JP .NEXT3
 571  4F70              .NEXT2:
 572  4F70 08           	EX AF, AF'
 573  4F71              .NEXT3:
 574  4F71 10 95        	DJNZ .LOOP
 575  4F73 08           	EX AF, AF'
 576  4F74 3C           	INC A
 577  4F75 32 FE 4C     	LD (FLICKER), A
 578  4F78
 579  4F78 ED 7B FF 4C  	LD SP, (TMPSP)
 580  4F7C 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 581  4F7F 36 00        	LD (HL), 0 ; zero out update flag
 582  4F81 C9           	RET
 583  4F82              ; *******************************************************************************************************
 584  4F82               ENDIF
 585  4F82
 586  4F82              ; General BASIC CALL-instruction handler
 587  4F82              CALLHAND:
 588  4F82 E5           	PUSH HL
 589  4F83 21 05 4D     	LD	HL, CMDS ; pointer table based on starting letter
 590  4F86 3A 89 FD         LD A, (PROCNM)
 591  4F89 D6 41            SUB 'A'
 592  4F8B 87               ADD A, A
 593  4F8C 16 00            LD D, 0
 594  4F8E 5F               LD E, A
 595  4F8F 19               ADD HL, DE
 596  4F90 5E               LD E, (HL)
 597  4F91 23               INC HL
 598  4F92 56               LD D, (HL)
 599  4F93 7A               LD A, D
 600  4F94 B3               OR E
 601  4F95 28 24            JR Z, .CMDNOTRECOGNIZED
 602  4F97 EB               EX DE, HL
 603  4F98              .CHKCMD:
 604  4F98 11 89 FD     	LD	DE, PROCNM
 605  4F9B 1A           .LOOP:	LD	A,(DE)
 606  4F9C BE           	CP	(HL)
 607  4F9D 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 608  4F9F 13           	INC	DE
 609  4FA0 23           	INC	HL
 610  4FA1 A7           	AND	A
 611  4FA2 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 612  4FA4 5E           	LD	E,(HL)
 613  4FA5 23           	INC	HL
 614  4FA6 56           	LD	D,(HL)
 615  4FA7 E1           	POP	HL		; routine address
 616  4FA8 CD C9 4F     	CALL	GETPREVCHAR
 617  4FAB CD BD 4F     	CALL	.CALLDE		; Call routine
 618  4FAE A7           	AND	A
 619  4FAF C9           	RET
 620  4FB0
 621  4FB0              .TONEXTCMD:
 622  4FB0 0E FF        	LD	C,0FFH
 623  4FB2 AF           	XOR	A
 624  4FB3 ED B1        	CPIR			; Skip to end of instruction name
 625  4FB5 23           	INC	HL
 626  4FB6 23           	INC	HL		; Skip address
 627  4FB7 BE           	CP	(HL)
 628  4FB8 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 629  4FBA E1           	POP	HL
 630  4FBB              .CMDNOTRECOGNIZED:
 631  4FBB 37               SCF
 632  4FBC C9           	RET
 633  4FBD
 634  4FBD              .CALLDE:
 635  4FBD D5           	PUSH	DE
 636  4FBE C9           	RET
 637  4FBF
 638  4FBF              ;---------------------------
 639  4FBF
 640  4FBF              ;GETSTRPNT:
 641  4FBF              ; OUT:
 642  4FBF              ; HL = String Address
 643  4FBF              ; B  = Lenght
 644  4FBF              ;        LD      HL,(USR)
 645  4FBF              ;        LD      B,(HL)
 646  4FBF              ;        INC     HL
 647  4FBF              ;        LD      E,(HL)
 648  4FBF              ;        INC     HL
 649  4FBF              ;        LD      D,(HL)
 650  4FBF              ;        EX      DE,HL
 651  4FBF              ;        RET
 652  4FBF
 653  4FBF              ;EVALTXTPARAM:
 654  4FBF              ;	CALL	CHKCHAR
 655  4FBF              ;	DEFB	"("             ; Check for (
 656  4FBF              ;	LD	IX,FRMEVL
 657  4FBF              ;	CALL	CALBAS		; Evaluate expression
 658  4FBF              ;       LD      A,(VALTYP)
 659  4FBF              ;        CP      3               ; Text type?
 660  4FBF              ;        JP      NZ,TYPE_MISMATCH
 661  4FBF              ;        PUSH	HL
 662  4FBF              ;        LD	IX,FRESTR         ; Free the temporary string
 663  4FBF              ;        CALL	CALBAS
 664  4FBF              ;        POP	HL
 665  4FBF              ;	CALL	CHKCHAR
 666  4FBF              ;	DEFB	")"             ; Check for )
 667  4FBF              ;        RET
 668  4FBF
 669  4FBF
 670  4FBF              CHKCHAR:
 671  4FBF CD C9 4F     	CALL	GETPREVCHAR	; Get previous basic char
 672  4FC2 E3           	EX	(SP),HL
 673  4FC3 BE           	CP	(HL) 	        ; Check if good char
 674  4FC4 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 675  4FC6 23           	INC	HL
 676  4FC7 E3           	EX	(SP),HL
 677  4FC8 23           	INC	HL		; Get next basic char
 678  4FC9
 679  4FC9              GETPREVCHAR:
 680  4FC9 2B           	DEC	HL
 681  4FCA DD 21 66 46  	LD	IX,CHRGTR
 682  4FCE C3 59 01     	JP      CALBAS
 683  4FD1
 684  4FD1
 685  4FD1              TYPE_MISMATCH:
 686  4FD1 1E 0D            LD E, 13 ; Type mismatch
 687  4FD3 18 02            JR THROW_ERROR
 688  4FD5
 689  4FD5              SYNTAX_ERROR:
 690  4FD5 1E 02            LD E, 2 ; Syntax error
 691  4FD7              THROW_ERROR:
 692  4FD7 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 693  4FDB C3 59 01     	JP	CALBAS
 694  4FDE
 695  4FDE              ;---------------------------
 696  4FDE
 697  4FDE               IFNDEF EXCLUDE_RAM_CMDS
 698  4FDE              ; *******************************************************************************************************
 699  4FDE              ; function to handle CALL MEMCPY basic extension
 700  4FDE              ; _MEMCPY ( INT source,
 701  4FDE              ;			INT destination,
 702  4FDE              ;			INT count,
 703  4FDE              ; will put ram in page 0 also, page 1 is already there
 704  4FDE              MEMCPY:
 705  4FDE              	; opening (
 706  4FDE CD BF 4F     	CALL CHKCHAR
 707  4FE1 28           	DB '('
 708  4FE2              	; get source address
 709  4FE2 DD 21 2F 54  	LD IX, FRMQNT
 710  4FE6 CD 59 01     	CALL CALBAS
 711  4FE9 D5           	PUSH DE
 712  4FEA              	; comma
 713  4FEA CD BF 4F     	CALL CHKCHAR
 714  4FED 2C           	DB ','
 715  4FEE              	; get destination address
 716  4FEE DD 21 2F 54  	LD IX, FRMQNT
 717  4FF2 CD 59 01     	CALL CALBAS
 718  4FF5 D5           	PUSH DE
 719  4FF6              	; comma
 720  4FF6 CD BF 4F     	CALL CHKCHAR
 721  4FF9 2C           	DB ','
 722  4FFA              	; get length
 723  4FFA DD 21 2F 54  	LD IX, FRMQNT
 724  4FFE CD 59 01     	CALL CALBAS
 725  5001 D5           	PUSH DE
 726  5002              	; ending )
 727  5002 CD BF 4F     	CALL CHKCHAR
 728  5005 29           	DB ')'
 729  5006
 730  5006              	; save position
 731  5006 E5           	PUSH HL
 732  5007 DD E1        	POP IX
 733  5009
 734  5009 C1           	POP BC ; count
 735  500A D1           	POP DE ; destination
 736  500B E1           	POP HL ; source
 737  500C D9           	EXX
 738  500D              	; enable page 0
 739  500D FD 21 14 50  	LD IY, .RET
 740  5011 C3 C1 4E     	JP ENABLE_PAGE0
 741  5014              .RET:
 742  5014 FB           	EI
 743  5015 D9           	EXX
 744  5016 ED B0        	LDIR
 745  5018 D1               POP DE
 746  5019 C1               POP BC
 747  501A CD 38 4E         CALL RESTORE_PAGE_INFO
 748  501D DD E5        	PUSH IX
 749  501F E1           	POP HL
 750  5020 C9           	RET
 751  5021              ; *******************************************************************************************************
 752  5021               ENDIF
 753  5021               IFNDEF EXCLUDE_VRAM_CMDS
 754  5021              ; *******************************************************************************************************
 755  5021              ; function to handle CALL FILVRM basic extension
 756  5021              ; FILVRM ( INT offset,
 757  5021              ;		   INT count,
 758  5021              ;		   BYTE value,
 759  5021              ;		   BYTE wait_vsync) >0 = true
 760  5021              ; wait_vsync will issue HALT before copying
 761  5021              FILVRM:
 762  5021              	; opening (
 763  5021 CD BF 4F     	CALL CHKCHAR
 764  5024 28           	DB '('
 765  5025              	; get offset address
 766  5025 DD 21 2F 54  	LD IX, FRMQNT
 767  5029 CD 59 01     	CALL CALBAS
 768  502C D5           	PUSH DE
 769  502D              	; comma
 770  502D CD BF 4F     	CALL CHKCHAR
 771  5030 2C           	DB ','
 772  5031              	; get count
 773  5031 DD 21 2F 54  	LD IX, FRMQNT
 774  5035 CD 59 01     	CALL CALBAS
 775  5038 D5           	PUSH DE
 776  5039              	; comma
 777  5039 CD BF 4F     	CALL CHKCHAR
 778  503C 2C           	DB ','
 779  503D              	; get value
 780  503D DD 21 1C 52  	LD IX, GETBYT
 781  5041 CD 59 01     	CALL CALBAS
 782  5044 F5           	PUSH AF
 783  5045              	; comma
 784  5045 CD BF 4F     	CALL CHKCHAR
 785  5048 2C           	DB ','
 786  5049              	; get vsync wait
 787  5049 DD 21 1C 52  	LD IX, GETBYT
 788  504D CD 59 01     	CALL CALBAS
 789  5050 F5           	PUSH AF
 790  5051              	; ending )
 791  5051 CD BF 4F     	CALL CHKCHAR
 792  5054 29           	DB ')'
 793  5055
 794  5055 FB               EI
 795  5056              	; save position
 796  5056 E5           	PUSH HL
 797  5057 DD E1        	POP IX
 798  5059
 799  5059              	; syntax ok
 800  5059              	; wait for vsync if needed
 801  5059 F1           	POP AF
 802  505A B7           	OR A
 803  505B 28 01        	JR Z, .L1
 804  505D 76           	HALT
 805  505E
 806  505E              .L1:
 807  505E F1               POP AF ; value
 808  505F C1               POP BC ; count
 809  5060 E1               POP HL ; offset
 810  5061 CD 56 00         CALL BIOS_FILVRM
 811  5064
 812  5064              .L3:
 813  5064 DD E5        	PUSH IX
 814  5066 E1           	POP HL
 815  5067 C9           	RET
 816  5068              ; *******************************************************************************************************
 817  5068               ENDIF
 818  5068
 819  5068               IFNDEF EXCLUDE_RAM_CMDS
 820  5068              ; *******************************************************************************************************
 821  5068              ; function to handle CALL FILRAM basic extension
 822  5068              ; FILRAM ( INT start address,
 823  5068              ;		   INT count,
 824  5068              ;		   BYTE value,
 825  5068              ; will put ram in page 0 also, page 1 is already there
 826  5068              FILRAM:
 827  5068              	; opening (
 828  5068 CD BF 4F     	CALL CHKCHAR
 829  506B 28           	DB '('
 830  506C              	; get start address
 831  506C DD 21 2F 54  	LD IX, FRMQNT
 832  5070 CD 59 01     	CALL CALBAS
 833  5073 D5           	PUSH DE
 834  5074              	; comma
 835  5074 CD BF 4F     	CALL CHKCHAR
 836  5077 2C           	DB ','
 837  5078              	; get count
 838  5078 DD 21 2F 54  	LD IX, FRMQNT
 839  507C CD 59 01     	CALL CALBAS
 840  507F D5           	PUSH DE
 841  5080              	; comma
 842  5080 CD BF 4F     	CALL CHKCHAR
 843  5083 2C           	DB ','
 844  5084              	; get value
 845  5084 DD 21 1C 52  	LD IX, GETBYT
 846  5088 CD 59 01     	CALL CALBAS
 847  508B F5           	PUSH AF
 848  508C              	; ending )
 849  508C CD BF 4F     	CALL CHKCHAR
 850  508F 29           	DB ')'
 851  5090
 852  5090              	; save position
 853  5090 E5           	PUSH HL
 854  5091 DD E1        	POP IX
 855  5093
 856  5093 D1           	POP DE ; actually AF
 857  5094 C1           	POP BC ; count
 858  5095 E1           	POP HL ; start address
 859  5096 78           	LD A, B
 860  5097 B7           	OR A
 861  5098 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 862  509A B1           	OR C
 863  509B 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 864  509D 79           	LD A, C
 865  509E 3D           	DEC A
 866  509F 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 867  50A1              	; one byte to fill
 868  50A1 72           	LD (HL), D
 869  50A2 18 12        	JR .EXIT
 870  50A4              .L1:
 871  50A4 D9           	EXX
 872  50A5              	; enable page 0
 873  50A5 FD 21 AC 50  	LD IY, .RET
 874  50A9 C3 C1 4E     	JP ENABLE_PAGE0
 875  50AC              .RET:
 876  50AC FB           	EI
 877  50AD D9           	EXX
 878  50AE CD BA 50     	CALL .FILLVALUE
 879  50B1 D1               POP DE
 880  50B2 C1               POP BC
 881  50B3 CD 38 4E         CALL RESTORE_PAGE_INFO
 882  50B6              .EXIT:
 883  50B6 DD E5        	PUSH IX
 884  50B8 E1           	POP HL
 885  50B9 C9           	RET
 886  50BA
 887  50BA              .FILLVALUE:
 888  50BA 72               LD (HL), D
 889  50BB 54               LD D, H
 890  50BC 5D               LD E, L
 891  50BD 13               INC DE
 892  50BE 0B               DEC BC
 893  50BF ED B0            LDIR
 894  50C1 C9               RET
 895  50C2              ; *******************************************************************************************************
 896  50C2               ENDIF
 897  50C2
 898  50C2               IFNDEF EXCLUDE_GENCAL
 899  50C2              ; *******************************************************************************************************
 900  50C2              ; function to handle CALL GENCAL basic extension
 901  50C2              ; GENCAL ( INT fn_addr, = address of the function to call
 902  50C2              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 903  50C2              ; output values of reristers will also be stored at reg_list_ptr
 904  50C2              GENCAL_VAR_SP:
 905  50C2 00 00            DW 0
 906  50C4              GENCAL_VAR_SP2:
 907  50C4 00 00            DW 0
 908  50C6              GENCAL:
 909  50C6              	; opening (
 910  50C6 CD BF 4F     	CALL CHKCHAR
 911  50C9 28           	DB '('
 912  50CA              	; get function address
 913  50CA DD 21 2F 54  	LD IX, FRMQNT
 914  50CE CD 59 01     	CALL CALBAS
 915  50D1 D5           	PUSH DE
 916  50D2              	; comma
 917  50D2 CD BF 4F     	CALL CHKCHAR
 918  50D5 2C           	DB ','
 919  50D6              	; get pointer to register list
 920  50D6 DD 21 2F 54  	LD IX, FRMQNT
 921  50DA CD 59 01     	CALL CALBAS
 922  50DD D5           	PUSH DE
 923  50DE              	; ending )
 924  50DE CD BF 4F     	CALL CHKCHAR
 925  50E1 29           	DB ')'
 926  50E2
 927  50E2              	; save BASIC token position
 928  50E2 E5           	PUSH HL
 929  50E3 D9               EXX
 930  50E4 E1           	POP HL ; HL'=next basic token
 931  50E5 D9               EXX
 932  50E6
 933  50E6 E1               POP HL ; get pointer to register values
 934  50E7 ED 73 C2 50      LD (GENCAL_VAR_SP), SP
 935  50EB F3               DI
 936  50EC F9               LD SP, HL
 937  50ED F1               POP AF
 938  50EE C1               POP BC
 939  50EF D1               POP DE
 940  50F0 E1               POP HL
 941  50F1 DD E1            POP IX
 942  50F3 FD E1            POP IY
 943  50F5 D9               EXX
 944  50F6 ED 73 C4 50      LD (GENCAL_VAR_SP2), SP
 945  50FA ED 7B C2 50      LD SP, (GENCAL_VAR_SP)
 946  50FE FB               EI
 947  50FF D1               POP DE ; get function to call
 948  5100 E5               PUSH HL
 949  5101 CD 1C 51         CALL .EXXDECALL
 950  5104 F3               DI
 951  5105 ED 73 C2 50      LD (GENCAL_VAR_SP), SP
 952  5109 ED 7B C4 50      LD SP, (GENCAL_VAR_SP2)
 953  510D FD E5            PUSH IY
 954  510F DD E5            PUSH IX
 955  5111 E5               PUSH HL
 956  5112 D5               PUSH DE
 957  5113 C5               PUSH BC
 958  5114 F5               PUSH AF
 959  5115 ED 7B C2 50      LD SP, (GENCAL_VAR_SP)
 960  5119 FB               EI
 961  511A E1               POP HL
 962  511B C9           	RET
 963  511C
 964  511C              .EXXDECALL:
 965  511C D5               PUSH DE
 966  511D D9               EXX
 967  511E C9               RET
 968  511F              ; *******************************************************************************************************
 969  511F               ENDIF
 970  511F
 971  511F               IFNDEF EXCLUDE_VRAM_CMDS
 972  511F              ; *******************************************************************************************************
 973  511F              ; function to handle CALL MEMVRM basic extension
 974  511F              ; copies from RAM to VRAM
 975  511F              ; _MEMVRM ( INT source,
 976  511F              ;			INT destination,
 977  511F              ;			INT count,
 978  511F              ;			BYTE wait_vsync) >0 = true
 979  511F              ; will put ram in page 0 also, page 1 is already there
 980  511F              ; wait_vsync will issue HALT before copying
 981  511F              MEMVRM:
 982  511F              	; opening (
 983  511F CD BF 4F     	CALL CHKCHAR
 984  5122 28           	DB '('
 985  5123              	; get source address
 986  5123 DD 21 2F 54  	LD IX, FRMQNT
 987  5127 CD 59 01     	CALL CALBAS
 988  512A D5           	PUSH DE
 989  512B              	; comma
 990  512B CD BF 4F     	CALL CHKCHAR
 991  512E 2C           	DB ','
 992  512F              	; get destination address
 993  512F DD 21 2F 54  	LD IX, FRMQNT
 994  5133 CD 59 01     	CALL CALBAS
 995  5136 D5           	PUSH DE
 996  5137              	; comma
 997  5137 CD BF 4F     	CALL CHKCHAR
 998  513A 2C           	DB ','
 999  513B              	; get length
1000  513B DD 21 2F 54  	LD IX, FRMQNT
1001  513F CD 59 01     	CALL CALBAS
1002  5142 D5           	PUSH DE
1003  5143              	; comma
1004  5143 CD BF 4F     	CALL CHKCHAR
1005  5146 2C           	DB ','
1006  5147              	; get vsync wait
1007  5147 DD 21 1C 52  	LD IX, GETBYT
1008  514B CD 59 01     	CALL CALBAS
1009  514E F5           	PUSH AF
1010  514F              	; ending )
1011  514F CD BF 4F     	CALL CHKCHAR
1012  5152 29           	DB ')'
1013  5153
1014  5153                  ; save position in BASIC text
1015  5153 E5           	PUSH HL
1016  5154 DD E1        	POP IX
1017  5156
1018  5156 F1           	POP AF ; wait vsync
1019  5157 B7           	OR A
1020  5158 28 03        	JR Z, .L1
1021  515A FB               EI
1022  515B 76           	HALT
1023  515C F3           	DI
1024  515D              .L1:
1025  515D              	; pop LDIR parameters and store away for later
1026  515D C1           	POP BC ; count
1027  515E D1           	POP DE ; vram destination
1028  515F E1           	POP HL ; ram source
1029  5160 D9           	EXX
1030  5161 FD 21 68 51   	LD IY, .RET
1031  5165 C3 C1 4E     	JP ENABLE_PAGE0
1032  5168              .RET:
1033  5168 FB           	EI
1034  5169 D9           	EXX
1035  516A CD 76 51     	CALL .LDIRVM
1036  516D D1               POP DE
1037  516E C1               POP BC
1038  516F CD 38 4E         CALL RESTORE_PAGE_INFO
1039  5172 DD E5        	PUSH IX
1040  5174 E1           	POP HL
1041  5175 C9           	RET
1042  5176
1043  5176              .LDIRVM:
1044  5176 EB           	EX DE, HL
1045  5177 F3           	DI
1046  5178 CD F6 4D     	CALL SETWRT_LOCAL
1047  517B FB           	EI
1048  517C EB           	EX DE, HL
1049  517D 78           	LD A, B
1050  517E B7           	OR A
1051  517F 28 0D        	JR Z, .L3
1052  5181 C5           	PUSH BC
1053  5182 0E 98        	LD C, #98
1054  5184              .L2:
1055  5184 50           	LD D, B
1056  5185 06 00        	LD B, 0
1057  5187 CD 94 51     	CALL .BBYTECOPY
1058  518A 42           	LD B, D
1059  518B 10 F7        	DJNZ .L2
1060  518D C1           	POP BC
1061  518E              .L3:
1062  518E 79           	LD A, C
1063  518F B7           	OR A
1064  5190 C8           	RET Z
1065  5191 41           	LD B, C
1066  5192 0E 98        	LD C, #98
1067  5194              .BBYTECOPY:
1068  5194 ED A3        	OUTI
1069  5196 C2 94 51     	JP	NZ, .BBYTECOPY
1070  5199 C9           	RET
1071  519A              ; *******************************************************************************************************
1072  519A               ENDIF
1073  519A
1074  519A               IFNDEF EXCLUDE_VRAM_CMDS
1075  519A              ; *******************************************************************************************************
1076  519A              ; function to handle CALL VRMMEM basic extension
1077  519A              ; copies from RAM to VRAM
1078  519A              ; _VRMMEM ( INT source,
1079  519A              ;			INT destination,
1080  519A              ;			INT count
1081  519A              ; will put ram in page 0 also, page 1 is already there
1082  519A              VRMMEM:
1083  519A              	; opening (
1084  519A CD BF 4F     	CALL CHKCHAR
1085  519D 28           	DB '('
1086  519E              	; get source address
1087  519E DD 21 2F 54  	LD IX, FRMQNT
1088  51A2 CD 59 01     	CALL CALBAS
1089  51A5 D5           	PUSH DE
1090  51A6              	; comma
1091  51A6 CD BF 4F     	CALL CHKCHAR
1092  51A9 2C           	DB ','
1093  51AA              	; get destination address
1094  51AA DD 21 2F 54  	LD IX, FRMQNT
1095  51AE CD 59 01     	CALL CALBAS
1096  51B1 D5           	PUSH DE
1097  51B2              	; comma
1098  51B2 CD BF 4F     	CALL CHKCHAR
1099  51B5 2C           	DB ','
1100  51B6              	; get length
1101  51B6 DD 21 2F 54  	LD IX, FRMQNT
1102  51BA CD 59 01     	CALL CALBAS
1103  51BD D5           	PUSH DE
1104  51BE              	; ending )
1105  51BE CD BF 4F     	CALL CHKCHAR
1106  51C1 29           	DB ')'
1107  51C2
1108  51C2                  ; save position in BASIC text
1109  51C2 E5           	PUSH HL
1110  51C3 DD E1        	POP IX
1111  51C5
1112  51C5 C1           	POP BC ; count
1113  51C6 D1           	POP DE ; destination
1114  51C7 E1           	POP HL ; source
1115  51C8 D9           	EXX
1116  51C9 FD 21 D0 51  	LD IY, .RET
1117  51CD C3 C1 4E     	JP ENABLE_PAGE0
1118  51D0              .RET:
1119  51D0 FB           	EI
1120  51D1 D9           	EXX
1121  51D2 CD DE 51     	CALL .LDIRMV
1122  51D5 D1               POP DE
1123  51D6 C1               POP BC
1124  51D7 CD 38 4E         CALL RESTORE_PAGE_INFO
1125  51DA DD E5        	PUSH IX
1126  51DC E1           	POP HL
1127  51DD C9           	RET
1128  51DE
1129  51DE              .LDIRMV:
1130  51DE              	; set VRAM address *exactly* as in ROM, otherwise corruption
1131  51DE 7D           	LD	A, L
1132  51DF F3           	DI
1133  51E0 D3 99        	OUT	(099H), A
1134  51E2 7C           	LD	A, H
1135  51E3 E6 3F        	AND	03FH
1136  51E5 D3 99        	OUT	(099H), A
1137  51E7 FB           	EI
1138  51E8              	;EX (SP), HL
1139  51E8              	;EX (SP), HL
1140  51E8              	;NOP
1141  51E8              	;NOP
1142  51E8              .L4:
1143  51E8 DB 98            IN A, (#98)
1144  51EA 12           	LD (DE), A
1145  51EB 13               INC DE
1146  51EC 0B               DEC BC
1147  51ED 79               LD A, C
1148  51EE B0               OR B
1149  51EF 20 F7            JR NZ, .L4
1150  51F1 C9               RET
1151  51F2              ; *******************************************************************************************************
1152  51F2               ENDIF
1153  51F2
1154  51F2              ; *******************************************************************************************************
1155  51F2              ; H.TIMI function
1156  51F2              MBGE_HTIMI:
1157  51F2               EXPORT MBGE_HTIMI
1158  51F2 F5           	PUSH AF
1159  51F3
1160  51F3               IFNDEF EXCLUDE_SPRITE_CMDS
1161  51F3 CD D1 4E     	CALL SPRATR_UPDATE
1162  51F6               ENDIF
1163  51F6
1164  51F6               IFNDEF EXCLUDE_SOUND_PLAYER
1165  51F6 3A F7 4C     	LD A, (SOUND_ENABLED)
1166  51F9 B7           	OR A
1167  51FA 28 2A        	JR Z, .EXIT
1168  51FC
1169  51FC              	; enable page 2
1170  51FC 3E 02            LD A, 2
1171  51FE CD 01 4E         CALL GET_PAGE_INFO
1172  5201 C5               PUSH BC
1173  5202 D5               PUSH DE
1174  5203 3A 43 F3         LD A, (RAMAD2)
1175  5206 26 80            LD H, 080H
1176  5208 CD 48 4E         CALL LOCAL_ENASLT
1177  520B              	; enable page 0
1178  520B AF               XOR A
1179  520C CD 01 4E         CALL GET_PAGE_INFO
1180  520F C5               PUSH BC
1181  5210 D5               PUSH DE
1182  5211 3A 41 F3         LD A, (RAMAD0)
1183  5214 26 00            LD H, 0
1184  5216 CD 48 4E         CALL LOCAL_ENASLT
1185  5219
1186  5219 CD 33 42     	CALL PLY_AKG_PLAY
1187  521C
1188  521C              	; restore page 0
1189  521C D1               POP DE
1190  521D C1               POP BC
1191  521E CD 38 4E         CALL RESTORE_PAGE_INFO
1192  5221              	; restore page 2
1193  5221 D1               POP DE
1194  5222 C1               POP BC
1195  5223 CD 38 4E         CALL RESTORE_PAGE_INFO
1196  5226               ENDIF
1197  5226
1198  5226              .EXIT:
1199  5226 F1           	POP AF
1200  5227 C3 F0 4C     	JP ORIG.HTIMI
1201  522A              ; *******************************************************************************************************
1202  522A
1203  522A              ; *******************************************************************************************************
1204  522A              ; interrupt handler when page 0 enabled
1205  522A              VBLANK:
1206  522A              	EXPORT VBLANK
1207  522A
1208  522A F5               PUSH AF
1209  522B              	; is VDP originator ?
1210  522B DB 99        	IN	A, (099H)
1211  522D A7           	AND	A
1212  522E F2 54 52     	JP P, .EXIT
1213  5231
1214  5231               IFNDEF EXCLUDE_SOUND_PLAYER
1215  5231 3A F7 4C     	LD A, (SOUND_ENABLED)
1216  5234 B7           	OR A
1217  5235 28 1D        	JR Z, .EXIT
1218  5237
1219  5237 C5               PUSH BC
1220  5238 D5               PUSH DE
1221  5239 E5               PUSH HL
1222  523A 08               EX AF, AF'
1223  523B D9               EXX
1224  523C F5               PUSH AF
1225  523D C5               PUSH BC
1226  523E D5               PUSH DE
1227  523F E5               PUSH HL
1228  5240 DD E5            PUSH IX
1229  5242 FD E5            PUSH IY
1230  5244
1231  5244 CD 33 42     	CALL PLY_AKG_PLAY
1232  5247
1233  5247 FD E1            POP IY
1234  5249 DD E1            POP IX
1235  524B E1               POP HL
1236  524C D1               POP DE
1237  524D C1               POP BC
1238  524E F1               POP AF
1239  524F 08               EX AF, AF'
1240  5250 D9               EXX
1241  5251 E1               POP HL
1242  5252 D1               POP DE
1243  5253 C1               POP BC
1244  5254               ENDIF
1245  5254
1246  5254              .EXIT:
1247  5254 F1           	POP AF
1248  5255 FB           	EI
1249  5256 ED 4D        	RETI
1250  5258              ; *******************************************************************************************************
1251  5258
1252  5258               IFNDEF EXCLUDE_SOUND_PLAYER
1253  5258              ; *******************************************************************************************************
1254  5258              ; function to handle CALL SNDPLYINIT basic extension
1255  5258              ; initializes sound player
1256  5258              ; _SNDPLYINIT ( INT music_offset,
1257  5258              ;				INT sfx_offset, can be -1 if no SFX
1258  5258              ; will put ram in page 0 also, page 1 is already there
1259  5258              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1260  5258              SNDPLYINIT:
1261  5258              	; opening (
1262  5258 CD BF 4F     	CALL CHKCHAR
1263  525B 28           	DB '('
1264  525C              	; get music address
1265  525C DD 21 2F 54  	LD IX, FRMQNT
1266  5260 CD 59 01     	CALL CALBAS
1267  5263 D5           	PUSH DE
1268  5264              	; comma
1269  5264 CD BF 4F     	CALL CHKCHAR
1270  5267 2C           	DB ','
1271  5268              	; get sfx address
1272  5268 DD 21 2F 54  	LD IX, FRMQNT
1273  526C CD 59 01     	CALL CALBAS
1274  526F D5           	PUSH DE
1275  5270              	; ending )
1276  5270 CD BF 4F     	CALL CHKCHAR
1277  5273 29           	DB ')'
1278  5274
1279  5274                  ; save position in BASIC text
1280  5274 44           	LD B, H
1281  5275 4D           	LD C, L
1282  5276
1283  5276              	; pop LDIR parameters and store away for later
1284  5276 D1           	POP DE ; sfx address
1285  5277 E1           	POP HL ; music address
1286  5278 C5           	PUSH BC ; basic text location
1287  5279 D9           	EXX
1288  527A FD 21 81 52  	LD IY, .RET
1289  527E C3 C1 4E     	JP ENABLE_PAGE0
1290  5281              .RET:
1291  5281 D9           	EXX
1292  5282
1293  5282 D5           	PUSH DE
1294  5283 AF           	XOR A
1295  5284              	; HL = music location
1296  5284 CD 62 41     	CALL PLY_AKG_INIT
1297  5287 3E 01        	LD A, 1
1298  5289 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1299  528C
1300  528C E1           	POP HL ; SFX
1301  528D              	; check if SFX address -1
1302  528D 23           	INC HL
1303  528E 7D           	LD A, L
1304  528F B4           	OR H
1305  5290 28 09        	JR Z,.L1
1306  5292 2B           	DEC HL
1307  5293 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1308  5296 3E 01        	LD A, 1
1309  5298 32 F6 4C     	LD (SFX_INIT_STATUS), A
1310  529B              .L1:
1311  529B D1               POP DE
1312  529C C1               POP BC
1313  529D CD 38 4E         CALL RESTORE_PAGE_INFO
1314  52A0
1315  52A0 E1           	POP HL
1316  52A1 C9           	RET
1317  52A2              ; *******************************************************************************************************
1318  52A2
1319  52A2              ; *******************************************************************************************************
1320  52A2              ; function to handle CALL SNDPLYON basic extension
1321  52A2              ; enables sound player
1322  52A2              ; _SNDPLYON
1323  52A2              ; sets SOUND_ENABLED variable to 1 if init call was done
1324  52A2              ; if not throws out of data error
1325  52A2              SNDPLYON:
1326  52A2 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1327  52A5 B7           	OR A
1328  52A6 20 05        	JR NZ, .L1
1329  52A8              	; player not initialized, throw error
1330  52A8 1E 04        	LD E, 04 ; Out of DATA
1331  52AA C3 D7 4F     	JP THROW_ERROR
1332  52AD              .L1:
1333  52AD 32 F7 4C     	LD (SOUND_ENABLED), A
1334  52B0              	; disable key click
1335  52B0 AF           	XOR A
1336  52B1 32 DB F3     	LD (CLIKSW), A
1337  52B4 C9           	RET
1338  52B5              ; *******************************************************************************************************
1339  52B5
1340  52B5              ; *******************************************************************************************************
1341  52B5              ; function to handle CALL SNDPLYOFF basic extension
1342  52B5              ; disables sound player
1343  52B5              ; _SNDPLYOFF
1344  52B5              ; sets SOUND_ENABLED variable to 0
1345  52B5              ; calls AKG to stop music and SFX on all channels if initialized
1346  52B5              SNDPLYOFF:
1347  52B5 3A F7 4C     	LD A, (SOUND_ENABLED)
1348  52B8 B7           	OR A
1349  52B9 C8           	RET Z ; already stopped
1350  52BA AF           	XOR A
1351  52BB 32 F7 4C     	LD (SOUND_ENABLED), A
1352  52BE E5           	PUSH HL
1353  52BF CD 21 42     	CALL PLY_AKG_STOP
1354  52C2 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1355  52C5 B7           	OR A
1356  52C6 28 0E        	JR Z, .EXIT ; SFX not in use
1357  52C8 AF           	XOR A
1358  52C9 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1359  52CC 3E 01        	LD A, 1
1360  52CE CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1361  52D1 3E 02        	LD A, 2
1362  52D3 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1363  52D6              .EXIT:
1364  52D6 E1           	POP HL
1365  52D7 C9           	RET
1366  52D8              ; *******************************************************************************************************
1367  52D8
1368  52D8              ; *******************************************************************************************************
1369  52D8              ; function to handle CALL SNDSFX basic extension
1370  52D8              ; plays a sound effect
1371  52D8              ; _SNDSFX ( BYTE sfx_number, >0
1372  52D8              ;			BYTE channel, = 0,1 or 2
1373  52D8              ;			BYTE inverted_volume = 0-16, 0 being full volume
1374  52D8              ; will put ram in page 0 also, page 1 is already there
1375  52D8              ; if sound off throws illegal function call
1376  52D8              ; if sfx not initialized, throws out of data
1377  52D8              SNDSFX:
1378  52D8              	; opening (
1379  52D8 CD BF 4F     	CALL CHKCHAR
1380  52DB 28           	DB '('
1381  52DC              	; get sfx_number
1382  52DC DD 21 1C 52  	LD IX, GETBYT
1383  52E0 CD 59 01     	CALL CALBAS
1384  52E3 D5           	PUSH DE
1385  52E4              	; comma
1386  52E4 CD BF 4F     	CALL CHKCHAR
1387  52E7 2C           	DB ','
1388  52E8              	; get sfx address
1389  52E8 DD 21 1C 52  	LD IX, GETBYT
1390  52EC CD 59 01     	CALL CALBAS
1391  52EF D5           	PUSH DE
1392  52F0              	; comma
1393  52F0 CD BF 4F     	CALL CHKCHAR
1394  52F3 2C           	DB ','
1395  52F4              	; get inverted volume
1396  52F4 DD 21 1C 52  	LD IX, GETBYT
1397  52F8 CD 59 01     	CALL CALBAS
1398  52FB D5           	PUSH DE
1399  52FC              	; ending )
1400  52FC CD BF 4F     	CALL CHKCHAR
1401  52FF 29           	DB ')'
1402  5300
1403  5300 3A F7 4C     	LD A, (SOUND_ENABLED)
1404  5303 B7           	OR A
1405  5304 20 05        	JR NZ, .L1
1406  5306              	; sound disabled, throw illegal function call
1407  5306 1E 05        	LD E, 5
1408  5308 C3 D7 4F     	JP THROW_ERROR
1409  530B              .L1:
1410  530B 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1411  530E B7           	OR A
1412  530F 20 05        	JR NZ, .L2
1413  5311              	; sfx data not initialized, throw out of data
1414  5311 1E 04        	LD E, 4
1415  5313 C3 D7 4F     	JP THROW_ERROR
1416  5316              .L2:
1417  5316              	; pop  parameters and store away for later
1418  5316 D1           	POP DE ; inverted volume
1419  5317 43           	LD B, E
1420  5318 D1           	POP DE ; channel
1421  5319 4B           	LD C, E
1422  531A D1           	POP DE
1423  531B 7B           	LD A, E
1424  531C 08           	EX AF, AF'
1425  531D E5           	PUSH HL ; basic text location
1426  531E D9           	EXX
1427  531F FD 21 26 53  	LD IY, .RET
1428  5323 C3 C1 4E     	JP ENABLE_PAGE0
1429  5326              .RET:
1430  5326 D9           	EXX
1431  5327 08           	EX AF, AF'
1432  5328 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1433  532B
1434  532B D1               POP DE
1435  532C C1               POP BC
1436  532D CD 38 4E         CALL RESTORE_PAGE_INFO
1437  5330
1438  5330 E1           	POP HL
1439  5331 C9           	RET
1440  5332              ; *******************************************************************************************************
1441  5332               ENDIF
1442  5332
1443  5332               IFNDEF EXCLUDE_SPRITE_CMDS
1444  5332              ; *******************************************************************************************************
1445  5332              ; function to handle CALL SPRATRINI basic extension
1446  5332              ; initializes sprites handler
1447  5332              ; _SPRATRINI ( INT sprites_attributes_data,
1448  5332              ;			   INT update_variable_location,
1449  5332              ;			   INT sprite_flicker_enabled )
1450  5332              ; expects both locations to be in range #8000+ or throws an error
1451  5332              ; since these should be BASIC variables
1452  5332              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
1453  5332              SPRATRINI:
1454  5332              	; opening (
1455  5332 CD BF 4F     	CALL CHKCHAR
1456  5335 28           	DB '('
1457  5336              	; get address of sprite attribute table DIM SA%(3,31)
1458  5336 DD 21 2F 54  	LD IX, FRMQNT
1459  533A CD 59 01     	CALL CALBAS
1460  533D D5           	PUSH DE
1461  533E              	; comma
1462  533E CD BF 4F     	CALL CHKCHAR
1463  5341 2C           	DB ','
1464  5342              	; get address of sprite attribute table DIM SA%(3,31)
1465  5342 DD 21 2F 54  	LD IX, FRMQNT
1466  5346 CD 59 01     	CALL CALBAS
1467  5349 D5           	PUSH DE
1468  534A              	; comma
1469  534A CD BF 4F     	CALL CHKCHAR
1470  534D 2C           	DB ','
1471  534E              	; get flicker enabled flag
1472  534E DD 21 2F 54  	LD IX, FRMQNT
1473  5352 CD 59 01     	CALL CALBAS
1474  5355 D5           	PUSH DE
1475  5356              	; ending )
1476  5356 CD BF 4F     	CALL CHKCHAR
1477  5359 29           	DB ')'
1478  535A
1479  535A D1           	POP DE ; get flicker flag
1480  535B 7A           	LD A, D
1481  535C B3           	OR E
1482  535D 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
1483  5360
1484  5360 D1           	POP DE ; update variable location
1485  5361 CB 7A        	BIT 7, D ; is address >= &h8000
1486  5363 20 05        	JR NZ, .L1
1487  5365 1E 05        	LD E, 5 ; illegal function call
1488  5367 C3 D7 4F     	JP THROW_ERROR
1489  536A              .L1:
1490  536A ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
1491  536E D1           	POP DE ; address of sprite attribute table
1492  536F CB 7A        	BIT 7, D ; is address >= &h8000
1493  5371 20 05        	JR NZ, .L2
1494  5373 1E 05        	LD E, 5 ; illegal function call
1495  5375 C3 D7 4F     	JP THROW_ERROR
1496  5378              .L2:
1497  5378 ED 53 FB 4C  	LD (SPRATR_DATA), DE
1498  537C 3E 01        	LD A, 1
1499  537E 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1500  5381 C9           	RET
1501  5382              ; *******************************************************************************************************
1502  5382
1503  5382              ; *******************************************************************************************************
1504  5382              ; function to handle CALL SPRSET basic extension
1505  5382              ; sets position, and optionally pattern and color of sprite
1506  5382              ; _SPRSET ( BYTE sprite_num , valid 0-31
1507  5382              ;			INT x,
1508  5382              ;			INT y,
1509  5382              ;			INT pattern, valid 0-31, otherwise ignored
1510  5382              ;			INT color, valid 0-15, otherwise ignored
1511  5382              SPRSET:
1512  5382 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1513  5385 B7           	OR A
1514  5386 20 05        	JR NZ, .L1
1515  5388 1E 05        	LD E, 5 ; illegal function call
1516  538A C3 D7 4F     	JP THROW_ERROR
1517  538D              .L1:
1518  538D              	; opening (
1519  538D CD BF 4F     	CALL CHKCHAR
1520  5390 28           	DB '('
1521  5391              	; get sprite number
1522  5391 DD 21 1C 52  	LD IX, GETBYT
1523  5395 CD 59 01     	CALL CALBAS
1524  5398 F5           	PUSH AF
1525  5399              	; comma
1526  5399 CD BF 4F     	CALL CHKCHAR
1527  539C 2C           	DB ','
1528  539D              	; get x
1529  539D DD 21 2F 54  	LD IX, FRMQNT
1530  53A1 CD 59 01     	CALL CALBAS
1531  53A4 D5           	PUSH DE
1532  53A5              	; comma
1533  53A5 CD BF 4F     	CALL CHKCHAR
1534  53A8 2C           	DB ','
1535  53A9              	; get y
1536  53A9 DD 21 2F 54  	LD IX, FRMQNT
1537  53AD CD 59 01     	CALL CALBAS
1538  53B0 D5           	PUSH DE
1539  53B1              	; comma
1540  53B1 CD BF 4F     	CALL CHKCHAR
1541  53B4 2C           	DB ','
1542  53B5              	; get pattern
1543  53B5 DD 21 2F 54  	LD IX, FRMQNT
1544  53B9 CD 59 01     	CALL CALBAS
1545  53BC D5           	PUSH DE
1546  53BD              	; comma
1547  53BD CD BF 4F     	CALL CHKCHAR
1548  53C0 2C           	DB ','
1549  53C1              	; get color
1550  53C1 DD 21 2F 54  	LD IX, FRMQNT
1551  53C5 CD 59 01     	CALL CALBAS
1552  53C8 D5           	PUSH DE
1553  53C9              	; ending )
1554  53C9 CD BF 4F     	CALL CHKCHAR
1555  53CC 29           	DB ')'
1556  53CD
1557  53CD                  ; save position in BASIC text
1558  53CD E5           	PUSH HL
1559  53CE DD E1        	POP IX
1560  53D0
1561  53D0 C1           	POP BC ; color
1562  53D1 D1           	POP DE ; pattern
1563  53D2 D9           	EXX
1564  53D3 C1           	POP BC ; y
1565  53D4 D1           	POP DE ; x
1566  53D5 F1           	POP AF ; sprite number
1567  53D6 FE 20        	CP 32
1568  53D8 38 05        	JR C, .L2
1569  53DA 1E 05        	LD E, 5 ; illegal function call
1570  53DC C3 D7 4F     	JP THROW_ERROR
1571  53DF              .L2:
1572  53DF              	; find location in sprite attributes table
1573  53DF 87          > ADD A, A
1573  53E0 87          > ADD A, A
1573  53E1 87          > ADD A, A
1574  53E2 D5           	PUSH DE
1575  53E3 16 00        	LD D, 0
1576  53E5 5F           	LD E, A
1577  53E6 2A FB 4C     	LD HL, (SPRATR_DATA)
1578  53E9 19           	ADD HL, DE
1579  53EA D1           	POP DE
1580  53EB              	; set y
1581  53EB 71           	LD (HL), C
1582  53EC 23           	INC HL
1583  53ED 70           	LD (HL), B
1584  53EE 23           	INC HL
1585  53EF              	; set x
1586  53EF 73           	LD (HL), E
1587  53F0 23           	INC HL
1588  53F1 72           	LD (HL), D
1589  53F2 23           	INC HL
1590  53F3 E5           	PUSH HL
1591  53F4 D9           	EXX
1592  53F5 E1           	POP HL
1593  53F6              	; check if 0<=pattern<32
1594  53F6 7A           	LD A, D
1595  53F7 B7           	OR A
1596  53F8 20 0B        	JR NZ, .L3
1597  53FA 7D           	LD A, L
1598  53FB FE 20        	CP 32
1599  53FD 30 06        	JR NC, .L3
1600  53FF              	; set pattern
1601  53FF 73           	LD (HL), E
1602  5400 23           	INC HL
1603  5401 72           	LD (HL), D
1604  5402 23           	INC HL
1605  5403 18 02        	JR .L4
1606  5405              .L3:
1607  5405              	; skip pattern
1608  5405 23          > INC HL
1608  5406 23          > INC HL
1609  5407              .L4:
1610  5407              	; check if 0<=color<16
1611  5407 78           	LD A, B
1612  5408 B7           	OR A
1613  5409 20 08        	JR NZ, .L5
1614  540B 79           	LD A, C
1615  540C FE 10        	CP 16
1616  540E 30 03        	JR NC, .L5
1617  5410              	; set color
1618  5410 71           	LD (HL), C
1619  5411 23           	INC HL
1620  5412 70           	LD (HL), B
1621  5413
1622  5413              .L5:
1623  5413 DD E5        	PUSH IX
1624  5415 E1           	POP HL
1625  5416 C9           	RET
1626  5417              ; *******************************************************************************************************
1627  5417
1628  5417              ; *******************************************************************************************************
1629  5417              ; function sets sprite location based on initial coordinates and offset provided
1630  5417              ; input A=sprite number in SPRATR_DATA , 0-31
1631  5417              ; input DE=initial x
1632  5417              ; input BC=initial y
1633  5417              ; input IY=location where delta y,x are located
1634  5417              ; modifies AF, HL, IX
1635  5417              SPRSET_DELTA_POS:
1636  5417 87          > ADD A, A
1636  5418 87          > ADD A, A
1636  5419 87          > ADD A, A
1637  541A D5           	PUSH DE
1638  541B 16 00        	LD D, 0
1639  541D 5F           	LD E, A
1640  541E DD 2A FB 4C  	LD IX, (SPRATR_DATA)
1641  5422 DD 19        	ADD IX, DE
1642  5424 D1           	POP DE
1643  5425              	; IX=sprite's y location
1644  5425 FD 6E 00     	LD L, (IY)
1645  5428 FD 66 01     	LD H, (IY+1)
1646  542B 09           	ADD HL, BC
1647  542C DD 75 00     	LD (IX), L
1648  542F DD 74 01     	LD (IX+1), H
1649  5432 FD 6E 02     	LD L, (IY+2)
1650  5435 FD 66 03     	LD H, (IY+3)
1651  5438 19           	ADD HL, DE
1652  5439 DD 75 02     	LD (IX+2), L
1653  543C DD 74 03     	LD (IX+3), H
1654  543F C9           	RET
1655  5440              ; *******************************************************************************************************
1656  5440
1657  5440              ; *******************************************************************************************************
1658  5440              ; function to handle CALL SPRGRPMOV basic extension
1659  5440              ; sets position of a group of sprites described with
1660  5440              ; { int sprite_num, int delta_y, int delta_x } [count]
1661  5440              ; _SPRGRPMOV ( INT x,
1662  5440              ;			   INT y,
1663  5440              ;			   INT data_ptr,
1664  5440              ;			   BYTE count,
1665  5440              ; will put ram in page 0 also, page 1 is already there
1666  5440              SPRGRPMOV:
1667  5440 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1668  5443 B7           	OR A
1669  5444 20 05        	JR NZ, .L1
1670  5446 1E 05        	LD E, 5 ; illegal function call
1671  5448 C3 D7 4F     	JP THROW_ERROR
1672  544B              .L1:
1673  544B              	; opening (
1674  544B CD BF 4F     	CALL CHKCHAR
1675  544E 28           	DB '('
1676  544F              	; get x
1677  544F DD 21 2F 54  	LD IX, FRMQNT
1678  5453 CD 59 01     	CALL CALBAS
1679  5456 D5           	PUSH DE
1680  5457              	; comma
1681  5457 CD BF 4F     	CALL CHKCHAR
1682  545A 2C           	DB ','
1683  545B              	; get y
1684  545B DD 21 2F 54  	LD IX, FRMQNT
1685  545F CD 59 01     	CALL CALBAS
1686  5462 D5           	PUSH DE
1687  5463              	; comma
1688  5463 CD BF 4F     	CALL CHKCHAR
1689  5466 2C           	DB ','
1690  5467              	; get data pointer
1691  5467 DD 21 2F 54  	LD IX, FRMQNT
1692  546B CD 59 01     	CALL CALBAS
1693  546E D5           	PUSH DE
1694  546F              	; comma
1695  546F CD BF 4F     	CALL CHKCHAR
1696  5472 2C           	DB ','
1697  5473              	; get count
1698  5473 DD 21 1C 52  	LD IX, GETBYT
1699  5477 CD 59 01     	CALL CALBAS
1700  547A F5           	PUSH AF
1701  547B              	; ending )
1702  547B CD BF 4F     	CALL CHKCHAR
1703  547E 29           	DB ')'
1704  547F
1705  547F E5           	PUSH HL
1706  5480 DD E1        	POP IX
1707  5482
1708  5482 C1           	POP BC ; count
1709  5483 E1           	POP HL ; data pointer
1710  5484 D9           	EXX
1711  5485 C1           	POP BC ; y
1712  5486 D1           	POP DE ; x
1713  5487 D9           	EXX
1714  5488
1715  5488 DD E5        	PUSH IX ; save position in BASIC buffer
1716  548A
1717  548A C5           	PUSH BC
1718  548B E5           	PUSH HL
1719  548C AF               XOR A
1720  548D CD 01 4E         CALL GET_PAGE_INFO
1721  5490 D9           	EXX
1722  5491 E1           	POP HL
1723  5492 F1           	POP AF
1724  5493 D9           	EXX
1725  5494 C5               PUSH BC
1726  5495 D5               PUSH DE
1727  5496 D9           	EXX
1728  5497 F5           	PUSH AF
1729  5498 E5           	PUSH HL
1730  5499 D9           	EXX
1731  549A 3A 41 F3         LD A, (RAMAD0)
1732  549D 26 00            LD H, 0
1733  549F CD 48 4E         CALL LOCAL_ENASLT
1734  54A2 FB           	EI
1735  54A3 E1           	POP HL
1736  54A4 C1           	POP BC
1737  54A5 CD AF 54     	CALL .UPDATE_LOC
1738  54A8 D1               POP DE
1739  54A9 C1               POP BC
1740  54AA CD 38 4E         CALL RESTORE_PAGE_INFO
1741  54AD E1           	POP HL
1742  54AE C9           	RET
1743  54AF
1744  54AF              .UPDATE_LOC:
1745  54AF              .L4:
1746  54AF 7E           	LD A, (HL)
1747  54B0 23           	INC HL
1748  54B1 23           	INC HL
1749  54B2 E5           	PUSH HL
1750  54B3 FD E1        	POP IY
1751  54B5 D9           	EXX
1752  54B6 CD 17 54     	CALL SPRSET_DELTA_POS
1753  54B9 D9           	EXX
1754  54BA 23          > INC HL
1754  54BB 23          > INC HL
1754  54BC 23          > INC HL
1754  54BD 23          > INC HL
1755  54BE 10 EF        	DJNZ .L4
1756  54C0 C9           	RET
1757  54C1              ; *******************************************************************************************************
1758  54C1               ENDIF
1759  54C1
1760  54C1               IFNDEF EXCLUDE_BLIT_CMDS
1761  54C1              ; *******************************************************************************************************
1762  54C1              ; function rotates mask and data of several characters and applies to background data
1763  54C1              ; this handles x-shift from 0 to 4
1764  54C1              ; contains self-modifying code that is set-up from external function
1765  54C1              ; input HL=pointer to mask data
1766  54C1              ; input HL'=pointer to character data
1767  54C1              ; input DE=output buffer containing background data
1768  54C1              ; input BC=DE+8
1769  54C1              ; input A=number of characters to process
1770  54C1              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1771  54C1              SHIFT04:
1772  54C1 08           	EX AF, AF'
1773  54C2 7E           	LD A, (HL) ; get mask
1774  54C3 D9           	EXX
1775  54C4 57           	LD D, A
1776  54C5 1E FF        	LD E, #FF
1777  54C7 37           	SCF
1778  54C8              .M1:
1779  54C8 18 FE        	JR .M1 ; this is self-modifying part
1780  54CA CB 1A        	RR D
1781  54CC CB 1B        	RR E
1782  54CE CB 1A        	RR D
1783  54D0 CB 1B        	RR E
1784  54D2 CB 1A        	RR D
1785  54D4 CB 1B        	RR E
1786  54D6 CB 1A        	RR D
1787  54D8 CB 1B        	RR E
1788  54DA
1789  54DA 46           	LD B, (HL) ; get data
1790  54DB 0E 00        	LD C, 0
1791  54DD              .M2:
1792  54DD 18 FE        	JR .M2 ; also self-modifying part
1793  54DF CB 38        	SRL B
1794  54E1 CB 19        	RR C
1795  54E3 CB 38        	SRL B
1796  54E5 CB 19        	RR C
1797  54E7 CB 38        	SRL B
1798  54E9 CB 19        	RR C
1799  54EB CB 38        	SRL B
1800  54ED CB 19        	RR C
1801  54EF
1802  54EF D9           	EXX
1803  54F0 1A           	LD A, (DE) ; background
1804  54F1 D9           	EXX
1805  54F2 A2           	AND D
1806  54F3 B0           	OR B
1807  54F4 D9           	EXX
1808  54F5 12           	LD (DE), A
1809  54F6
1810  54F6 0A           	LD A, (BC)
1811  54F7 D9           	EXX
1812  54F8 A3           	AND E
1813  54F9 B1           	OR C
1814  54FA 23           	INC HL
1815  54FB D9           	EXX
1816  54FC 02           	LD (BC), A
1817  54FD
1818  54FD 23           	INC HL
1819  54FE 13           	INC DE
1820  54FF 03           	INC BC
1821  5500
1822  5500 08           	EX AF, AF'
1823  5501 3D           	DEC A
1824  5502 C2 C1 54     	JP NZ, SHIFT04
1825  5505 C9           	RET
1826  5506              ; *******************************************************************************************************
1827  5506
1828  5506              ; *******************************************************************************************************
1829  5506              ; function rotates mask and data of several characters and applies to background data
1830  5506              ; this handles x-shift from 5 to 8
1831  5506              ; contains self-modifying code that is set-up from external function
1832  5506              ; input HL=pointer to mask data
1833  5506              ; input HL'=pointer to character data
1834  5506              ; input DE=output buffer containing background data
1835  5506              ; input BC=DE+8
1836  5506              ; input A=number of characters to process
1837  5506              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1838  5506              SHIFT58:
1839  5506 08           	EX AF, AF'
1840  5507 7E           	LD A, (HL) ; get mask
1841  5508 D9           	EXX
1842  5509 57           	LD D, A
1843  550A 1E FF        	LD E, #FF
1844  550C 37           	SCF
1845  550D              .M1:
1846  550D 18 FE        	JR .M1 ; this is self-modifying part
1847  550F CB 12        	RL D
1848  5511 CB 13        	RL E
1849  5513 CB 12        	RL D
1850  5515 CB 13        	RL E
1851  5517 CB 12        	RL D
1852  5519 CB 13        	RL E
1853  551B
1854  551B 46           	LD B, (HL)
1855  551C 0E 00        	LD C, 0
1856  551E              .M2:
1857  551E 18 FE        	JR .M2 ; also self-modifying part
1858  5520 CB 20        	SLA B
1859  5522 CB 11        	RL C
1860  5524 CB 20        	SLA B
1861  5526 CB 11        	RL C
1862  5528 CB 20        	SLA B
1863  552A CB 11        	RL C
1864  552C
1865  552C D9           	EXX
1866  552D 1A           	LD A, (DE) ; background
1867  552E D9           	EXX
1868  552F A3           	AND E
1869  5530 B1           	OR C
1870  5531 D9           	EXX
1871  5532 12           	LD (DE), A
1872  5533
1873  5533 0A           	LD A, (BC)
1874  5534 D9           	EXX
1875  5535 A2           	AND D
1876  5536 B0           	OR B
1877  5537 23           	INC HL
1878  5538 D9           	EXX
1879  5539 02           	LD (BC), A
1880  553A
1881  553A 23           	INC HL
1882  553B 13           	INC DE
1883  553C 03           	INC BC
1884  553D
1885  553D 08           	EX AF, AF'
1886  553E 3D           	DEC A
1887  553F C2 06 55     	JP NZ, SHIFT58
1888  5542 C9           	RET
1889  5543              ; *******************************************************************************************************
1890  5543
1891  5543              ; *******************************************************************************************************
1892  5543              ; routine that shifts one row of characters
1893  5543              ; contains self-modifying code that is set-up from external function
1894  5543              ; input HL=pointer to mask data
1895  5543              ; input HL'=pointer to character data
1896  5543              ; input DE=output buffer containing background data
1897  5543              ; input A=number of characters to process
1898  5543              ; input IX=pointer to structure describing input data
1899  5543              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1900  5543              SHIFT_ROW:
1901  5543 F5           	PUSH AF
1902  5544 ED 53 01 4D  		LD (BLIT_TMP1), DE
1903  5548 E5           		PUSH HL
1904  5549 CD 8C 55     			CALL .ADDYSHIFT
1905  554C E1           		POP HL
1906  554D ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1907  5551              .L1:
1908  5551 3E 08        		LD A, 8
1909  5553 DD 96 02     		SUB (IX+2) ; y shift
1910  5556              .CALL1:
1911  5556 CD 00 00     		CALL 0
1912  5559 DD 7E 02     		LD A, (IX+2); y shift
1913  555C B7           		OR A
1914  555D 28 26        		JR Z, .DONE
1915  555F ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1916  5563 E5           		PUSH HL
1917  5564 CD 9A 55     			CALL .DETONEXTROW
1918  5567 E1           		POP HL
1919  5568              .CALL2:
1920  5568 CD 00 00     		CALL 0
1921  556B ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1922  556F E5           		PUSH HL
1923  5570 CD 94 55     			CALL .ADD8
1924  5573 E1           		POP HL
1925  5574 ED 53 01 4D  		LD (BLIT_TMP1), DE
1926  5578 ED 5B 03 4D  		LD DE, (BLIT_TMP2)
1927  557C E5           		PUSH HL
1928  557D CD 94 55     			CALL .ADD8
1929  5580 E1           		POP HL
1930  5581 ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1931  5585              .DONE:
1932  5585 F1           	POP AF
1933  5586 3D           	DEC A
1934  5587 C8           	RET Z
1935  5588 F5           	PUSH AF
1936  5589 C3 51 55     	JP .L1
1937  558C              .ADDYSHIFT:
1938  558C EB           	EX DE, HL
1939  558D 16 00        	LD D, 0
1940  558F DD 5E 02     	LD E, (IX+2); y shift
1941  5592 18 0C        	JR .MOVDEBC
1942  5594              .ADD8:
1943  5594 21 08 00     	LD HL, 8
1944  5597 C3 A0 55     	JP .MOVDEBC
1945  559A              .DETONEXTROW:
1946  559A DD 6E 06     	LD L, (IX+6)
1947  559D DD 66 07     	LD H, (IX+7) ; bkg add to value
1948  55A0              .MOVDEBC:
1949  55A0 19           	ADD HL, DE
1950  55A1 54           	LD D, H
1951  55A2 5D           	LD E, L
1952  55A3 01 08 00     	LD BC, 8
1953  55A6 09           	ADD HL, BC
1954  55A7 44           	LD B, H
1955  55A8 4D           	LD C, L
1956  55A9 C9           	RET
1957  55AA              ; *******************************************************************************************************
1958  55AA
1959  55AA              ; *******************************************************************************************************
1960  55AA              ; function rotates mask and character data and applies it to background
1961  55AA              ; input IX=pointer to structure describing input data
1962  55AA              ; +0  DW horizontal shift count 0-7
1963  55AA              ; +2  DW vertical shift count 0-7
1964  55AA              ; +4  DW background data start;
1965  55AA              ; +6  DW background add to value to next row of background data
1966  55AA              ; +8  DW mask data start;
1967  55AA              ; +10  DW character data start;
1968  55AA              ; +12 DW character&mask add to value to next row of data
1969  55AA              ; +14 DW columns (low byte used)
1970  55AA              ; +16 DW rows (low byte used)
1971  55AA              SHIFT_MERGE_CHARACTER:
1972  55AA DD 7E 00     	LD A, (IX) ; shift
1973  55AD FE 05        	CP 5
1974  55AF 38 25        	JR C, .RIGHT
1975  55B1              	; shifts 5-7, use rotate towards left 1-3
1976  55B1 21 06 55     	LD HL, SHIFT58
1977  55B4 22 57 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1978  55B7 22 69 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1979  55BA D6 05        	SUB 5
1980  55BC 28 0D        	JR Z, .L1
1981  55BE 87           	ADD A, A
1982  55BF 87           	ADD A, A
1983  55C0 67           	LD H, A
1984  55C1 2E 18        	LD L, #18 ; JR opcode
1985  55C3 22 0D 55     	LD (SHIFT58.M1), HL
1986  55C6 22 1E 55     	LD (SHIFT58.M2), HL
1987  55C9 18 32        	JR .DO
1988  55CB              .L1:
1989  55CB 21 00 00     	LD HL, 0 ; 2xNOP opcode
1990  55CE 22 0D 55     	LD (SHIFT58.M1), HL
1991  55D1 22 1E 55     	LD (SHIFT58.M2), HL
1992  55D4 18 27        	JR .DO
1993  55D6              .RIGHT:
1994  55D6              	; shifts 0-4, rotate towards right
1995  55D6 21 C1 54     	LD HL, SHIFT04
1996  55D9 22 57 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1997  55DC 22 69 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1998  55DF FE 04        	CP 4
1999  55E1 28 11        	JR Z, .R1
2000  55E3 D6 04        	SUB 4
2001  55E5 ED 44        	NEG
2002  55E7 87           	ADD A, A
2003  55E8 87           	ADD A, A
2004  55E9 67           	LD H, A
2005  55EA 2E 18        	LD L, #18 ; JR opcode
2006  55EC 22 C8 54     	LD (SHIFT04.M1), HL
2007  55EF 22 DD 54     	LD (SHIFT04.M2), HL
2008  55F2 18 09        	JR .DO
2009  55F4              .R1:
2010  55F4 21 00 00     	LD HL, 0 ; 2xNOP opcode
2011  55F7 22 C8 54     	LD (SHIFT04.M1), HL
2012  55FA 22 DD 54     	LD (SHIFT04.M2), HL
2013  55FD              .DO:
2014  55FD DD 46 10     	LD B, (IX+16) ; rows
2015  5600 DD 6E 08     	LD L, (IX+8)
2016  5603 DD 66 09     	LD H, (IX+9) ; mask data
2017  5606 DD 5E 04     	LD E, (IX+4)
2018  5609 DD 56 05     	LD D, (IX+5) ; background data
2019  560C D9           	EXX
2020  560D DD 6E 0A     	LD L, (IX+10)
2021  5610 DD 66 0B     	LD H, (IX+11) ; character data
2022  5613 D9           	EXX
2023  5614              .LOOP:
2024  5614 C5           	PUSH BC
2025  5615 E5           		PUSH HL
2026  5616 D5           			PUSH DE
2027  5617 D9           				EXX
2028  5618 E5           				PUSH HL
2029  5619 D9           					EXX
2030  561A DD 7E 0E     					LD A, (IX+14) ; columns
2031  561D              .CALL:
2032  561D CD 43 55     					CALL SHIFT_ROW
2033  5620 E1           				POP HL
2034  5621 DD 5E 0C     				LD E, (IX+12)
2035  5624 DD 56 0D     				LD D, (IX+13) ; char data to next row
2036  5627 19           				ADD HL, DE
2037  5628 D9           				EXX
2038  5629 E1           			POP HL
2039  562A DD 5E 06     			LD E, (IX+6)
2040  562D DD 56 07     			LD D, (IX+7) ; background to next row
2041  5630 19           			ADD HL, DE
2042  5631 EB           			EX DE, HL
2043  5632 E1           		POP HL
2044  5633 DD 4E 0C     		LD C, (IX+12)
2045  5636 DD 46 0D     		LD B, (IX+13) ; char data to next row
2046  5639 09           		ADD HL, BC
2047  563A C1           	POP BC
2048  563B 10 D7        	DJNZ .LOOP
2049  563D C9           	RET
2050  563E              ; *******************************************************************************************************
2051  563E
2052  563E              ; *******************************************************************************************************
2053  563E              ; function to handle CALL BLIT basic extension
2054  563E              ; rotates 1-bit character drawing horizontally with mask and character data and
2055  563E              ; fuses with background data and applies vertical shift too
2056  563E              ; BLIT ( INT request_data_ptr )
2057  563E              ; request_data_ptr described in SHIFT_MERGE_CHARACTER
2058  563E              ; will put ram in page 0 also, page 1 is already there
2059  563E              BLIT:
2060  563E              	; opening (
2061  563E CD BF 4F     	CALL CHKCHAR
2062  5641 28           	DB '('
2063  5642              	; get pointer to request struct
2064  5642 DD 21 2F 54  	LD IX, FRMQNT
2065  5646 CD 59 01     	CALL CALBAS
2066  5649 D5           	PUSH DE
2067  564A              	; ending )
2068  564A CD BF 4F     	CALL CHKCHAR
2069  564D 29           	DB ')'
2070  564E
2071  564E DD E1        	POP IX ; pointer to request struct
2072  5650
2073  5650 E5           	PUSH HL ; save position in BASIC buffer
2074  5651
2075  5651 FD 21 58 56  	LD IY, .RET
2076  5655 C3 C1 4E     	JP ENABLE_PAGE0
2077  5658              .RET:
2078  5658 FB           	EI
2079  5659 CD AA 55     	CALL SHIFT_MERGE_CHARACTER
2080  565C
2081  565C D1               POP DE
2082  565D C1               POP BC
2083  565E CD 38 4E         CALL RESTORE_PAGE_INFO
2084  5661
2085  5661 E1           	POP HL
2086  5662 C9           	RET
2087  5663              ; *******************************************************************************************************
2088  5663
2089  5663              ; *******************************************************************************************************
2090  5663              ; generic function to implement tiling
2091  5663              ; should be modified to call appropriate function for memory or vram
2092  5663              ; input IX=pointer to following structure
2093  5663              ; +00 tile_data_ptr
2094  5663              ; +02 tile_rows
2095  5663              ; +04 tile_columns
2096  5663              ; +06 destination_address
2097  5663              ; +08 dest_to_next_row_add_to_value
2098  5663              ; +10 num_horizontal_tiles
2099  5663              ; +12 num_vertical_tiles
2100  5663              ; modifies AF, BC, DE, HL
2101  5663              TILE:
2102  5663 DD 6E 06     	LD L, (IX+6)
2103  5666 DD 66 07     	LD H, (IX+7) ; destination address
2104  5669 22 01 4D     	LD (TILETMP1), HL
2105  566C DD 46 0C     	LD B, (IX+12) ; vertical tile number
2106  566F              .L1:
2107  566F C5           	PUSH BC
2108  5670 DD 6E 00     		LD L, (IX+0)
2109  5673 DD 66 01     		LD H, (IX+1) ; tile address
2110  5676 22 03 4D     		LD (TILETMP2), HL
2111  5679 DD 46 02     		LD B, (IX+2) ; tile rows
2112  567C              .L2:
2113  567C C5           		PUSH BC
2114  567D              .CALL1:
2115  567D CD 00 00     			CALL 0
2116  5680 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
2117  5683              .L3:
2118  5683 C5           			PUSH BC
2119  5684 2A 03 4D     				LD HL, (TILETMP2)
2120  5687 DD 46 04     				LD B, (IX+4) ; tile columns
2121  568A              .L4:
2122  568A C5           				PUSH BC
2123  568B              .CALL2:
2124  568B CD 00 00     					CALL 0
2125  568E C1           				POP BC
2126  568F 10 F9        				DJNZ .L4
2127  5691 C1           			POP BC
2128  5692 10 EF        			DJNZ .L3
2129  5694 22 03 4D     			LD (TILETMP2), HL
2130  5697 2A 01 4D     			LD HL, (TILETMP1)
2131  569A DD 5E 08     			LD E, (IX+8)
2132  569D DD 56 09     			LD D, (IX+9) ; add to value for dest next row
2133  56A0 19           			ADD HL, DE
2134  56A1 22 01 4D     			LD (TILETMP1), HL
2135  56A4 C1           		POP BC
2136  56A5 10 D5        		DJNZ .L2
2137  56A7 C1           	POP BC
2138  56A8 10 C5        	DJNZ .L1
2139  56AA C9           	RET
2140  56AB              ; *******************************************************************************************************
2141  56AB
2142  56AB              ; *******************************************************************************************************
2143  56AB              ; function to handle CALL TILERAM basic extension
2144  56AB              ; fills memory with tiles
2145  56AB              ; fuses with background data and applies vertical shift too
2146  56AB              ; TILERAM ( INT request_data_ptr )
2147  56AB              ; request_data_ptr described in TILE
2148  56AB              ; will put ram in page 0 also, page 1 is already there
2149  56AB              TILERAM:
2150  56AB              	; opening (
2151  56AB CD BF 4F     	CALL CHKCHAR
2152  56AE 28           	DB '('
2153  56AF              	; get pointer to request struct
2154  56AF DD 21 2F 54  	LD IX, FRMQNT
2155  56B3 CD 59 01     	CALL CALBAS
2156  56B6 D5           	PUSH DE
2157  56B7              	; ending )
2158  56B7 CD BF 4F     	CALL CHKCHAR
2159  56BA 29           	DB ')'
2160  56BB
2161  56BB DD E1        	POP IX ; pointer to request struct
2162  56BD
2163  56BD E5           	PUSH HL ; save position in BASIC buffer
2164  56BE
2165  56BE FD 21 C5 56  	LD IY, .RET
2166  56C2 C3 C1 4E     	JP ENABLE_PAGE0
2167  56C5              .RET:
2168  56C5 FB           	EI
2169  56C6              	; set RAM functions to call
2170  56C6 21 DC 56     	LD HL, .TILECOPY
2171  56C9 22 8C 56     	LD (TILE.CALL2+1), HL
2172  56CC 21 ED 56     	LD HL, .SETDESTROW
2173  56CF 22 7E 56     	LD (TILE.CALL1+1), HL
2174  56D2 CD 63 56     	CALL TILE
2175  56D5
2176  56D5 D1               POP DE
2177  56D6 C1               POP BC
2178  56D7 CD 38 4E         CALL RESTORE_PAGE_INFO
2179  56DA
2180  56DA E1           	POP HL
2181  56DB C9           	RET
2182  56DC              .TILECOPY:
2183  56DC ED A0       > LDI
2183  56DE ED A0       > LDI
2183  56E0 ED A0       > LDI
2183  56E2 ED A0       > LDI
2183  56E4 ED A0       > LDI
2183  56E6 ED A0       > LDI
2183  56E8 ED A0       > LDI
2183  56EA ED A0       > LDI
2184  56EC C9           	RET
2185  56ED              .SETDESTROW:
2186  56ED ED 5B 01 4D  	LD DE, (TILETMP1)
2187  56F1 C9           	RET
2188  56F2              ; *******************************************************************************************************
2189  56F2
2190  56F2              ; *******************************************************************************************************
2191  56F2              ; function to handle CALL TILEVRM basic extension
2192  56F2              ; fills vram with tiles
2193  56F2              ; fuses with background data and applies vertical shift too
2194  56F2              ; TILEVRM ( INT request_data_ptr )
2195  56F2              ; request_data_ptr described in TILE
2196  56F2              ; will put ram in page 0 also, page 1 is already there
2197  56F2              TILEVRM:
2198  56F2              	; opening (
2199  56F2 CD BF 4F     	CALL CHKCHAR
2200  56F5 28           	DB '('
2201  56F6              	; get pointer to request struct
2202  56F6 DD 21 2F 54  	LD IX, FRMQNT
2203  56FA CD 59 01     	CALL CALBAS
2204  56FD D5           	PUSH DE
2205  56FE              	; ending )
2206  56FE CD BF 4F     	CALL CHKCHAR
2207  5701 29           	DB ')'
2208  5702
2209  5702 DD E1        	POP IX ; pointer to request struct
2210  5704
2211  5704 E5           	PUSH HL ; save position in BASIC buffer
2212  5705
2213  5705 FD 21 0C 57  	LD IY, .RET
2214  5709 C3 C1 4E     	JP ENABLE_PAGE0
2215  570C              .RET:
2216  570C FB           	EI
2217  570D              	; set RAM functions to call
2218  570D 21 23 57     	LD HL, .TILECOPY
2219  5710 22 8C 56     	LD (TILE.CALL2+1), HL
2220  5713 21 29 57     	LD HL, .SETDESTROW
2221  5716 22 7E 56     	LD (TILE.CALL1+1), HL
2222  5719 CD 63 56     	CALL TILE
2223  571C
2224  571C D1               POP DE
2225  571D C1               POP BC
2226  571E CD 38 4E         CALL RESTORE_PAGE_INFO
2227  5721
2228  5721 E1           	POP HL
2229  5722 C9           	RET
2230  5723              .TILECOPY:
2231  5723 01 98 08     	LD BC, #0898
2232  5726               IFNDEF EXCLUDE_VRAM_CMDS
2233  5726 C3 94 51     	JP MEMVRM.BBYTECOPY
2234  5729               ELSE
2235  5729 ~            .BBYTECOPY:
2236  5729 ~            	OUTI
2237  5729 ~            	JP	NZ, .BBYTECOPY
2238  5729 ~            	RET
2239  5729               ENDIF
2240  5729              .SETDESTROW:
2241  5729 2A 01 4D     	LD HL, (TILETMP1)
2242  572C F3           	DI
2243  572D CD F6 4D     	CALL SETWRT_LOCAL
2244  5730 FB           	EI
2245  5731 C9           	RET
2246  5732              ; *******************************************************************************************************
2247  5732
2248  5732              ; *******************************************************************************************************
2249  5732              ; generic function to implement rectangle data copy
2250  5732              ; should be modified to call appropriate function for memory or vram
2251  5732              ; input IX=pointer to following structure
2252  5732              ; +00 source data pointer
2253  5732              ; +02 num bytes in a row
2254  5732              ; +04 number of rows
2255  5732              ; +06 source add-to value till next row
2256  5732              ; +08 destination address
2257  5732              ; +10 destination add-to value till next row
2258  5732              ; modifies AF, BC, DE, HL
2259  5732              RECTANGLE_COPY:
2260  5732 DD 6E 00     	LD L, (IX+0)
2261  5735 DD 66 01     	LD H, (IX+1) ; source address
2262  5738 DD 5E 08     	LD E, (IX+8)
2263  573B DD 56 09     	LD D, (IX+9) ; destination
2264  573E DD 46 04     	LD B, (IX+4) ; row number
2265  5741              .L1:
2266  5741 C5           	PUSH BC
2267  5742 E5           		PUSH HL
2268  5743 D5           			PUSH DE
2269  5744 DD 4E 02     				LD C, (IX+2)
2270  5747 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2271  574A              .CALL1:
2272  574A CD 00 00     				CALL 0 ; set destination address from DE
2273  574D              .CALL2:
2274  574D CD 00 00     				CALL 0 ; copy data fn
2275  5750 E1           			POP HL
2276  5751 DD 4E 0A     			LD C, (IX+10)
2277  5754 DD 46 0B     			LD B, (IX+11) ; destination add-to
2278  5757 09           			ADD HL, BC
2279  5758 EB           			EX DE, HL
2280  5759 E1           		POP HL
2281  575A DD 4E 06     		LD C, (IX+6)
2282  575D DD 46 07     		LD B, (IX+7) ; src add-to
2283  5760 09           		ADD HL, BC
2284  5761 C1           	POP BC
2285  5762 10 DD        	DJNZ .L1
2286  5764 C9           	RET
2287  5765              ; *******************************************************************************************************
2288  5765
2289  5765              ; *******************************************************************************************************
2290  5765              ; function to handle CALL BOXMEMCPY basic extension
2291  5765              ; copies data with window like boundaries to ram
2292  5765              ; BOXMEMCPY ( INT request_data_ptr )
2293  5765              ; request_data_ptr described in RECTANGLE_COPY
2294  5765              ; will put ram in page 0 also, page 1 is already there
2295  5765              BOXMEMCPY:
2296  5765              	; opening (
2297  5765 CD BF 4F     	CALL CHKCHAR
2298  5768 28           	DB '('
2299  5769              	; get pointer to request struct
2300  5769 DD 21 2F 54  	LD IX, FRMQNT
2301  576D CD 59 01     	CALL CALBAS
2302  5770 D5           	PUSH DE
2303  5771              	; ending )
2304  5771 CD BF 4F     	CALL CHKCHAR
2305  5774 29           	DB ')'
2306  5775
2307  5775 DD E1        	POP IX ; pointer to request struct
2308  5777
2309  5777 E5           	PUSH HL ; save position in BASIC buffer
2310  5778
2311  5778 FD 21 7F 57  	LD IY, .RET
2312  577C C3 C1 4E     	JP ENABLE_PAGE0
2313  577F              .RET:
2314  577F FB           	EI
2315  5780              	; set RAM functions to call
2316  5780 21 00 00     	LD HL, 0
2317  5783 22 4A 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2318  5786 22 4C 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2319  5789 21 ED B0     	LD HL, #B0ED ; LDIR
2320  578C 22 4E 57     	LD (RECTANGLE_COPY.CALL1+4), HL
2321  578F CD 32 57     	CALL RECTANGLE_COPY
2322  5792
2323  5792 D1               POP DE
2324  5793 C1               POP BC
2325  5794 CD 38 4E         CALL RESTORE_PAGE_INFO
2326  5797
2327  5797 E1           	POP HL
2328  5798 C9           	RET
2329  5799              ; *******************************************************************************************************
2330  5799
2331  5799              ; *******************************************************************************************************
2332  5799              ; function to handle CALL BOXMEMVRM basic extension
2333  5799              ; copies data with window like boundaries to ram
2334  5799              ; BOXMEMVRM ( INT request_data_ptr )
2335  5799              ; request_data_ptr described in RECTANGLE_COPY
2336  5799              ; will put ram in page 0 also, page 1 is already there
2337  5799              BOXMEMVRM:
2338  5799              	; opening (
2339  5799 CD BF 4F     	CALL CHKCHAR
2340  579C 28           	DB '('
2341  579D              	; get pointer to request struct
2342  579D DD 21 2F 54  	LD IX, FRMQNT
2343  57A1 CD 59 01     	CALL CALBAS
2344  57A4 D5           	PUSH DE
2345  57A5              	; ending )
2346  57A5 CD BF 4F     	CALL CHKCHAR
2347  57A8 29           	DB ')'
2348  57A9
2349  57A9 DD E1        	POP IX ; pointer to request struct
2350  57AB
2351  57AB E5           	PUSH HL ; save position in BASIC buffer
2352  57AC
2353  57AC FD 21 B3 57  	LD IY, .RET
2354  57B0 C3 C1 4E     	JP ENABLE_PAGE0
2355  57B3              .RET:
2356  57B3 FB           	EI
2357  57B4              	; set RAM functions to call
2358  57B4 21 D2 57     	LD HL, .SETDEST
2359  57B7 22 4B 57     	LD (RECTANGLE_COPY.CALL1+1), HL
2360  57BA 21 DA 57     	LD HL, .COPYDATA
2361  57BD 22 4E 57     	LD (RECTANGLE_COPY.CALL2+1), HL
2362  57C0 3E CD        	LD A, #CD ; CALL
2363  57C2 32 4A 57     	LD (RECTANGLE_COPY.CALL1), A
2364  57C5 32 4D 57     	LD (RECTANGLE_COPY.CALL2), A
2365  57C8 CD 32 57     	CALL RECTANGLE_COPY
2366  57CB
2367  57CB D1               POP DE
2368  57CC C1               POP BC
2369  57CD CD 38 4E         CALL RESTORE_PAGE_INFO
2370  57D0
2371  57D0 E1           	POP HL
2372  57D1 C9           	RET
2373  57D2              .SETDEST:
2374  57D2 EB           	EX DE, HL
2375  57D3 F3           	DI
2376  57D4 CD F6 4D     	CALL SETWRT_LOCAL
2377  57D7 FB           	EI
2378  57D8 EB           	EX DE, HL
2379  57D9 C9           	RET
2380  57DA              .COPYDATA:
2381  57DA 41           	LD B, C
2382  57DB 0E 98        	LD C, #98
2383  57DD               IFNDEF EXCLUDE_VRAM_CMDS
2384  57DD C3 94 51     	JP MEMVRM.BBYTECOPY
2385  57E0               ELSE
2386  57E0 ~            	JP TILEVRM.BBYTECOPY
2387  57E0               ENDIF
2388  57E0              ; *******************************************************************************************************
2389  57E0               ENDIF
2390  57E0
2391  57E0              EXT_END:
2392  57E0
# file closed: asm\main.asm
