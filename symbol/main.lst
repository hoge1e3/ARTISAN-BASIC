# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; DEFINE EXCLUDE_SOUND_PLAYER
   4  4000              ; DEFINE EXCLUDE_RAM_CMDS
   5  4000              ; DEFINE EXCLUDE_VRAM_CMDS
   6  4000              ; DEFINE EXCLUDE_BLIT_CMDS
   7  4000              ; DEFINE EXCLUDE_SPRITE_CMDS
   8  4000              ; DEFINE EXCLUDE_GENCAL
   9  4000
  10  4000              CHPUT   EQU     #A2
  11  4000              CALBAS	EQU		#159
  12  4000              ERRHAND EQU     #406F
  13  4000              FRMEVL  EQU     #4C64
  14  4000              FRESTR	EQU		#67D0
  15  4000              ; FRMQNT = formula quantificator
  16  4000              ; input HL=pointer to current program expression
  17  4000              ; output HL=next address
  18  4000              ; output DE=integer datum
  19  4000              FRMQNT	EQU		#542F
  20  4000              ; GETBYT = get byte parameter
  21  4000              ; input HL=pointer to current program expression
  22  4000              ; output HL=next address
  23  4000              ; output A=E=byte read
  24  4000              GETBYT	EQU		#521C
  25  4000              CHRGTR  EQU     #4666
  26  4000              SYNCHR	EQU		#558C
  27  4000              VALTYP  EQU     #F663
  28  4000              USR     EQU     #F7F8
  29  4000              PROCNM	EQU		#FD89
  30  4000              BIOS_FILVRM  EQU     #56
  31  4000              CLIKSW	EQU		#F3DB
  32  4000              ATRBAS	EQU		#F928
  33  4000
  34  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  35  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  36  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  37  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  38  4000              EXPTBL	EQU #FCC1
  39  4000              SCRMOD	EQU #FCAF ; current screen mode
  40  4000
  41  4000              ; BASIC error codes
  42  4000              ;01 NEXT without FOR
  43  4000              ;02 Syntax error
  44  4000              ;03 RETURN without GOSUB
  45  4000              ;04 Out of DATA
  46  4000              ;05 Illegal function call
  47  4000              ;06 Overflow
  48  4000              ;07 Out of memory
  49  4000              ;08 Undefined line number
  50  4000              ;09 Subscript out of range
  51  4000              ;10 Redimensioned array
  52  4000              ;11 Division by zero
  53  4000              ;12 Illegal direct
  54  4000              ;13 Type mismatch
  55  4000              ;14 Out of string space
  56  4000              ;15 String too long
  57  4000              ;16 String formula too complex
  58  4000              ;17 Can't CONTINUE
  59  4000              ;18 Undefined user function
  60  4000              ;19 Device I/O error
  61  4000              ;20 Verify error
  62  4000              ;21 No RESUME
  63  4000              ;22 RESUME without error
  64  4000              ;23 Unprintable error
  65  4000              ;24 Missing operand
  66  4000              ;25 Line buffer overflow
  67  4000              ;50 FIELD overflow
  68  4000              ;51 Internal error
  69  4000              ;52 Bad file number
  70  4000              ;53 File not found
  71  4000              ;54 File already open
  72  4000              ;55 Input past end
  73  4000              ;56 Bad file name
  74  4000              ;57 Direct statement in file
  75  4000              ;58 Sequential I/O only
  76  4000              ;59 File not OPEN
  77  4000
  78  4000
  79  4000               ; simulate cartridge with BASIC extension
  80  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  80  4004 82 4F 00 00
  80  4008 00 00 00 00
  80  400C 00 00 00 00
  81  4010
  82  4010              ; this location #4010 stores last location used by basic extension
  83  4010              ; free memory after that point
  84  4010 E2 57         DW EXT_END
  85  4012
  86  4012              ; this location #4012 stores extension version in DAA format
  87  4012              ; first byte is major version and second minor
  88  4012 00 70         DB #00, #70
  89  4014
  90  4014              ; binary included AKG player compiled at #4014
  91  4014               IFNDEF EXCLUDE_SOUND_PLAYER
  92  4014              	INCBIN "bin/AKG.bin"
  93  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
  94  4CF0               ENDIF
  95  4CF0
  96  4CF0              ORIG.HTIMI:
  97  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  97  4CF4 00
  98  4CF5               EXPORT ORIG.HTIMI
  99  4CF5
 100  4CF5               IFNDEF EXCLUDE_SOUND_PLAYER
 101  4CF5              MUSIC_INIT_STATUS:
 102  4CF5 00            DB 0
 103  4CF6              SFX_INIT_STATUS:
 104  4CF6 00            DB 0
 105  4CF7              SOUND_ENABLED:
 106  4CF7 00            DB 0
 107  4CF8               ENDIF
 108  4CF8
 109  4CF8               IFNDEF EXCLUDE_SPRITE_CMDS
 110  4CF8              SPRATR_INIT_STATUS:
 111  4CF8 00            DB 0
 112  4CF9              SPRATR_UPDATE_FLAG:
 113  4CF9 00 00         DW 0
 114  4CFB              SPRATR_DATA:
 115  4CFB 00 00         DW 0
 116  4CFD              SPRFLICKER_ENABLED:
 117  4CFD 00            DB 0
 118  4CFE              ; to support sprite flicker
 119  4CFE              FLICKER:
 120  4CFE 00            DB 0
 121  4CFF               ENDIF
 122  4CFF
 123  4CFF              ; to temporarily store stack pointer
 124  4CFF              TMPSP:
 125  4CFF 00 00         DW 0
 126  4D01
 127  4D01              ; temp variables for BLIT, TILE functions
 128  4D01               IFNDEF EXCLUDE_BLIT_CMDS
 129  4D01              TILETMP1:
 130  4D01              BLIT_TMP1:
 131  4D01 00 00         DW 0
 132  4D03              TILETMP2:
 133  4D03              BLIT_TMP2:
 134  4D03 00 00         DW 0
 135  4D05               ENDIF
 136  4D05
 137  4D05              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 138  4D05              ; per starting letter, if no commands with this letter, NULL value
 139  4D05              CMDS:
 140  4D05 00 00            DW 0 ; A
 141  4D07 C1 4D            DW CMDS_B ; B
 142  4D09 00 00            DW 0 ; C
 143  4D0B 00 00            DW 0 ; D
 144  4D0D 00 00            DW 0 ; E
 145  4D0F 4C 4D            DW CMDS_F; F
 146  4D11 5F 4D            DW CMDS_G; G
 147  4D13 00 00            DW 0 ; H
 148  4D15 00 00            DW 0 ; I
 149  4D17 00 00            DW 0 ; J
 150  4D19 00 00            DW 0 ; K
 151  4D1B 00 00            DW 0 ; L
 152  4D1D 39 4D            DW CMDS_M ; M
 153  4D1F 00 00            DW 0 ; N
 154  4D21 00 00            DW 0 ; O
 155  4D23 00 00            DW 0 ; P
 156  4D25 00 00            DW 0 ; Q
 157  4D27 00 00            DW 0 ; R
 158  4D29 73 4D            DW CMDS_S ; S
 159  4D2B E1 4D            DW CMDS_T ; T
 160  4D2D 00 00            DW 0 ; U
 161  4D2F 69 4D            DW CMDS_V ; V
 162  4D31 00 00            DW 0 ; W
 163  4D33 00 00            DW 0 ; X
 164  4D35 00 00            DW 0 ; Y
 165  4D37 00 00            DW 0 ; Z
 166  4D39
 167  4D39              CMDS_M:
 168  4D39               IFNDEF EXCLUDE_VRAM_CMDS
 169  4D39 4D 45 4D 56      DB "MEMVRM", 0
 169  4D3D 52 4D 00
 170  4D40 1F 51            DW MEMVRM
 171  4D42               ENDIF
 172  4D42               IFNDEF EXCLUDE_RAM_CMDS
 173  4D42 4D 45 4D 43  	DB "MEMCPY", 0
 173  4D46 50 59 00
 174  4D49 DE 4F        	DW MEMCPY
 175  4D4B               ENDIF
 176  4D4B 00           	DB 0
 177  4D4C              CMDS_F:
 178  4D4C               IFNDEF EXCLUDE_VRAM_CMDS
 179  4D4C 46 49 4C 56      DB "FILVRM", 0
 179  4D50 52 4D 00
 180  4D53 21 50            DW FILVRM
 181  4D55               ENDIF
 182  4D55               IFNDEF EXCLUDE_RAM_CMDS
 183  4D55 46 49 4C 52      DB "FILRAM", 0
 183  4D59 41 4D 00
 184  4D5C 68 50            DW FILRAM
 185  4D5E               ENDIF
 186  4D5E 00               DB 0
 187  4D5F              CMDS_G:
 188  4D5F               IFNDEF EXCLUDE_GENCAL
 189  4D5F 47 45 4E 43      DB "GENCAL", 0
 189  4D63 41 4C 00
 190  4D66 C6 50            DW GENCAL
 191  4D68               ENDIF
 192  4D68 00           	DB	0
 193  4D69              CMDS_V:
 194  4D69               IFNDEF EXCLUDE_VRAM_CMDS
 195  4D69 56 52 4D 4D  	DB "VRMMEM", 0
 195  4D6D 45 4D 00
 196  4D70 9A 51        	DW VRMMEM
 197  4D72               ENDIF
 198  4D72 00           	DB 0
 199  4D73              CMDS_S:
 200  4D73               IFNDEF EXCLUDE_SPRITE_CMDS
 201  4D73 53 50 52 53  	DB "SPRSET", 0
 201  4D77 45 54 00
 202  4D7A 82 53        	DW SPRSET
 203  4D7C 53 50 52 47  	DB "SPRGRPMOV", 0
 203  4D80 52 50 4D 4F
 203  4D84 56 00
 204  4D86 42 54        	DW SPRGRPMOV
 205  4D88               ENDIF
 206  4D88               IFNDEF EXCLUDE_SOUND_PLAYER
 207  4D88 53 4E 44 53  	DB "SNDSFX", 0
 207  4D8C 46 58 00
 208  4D8F D8 52        	DW SNDSFX
 209  4D91 53 4E 44 50  	DB "SNDPLYON", 0
 209  4D95 4C 59 4F 4E
 209  4D99 00
 210  4D9A A2 52        	DW SNDPLYON
 211  4D9C 53 4E 44 50  	DB "SNDPLYOFF", 0
 211  4DA0 4C 59 4F 46
 211  4DA4 46 00
 212  4DA6 B5 52        	DW SNDPLYOFF
 213  4DA8 53 4E 44 50  	DB "SNDPLYINI", 0
 213  4DAC 4C 59 49 4E
 213  4DB0 49 00
 214  4DB2 58 52        	DW SNDPLYINIT
 215  4DB4               ENDIF
 216  4DB4               IFNDEF EXCLUDE_SPRITE_CMDS
 217  4DB4 53 50 52 41  	DB "SPRATRINI", 0
 217  4DB8 54 52 49 4E
 217  4DBC 49 00
 218  4DBE 32 53        	DW SPRATRINI
 219  4DC0               ENDIF
 220  4DC0 00           	DB 0
 221  4DC1              CMDS_B:
 222  4DC1               IFNDEF EXCLUDE_BLIT_CMDS
 223  4DC1 42 4C 49 54  	DB "BLIT", 0
 223  4DC5 00
 224  4DC6 40 56        	DW BLIT
 225  4DC8 42 4F 58 4D  	DB "BOXMEMCPY", 0
 225  4DCC 45 4D 43 50
 225  4DD0 59 00
 226  4DD2 67 57        	DW BOXMEMCPY
 227  4DD4 42 4F 58 4D  	DB "BOXMEMVRM", 0
 227  4DD8 45 4D 56 52
 227  4DDC 4D 00
 228  4DDE 9B 57        	DW BOXMEMVRM
 229  4DE0               ENDIF
 230  4DE0 00           	DB 0
 231  4DE1              CMDS_T:
 232  4DE1               IFNDEF EXCLUDE_BLIT_CMDS
 233  4DE1 54 49 4C 45  	DB "TILERAM", 0
 233  4DE5 52 41 4D 00
 234  4DE9 AD 56        	DW TILERAM
 235  4DEB 54 49 4C 45  	DB "TILEVRM", 0
 235  4DEF 56 52 4D 00
 236  4DF3 F4 56        	DW TILEVRM
 237  4DF5               ENDIF
 238  4DF5 00           	DB 0
 239  4DF6
 240  4DF6              ; ****************************************************************************************************
 241  4DF6              ; function sets VRAM address
 242  4DF6              ; input HL=address
 243  4DF6              ; modifies AF
 244  4DF6              SETWRT_LOCAL:
 245  4DF6 7D           	LD	A, L
 246  4DF7 D3 99        	OUT	(099H), A
 247  4DF9 7C           	LD	A, H
 248  4DFA E6 3F        	AND	03FH
 249  4DFC F6 40        	OR	040H
 250  4DFE D3 99        	OUT	(099H), A
 251  4E00 C9           	RET
 252  4E01              ; ****************************************************************************************************
 253  4E01
 254  4E01              ; ****************************************************************************************************
 255  4E01              ; function gets slot and subslot data for specific page
 256  4E01              ; input A=page (0, 1 or 2)
 257  4E01              ; output B = 0A8H register value
 258  4E01              ; output D = 0 is no subslots, 1 if yes
 259  4E01              ; output C = 0A8H value when page 3 slot equals to requested page slot
 260  4E01              ; output E = subslot value if present
 261  4E01              ; modifies AF, BC, DE, HL
 262  4E01              GET_PAGE_INFO:
 263  4E01 6F               LD L, A
 264  4E02 C6 C1            ADD A, low (EXPTBL)
 265  4E04 32 0E 4E         LD (GET_PAGE_INFO_L1+1), A
 266  4E07 DB A8            IN A, (0A8H)
 267  4E09 47               LD B, A
 268  4E0A E6 3F            AND 03FH
 269  4E0C 4F               LD C, A
 270  4E0D              GET_PAGE_INFO_L1:
 271  4E0D 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 272  4E10 E6 80            AND 080H
 273  4E12 28 1B            JR Z, GET_PAGE_INFO_L2
 274  4E14                  ; expanded
 275  4E14 2D               DEC L
 276  4E15 FA 34 4E         JP M, GET_PAGE_INFO_L3
 277  4E18 2D               DEC L
 278  4E19 FA 32 4E         JP M, GET_PAGE_INFO_L4
 279  4E1C                  ; page 2
 280  4E1C 07               RLCA
 281  4E1D 07               RLCA
 282  4E1E              GET_PAGE_INFO_L5:
 283  4E1E E6 C0            AND 0C0H
 284  4E20 B1               OR C
 285  4E21 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 286  4E23 4F               LD C, A
 287  4E24 3A FF FF         LD A, (0FFFFH)
 288  4E27 2F               CPL
 289  4E28 5F               LD E, A
 290  4E29 16 01            LD D, 1
 291  4E2B 78               LD A, B ; return stack
 292  4E2C D3 A8            OUT (0A8H), A
 293  4E2E C9               RET
 294  4E2F              GET_PAGE_INFO_L2:
 295  4E2F                  ; not expanded
 296  4E2F 16 00            LD D, 0
 297  4E31 C9               RET
 298  4E32              GET_PAGE_INFO_L4:
 299  4E32                  ; page 1
 300  4E32 0F               RRCA
 301  4E33 0F               RRCA
 302  4E34              GET_PAGE_INFO_L3:
 303  4E34                  ; page 0
 304  4E34 0F               RRCA
 305  4E35 0F               RRCA
 306  4E36 18 E6            JR GET_PAGE_INFO_L5
 307  4E38              ; ****************************************************************************************************
 308  4E38
 309  4E38              ; ****************************************************************************************************
 310  4E38              ; function returns original slot and subslot info
 311  4E38              ; input B = 0A8H register value
 312  4E38              ; input D = 0 is no subslots, 1 if yes
 313  4E38              ; input C = 0A8H value when page 3 slot equals to requested page slot
 314  4E38              ; input E = subslot value if present
 315  4E38              ; modifies AF, disables interrupts
 316  4E38              RESTORE_PAGE_INFO:
 317  4E38 7A               LD A, D
 318  4E39 B7               OR A
 319  4E3A 28 08            JR Z, RESTORE_PAGE_INFO_L1
 320  4E3C 79               LD A, C
 321  4E3D F3           	DI
 322  4E3E D3 A8            OUT (0A8H), A
 323  4E40 7B               LD A, E
 324  4E41 32 FF FF         LD (0FFFFH), A
 325  4E44              RESTORE_PAGE_INFO_L1:
 326  4E44 78               LD A, B
 327  4E45 D3 A8            OUT (0A8H), A
 328  4E47 C9               RET
 329  4E48              ; ****************************************************************************************************
 330  4E48
 331  4E48              ; *******************************************************************************************************
 332  4E48              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 333  4E48              ; INPUT:  A = SLOT ID: EXXXSSPP
 334  4E48              ; E = EXPANDED FLAG
 335  4E48              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 336  4E48              ; PP = PRIMARY SLOT NUMBER
 337  4E48              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 338  4E48              ; CHANGES: AF, BC, DE
 339  4E48
 340  4E48              LOCAL_ENASLT:
 341  4E48 CD 68 4E         CALL L0353
 342  4E4B FA 55 4E         JP M, L0340
 343  4E4E DB A8            IN A, (0A8H)
 344  4E50 A1               AND C
 345  4E51 B0               OR B
 346  4E52 D3 A8            OUT (0A8H), A
 347  4E54 C9               RET
 348  4E55              L0340:
 349  4E55 E5               PUSH HL
 350  4E56 CD 8D 4E         CALL L0378
 351  4E59 4F               LD C, A
 352  4E5A 06 00            LD B, 0
 353  4E5C 7D               LD A, L
 354  4E5D A4               AND H
 355  4E5E B2               OR D
 356  4E5F 21 C5 FC         LD HL, 0FCC5H
 357  4E62 09               ADD HL, BC
 358  4E63 77               LD (HL), A
 359  4E64 E1               POP HL
 360  4E65 79               LD A, C
 361  4E66 18 E0            JR LOCAL_ENASLT
 362  4E68              L0353:
 363  4E68 F3               DI
 364  4E69 F5               PUSH AF
 365  4E6A 7C               LD A, H
 366  4E6B 07               RLCA
 367  4E6C 07               RLCA
 368  4E6D E6 03            AND 3
 369  4E6F 5F               LD E, A
 370  4E70 3E C0            LD A, 0C0H
 371  4E72              L035D:
 372  4E72 07               RLCA
 373  4E73 07               RLCA
 374  4E74 1D               DEC E
 375  4E75 F2 72 4E         JP P, L035D
 376  4E78 5F               LD E, A
 377  4E79 2F               CPL
 378  4E7A 4F               LD C, A
 379  4E7B F1               POP AF
 380  4E7C F5               PUSH AF
 381  4E7D E6 03            AND 3
 382  4E7F 3C               INC A
 383  4E80 47               LD B, A
 384  4E81 3E AB            LD A, 0ABH
 385  4E83              L036E:
 386  4E83 C6 55            ADD A, 055H
 387  4E85 10 FC            DJNZ L036E
 388  4E87 57               LD D, A
 389  4E88 A3               AND E
 390  4E89 47               LD B, A
 391  4E8A F1               POP AF
 392  4E8B A7               AND A
 393  4E8C C9               RET
 394  4E8D              L0378:
 395  4E8D F5               PUSH AF
 396  4E8E 7A               LD A, D
 397  4E8F E6 C0            AND 0C0H
 398  4E91 4F               LD C, A
 399  4E92 F1               POP AF
 400  4E93 F5               PUSH AF
 401  4E94 57               LD D, A
 402  4E95 DB A8            IN A, (0A8H)
 403  4E97 47               LD B, A
 404  4E98 E6 3F            AND 03FH
 405  4E9A B1               OR C
 406  4E9B D3 A8            OUT (0A8H), A
 407  4E9D 7A               LD A, D
 408  4E9E 0F               RRCA
 409  4E9F 0F               RRCA
 410  4EA0 E6 03            AND 3
 411  4EA2 57               LD D, A
 412  4EA3 3E AB            LD A, 0ABH
 413  4EA5              L0390:
 414  4EA5 C6 55            ADD A, 055H
 415  4EA7 15               DEC D
 416  4EA8 F2 A5 4E         JP P, L0390
 417  4EAB A3               AND E
 418  4EAC 57               LD D, A
 419  4EAD 7B               LD A, E
 420  4EAE 2F               CPL
 421  4EAF 67               LD H, A
 422  4EB0 3A FF FF         LD A, (0FFFFH)
 423  4EB3 2F               CPL
 424  4EB4 6F               LD L, A
 425  4EB5 A4               AND H
 426  4EB6 B2               OR D
 427  4EB7 32 FF FF         LD (0FFFFH), A
 428  4EBA 78               LD A, B
 429  4EBB D3 A8            OUT (0A8H), A
 430  4EBD F1               POP AF
 431  4EBE E6 03            AND 3
 432  4EC0 C9               RET
 433  4EC1              ; *******************************************************************************************************
 434  4EC1
 435  4EC1              ; *******************************************************************************************************
 436  4EC1              ; some common code to activate page 0 and place values needed to restore original page on stack
 437  4EC1              ; input IY=return address
 438  4EC1              ENABLE_PAGE0:
 439  4EC1 AF               XOR A
 440  4EC2 CD 01 4E         CALL GET_PAGE_INFO
 441  4EC5 C5               PUSH BC
 442  4EC6 D5               PUSH DE
 443  4EC7 3A 41 F3         LD A, (RAMAD0)
 444  4ECA 26 00            LD H, 0
 445  4ECC CD 48 4E         CALL LOCAL_ENASLT
 446  4ECF FD E9        	JP (IY)
 447  4ED1              ; *******************************************************************************************************
 448  4ED1
 449  4ED1               IFNDEF EXCLUDE_SPRITE_CMDS
 450  4ED1              ; *******************************************************************************************************
 451  4ED1              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 452  4ED1              ; struct {
 453  4ED1              ; DW y
 454  4ED1              ; DW x
 455  4ED1              ; DW pattern (0-31)
 456  4ED1              ; DW color
 457  4ED1              ; } [32]
 458  4ED1              ; will hide sprites whose location is outside of visible area
 459  4ED1              ; works in screen 1 and 2
 460  4ED1              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 461  4ED1              ; modifies AF, AF', BC, DE, HL
 462  4ED1              SPRATR_UPDATE:
 463  4ED1              	; check if initialized
 464  4ED1 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 465  4ED4 B7           	OR A
 466  4ED5 C8           	RET Z
 467  4ED6              	; check if update requested
 468  4ED6 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 469  4ED9 7E           	LD A, (HL)
 470  4EDA B7           	OR A
 471  4EDB C8           	RET Z
 472  4EDC              	; check screen mode
 473  4EDC 3A AF FC     	LD A, (SCRMOD)
 474  4EDF 3D           	DEC A
 475  4EE0 28 02        	JR Z, .L0 ; screen 1
 476  4EE2 3D           	DEC A
 477  4EE3 C0           	RET NZ ; not screen 2
 478  4EE4              .L0:
 479  4EE4 06 20        	LD B, 32 ; sprite number
 480  4EE6 0E 98        	LD C, #98 ; register for vdp data output
 481  4EE8              	; set VDP address
 482  4EE8 2A 28 F9     	LD HL, (ATRBAS)
 483  4EEB 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
 484  4EEE B7           	OR A
 485  4EEF 28 03        	JR Z, .L3
 486  4EF1 3A FE 4C     	LD A, (FLICKER)
 487  4EF4              .L3:
 488  4EF4 5F           	LD E, A
 489  4EF5 08           	EX AF, AF'
 490  4EF6 7B           	LD A, E
 491  4EF7 87           	ADD A, A
 492  4EF8 87           	ADD A, A
 493  4EF9 16 00        	LD D, 0
 494  4EFB 5F           	LD E, A
 495  4EFC 19           	ADD HL, DE
 496  4EFD CD F6 4D     	CALL SETWRT_LOCAL
 497  4F00 ED 73 FF 4C  	LD (TMPSP), SP
 498  4F04 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
 499  4F08
 500  4F08              .LOOP:
 501  4F08 E1           	POP HL
 502  4F09 24           	INC H
 503  4F0A 28 0D        	JR Z, .L1 ; negative number above -256
 504  4F0C 25           	DEC H
 505  4F0D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 506  4F0F 7D           	LD A, L
 507  4F10 FE C0        	CP 192
 508  4F12 30 10        	JR NC, .OUT3
 509  4F14 3D           	DEC A ; due to VDP rule that top of screen is -1
 510  4F15 57           	LD D, A
 511  4F16 C3 34 4F     	JP .X
 512  4F19              .L1:
 513  4F19 7D           	LD A, L
 514  4F1A C6 10        	ADD 16
 515  4F1C FA 24 4F     	JP M, .OUT3 ; below -16
 516  4F1F 2D           	DEC L ; due to VDP rule that top of screen is -1
 517  4F20 55           	LD D, L
 518  4F21 C3 34 4F     	JP .X
 519  4F24              .OUT3:
 520  4F24 E1           	POP HL ; skip x value
 521  4F25              .OUT2:
 522  4F25 E1           	POP HL ; skip pattern
 523  4F26 E1           	POP HL ; skip color
 524  4F27 3E D1        	LD A, #D1
 525  4F29 D3 98        	OUT (#98), A ; sprite hidden
 526  4F2B D3 98        	OUT (#98), A ; value unimportant
 527  4F2D D3 98        	OUT (#98), A ; value unimportant
 528  4F2F D3 98        	OUT (#98), A ; value unimportant
 529  4F31 C3 58 4F     	JP .NEXT
 530  4F34              .X:
 531  4F34 E1           	POP HL
 532  4F35 24           	INC H
 533  4F36 28 08        	JR Z, .L2
 534  4F38 25           	DEC H
 535  4F39 20 EA        	JR NZ, .OUT2
 536  4F3B 1E 00        	LD E, 0 ; EC bit
 537  4F3D C3 49 4F     	JP .XY
 538  4F40              .L2:
 539  4F40 7D           	LD A, L
 540  4F41 C6 20        	ADD 32
 541  4F43 FA 25 4F     	JP M, .OUT2
 542  4F46 6F           	LD L, A
 543  4F47 1E 80        	LD E, #80
 544  4F49              .XY:
 545  4F49 ED 51        	OUT (C), D
 546  4F4B ED 69        	OUT (C), L
 547  4F4D E1           	POP HL ; pattern
 548  4F4E 7D           	LD A, L
 549  4F4F 87           	ADD A, A
 550  4F50 87           	ADD A, A ; needs to go at 4x
 551  4F51 D3 98        	OUT (#98), A
 552  4F53 E1           	POP HL ; color
 553  4F54 7D           	LD A, L
 554  4F55 B3           	OR E
 555  4F56 D3 98        	OUT (#98), A
 556  4F58              .NEXT:
 557  4F58 08           	EX AF, AF'
 558  4F59 3C           	INC A
 559  4F5A E6 1F        	AND 31
 560  4F5C C2 70 4F     	JP NZ, .NEXT2
 561  4F5F 08           	EX AF, AF'
 562  4F60 2A 28 F9     	LD HL, (ATRBAS)
 563  4F63              	; CALL SETWRT_LOCAL not allowed as SP modified
 564  4F63 7D           	LD	A, L
 565  4F64 D3 99        	OUT	(099H), A
 566  4F66 7C           	LD	A, H
 567  4F67 E6 3F        	AND	03FH
 568  4F69 F6 40        	OR	040H
 569  4F6B D3 99        	OUT	(099H), A
 570  4F6D C3 71 4F     	JP .NEXT3
 571  4F70              .NEXT2:
 572  4F70 08           	EX AF, AF'
 573  4F71              .NEXT3:
 574  4F71 10 95        	DJNZ .LOOP
 575  4F73 08           	EX AF, AF'
 576  4F74 3C           	INC A
 577  4F75 32 FE 4C     	LD (FLICKER), A
 578  4F78
 579  4F78 ED 7B FF 4C  	LD SP, (TMPSP)
 580  4F7C 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 581  4F7F 36 00        	LD (HL), 0 ; zero out update flag
 582  4F81 C9           	RET
 583  4F82              ; *******************************************************************************************************
 584  4F82               ENDIF
 585  4F82
 586  4F82              ; General BASIC CALL-instruction handler
 587  4F82              CALLHAND:
 588  4F82 E5           	PUSH HL
 589  4F83 21 05 4D     	LD	HL, CMDS ; pointer table based on starting letter
 590  4F86 3A 89 FD         LD A, (PROCNM)
 591  4F89 D6 41            SUB 'A'
 592  4F8B 87               ADD A, A
 593  4F8C 16 00            LD D, 0
 594  4F8E 5F               LD E, A
 595  4F8F 19               ADD HL, DE
 596  4F90 5E               LD E, (HL)
 597  4F91 23               INC HL
 598  4F92 56               LD D, (HL)
 599  4F93 7A               LD A, D
 600  4F94 B3               OR E
 601  4F95 28 24            JR Z, .CMDNOTRECOGNIZED
 602  4F97 EB               EX DE, HL
 603  4F98              .CHKCMD:
 604  4F98 11 89 FD     	LD	DE, PROCNM
 605  4F9B 1A           .LOOP:	LD	A,(DE)
 606  4F9C BE           	CP	(HL)
 607  4F9D 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 608  4F9F 13           	INC	DE
 609  4FA0 23           	INC	HL
 610  4FA1 A7           	AND	A
 611  4FA2 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 612  4FA4 5E           	LD	E,(HL)
 613  4FA5 23           	INC	HL
 614  4FA6 56           	LD	D,(HL)
 615  4FA7 E1           	POP	HL		; routine address
 616  4FA8 CD C9 4F     	CALL	GETPREVCHAR
 617  4FAB CD BD 4F     	CALL	.CALLDE		; Call routine
 618  4FAE A7           	AND	A
 619  4FAF C9           	RET
 620  4FB0
 621  4FB0              .TONEXTCMD:
 622  4FB0 0E FF        	LD	C,0FFH
 623  4FB2 AF           	XOR	A
 624  4FB3 ED B1        	CPIR			; Skip to end of instruction name
 625  4FB5 23           	INC	HL
 626  4FB6 23           	INC	HL		; Skip address
 627  4FB7 BE           	CP	(HL)
 628  4FB8 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 629  4FBA E1           	POP	HL
 630  4FBB              .CMDNOTRECOGNIZED:
 631  4FBB 37               SCF
 632  4FBC C9           	RET
 633  4FBD
 634  4FBD              .CALLDE:
 635  4FBD D5           	PUSH	DE
 636  4FBE C9           	RET
 637  4FBF
 638  4FBF              ;---------------------------
 639  4FBF
 640  4FBF              ;GETSTRPNT:
 641  4FBF              ; OUT:
 642  4FBF              ; HL = String Address
 643  4FBF              ; B  = Lenght
 644  4FBF              ;        LD      HL,(USR)
 645  4FBF              ;        LD      B,(HL)
 646  4FBF              ;        INC     HL
 647  4FBF              ;        LD      E,(HL)
 648  4FBF              ;        INC     HL
 649  4FBF              ;        LD      D,(HL)
 650  4FBF              ;        EX      DE,HL
 651  4FBF              ;        RET
 652  4FBF
 653  4FBF              ;EVALTXTPARAM:
 654  4FBF              ;	CALL	CHKCHAR
 655  4FBF              ;	DEFB	"("             ; Check for (
 656  4FBF              ;	LD	IX,FRMEVL
 657  4FBF              ;	CALL	CALBAS		; Evaluate expression
 658  4FBF              ;       LD      A,(VALTYP)
 659  4FBF              ;        CP      3               ; Text type?
 660  4FBF              ;        JP      NZ,TYPE_MISMATCH
 661  4FBF              ;        PUSH	HL
 662  4FBF              ;        LD	IX,FRESTR         ; Free the temporary string
 663  4FBF              ;        CALL	CALBAS
 664  4FBF              ;        POP	HL
 665  4FBF              ;	CALL	CHKCHAR
 666  4FBF              ;	DEFB	")"             ; Check for )
 667  4FBF              ;        RET
 668  4FBF
 669  4FBF
 670  4FBF              CHKCHAR:
 671  4FBF CD C9 4F     	CALL	GETPREVCHAR	; Get previous basic char
 672  4FC2 E3           	EX	(SP),HL
 673  4FC3 BE           	CP	(HL) 	        ; Check if good char
 674  4FC4 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 675  4FC6 23           	INC	HL
 676  4FC7 E3           	EX	(SP),HL
 677  4FC8 23           	INC	HL		; Get next basic char
 678  4FC9
 679  4FC9              GETPREVCHAR:
 680  4FC9 2B           	DEC	HL
 681  4FCA DD 21 66 46  	LD	IX,CHRGTR
 682  4FCE C3 59 01     	JP      CALBAS
 683  4FD1
 684  4FD1
 685  4FD1              TYPE_MISMATCH:
 686  4FD1 1E 0D            LD E, 13 ; Type mismatch
 687  4FD3 18 02            JR THROW_ERROR
 688  4FD5
 689  4FD5              SYNTAX_ERROR:
 690  4FD5 1E 02            LD E, 2 ; Syntax error
 691  4FD7              THROW_ERROR:
 692  4FD7 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 693  4FDB C3 59 01     	JP	CALBAS
 694  4FDE
 695  4FDE              ;---------------------------
 696  4FDE
 697  4FDE               IFNDEF EXCLUDE_RAM_CMDS
 698  4FDE              ; *******************************************************************************************************
 699  4FDE              ; function to handle CALL MEMCPY basic extension
 700  4FDE              ; _MEMCPY ( INT source,
 701  4FDE              ;			INT destination,
 702  4FDE              ;			INT count,
 703  4FDE              ; will put ram in page 0 also, page 1 is already there
 704  4FDE              MEMCPY:
 705  4FDE              	; opening (
 706  4FDE CD BF 4F     	CALL CHKCHAR
 707  4FE1 28           	DB '('
 708  4FE2              	; get source address
 709  4FE2 DD 21 2F 54  	LD IX, FRMQNT
 710  4FE6 CD 59 01     	CALL CALBAS
 711  4FE9 D5           	PUSH DE
 712  4FEA              	; comma
 713  4FEA CD BF 4F     	CALL CHKCHAR
 714  4FED 2C           	DB ','
 715  4FEE              	; get destination address
 716  4FEE DD 21 2F 54  	LD IX, FRMQNT
 717  4FF2 CD 59 01     	CALL CALBAS
 718  4FF5 D5           	PUSH DE
 719  4FF6              	; comma
 720  4FF6 CD BF 4F     	CALL CHKCHAR
 721  4FF9 2C           	DB ','
 722  4FFA              	; get length
 723  4FFA DD 21 2F 54  	LD IX, FRMQNT
 724  4FFE CD 59 01     	CALL CALBAS
 725  5001 D5           	PUSH DE
 726  5002              	; ending )
 727  5002 CD BF 4F     	CALL CHKCHAR
 728  5005 29           	DB ')'
 729  5006
 730  5006              	; save position
 731  5006 E5           	PUSH HL
 732  5007 DD E1        	POP IX
 733  5009
 734  5009 C1           	POP BC ; count
 735  500A D1           	POP DE ; destination
 736  500B E1           	POP HL ; source
 737  500C D9           	EXX
 738  500D              	; enable page 0
 739  500D FD 21 14 50  	LD IY, .RET
 740  5011 C3 C1 4E     	JP ENABLE_PAGE0
 741  5014              .RET:
 742  5014 FB           	EI
 743  5015 D9           	EXX
 744  5016 ED B0        	LDIR
 745  5018 D1               POP DE
 746  5019 C1               POP BC
 747  501A CD 38 4E         CALL RESTORE_PAGE_INFO
 748  501D DD E5        	PUSH IX
 749  501F E1           	POP HL
 750  5020 C9           	RET
 751  5021              ; *******************************************************************************************************
 752  5021               ENDIF
 753  5021               IFNDEF EXCLUDE_VRAM_CMDS
 754  5021              ; *******************************************************************************************************
 755  5021              ; function to handle CALL FILVRM basic extension
 756  5021              ; FILVRM ( INT offset,
 757  5021              ;		   INT count,
 758  5021              ;		   BYTE value,
 759  5021              ;		   BYTE wait_vsync) >0 = true
 760  5021              ; wait_vsync will issue HALT before copying
 761  5021              FILVRM:
 762  5021              	; opening (
 763  5021 CD BF 4F     	CALL CHKCHAR
 764  5024 28           	DB '('
 765  5025              	; get offset address
 766  5025 DD 21 2F 54  	LD IX, FRMQNT
 767  5029 CD 59 01     	CALL CALBAS
 768  502C D5           	PUSH DE
 769  502D              	; comma
 770  502D CD BF 4F     	CALL CHKCHAR
 771  5030 2C           	DB ','
 772  5031              	; get count
 773  5031 DD 21 2F 54  	LD IX, FRMQNT
 774  5035 CD 59 01     	CALL CALBAS
 775  5038 D5           	PUSH DE
 776  5039              	; comma
 777  5039 CD BF 4F     	CALL CHKCHAR
 778  503C 2C           	DB ','
 779  503D              	; get value
 780  503D DD 21 1C 52  	LD IX, GETBYT
 781  5041 CD 59 01     	CALL CALBAS
 782  5044 F5           	PUSH AF
 783  5045              	; comma
 784  5045 CD BF 4F     	CALL CHKCHAR
 785  5048 2C           	DB ','
 786  5049              	; get vsync wait
 787  5049 DD 21 1C 52  	LD IX, GETBYT
 788  504D CD 59 01     	CALL CALBAS
 789  5050 F5           	PUSH AF
 790  5051              	; ending )
 791  5051 CD BF 4F     	CALL CHKCHAR
 792  5054 29           	DB ')'
 793  5055
 794  5055 FB               EI
 795  5056              	; save position
 796  5056 E5           	PUSH HL
 797  5057 DD E1        	POP IX
 798  5059
 799  5059              	; syntax ok
 800  5059              	; wait for vsync if needed
 801  5059 F1           	POP AF
 802  505A B7           	OR A
 803  505B 28 01        	JR Z, .L1
 804  505D 76           	HALT
 805  505E
 806  505E              .L1:
 807  505E F1               POP AF ; value
 808  505F C1               POP BC ; count
 809  5060 E1               POP HL ; offset
 810  5061 CD 56 00         CALL BIOS_FILVRM
 811  5064
 812  5064              .L3:
 813  5064 DD E5        	PUSH IX
 814  5066 E1           	POP HL
 815  5067 C9           	RET
 816  5068              ; *******************************************************************************************************
 817  5068               ENDIF
 818  5068
 819  5068               IFNDEF EXCLUDE_RAM_CMDS
 820  5068              ; *******************************************************************************************************
 821  5068              ; function to handle CALL FILRAM basic extension
 822  5068              ; FILRAM ( INT start address,
 823  5068              ;		   INT count,
 824  5068              ;		   BYTE value,
 825  5068              ; will put ram in page 0 also, page 1 is already there
 826  5068              FILRAM:
 827  5068              	; opening (
 828  5068 CD BF 4F     	CALL CHKCHAR
 829  506B 28           	DB '('
 830  506C              	; get start address
 831  506C DD 21 2F 54  	LD IX, FRMQNT
 832  5070 CD 59 01     	CALL CALBAS
 833  5073 D5           	PUSH DE
 834  5074              	; comma
 835  5074 CD BF 4F     	CALL CHKCHAR
 836  5077 2C           	DB ','
 837  5078              	; get count
 838  5078 DD 21 2F 54  	LD IX, FRMQNT
 839  507C CD 59 01     	CALL CALBAS
 840  507F D5           	PUSH DE
 841  5080              	; comma
 842  5080 CD BF 4F     	CALL CHKCHAR
 843  5083 2C           	DB ','
 844  5084              	; get value
 845  5084 DD 21 1C 52  	LD IX, GETBYT
 846  5088 CD 59 01     	CALL CALBAS
 847  508B F5           	PUSH AF
 848  508C              	; ending )
 849  508C CD BF 4F     	CALL CHKCHAR
 850  508F 29           	DB ')'
 851  5090
 852  5090              	; save position
 853  5090 E5           	PUSH HL
 854  5091 DD E1        	POP IX
 855  5093
 856  5093 D1           	POP DE ; actually AF
 857  5094 C1           	POP BC ; count
 858  5095 E1           	POP HL ; start address
 859  5096 78           	LD A, B
 860  5097 B7           	OR A
 861  5098 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 862  509A B1           	OR C
 863  509B 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 864  509D 79           	LD A, C
 865  509E 3D           	DEC A
 866  509F 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 867  50A1              	; one byte to fill
 868  50A1 72           	LD (HL), D
 869  50A2 18 12        	JR .EXIT
 870  50A4              .L1:
 871  50A4 D9           	EXX
 872  50A5              	; enable page 0
 873  50A5 FD 21 AC 50  	LD IY, .RET
 874  50A9 C3 C1 4E     	JP ENABLE_PAGE0
 875  50AC              .RET:
 876  50AC FB           	EI
 877  50AD D9           	EXX
 878  50AE CD BA 50     	CALL .FILLVALUE
 879  50B1 D1               POP DE
 880  50B2 C1               POP BC
 881  50B3 CD 38 4E         CALL RESTORE_PAGE_INFO
 882  50B6              .EXIT:
 883  50B6 DD E5        	PUSH IX
 884  50B8 E1           	POP HL
 885  50B9 C9           	RET
 886  50BA
 887  50BA              .FILLVALUE:
 888  50BA 72               LD (HL), D
 889  50BB 54               LD D, H
 890  50BC 5D               LD E, L
 891  50BD 13               INC DE
 892  50BE 0B               DEC BC
 893  50BF ED B0            LDIR
 894  50C1 C9               RET
 895  50C2              ; *******************************************************************************************************
 896  50C2               ENDIF
 897  50C2
 898  50C2               IFNDEF EXCLUDE_GENCAL
 899  50C2              ; *******************************************************************************************************
 900  50C2              ; function to handle CALL GENCAL basic extension
 901  50C2              ; GENCAL ( INT fn_addr, = address of the function to call
 902  50C2              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 903  50C2              ; output values of reristers will also be stored at reg_list_ptr
 904  50C2              GENCAL_VAR_SP:
 905  50C2 00 00            DW 0
 906  50C4              GENCAL_VAR_SP2:
 907  50C4 00 00            DW 0
 908  50C6              GENCAL:
 909  50C6              	; opening (
 910  50C6 CD BF 4F     	CALL CHKCHAR
 911  50C9 28           	DB '('
 912  50CA              	; get function address
 913  50CA DD 21 2F 54  	LD IX, FRMQNT
 914  50CE CD 59 01     	CALL CALBAS
 915  50D1 D5           	PUSH DE
 916  50D2              	; comma
 917  50D2 CD BF 4F     	CALL CHKCHAR
 918  50D5 2C           	DB ','
 919  50D6              	; get pointer to register list
 920  50D6 DD 21 2F 54  	LD IX, FRMQNT
 921  50DA CD 59 01     	CALL CALBAS
 922  50DD D5           	PUSH DE
 923  50DE              	; ending )
 924  50DE CD BF 4F     	CALL CHKCHAR
 925  50E1 29           	DB ')'
 926  50E2
 927  50E2              	; save BASIC token position
 928  50E2 E5           	PUSH HL
 929  50E3 D9               EXX
 930  50E4 E1           	POP HL ; HL'=next basic token
 931  50E5 D9               EXX
 932  50E6
 933  50E6 E1               POP HL ; get pointer to register values
 934  50E7 ED 73 C2 50      LD (GENCAL_VAR_SP), SP
 935  50EB F3               DI
 936  50EC F9               LD SP, HL
 937  50ED F1               POP AF
 938  50EE C1               POP BC
 939  50EF D1               POP DE
 940  50F0 E1               POP HL
 941  50F1 DD E1            POP IX
 942  50F3 FD E1            POP IY
 943  50F5 D9               EXX
 944  50F6 ED 73 C4 50      LD (GENCAL_VAR_SP2), SP
 945  50FA ED 7B C2 50      LD SP, (GENCAL_VAR_SP)
 946  50FE FB               EI
 947  50FF D1               POP DE ; get function to call
 948  5100 E5               PUSH HL
 949  5101 CD 1C 51         CALL .EXXDECALL
 950  5104 F3               DI
 951  5105 ED 73 C2 50      LD (GENCAL_VAR_SP), SP
 952  5109 ED 7B C4 50      LD SP, (GENCAL_VAR_SP2)
 953  510D FD E5            PUSH IY
 954  510F DD E5            PUSH IX
 955  5111 E5               PUSH HL
 956  5112 D5               PUSH DE
 957  5113 C5               PUSH BC
 958  5114 F5               PUSH AF
 959  5115 ED 7B C2 50      LD SP, (GENCAL_VAR_SP)
 960  5119 FB               EI
 961  511A E1               POP HL
 962  511B C9           	RET
 963  511C
 964  511C              .EXXDECALL:
 965  511C D5               PUSH DE
 966  511D D9               EXX
 967  511E C9               RET
 968  511F              ; *******************************************************************************************************
 969  511F               ENDIF
 970  511F
 971  511F               IFNDEF EXCLUDE_VRAM_CMDS
 972  511F              ; *******************************************************************************************************
 973  511F              ; function to handle CALL MEMVRM basic extension
 974  511F              ; copies from RAM to VRAM
 975  511F              ; _MEMVRM ( INT source,
 976  511F              ;			INT destination,
 977  511F              ;			INT count,
 978  511F              ;			BYTE wait_vsync) >0 = true
 979  511F              ; will put ram in page 0 also, page 1 is already there
 980  511F              ; wait_vsync will issue HALT before copying
 981  511F              MEMVRM:
 982  511F              	; opening (
 983  511F CD BF 4F     	CALL CHKCHAR
 984  5122 28           	DB '('
 985  5123              	; get source address
 986  5123 DD 21 2F 54  	LD IX, FRMQNT
 987  5127 CD 59 01     	CALL CALBAS
 988  512A D5           	PUSH DE
 989  512B              	; comma
 990  512B CD BF 4F     	CALL CHKCHAR
 991  512E 2C           	DB ','
 992  512F              	; get destination address
 993  512F DD 21 2F 54  	LD IX, FRMQNT
 994  5133 CD 59 01     	CALL CALBAS
 995  5136 D5           	PUSH DE
 996  5137              	; comma
 997  5137 CD BF 4F     	CALL CHKCHAR
 998  513A 2C           	DB ','
 999  513B              	; get length
1000  513B DD 21 2F 54  	LD IX, FRMQNT
1001  513F CD 59 01     	CALL CALBAS
1002  5142 D5           	PUSH DE
1003  5143              	; comma
1004  5143 CD BF 4F     	CALL CHKCHAR
1005  5146 2C           	DB ','
1006  5147              	; get vsync wait
1007  5147 DD 21 1C 52  	LD IX, GETBYT
1008  514B CD 59 01     	CALL CALBAS
1009  514E F5           	PUSH AF
1010  514F              	; ending )
1011  514F CD BF 4F     	CALL CHKCHAR
1012  5152 29           	DB ')'
1013  5153
1014  5153                  ; save position in BASIC text
1015  5153 E5           	PUSH HL
1016  5154 DD E1        	POP IX
1017  5156
1018  5156 F1           	POP AF ; wait vsync
1019  5157 B7           	OR A
1020  5158 28 03        	JR Z, .L1
1021  515A FB               EI
1022  515B 76           	HALT
1023  515C F3           	DI
1024  515D              .L1:
1025  515D              	; pop LDIR parameters and store away for later
1026  515D C1           	POP BC ; count
1027  515E D1           	POP DE ; vram destination
1028  515F E1           	POP HL ; ram source
1029  5160 D9           	EXX
1030  5161 FD 21 68 51   	LD IY, .RET
1031  5165 C3 C1 4E     	JP ENABLE_PAGE0
1032  5168              .RET:
1033  5168 FB           	EI
1034  5169 D9           	EXX
1035  516A CD 76 51     	CALL .LDIRVM
1036  516D D1               POP DE
1037  516E C1               POP BC
1038  516F CD 38 4E         CALL RESTORE_PAGE_INFO
1039  5172 DD E5        	PUSH IX
1040  5174 E1           	POP HL
1041  5175 C9           	RET
1042  5176
1043  5176              .LDIRVM:
1044  5176 EB           	EX DE, HL
1045  5177 F3           	DI
1046  5178 CD F6 4D     	CALL SETWRT_LOCAL
1047  517B FB           	EI
1048  517C EB           	EX DE, HL
1049  517D 78           	LD A, B
1050  517E B7           	OR A
1051  517F 28 0D        	JR Z, .L3
1052  5181 C5           	PUSH BC
1053  5182 0E 98        	LD C, #98
1054  5184              .L2:
1055  5184 50           	LD D, B
1056  5185 06 00        	LD B, 0
1057  5187 CD 94 51     	CALL .BBYTECOPY
1058  518A 42           	LD B, D
1059  518B 10 F7        	DJNZ .L2
1060  518D C1           	POP BC
1061  518E              .L3:
1062  518E 79           	LD A, C
1063  518F B7           	OR A
1064  5190 C8           	RET Z
1065  5191 41           	LD B, C
1066  5192 0E 98        	LD C, #98
1067  5194              .BBYTECOPY:
1068  5194 ED A3        	OUTI
1069  5196 C2 94 51     	JP	NZ, .BBYTECOPY
1070  5199 C9           	RET
1071  519A              ; *******************************************************************************************************
1072  519A               ENDIF
1073  519A
1074  519A               IFNDEF EXCLUDE_VRAM_CMDS
1075  519A              ; *******************************************************************************************************
1076  519A              ; function to handle CALL VRMMEM basic extension
1077  519A              ; copies from RAM to VRAM
1078  519A              ; _VRMMEM ( INT source,
1079  519A              ;			INT destination,
1080  519A              ;			INT count
1081  519A              ; will put ram in page 0 also, page 1 is already there
1082  519A              VRMMEM:
1083  519A              	; opening (
1084  519A CD BF 4F     	CALL CHKCHAR
1085  519D 28           	DB '('
1086  519E              	; get source address
1087  519E DD 21 2F 54  	LD IX, FRMQNT
1088  51A2 CD 59 01     	CALL CALBAS
1089  51A5 D5           	PUSH DE
1090  51A6              	; comma
1091  51A6 CD BF 4F     	CALL CHKCHAR
1092  51A9 2C           	DB ','
1093  51AA              	; get destination address
1094  51AA DD 21 2F 54  	LD IX, FRMQNT
1095  51AE CD 59 01     	CALL CALBAS
1096  51B1 D5           	PUSH DE
1097  51B2              	; comma
1098  51B2 CD BF 4F     	CALL CHKCHAR
1099  51B5 2C           	DB ','
1100  51B6              	; get length
1101  51B6 DD 21 2F 54  	LD IX, FRMQNT
1102  51BA CD 59 01     	CALL CALBAS
1103  51BD D5           	PUSH DE
1104  51BE              	; ending )
1105  51BE CD BF 4F     	CALL CHKCHAR
1106  51C1 29           	DB ')'
1107  51C2
1108  51C2                  ; save position in BASIC text
1109  51C2 E5           	PUSH HL
1110  51C3 DD E1        	POP IX
1111  51C5
1112  51C5 C1           	POP BC ; count
1113  51C6 D1           	POP DE ; destination
1114  51C7 E1           	POP HL ; source
1115  51C8 D9           	EXX
1116  51C9 FD 21 D0 51  	LD IY, .RET
1117  51CD C3 C1 4E     	JP ENABLE_PAGE0
1118  51D0              .RET:
1119  51D0 FB           	EI
1120  51D1 D9           	EXX
1121  51D2 CD DE 51     	CALL .LDIRMV
1122  51D5 D1               POP DE
1123  51D6 C1               POP BC
1124  51D7 CD 38 4E         CALL RESTORE_PAGE_INFO
1125  51DA DD E5        	PUSH IX
1126  51DC E1           	POP HL
1127  51DD C9           	RET
1128  51DE
1129  51DE              .LDIRMV:
1130  51DE              	; set VRAM address *exactly* as in ROM, otherwise corruption
1131  51DE 7D           	LD	A, L
1132  51DF F3           	DI
1133  51E0 D3 99        	OUT	(099H), A
1134  51E2 7C           	LD	A, H
1135  51E3 E6 3F        	AND	03FH
1136  51E5 D3 99        	OUT	(099H), A
1137  51E7 FB           	EI
1138  51E8              	;EX (SP), HL
1139  51E8              	;EX (SP), HL
1140  51E8              	;NOP
1141  51E8              	;NOP
1142  51E8              .L4:
1143  51E8 DB 98            IN A, (#98)
1144  51EA 12           	LD (DE), A
1145  51EB 13               INC DE
1146  51EC 0B               DEC BC
1147  51ED 79               LD A, C
1148  51EE B0               OR B
1149  51EF 20 F7            JR NZ, .L4
1150  51F1 C9               RET
1151  51F2              ; *******************************************************************************************************
1152  51F2               ENDIF
1153  51F2
1154  51F2              ; *******************************************************************************************************
1155  51F2              ; H.TIMI function
1156  51F2              MBGE_HTIMI:
1157  51F2               EXPORT MBGE_HTIMI
1158  51F2 F5           	PUSH AF
1159  51F3
1160  51F3               IFNDEF EXCLUDE_SPRITE_CMDS
1161  51F3 CD D1 4E     	CALL SPRATR_UPDATE
1162  51F6               ENDIF
1163  51F6
1164  51F6               IFNDEF EXCLUDE_SOUND_PLAYER
1165  51F6 3A F7 4C     	LD A, (SOUND_ENABLED)
1166  51F9 B7           	OR A
1167  51FA 28 2A        	JR Z, .EXIT
1168  51FC
1169  51FC              	; enable page 2
1170  51FC 3E 02            LD A, 2
1171  51FE CD 01 4E         CALL GET_PAGE_INFO
1172  5201 C5               PUSH BC
1173  5202 D5               PUSH DE
1174  5203 3A 43 F3         LD A, (RAMAD2)
1175  5206 26 80            LD H, 080H
1176  5208 CD 48 4E         CALL LOCAL_ENASLT
1177  520B              	; enable page 0
1178  520B AF               XOR A
1179  520C CD 01 4E         CALL GET_PAGE_INFO
1180  520F C5               PUSH BC
1181  5210 D5               PUSH DE
1182  5211 3A 41 F3         LD A, (RAMAD0)
1183  5214 26 00            LD H, 0
1184  5216 CD 48 4E         CALL LOCAL_ENASLT
1185  5219
1186  5219 CD 33 42     	CALL PLY_AKG_PLAY
1187  521C
1188  521C              	; restore page 0
1189  521C D1               POP DE
1190  521D C1               POP BC
1191  521E CD 38 4E         CALL RESTORE_PAGE_INFO
1192  5221              	; restore page 2
1193  5221 D1               POP DE
1194  5222 C1               POP BC
1195  5223 CD 38 4E         CALL RESTORE_PAGE_INFO
1196  5226               ENDIF
1197  5226
1198  5226              .EXIT:
1199  5226 F1           	POP AF
1200  5227 C3 F0 4C     	JP ORIG.HTIMI
1201  522A              ; *******************************************************************************************************
1202  522A
1203  522A              ; *******************************************************************************************************
1204  522A              ; interrupt handler when page 0 enabled
1205  522A              VBLANK:
1206  522A              	EXPORT VBLANK
1207  522A
1208  522A F5               PUSH AF
1209  522B              	; is VDP originator ?
1210  522B DB 99        	IN	A, (099H)
1211  522D A7           	AND	A
1212  522E F2 54 52     	JP P, .EXIT
1213  5231
1214  5231               IFNDEF EXCLUDE_SOUND_PLAYER
1215  5231 3A F7 4C     	LD A, (SOUND_ENABLED)
1216  5234 B7           	OR A
1217  5235 28 1D        	JR Z, .EXIT
1218  5237
1219  5237 C5               PUSH BC
1220  5238 D5               PUSH DE
1221  5239 E5               PUSH HL
1222  523A 08               EX AF, AF'
1223  523B D9               EXX
1224  523C F5               PUSH AF
1225  523D C5               PUSH BC
1226  523E D5               PUSH DE
1227  523F E5               PUSH HL
1228  5240 DD E5            PUSH IX
1229  5242 FD E5            PUSH IY
1230  5244
1231  5244 CD 33 42     	CALL PLY_AKG_PLAY
1232  5247
1233  5247 FD E1            POP IY
1234  5249 DD E1            POP IX
1235  524B E1               POP HL
1236  524C D1               POP DE
1237  524D C1               POP BC
1238  524E F1               POP AF
1239  524F 08               EX AF, AF'
1240  5250 D9               EXX
1241  5251 E1               POP HL
1242  5252 D1               POP DE
1243  5253 C1               POP BC
1244  5254               ENDIF
1245  5254
1246  5254              .EXIT:
1247  5254 F1           	POP AF
1248  5255 FB           	EI
1249  5256 ED 4D        	RETI
1250  5258              ; *******************************************************************************************************
1251  5258
1252  5258               IFNDEF EXCLUDE_SOUND_PLAYER
1253  5258              ; *******************************************************************************************************
1254  5258              ; function to handle CALL SNDPLYINIT basic extension
1255  5258              ; initializes sound player
1256  5258              ; _SNDPLYINIT ( INT music_offset,
1257  5258              ;				INT sfx_offset, can be -1 if no SFX
1258  5258              ; will put ram in page 0 also, page 1 is already there
1259  5258              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1260  5258              SNDPLYINIT:
1261  5258              	; opening (
1262  5258 CD BF 4F     	CALL CHKCHAR
1263  525B 28           	DB '('
1264  525C              	; get music address
1265  525C DD 21 2F 54  	LD IX, FRMQNT
1266  5260 CD 59 01     	CALL CALBAS
1267  5263 D5           	PUSH DE
1268  5264              	; comma
1269  5264 CD BF 4F     	CALL CHKCHAR
1270  5267 2C           	DB ','
1271  5268              	; get sfx address
1272  5268 DD 21 2F 54  	LD IX, FRMQNT
1273  526C CD 59 01     	CALL CALBAS
1274  526F D5           	PUSH DE
1275  5270              	; ending )
1276  5270 CD BF 4F     	CALL CHKCHAR
1277  5273 29           	DB ')'
1278  5274
1279  5274                  ; save position in BASIC text
1280  5274 44           	LD B, H
1281  5275 4D           	LD C, L
1282  5276
1283  5276              	; pop LDIR parameters and store away for later
1284  5276 D1           	POP DE ; sfx address
1285  5277 E1           	POP HL ; music address
1286  5278 C5           	PUSH BC ; basic text location
1287  5279 D9           	EXX
1288  527A FD 21 81 52  	LD IY, .RET
1289  527E C3 C1 4E     	JP ENABLE_PAGE0
1290  5281              .RET:
1291  5281 D9           	EXX
1292  5282
1293  5282 D5           	PUSH DE
1294  5283 AF           	XOR A
1295  5284              	; HL = music location
1296  5284 CD 62 41     	CALL PLY_AKG_INIT
1297  5287 3E 01        	LD A, 1
1298  5289 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1299  528C
1300  528C E1           	POP HL ; SFX
1301  528D              	; check if SFX address -1
1302  528D 23           	INC HL
1303  528E 7D           	LD A, L
1304  528F B4           	OR H
1305  5290 28 09        	JR Z,.L1
1306  5292 2B           	DEC HL
1307  5293 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1308  5296 3E 01        	LD A, 1
1309  5298 32 F6 4C     	LD (SFX_INIT_STATUS), A
1310  529B              .L1:
1311  529B D1               POP DE
1312  529C C1               POP BC
1313  529D CD 38 4E         CALL RESTORE_PAGE_INFO
1314  52A0
1315  52A0 E1           	POP HL
1316  52A1 C9           	RET
1317  52A2              ; *******************************************************************************************************
1318  52A2
1319  52A2              ; *******************************************************************************************************
1320  52A2              ; function to handle CALL SNDPLYON basic extension
1321  52A2              ; enables sound player
1322  52A2              ; _SNDPLYON
1323  52A2              ; sets SOUND_ENABLED variable to 1 if init call was done
1324  52A2              ; if not throws out of data error
1325  52A2              SNDPLYON:
1326  52A2 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1327  52A5 B7           	OR A
1328  52A6 20 05        	JR NZ, .L1
1329  52A8              	; player not initialized, throw error
1330  52A8 1E 04        	LD E, 04 ; Out of DATA
1331  52AA C3 D7 4F     	JP THROW_ERROR
1332  52AD              .L1:
1333  52AD 32 F7 4C     	LD (SOUND_ENABLED), A
1334  52B0              	; disable key click
1335  52B0 AF           	XOR A
1336  52B1 32 DB F3     	LD (CLIKSW), A
1337  52B4 C9           	RET
1338  52B5              ; *******************************************************************************************************
1339  52B5
1340  52B5              ; *******************************************************************************************************
1341  52B5              ; function to handle CALL SNDPLYOFF basic extension
1342  52B5              ; disables sound player
1343  52B5              ; _SNDPLYOFF
1344  52B5              ; sets SOUND_ENABLED variable to 0
1345  52B5              ; calls AKG to stop music and SFX on all channels if initialized
1346  52B5              SNDPLYOFF:
1347  52B5 3A F7 4C     	LD A, (SOUND_ENABLED)
1348  52B8 B7           	OR A
1349  52B9 C8           	RET Z ; already stopped
1350  52BA AF           	XOR A
1351  52BB 32 F7 4C     	LD (SOUND_ENABLED), A
1352  52BE E5           	PUSH HL
1353  52BF CD 21 42     	CALL PLY_AKG_STOP
1354  52C2 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1355  52C5 B7           	OR A
1356  52C6 28 0E        	JR Z, .EXIT ; SFX not in use
1357  52C8 AF           	XOR A
1358  52C9 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1359  52CC 3E 01        	LD A, 1
1360  52CE CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1361  52D1 3E 02        	LD A, 2
1362  52D3 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1363  52D6              .EXIT:
1364  52D6 E1           	POP HL
1365  52D7 C9           	RET
1366  52D8              ; *******************************************************************************************************
1367  52D8
1368  52D8              ; *******************************************************************************************************
1369  52D8              ; function to handle CALL SNDSFX basic extension
1370  52D8              ; plays a sound effect
1371  52D8              ; _SNDSFX ( BYTE sfx_number, >0
1372  52D8              ;			BYTE channel, = 0,1 or 2
1373  52D8              ;			BYTE inverted_volume = 0-16, 0 being full volume
1374  52D8              ; will put ram in page 0 also, page 1 is already there
1375  52D8              ; if sound off throws illegal function call
1376  52D8              ; if sfx not initialized, throws out of data
1377  52D8              SNDSFX:
1378  52D8              	; opening (
1379  52D8 CD BF 4F     	CALL CHKCHAR
1380  52DB 28           	DB '('
1381  52DC              	; get sfx_number
1382  52DC DD 21 1C 52  	LD IX, GETBYT
1383  52E0 CD 59 01     	CALL CALBAS
1384  52E3 D5           	PUSH DE
1385  52E4              	; comma
1386  52E4 CD BF 4F     	CALL CHKCHAR
1387  52E7 2C           	DB ','
1388  52E8              	; get sfx address
1389  52E8 DD 21 1C 52  	LD IX, GETBYT
1390  52EC CD 59 01     	CALL CALBAS
1391  52EF D5           	PUSH DE
1392  52F0              	; comma
1393  52F0 CD BF 4F     	CALL CHKCHAR
1394  52F3 2C           	DB ','
1395  52F4              	; get inverted volume
1396  52F4 DD 21 1C 52  	LD IX, GETBYT
1397  52F8 CD 59 01     	CALL CALBAS
1398  52FB D5           	PUSH DE
1399  52FC              	; ending )
1400  52FC CD BF 4F     	CALL CHKCHAR
1401  52FF 29           	DB ')'
1402  5300
1403  5300 3A F7 4C     	LD A, (SOUND_ENABLED)
1404  5303 B7           	OR A
1405  5304 20 05        	JR NZ, .L1
1406  5306              	; sound disabled, throw illegal function call
1407  5306 1E 05        	LD E, 5
1408  5308 C3 D7 4F     	JP THROW_ERROR
1409  530B              .L1:
1410  530B 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1411  530E B7           	OR A
1412  530F 20 05        	JR NZ, .L2
1413  5311              	; sfx data not initialized, throw out of data
1414  5311 1E 04        	LD E, 4
1415  5313 C3 D7 4F     	JP THROW_ERROR
1416  5316              .L2:
1417  5316              	; pop  parameters and store away for later
1418  5316 D1           	POP DE ; inverted volume
1419  5317 43           	LD B, E
1420  5318 D1           	POP DE ; channel
1421  5319 4B           	LD C, E
1422  531A D1           	POP DE
1423  531B 7B           	LD A, E
1424  531C 08           	EX AF, AF'
1425  531D E5           	PUSH HL ; basic text location
1426  531E D9           	EXX
1427  531F FD 21 26 53  	LD IY, .RET
1428  5323 C3 C1 4E     	JP ENABLE_PAGE0
1429  5326              .RET:
1430  5326 D9           	EXX
1431  5327 08           	EX AF, AF'
1432  5328 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1433  532B
1434  532B D1               POP DE
1435  532C C1               POP BC
1436  532D CD 38 4E         CALL RESTORE_PAGE_INFO
1437  5330
1438  5330 E1           	POP HL
1439  5331 C9           	RET
1440  5332              ; *******************************************************************************************************
1441  5332               ENDIF
1442  5332
1443  5332               IFNDEF EXCLUDE_SPRITE_CMDS
1444  5332              ; *******************************************************************************************************
1445  5332              ; function to handle CALL SPRATRINI basic extension
1446  5332              ; initializes sprites handler
1447  5332              ; _SPRATRINI ( INT sprites_attributes_data,
1448  5332              ;			   INT update_variable_location,
1449  5332              ;			   INT sprite_flicker_enabled )
1450  5332              ; expects both locations to be in range #8000+ or throws an error
1451  5332              ; since these should be BASIC variables
1452  5332              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
1453  5332              SPRATRINI:
1454  5332              	; opening (
1455  5332 CD BF 4F     	CALL CHKCHAR
1456  5335 28           	DB '('
1457  5336              	; get address of sprite attribute table DIM SA%(3,31)
1458  5336 DD 21 2F 54  	LD IX, FRMQNT
1459  533A CD 59 01     	CALL CALBAS
1460  533D D5           	PUSH DE
1461  533E              	; comma
1462  533E CD BF 4F     	CALL CHKCHAR
1463  5341 2C           	DB ','
1464  5342              	; get address of sprite attribute table DIM SA%(3,31)
1465  5342 DD 21 2F 54  	LD IX, FRMQNT
1466  5346 CD 59 01     	CALL CALBAS
1467  5349 D5           	PUSH DE
1468  534A              	; comma
1469  534A CD BF 4F     	CALL CHKCHAR
1470  534D 2C           	DB ','
1471  534E              	; get flicker enabled flag
1472  534E DD 21 2F 54  	LD IX, FRMQNT
1473  5352 CD 59 01     	CALL CALBAS
1474  5355 D5           	PUSH DE
1475  5356              	; ending )
1476  5356 CD BF 4F     	CALL CHKCHAR
1477  5359 29           	DB ')'
1478  535A
1479  535A D1           	POP DE ; get flicker flag
1480  535B 7A           	LD A, D
1481  535C B3           	OR E
1482  535D 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
1483  5360
1484  5360 D1           	POP DE ; update variable location
1485  5361 CB 7A        	BIT 7, D ; is address >= &h8000
1486  5363 20 05        	JR NZ, .L1
1487  5365 1E 05        	LD E, 5 ; illegal function call
1488  5367 C3 D7 4F     	JP THROW_ERROR
1489  536A              .L1:
1490  536A ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
1491  536E D1           	POP DE ; address of sprite attribute table
1492  536F CB 7A        	BIT 7, D ; is address >= &h8000
1493  5371 20 05        	JR NZ, .L2
1494  5373 1E 05        	LD E, 5 ; illegal function call
1495  5375 C3 D7 4F     	JP THROW_ERROR
1496  5378              .L2:
1497  5378 ED 53 FB 4C  	LD (SPRATR_DATA), DE
1498  537C 3E 01        	LD A, 1
1499  537E 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1500  5381 C9           	RET
1501  5382              ; *******************************************************************************************************
1502  5382
1503  5382              ; *******************************************************************************************************
1504  5382              ; function to handle CALL SPRSET basic extension
1505  5382              ; sets position, and optionally pattern and color of sprite
1506  5382              ; _SPRSET ( BYTE sprite_num , valid 0-31
1507  5382              ;			INT x,
1508  5382              ;			INT y,
1509  5382              ;			INT pattern, valid 0-63, otherwise ignored
1510  5382              ;			INT color, valid 0-15, otherwise ignored
1511  5382              SPRSET:
1512  5382 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1513  5385 B7           	OR A
1514  5386 20 05        	JR NZ, .L1
1515  5388 1E 05        	LD E, 5 ; illegal function call
1516  538A C3 D7 4F     	JP THROW_ERROR
1517  538D              .L1:
1518  538D              	; opening (
1519  538D CD BF 4F     	CALL CHKCHAR
1520  5390 28           	DB '('
1521  5391              	; get sprite number
1522  5391 DD 21 1C 52  	LD IX, GETBYT
1523  5395 CD 59 01     	CALL CALBAS
1524  5398 F5           	PUSH AF
1525  5399              	; comma
1526  5399 CD BF 4F     	CALL CHKCHAR
1527  539C 2C           	DB ','
1528  539D              	; get x
1529  539D DD 21 2F 54  	LD IX, FRMQNT
1530  53A1 CD 59 01     	CALL CALBAS
1531  53A4 D5           	PUSH DE
1532  53A5              	; comma
1533  53A5 CD BF 4F     	CALL CHKCHAR
1534  53A8 2C           	DB ','
1535  53A9              	; get y
1536  53A9 DD 21 2F 54  	LD IX, FRMQNT
1537  53AD CD 59 01     	CALL CALBAS
1538  53B0 D5           	PUSH DE
1539  53B1              	; comma
1540  53B1 CD BF 4F     	CALL CHKCHAR
1541  53B4 2C           	DB ','
1542  53B5              	; get pattern
1543  53B5 DD 21 2F 54  	LD IX, FRMQNT
1544  53B9 CD 59 01     	CALL CALBAS
1545  53BC D5           	PUSH DE
1546  53BD              	; comma
1547  53BD CD BF 4F     	CALL CHKCHAR
1548  53C0 2C           	DB ','
1549  53C1              	; get color
1550  53C1 DD 21 2F 54  	LD IX, FRMQNT
1551  53C5 CD 59 01     	CALL CALBAS
1552  53C8 D5           	PUSH DE
1553  53C9              	; ending )
1554  53C9 CD BF 4F     	CALL CHKCHAR
1555  53CC 29           	DB ')'
1556  53CD
1557  53CD                  ; save position in BASIC text
1558  53CD E5           	PUSH HL
1559  53CE DD E1        	POP IX
1560  53D0
1561  53D0 C1           	POP BC ; color
1562  53D1 D1           	POP DE ; pattern
1563  53D2 D9           	EXX
1564  53D3 C1           	POP BC ; y
1565  53D4 D1           	POP DE ; x
1566  53D5 F1           	POP AF ; sprite number
1567  53D6 FE 20        	CP 32
1568  53D8 38 05        	JR C, .L2
1569  53DA 1E 05        	LD E, 5 ; illegal function call
1570  53DC C3 D7 4F     	JP THROW_ERROR
1571  53DF              .L2:
1572  53DF              	; find location in sprite attributes table
1573  53DF 87          > ADD A, A
1573  53E0 87          > ADD A, A
1573  53E1 87          > ADD A, A
1574  53E2 D5           	PUSH DE
1575  53E3 16 00        	LD D, 0
1576  53E5 5F           	LD E, A
1577  53E6 2A FB 4C     	LD HL, (SPRATR_DATA)
1578  53E9 19           	ADD HL, DE
1579  53EA D1           	POP DE
1580  53EB              	; set y
1581  53EB 71           	LD (HL), C
1582  53EC 23           	INC HL
1583  53ED 70           	LD (HL), B
1584  53EE 23           	INC HL
1585  53EF              	; set x
1586  53EF 73           	LD (HL), E
1587  53F0 23           	INC HL
1588  53F1 72           	LD (HL), D
1589  53F2 23           	INC HL
1590  53F3 E5           	PUSH HL
1591  53F4 D9           	EXX
1592  53F5 E1           	POP HL
1593  53F6              	; check if 0<=pattern<64
1594  53F6 7A           	LD A, D
1595  53F7 B7           	OR A
1596  53F8 20 0D        	JR NZ, .L3
1597  53FA 7B           	LD A, E
1598  53FB FE 40        	CP 64
1599  53FD 30 08        	JR NC, .L3
1600  53FF              	; set pattern
1601  53FF              	;ADD A, A
1602  53FF 87           	ADD A, A
1603  5400 87           	ADD A, A
1604  5401 77           	LD (HL), A
1605  5402 23           	INC HL
1606  5403 72           	LD (HL), D
1607  5404 23           	INC HL
1608  5405 18 02        	JR .L4
1609  5407              .L3:
1610  5407              	; skip pattern
1611  5407 23          > INC HL
1611  5408 23          > INC HL
1612  5409              .L4:
1613  5409              	; check if 0<=color<16
1614  5409 78           	LD A, B
1615  540A B7           	OR A
1616  540B 20 08        	JR NZ, .L5
1617  540D 79           	LD A, C
1618  540E FE 10        	CP 16
1619  5410 30 03        	JR NC, .L5
1620  5412              	; set color
1621  5412 71           	LD (HL), C
1622  5413 23           	INC HL
1623  5414 70           	LD (HL), B
1624  5415
1625  5415              .L5:
1626  5415 DD E5        	PUSH IX
1627  5417 E1           	POP HL
1628  5418 C9           	RET
1629  5419              ; *******************************************************************************************************
1630  5419
1631  5419              ; *******************************************************************************************************
1632  5419              ; function sets sprite location based on initial coordinates and offset provided
1633  5419              ; input A=sprite number in SPRATR_DATA , 0-31
1634  5419              ; input DE=initial x
1635  5419              ; input BC=initial y
1636  5419              ; input IY=location where delta y,x are located
1637  5419              ; modifies AF, HL, IX
1638  5419              SPRSET_DELTA_POS:
1639  5419 87          > ADD A, A
1639  541A 87          > ADD A, A
1639  541B 87          > ADD A, A
1640  541C D5           	PUSH DE
1641  541D 16 00        	LD D, 0
1642  541F 5F           	LD E, A
1643  5420 DD 2A FB 4C  	LD IX, (SPRATR_DATA)
1644  5424 DD 19        	ADD IX, DE
1645  5426 D1           	POP DE
1646  5427              	; IX=sprite's y location
1647  5427 FD 6E 00     	LD L, (IY)
1648  542A FD 66 01     	LD H, (IY+1)
1649  542D 09           	ADD HL, BC
1650  542E DD 75 00     	LD (IX), L
1651  5431 DD 74 01     	LD (IX+1), H
1652  5434 FD 6E 02     	LD L, (IY+2)
1653  5437 FD 66 03     	LD H, (IY+3)
1654  543A 19           	ADD HL, DE
1655  543B DD 75 02     	LD (IX+2), L
1656  543E DD 74 03     	LD (IX+3), H
1657  5441 C9           	RET
1658  5442              ; *******************************************************************************************************
1659  5442
1660  5442              ; *******************************************************************************************************
1661  5442              ; function to handle CALL SPRGRPMOV basic extension
1662  5442              ; sets position of a group of sprites described with
1663  5442              ; { int sprite_num, int delta_y, int delta_x } [count]
1664  5442              ; _SPRGRPMOV ( INT x,
1665  5442              ;			   INT y,
1666  5442              ;			   INT data_ptr,
1667  5442              ;			   BYTE count,
1668  5442              ; will put ram in page 0 also, page 1 is already there
1669  5442              SPRGRPMOV:
1670  5442 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1671  5445 B7           	OR A
1672  5446 20 05        	JR NZ, .L1
1673  5448 1E 05        	LD E, 5 ; illegal function call
1674  544A C3 D7 4F     	JP THROW_ERROR
1675  544D              .L1:
1676  544D              	; opening (
1677  544D CD BF 4F     	CALL CHKCHAR
1678  5450 28           	DB '('
1679  5451              	; get x
1680  5451 DD 21 2F 54  	LD IX, FRMQNT
1681  5455 CD 59 01     	CALL CALBAS
1682  5458 D5           	PUSH DE
1683  5459              	; comma
1684  5459 CD BF 4F     	CALL CHKCHAR
1685  545C 2C           	DB ','
1686  545D              	; get y
1687  545D DD 21 2F 54  	LD IX, FRMQNT
1688  5461 CD 59 01     	CALL CALBAS
1689  5464 D5           	PUSH DE
1690  5465              	; comma
1691  5465 CD BF 4F     	CALL CHKCHAR
1692  5468 2C           	DB ','
1693  5469              	; get data pointer
1694  5469 DD 21 2F 54  	LD IX, FRMQNT
1695  546D CD 59 01     	CALL CALBAS
1696  5470 D5           	PUSH DE
1697  5471              	; comma
1698  5471 CD BF 4F     	CALL CHKCHAR
1699  5474 2C           	DB ','
1700  5475              	; get count
1701  5475 DD 21 1C 52  	LD IX, GETBYT
1702  5479 CD 59 01     	CALL CALBAS
1703  547C F5           	PUSH AF
1704  547D              	; ending )
1705  547D CD BF 4F     	CALL CHKCHAR
1706  5480 29           	DB ')'
1707  5481
1708  5481 E5           	PUSH HL
1709  5482 DD E1        	POP IX
1710  5484
1711  5484 C1           	POP BC ; count
1712  5485 E1           	POP HL ; data pointer
1713  5486 D9           	EXX
1714  5487 C1           	POP BC ; y
1715  5488 D1           	POP DE ; x
1716  5489 D9           	EXX
1717  548A
1718  548A DD E5        	PUSH IX ; save position in BASIC buffer
1719  548C
1720  548C C5           	PUSH BC
1721  548D E5           	PUSH HL
1722  548E AF               XOR A
1723  548F CD 01 4E         CALL GET_PAGE_INFO
1724  5492 D9           	EXX
1725  5493 E1           	POP HL
1726  5494 F1           	POP AF
1727  5495 D9           	EXX
1728  5496 C5               PUSH BC
1729  5497 D5               PUSH DE
1730  5498 D9           	EXX
1731  5499 F5           	PUSH AF
1732  549A E5           	PUSH HL
1733  549B D9           	EXX
1734  549C 3A 41 F3         LD A, (RAMAD0)
1735  549F 26 00            LD H, 0
1736  54A1 CD 48 4E         CALL LOCAL_ENASLT
1737  54A4 FB           	EI
1738  54A5 E1           	POP HL
1739  54A6 C1           	POP BC
1740  54A7 CD B1 54     	CALL .UPDATE_LOC
1741  54AA D1               POP DE
1742  54AB C1               POP BC
1743  54AC CD 38 4E         CALL RESTORE_PAGE_INFO
1744  54AF E1           	POP HL
1745  54B0 C9           	RET
1746  54B1
1747  54B1              .UPDATE_LOC:
1748  54B1              .L4:
1749  54B1 7E           	LD A, (HL)
1750  54B2 23           	INC HL
1751  54B3 23           	INC HL
1752  54B4 E5           	PUSH HL
1753  54B5 FD E1        	POP IY
1754  54B7 D9           	EXX
1755  54B8 CD 19 54     	CALL SPRSET_DELTA_POS
1756  54BB D9           	EXX
1757  54BC 23          > INC HL
1757  54BD 23          > INC HL
1757  54BE 23          > INC HL
1757  54BF 23          > INC HL
1758  54C0 10 EF        	DJNZ .L4
1759  54C2 C9           	RET
1760  54C3              ; *******************************************************************************************************
1761  54C3               ENDIF
1762  54C3
1763  54C3               IFNDEF EXCLUDE_BLIT_CMDS
1764  54C3              ; *******************************************************************************************************
1765  54C3              ; function rotates mask and data of several characters and applies to background data
1766  54C3              ; this handles x-shift from 0 to 4
1767  54C3              ; contains self-modifying code that is set-up from external function
1768  54C3              ; input HL=pointer to mask data
1769  54C3              ; input HL'=pointer to character data
1770  54C3              ; input DE=output buffer containing background data
1771  54C3              ; input BC=DE+8
1772  54C3              ; input A=number of characters to process
1773  54C3              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1774  54C3              SHIFT04:
1775  54C3 08           	EX AF, AF'
1776  54C4 7E           	LD A, (HL) ; get mask
1777  54C5 D9           	EXX
1778  54C6 57           	LD D, A
1779  54C7 1E FF        	LD E, #FF
1780  54C9 37           	SCF
1781  54CA              .M1:
1782  54CA 18 FE        	JR .M1 ; this is self-modifying part
1783  54CC CB 1A        	RR D
1784  54CE CB 1B        	RR E
1785  54D0 CB 1A        	RR D
1786  54D2 CB 1B        	RR E
1787  54D4 CB 1A        	RR D
1788  54D6 CB 1B        	RR E
1789  54D8 CB 1A        	RR D
1790  54DA CB 1B        	RR E
1791  54DC
1792  54DC 46           	LD B, (HL) ; get data
1793  54DD 0E 00        	LD C, 0
1794  54DF              .M2:
1795  54DF 18 FE        	JR .M2 ; also self-modifying part
1796  54E1 CB 38        	SRL B
1797  54E3 CB 19        	RR C
1798  54E5 CB 38        	SRL B
1799  54E7 CB 19        	RR C
1800  54E9 CB 38        	SRL B
1801  54EB CB 19        	RR C
1802  54ED CB 38        	SRL B
1803  54EF CB 19        	RR C
1804  54F1
1805  54F1 D9           	EXX
1806  54F2 1A           	LD A, (DE) ; background
1807  54F3 D9           	EXX
1808  54F4 A2           	AND D
1809  54F5 B0           	OR B
1810  54F6 D9           	EXX
1811  54F7 12           	LD (DE), A
1812  54F8
1813  54F8 0A           	LD A, (BC)
1814  54F9 D9           	EXX
1815  54FA A3           	AND E
1816  54FB B1           	OR C
1817  54FC 23           	INC HL
1818  54FD D9           	EXX
1819  54FE 02           	LD (BC), A
1820  54FF
1821  54FF 23           	INC HL
1822  5500 13           	INC DE
1823  5501 03           	INC BC
1824  5502
1825  5502 08           	EX AF, AF'
1826  5503 3D           	DEC A
1827  5504 C2 C3 54     	JP NZ, SHIFT04
1828  5507 C9           	RET
1829  5508              ; *******************************************************************************************************
1830  5508
1831  5508              ; *******************************************************************************************************
1832  5508              ; function rotates mask and data of several characters and applies to background data
1833  5508              ; this handles x-shift from 5 to 8
1834  5508              ; contains self-modifying code that is set-up from external function
1835  5508              ; input HL=pointer to mask data
1836  5508              ; input HL'=pointer to character data
1837  5508              ; input DE=output buffer containing background data
1838  5508              ; input BC=DE+8
1839  5508              ; input A=number of characters to process
1840  5508              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1841  5508              SHIFT58:
1842  5508 08           	EX AF, AF'
1843  5509 7E           	LD A, (HL) ; get mask
1844  550A D9           	EXX
1845  550B 57           	LD D, A
1846  550C 1E FF        	LD E, #FF
1847  550E 37           	SCF
1848  550F              .M1:
1849  550F 18 FE        	JR .M1 ; this is self-modifying part
1850  5511 CB 12        	RL D
1851  5513 CB 13        	RL E
1852  5515 CB 12        	RL D
1853  5517 CB 13        	RL E
1854  5519 CB 12        	RL D
1855  551B CB 13        	RL E
1856  551D
1857  551D 46           	LD B, (HL)
1858  551E 0E 00        	LD C, 0
1859  5520              .M2:
1860  5520 18 FE        	JR .M2 ; also self-modifying part
1861  5522 CB 20        	SLA B
1862  5524 CB 11        	RL C
1863  5526 CB 20        	SLA B
1864  5528 CB 11        	RL C
1865  552A CB 20        	SLA B
1866  552C CB 11        	RL C
1867  552E
1868  552E D9           	EXX
1869  552F 1A           	LD A, (DE) ; background
1870  5530 D9           	EXX
1871  5531 A3           	AND E
1872  5532 B1           	OR C
1873  5533 D9           	EXX
1874  5534 12           	LD (DE), A
1875  5535
1876  5535 0A           	LD A, (BC)
1877  5536 D9           	EXX
1878  5537 A2           	AND D
1879  5538 B0           	OR B
1880  5539 23           	INC HL
1881  553A D9           	EXX
1882  553B 02           	LD (BC), A
1883  553C
1884  553C 23           	INC HL
1885  553D 13           	INC DE
1886  553E 03           	INC BC
1887  553F
1888  553F 08           	EX AF, AF'
1889  5540 3D           	DEC A
1890  5541 C2 08 55     	JP NZ, SHIFT58
1891  5544 C9           	RET
1892  5545              ; *******************************************************************************************************
1893  5545
1894  5545              ; *******************************************************************************************************
1895  5545              ; routine that shifts one row of characters
1896  5545              ; contains self-modifying code that is set-up from external function
1897  5545              ; input HL=pointer to mask data
1898  5545              ; input HL'=pointer to character data
1899  5545              ; input DE=output buffer containing background data
1900  5545              ; input A=number of characters to process
1901  5545              ; input IX=pointer to structure describing input data
1902  5545              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1903  5545              SHIFT_ROW:
1904  5545 F5           	PUSH AF
1905  5546 ED 53 01 4D  		LD (BLIT_TMP1), DE
1906  554A E5           		PUSH HL
1907  554B CD 8E 55     			CALL .ADDYSHIFT
1908  554E E1           		POP HL
1909  554F ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1910  5553              .L1:
1911  5553 3E 08        		LD A, 8
1912  5555 DD 96 02     		SUB (IX+2) ; y shift
1913  5558              .CALL1:
1914  5558 CD 00 00     		CALL 0
1915  555B DD 7E 02     		LD A, (IX+2); y shift
1916  555E B7           		OR A
1917  555F 28 26        		JR Z, .DONE
1918  5561 ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1919  5565 E5           		PUSH HL
1920  5566 CD 9C 55     			CALL .DETONEXTROW
1921  5569 E1           		POP HL
1922  556A              .CALL2:
1923  556A CD 00 00     		CALL 0
1924  556D ED 5B 01 4D  		LD DE, (BLIT_TMP1)
1925  5571 E5           		PUSH HL
1926  5572 CD 96 55     			CALL .ADD8
1927  5575 E1           		POP HL
1928  5576 ED 53 01 4D  		LD (BLIT_TMP1), DE
1929  557A ED 5B 03 4D  		LD DE, (BLIT_TMP2)
1930  557E E5           		PUSH HL
1931  557F CD 96 55     			CALL .ADD8
1932  5582 E1           		POP HL
1933  5583 ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
1934  5587              .DONE:
1935  5587 F1           	POP AF
1936  5588 3D           	DEC A
1937  5589 C8           	RET Z
1938  558A F5           	PUSH AF
1939  558B C3 53 55     	JP .L1
1940  558E              .ADDYSHIFT:
1941  558E EB           	EX DE, HL
1942  558F 16 00        	LD D, 0
1943  5591 DD 5E 02     	LD E, (IX+2); y shift
1944  5594 18 0C        	JR .MOVDEBC
1945  5596              .ADD8:
1946  5596 21 08 00     	LD HL, 8
1947  5599 C3 A2 55     	JP .MOVDEBC
1948  559C              .DETONEXTROW:
1949  559C DD 6E 06     	LD L, (IX+6)
1950  559F DD 66 07     	LD H, (IX+7) ; bkg add to value
1951  55A2              .MOVDEBC:
1952  55A2 19           	ADD HL, DE
1953  55A3 54           	LD D, H
1954  55A4 5D           	LD E, L
1955  55A5 01 08 00     	LD BC, 8
1956  55A8 09           	ADD HL, BC
1957  55A9 44           	LD B, H
1958  55AA 4D           	LD C, L
1959  55AB C9           	RET
1960  55AC              ; *******************************************************************************************************
1961  55AC
1962  55AC              ; *******************************************************************************************************
1963  55AC              ; function rotates mask and character data and applies it to background
1964  55AC              ; input IX=pointer to structure describing input data
1965  55AC              ; +0  DW horizontal shift count 0-7
1966  55AC              ; +2  DW vertical shift count 0-7
1967  55AC              ; +4  DW background data start;
1968  55AC              ; +6  DW background add to value to next row of background data
1969  55AC              ; +8  DW mask data start;
1970  55AC              ; +10  DW character data start;
1971  55AC              ; +12 DW character&mask add to value to next row of data
1972  55AC              ; +14 DW columns (low byte used)
1973  55AC              ; +16 DW rows (low byte used)
1974  55AC              SHIFT_MERGE_CHARACTER:
1975  55AC DD 7E 00     	LD A, (IX) ; shift
1976  55AF FE 05        	CP 5
1977  55B1 38 25        	JR C, .RIGHT
1978  55B3              	; shifts 5-7, use rotate towards left 1-3
1979  55B3 21 08 55     	LD HL, SHIFT58
1980  55B6 22 59 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1981  55B9 22 6B 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1982  55BC D6 05        	SUB 5
1983  55BE 28 0D        	JR Z, .L1
1984  55C0 87           	ADD A, A
1985  55C1 87           	ADD A, A
1986  55C2 67           	LD H, A
1987  55C3 2E 18        	LD L, #18 ; JR opcode
1988  55C5 22 0F 55     	LD (SHIFT58.M1), HL
1989  55C8 22 20 55     	LD (SHIFT58.M2), HL
1990  55CB 18 32        	JR .DO
1991  55CD              .L1:
1992  55CD 21 00 00     	LD HL, 0 ; 2xNOP opcode
1993  55D0 22 0F 55     	LD (SHIFT58.M1), HL
1994  55D3 22 20 55     	LD (SHIFT58.M2), HL
1995  55D6 18 27        	JR .DO
1996  55D8              .RIGHT:
1997  55D8              	; shifts 0-4, rotate towards right
1998  55D8 21 C3 54     	LD HL, SHIFT04
1999  55DB 22 59 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2000  55DE 22 6B 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2001  55E1 FE 04        	CP 4
2002  55E3 28 11        	JR Z, .R1
2003  55E5 D6 04        	SUB 4
2004  55E7 ED 44        	NEG
2005  55E9 87           	ADD A, A
2006  55EA 87           	ADD A, A
2007  55EB 67           	LD H, A
2008  55EC 2E 18        	LD L, #18 ; JR opcode
2009  55EE 22 CA 54     	LD (SHIFT04.M1), HL
2010  55F1 22 DF 54     	LD (SHIFT04.M2), HL
2011  55F4 18 09        	JR .DO
2012  55F6              .R1:
2013  55F6 21 00 00     	LD HL, 0 ; 2xNOP opcode
2014  55F9 22 CA 54     	LD (SHIFT04.M1), HL
2015  55FC 22 DF 54     	LD (SHIFT04.M2), HL
2016  55FF              .DO:
2017  55FF DD 46 10     	LD B, (IX+16) ; rows
2018  5602 DD 6E 08     	LD L, (IX+8)
2019  5605 DD 66 09     	LD H, (IX+9) ; mask data
2020  5608 DD 5E 04     	LD E, (IX+4)
2021  560B DD 56 05     	LD D, (IX+5) ; background data
2022  560E D9           	EXX
2023  560F DD 6E 0A     	LD L, (IX+10)
2024  5612 DD 66 0B     	LD H, (IX+11) ; character data
2025  5615 D9           	EXX
2026  5616              .LOOP:
2027  5616 C5           	PUSH BC
2028  5617 E5           		PUSH HL
2029  5618 D5           			PUSH DE
2030  5619 D9           				EXX
2031  561A E5           				PUSH HL
2032  561B D9           					EXX
2033  561C DD 7E 0E     					LD A, (IX+14) ; columns
2034  561F              .CALL:
2035  561F CD 45 55     					CALL SHIFT_ROW
2036  5622 E1           				POP HL
2037  5623 DD 5E 0C     				LD E, (IX+12)
2038  5626 DD 56 0D     				LD D, (IX+13) ; char data to next row
2039  5629 19           				ADD HL, DE
2040  562A D9           				EXX
2041  562B E1           			POP HL
2042  562C DD 5E 06     			LD E, (IX+6)
2043  562F DD 56 07     			LD D, (IX+7) ; background to next row
2044  5632 19           			ADD HL, DE
2045  5633 EB           			EX DE, HL
2046  5634 E1           		POP HL
2047  5635 DD 4E 0C     		LD C, (IX+12)
2048  5638 DD 46 0D     		LD B, (IX+13) ; char data to next row
2049  563B 09           		ADD HL, BC
2050  563C C1           	POP BC
2051  563D 10 D7        	DJNZ .LOOP
2052  563F C9           	RET
2053  5640              ; *******************************************************************************************************
2054  5640
2055  5640              ; *******************************************************************************************************
2056  5640              ; function to handle CALL BLIT basic extension
2057  5640              ; rotates 1-bit character drawing horizontally with mask and character data and
2058  5640              ; fuses with background data and applies vertical shift too
2059  5640              ; BLIT ( INT request_data_ptr )
2060  5640              ; request_data_ptr described in SHIFT_MERGE_CHARACTER
2061  5640              ; will put ram in page 0 also, page 1 is already there
2062  5640              BLIT:
2063  5640              	; opening (
2064  5640 CD BF 4F     	CALL CHKCHAR
2065  5643 28           	DB '('
2066  5644              	; get pointer to request struct
2067  5644 DD 21 2F 54  	LD IX, FRMQNT
2068  5648 CD 59 01     	CALL CALBAS
2069  564B D5           	PUSH DE
2070  564C              	; ending )
2071  564C CD BF 4F     	CALL CHKCHAR
2072  564F 29           	DB ')'
2073  5650
2074  5650 DD E1        	POP IX ; pointer to request struct
2075  5652
2076  5652 E5           	PUSH HL ; save position in BASIC buffer
2077  5653
2078  5653 FD 21 5A 56  	LD IY, .RET
2079  5657 C3 C1 4E     	JP ENABLE_PAGE0
2080  565A              .RET:
2081  565A FB           	EI
2082  565B CD AC 55     	CALL SHIFT_MERGE_CHARACTER
2083  565E
2084  565E D1               POP DE
2085  565F C1               POP BC
2086  5660 CD 38 4E         CALL RESTORE_PAGE_INFO
2087  5663
2088  5663 E1           	POP HL
2089  5664 C9           	RET
2090  5665              ; *******************************************************************************************************
2091  5665
2092  5665              ; *******************************************************************************************************
2093  5665              ; generic function to implement tiling
2094  5665              ; should be modified to call appropriate function for memory or vram
2095  5665              ; input IX=pointer to following structure
2096  5665              ; +00 tile_data_ptr
2097  5665              ; +02 tile_rows
2098  5665              ; +04 tile_columns
2099  5665              ; +06 destination_address
2100  5665              ; +08 dest_to_next_row_add_to_value
2101  5665              ; +10 num_horizontal_tiles
2102  5665              ; +12 num_vertical_tiles
2103  5665              ; modifies AF, BC, DE, HL
2104  5665              TILE:
2105  5665 DD 6E 06     	LD L, (IX+6)
2106  5668 DD 66 07     	LD H, (IX+7) ; destination address
2107  566B 22 01 4D     	LD (TILETMP1), HL
2108  566E DD 46 0C     	LD B, (IX+12) ; vertical tile number
2109  5671              .L1:
2110  5671 C5           	PUSH BC
2111  5672 DD 6E 00     		LD L, (IX+0)
2112  5675 DD 66 01     		LD H, (IX+1) ; tile address
2113  5678 22 03 4D     		LD (TILETMP2), HL
2114  567B DD 46 02     		LD B, (IX+2) ; tile rows
2115  567E              .L2:
2116  567E C5           		PUSH BC
2117  567F              .CALL1:
2118  567F CD 00 00     			CALL 0
2119  5682 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
2120  5685              .L3:
2121  5685 C5           			PUSH BC
2122  5686 2A 03 4D     				LD HL, (TILETMP2)
2123  5689 DD 46 04     				LD B, (IX+4) ; tile columns
2124  568C              .L4:
2125  568C C5           				PUSH BC
2126  568D              .CALL2:
2127  568D CD 00 00     					CALL 0
2128  5690 C1           				POP BC
2129  5691 10 F9        				DJNZ .L4
2130  5693 C1           			POP BC
2131  5694 10 EF        			DJNZ .L3
2132  5696 22 03 4D     			LD (TILETMP2), HL
2133  5699 2A 01 4D     			LD HL, (TILETMP1)
2134  569C DD 5E 08     			LD E, (IX+8)
2135  569F DD 56 09     			LD D, (IX+9) ; add to value for dest next row
2136  56A2 19           			ADD HL, DE
2137  56A3 22 01 4D     			LD (TILETMP1), HL
2138  56A6 C1           		POP BC
2139  56A7 10 D5        		DJNZ .L2
2140  56A9 C1           	POP BC
2141  56AA 10 C5        	DJNZ .L1
2142  56AC C9           	RET
2143  56AD              ; *******************************************************************************************************
2144  56AD
2145  56AD              ; *******************************************************************************************************
2146  56AD              ; function to handle CALL TILERAM basic extension
2147  56AD              ; fills memory with tiles
2148  56AD              ; fuses with background data and applies vertical shift too
2149  56AD              ; TILERAM ( INT request_data_ptr )
2150  56AD              ; request_data_ptr described in TILE
2151  56AD              ; will put ram in page 0 also, page 1 is already there
2152  56AD              TILERAM:
2153  56AD              	; opening (
2154  56AD CD BF 4F     	CALL CHKCHAR
2155  56B0 28           	DB '('
2156  56B1              	; get pointer to request struct
2157  56B1 DD 21 2F 54  	LD IX, FRMQNT
2158  56B5 CD 59 01     	CALL CALBAS
2159  56B8 D5           	PUSH DE
2160  56B9              	; ending )
2161  56B9 CD BF 4F     	CALL CHKCHAR
2162  56BC 29           	DB ')'
2163  56BD
2164  56BD DD E1        	POP IX ; pointer to request struct
2165  56BF
2166  56BF E5           	PUSH HL ; save position in BASIC buffer
2167  56C0
2168  56C0 FD 21 C7 56  	LD IY, .RET
2169  56C4 C3 C1 4E     	JP ENABLE_PAGE0
2170  56C7              .RET:
2171  56C7 FB           	EI
2172  56C8              	; set RAM functions to call
2173  56C8 21 DE 56     	LD HL, .TILECOPY
2174  56CB 22 8E 56     	LD (TILE.CALL2+1), HL
2175  56CE 21 EF 56     	LD HL, .SETDESTROW
2176  56D1 22 80 56     	LD (TILE.CALL1+1), HL
2177  56D4 CD 65 56     	CALL TILE
2178  56D7
2179  56D7 D1               POP DE
2180  56D8 C1               POP BC
2181  56D9 CD 38 4E         CALL RESTORE_PAGE_INFO
2182  56DC
2183  56DC E1           	POP HL
2184  56DD C9           	RET
2185  56DE              .TILECOPY:
2186  56DE ED A0       > LDI
2186  56E0 ED A0       > LDI
2186  56E2 ED A0       > LDI
2186  56E4 ED A0       > LDI
2186  56E6 ED A0       > LDI
2186  56E8 ED A0       > LDI
2186  56EA ED A0       > LDI
2186  56EC ED A0       > LDI
2187  56EE C9           	RET
2188  56EF              .SETDESTROW:
2189  56EF ED 5B 01 4D  	LD DE, (TILETMP1)
2190  56F3 C9           	RET
2191  56F4              ; *******************************************************************************************************
2192  56F4
2193  56F4              ; *******************************************************************************************************
2194  56F4              ; function to handle CALL TILEVRM basic extension
2195  56F4              ; fills vram with tiles
2196  56F4              ; fuses with background data and applies vertical shift too
2197  56F4              ; TILEVRM ( INT request_data_ptr )
2198  56F4              ; request_data_ptr described in TILE
2199  56F4              ; will put ram in page 0 also, page 1 is already there
2200  56F4              TILEVRM:
2201  56F4              	; opening (
2202  56F4 CD BF 4F     	CALL CHKCHAR
2203  56F7 28           	DB '('
2204  56F8              	; get pointer to request struct
2205  56F8 DD 21 2F 54  	LD IX, FRMQNT
2206  56FC CD 59 01     	CALL CALBAS
2207  56FF D5           	PUSH DE
2208  5700              	; ending )
2209  5700 CD BF 4F     	CALL CHKCHAR
2210  5703 29           	DB ')'
2211  5704
2212  5704 DD E1        	POP IX ; pointer to request struct
2213  5706
2214  5706 E5           	PUSH HL ; save position in BASIC buffer
2215  5707
2216  5707 FD 21 0E 57  	LD IY, .RET
2217  570B C3 C1 4E     	JP ENABLE_PAGE0
2218  570E              .RET:
2219  570E FB           	EI
2220  570F              	; set RAM functions to call
2221  570F 21 25 57     	LD HL, .TILECOPY
2222  5712 22 8E 56     	LD (TILE.CALL2+1), HL
2223  5715 21 2B 57     	LD HL, .SETDESTROW
2224  5718 22 80 56     	LD (TILE.CALL1+1), HL
2225  571B CD 65 56     	CALL TILE
2226  571E
2227  571E D1               POP DE
2228  571F C1               POP BC
2229  5720 CD 38 4E         CALL RESTORE_PAGE_INFO
2230  5723
2231  5723 E1           	POP HL
2232  5724 C9           	RET
2233  5725              .TILECOPY:
2234  5725 01 98 08     	LD BC, #0898
2235  5728               IFNDEF EXCLUDE_VRAM_CMDS
2236  5728 C3 94 51     	JP MEMVRM.BBYTECOPY
2237  572B               ELSE
2238  572B ~            .BBYTECOPY:
2239  572B ~            	OUTI
2240  572B ~            	JP	NZ, .BBYTECOPY
2241  572B ~            	RET
2242  572B               ENDIF
2243  572B              .SETDESTROW:
2244  572B 2A 01 4D     	LD HL, (TILETMP1)
2245  572E F3           	DI
2246  572F CD F6 4D     	CALL SETWRT_LOCAL
2247  5732 FB           	EI
2248  5733 C9           	RET
2249  5734              ; *******************************************************************************************************
2250  5734
2251  5734              ; *******************************************************************************************************
2252  5734              ; generic function to implement rectangle data copy
2253  5734              ; should be modified to call appropriate function for memory or vram
2254  5734              ; input IX=pointer to following structure
2255  5734              ; +00 source data pointer
2256  5734              ; +02 num bytes in a row
2257  5734              ; +04 number of rows
2258  5734              ; +06 source add-to value till next row
2259  5734              ; +08 destination address
2260  5734              ; +10 destination add-to value till next row
2261  5734              ; modifies AF, BC, DE, HL
2262  5734              RECTANGLE_COPY:
2263  5734 DD 6E 00     	LD L, (IX+0)
2264  5737 DD 66 01     	LD H, (IX+1) ; source address
2265  573A DD 5E 08     	LD E, (IX+8)
2266  573D DD 56 09     	LD D, (IX+9) ; destination
2267  5740 DD 46 04     	LD B, (IX+4) ; row number
2268  5743              .L1:
2269  5743 C5           	PUSH BC
2270  5744 E5           		PUSH HL
2271  5745 D5           			PUSH DE
2272  5746 DD 4E 02     				LD C, (IX+2)
2273  5749 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2274  574C              .CALL1:
2275  574C CD 00 00     				CALL 0 ; set destination address from DE
2276  574F              .CALL2:
2277  574F CD 00 00     				CALL 0 ; copy data fn
2278  5752 E1           			POP HL
2279  5753 DD 4E 0A     			LD C, (IX+10)
2280  5756 DD 46 0B     			LD B, (IX+11) ; destination add-to
2281  5759 09           			ADD HL, BC
2282  575A EB           			EX DE, HL
2283  575B E1           		POP HL
2284  575C DD 4E 06     		LD C, (IX+6)
2285  575F DD 46 07     		LD B, (IX+7) ; src add-to
2286  5762 09           		ADD HL, BC
2287  5763 C1           	POP BC
2288  5764 10 DD        	DJNZ .L1
2289  5766 C9           	RET
2290  5767              ; *******************************************************************************************************
2291  5767
2292  5767              ; *******************************************************************************************************
2293  5767              ; function to handle CALL BOXMEMCPY basic extension
2294  5767              ; copies data with window like boundaries to ram
2295  5767              ; BOXMEMCPY ( INT request_data_ptr )
2296  5767              ; request_data_ptr described in RECTANGLE_COPY
2297  5767              ; will put ram in page 0 also, page 1 is already there
2298  5767              BOXMEMCPY:
2299  5767              	; opening (
2300  5767 CD BF 4F     	CALL CHKCHAR
2301  576A 28           	DB '('
2302  576B              	; get pointer to request struct
2303  576B DD 21 2F 54  	LD IX, FRMQNT
2304  576F CD 59 01     	CALL CALBAS
2305  5772 D5           	PUSH DE
2306  5773              	; ending )
2307  5773 CD BF 4F     	CALL CHKCHAR
2308  5776 29           	DB ')'
2309  5777
2310  5777 DD E1        	POP IX ; pointer to request struct
2311  5779
2312  5779 E5           	PUSH HL ; save position in BASIC buffer
2313  577A
2314  577A FD 21 81 57  	LD IY, .RET
2315  577E C3 C1 4E     	JP ENABLE_PAGE0
2316  5781              .RET:
2317  5781 FB           	EI
2318  5782              	; set RAM functions to call
2319  5782 21 00 00     	LD HL, 0
2320  5785 22 4C 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2321  5788 22 4E 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2322  578B 21 ED B0     	LD HL, #B0ED ; LDIR
2323  578E 22 50 57     	LD (RECTANGLE_COPY.CALL1+4), HL
2324  5791 CD 34 57     	CALL RECTANGLE_COPY
2325  5794
2326  5794 D1               POP DE
2327  5795 C1               POP BC
2328  5796 CD 38 4E         CALL RESTORE_PAGE_INFO
2329  5799
2330  5799 E1           	POP HL
2331  579A C9           	RET
2332  579B              ; *******************************************************************************************************
2333  579B
2334  579B              ; *******************************************************************************************************
2335  579B              ; function to handle CALL BOXMEMVRM basic extension
2336  579B              ; copies data with window like boundaries to ram
2337  579B              ; BOXMEMVRM ( INT request_data_ptr )
2338  579B              ; request_data_ptr described in RECTANGLE_COPY
2339  579B              ; will put ram in page 0 also, page 1 is already there
2340  579B              BOXMEMVRM:
2341  579B              	; opening (
2342  579B CD BF 4F     	CALL CHKCHAR
2343  579E 28           	DB '('
2344  579F              	; get pointer to request struct
2345  579F DD 21 2F 54  	LD IX, FRMQNT
2346  57A3 CD 59 01     	CALL CALBAS
2347  57A6 D5           	PUSH DE
2348  57A7              	; ending )
2349  57A7 CD BF 4F     	CALL CHKCHAR
2350  57AA 29           	DB ')'
2351  57AB
2352  57AB DD E1        	POP IX ; pointer to request struct
2353  57AD
2354  57AD E5           	PUSH HL ; save position in BASIC buffer
2355  57AE
2356  57AE FD 21 B5 57  	LD IY, .RET
2357  57B2 C3 C1 4E     	JP ENABLE_PAGE0
2358  57B5              .RET:
2359  57B5 FB           	EI
2360  57B6              	; set RAM functions to call
2361  57B6 21 D4 57     	LD HL, .SETDEST
2362  57B9 22 4D 57     	LD (RECTANGLE_COPY.CALL1+1), HL
2363  57BC 21 DC 57     	LD HL, .COPYDATA
2364  57BF 22 50 57     	LD (RECTANGLE_COPY.CALL2+1), HL
2365  57C2 3E CD        	LD A, #CD ; CALL
2366  57C4 32 4C 57     	LD (RECTANGLE_COPY.CALL1), A
2367  57C7 32 4F 57     	LD (RECTANGLE_COPY.CALL2), A
2368  57CA CD 34 57     	CALL RECTANGLE_COPY
2369  57CD
2370  57CD D1               POP DE
2371  57CE C1               POP BC
2372  57CF CD 38 4E         CALL RESTORE_PAGE_INFO
2373  57D2
2374  57D2 E1           	POP HL
2375  57D3 C9           	RET
2376  57D4              .SETDEST:
2377  57D4 EB           	EX DE, HL
2378  57D5 F3           	DI
2379  57D6 CD F6 4D     	CALL SETWRT_LOCAL
2380  57D9 FB           	EI
2381  57DA EB           	EX DE, HL
2382  57DB C9           	RET
2383  57DC              .COPYDATA:
2384  57DC 41           	LD B, C
2385  57DD 0E 98        	LD C, #98
2386  57DF               IFNDEF EXCLUDE_VRAM_CMDS
2387  57DF C3 94 51     	JP MEMVRM.BBYTECOPY
2388  57E2               ELSE
2389  57E2 ~            	JP TILEVRM.BBYTECOPY
2390  57E2               ENDIF
2391  57E2              ; *******************************************************************************************************
2392  57E2               ENDIF
2393  57E2
2394  57E2              EXT_END:
2395  57E2
# file closed: asm\main.asm
