# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000
 14   4000               DEFINE CMDS_WITH_PARAMETERS
 15   4000
 16   4000              CHPUT   EQU     #A2
 17   4000              CALBAS	EQU		#159
 18   4000              ERRHAND EQU     #406F
 19   4000              FRMEVL  EQU     #4C64
 20   4000              FRESTR	EQU		#67D0
 21   4000              ; FRMQNT = formula quantificator
 22   4000              ; input HL=pointer to current program expression
 23   4000              ; output HL=next address
 24   4000              ; output DE=integer datum
 25   4000              FRMQNT	EQU		#542F
 26   4000              ; GETBYT = get byte parameter
 27   4000              ; input HL=pointer to current program expression
 28   4000              ; output HL=next address
 29   4000              ; output A=E=byte read
 30   4000              GETBYT		EQU		#521C
 31   4000              CHRGTR  	EQU     #4666
 32   4000              PTRGET		EQU 	#5EA4
 33   4000              SUBFLG		EQU		#F6A5
 34   4000              SYNCHR		EQU		#558C
 35   4000              VALTYP  	EQU     #F663
 36   4000              USR     	EQU     #F7F8
 37   4000              PROCNM		EQU		#FD89
 38   4000              BIOS_FILVRM EQU     #0056
 39   4000              CLIKSW		EQU		#F3DB
 40   4000              ATRBAS		EQU		#F928
 41   4000              GRPCGP		EQU		#F3CB
 42   4000
 43   4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 44   4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 45   4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 46   4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 47   4000              EXPTBL	EQU #FCC1
 48   4000              SCRMOD	EQU #FCAF ; current screen mode
 49   4000              REG1SAV EQU #F3E0 ; VDP(1)
 50   4000              JIFFY	EQU #FC9E
 51   4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
 52   4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
 53   4000              PATBAS  EQU #F926 ; current sprite generator table address
 54   4000
 55   4000              ; BASIC error codes
 56   4000              ;01 NEXT without FOR
 57   4000              ;02 Syntax error
 58   4000              ;03 RETURN without GOSUB
 59   4000              ;04 Out of DATA
 60   4000              ;05 Illegal function call
 61   4000              ;06 Overflow
 62   4000              ;07 Out of memory
 63   4000              ;08 Undefined line number
 64   4000              ;09 Subscript out of range
 65   4000              ;10 Redimensioned array
 66   4000              ;11 Division by zero
 67   4000              ;12 Illegal direct
 68   4000              ;13 Type mismatch
 69   4000              ;14 Out of string space
 70   4000              ;15 String too long
 71   4000              ;16 String formula too complex
 72   4000              ;17 Can't CONTINUE
 73   4000              ;18 Undefined user function
 74   4000              ;19 Device I/O error
 75   4000              ;20 Verify error
 76   4000              ;21 No RESUME
 77   4000              ;22 RESUME without error
 78   4000              ;23 Unprintable error
 79   4000              ;24 Missing operand
 80   4000              ;25 Line buffer overflow
 81   4000              ;50 FIELD overflow
 82   4000              ;51 Internal error
 83   4000              ;52 Bad file number
 84   4000              ;53 File not found
 85   4000              ;54 File already open
 86   4000              ;55 Input past end
 87   4000              ;56 Bad file name
 88   4000              ;57 Direct statement in file
 89   4000              ;58 Sequential I/O only
 90   4000              ;59 File not OPEN
 91   4000
 92   4000
 93   4000               ; simulate cartridge with BASIC extension
 94   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 94   4004 26 5F 00 00
 94   4008 00 00 00 00
 94   400C 00 00 00 00
 95   4010
 96   4010              ; this location #4010 stores last location used by basic extension
 97   4010              ; free memory after that point
 98   4010              FREEMEMPTR:
 99   4010 BF 5F         DW EXT_END
100   4012
101   4012              ; this location #4012 stores extension version in DAA format
102   4012              ; first byte is major version and second minor
103   4012              VERSION:
104   4012 00 70         DB #00, #70
105   4014
106   4014              ; binary included AKG player compiled at #4014
107   4014               IF (SOUND_CMDS == 1)
108   4014              	INCBIN "bin/AKG.bin"
109   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
110   4CF0               ENDIF
111   4CF0
112   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A C2 54     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD 56 5E         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD 9D 5E         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD 56 5E         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD 9D 5E         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A C2 54     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD 8D 5E         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD 8D 5E         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A BD 5C         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD 40 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
113   4D73
114   4D73               IF (SPRITE_CMDS == 1)
115   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD 52 5E         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D95 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D98 B7           	OR A
 55+  4D99 28 03        	JR Z, .L3
 56+  4D9B 3A 79 4D     	LD A, (FLICKER)
 57+  4D9E              .L3:
 58+  4D9E 5F           	LD E, A
 59+  4D9F 08           	EX AF, AF'
 60+  4DA0 7B           	LD A, E
 61+  4DA1 87           	ADD A, A
 62+  4DA2 87           	ADD A, A
 63+  4DA3 16 00        	LD D, 0
 64+  4DA5 5F           	LD E, A
 65+  4DA6 19           	ADD HL, DE
 66+  4DA7 CD 3D 5E     	CALL SETWRT_LOCAL
 67+  4DAA ED 73 7A 4D  	LD (TMPSP), SP
 68+  4DAE ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 69+  4DB2
 70+  4DB2              .LOOP:
 71+  4DB2 E1           	POP HL
 72+  4DB3 24           	INC H
 73+  4DB4 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DB6 25           	DEC H
 75+  4DB7 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DB9 7D           	LD A, L
 77+  4DBA FE C0        	CP 192
 78+  4DBC 30 10        	JR NC, .OUT3
 79+  4DBE 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DBF 57           	LD D, A
 81+  4DC0 C3 E7 4D     	JP .X
 82+  4DC3              .L1:
 83+  4DC3 7D           	LD A, L
 84+  4DC4 C6 10        	ADD 16
 85+  4DC6 FA CE 4D     	JP M, .OUT3 ; below -16
 86+  4DC9 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DCA 55           	LD D, L
 88+  4DCB C3 E7 4D     	JP .X
 89+  4DCE              .OUT3:
 90+  4DCE E1           	POP HL ; skip x value
 91+  4DCF              .OUT2:
 92+  4DCF E1           	POP HL ; skip pattern
 93+  4DD0 E1           	POP HL ; skip color
 94+  4DD1 3E D1        	LD A, #D1
 95+  4DD3 ED 79        	OUT (C), A ; sprite hidden
 96+  4DD5 00          > NOP
 96+  4DD6 00          > NOP
 96+  4DD7 00          > NOP
 97+  4DD8 ED 79        	OUT (C), A ; value unimportant
 98+  4DDA 00          > NOP
 98+  4DDB 00          > NOP
 98+  4DDC 00          > NOP
 99+  4DDD ED 79        	OUT (C), A ; value unimportant
100+  4DDF 00          > NOP
100+  4DE0 00          > NOP
100+  4DE1 00          > NOP
101+  4DE2 ED 79        	OUT (C), A ; value unimportant
102+  4DE4 C3 12 4E     	JP .NEXT
103+  4DE7              .X:
104+  4DE7 E1           	POP HL
105+  4DE8 24           	INC H
106+  4DE9 28 08        	JR Z, .L2
107+  4DEB 25           	DEC H
108+  4DEC 20 E1        	JR NZ, .OUT2
109+  4DEE 1E 00        	LD E, 0 ; EC bit
110+  4DF0 C3 FC 4D     	JP .XY
111+  4DF3              .L2:
112+  4DF3 7D           	LD A, L
113+  4DF4 C6 20        	ADD 32
114+  4DF6 FA CF 4D     	JP M, .OUT2
115+  4DF9 6F           	LD L, A
116+  4DFA 1E 80        	LD E, #80
117+  4DFC              .XY:
118+  4DFC ED 51        	OUT (C), D
119+  4DFE 3A E0 F3     	LD A, (REG1SAV)
120+  4E01 E6 02        	AND 2
121+  4E03 ED 69        	OUT (C), L
122+  4E05 E1           	POP HL ; pattern
123+  4E06 7D           	LD A, L
124+  4E07 28 02        	JR Z, .SMALLSPRITES
125+  4E09 87           	ADD A, A
126+  4E0A 87           	ADD A, A ; needs to go at 4x
127+  4E0B              .SMALLSPRITES:
128+  4E0B D3 98        	OUT (#98), A
129+  4E0D E1           	POP HL ; color
130+  4E0E 7D           	LD A, L
131+  4E0F B3           	OR E
132+  4E10 D3 98        	OUT (#98), A
133+  4E12              .NEXT:
134+  4E12 08           	EX AF, AF'
135+  4E13 3C           	INC A
136+  4E14 E6 1F        	AND 31
137+  4E16 C2 2A 4E     	JP NZ, .NEXT2
138+  4E19 08           	EX AF, AF'
139+  4E1A 2A 28 F9     	LD HL, (ATRBAS)
140+  4E1D              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E1D 7D           	LD	A, L
142+  4E1E D3 99        	OUT	(099H), A
143+  4E20 7C           	LD	A, H
144+  4E21 E6 3F        	AND	03FH
145+  4E23 F6 40        	OR	040H
146+  4E25 D3 99        	OUT	(099H), A
147+  4E27 C3 2B 4E     	JP .NEXT3
148+  4E2A              .NEXT2:
149+  4E2A 08           	EX AF, AF'
150+  4E2B              .NEXT3:
151+  4E2B 10 85        	DJNZ .LOOP
152+  4E2D 08           	EX AF, AF'
153+  4E2E 3C           	INC A
154+  4E2F 32 79 4D     	LD (FLICKER), A
155+  4E32
156+  4E32 ED 7B 7A 4D  	LD SP, (TMPSP)
157+  4E36 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E39 36 00        	LD (HL), 0 ; zero out update flag
159+  4E3B C9           	RET
160+  4E3C              ; *******************************************************************************************************
161+  4E3C
162+  4E3C              ; *******************************************************************************************************
163+  4E3C              ; function to handle CALL SPRENABLE basic extension
164+  4E3C              ; initializes sprites handler
165+  4E3C              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E3C              ;			   INT update_variable,
167+  4E3C              ;			   BYTE sprite_flicker_enabled )
168+  4E3C              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E3C              SPRENABLE:
170+  4E3C              	; opening (
171+  4E3C CD 63 5F     	CALL CHKCHAR
172+  4E3F 28           	DB '('
173+  4E40              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E40 3E 02        	LD A,2
175+  4E42 06 02        	LD B,2
176+  4E44 11 20 04     	LD DE,#0420
177+  4E47 CD 8A 5F     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E4A C5           	PUSH BC
179+  4E4B              	; comma
180+  4E4B CD 63 5F     	CALL CHKCHAR
181+  4E4E 2C           	DB ','
182+  4E4F              	; get address of sprite update flag
183+  4E4F DD 21 A4 5E  	LD IX, PTRGET
184+  4E53 CD 59 01     	CALL CALBAS
185+  4E56 D5           	PUSH DE
186+  4E57              	; comma
187+  4E57 CD 63 5F     	CALL CHKCHAR
188+  4E5A 2C           	DB ','
189+  4E5B              	; get flicker enabled flag
190+  4E5B DD 21 1C 52  	LD IX, GETBYT
191+  4E5F CD 59 01     	CALL CALBAS
192+  4E62 F5           	PUSH AF
193+  4E63              	; ending )
194+  4E63 CD 63 5F     	CALL CHKCHAR
195+  4E66 29           	DB ')'
196+  4E67
197+  4E67 F1           	POP AF ; get flicker flag
198+  4E68 B7           	OR A
199+  4E69 32 78 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E6C
201+  4E6C D1           	POP DE ; update variable location
202+  4E6D ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E71 D1           	POP DE ; address of sprite attribute table
204+  4E72 ED 53 76 4D  	LD (SPRATR_DATA), DE
205+  4E76 3E 01        	LD A, 1
206+  4E78 32 73 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E7B C9           	RET
208+  4E7C              ; *******************************************************************************************************
209+  4E7C
210+  4E7C              ; *******************************************************************************************************
211+  4E7C              ; function to handle CALL SPRDISABLE basic extension
212+  4E7C              ; disables sprites handling
213+  4E7C              ; _SPRDISABLE
214+  4E7C              ; resets variable SPRATR_INIT_STATUS
215+  4E7C              SPRDISABLE:
216+  4E7C AF           	XOR A
217+  4E7D 32 73 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E80 C9           	RET
219+  4E81              ; *******************************************************************************************************
220+  4E81
221+  4E81              ; *******************************************************************************************************
222+  4E81              ; function to handle CALL SPRSET basic extension
223+  4E81              ; sets position, and optionally pattern and color of sprite
224+  4E81              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E81              ;			INT x,
226+  4E81              ;			INT y,
227+  4E81              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E81              ;			INT color, valid 0-15, otherwise ignored
229+  4E81              SPRSET:
230+  4E81 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E84 B7           	OR A
232+  4E85 20 05        	JR NZ, .L1
233+  4E87 1E 05        	LD E, 5 ; illegal function call
234+  4E89 C3 83 5F     	JP THROW_ERROR
235+  4E8C              .L1:
236+  4E8C              	; opening (
237+  4E8C CD 63 5F     	CALL CHKCHAR
238+  4E8F 28           	DB '('
239+  4E90              	; get sprite number
240+  4E90 DD 21 1C 52  	LD IX, GETBYT
241+  4E94 CD 59 01     	CALL CALBAS
242+  4E97 F5           	PUSH AF
243+  4E98              	; comma
244+  4E98 CD 63 5F     	CALL CHKCHAR
245+  4E9B 2C           	DB ','
246+  4E9C              	; get x
247+  4E9C DD 21 2F 54  	LD IX, FRMQNT
248+  4EA0 CD 59 01     	CALL CALBAS
249+  4EA3 D5           	PUSH DE
250+  4EA4              	; comma
251+  4EA4 CD 63 5F     	CALL CHKCHAR
252+  4EA7 2C           	DB ','
253+  4EA8              	; get y
254+  4EA8 DD 21 2F 54  	LD IX, FRMQNT
255+  4EAC CD 59 01     	CALL CALBAS
256+  4EAF D5           	PUSH DE
257+  4EB0              	; comma
258+  4EB0 CD 63 5F     	CALL CHKCHAR
259+  4EB3 2C           	DB ','
260+  4EB4              	; get pattern
261+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
262+  4EB8 CD 59 01     	CALL CALBAS
263+  4EBB D5           	PUSH DE
264+  4EBC              	; comma
265+  4EBC CD 63 5F     	CALL CHKCHAR
266+  4EBF 2C           	DB ','
267+  4EC0              	; get color
268+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
269+  4EC4 CD 59 01     	CALL CALBAS
270+  4EC7 D5           	PUSH DE
271+  4EC8              	; ending )
272+  4EC8 CD 63 5F     	CALL CHKCHAR
273+  4ECB 29           	DB ')'
274+  4ECC
275+  4ECC                  ; save position in BASIC text
276+  4ECC E5           	PUSH HL
277+  4ECD DD E1        	POP IX
278+  4ECF
279+  4ECF C1           	POP BC ; color
280+  4ED0 D1           	POP DE ; pattern
281+  4ED1 D9           	EXX
282+  4ED2 C1           	POP BC ; y
283+  4ED3 D1           	POP DE ; x
284+  4ED4 F1           	POP AF ; sprite number
285+  4ED5 FE 20        	CP 32
286+  4ED7 38 05        	JR C, .L2
287+  4ED9 1E 05        	LD E, 5 ; illegal function call
288+  4EDB C3 83 5F     	JP THROW_ERROR
289+  4EDE              .L2:
290+  4EDE              	; find location in sprite attributes table
291+  4EDE D5           	PUSH DE
292+  4EDF CD 7C 4D     	CALL GETnthSPRATTR
293+  4EE2 D1           	POP DE
294+  4EE3              	; set y
295+  4EE3 71           	LD (HL), C
296+  4EE4 23           	INC HL
297+  4EE5 70           	LD (HL), B
298+  4EE6 23           	INC HL
299+  4EE7              	; set x
300+  4EE7 73           	LD (HL), E
301+  4EE8 23           	INC HL
302+  4EE9 72           	LD (HL), D
303+  4EEA 23           	INC HL
304+  4EEB E5           	PUSH HL
305+  4EEC D9           	EXX
306+  4EED E1           	POP HL
307+  4EEE              	; check if 0<=pattern<64
308+  4EEE 7A           	LD A, D
309+  4EEF B7           	OR A
310+  4EF0 20 0B        	JR NZ, .L3
311+  4EF2 7B           	LD A, E
312+  4EF3 FE 40        	CP 64
313+  4EF5 30 06        	JR NC, .L3
314+  4EF7              	; set pattern
315+  4EF7              	;ADD A, A
316+  4EF7              	;ADD A, A
317+  4EF7              	;ADD A, A
318+  4EF7 77           	LD (HL), A
319+  4EF8 23           	INC HL
320+  4EF9 72           	LD (HL), D
321+  4EFA 23           	INC HL
322+  4EFB 18 02        	JR .L4
323+  4EFD              .L3:
324+  4EFD              	; skip pattern
325+  4EFD 23          > INC HL
325+  4EFE 23          > INC HL
326+  4EFF              .L4:
327+  4EFF              	; check if 0<=color<16
328+  4EFF 78           	LD A, B
329+  4F00 B7           	OR A
330+  4F01 20 08        	JR NZ, .L5
331+  4F03 79           	LD A, C
332+  4F04 FE 10        	CP 16
333+  4F06 30 03        	JR NC, .L5
334+  4F08              	; set color
335+  4F08 71           	LD (HL), C
336+  4F09 23           	INC HL
337+  4F0A 70           	LD (HL), B
338+  4F0B
339+  4F0B              .L5:
340+  4F0B DD E5        	PUSH IX
341+  4F0D E1           	POP HL
342+  4F0E C9           	RET
343+  4F0F              ; *******************************************************************************************************
344+  4F0F
345+  4F0F              ; *******************************************************************************************************
346+  4F0F              ; function sets sprite location based on initial coordinates and offset provided
347+  4F0F              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F0F              ; input DE=initial x
349+  4F0F              ; input BC=initial y
350+  4F0F              ; input IY=location where delta y,x are located
351+  4F0F              ; modifies AF, HL, IX
352+  4F0F              SPRSET_DELTA_POS:
353+  4F0F D5           	PUSH DE
354+  4F10 CD 7C 4D     	CALL GETnthSPRATTR
355+  4F13 E5           	PUSH HL
356+  4F14 DD E1        	POP IX
357+  4F16 D1           	POP DE
358+  4F17              	; IX=sprite's y location
359+  4F17 FD 6E 00     	LD L, (IY)
360+  4F1A FD 66 01     	LD H, (IY+1)
361+  4F1D 09           	ADD HL, BC
362+  4F1E DD 75 00     	LD (IX), L
363+  4F21 DD 74 01     	LD (IX+1), H
364+  4F24 FD 6E 02     	LD L, (IY+2)
365+  4F27 FD 66 03     	LD H, (IY+3)
366+  4F2A 19           	ADD HL, DE
367+  4F2B DD 75 02     	LD (IX+2), L
368+  4F2E DD 74 03     	LD (IX+3), H
369+  4F31 C9           	RET
370+  4F32              ; *******************************************************************************************************
371+  4F32
372+  4F32              ; *******************************************************************************************************
373+  4F32              ; function to handle CALL SPRGRPMOV basic extension
374+  4F32              ; sets position of a group of sprites described with
375+  4F32              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F32              ; _SPRGRPMOV ( INT x,
377+  4F32              ;			   INT y,
378+  4F32              ;			   BYTE count,
379+  4F32              ;			   INT[2][count] data_ptr
380+  4F32              ; will put ram in page 0 also, page 1 is already there
381+  4F32              SPRGRPMOV:
382+  4F32 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F35 B7           	OR A
384+  4F36 20 05        	JR NZ, .L1
385+  4F38 1E 05        	LD E, 5 ; illegal function call
386+  4F3A C3 83 5F     	JP THROW_ERROR
387+  4F3D              .L1:
388+  4F3D              	; opening (
389+  4F3D CD 63 5F     	CALL CHKCHAR
390+  4F40 28           	DB '('
391+  4F41              	; get x
392+  4F41 DD 21 2F 54  	LD IX, FRMQNT
393+  4F45 CD 59 01     	CALL CALBAS
394+  4F48 D5           	PUSH DE
395+  4F49              	; comma
396+  4F49 CD 63 5F     	CALL CHKCHAR
397+  4F4C 2C           	DB ','
398+  4F4D              	; get y
399+  4F4D DD 21 2F 54  	LD IX, FRMQNT
400+  4F51 CD 59 01     	CALL CALBAS
401+  4F54 D5           	PUSH DE
402+  4F55              	; comma
403+  4F55 CD 63 5F     	CALL CHKCHAR
404+  4F58 2C           	DB ','
405+  4F59              	; get count
406+  4F59 DD 21 1C 52  	LD IX, GETBYT
407+  4F5D CD 59 01     	CALL CALBAS
408+  4F60 F5           	PUSH AF
409+  4F61              	; comma
410+  4F61 CD 63 5F     	CALL CHKCHAR
411+  4F64 2C           	DB ','
412+  4F65              	; get sprite group definition array data pointer
413+  4F65 D1           	POP DE
414+  4F66 D5           	PUSH DE
415+  4F67 5A           	LD E,D
416+  4F68 16 03        	LD D,3
417+  4F6A 3E 02        	LD A,2
418+  4F6C 47           	LD B,A
419+  4F6D CD 8A 5F     	CALL GET_BASIC_ARRAY_DATA_POINTER
420+  4F70 C5           	PUSH BC
421+  4F71              	; ending )
422+  4F71 CD 63 5F     	CALL CHKCHAR
423+  4F74 29           	DB ')'
424+  4F75
425+  4F75 E5           	PUSH HL
426+  4F76 DD E1        	POP IX
427+  4F78
428+  4F78 E1           	POP HL ; data pointer
429+  4F79 C1           	POP BC ; count
430+  4F7A D9           	EXX
431+  4F7B C1           	POP BC ; y
432+  4F7C D1           	POP DE ; x
433+  4F7D D9           	EXX
434+  4F7E
435+  4F7E DD E5        	PUSH IX ; save position in BASIC buffer
436+  4F80
437+  4F80 C5           	PUSH BC
438+  4F81 E5           	PUSH HL
439+  4F82 AF               XOR A
440+  4F83 CD 56 5E         CALL GET_PAGE_INFO
441+  4F86 D9           	EXX
442+  4F87 E1           	POP HL
443+  4F88 F1           	POP AF
444+  4F89 D9           	EXX
445+  4F8A C5               PUSH BC
446+  4F8B D5               PUSH DE
447+  4F8C D9           	EXX
448+  4F8D F5           	PUSH AF
449+  4F8E E5           	PUSH HL
450+  4F8F D9           	EXX
451+  4F90 3A 41 F3         LD A, (RAMAD0)
452+  4F93 26 00            LD H, 0
453+  4F95 CD 9D 5E         CALL LOCAL_ENASLT
454+  4F98 FB           	EI
455+  4F99 E1           	POP HL
456+  4F9A C1           	POP BC
457+  4F9B CD A5 4F     	CALL .UPDATE_LOC
458+  4F9E D1               POP DE
459+  4F9F C1               POP BC
460+  4FA0 CD 8D 5E         CALL RESTORE_PAGE_INFO
461+  4FA3 E1           	POP HL
462+  4FA4 C9           	RET
463+  4FA5
464+  4FA5              .UPDATE_LOC:
465+  4FA5              .L4:
466+  4FA5 7E           	LD A, (HL)
467+  4FA6 23           	INC HL
468+  4FA7 23           	INC HL
469+  4FA8 E5           	PUSH HL
470+  4FA9 FD E1        	POP IY
471+  4FAB D9           	EXX
472+  4FAC CD 0F 4F     	CALL SPRSET_DELTA_POS
473+  4FAF D9           	EXX
474+  4FB0 23          > INC HL
474+  4FB1 23          > INC HL
474+  4FB2 23          > INC HL
474+  4FB3 23          > INC HL
475+  4FB4 10 EF        	DJNZ .L4
476+  4FB6 C9           	RET
477+  4FB7              ; *******************************************************************************************************
478+  4FB7
# file closed: asm\SPRITES.asm
116   4FB7               ENDIF
117   4FB7
118   4FB7               IF (ANIM_CMDS == 1)
119   4FB7               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FB7              ; sprite animation routines
  2+  4FB7
  3+  4FB7              ; number of animation items and pointer
  4+  4FB7              ANIMITEMNUM:
  5+  4FB7 00            DB 0
  6+  4FB8              ANIMITEMPTR:
  7+  4FB8 BF 5F         DW EXT_END
  8+  4FBA              ; number of animation definitions and pointer
  9+  4FBA              ANIMDEFNUM:
 10+  4FBA 00            DB 0
 11+  4FBB              ANIMDEFPTR:
 12+  4FBB BF 5F         DW EXT_END
 13+  4FBD              ; number of links between sprite and animation definitions
 14+  4FBD              ANIMSPRNUM:
 15+  4FBD 00            DB 0
 16+  4FBE              ANIMSPRPTR:
 17+  4FBE BF 5F         DW EXT_END
 18+  4FC0
 19+  4FC0              ; ANIMATION ITEM
 20+  4FC0              ; byte type = [0 - pattern and color change
 21+  4FC0              ;              1 - pattern definition change ]
 22+  4FC0              ; word ticks - number of ticks to hold this state
 23+  4FC0              ; for type = 0
 24+  4FC0              ;   byte pattern;
 25+  4FC0              ;   byte color;
 26+  4FC0              ; for type = 1
 27+  4FC0              ;   work data_pointer;
 28+  4FC0              ; total size = 5b
 29+  4FC0
 30+  4FC0              ; ANIMATION DEFINITION
 31+  4FC0              ; byte number of items 1-15
 32+  4FC0              ; byte[15] anim_item;
 33+  4FC0              ; total size = 16b
 34+  4FC0
 35+  4FC0              ; SPRITE ANIMATION
 36+  4FC0              ; +00 byte sprite number;
 37+  4FC0              ; +01 word time;
 38+  4FC0              ; +03 byte current item;
 39+  4FC0              ; +04 byte animation definition;
 40+  4FC0              ; +05 byte cyclic;
 41+  4FC0              ; +06 byte active;
 42+  4FC0              ; +07 byte reserved
 43+  4FC0              ; total size = 8b
 44+  4FC0
 45+  4FC0              ; *******************************************************************************************************
 46+  4FC0              ; helper function HL=A*5
 47+  4FC0              ; changes HL,DE;
 48+  4FC0              Ax5:
 49+  4FC0 26 00            LD H,0
 50+  4FC2 6F               LD L,A
 51+  4FC3 54               LD D,H
 52+  4FC4 5D               LD E,L
 53+  4FC5 29               ADD HL,HL
 54+  4FC6 29               ADD HL,HL
 55+  4FC7 19               ADD HL,DE
 56+  4FC8 C9               RET
 57+  4FC9              ; *******************************************************************************************************
 58+  4FC9
 59+  4FC9              ; *******************************************************************************************************
 60+  4FC9              ; helper function gets pointer to n-th animation item
 61+  4FC9              ; changes HL,DE;
 62+  4FC9              GETnthANIMITEM:
 63+  4FC9 CD C0 4F         CALL Ax5
 64+  4FCC ED 5B B8 4F      LD DE,(ANIMITEMPTR)
 65+  4FD0 19               ADD HL,DE
 66+  4FD1 C9               RET
 67+  4FD2              ; *******************************************************************************************************
 68+  4FD2
 69+  4FD2              ; *******************************************************************************************************
 70+  4FD2              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD2              ; changes HL,DE;
 72+  4FD2              GETnthANIMDEF:
 73+  4FD2 26 00            LD H,0
 74+  4FD4 6F               LD L,A
 75+  4FD5 CD 52 5E         CALL HLx8
 76+  4FD8 ED 5B BB 4F      LD DE,(ANIMDEFPTR)
 77+  4FDC 19               ADD HL,DE
 78+  4FDD C9               RET
 79+  4FDE              ; *******************************************************************************************************
 80+  4FDE
 81+  4FDE              ; *******************************************************************************************************
 82+  4FDE              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FDE              ; changes HL,DE;
 84+  4FDE              GETnthSPRANIM:
 85+  4FDE 26 00            LD H,0
 86+  4FE0 6F               LD L,A
 87+  4FE1 CD 51 5E         CALL HLx16
 88+  4FE4 ED 5B BE 4F      LD DE,(ANIMSPRPTR)
 89+  4FE8 19               ADD HL,DE
 90+  4FE9 C9               RET
 91+  4FEA              ; *******************************************************************************************************
 92+  4FEA
 93+  4FEA              ; *******************************************************************************************************
 94+  4FEA              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FEA              ; MAXANIMITEMS (BYTE number)
 96+  4FEA              ; sets new number and moves memory buffers as needed
 97+  4FEA              MAXANIMITEMS:
 98+  4FEA              	; opening (
 99+  4FEA CD 63 5F     	CALL CHKCHAR
100+  4FED 28           	DB '('
101+  4FEE              	; get value
102+  4FEE DD 21 1C 52  	LD IX, GETBYT
103+  4FF2 CD 59 01     	CALL CALBAS
104+  4FF5 F5               PUSH AF
105+  4FF6              	; ending )
106+  4FF6 CD 63 5F     	CALL CHKCHAR
107+  4FF9 29           	DB ')'
108+  4FFA F1               POP AF
109+  4FFB
110+  4FFB              	; save position
111+  4FFB E5           	PUSH HL
112+  4FFC              .ENTRY:
113+  4FFC 47               LD B,A
114+  4FFD 3A B7 4F         LD A,(ANIMITEMNUM)
115+  5000 90               SUB B
116+  5001 28 1F            JR Z, .EXIT; same value as before
117+  5003 FD 21 BB 4F      LD IY,ANIMDEFPTR
118+  5007 FA 25 50         JP M, .INCREASE
119+  500A                  ; new value is lower than previous one
120+  500A CD 3D 50         CALL .SIZEDIFF
121+  500D CD 58 50         CALL .DECREASE_COMMON
122+  5010 2A BE 4F         LD HL,(ANIMSPRPTR)
123+  5013 AF               XOR A
124+  5014 ED 42            SBC HL,BC
125+  5016 22 BE 4F         LD (ANIMSPRPTR),HL
126+  5019              .E1:
127+  5019 2A 10 40         LD HL,(FREEMEMPTR)
128+  501C AF               XOR A
129+  501D ED 42            SBC HL,BC
130+  501F 22 10 40         LD (FREEMEMPTR),HL
131+  5022              .EXIT:
132+  5022 FB               EI
133+  5023 E1           	POP HL
134+  5024 C9           	RET
135+  5025              .INCREASE:
136+  5025 ED 44            NEG
137+  5027 CD 3D 50         CALL .SIZEDIFF
138+  502A CD 84 50         CALL .INCREASE_COMMON
139+  502D 2A BE 4F         LD HL,(ANIMSPRPTR)
140+  5030 09               ADD HL,BC
141+  5031 22 BE 4F         LD (ANIMSPRPTR),HL
142+  5034              .E2:
143+  5034 2A 10 40         LD HL,(FREEMEMPTR)
144+  5037 09               ADD HL,BC
145+  5038 22 10 40         LD (FREEMEMPTR),HL
146+  503B 18 E5            JR .EXIT
147+  503D              .SIZEDIFF:
148+  503D CD C0 4F         CALL Ax5
149+  5040 78               LD A,B
150+  5041 32 B7 4F         LD (ANIMITEMNUM),A
151+  5044 44               LD B,H
152+  5045 4D               LD C,L
153+  5046 C9               RET ; BC=size difference in bytes
154+  5047              .SIZETOMOVE:
155+  5047 D5               PUSH DE
156+  5048 2A 10 40         LD HL,(FREEMEMPTR)
157+  504B FD 5E 00         LD E,(IY)
158+  504E FD 56 01         LD D,(IY+1)
159+  5051 AF               XOR A
160+  5052 ED 52            SBC HL,DE
161+  5054 44               LD B,H
162+  5055 4D               LD C,L
163+  5056 D1               POP DE
164+  5057 C9               RET
165+  5058              .DECREASE_COMMON:
166+  5058 FD 6E 00         LD L,(IY)
167+  505B FD 66 01         LD H,(IY+1)
168+  505E AF               XOR A
169+  505F ED 42            SBC HL,BC
170+  5061 EB               EX DE,HL
171+  5062 C5               PUSH BC
172+  5063 CD 47 50         CALL .SIZETOMOVE
173+  5066 F3               DI
174+  5067 78               LD A,B
175+  5068 B1               OR C
176+  5069 28 08            JR Z,.L1
177+  506B FD 6E 00         LD L,(IY)
178+  506E FD 66 01         LD H,(IY+1)
179+  5071 ED B0            LDIR
180+  5073              .L1:
181+  5073 C1               POP BC
182+  5074 FD 6E 00         LD L,(IY)
183+  5077 FD 66 01         LD H,(IY+1)
184+  507A AF               XOR A
185+  507B ED 42            SBC HL,BC
186+  507D FD 75 00         LD (IY),L
187+  5080 FD 74 01         LD (IY+1),H
188+  5083 C9               RET
189+  5084              .INCREASE_COMMON:
190+  5084 2A 10 40         LD HL,(FREEMEMPTR)
191+  5087 2B               DEC HL
192+  5088 AF               XOR A
193+  5089 ED 42            SBC HL,BC
194+  508B EB               EX DE,HL
195+  508C C5               PUSH BC
196+  508D CD 47 50         CALL .SIZETOMOVE
197+  5090 F3               DI
198+  5091 78               LD A,B
199+  5092 B1               OR C
200+  5093 28 06            JR Z,.L2
201+  5095 2A 10 40         LD HL,(FREEMEMPTR)
202+  5098 2B               DEC HL
203+  5099 ED B8            LDDR
204+  509B              .L2:
205+  509B C1               POP BC
206+  509C FD 6E 00         LD L,(IY)
207+  509F FD 66 01         LD H,(IY+1)
208+  50A2 09               ADD HL,BC
209+  50A3 FD 75 00         LD (IY),L
210+  50A6 FD 74 01         LD (IY+1),H
211+  50A9 C9               RET
212+  50AA              ; *******************************************************************************************************
213+  50AA
214+  50AA              ; *******************************************************************************************************
215+  50AA              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AA              ; ANIMITEMPAT ( BYTE id,
217+  50AA              ;               INT ticks,
218+  50AA              ;               BYTE pattern,
219+  50AA              ;               BYTE color )
220+  50AA              ; fills animation item data, returns an error if out of bounds
221+  50AA              ANIMITEMPAT:
222+  50AA                  ; opening (
223+  50AA CD 63 5F     	CALL CHKCHAR
224+  50AD 28           	DB '('
225+  50AE              	; get id
226+  50AE DD 21 1C 52  	LD IX, GETBYT
227+  50B2 CD 59 01     	CALL CALBAS
228+  50B5 F5               PUSH AF
229+  50B6                  ; check if out of bounds
230+  50B6 3C               INC A
231+  50B7 4F               LD C,A
232+  50B8 3A B7 4F         LD A,(ANIMITEMNUM)
233+  50BB B9               CP C
234+  50BC DA 79 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50BF              	; comma
236+  50BF CD 63 5F     	CALL CHKCHAR
237+  50C2 2C           	DB ','
238+  50C3              	; get ticks
239+  50C3 DD 21 2F 54  	LD IX, FRMQNT
240+  50C7 CD 59 01     	CALL CALBAS
241+  50CA D5           	PUSH DE
242+  50CB              	; comma
243+  50CB CD 63 5F     	CALL CHKCHAR
244+  50CE 2C           	DB ','
245+  50CF              	; get pattern
246+  50CF DD 21 1C 52  	LD IX, GETBYT
247+  50D3 CD 59 01     	CALL CALBAS
248+  50D6 F5               PUSH AF
249+  50D7              	; comma
250+  50D7 CD 63 5F     	CALL CHKCHAR
251+  50DA 2C           	DB ','
252+  50DB              	; get color
253+  50DB DD 21 1C 52  	LD IX, GETBYT
254+  50DF CD 59 01     	CALL CALBAS
255+  50E2 F5               PUSH AF
256+  50E3              	; ending )
257+  50E3 CD 63 5F     	CALL CHKCHAR
258+  50E6 29           	DB ')'
259+  50E7              .ENTRY:
260+  50E7 E5               PUSH HL
261+  50E8 DD E1            POP IX
262+  50EA D9               EXX
263+  50EB C1               POP BC ; color
264+  50EC D1               POP DE ; pattern
265+  50ED E1               POP HL ; ticks
266+  50EE D9               EXX
267+  50EF F1               POP AF
268+  50F0 CD C9 4F         CALL GETnthANIMITEM
269+  50F3 E5               PUSH HL
270+  50F4 FD E1            POP IY
271+  50F6 D9               EXX
272+  50F7 FD 36 00 00      LD (IY),0 ; type=0
273+  50FB FD 75 01         LD (IY+1),L
274+  50FE FD 74 02         LD (IY+2),H
275+  5101 FD 72 03         LD (IY+3),D
276+  5104 FD 70 04         LD (IY+4),B
277+  5107
278+  5107 DD E5            PUSH IX
279+  5109 E1               POP HL
280+  510A C9               RET
281+  510B              ; *******************************************************************************************************
282+  510B
283+  510B              ; *******************************************************************************************************
284+  510B              ; function to handle CALL ANIMITEMPTR basic extension
285+  510B              ; ANIMITEMPTR ( BYTE id,
286+  510B              ;               INT ticks,
287+  510B              ;               INT pointer,
288+  510B              ; fills animation item data, returns an error if out of bounds
289+  510B              ANIMITEMPTR_CMD:
290+  510B                  ; opening (
291+  510B CD 63 5F     	CALL CHKCHAR
292+  510E 28           	DB '('
293+  510F              	; get id
294+  510F DD 21 1C 52  	LD IX, GETBYT
295+  5113 CD 59 01     	CALL CALBAS
296+  5116 F5               PUSH AF
297+  5117                  ; check if out of bounds
298+  5117 3C               INC A
299+  5118 4F               LD C,A
300+  5119 3A B7 4F         LD A,(ANIMITEMNUM)
301+  511C B9               CP C
302+  511D DA 79 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5120              	; comma
304+  5120 CD 63 5F     	CALL CHKCHAR
305+  5123 2C           	DB ','
306+  5124              	; get ticks
307+  5124 DD 21 2F 54  	LD IX, FRMQNT
308+  5128 CD 59 01     	CALL CALBAS
309+  512B D5           	PUSH DE
310+  512C              	; comma
311+  512C CD 63 5F     	CALL CHKCHAR
312+  512F 2C           	DB ','
313+  5130              	; get pointer
314+  5130 DD 21 2F 54  	LD IX, FRMQNT
315+  5134 CD 59 01     	CALL CALBAS
316+  5137 D5           	PUSH DE
317+  5138              	; ending )
318+  5138 CD 63 5F     	CALL CHKCHAR
319+  513B 29           	DB ')'
320+  513C              .ENTRY:
321+  513C E5               PUSH HL
322+  513D DD E1            POP IX
323+  513F D9               EXX
324+  5140 D1               POP DE ; pointer
325+  5141 E1               POP HL ; ticks
326+  5142 D9               EXX
327+  5143 F1               POP AF
328+  5144 CD C9 4F         CALL GETnthANIMITEM
329+  5147 E5               PUSH HL
330+  5148 FD E1            POP IY
331+  514A D9               EXX
332+  514B FD 36 00 01      LD (IY),1 ; type=1
333+  514F FD 75 01         LD (IY+1),L
334+  5152 FD 74 02         LD (IY+2),H
335+  5155 FD 73 03         LD (IY+3),E
336+  5158 FD 72 04         LD (IY+4),D
337+  515B
338+  515B DD E5            PUSH IX
339+  515D E1               POP HL
340+  515E C9               RET
341+  515F              ; *******************************************************************************************************
342+  515F
343+  515F              ; *******************************************************************************************************
344+  515F              ; function to handle CALL MAXANIMDEFS basic extension
345+  515F              ; MAXANIMDEFS (BYTE number)
346+  515F              ; sets new number and moves memory buffers as needed
347+  515F              MAXANIMDEFS:
348+  515F              	; opening (
349+  515F CD 63 5F     	CALL CHKCHAR
350+  5162 28           	DB '('
351+  5163              	; get value
352+  5163 DD 21 1C 52  	LD IX, GETBYT
353+  5167 CD 59 01     	CALL CALBAS
354+  516A F5               PUSH AF
355+  516B              	; ending )
356+  516B CD 63 5F     	CALL CHKCHAR
357+  516E 29           	DB ')'
358+  516F F1               POP AF
359+  5170
360+  5170              	; save position
361+  5170 E5           	PUSH HL
362+  5171              .ENTRY:
363+  5171 47               LD B,A
364+  5172 3A BA 4F         LD A,(ANIMDEFNUM)
365+  5175 90               SUB B
366+  5176 CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  5179 FD 21 BE 4F      LD IY,ANIMSPRPTR
368+  517D FA 89 51         JP M, .INCREASE
369+  5180                  ; new value is lower than previous one
370+  5180 CD 94 51         CALL .SIZEDIFF
371+  5183 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  5186 C3 19 50         JP MAXANIMITEMS.E1
373+  5189              .INCREASE:
374+  5189 ED 44            NEG
375+  518B CD 94 51         CALL .SIZEDIFF
376+  518E CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5191 C3 34 50         JP MAXANIMITEMS.E2
378+  5194              .SIZEDIFF:
379+  5194 26 00            LD H,0
380+  5196 6F               LD L,A
381+  5197 CD 51 5E         CALL HLx16
382+  519A 78               LD A,B
383+  519B 32 BA 4F         LD (ANIMDEFNUM),A
384+  519E 44               LD B,H
385+  519F 4D               LD C,L
386+  51A0 C9               RET ; BC=size difference in bytes
387+  51A1              ; *******************************************************************************************************
388+  51A1
389+  51A1              ; *******************************************************************************************************
390+  51A1              ; function to handle CALL ANIMDEF basic extension
391+  51A1              ; ANIMITEMPAT ( BYTE id,
392+  51A1              ;               BYTE size,
393+  51A1              ;               INT[] list )
394+  51A1              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A1              ANIMDEF:
396+  51A1                  ; opening (
397+  51A1 CD 63 5F     	CALL CHKCHAR
398+  51A4 28           	DB '('
399+  51A5              	; get id
400+  51A5 DD 21 1C 52  	LD IX, GETBYT
401+  51A9 CD 59 01     	CALL CALBAS
402+  51AC F5               PUSH AF
403+  51AD                  ; check if out of bounds
404+  51AD 3C               INC A
405+  51AE 4F               LD C,A
406+  51AF 3A BA 4F         LD A,(ANIMDEFNUM)
407+  51B2 B9               CP C
408+  51B3 DA 79 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51B6              	; comma
410+  51B6 CD 63 5F     	CALL CHKCHAR
411+  51B9 2C           	DB ','
412+  51BA              	; get size
413+  51BA DD 21 1C 52  	LD IX, GETBYT
414+  51BE CD 59 01     	CALL CALBAS
415+  51C1 FE 10            CP 16
416+  51C3 D2 7D 5F         JP NC, OVERFLOW
417+  51C6 B7               OR A
418+  51C7 CA 7D 5F         JP Z, OVERFLOW
419+  51CA F5           	PUSH AF
420+  51CB              	; comma
421+  51CB CD 63 5F     	CALL CHKCHAR
422+  51CE 2C           	DB ','
423+  51CF              	; get pointer to a list of animation items in integer array format
424+  51CF                  ; get array pointer
425+  51CF D1               POP DE
426+  51D0 D5               PUSH DE
427+  51D1 3E 02            LD A,2
428+  51D3 06 01            LD B,1
429+  51D5 CD 8A 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51D8 C5               PUSH BC
431+  51D9              	; ending )
432+  51D9 CD 63 5F     	CALL CHKCHAR
433+  51DC 29           	DB ')'
434+  51DD              .ENTRY:
435+  51DD E5               PUSH HL
436+  51DE DD E1            POP IX
437+  51E0 D1               POP DE ; pointer to INT array
438+  51E1 C1               POP BC ; B=item number
439+  51E2 F1               POP AF ; id
440+  51E3 D5               PUSH DE
441+  51E4 CD D2 4F         CALL GETnthANIMDEF
442+  51E7 D1               POP DE
443+  51E8 70               LD (HL),B
444+  51E9              .L1:
445+  51E9 23               INC HL
446+  51EA 1A               LD A,(DE)
447+  51EB 13          > INC DE
447+  51EC 13          > INC DE
448+  51ED 77               LD (HL),A
449+  51EE 10 F9            DJNZ .L1
450+  51F0 DD E5            PUSH IX
451+  51F2 E1               POP HL
452+  51F3 C9               RET
453+  51F4              ; *******************************************************************************************************
454+  51F4
455+  51F4              ; *******************************************************************************************************
456+  51F4              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F4              ; MAXANIMSPRS (BYTE number)
458+  51F4              ; sets new number and moves memory buffers as needed
459+  51F4              MAXANIMSPRS:
460+  51F4              	; opening (
461+  51F4 CD 63 5F     	CALL CHKCHAR
462+  51F7 28           	DB '('
463+  51F8              	; get value
464+  51F8 DD 21 1C 52  	LD IX, GETBYT
465+  51FC CD 59 01     	CALL CALBAS
466+  51FF F5               PUSH AF
467+  5200              	; ending )
468+  5200 CD 63 5F     	CALL CHKCHAR
469+  5203 29           	DB ')'
470+  5204 F1               POP AF
471+  5205
472+  5205              	; save position
473+  5205 E5           	PUSH HL
474+  5206              .ENTRY:
475+  5206 47               LD B,A
476+  5207 3A BD 4F         LD A,(ANIMSPRNUM)
477+  520A 90               SUB B
478+  520B CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  520E FD 21 10 40      LD IY,FREEMEMPTR
480+  5212 FA 1E 52         JP M, .INCREASE
481+  5215                  ; new value is lower than previous one
482+  5215 CD 3D 52         CALL .SIZEDIFF
483+  5218 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  521B C3 22 50         JP MAXANIMITEMS.EXIT
485+  521E              .INCREASE:
486+  521E ED 44            NEG
487+  5220 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5221 CD 3D 52         CALL .SIZEDIFF
489+  5224 CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  5227 AF               XOR A
491+  5228 ED 42            SBC HL,BC ; location of new stuff
492+  522A F1               POP AF
493+  522B 47               LD B,A
494+  522C 11 08 00         LD DE,8
495+  522F E5               PUSH HL
496+  5230 DD E1            POP IX
497+  5232              .L1:
498+  5232 DD 36 06 00      LD (IX+6),0
499+  5236 DD 19            ADD IX,DE
500+  5238 10 F8            DJNZ .L1
501+  523A C3 22 50         JP MAXANIMITEMS.EXIT
502+  523D              .SIZEDIFF:
503+  523D 26 00            LD H,0
504+  523F 6F               LD L,A
505+  5240 CD 52 5E         CALL HLx8
506+  5243 78               LD A,B
507+  5244 32 BD 4F         LD (ANIMSPRNUM),A
508+  5247 44               LD B,H
509+  5248 4D               LD C,L
510+  5249 C9               RET ; BC=size difference in bytes
511+  524A              ; *******************************************************************************************************
512+  524A
513+  524A              ; *******************************************************************************************************
514+  524A              ; function to handle CALL ANIMSPRITE basic extension
515+  524A              ; ANIMSPRITE ( BYTE id,
516+  524A              ;              BYTE sprite_number,
517+  524A              ;              BYTE animation_definition_id,
518+  524A              ;              BYTE cyclic_flag )
519+  524A              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524A              ANIMSPRITE:
521+  524A                  ; opening (
522+  524A CD 63 5F     	CALL CHKCHAR
523+  524D 28           	DB '('
524+  524E              	; get sprite animation id
525+  524E DD 21 1C 52  	LD IX, GETBYT
526+  5252 CD 59 01     	CALL CALBAS
527+  5255 F5               PUSH AF
528+  5256 3C               INC A
529+  5257 4F               LD C,A
530+  5258 3A BD 4F         LD A,(ANIMSPRNUM)
531+  525B B9               CP C
532+  525C DA 79 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  525F              	; comma
534+  525F CD 63 5F     	CALL CHKCHAR
535+  5262 2C           	DB ','
536+  5263              	; get sprite number
537+  5263 DD 21 1C 52  	LD IX, GETBYT
538+  5267 CD 59 01     	CALL CALBAS
539+  526A F5               PUSH AF
540+  526B                  ; check if out of bounds
541+  526B FE 20            CP 32
542+  526D D2 79 5F         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5270              	; comma
544+  5270 CD 63 5F     	CALL CHKCHAR
545+  5273 2C           	DB ','
546+  5274              	; get animation definition id
547+  5274 DD 21 1C 52  	LD IX, GETBYT
548+  5278 CD 59 01     	CALL CALBAS
549+  527B F5               PUSH AF
550+  527C 3C               INC A
551+  527D 4F               LD C,A
552+  527E 3A BA 4F         LD A,(ANIMDEFNUM)
553+  5281 B9               CP C
554+  5282 DA 79 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  5285              	; comma
556+  5285 CD 63 5F     	CALL CHKCHAR
557+  5288 2C           	DB ','
558+  5289              	; get cyclic flag
559+  5289 DD 21 1C 52  	LD IX, GETBYT
560+  528D CD 59 01         CALL CALBAS
561+  5290 F5           	PUSH AF
562+  5291              	; ending )
563+  5291 CD 63 5F     	CALL CHKCHAR
564+  5294 29           	DB ')'
565+  5295              .ENTRY:
566+  5295 E5               PUSH HL
567+  5296 DD E1            POP IX
568+  5298 D9               EXX
569+  5299 D1               POP DE ; cyclic
570+  529A C1               POP BC ; animation definition id
571+  529B E1               POP HL ; sprite number
572+  529C D9               EXX
573+  529D F1               POP AF ; sprite animation id
574+  529E CD DE 4F         CALL GETnthSPRANIM
575+  52A1 E5               PUSH HL
576+  52A2 FD E1            POP IY
577+  52A4 D9               EXX
578+  52A5 FD 74 00         LD (IY),H
579+  52A8 FD 70 04         LD (IY+4),B
580+  52AB FD 72 05         LD (IY+5),D
581+  52AE                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
582+  52AE                  ; following will do preparation for ANIMSTEP situation
583+  52AE                  ; current item set to above limit and timer to 1
584+  52AE                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
585+  52AE FD 36 03 FF      LD (IY+3),255
586+  52B2 FD 36 01 01      LD (IY+1),1
587+  52B6 FD 36 02 00      LD (IY+2),0
588+  52BA DD E5            PUSH IX
589+  52BC E1               POP HL
590+  52BD C9               RET
591+  52BE              ; *******************************************************************************************************
592+  52BE
593+  52BE              ; *******************************************************************************************************
594+  52BE              ; function to handle CALL ANIMSTEP basic extension
595+  52BE              ; two forms
596+  52BE              ; ANIMSTEP ( BYTE id )
597+  52BE              ; or
598+  52BE              ; ANIMSTEP ( BYTE item_number,
599+  52BE              ;            INT[] sprite_animations )
600+  52BE              ; sets active flag to 1
601+  52BE              ANIMSTEP:
602+  52BE 11 3B 53         LD DE,ANIMSTARTSTOP_COMMON.STEP
603+  52C1 18 08            JR ANIMSTARTSTOP_COMMON
604+  52C3              ; *******************************************************************************************************
605+  52C3              ; *******************************************************************************************************
606+  52C3              ; function to handle CALL ANIMSTART basic extension
607+  52C3              ; two forms
608+  52C3              ; ANIMSTART ( BYTE id )
609+  52C3              ; or
610+  52C3              ; ANIMSTART ( BYTE item_number,
611+  52C3              ;             INT[] sprite_animations )
612+  52C3              ; sets active flag to 1
613+  52C3              ANIMSTART:
614+  52C3 11 29 53         LD DE,ANIMSTARTSTOP_COMMON.START
615+  52C6 18 03            JR ANIMSTARTSTOP_COMMON
616+  52C8              ; *******************************************************************************************************
617+  52C8              ; *******************************************************************************************************
618+  52C8              ; function to handle CALL ANIMSTOP basic extension
619+  52C8              ; two forms
620+  52C8              ; ANIMSTOP ( BYTE id )
621+  52C8              ; or
622+  52C8              ; ANIMSTOP ( BYTE item_number,
623+  52C8              ;            INT[] sprite_animations )
624+  52C8              ; sets active flag to 1
625+  52C8              ANIMSTOP:
626+  52C8 11 36 53         LD DE,ANIMSTARTSTOP_COMMON.STOP
627+  52CB              ; *******************************************************************************************************
628+  52CB              ANIMSTARTSTOP_COMMON:
629+  52CB ED 53 27 53      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
630+  52CF                  ; opening (
631+  52CF CD 63 5F     	CALL CHKCHAR
632+  52D2 28           	DB '('
633+  52D3              	; get sprite animation id or array size
634+  52D3 DD 21 1C 52  	LD IX,GETBYT
635+  52D7 CD 59 01     	CALL CALBAS
636+  52DA F5               PUSH AF
637+  52DB                  ; check if comma present
638+  52DB CD 6D 5F         CALL GETPREVCHAR
639+  52DE 23               INC HL
640+  52DF FE 2C            CP ','
641+  52E1 28 0C            JR Z,.L1
642+  52E3 FE 29            CP ')'
643+  52E5 C2 81 5F         JP NZ,SYNTAX_ERROR
644+  52E8                  ; ok so single argument variant
645+  52E8 F1               POP AF
646+  52E9 E5               PUSH HL
647+  52EA CD 15 53         CALL .SETVALUE
648+  52ED E1               POP HL
649+  52EE C9               RET
650+  52EF              .L1:
651+  52EF                  ; get array pointer
652+  52EF D1               POP DE
653+  52F0 D5               PUSH DE
654+  52F1 3E 02            LD A,2
655+  52F3 06 01            LD B,1
656+  52F5 CD 8A 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
657+  52F8 C5               PUSH BC
658+  52F9              	; ending )
659+  52F9 CD 63 5F     	CALL CHKCHAR
660+  52FC 29           	DB ')'
661+  52FD D1               POP DE ; array pointer
662+  52FE C1               POP BC ; number of items
663+  52FF 78               LD A,B
664+  5300 B7               OR A
665+  5301 CA 79 5F         JP Z,SUBSCRIPT_OUT_OF_RANGE
666+  5304 E5               PUSH HL
667+  5305 F3               DI
668+  5306              .L2:
669+  5306 C5               PUSH BC
670+  5307 1A               LD A,(DE)
671+  5308 13          > INC DE
671+  5309 13          > INC DE
672+  530A D5               PUSH DE
673+  530B CD 15 53         CALL .SETVALUE
674+  530E D1               POP DE
675+  530F C1               POP BC
676+  5310 10 F4            DJNZ .L2
677+  5312 FB               EI
678+  5313 E1               POP HL
679+  5314 C9               RET
680+  5315
681+  5315              .SETVALUE:
682+  5315 47               LD B,A
683+  5316 3C               INC A
684+  5317 4F               LD C,A
685+  5318 3A BD 4F         LD A,(ANIMSPRNUM)
686+  531B B9               CP C
687+  531C DA 79 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
688+  531F 78               LD A,B
689+  5320 CD DE 4F         CALL GETnthSPRANIM
690+  5323 E5               PUSH HL
691+  5324 DD E1            POP IX
692+  5326              .FN:
693+  5326 C3 00 00         JP 0
694+  5329              .START:
695+  5329 DD 36 06 01      LD (IX+6),1 ; active flag
696+  532D DD 36 03 00      LD (IX+3),0 ; current item
697+  5331 06 00            LD B,0 ; setup timer
698+  5333 C3 BA 53         JP SETUP_ANIM_STEP
699+  5336              .STOP:
700+  5336 DD 36 06 00      LD (IX+6),0 ; active flag
701+  533A C9               RET
702+  533B              .STEP:
703+  533B 06 00            LD B,0
704+  533D C3 5E 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
705+  5340              ; *******************************************************************************************************
706+  5340
707+  5340              ; *******************************************************************************************************
708+  5340              ; function processes animations during vblank period
709+  5340              PROCESS_ANIMATIONS:
710+  5340 3A BD 4F         LD A,(ANIMSPRNUM)
711+  5343 B7               OR A
712+  5344 C8               RET Z; no animations defined
713+  5345 47               LD B,A
714+  5346 DD 2A BE 4F      LD IX,(ANIMSPRPTR)
715+  534A              .L1:
716+  534A C5               PUSH BC
717+  534B 06 00            LD B,0 ; normal mode, change on timer expiry only
718+  534D CD 59 53         CALL PROCESS_SINGLE_ANIMATION
719+  5350 11 08 00         LD DE,8
720+  5353 DD 19            ADD IX,DE
721+  5355 C1               POP BC
722+  5356 10 F2            DJNZ .L1
723+  5358 C9               RET
724+  5359              ; *******************************************************************************************************
725+  5359
726+  5359              ; *******************************************************************************************************
727+  5359              ; processes single sprite animation
728+  5359              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
729+  5359              ; on timer expiry goes to next animation item
730+  5359              ; input IX=sprite animation pointer
731+  5359              ; input B=1 force mode, activate animation action regardless of expired timer
732+  5359              PROCESS_SINGLE_ANIMATION:
733+  5359 DD 7E 06         LD A,(IX+6); active
734+  535C B7               OR A
735+  535D C8               RET Z ; inactive animation
736+  535E              .INACTIVE_TOO:
737+  535E DD 6E 01         LD L,(IX+1)
738+  5361 DD 66 02         LD H,(IX+2) ; HL=end time
739+  5364 2B               DEC HL
740+  5365 DD 75 01         LD (IX+1),L
741+  5368 DD 74 02         LD (IX+2),H
742+  536B 7D               LD A,L
743+  536C B4               OR H
744+  536D 28 06            JR Z,.STEP
745+  536F 05               DEC B
746+  5370 04               INC B
747+  5371 C8               RET Z ; not forced mode, return
748+  5372 C3 BA 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
749+  5375              .STEP:
750+  5375 06 00            LD B,0; setup timer
751+  5377 DD 34 03         INC (IX+3) ; current animation item
752+  537A C3 BA 53         JP SETUP_ANIM_STEP
753+  537D              ; *******************************************************************************************************
754+  537D
755+  537D              ; *******************************************************************************************************
756+  537D              ; function will setup sprite animation after current item change
757+  537D              ; input A=current animation definition
758+  537D              ; input IX=pointer to sprite animation
759+  537D              ; input B=1 skip timer setup
760+  537D              ; output IY=pointer to animation item
761+  537D              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
762+  537D              ; basically sets new end time for current animation
763+  537D              INIT_CURRENT_ANIMATION:
764+  537D CD D2 4F         CALL GETnthANIMDEF
765+  5380 DD 7E 03         LD A,(IX+3) ; current animation item
766+  5383 BE               CP (HL) ; number of animation items in the animation definition
767+  5384 38 0A            JR C,.L3 ; last item not reached
768+  5386                  ; last item reached
769+  5386 DD 7E 05         LD A,(IX+5) ; cyclic flag
770+  5389 B7               OR A
771+  538A 28 2C            JR Z,.ERROR ; non-cyclic animation
772+  538C                  ; cyclic animation, restart
773+  538C DD 36 03 00      LD (IX+3),0; current item
774+  5390              .L3:
775+  5390                  ; HL = animation definition
776+  5390 23               INC HL ; skip animation definition size field
777+  5391 16 00            LD D,0
778+  5393 DD 5E 03         LD E,(IX+3); current item
779+  5396 19               ADD HL,DE
780+  5397 4E               LD C,(HL) ; current animation item
781+  5398 0C               INC C
782+  5399 3A B7 4F         LD A,(ANIMITEMNUM)
783+  539C B9               CP C
784+  539D 38 19            JR C,.ERROR ; invalid animation item, stop animation
785+  539F 0D               DEC C
786+  53A0 79               LD A,C
787+  53A1 CD C9 4F         CALL GETnthANIMITEM
788+  53A4 E5               PUSH HL
789+  53A5 FD E1            POP IY ; IY=animation item
790+  53A7 05               DEC B
791+  53A8 28 0C            JR Z,.EXIT
792+  53AA FD 5E 01         LD E,(IY+1)
793+  53AD FD 56 02         LD D,(IY+2) ; duration
794+  53B0 DD 73 01         LD (IX+1),E
795+  53B3 DD 72 02         LD (IX+2),D
796+  53B6              .EXIT:
797+  53B6 AF               XOR A
798+  53B7 C9               RET
799+  53B8              .ERROR:
800+  53B8 37               SCF
801+  53B9 C9               RET
802+  53BA              ; *******************************************************************************************************
803+  53BA
804+  53BA              ; *******************************************************************************************************
805+  53BA              ; function will display currect item and set up expiry time
806+  53BA              ; it will also stop the animation if expired
807+  53BA              ; sets sprite update flag if any changes in sprite data made
808+  53BA              ; input IX=current sprite animation
809+  53BA              ; input B=1 skip timer setup
810+  53BA              SETUP_ANIM_STEP:
811+  53BA DD 4E 04         LD C,(IX+4) ; animation definition ID
812+  53BD 0C               INC C
813+  53BE 3A BA 4F         LD A,(ANIMDEFNUM)
814+  53C1 B9               CP C
815+  53C2 30 05            JR NC,.L2
816+  53C4                  ; given animation item is outside of bounds, deactivate animation
817+  53C4              .STOPANIM:
818+  53C4 DD 36 06 00      LD (IX+6),0
819+  53C8 C9               RET
820+  53C9              .L2:
821+  53C9 0D               DEC C
822+  53CA 79               LD A,C
823+  53CB CD 7D 53         CALL INIT_CURRENT_ANIMATION
824+  53CE 38 F4            JR C, .STOPANIM
825+  53D0 FD 7E 00         LD A,(IY) ; type of animation item
826+  53D3 B7               OR A
827+  53D4 CA 09 54         JP Z,.L4 ; change pattern and/or color
828+  53D7              .PAT:
829+  53D7                  ; change sprite pattern definition
830+  53D7 DD 7E 00         LD A,(IX) ; sprite number
831+  53DA CD 7C 4D         CALL GETnthSPRATTR
832+  53DD 23          > INC HL ; skip y and x
832+  53DE 23          > INC HL
832+  53DF 23          > INC HL
832+  53E0 23          > INC HL
833+  53E1 7E               LD A,(HL); current pattern
834+  53E2 26 00            LD H,0
835+  53E4 6F               LD L,A
836+  53E5 3A E0 F3         LD A,(REG1SAV)
837+  53E8 E6 02            AND 2
838+  53EA 20 07            JR NZ,.L6
839+  53EC                  ; 8x8 sprite
840+  53EC CD 52 5E         CALL HLx8
841+  53EF 06 08            LD B,8
842+  53F1 18 05            JR .L5
843+  53F3              .L6:
844+  53F3 CD 50 5E         CALL HLx32
845+  53F6 06 20            LD B,32
846+  53F8              .L5:
847+  53F8 ED 5B 26 F9      LD DE,(PATBAS)
848+  53FC 19               ADD HL,DE
849+  53FD CD 3D 5E         CALL SETWRT_LOCAL
850+  5400 FD 6E 03         LD L,(IY+3)
851+  5403 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
852+  5406 C3 48 5E         JP BBYTECOPY
853+  5409              .L4:
854+  5409                  ; change pattern and color in sprite attributes table
855+  5409 DD 7E 00         LD A,(IX) ; sprite number
856+  540C CD 7C 4D         CALL GETnthSPRATTR
857+  540F 23          > INC HL ; skip y and x
857+  5410 23          > INC HL
857+  5411 23          > INC HL
857+  5412 23          > INC HL
858+  5413 FD 7E 03         LD A,(IY+3) ; new pattern
859+  5416 77               LD (HL),A
860+  5417 23          > INC HL
860+  5418 23          > INC HL
861+  5419 FD 7E 04         LD A,(IY+4) ; new color
862+  541C 77               LD (HL),A
863+  541D 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
864+  5420 36 01            LD (HL),1
865+  5422 C9               RET
866+  5423              ; *******************************************************************************************************
867+  5423
# file closed: asm\ANIMATION.asm
120   5423               ENDIF
121   5423
122   5423               IF (RAM_CMDS == 1)
123   5423               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  5423              ; *******************************************************************************************************
  2+  5423              ; function to handle CALL MEMCPY basic extension
  3+  5423              ; _MEMCPY ( INT source,
  4+  5423              ;			INT destination,
  5+  5423              ;			INT count,
  6+  5423              ; will put ram in page 0 also, page 1 is already there
  7+  5423              MEMCPY:
  8+  5423              	; opening (
  9+  5423 CD 63 5F     	CALL CHKCHAR
 10+  5426 28           	DB '('
 11+  5427              	; get source address
 12+  5427 DD 21 2F 54  	LD IX, FRMQNT
 13+  542B CD 59 01     	CALL CALBAS
 14+  542E D5           	PUSH DE
 15+  542F              	; comma
 16+  542F CD 63 5F     	CALL CHKCHAR
 17+  5432 2C           	DB ','
 18+  5433              	; get destination address
 19+  5433 DD 21 2F 54  	LD IX, FRMQNT
 20+  5437 CD 59 01     	CALL CALBAS
 21+  543A D5           	PUSH DE
 22+  543B              	; comma
 23+  543B CD 63 5F     	CALL CHKCHAR
 24+  543E 2C           	DB ','
 25+  543F              	; get length
 26+  543F DD 21 2F 54  	LD IX, FRMQNT
 27+  5443 CD 59 01     	CALL CALBAS
 28+  5446 D5           	PUSH DE
 29+  5447              	; ending )
 30+  5447 CD 63 5F     	CALL CHKCHAR
 31+  544A 29           	DB ')'
 32+  544B
 33+  544B              	; save position
 34+  544B E5           	PUSH HL
 35+  544C DD E1        	POP IX
 36+  544E
 37+  544E C1           	POP BC ; count
 38+  544F D1           	POP DE ; destination
 39+  5450 E1           	POP HL ; source
 40+  5451 D9           	EXX
 41+  5452              	; enable page 0
 42+  5452 FD 21 59 54  	LD IY, .RET
 43+  5456 C3 16 5F     	JP ENABLE_PAGE0
 44+  5459              .RET:
 45+  5459 FB           	EI
 46+  545A D9           	EXX
 47+  545B ED B0        	LDIR
 48+  545D D1               POP DE
 49+  545E C1               POP BC
 50+  545F CD 8D 5E         CALL RESTORE_PAGE_INFO
 51+  5462 DD E5        	PUSH IX
 52+  5464 E1           	POP HL
 53+  5465 C9           	RET
 54+  5466              ; *******************************************************************************************************
 55+  5466
 56+  5466              ; *******************************************************************************************************
 57+  5466              ; function to handle CALL FILRAM basic extension
 58+  5466              ; FILRAM ( INT start address,
 59+  5466              ;		   INT count,
 60+  5466              ;		   BYTE value,
 61+  5466              ; will put ram in page 0 also, page 1 is already there
 62+  5466              FILRAM:
 63+  5466              	; opening (
 64+  5466 CD 63 5F     	CALL CHKCHAR
 65+  5469 28           	DB '('
 66+  546A              	; get start address
 67+  546A DD 21 2F 54  	LD IX, FRMQNT
 68+  546E CD 59 01     	CALL CALBAS
 69+  5471 D5           	PUSH DE
 70+  5472              	; comma
 71+  5472 CD 63 5F     	CALL CHKCHAR
 72+  5475 2C           	DB ','
 73+  5476              	; get count
 74+  5476 DD 21 2F 54  	LD IX, FRMQNT
 75+  547A CD 59 01     	CALL CALBAS
 76+  547D D5           	PUSH DE
 77+  547E              	; comma
 78+  547E CD 63 5F     	CALL CHKCHAR
 79+  5481 2C           	DB ','
 80+  5482              	; get value
 81+  5482 DD 21 1C 52  	LD IX, GETBYT
 82+  5486 CD 59 01     	CALL CALBAS
 83+  5489 F5           	PUSH AF
 84+  548A              	; ending )
 85+  548A CD 63 5F     	CALL CHKCHAR
 86+  548D 29           	DB ')'
 87+  548E
 88+  548E              	; save position
 89+  548E E5           	PUSH HL
 90+  548F DD E1        	POP IX
 91+  5491
 92+  5491 D1           	POP DE ; actually AF
 93+  5492 C1           	POP BC ; count
 94+  5493 E1           	POP HL ; start address
 95+  5494 78           	LD A, B
 96+  5495 B7           	OR A
 97+  5496 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  5498 B1           	OR C
 99+  5499 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  549B 79           	LD A, C
101+  549C 3D           	DEC A
102+  549D 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  549F              	; one byte to fill
104+  549F 72           	LD (HL), D
105+  54A0 18 12        	JR .EXIT
106+  54A2              .L1:
107+  54A2 D9           	EXX
108+  54A3              	; enable page 0
109+  54A3 FD 21 AA 54  	LD IY, .RET
110+  54A7 C3 16 5F     	JP ENABLE_PAGE0
111+  54AA              .RET:
112+  54AA FB           	EI
113+  54AB D9           	EXX
114+  54AC CD B8 54     	CALL .FILLVALUE
115+  54AF D1               POP DE
116+  54B0 C1               POP BC
117+  54B1 CD 8D 5E         CALL RESTORE_PAGE_INFO
118+  54B4              .EXIT:
119+  54B4 DD E5        	PUSH IX
120+  54B6 E1           	POP HL
121+  54B7 C9           	RET
122+  54B8
123+  54B8              .FILLVALUE:
124+  54B8 72               LD (HL), D
125+  54B9 54               LD D, H
126+  54BA 5D               LD E, L
127+  54BB 13               INC DE
128+  54BC 0B               DEC BC
129+  54BD ED B0            LDIR
130+  54BF C9               RET
131+  54C0              ; *******************************************************************************************************
132+  54C0
# file closed: asm\MEMORY.asm
124   54C0               ENDIF
125   54C0
126   54C0               IF (SOUND_CMDS == 1)
127   54C0               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  54C0              MUSIC_INIT_STATUS:
  2+  54C0 00            DB 0
  3+  54C1              SFX_INIT_STATUS:
  4+  54C1 00            DB 0
  5+  54C2              SOUND_ENABLED:
  6+  54C2 00            DB 0
  7+  54C3
  8+  54C3              ; *******************************************************************************************************
  9+  54C3              ; function to handle CALL SNDPLYINIT basic extension
 10+  54C3              ; initializes sound player
 11+  54C3              ; _SNDPLYINIT ( INT music_offset,
 12+  54C3              ;				INT sfx_offset, can be -1 if no SFX
 13+  54C3              ; will put ram in page 0 also, page 1 is already there
 14+  54C3              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  54C3              SNDPLYINIT:
 16+  54C3              	; opening (
 17+  54C3 CD 63 5F     	CALL CHKCHAR
 18+  54C6 28           	DB '('
 19+  54C7              	; get music address
 20+  54C7 DD 21 2F 54  	LD IX, FRMQNT
 21+  54CB CD 59 01     	CALL CALBAS
 22+  54CE D5           	PUSH DE
 23+  54CF              	; comma
 24+  54CF CD 63 5F     	CALL CHKCHAR
 25+  54D2 2C           	DB ','
 26+  54D3              	; get sfx address
 27+  54D3 DD 21 2F 54  	LD IX, FRMQNT
 28+  54D7 CD 59 01     	CALL CALBAS
 29+  54DA D5           	PUSH DE
 30+  54DB              	; ending )
 31+  54DB CD 63 5F     	CALL CHKCHAR
 32+  54DE 29           	DB ')'
 33+  54DF
 34+  54DF                  ; save position in BASIC text
 35+  54DF 44           	LD B, H
 36+  54E0 4D           	LD C, L
 37+  54E1
 38+  54E1              	; pop LDIR parameters and store away for later
 39+  54E1 D1           	POP DE ; sfx address
 40+  54E2 E1           	POP HL ; music address
 41+  54E3 C5           	PUSH BC ; basic text location
 42+  54E4 D9           	EXX
 43+  54E5 FD 21 EC 54  	LD IY, .RET
 44+  54E9 C3 16 5F     	JP ENABLE_PAGE0
 45+  54EC              .RET:
 46+  54EC D9           	EXX
 47+  54ED
 48+  54ED D5           	PUSH DE
 49+  54EE AF           	XOR A
 50+  54EF              	; HL = music location
 51+  54EF CD 62 41     	CALL PLY_AKG_INIT
 52+  54F2 3E 01        	LD A, 1
 53+  54F4 32 C0 54     	LD (MUSIC_INIT_STATUS), A
 54+  54F7
 55+  54F7 E1           	POP HL ; SFX
 56+  54F8              	; check if SFX address -1
 57+  54F8 23           	INC HL
 58+  54F9 7D           	LD A, L
 59+  54FA B4           	OR H
 60+  54FB 28 09        	JR Z,.L1
 61+  54FD 2B           	DEC HL
 62+  54FE CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  5501 3E 01        	LD A, 1
 64+  5503 32 C1 54     	LD (SFX_INIT_STATUS), A
 65+  5506              .L1:
 66+  5506 D1               POP DE
 67+  5507 C1               POP BC
 68+  5508 CD 8D 5E         CALL RESTORE_PAGE_INFO
 69+  550B
 70+  550B E1           	POP HL
 71+  550C C9           	RET
 72+  550D              ; *******************************************************************************************************
 73+  550D
 74+  550D              ; *******************************************************************************************************
 75+  550D              ; function to handle CALL SNDPLYON basic extension
 76+  550D              ; enables sound player
 77+  550D              ; _SNDPLYON
 78+  550D              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  550D              ; if not throws out of data error
 80+  550D              SNDPLYON:
 81+  550D 3A C0 54     	LD A, (MUSIC_INIT_STATUS)
 82+  5510 B7           	OR A
 83+  5511 20 05        	JR NZ, .L1
 84+  5513              	; player not initialized, throw error
 85+  5513 1E 04        	LD E, 04 ; Out of DATA
 86+  5515 C3 83 5F     	JP THROW_ERROR
 87+  5518              .L1:
 88+  5518 32 C2 54     	LD (SOUND_ENABLED), A
 89+  551B              	; disable key click
 90+  551B AF           	XOR A
 91+  551C 32 DB F3     	LD (CLIKSW), A
 92+  551F C9           	RET
 93+  5520              ; *******************************************************************************************************
 94+  5520
 95+  5520              ; *******************************************************************************************************
 96+  5520              ; function to handle CALL SNDPLYOFF basic extension
 97+  5520              ; disables sound player
 98+  5520              ; _SNDPLYOFF
 99+  5520              ; sets SOUND_ENABLED variable to 0
100+  5520              ; calls AKG to stop music and SFX on all channels if initialized
101+  5520              SNDPLYOFF:
102+  5520 3A C2 54     	LD A, (SOUND_ENABLED)
103+  5523 B7           	OR A
104+  5524 C8           	RET Z ; already stopped
105+  5525 AF           	XOR A
106+  5526 32 C2 54     	LD (SOUND_ENABLED), A
107+  5529 E5           	PUSH HL
108+  552A CD 21 42     	CALL PLY_AKG_STOP
109+  552D 3A C1 54     	LD A, (SFX_INIT_STATUS)
110+  5530 B7           	OR A
111+  5531 28 0E        	JR Z, .EXIT ; SFX not in use
112+  5533 AF           	XOR A
113+  5534 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  5537 3E 01        	LD A, 1
115+  5539 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  553C 3E 02        	LD A, 2
117+  553E CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  5541              .EXIT:
119+  5541 E1           	POP HL
120+  5542 C9           	RET
121+  5543              ; *******************************************************************************************************
122+  5543
123+  5543              ; *******************************************************************************************************
124+  5543              ; function to handle CALL SNDSFX basic extension
125+  5543              ; plays a sound effect
126+  5543              ; _SNDSFX ( BYTE sfx_number, >0
127+  5543              ;			BYTE channel, = 0,1 or 2
128+  5543              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  5543              ; will put ram in page 0 also, page 1 is already there
130+  5543              ; if sound off throws illegal function call
131+  5543              ; if sfx not initialized, throws out of data
132+  5543              SNDSFX:
133+  5543              	; opening (
134+  5543 CD 63 5F     	CALL CHKCHAR
135+  5546 28           	DB '('
136+  5547              	; get sfx_number
137+  5547 DD 21 1C 52  	LD IX, GETBYT
138+  554B CD 59 01     	CALL CALBAS
139+  554E D5           	PUSH DE
140+  554F              	; comma
141+  554F CD 63 5F     	CALL CHKCHAR
142+  5552 2C           	DB ','
143+  5553              	; get sfx address
144+  5553 DD 21 1C 52  	LD IX, GETBYT
145+  5557 CD 59 01     	CALL CALBAS
146+  555A D5           	PUSH DE
147+  555B              	; comma
148+  555B CD 63 5F     	CALL CHKCHAR
149+  555E 2C           	DB ','
150+  555F              	; get inverted volume
151+  555F DD 21 1C 52  	LD IX, GETBYT
152+  5563 CD 59 01     	CALL CALBAS
153+  5566 D5           	PUSH DE
154+  5567              	; ending )
155+  5567 CD 63 5F     	CALL CHKCHAR
156+  556A 29           	DB ')'
157+  556B
158+  556B 3A C2 54     	LD A, (SOUND_ENABLED)
159+  556E B7           	OR A
160+  556F 20 05        	JR NZ, .L1
161+  5571              	; sound disabled, throw illegal function call
162+  5571 1E 05        	LD E, 5
163+  5573 C3 83 5F     	JP THROW_ERROR
164+  5576              .L1:
165+  5576 3A C1 54     	LD A, (SFX_INIT_STATUS)
166+  5579 B7           	OR A
167+  557A 20 05        	JR NZ, .L2
168+  557C              	; sfx data not initialized, throw out of data
169+  557C 1E 04        	LD E, 4
170+  557E C3 83 5F     	JP THROW_ERROR
171+  5581              .L2:
172+  5581              	; pop  parameters and store away for later
173+  5581 D1           	POP DE ; inverted volume
174+  5582 43           	LD B, E
175+  5583 D1           	POP DE ; channel
176+  5584 4B           	LD C, E
177+  5585 D1           	POP DE
178+  5586 7B           	LD A, E
179+  5587 08           	EX AF, AF'
180+  5588 E5           	PUSH HL ; basic text location
181+  5589 D9           	EXX
182+  558A FD 21 91 55  	LD IY, .RET
183+  558E C3 16 5F     	JP ENABLE_PAGE0
184+  5591              .RET:
185+  5591 D9           	EXX
186+  5592 08           	EX AF, AF'
187+  5593 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  5596
189+  5596 D1               POP DE
190+  5597 C1               POP BC
191+  5598 CD 8D 5E         CALL RESTORE_PAGE_INFO
192+  559B
193+  559B E1           	POP HL
194+  559C C9           	RET
195+  559D              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
128   559D               ENDIF
129   559D
130   559D               IF (VRAM_CMDS == 1)
131   559D               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  559D              ; *******************************************************************************************************
  2+  559D              ; function to handle CALL FILVRM basic extension
  3+  559D              ; FILVRM ( INT offset,
  4+  559D              ;		   INT count,
  5+  559D              ;		   BYTE value,
  6+  559D              ;		   BYTE wait_vsync) >0 = true
  7+  559D              ; wait_vsync will issue HALT before copying
  8+  559D              FILVRM:
  9+  559D              	; opening (
 10+  559D CD 63 5F     	CALL CHKCHAR
 11+  55A0 28           	DB '('
 12+  55A1              	; get offset address
 13+  55A1 DD 21 2F 54  	LD IX, FRMQNT
 14+  55A5 CD 59 01     	CALL CALBAS
 15+  55A8 D5           	PUSH DE
 16+  55A9              	; comma
 17+  55A9 CD 63 5F     	CALL CHKCHAR
 18+  55AC 2C           	DB ','
 19+  55AD              	; get count
 20+  55AD DD 21 2F 54  	LD IX, FRMQNT
 21+  55B1 CD 59 01     	CALL CALBAS
 22+  55B4 D5           	PUSH DE
 23+  55B5              	; comma
 24+  55B5 CD 63 5F     	CALL CHKCHAR
 25+  55B8 2C           	DB ','
 26+  55B9              	; get value
 27+  55B9 DD 21 1C 52  	LD IX, GETBYT
 28+  55BD CD 59 01     	CALL CALBAS
 29+  55C0 F5           	PUSH AF
 30+  55C1              	; comma
 31+  55C1 CD 63 5F     	CALL CHKCHAR
 32+  55C4 2C           	DB ','
 33+  55C5              	; get vsync wait
 34+  55C5 DD 21 1C 52  	LD IX, GETBYT
 35+  55C9 CD 59 01     	CALL CALBAS
 36+  55CC F5           	PUSH AF
 37+  55CD              	; ending )
 38+  55CD CD 63 5F     	CALL CHKCHAR
 39+  55D0 29           	DB ')'
 40+  55D1
 41+  55D1 FB               EI
 42+  55D2              	; save position
 43+  55D2 E5           	PUSH HL
 44+  55D3 DD E1        	POP IX
 45+  55D5
 46+  55D5              	; syntax ok
 47+  55D5              	; wait for vsync if needed
 48+  55D5 F1           	POP AF
 49+  55D6 B7           	OR A
 50+  55D7 28 01        	JR Z, .L1
 51+  55D9 76           	HALT
 52+  55DA
 53+  55DA              .L1:
 54+  55DA 3E 01        	LD A,1
 55+  55DC 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  55DF F1               POP AF ; value
 57+  55E0 C1               POP BC ; count
 58+  55E1 E1               POP HL ; offset
 59+  55E2 CD 56 00         CALL BIOS_FILVRM
 60+  55E5 AF           	XOR A
 61+  55E6 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  55E9
 63+  55E9              .L3:
 64+  55E9 DD E5        	PUSH IX
 65+  55EB E1           	POP HL
 66+  55EC C9           	RET
 67+  55ED              ; *******************************************************************************************************
 68+  55ED
 69+  55ED              ; *******************************************************************************************************
 70+  55ED              ; function to handle CALL MEMVRM basic extension
 71+  55ED              ; copies from RAM to VRAM
 72+  55ED              ; _MEMVRM ( INT source,
 73+  55ED              ;			INT destination,
 74+  55ED              ;			INT count,
 75+  55ED              ;			BYTE wait_vsync) >0 = true
 76+  55ED              ; will put ram in page 0 also, page 1 is already there
 77+  55ED              ; wait_vsync will issue HALT before copying
 78+  55ED              MEMVRM:
 79+  55ED              	; opening (
 80+  55ED CD 63 5F     	CALL CHKCHAR
 81+  55F0 28           	DB '('
 82+  55F1              	; get source address
 83+  55F1 DD 21 2F 54  	LD IX, FRMQNT
 84+  55F5 CD 59 01     	CALL CALBAS
 85+  55F8 D5           	PUSH DE
 86+  55F9              	; comma
 87+  55F9 CD 63 5F     	CALL CHKCHAR
 88+  55FC 2C           	DB ','
 89+  55FD              	; get destination address
 90+  55FD DD 21 2F 54  	LD IX, FRMQNT
 91+  5601 CD 59 01     	CALL CALBAS
 92+  5604 D5           	PUSH DE
 93+  5605              	; comma
 94+  5605 CD 63 5F     	CALL CHKCHAR
 95+  5608 2C           	DB ','
 96+  5609              	; get length
 97+  5609 DD 21 2F 54  	LD IX, FRMQNT
 98+  560D CD 59 01     	CALL CALBAS
 99+  5610 D5           	PUSH DE
100+  5611              	; comma
101+  5611 CD 63 5F     	CALL CHKCHAR
102+  5614 2C           	DB ','
103+  5615              	; get vsync wait
104+  5615 DD 21 1C 52  	LD IX, GETBYT
105+  5619 CD 59 01     	CALL CALBAS
106+  561C F5           	PUSH AF
107+  561D              	; ending )
108+  561D CD 63 5F     	CALL CHKCHAR
109+  5620 29           	DB ')'
110+  5621
111+  5621                  ; save position in BASIC text
112+  5621 E5           	PUSH HL
113+  5622 DD E1        	POP IX
114+  5624
115+  5624 F1           	POP AF ; wait vsync
116+  5625 B7           	OR A
117+  5626 28 03        	JR Z, .L1
118+  5628 FB               EI
119+  5629 76           	HALT
120+  562A F3           	DI
121+  562B              .L1:
122+  562B              	; pop LDIR parameters and store away for later
123+  562B C1           	POP BC ; count
124+  562C D1           	POP DE ; vram destination
125+  562D E1           	POP HL ; ram source
126+  562E D9           	EXX
127+  562F FD 21 36 56   	LD IY, .RET
128+  5633 C3 16 5F     	JP ENABLE_PAGE0
129+  5636              .RET:
130+  5636 FB           	EI
131+  5637 D9           	EXX
132+  5638 3E 01        	LD A,1
133+  563A 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  563D CD 4D 56     	CALL .LDIRVM
135+  5640 AF           	XOR A
136+  5641 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  5644 D1               POP DE
138+  5645 C1               POP BC
139+  5646 CD 8D 5E         CALL RESTORE_PAGE_INFO
140+  5649 DD E5        	PUSH IX
141+  564B E1           	POP HL
142+  564C C9           	RET
143+  564D
144+  564D              .LDIRVM:
145+  564D EB           	EX DE, HL
146+  564E F3           	DI
147+  564F CD 3D 5E     	CALL SETWRT_LOCAL
148+  5652 FB           	EI
149+  5653 EB           	EX DE, HL
150+  5654 78           	LD A, B
151+  5655 B7           	OR A
152+  5656 28 0D        	JR Z, .L3
153+  5658 C5           	PUSH BC
154+  5659 0E 98        	LD C, #98
155+  565B              .L2:
156+  565B 50           	LD D, B
157+  565C 06 00        	LD B, 0
158+  565E CD 4A 5E     	CALL BBYTECOPY_NO_C
159+  5661 42           	LD B, D
160+  5662 10 F7        	DJNZ .L2
161+  5664 C1           	POP BC
162+  5665              .L3:
163+  5665 79           	LD A, C
164+  5666 B7           	OR A
165+  5667 C8           	RET Z
166+  5668 41           	LD B, C
167+  5669 C3 48 5E     	JP BBYTECOPY
168+  566C              ; *******************************************************************************************************
169+  566C
170+  566C              ; *******************************************************************************************************
171+  566C              ; function to handle CALL VRMMEM basic extension
172+  566C              ; copies from RAM to VRAM
173+  566C              ; _VRMMEM ( INT source,
174+  566C              ;			INT destination,
175+  566C              ;			INT count
176+  566C              ; will put ram in page 0 also, page 1 is already there
177+  566C              VRMMEM:
178+  566C              	; opening (
179+  566C CD 63 5F     	CALL CHKCHAR
180+  566F 28           	DB '('
181+  5670              	; get source address
182+  5670 DD 21 2F 54  	LD IX, FRMQNT
183+  5674 CD 59 01     	CALL CALBAS
184+  5677 D5           	PUSH DE
185+  5678              	; comma
186+  5678 CD 63 5F     	CALL CHKCHAR
187+  567B 2C           	DB ','
188+  567C              	; get destination address
189+  567C DD 21 2F 54  	LD IX, FRMQNT
190+  5680 CD 59 01     	CALL CALBAS
191+  5683 D5           	PUSH DE
192+  5684              	; comma
193+  5684 CD 63 5F     	CALL CHKCHAR
194+  5687 2C           	DB ','
195+  5688              	; get length
196+  5688 DD 21 2F 54  	LD IX, FRMQNT
197+  568C CD 59 01     	CALL CALBAS
198+  568F D5           	PUSH DE
199+  5690              	; ending )
200+  5690 CD 63 5F     	CALL CHKCHAR
201+  5693 29           	DB ')'
202+  5694
203+  5694                  ; save position in BASIC text
204+  5694 E5           	PUSH HL
205+  5695 DD E1        	POP IX
206+  5697
207+  5697 C1           	POP BC ; count
208+  5698 D1           	POP DE ; destination
209+  5699 E1           	POP HL ; source
210+  569A D9           	EXX
211+  569B FD 21 A2 56  	LD IY, .RET
212+  569F C3 16 5F     	JP ENABLE_PAGE0
213+  56A2              .RET:
214+  56A2 FB           	EI
215+  56A3 D9           	EXX
216+  56A4 3E 01        	LD A,1
217+  56A6 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  56A9 CD B9 56     	CALL .LDIRMV
219+  56AC AF           	XOR A
220+  56AD 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  56B0 D1               POP DE
222+  56B1 C1               POP BC
223+  56B2 CD 8D 5E         CALL RESTORE_PAGE_INFO
224+  56B5 DD E5        	PUSH IX
225+  56B7 E1           	POP HL
226+  56B8 C9           	RET
227+  56B9
228+  56B9              .LDIRMV:
229+  56B9              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  56B9 7D           	LD	A, L
231+  56BA F3           	DI
232+  56BB D3 99        	OUT	(099H), A
233+  56BD 7C           	LD	A, H
234+  56BE E6 3F        	AND	03FH
235+  56C0 D3 99        	OUT	(099H), A
236+  56C2 FB           	EI
237+  56C3              	;EX (SP), HL
238+  56C3              	;EX (SP), HL
239+  56C3              	;NOP
240+  56C3              	;NOP
241+  56C3              .L4:
242+  56C3 DB 98            IN A, (#98)
243+  56C5 12           	LD (DE), A
244+  56C6 13               INC DE
245+  56C7 0B               DEC BC
246+  56C8 79               LD A, C
247+  56C9 B0               OR B
248+  56CA 20 F7            JR NZ, .L4
249+  56CC C9               RET
250+  56CD              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
132   56CD               ENDIF
133   56CD
134   56CD               IF (GENCAL_CMD == 1)
135   56CD               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  56CD              ; *******************************************************************************************************
  2+  56CD              ; function to handle CALL GENCAL basic extension
  3+  56CD              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  56CD              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  56CD              ; output values of registers will also be stored at reg_list_ptr
  6+  56CD              GENCAL_VAR_SP:
  7+  56CD 00 00            DW 0
  8+  56CF              GENCAL_VAR_SP2:
  9+  56CF 00 00            DW 0
 10+  56D1              GENCAL:
 11+  56D1              	; opening (
 12+  56D1 CD 63 5F     	CALL CHKCHAR
 13+  56D4 28           	DB '('
 14+  56D5              	; get function address
 15+  56D5 DD 21 2F 54  	LD IX, FRMQNT
 16+  56D9 CD 59 01     	CALL CALBAS
 17+  56DC D5           	PUSH DE
 18+  56DD              	; comma
 19+  56DD CD 63 5F     	CALL CHKCHAR
 20+  56E0 2C           	DB ','
 21+  56E1              	; get pointer to register list
 22+  56E1 3E 02            LD A,2
 23+  56E3 06 01            LD B,1
 24+  56E5 11 00 05         LD DE,#0500
 25+  56E8 CD 8A 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  56EB C5           	PUSH BC
 27+  56EC              	; ending )
 28+  56EC CD 63 5F     	CALL CHKCHAR
 29+  56EF 29           	DB ')'
 30+  56F0
 31+  56F0              	; save BASIC token position
 32+  56F0 E5           	PUSH HL
 33+  56F1 D9               EXX
 34+  56F2 E1           	POP HL ; HL'=next basic token
 35+  56F3 D9               EXX
 36+  56F4
 37+  56F4 E1               POP HL ; get pointer to register values
 38+  56F5 F3           	DI
 39+  56F6 ED 73 CD 56      LD (GENCAL_VAR_SP), SP
 40+  56FA F9               LD SP, HL
 41+  56FB F1               POP AF
 42+  56FC C1               POP BC
 43+  56FD D1               POP DE
 44+  56FE E1               POP HL
 45+  56FF DD E1            POP IX
 46+  5701 FD E1            POP IY
 47+  5703 D9               EXX
 48+  5704 ED 73 CF 56      LD (GENCAL_VAR_SP2), SP
 49+  5708 ED 7B CD 56      LD SP, (GENCAL_VAR_SP)
 50+  570C FB               EI
 51+  570D D1               POP DE ; get function to call
 52+  570E E5               PUSH HL
 53+  570F CD 2A 57         CALL .EXXDECALL
 54+  5712 F3               DI
 55+  5713 ED 73 CD 56      LD (GENCAL_VAR_SP), SP
 56+  5717 ED 7B CF 56      LD SP, (GENCAL_VAR_SP2)
 57+  571B FD E5            PUSH IY
 58+  571D DD E5            PUSH IX
 59+  571F E5               PUSH HL
 60+  5720 D5               PUSH DE
 61+  5721 C5               PUSH BC
 62+  5722 F5               PUSH AF
 63+  5723 ED 7B CD 56      LD SP, (GENCAL_VAR_SP)
 64+  5727 FB               EI
 65+  5728 E1               POP HL
 66+  5729 C9           	RET
 67+  572A
 68+  572A              .EXXDECALL:
 69+  572A D5               PUSH DE
 70+  572B D9               EXX
 71+  572C C9               RET
 72+  572D              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
136   572D               ENDIF
137   572D
138   572D               IF (BOX_CMDS == 1)
139   572D               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  572D              ; *******************************************************************************************************
  2+  572D              ; generic function to implement rectangle data copy
  3+  572D              ; should be modified to call appropriate function for memory or vram
  4+  572D              ; input IX=pointer to following structure
  5+  572D              ; +00 source data pointer
  6+  572D              ; +02 num bytes in a row
  7+  572D              ; +04 number of rows
  8+  572D              ; +06 source add-to value till next row
  9+  572D              ; +08 destination address
 10+  572D              ; +10 destination add-to value till next row
 11+  572D              ; modifies AF, BC, DE, HL
 12+  572D              RECTANGLE_COPY:
 13+  572D DD 6E 00     	LD L, (IX+0)
 14+  5730 DD 66 01     	LD H, (IX+1) ; source address
 15+  5733 DD 5E 08     	LD E, (IX+8)
 16+  5736 DD 56 09     	LD D, (IX+9) ; destination
 17+  5739 DD 46 04     	LD B, (IX+4) ; row number
 18+  573C              .L1:
 19+  573C C5           	PUSH BC
 20+  573D E5           		PUSH HL
 21+  573E D5           			PUSH DE
 22+  573F DD 4E 02     				LD C, (IX+2)
 23+  5742 DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  5745              .CALL1:
 25+  5745 CD 00 00     				CALL 0 ; set destination address from DE
 26+  5748              .CALL2:
 27+  5748 CD 00 00     				CALL 0 ; copy data fn
 28+  574B E1           			POP HL
 29+  574C DD 4E 0A     			LD C, (IX+10)
 30+  574F DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  5752 09           			ADD HL, BC
 32+  5753 EB           			EX DE, HL
 33+  5754 E1           		POP HL
 34+  5755 DD 4E 06     		LD C, (IX+6)
 35+  5758 DD 46 07     		LD B, (IX+7) ; src add-to
 36+  575B 09           		ADD HL, BC
 37+  575C C1           	POP BC
 38+  575D 10 DD        	DJNZ .L1
 39+  575F C9           	RET
 40+  5760              ; *******************************************************************************************************
 41+  5760
 42+  5760              ; *******************************************************************************************************
 43+  5760              ; function to handle CALL BOXMEMCPY basic extension
 44+  5760              ; copies data with window like boundaries within ram
 45+  5760              ; BOXMEMCPY ( INT source data pointer,
 46+  5760              ;			  INT source number of bytes in a row,
 47+  5760              ;			  INT number of rows,
 48+  5760              ;			  INT source add-to value till next row,
 49+  5760              ; 			  INT destination pointer,
 50+  5760              ;			  INT destination add-to value till next row )
 51+  5760              ; request_data_ptr described in RECTANGLE_COPY
 52+  5760              ; will put ram in page 0 also, page 1 is already there
 53+  5760              BOXMEMCPY:
 54+  5760 11 6A 57     	LD DE,BOXMEMCPY.RET
 55+  5763 ED 53 DE 57  	LD (BOXCOMMON.ADDR+2), DE
 56+  5767 C3 7D 57     	JP BOXCOMMON
 57+  576A              .RET:
 58+  576A FB           	EI
 59+  576B              	; set RAM functions to call
 60+  576B 21 00 00     	LD HL, 0
 61+  576E 22 45 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 62+  5771 22 47 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 63+  5774 21 ED B0     	LD HL, #B0ED ; LDIR
 64+  5777 22 49 57     	LD (RECTANGLE_COPY.CALL1+4), HL
 65+  577A C3 E3 57     	JP BOXCOMMON.CALL
 66+  577D              ; *******************************************************************************************************
 67+  577D
 68+  577D              ; *******************************************************************************************************
 69+  577D              ; common parts of BOX commands
 70+  577D              BOXCOMMON:
 71+  577D              	; opening (
 72+  577D CD 63 5F     	CALL CHKCHAR
 73+  5780 28           	DB '('
 74+  5781              	; get source data pointer
 75+  5781 DD 21 2F 54  	LD IX, FRMQNT
 76+  5785 CD 59 01     	CALL CALBAS
 77+  5788 ED 53 AC 5C  	LD (BLIT_STRUCT+0), DE
 78+  578C              	; comma
 79+  578C CD 63 5F     	CALL CHKCHAR
 80+  578F 2C           	DB ','
 81+  5790              	; source number of bytes in a row
 82+  5790 DD 21 2F 54  	LD IX, FRMQNT
 83+  5794 CD 59 01     	CALL CALBAS
 84+  5797 ED 53 AE 5C  	LD (BLIT_STRUCT+2), DE
 85+  579B              	; comma
 86+  579B CD 63 5F     	CALL CHKCHAR
 87+  579E 2C           	DB ','
 88+  579F              	; number of rows
 89+  579F DD 21 2F 54  	LD IX, FRMQNT
 90+  57A3 CD 59 01     	CALL CALBAS
 91+  57A6 ED 53 B0 5C  	LD (BLIT_STRUCT+4), DE
 92+  57AA              	; comma
 93+  57AA CD 63 5F     	CALL CHKCHAR
 94+  57AD 2C           	DB ','
 95+  57AE              	; source add-to value till next row
 96+  57AE DD 21 2F 54  	LD IX, FRMQNT
 97+  57B2 CD 59 01     	CALL CALBAS
 98+  57B5 ED 53 B2 5C  	LD (BLIT_STRUCT+6), DE
 99+  57B9              	; comma
100+  57B9 CD 63 5F     	CALL CHKCHAR
101+  57BC 2C           	DB ','
102+  57BD              	; destination pointer
103+  57BD DD 21 2F 54  	LD IX, FRMQNT
104+  57C1 CD 59 01     	CALL CALBAS
105+  57C4 ED 53 B4 5C  	LD (BLIT_STRUCT+8), DE
106+  57C8              	; comma
107+  57C8 CD 63 5F     	CALL CHKCHAR
108+  57CB 2C           	DB ','
109+  57CC              	; destination add-to value till next row
110+  57CC DD 21 2F 54  	LD IX, FRMQNT
111+  57D0 CD 59 01     	CALL CALBAS
112+  57D3 ED 53 B6 5C  	LD (BLIT_STRUCT+10), DE
113+  57D7              	; ending )
114+  57D7 CD 63 5F     	CALL CHKCHAR
115+  57DA 29           	DB ')'
116+  57DB
117+  57DB E5           	PUSH HL ; save position in BASIC buffer
118+  57DC              .ADDR:
119+  57DC FD 21 00 00  	LD IY, 0
120+  57E0 C3 16 5F     	JP ENABLE_PAGE0
121+  57E3              .CALL:
122+  57E3 DD 21 AC 5C  	LD IX,BLIT_STRUCT
123+  57E7 CD 2D 57     	CALL RECTANGLE_COPY
124+  57EA AF           	XOR A
125+  57EB 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
126+  57EE
127+  57EE D1               POP DE
128+  57EF C1               POP BC
129+  57F0 CD 8D 5E         CALL RESTORE_PAGE_INFO
130+  57F3
131+  57F3 E1           	POP HL
132+  57F4 C9           	RET
133+  57F5              ; *******************************************************************************************************
134+  57F5
135+  57F5              ; *******************************************************************************************************
136+  57F5              ; function to handle CALL BOXMEMVRM basic extension
137+  57F5              ; copies data with window like boundaries from ram to Vram
138+  57F5              ; BOXMEMVRM ( INT source data pointer,
139+  57F5              ;			  INT source number of bytes in a row,
140+  57F5              ;			  INT number of rows,
141+  57F5              ;			  INT source add-to value till next row,
142+  57F5              ; 			  INT destination pointer,
143+  57F5              ;			  INT destination add-to value till next row )
144+  57F5              ; request_data_ptr described in RECTANGLE_COPY
145+  57F5              ; will put ram in page 0 also, page 1 is already there
146+  57F5              BOXMEMVRM:
147+  57F5 11 FF 57     	LD DE,BOXMEMVRM.RET
148+  57F8 ED 53 DE 57  	LD (BOXCOMMON.ADDR+2), DE
149+  57FC C3 7D 57     	JP BOXCOMMON
150+  57FF              .RET:
151+  57FF FB           	EI
152+  5800              	; set RAM functions to call
153+  5800 21 1A 58     	LD HL, .SETDEST
154+  5803 22 46 57     	LD (RECTANGLE_COPY.CALL1+1), HL
155+  5806 21 22 58     	LD HL, .COPYDATA
156+  5809 22 49 57     	LD (RECTANGLE_COPY.CALL2+1), HL
157+  580C 3E CD        	LD A, #CD ; CALL
158+  580E 32 45 57     	LD (RECTANGLE_COPY.CALL1), A
159+  5811 32 48 57     	LD (RECTANGLE_COPY.CALL2), A
160+  5814              	;LD A,1
161+  5814 32 BD 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
162+  5817 C3 E3 57     	JP BOXCOMMON.CALL
163+  581A              .SETDEST:
164+  581A EB           	EX DE, HL
165+  581B F3           	DI
166+  581C CD 3D 5E     	CALL SETWRT_LOCAL
167+  581F FB           	EI
168+  5820 EB           	EX DE, HL
169+  5821 C9           	RET
170+  5822              .COPYDATA:
171+  5822 41           	LD B, C
172+  5823 C3 48 5E     	JP BBYTECOPY
173+  5826              ; *******************************************************************************************************
# file closed: asm\BOX.asm
140   5826               ENDIF
141   5826
142   5826               IF (BLIT_CMDS == 1)
143   5826               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  5826              ; *******************************************************************************************************
  2+  5826              ; function rotates mask and data of several characters and applies to background data
  3+  5826              ; this handles x-shift from 0 to 4
  4+  5826              ; contains self-modifying code that is set-up from external function
  5+  5826              ; input HL=pointer to mask data
  6+  5826              ; input HL'=pointer to character data
  7+  5826              ; input DE=output buffer containing background data
  8+  5826              ; input BC=DE+8
  9+  5826              ; input A=number of characters to process
 10+  5826              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  5826              SHIFT04:
 12+  5826 08           	EX AF, AF'
 13+  5827 7E           	LD A, (HL) ; get mask
 14+  5828 D9           	EXX
 15+  5829 57           	LD D, A
 16+  582A 1E FF        	LD E, #FF
 17+  582C 37           	SCF
 18+  582D              .M1:
 19+  582D 18 FE        	JR .M1 ; this is self-modifying part
 20+  582F CB 1A        	RR D
 21+  5831 CB 1B        	RR E
 22+  5833 CB 1A        	RR D
 23+  5835 CB 1B        	RR E
 24+  5837 CB 1A        	RR D
 25+  5839 CB 1B        	RR E
 26+  583B CB 1A        	RR D
 27+  583D CB 1B        	RR E
 28+  583F
 29+  583F 46           	LD B, (HL) ; get data
 30+  5840 0E 00        	LD C, 0
 31+  5842              .M2:
 32+  5842 18 FE        	JR .M2 ; also self-modifying part
 33+  5844 CB 38        	SRL B
 34+  5846 CB 19        	RR C
 35+  5848 CB 38        	SRL B
 36+  584A CB 19        	RR C
 37+  584C CB 38        	SRL B
 38+  584E CB 19        	RR C
 39+  5850 CB 38        	SRL B
 40+  5852 CB 19        	RR C
 41+  5854
 42+  5854 D9           	EXX
 43+  5855 1A           	LD A, (DE) ; background
 44+  5856 D9           	EXX
 45+  5857 A2           	AND D
 46+  5858 B0           	OR B
 47+  5859 D9           	EXX
 48+  585A 12           	LD (DE), A
 49+  585B
 50+  585B 0A           	LD A, (BC)
 51+  585C D9           	EXX
 52+  585D A3           	AND E
 53+  585E B1           	OR C
 54+  585F 23           	INC HL
 55+  5860 D9           	EXX
 56+  5861 02           	LD (BC), A
 57+  5862
 58+  5862 23           	INC HL
 59+  5863 13           	INC DE
 60+  5864 03           	INC BC
 61+  5865
 62+  5865 08           	EX AF, AF'
 63+  5866 3D           	DEC A
 64+  5867 C2 26 58     	JP NZ, SHIFT04
 65+  586A C9           	RET
 66+  586B              ; *******************************************************************************************************
 67+  586B
 68+  586B              ; *******************************************************************************************************
 69+  586B              ; function rotates mask and data of several characters and applies to background data
 70+  586B              ; this handles x-shift from 5 to 8
 71+  586B              ; contains self-modifying code that is set-up from external function
 72+  586B              ; input HL=pointer to mask data
 73+  586B              ; input HL'=pointer to character data
 74+  586B              ; input DE=output buffer containing background data
 75+  586B              ; input BC=DE+8
 76+  586B              ; input A=number of characters to process
 77+  586B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  586B              SHIFT58:
 79+  586B 08           	EX AF, AF'
 80+  586C 7E           	LD A, (HL) ; get mask
 81+  586D D9           	EXX
 82+  586E 57           	LD D, A
 83+  586F 1E FF        	LD E, #FF
 84+  5871 37           	SCF
 85+  5872              .M1:
 86+  5872 18 FE        	JR .M1 ; this is self-modifying part
 87+  5874 CB 12        	RL D
 88+  5876 CB 13        	RL E
 89+  5878 CB 12        	RL D
 90+  587A CB 13        	RL E
 91+  587C CB 12        	RL D
 92+  587E CB 13        	RL E
 93+  5880
 94+  5880 46           	LD B, (HL)
 95+  5881 0E 00        	LD C, 0
 96+  5883              .M2:
 97+  5883 18 FE        	JR .M2 ; also self-modifying part
 98+  5885 CB 20        	SLA B
 99+  5887 CB 11        	RL C
100+  5889 CB 20        	SLA B
101+  588B CB 11        	RL C
102+  588D CB 20        	SLA B
103+  588F CB 11        	RL C
104+  5891
105+  5891 D9           	EXX
106+  5892 1A           	LD A, (DE) ; background
107+  5893 D9           	EXX
108+  5894 A3           	AND E
109+  5895 B1           	OR C
110+  5896 D9           	EXX
111+  5897 12           	LD (DE), A
112+  5898
113+  5898 0A           	LD A, (BC)
114+  5899 D9           	EXX
115+  589A A2           	AND D
116+  589B B0           	OR B
117+  589C 23           	INC HL
118+  589D D9           	EXX
119+  589E 02           	LD (BC), A
120+  589F
121+  589F 23           	INC HL
122+  58A0 13           	INC DE
123+  58A1 03           	INC BC
124+  58A2
125+  58A2 08           	EX AF, AF'
126+  58A3 3D           	DEC A
127+  58A4 C2 6B 58     	JP NZ, SHIFT58
128+  58A7 C9           	RET
129+  58A8              ; *******************************************************************************************************
130+  58A8
131+  58A8              ; *******************************************************************************************************
132+  58A8              ; routine that shifts one row of characters
133+  58A8              ; contains self-modifying code that is set-up from external function
134+  58A8              ; input HL=pointer to mask data
135+  58A8              ; input HL'=pointer to character data
136+  58A8              ; input DE=output buffer containing background data
137+  58A8              ; input A=number of characters to process
138+  58A8              ; input IX=pointer to structure describing input data
139+  58A8              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  58A8              SHIFT_ROW:
141+  58A8 F5           	PUSH AF
142+  58A9 ED 53 A8 5C  		LD (BLIT_TMP1), DE
143+  58AD E5           		PUSH HL
144+  58AE CD F1 58     			CALL .ADDYSHIFT
145+  58B1 E1           		POP HL
146+  58B2 ED 53 AA 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  58B6              .L1:
148+  58B6 3E 08        		LD A, 8
149+  58B8 DD 96 02     		SUB (IX+2) ; y shift
150+  58BB              .CALL1:
151+  58BB CD 00 00     		CALL 0
152+  58BE DD 7E 02     		LD A, (IX+2); y shift
153+  58C1 B7           		OR A
154+  58C2 28 26        		JR Z, .DONE
155+  58C4 ED 5B A8 5C  		LD DE, (BLIT_TMP1)
156+  58C8 E5           		PUSH HL
157+  58C9 CD FF 58     			CALL .DETONEXTROW
158+  58CC E1           		POP HL
159+  58CD              .CALL2:
160+  58CD CD 00 00     		CALL 0
161+  58D0 ED 5B A8 5C  		LD DE, (BLIT_TMP1)
162+  58D4 E5           		PUSH HL
163+  58D5 CD F9 58     			CALL .ADD8
164+  58D8 E1           		POP HL
165+  58D9 ED 53 A8 5C  		LD (BLIT_TMP1), DE
166+  58DD ED 5B AA 5C  		LD DE, (BLIT_TMP2)
167+  58E1 E5           		PUSH HL
168+  58E2 CD F9 58     			CALL .ADD8
169+  58E5 E1           		POP HL
170+  58E6 ED 53 AA 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  58EA              .DONE:
172+  58EA F1           	POP AF
173+  58EB 3D           	DEC A
174+  58EC C8           	RET Z
175+  58ED F5           	PUSH AF
176+  58EE C3 B6 58     	JP .L1
177+  58F1              .ADDYSHIFT:
178+  58F1 EB           	EX DE, HL
179+  58F2 16 00        	LD D, 0
180+  58F4 DD 5E 02     	LD E, (IX+2); y shift
181+  58F7 18 0C        	JR .MOVDEBC
182+  58F9              .ADD8:
183+  58F9 21 08 00     	LD HL, 8
184+  58FC C3 05 59     	JP .MOVDEBC
185+  58FF              .DETONEXTROW:
186+  58FF DD 6E 06     	LD L, (IX+6)
187+  5902 DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5905              .MOVDEBC:
189+  5905 19           	ADD HL, DE
190+  5906 54           	LD D, H
191+  5907 5D           	LD E, L
192+  5908 01 08 00     	LD BC, 8
193+  590B 09           	ADD HL, BC
194+  590C 44           	LD B, H
195+  590D 4D           	LD C, L
196+  590E C9           	RET
197+  590F              ; *******************************************************************************************************
198+  590F
199+  590F              ; *******************************************************************************************************
200+  590F              ; function rotates mask and character data and applies it to background
201+  590F              ; input IX=pointer to structure describing input data
202+  590F              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  590F              ; +2  DW vertical shift count 0-7 (low byte used)
204+  590F              ; +4  DW background data start;
205+  590F              ; +6  DW background add to value to next row of background data
206+  590F              ; +8  DW mask data start;
207+  590F              ; +10  DW character data start;
208+  590F              ; +12 DW character&mask add to value to next row of data
209+  590F              ; +14 DW columns (low byte used)
210+  590F              ; +16 DW rows (low byte used)
211+  590F              SHIFT_MERGE_CHARACTER:
212+  590F DD 7E 00     	LD A, (IX) ; shift
213+  5912 FE 05        	CP 5
214+  5914 38 25        	JR C, .RIGHT
215+  5916              	; shifts 5-7, use rotate towards left 1-3
216+  5916 21 6B 58     	LD HL, SHIFT58
217+  5919 22 BC 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  591C 22 CE 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  591F D6 05        	SUB 5
220+  5921 28 0D        	JR Z, .L1
221+  5923 87           	ADD A, A
222+  5924 87           	ADD A, A
223+  5925 67           	LD H, A
224+  5926 2E 18        	LD L, #18 ; JR opcode
225+  5928 22 72 58     	LD (SHIFT58.M1), HL
226+  592B 22 83 58     	LD (SHIFT58.M2), HL
227+  592E 18 32        	JR .DO
228+  5930              .L1:
229+  5930 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  5933 22 72 58     	LD (SHIFT58.M1), HL
231+  5936 22 83 58     	LD (SHIFT58.M2), HL
232+  5939 18 27        	JR .DO
233+  593B              .RIGHT:
234+  593B              	; shifts 0-4, rotate towards right
235+  593B 21 26 58     	LD HL, SHIFT04
236+  593E 22 BC 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  5941 22 CE 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  5944 FE 04        	CP 4
239+  5946 28 11        	JR Z, .R1
240+  5948 D6 04        	SUB 4
241+  594A ED 44        	NEG
242+  594C 87           	ADD A, A
243+  594D 87           	ADD A, A
244+  594E 67           	LD H, A
245+  594F 2E 18        	LD L, #18 ; JR opcode
246+  5951 22 2D 58     	LD (SHIFT04.M1), HL
247+  5954 22 42 58     	LD (SHIFT04.M2), HL
248+  5957 18 09        	JR .DO
249+  5959              .R1:
250+  5959 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  595C 22 2D 58     	LD (SHIFT04.M1), HL
252+  595F 22 42 58     	LD (SHIFT04.M2), HL
253+  5962              .DO:
254+  5962 DD 46 10     	LD B, (IX+16) ; rows
255+  5965 DD 6E 08     	LD L, (IX+8)
256+  5968 DD 66 09     	LD H, (IX+9) ; mask data
257+  596B DD 5E 04     	LD E, (IX+4)
258+  596E DD 56 05     	LD D, (IX+5) ; background data
259+  5971 D9           	EXX
260+  5972 DD 6E 0A     	LD L, (IX+10)
261+  5975 DD 66 0B     	LD H, (IX+11) ; character data
262+  5978 D9           	EXX
263+  5979              .LOOP:
264+  5979 C5           	PUSH BC
265+  597A E5           		PUSH HL
266+  597B D5           			PUSH DE
267+  597C D9           				EXX
268+  597D E5           				PUSH HL
269+  597E D9           					EXX
270+  597F DD 7E 0E     					LD A, (IX+14) ; columns
271+  5982              .CALL:
272+  5982 CD A8 58     					CALL SHIFT_ROW
273+  5985 E1           				POP HL
274+  5986 DD 5E 0C     				LD E, (IX+12)
275+  5989 DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  598C 19           				ADD HL, DE
277+  598D D9           				EXX
278+  598E E1           			POP HL
279+  598F DD 5E 06     			LD E, (IX+6)
280+  5992 DD 56 07     			LD D, (IX+7) ; background to next row
281+  5995 19           			ADD HL, DE
282+  5996 EB           			EX DE, HL
283+  5997 E1           		POP HL
284+  5998 DD 4E 0C     		LD C, (IX+12)
285+  599B DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  599E 09           		ADD HL, BC
287+  599F C1           	POP BC
288+  59A0 10 D7        	DJNZ .LOOP
289+  59A2 C9           	RET
290+  59A3              ; *******************************************************************************************************
291+  59A3
292+  59A3               IFNDEF CMDS_WITH_PARAMETERS
293+  59A3 ~            ; *******************************************************************************************************
294+  59A3 ~            ; function to handle CALL BLIT basic extension
295+  59A3 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  59A3 ~            ; fuses with background data and applies vertical shift too
297+  59A3 ~            ; BLIT ( INT request_data_ptr )
298+  59A3 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  59A3 ~            ; will put ram in page 0 also, page 1 is already there
300+  59A3 ~            BLIT:
301+  59A3 ~            	; opening (
302+  59A3 ~            	CALL CHKCHAR
303+  59A3 ~            	DB '('
304+  59A3 ~            	; get pointer to request struct
305+  59A3 ~            	LD IX, FRMQNT
306+  59A3 ~            	CALL CALBAS
307+  59A3 ~            	PUSH DE
308+  59A3 ~            	; ending )
309+  59A3 ~            	CALL CHKCHAR
310+  59A3 ~            	DB ')'
311+  59A3 ~
312+  59A3 ~            	POP IX ; pointer to request struct
313+  59A3 ~
314+  59A3 ~            	PUSH HL ; save position in BASIC buffer
315+  59A3 ~
316+  59A3 ~            	LD IY, .RET
317+  59A3 ~            	JP ENABLE_PAGE0
318+  59A3 ~            .RET:
319+  59A3 ~            	EI
320+  59A3 ~            	CALL SHIFT_MERGE_CHARACTER
321+  59A3 ~
322+  59A3 ~                POP DE
323+  59A3 ~                POP BC
324+  59A3 ~                CALL RESTORE_PAGE_INFO
325+  59A3 ~
326+  59A3 ~            	POP HL
327+  59A3 ~            	RET
328+  59A3 ~            ; *******************************************************************************************************
329+  59A3               ENDIF
330+  59A3
331+  59A3               IFDEF CMDS_WITH_PARAMETERS
332+  59A3              ; *******************************************************************************************************
333+  59A3              ; function to handle CALL BLIT basic extension
334+  59A3              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  59A3              ; fuses with background data and applies vertical shift too
336+  59A3              ; in form without pointers
337+  59A3              ; BLIT ( INT x,
338+  59A3              ;		 INT y,
339+  59A3              ;		 INT char_data_pointer,
340+  59A3              ;		 INT mask_data_pointer,
341+  59A3              ;		 INT width (in characters),
342+  59A3              ;		 INT height (in characters),
343+  59A3              ;		 INT background_pointer (top left),
344+  59A3              ;		 INT background_width (in characters),
345+  59A3              ;		 INT background_height (in characters))
346+  59A3              ; will put ram in page 0 also, page 1 is already there
347+  59A3              BLIT:
348+  59A3              	; opening (
349+  59A3 CD 63 5F     	CALL CHKCHAR
350+  59A6 28           	DB '('
351+  59A7              	; get x coordinate
352+  59A7 DD 21 2F 54  	LD IX, FRMQNT
353+  59AB CD 59 01     	CALL CALBAS
354+  59AE 7B           	LD A, E
355+  59AF E6 07        	AND 7
356+  59B1 32 AC 5C     	LD (BLIT_STRUCT+0), A
357+  59B4 CD 91 5A     	CALL .DAdiv8
358+  59B7 32 A8 5C     	LD (BLIT_TMP+0),A
359+  59BA              	; comma
360+  59BA CD 63 5F     	CALL CHKCHAR
361+  59BD 2C           	DB ','
362+  59BE              	; get y coordinate
363+  59BE DD 21 2F 54  	LD IX, FRMQNT
364+  59C2 CD 59 01     	CALL CALBAS
365+  59C5 7B           	LD A, E
366+  59C6 E6 07        	AND 7
367+  59C8 32 AE 5C     	LD (BLIT_STRUCT+2), A
368+  59CB CD 91 5A     	CALL .DAdiv8
369+  59CE 32 A9 5C     	LD (BLIT_TMP+1),A
370+  59D1              	; comma
371+  59D1 CD 63 5F     	CALL CHKCHAR
372+  59D4 2C           	DB ','
373+  59D5              	; get char data pointer
374+  59D5 DD 21 2F 54  	LD IX, FRMQNT
375+  59D9 CD 59 01     	CALL CALBAS
376+  59DC ED 53 B6 5C  	LD (BLIT_STRUCT+10), DE
377+  59E0              	; comma
378+  59E0 CD 63 5F     	CALL CHKCHAR
379+  59E3 2C           	DB ','
380+  59E4              	; get mask data pointer
381+  59E4 DD 21 2F 54  	LD IX, FRMQNT
382+  59E8 CD 59 01     	CALL CALBAS
383+  59EB ED 53 B4 5C  	LD (BLIT_STRUCT+8), DE
384+  59EF              	; comma
385+  59EF CD 63 5F     	CALL CHKCHAR
386+  59F2 2C           	DB ','
387+  59F3              	; get width
388+  59F3 DD 21 2F 54  	LD IX, FRMQNT
389+  59F7 CD 59 01     	CALL CALBAS
390+  59FA 7B           	LD A, E
391+  59FB 32 BA 5C     	LD (BLIT_STRUCT+14), A
392+  59FE              	; comma
393+  59FE CD 63 5F     	CALL CHKCHAR
394+  5A01 2C           	DB ','
395+  5A02              	; get height
396+  5A02 DD 21 2F 54  	LD IX, FRMQNT
397+  5A06 CD 59 01     	CALL CALBAS
398+  5A09 7B           	LD A, E
399+  5A0A 32 BC 5C     	LD (BLIT_STRUCT+16), A
400+  5A0D              	; comma
401+  5A0D CD 63 5F     	CALL CHKCHAR
402+  5A10 2C           	DB ','
403+  5A11              	; get background pointer
404+  5A11 DD 21 2F 54  	LD IX, FRMQNT
405+  5A15 CD 59 01     	CALL CALBAS
406+  5A18 ED 53 B0 5C  	LD (BLIT_STRUCT+4), DE
407+  5A1C              	; comma
408+  5A1C CD 63 5F     	CALL CHKCHAR
409+  5A1F 2C           	DB ','
410+  5A20              	; get background width
411+  5A20 DD 21 2F 54  	LD IX, FRMQNT
412+  5A24 CD 59 01     	CALL CALBAS
413+  5A27 7B           	LD A, E
414+  5A28 32 AA 5C     	LD (BLIT_TMP+2), A
415+  5A2B              	; comma
416+  5A2B CD 63 5F     	CALL CHKCHAR
417+  5A2E 2C           	DB ','
418+  5A2F              	; get background height
419+  5A2F DD 21 2F 54  	LD IX, FRMQNT
420+  5A33 CD 59 01     	CALL CALBAS
421+  5A36 7B           	LD A, E
422+  5A37 32 AB 5C     	LD (BLIT_TMP+3), A
423+  5A3A              	; ending )
424+  5A3A CD 63 5F     	CALL CHKCHAR
425+  5A3D 29           	DB ')'
426+  5A3E
427+  5A3E E5           	PUSH HL ; save position in BASIC buffer
428+  5A3F
429+  5A3F              	; calculate char&mask add to value
430+  5A3F 26 00        	LD H, 0
431+  5A41 3A BA 5C     	LD A, (BLIT_STRUCT+14)
432+  5A44 6F           	LD L, A
433+  5A45 CD 52 5E     	CALL HLx8
434+  5A48 22 B8 5C     	LD (BLIT_STRUCT+12), HL
435+  5A4B              	; calculate background add to value
436+  5A4B 26 00        	LD H, 0
437+  5A4D 3A AA 5C     	LD A, (BLIT_TMP+2)
438+  5A50 6F           	LD L, A
439+  5A51 CD 52 5E     	CALL HLx8
440+  5A54 22 B2 5C     	LD (BLIT_STRUCT+6), HL
441+  5A57              	; calculate pointer to background location
442+  5A57 21 00 00     	LD HL, 0
443+  5A5A 3A A9 5C     	LD A,(BLIT_TMP+1)
444+  5A5D B7           	OR A
445+  5A5E 28 08        	JR Z, .L1
446+  5A60 47           	LD B,A
447+  5A61 ED 5B B2 5C  	LD DE,(BLIT_STRUCT+6)
448+  5A65              .L0:
449+  5A65 19           	ADD HL, DE
450+  5A66 10 FD        	DJNZ .L0
451+  5A68              .L1:
452+  5A68 EB           	EX DE,HL
453+  5A69 26 00        	LD H,0
454+  5A6B 3A A8 5C     	LD A,(BLIT_TMP+0)
455+  5A6E 6F           	LD L,A
456+  5A6F CD 52 5E     	CALL HLx8
457+  5A72 19           	ADD HL,DE
458+  5A73 ED 5B B0 5C  	LD DE,(BLIT_STRUCT+4)
459+  5A77 19           	ADD HL,DE
460+  5A78 22 B0 5C     	LD (BLIT_STRUCT+4),HL
461+  5A7B
462+  5A7B FD 21 82 5A  	LD IY, .RET
463+  5A7F C3 16 5F     	JP ENABLE_PAGE0
464+  5A82              .RET:
465+  5A82 FB           	EI
466+  5A83 DD 21 AC 5C  	LD IX, BLIT_STRUCT
467+  5A87 CD 0F 59     	CALL SHIFT_MERGE_CHARACTER
468+  5A8A
469+  5A8A D1               POP DE
470+  5A8B C1               POP BC
471+  5A8C CD 8D 5E         CALL RESTORE_PAGE_INFO
472+  5A8F
473+  5A8F E1           	POP HL
474+  5A90 C9           	RET
475+  5A91              .DAdiv8:
476+  5A91 7B           	LD A,E
477+  5A92 CB 2A        	SRA D
478+  5A94 CB 1F            RR  A
479+  5A96 CB 2A            SRA D
480+  5A98 CB 1F            RR  A
481+  5A9A CB 2A            SRA D
482+  5A9C CB 1F            RR  A
483+  5A9E C9           	RET
484+  5A9F              ; *******************************************************************************************************
485+  5A9F               ENDIF
# file closed: asm\BLIT.asm
144   5A9F               ENDIF
145   5A9F
146   5A9F               IF (TILE_CMDS == 1)
147   5A9F               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5A9F              ; *******************************************************************************************************
  2+  5A9F              ; generic function to implement tiling
  3+  5A9F              ; should be modified to call appropriate function for memory or vram
  4+  5A9F              ; input IX=pointer to following structure
  5+  5A9F              ; +00 tile_data_ptr
  6+  5A9F              ; +02 tile_rows
  7+  5A9F              ; +04 tile_columns
  8+  5A9F              ; +06 destination_address
  9+  5A9F              ; +08 dest_to_next_row_add_to_value
 10+  5A9F              ; +10 num_horizontal_tiles
 11+  5A9F              ; +12 num_vertical_tiles
 12+  5A9F              ; modifies AF, BC, DE, HL
 13+  5A9F              TILE:
 14+  5A9F DD 6E 06     	LD L, (IX+6)
 15+  5AA2 DD 66 07     	LD H, (IX+7) ; destination address
 16+  5AA5 22 A8 5C     	LD (TILETMP1), HL
 17+  5AA8 DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5AAB              .L1:
 19+  5AAB C5           	PUSH BC
 20+  5AAC DD 6E 00     		LD L, (IX+0)
 21+  5AAF DD 66 01     		LD H, (IX+1) ; tile address
 22+  5AB2 22 AA 5C     		LD (TILETMP2), HL
 23+  5AB5 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5AB8              .L2:
 25+  5AB8 C5           		PUSH BC
 26+  5AB9 CD 00 00     .CALL1:		CALL 0
 27+  5ABC DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5ABF              .L3:
 29+  5ABF C5           			PUSH BC
 30+  5AC0 2A AA 5C     				LD HL, (TILETMP2)
 31+  5AC3 DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5AC6              .L4:
 33+  5AC6 C5           				PUSH BC
 34+  5AC7              .CALL2:
 35+  5AC7 CD 00 00     					CALL 0
 36+  5ACA C1           				POP BC
 37+  5ACB 10 F9        				DJNZ .L4
 38+  5ACD C1           			POP BC
 39+  5ACE 10 EF        			DJNZ .L3
 40+  5AD0 22 AA 5C     			LD (TILETMP2), HL
 41+  5AD3 2A A8 5C     			LD HL, (TILETMP1)
 42+  5AD6 DD 5E 08     			LD E, (IX+8)
 43+  5AD9 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5ADC 19           			ADD HL, DE
 45+  5ADD 22 A8 5C     			LD (TILETMP1), HL
 46+  5AE0 C1           		POP BC
 47+  5AE1 10 D5        		DJNZ .L2
 48+  5AE3 C1           	POP BC
 49+  5AE4 10 C5        	DJNZ .L1
 50+  5AE6 C9           	RET
 51+  5AE7              ; *******************************************************************************************************
 52+  5AE7
 53+  5AE7               IFNDEF CMDS_WITH_PARAMETERS
 54+  5AE7 ~            ; *******************************************************************************************************
 55+  5AE7 ~            ; function to handle CALL TILERAM basic extension
 56+  5AE7 ~            ; fills memory with tiles
 57+  5AE7 ~            ; TILERAM ( INT request_data_ptr )
 58+  5AE7 ~            ; request_data_ptr described in TILE
 59+  5AE7 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5AE7 ~            TILERAM:
 61+  5AE7 ~            	; opening (
 62+  5AE7 ~            	CALL CHKCHAR
 63+  5AE7 ~            	DB '('
 64+  5AE7 ~            	; get pointer to request struct
 65+  5AE7 ~            	LD IX, FRMQNT
 66+  5AE7 ~            	CALL CALBAS
 67+  5AE7 ~            	PUSH DE
 68+  5AE7 ~            	; ending )
 69+  5AE7 ~            	CALL CHKCHAR
 70+  5AE7 ~            	DB ')'
 71+  5AE7 ~
 72+  5AE7 ~            	POP IX ; pointer to request struct
 73+  5AE7 ~
 74+  5AE7 ~            	PUSH HL ; save position in BASIC buffer
 75+  5AE7 ~
 76+  5AE7 ~            	LD IY, .RET
 77+  5AE7 ~            	JP ENABLE_PAGE0
 78+  5AE7 ~            .RET:
 79+  5AE7 ~            	EI
 80+  5AE7 ~            	; set RAM functions to call
 81+  5AE7 ~            	LD HL, .TILECOPY
 82+  5AE7 ~            	LD (TILE.CALL2+1), HL
 83+  5AE7 ~            	LD HL, .SETDESTROW
 84+  5AE7 ~            	LD (TILE.CALL1+1), HL
 85+  5AE7 ~            	LD A,1
 86+  5AE7 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5AE7 ~            	CALL TILE
 88+  5AE7 ~            	XOR A
 89+  5AE7 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5AE7 ~
 91+  5AE7 ~                POP DE
 92+  5AE7 ~                POP BC
 93+  5AE7 ~                CALL RESTORE_PAGE_INFO
 94+  5AE7 ~
 95+  5AE7 ~            	POP HL
 96+  5AE7 ~            	RET
 97+  5AE7 ~            .TILECOPY:
 98+  5AE7 ~            	.8 LDI
 99+  5AE7 ~            	RET
100+  5AE7 ~            .SETDESTROW:
101+  5AE7 ~            	LD DE, (TILETMP1)
102+  5AE7 ~            	RET
103+  5AE7 ~            ; *******************************************************************************************************
104+  5AE7               ENDIF
105+  5AE7
106+  5AE7               IFDEF CMDS_WITH_PARAMETERS
107+  5AE7              ; *******************************************************************************************************
108+  5AE7              ; function to handle CALL TILERAM basic extension
109+  5AE7              ; fills memory with tiles
110+  5AE7              ; TILERAM ( INT tile_data_pointer,
111+  5AE7              ;			INT tile_columns,
112+  5AE7              ;			INT tile_rows,
113+  5AE7              ;			INT destination_pointer,
114+  5AE7              ;			INT destination_columns,
115+  5AE7              ;			INT destination_rows,
116+  5AE7              ;			INT destination_begin_column,
117+  5AE7              ;			INT destination_begin_row,
118+  5AE7              ;			INT number_of_tiles_horizontally,
119+  5AE7              ;			INT	number_of_tiles_vertically )
120+  5AE7              ; will put ram in page 0 also, page 1 is already there
121+  5AE7              TILERAM:
122+  5AE7              	; opening (
123+  5AE7 CD 63 5F     	CALL CHKCHAR
124+  5AEA 28           	DB '('
125+  5AEB              	; get tile data pointer coordinate
126+  5AEB DD 21 2F 54  	LD IX, FRMQNT
127+  5AEF CD 59 01     	CALL CALBAS
128+  5AF2 ED 53 AC 5C  	LD (BLIT_STRUCT+0), DE
129+  5AF6              	; comma
130+  5AF6 CD 63 5F     	CALL CHKCHAR
131+  5AF9 2C           	DB ','
132+  5AFA              	; get tile columns
133+  5AFA DD 21 2F 54  	LD IX, FRMQNT
134+  5AFE CD 59 01     	CALL CALBAS
135+  5B01 ED 53 B0 5C  	LD (BLIT_STRUCT+4), DE
136+  5B05              	; comma
137+  5B05 CD 63 5F     	CALL CHKCHAR
138+  5B08 2C           	DB ','
139+  5B09              	; get tile columns
140+  5B09 DD 21 2F 54  	LD IX, FRMQNT
141+  5B0D CD 59 01     	CALL CALBAS
142+  5B10 ED 53 AE 5C  	LD (BLIT_STRUCT+2), DE
143+  5B14              	; comma
144+  5B14 CD 63 5F     	CALL CHKCHAR
145+  5B17 2C           	DB ','
146+  5B18              	; get destintion pointer
147+  5B18 DD 21 2F 54  	LD IX, FRMQNT
148+  5B1C CD 59 01     	CALL CALBAS
149+  5B1F ED 53 B2 5C  	LD (BLIT_STRUCT+6), DE
150+  5B23              	; comma
151+  5B23 CD 63 5F     	CALL CHKCHAR
152+  5B26 2C           	DB ','
153+  5B27              	; get destination columns
154+  5B27 DD 21 2F 54  	LD IX, FRMQNT
155+  5B2B CD 59 01     	CALL CALBAS
156+  5B2E 7B           	LD A, E
157+  5B2F 32 A8 5C     	LD (BLIT_TMP+0), A
158+  5B32              	; comma
159+  5B32 CD 63 5F     	CALL CHKCHAR
160+  5B35 2C           	DB ','
161+  5B36              	; get destination rows
162+  5B36 DD 21 2F 54  	LD IX, FRMQNT
163+  5B3A CD 59 01     	CALL CALBAS
164+  5B3D 7B           	LD A, E
165+  5B3E 32 A9 5C     	LD (BLIT_TMP+1), A
166+  5B41              	; comma
167+  5B41 CD 63 5F     	CALL CHKCHAR
168+  5B44 2C           	DB ','
169+  5B45              	; get destination begin column
170+  5B45 DD 21 2F 54  	LD IX, FRMQNT
171+  5B49 CD 59 01     	CALL CALBAS
172+  5B4C 7B           	LD A, E
173+  5B4D 32 AA 5C     	LD (BLIT_TMP+2), A
174+  5B50              	; comma
175+  5B50 CD 63 5F     	CALL CHKCHAR
176+  5B53 2C           	DB ','
177+  5B54              	; get destination begin row
178+  5B54 DD 21 2F 54  	LD IX, FRMQNT
179+  5B58 CD 59 01     	CALL CALBAS
180+  5B5B 7B           	LD A, E
181+  5B5C 32 AB 5C     	LD (BLIT_TMP+3), A
182+  5B5F              	; comma
183+  5B5F CD 63 5F     	CALL CHKCHAR
184+  5B62 2C           	DB ','
185+  5B63              	; get number of tiles horizontally
186+  5B63 DD 21 2F 54  	LD IX, FRMQNT
187+  5B67 CD 59 01     	CALL CALBAS
188+  5B6A ED 53 B6 5C  	LD (BLIT_STRUCT+10), DE
189+  5B6E              	; comma
190+  5B6E CD 63 5F     	CALL CHKCHAR
191+  5B71 2C           	DB ','
192+  5B72              	; get number of tiles vertically
193+  5B72 DD 21 2F 54  	LD IX, FRMQNT
194+  5B76 CD 59 01     	CALL CALBAS
195+  5B79 ED 53 B8 5C  	LD (BLIT_STRUCT+12), DE
196+  5B7D              	; ending )
197+  5B7D CD 63 5F     	CALL CHKCHAR
198+  5B80 29           	DB ')'
199+  5B81
200+  5B81 E5           	PUSH HL ; save position in BASIC buffer
201+  5B82
202+  5B82              	; calculate destination add to value
203+  5B82 26 00        	LD H, 0
204+  5B84 3A A8 5C     	LD A, (BLIT_TMP+0)
205+  5B87 6F           	LD L, A
206+  5B88 CD 52 5E     	CALL HLx8
207+  5B8B 22 B4 5C     	LD (BLIT_STRUCT+8), HL
208+  5B8E              	; calculate pointer to background location
209+  5B8E 21 00 00     	LD HL, 0
210+  5B91 3A AB 5C     	LD A,(BLIT_TMP+3)
211+  5B94 B7           	OR A
212+  5B95 28 08        	JR Z, .L1
213+  5B97 47           	LD B,A
214+  5B98 ED 5B B4 5C  	LD DE,(BLIT_STRUCT+8)
215+  5B9C              .L0:
216+  5B9C 19           	ADD HL, DE
217+  5B9D 10 FD        	DJNZ .L0
218+  5B9F              .L1:
219+  5B9F EB           	EX DE,HL
220+  5BA0 26 00        	LD H,0
221+  5BA2 3A AA 5C     	LD A,(BLIT_TMP+2)
222+  5BA5 6F           	LD L,A
223+  5BA6 CD 52 5E     	CALL HLx8
224+  5BA9 19           	ADD HL,DE
225+  5BAA ED 5B B2 5C  	LD DE,(BLIT_STRUCT+6)
226+  5BAE 19           	ADD HL,DE
227+  5BAF 22 B2 5C     	LD (BLIT_STRUCT+6),HL
228+  5BB2
229+  5BB2 FD 21 B9 5B  	LD IY, .RET
230+  5BB6 C3 16 5F     	JP ENABLE_PAGE0
231+  5BB9              .RET:
232+  5BB9 FB           	EI
233+  5BBA              	; set RAM functions to call
234+  5BBA 21 D4 5B     	LD HL, .TILECOPY
235+  5BBD 22 C8 5A     	LD (TILE.CALL2+1), HL
236+  5BC0 21 E5 5B     	LD HL, .SETDESTROW
237+  5BC3 22 BA 5A     	LD (TILE.CALL1+1), HL
238+  5BC6 DD 21 AC 5C  	LD IX,BLIT_STRUCT
239+  5BCA CD 9F 5A     	CALL TILE
240+  5BCD
241+  5BCD D1               POP DE
242+  5BCE C1               POP BC
243+  5BCF CD 8D 5E         CALL RESTORE_PAGE_INFO
244+  5BD2
245+  5BD2 E1           	POP HL
246+  5BD3 C9           	RET
247+  5BD4              .TILECOPY:
248+  5BD4 ED A0       > LDI
248+  5BD6 ED A0       > LDI
248+  5BD8 ED A0       > LDI
248+  5BDA ED A0       > LDI
248+  5BDC ED A0       > LDI
248+  5BDE ED A0       > LDI
248+  5BE0 ED A0       > LDI
248+  5BE2 ED A0       > LDI
249+  5BE4 C9           	RET
250+  5BE5              .SETDESTROW:
251+  5BE5 ED 5B A8 5C  	LD DE, (TILETMP1)
252+  5BE9 C9           	RET
253+  5BEA              ; *******************************************************************************************************
254+  5BEA               ENDIF
255+  5BEA
256+  5BEA               IFDEF CMDS_WITH_PARAMETERS
257+  5BEA              ; *******************************************************************************************************
258+  5BEA              ; function to handle CALL TILEVRM basic extension
259+  5BEA              ; fills vram with tiles
260+  5BEA              ; TILEVRM ( INT tile_data_pointer,
261+  5BEA              ;			INT tile_columns,
262+  5BEA              ;			INT tile_rows,
263+  5BEA              ;			INT destination_begin_column,
264+  5BEA              ;			INT destination_begin_row,
265+  5BEA              ;			INT number_of_tiles_horizontally,
266+  5BEA              ;			INT	number_of_tiles_vertically )
267+  5BEA              ; will put ram in page 0 also, page 1 is already there
268+  5BEA              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5BEA              TILEVRM:
270+  5BEA              	; opening (
271+  5BEA CD 63 5F     	CALL CHKCHAR
272+  5BED 28           	DB '('
273+  5BEE              	; get tile data pointer coordinate
274+  5BEE DD 21 2F 54  	LD IX, FRMQNT
275+  5BF2 CD 59 01     	CALL CALBAS
276+  5BF5 ED 53 AC 5C  	LD (BLIT_STRUCT+0), DE
277+  5BF9              	; comma
278+  5BF9 CD 63 5F     	CALL CHKCHAR
279+  5BFC 2C           	DB ','
280+  5BFD              	; get tile columns
281+  5BFD DD 21 2F 54  	LD IX, FRMQNT
282+  5C01 CD 59 01     	CALL CALBAS
283+  5C04 ED 53 B0 5C  	LD (BLIT_STRUCT+4), DE
284+  5C08              	; comma
285+  5C08 CD 63 5F     	CALL CHKCHAR
286+  5C0B 2C           	DB ','
287+  5C0C              	; get tile columns
288+  5C0C DD 21 2F 54  	LD IX, FRMQNT
289+  5C10 CD 59 01     	CALL CALBAS
290+  5C13 ED 53 AE 5C  	LD (BLIT_STRUCT+2), DE
291+  5C17              	; comma
292+  5C17 CD 63 5F     	CALL CHKCHAR
293+  5C1A 2C           	DB ','
294+  5C1B              	; get destination begin column
295+  5C1B DD 21 2F 54  	LD IX, FRMQNT
296+  5C1F CD 59 01     	CALL CALBAS
297+  5C22 7B           	LD A, E
298+  5C23 32 AA 5C     	LD (BLIT_TMP+2), A
299+  5C26              	; comma
300+  5C26 CD 63 5F     	CALL CHKCHAR
301+  5C29 2C           	DB ','
302+  5C2A              	; get destination begin row
303+  5C2A DD 21 2F 54  	LD IX, FRMQNT
304+  5C2E CD 59 01     	CALL CALBAS
305+  5C31 7B           	LD A, E
306+  5C32 32 AB 5C     	LD (BLIT_TMP+3), A
307+  5C35              	; comma
308+  5C35 CD 63 5F     	CALL CHKCHAR
309+  5C38 2C           	DB ','
310+  5C39              	; get number of tiles horizontally
311+  5C39 DD 21 2F 54  	LD IX, FRMQNT
312+  5C3D CD 59 01     	CALL CALBAS
313+  5C40 ED 53 B6 5C  	LD (BLIT_STRUCT+10), DE
314+  5C44              	; comma
315+  5C44 CD 63 5F     	CALL CHKCHAR
316+  5C47 2C           	DB ','
317+  5C48              	; get number of tiles vertically
318+  5C48 DD 21 2F 54  	LD IX, FRMQNT
319+  5C4C CD 59 01     	CALL CALBAS
320+  5C4F ED 53 B8 5C  	LD (BLIT_STRUCT+12), DE
321+  5C53              	; ending )
322+  5C53 CD 63 5F     	CALL CHKCHAR
323+  5C56 29           	DB ')'
324+  5C57
325+  5C57 E5           	PUSH HL ; save position in BASIC buffer
326+  5C58
327+  5C58              	; calculate destination add to value
328+  5C58 21 00 01     	LD HL, 256
329+  5C5B 22 B4 5C     	LD (BLIT_STRUCT+8), HL
330+  5C5E              	; calculate pointer to background location
331+  5C5E 3A AB 5C     	LD A,(BLIT_TMP+3)
332+  5C61 67           	LD H,A
333+  5C62 2E 00        	LD L,0
334+  5C64 EB           	EX DE,HL
335+  5C65 26 00        	LD H,0
336+  5C67 3A AA 5C     	LD A,(BLIT_TMP+2)
337+  5C6A 6F           	LD L,A
338+  5C6B CD 52 5E     	CALL HLx8
339+  5C6E 19           	ADD HL,DE
340+  5C6F ED 5B CB F3  	LD DE,(GRPCGP)
341+  5C73 19           	ADD HL,DE
342+  5C74 22 B2 5C     	LD (BLIT_STRUCT+6),HL
343+  5C77
344+  5C77 FD 21 7E 5C  	LD IY, .RET
345+  5C7B C3 16 5F     	JP ENABLE_PAGE0
346+  5C7E              .RET:
347+  5C7E FB           	EI
348+  5C7F              	; set RAM functions to call
349+  5C7F 21 99 5C     	LD HL, .TILECOPY
350+  5C82 22 C8 5A     	LD (TILE.CALL2+1), HL
351+  5C85 21 9F 5C     	LD HL, .SETDESTROW
352+  5C88 22 BA 5A     	LD (TILE.CALL1+1), HL
353+  5C8B DD 21 AC 5C  	LD IX,BLIT_STRUCT
354+  5C8F CD 9F 5A     	CALL TILE
355+  5C92
356+  5C92 D1               POP DE
357+  5C93 C1               POP BC
358+  5C94 CD 8D 5E         CALL RESTORE_PAGE_INFO
359+  5C97
360+  5C97 E1           	POP HL
361+  5C98 C9           	RET
362+  5C99              .TILECOPY:
363+  5C99 01 98 08     	LD BC, #0898
364+  5C9C C3 4A 5E     	JP BBYTECOPY_NO_C
365+  5C9F              .SETDESTROW:
366+  5C9F 2A A8 5C     	LD HL, (TILETMP1)
367+  5CA2 F3           	DI
368+  5CA3 CD 3D 5E     	CALL SETWRT_LOCAL
369+  5CA6 FB           	EI
370+  5CA7 C9           	RET
371+  5CA8              ; *******************************************************************************************************
372+  5CA8               ENDIF
373+  5CA8
374+  5CA8               IFNDEF CMDS_WITH_PARAMETERS
375+  5CA8 ~            ; *******************************************************************************************************
376+  5CA8 ~            ; function to handle CALL TILEVRM basic extension
377+  5CA8 ~            ; fills vram with tiles
378+  5CA8 ~            ; TILEVRM ( INT request_data_ptr )
379+  5CA8 ~            ; request_data_ptr described in TILE
380+  5CA8 ~            ; will put ram in page 0 also, page 1 is already there
381+  5CA8 ~            TILEVRM:
382+  5CA8 ~            	; opening (
383+  5CA8 ~            	CALL CHKCHAR
384+  5CA8 ~            	DB '('
385+  5CA8 ~            	; get pointer to request struct
386+  5CA8 ~            	LD IX, FRMQNT
387+  5CA8 ~            	CALL CALBAS
388+  5CA8 ~            	PUSH DE
389+  5CA8 ~            	; ending )
390+  5CA8 ~            	CALL CHKCHAR
391+  5CA8 ~            	DB ')'
392+  5CA8 ~
393+  5CA8 ~            	POP IX ; pointer to request struct
394+  5CA8 ~
395+  5CA8 ~            	PUSH HL ; save position in BASIC buffer
396+  5CA8 ~
397+  5CA8 ~            	LD IY, .RET
398+  5CA8 ~            	JP ENABLE_PAGE0
399+  5CA8 ~            .RET:
400+  5CA8 ~            	EI
401+  5CA8 ~            	; set RAM functions to call
402+  5CA8 ~            	LD HL, .TILECOPY
403+  5CA8 ~            	LD (TILE.CALL2+1), HL
404+  5CA8 ~            	LD HL, .SETDESTROW
405+  5CA8 ~            	LD (TILE.CALL1+1), HL
406+  5CA8 ~            	CALL TILE
407+  5CA8 ~
408+  5CA8 ~                POP DE
409+  5CA8 ~                POP BC
410+  5CA8 ~                CALL RESTORE_PAGE_INFO
411+  5CA8 ~
412+  5CA8 ~            	POP HL
413+  5CA8 ~            	RET
414+  5CA8 ~            .TILECOPY:
415+  5CA8 ~            	LD BC, #0898
416+  5CA8 ~            	JP BBYTECOPY_NO_C
417+  5CA8 ~            .SETDESTROW:
418+  5CA8 ~            	LD HL, (TILETMP1)
419+  5CA8 ~            	DI
420+  5CA8 ~            	CALL SETWRT_LOCAL
421+  5CA8 ~            	EI
422+  5CA8 ~            	RET
423+  5CA8 ~            ; *******************************************************************************************************
424+  5CA8               ENDIF
# file closed: asm\TILE.asm
148   5CA8               ENDIF
149   5CA8
150   5CA8              ; temp variables for BLIT, TILE functions
151   5CA8               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS > 0)
152   5CA8              BLIT_TMP:
153   5CA8              TILETMP1:
154   5CA8              BLIT_TMP1:
155   5CA8 00 00         DW 0
156   5CAA              TILETMP2:
157   5CAA              BLIT_TMP2:
158   5CAA 00 00         DW 0
159   5CAC                IFDEF CMDS_WITH_PARAMETERS
160   5CAC              BLIT_STRUCT:
161   5CAC 00 00 00...   DS 17
162   5CB0                ENDIF
163   5CB0               ENDIF
164   5CBD
165   5CBD               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS > 0)
166   5CBD              VRAM_UPDATE_IN_PROGRESS:
167   5CBD 00            DB 0
168   5CBE               ENDIF
169   5CBE
170   5CBE              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
171   5CBE              ; per starting letter, if no commands with this letter, NULL value
172   5CBE              CMDS:
173   5CBE               IF (ANIM_CMDS == 1)
174   5CBE E7 5D        	DW CMDS_A ;
175   5CC0               ELSE
176   5CC0 ~                DW 0 ; A
177   5CC0               ENDIF
178   5CC0               IF (BLIT_CMDS + BOX_CMDS > 0)
179   5CC0 B2 5D            DW CMDS_B ; B
180   5CC2               ELSE
181   5CC2 ~            	DW 0
182   5CC2               ENDIF
183   5CC2 00 00            DW 0 ; C
184   5CC4 00 00            DW 0 ; D
185   5CC6 00 00            DW 0 ; E
186   5CC8               IF (VRAM_CMDS + RAM_CMDS > 0)
187   5CC8 30 5D            DW CMDS_F; F
188   5CCA               ELSE
189   5CCA ~            	DW 0
190   5CCA               ENDIF
191   5CCA               IF (GENCAL_CMD > 0)
192   5CCA 43 5D            DW CMDS_G; G
193   5CCC               ELSE
194   5CCC ~            	DW 0
195   5CCC               ENDIF
196   5CCC 00 00            DW 0 ; H
197   5CCE 00 00            DW 0 ; I
198   5CD0 00 00            DW 0 ; J
199   5CD2 00 00            DW 0 ; K
200   5CD4 00 00            DW 0 ; L
201   5CD6               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
202   5CD6 F2 5C            DW CMDS_M ; M
203   5CD8               ELSE
204   5CD8 ~            	DW 0
205   5CD8               ENDIF
206   5CD8 00 00            DW 0 ; N
207   5CDA 00 00            DW 0 ; O
208   5CDC 00 00            DW 0 ; P
209   5CDE 00 00            DW 0 ; Q
210   5CE0 00 00            DW 0 ; R
211   5CE2               IF (SOUND_CMDS + SPRITE_CMDS > 0)
212   5CE2 57 5D            DW CMDS_S ; S
213   5CE4               ELSE
214   5CE4 ~            	DW 0
215   5CE4               ENDIF
216   5CE4               IF (TILE_CMDS > 0)
217   5CE4 D2 5D            DW CMDS_T ; T
218   5CE6               ELSE
219   5CE6 ~            	DW 0
220   5CE6               ENDIF
221   5CE6 00 00            DW 0 ; U
222   5CE8               IF (VRAM_CMDS > 0)
223   5CE8 4D 5D            DW CMDS_V ; V
224   5CEA               ELSE
225   5CEA ~            	DW 0
226   5CEA               ENDIF
227   5CEA 00 00            DW 0 ; W
228   5CEC 00 00            DW 0 ; X
229   5CEE 00 00            DW 0 ; Y
230   5CF0 00 00            DW 0 ; Z
231   5CF2
232   5CF2              CMDS_M:
233   5CF2               IF (VRAM_CMDS == 1)
234   5CF2 4D 45 4D 56      DB "MEMVRM", 0
234   5CF6 52 4D 00
235   5CF9 ED 55            DW MEMVRM
236   5CFB               ENDIF
237   5CFB               IF (RAM_CMDS == 1)
238   5CFB 4D 45 4D 43  	DB "MEMCPY", 0
238   5CFF 50 59 00
239   5D02 23 54        	DW MEMCPY
240   5D04               ENDIF
241   5D04               IF (ANIM_CMDS == 1)
242   5D04 4D 41 58 41  	DB "MAXANIMITEMS",0
242   5D08 4E 49 4D 49
242   5D0C 54 45 4D 53
242   5D10 00
243   5D11 EA 4F        	DW MAXANIMITEMS
244   5D13 4D 41 58 41  	DB "MAXANIMDEFS",0
244   5D17 4E 49 4D 44
244   5D1B 45 46 53 00
245   5D1F 5F 51        	DW MAXANIMDEFS
246   5D21 4D 41 58 41  	DB "MAXANIMSPRS",0
246   5D25 4E 49 4D 53
246   5D29 50 52 53 00
247   5D2D F4 51        	DW MAXANIMSPRS
248   5D2F               ENDIF
249   5D2F               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
250   5D2F 00           	DB 0
251   5D30               ENDIF
252   5D30              CMDS_F:
253   5D30               IF (VRAM_CMDS == 1)
254   5D30 46 49 4C 56      DB "FILVRM", 0
254   5D34 52 4D 00
255   5D37 9D 55            DW FILVRM
256   5D39               ENDIF
257   5D39               IF (RAM_CMDS == 1)
258   5D39 46 49 4C 52      DB "FILRAM", 0
258   5D3D 41 4D 00
259   5D40 66 54            DW FILRAM
260   5D42               ENDIF
261   5D42               IF (VRAM_CMDS + RAM_CMDS > 0)
262   5D42 00               DB 0
263   5D43               ENDIF
264   5D43              CMDS_G:
265   5D43               IF (GENCAL_CMD == 1)
266   5D43 47 45 4E 43      DB "GENCAL", 0
266   5D47 41 4C 00
267   5D4A D1 56            DW GENCAL
268   5D4C               ENDIF
269   5D4C               IF (GENCAL_CMD > 0)
270   5D4C 00           	DB	0
271   5D4D               ENDIF
272   5D4D              CMDS_V:
273   5D4D               IF (VRAM_CMDS == 1)
274   5D4D 56 52 4D 4D  	DB "VRMMEM", 0
274   5D51 45 4D 00
275   5D54 6C 56        	DW VRMMEM
276   5D56               ENDIF
277   5D56               IF (VRAM_CMDS > 0)
278   5D56 00           	DB 0
279   5D57               ENDIF
280   5D57              CMDS_S:
281   5D57               IF (SPRITE_CMDS == 1)
282   5D57 53 50 52 53  	DB "SPRSET", 0
282   5D5B 45 54 00
283   5D5E 81 4E        	DW SPRSET
284   5D60 53 50 52 47  	DB "SPRGRPMOV", 0
284   5D64 52 50 4D 4F
284   5D68 56 00
285   5D6A 32 4F        	DW SPRGRPMOV
286   5D6C               ENDIF
287   5D6C               IF (SOUND_CMDS == 1)
288   5D6C 53 4E 44 53  	DB "SNDSFX", 0
288   5D70 46 58 00
289   5D73 43 55        	DW SNDSFX
290   5D75 53 4E 44 50  	DB "SNDPLYON", 0
290   5D79 4C 59 4F 4E
290   5D7D 00
291   5D7E 0D 55        	DW SNDPLYON
292   5D80 53 4E 44 50  	DB "SNDPLYOFF", 0
292   5D84 4C 59 4F 46
292   5D88 46 00
293   5D8A 20 55        	DW SNDPLYOFF
294   5D8C 53 4E 44 50  	DB "SNDPLYINI", 0
294   5D90 4C 59 49 4E
294   5D94 49 00
295   5D96 C3 54        	DW SNDPLYINIT
296   5D98               ENDIF
297   5D98               IF (SPRITE_CMDS == 1)
298   5D98 53 50 52 45  	DB "SPRENABLE", 0
298   5D9C 4E 41 42 4C
298   5DA0 45 00
299   5DA2 3C 4E        	DW SPRENABLE
300   5DA4 53 50 52 44  	DB "SPRDISABLE", 0
300   5DA8 49 53 41 42
300   5DAC 4C 45 00
301   5DAF 7C 4E        	DW SPRDISABLE
302   5DB1               ENDIF
303   5DB1               IF (SOUND_CMDS + SPRITE_CMDS > 0)
304   5DB1 00           	DB 0
305   5DB2               ENDIF
306   5DB2              CMDS_B:
307   5DB2               IF (BLIT_CMDS == 1)
308   5DB2 42 4C 49 54  	DB "BLIT", 0
308   5DB6 00
309   5DB7 A3 59        	DW BLIT
310   5DB9               ENDIF
311   5DB9               IF (BOX_CMDS == 1)
312   5DB9 42 4F 58 4D  	DB "BOXMEMCPY", 0
312   5DBD 45 4D 43 50
312   5DC1 59 00
313   5DC3 60 57        	DW BOXMEMCPY
314   5DC5 42 4F 58 4D  	DB "BOXMEMVRM", 0
314   5DC9 45 4D 56 52
314   5DCD 4D 00
315   5DCF F5 57        	DW BOXMEMVRM
316   5DD1               ENDIF
317   5DD1               IF (BLIT_CMDS + BOX_CMDS > 0)
318   5DD1 00           	DB 0
319   5DD2               ENDIF
320   5DD2              CMDS_T:
321   5DD2               IF (TILE_CMDS == 1)
322   5DD2 54 49 4C 45  	DB "TILERAM", 0
322   5DD6 52 41 4D 00
323   5DDA E7 5A        	DW TILERAM
324   5DDC 54 49 4C 45  	DB "TILEVRM", 0
324   5DE0 56 52 4D 00
325   5DE4 EA 5B        	DW TILEVRM
326   5DE6               ENDIF
327   5DE6               IF (TILE_CMDS > 0)
328   5DE6 00           	DB 0
329   5DE7               ENDIF
330   5DE7              CMDS_A:
331   5DE7               IF (ANIM_CMDS == 1)
332   5DE7 41 4E 49 4D      DB "ANIMSTEP",0
332   5DEB 53 54 45 50
332   5DEF 00
333   5DF0 BE 52            DW ANIMSTEP
334   5DF2 41 4E 49 4D  	DB "ANIMSTART",0
334   5DF6 53 54 41 52
334   5DFA 54 00
335   5DFC C3 52        	DW ANIMSTART
336   5DFE 41 4E 49 4D  	DB "ANIMSTOP",0
336   5E02 53 54 4F 50
336   5E06 00
337   5E07 C8 52        	DW ANIMSTOP
338   5E09 41 4E 49 4D  	DB "ANIMITEMPAT",0
338   5E0D 49 54 45 4D
338   5E11 50 41 54 00
339   5E15 AA 50        	DW ANIMITEMPAT
340   5E17 41 4E 49 4D  	DB "ANIMITEMPTR",0
340   5E1B 49 54 45 4D
340   5E1F 50 54 52 00
341   5E23 0B 51        	DW ANIMITEMPTR_CMD
342   5E25 41 4E 49 4D  	DB "ANIMDEF",0
342   5E29 44 45 46 00
343   5E2D A1 51        	DW ANIMDEF
344   5E2F 41 4E 49 4D  	DB "ANIMSPRITE",0
344   5E33 53 50 52 49
344   5E37 54 45 00
345   5E3A 4A 52        	DW ANIMSPRITE
346   5E3C 00           	DB 0
347   5E3D               ENDIF
348   5E3D
349   5E3D               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
350   5E3D              ; ****************************************************************************************************
351   5E3D              ; function sets VRAM address
352   5E3D              ; input HL=address
353   5E3D              ; modifies AF
354   5E3D              SETWRT_LOCAL:
355   5E3D 7D           	LD	A, L
356   5E3E D3 99        	OUT	(099H), A
357   5E40 7C           	LD	A, H
358   5E41 E6 3F        	AND	03FH
359   5E43 F6 40        	OR	040H
360   5E45 D3 99        	OUT	(099H), A
361   5E47 C9           	RET
362   5E48              ; ****************************************************************************************************
363   5E48               ENDIF
364   5E48
365   5E48               IF (VRAM_CMDS + TILE_CMDS > 0)
366   5E48              ; ****************************************************************************************************
367   5E48              ; function copies data from RAM to VRAM
368   5E48              ; input HL=address in RAM
369   5E48              ; input B=count
370   5E48              ; modifies AF, BC, HL
371   5E48              BBYTECOPY:
372   5E48 0E 98        	LD C,#98
373   5E4A              BBYTECOPY_NO_C:
374   5E4A ED A3        	OUTI
375   5E4C C2 4A 5E     	JP	NZ, BBYTECOPY_NO_C
376   5E4F C9           	RET
377   5E50              ; ****************************************************************************************************
378   5E50               ENDIF
379   5E50
380   5E50              ; ****************************************************************************************************
381   5E50              ; function multiplies HL by 32
382   5E50              HLx32:
383   5E50 29           	ADD HL,HL
384   5E51              ; ****************************************************************************************************
385   5E51              ; function multiplies HL by 16
386   5E51              HLx16:
387   5E51 29           	ADD HL,HL
388   5E52              ; ****************************************************************************************************
389   5E52              ; function multiplies HL by 8
390   5E52              HLx8:
391   5E52 29          > ADD HL, HL
391   5E53 29          > ADD HL, HL
391   5E54 29          > ADD HL, HL
392   5E55 C9           	RET
393   5E56              ; ****************************************************************************************************
394   5E56
395   5E56              ; ****************************************************************************************************
396   5E56              ; function gets slot and subslot data for specific page
397   5E56              ; input A=page (0, 1 or 2)
398   5E56              ; output B = 0A8H register value
399   5E56              ; output D = 0 is no subslots, 1 if yes
400   5E56              ; output C = 0A8H value when page 3 slot equals to requested page slot
401   5E56              ; output E = subslot value if present
402   5E56              ; modifies AF, BC, DE, HL
403   5E56              GET_PAGE_INFO:
404   5E56 6F               LD L, A
405   5E57 C6 C1            ADD A, low (EXPTBL)
406   5E59 32 63 5E         LD (GET_PAGE_INFO_L1+1), A
407   5E5C DB A8            IN A, (0A8H)
408   5E5E 47               LD B, A
409   5E5F E6 3F            AND 03FH
410   5E61 4F               LD C, A
411   5E62              GET_PAGE_INFO_L1:
412   5E62 3A C1 FC         LD A, (EXPTBL) ; modified by code above
413   5E65 E6 80            AND 080H
414   5E67 28 1B            JR Z, GET_PAGE_INFO_L2
415   5E69                  ; expanded
416   5E69 2D               DEC L
417   5E6A FA 89 5E         JP M, GET_PAGE_INFO_L3
418   5E6D 2D               DEC L
419   5E6E FA 87 5E         JP M, GET_PAGE_INFO_L4
420   5E71                  ; page 2
421   5E71 07               RLCA
422   5E72 07               RLCA
423   5E73              GET_PAGE_INFO_L5:
424   5E73 E6 C0            AND 0C0H
425   5E75 B1               OR C
426   5E76 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
427   5E78 4F               LD C, A
428   5E79 3A FF FF         LD A, (0FFFFH)
429   5E7C 2F               CPL
430   5E7D 5F               LD E, A
431   5E7E 16 01            LD D, 1
432   5E80 78               LD A, B ; return stack
433   5E81 D3 A8            OUT (0A8H), A
434   5E83 C9               RET
435   5E84              GET_PAGE_INFO_L2:
436   5E84                  ; not expanded
437   5E84 16 00            LD D, 0
438   5E86 C9               RET
439   5E87              GET_PAGE_INFO_L4:
440   5E87                  ; page 1
441   5E87 0F               RRCA
442   5E88 0F               RRCA
443   5E89              GET_PAGE_INFO_L3:
444   5E89                  ; page 0
445   5E89 0F               RRCA
446   5E8A 0F               RRCA
447   5E8B 18 E6            JR GET_PAGE_INFO_L5
448   5E8D              ; ****************************************************************************************************
449   5E8D
450   5E8D              ; ****************************************************************************************************
451   5E8D              ; function returns original slot and subslot info
452   5E8D              ; input B = 0A8H register value
453   5E8D              ; input D = 0 is no subslots, 1 if yes
454   5E8D              ; input C = 0A8H value when page 3 slot equals to requested page slot
455   5E8D              ; input E = subslot value if present
456   5E8D              ; modifies AF, disables interrupts
457   5E8D              RESTORE_PAGE_INFO:
458   5E8D 7A               LD A, D
459   5E8E B7               OR A
460   5E8F 28 08            JR Z, RESTORE_PAGE_INFO_L1
461   5E91 79               LD A, C
462   5E92 F3           	DI
463   5E93 D3 A8            OUT (0A8H), A
464   5E95 7B               LD A, E
465   5E96 32 FF FF         LD (0FFFFH), A
466   5E99              RESTORE_PAGE_INFO_L1:
467   5E99 78               LD A, B
468   5E9A D3 A8            OUT (0A8H), A
469   5E9C C9               RET
470   5E9D              ; ****************************************************************************************************
471   5E9D
472   5E9D              ; *******************************************************************************************************
473   5E9D              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
474   5E9D              ; INPUT:  A = SLOT ID: EXXXSSPP
475   5E9D              ; E = EXPANDED FLAG
476   5E9D              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
477   5E9D              ; PP = PRIMARY SLOT NUMBER
478   5E9D              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
479   5E9D              ; CHANGES: AF, BC, DE
480   5E9D
481   5E9D              LOCAL_ENASLT:
482   5E9D CD BD 5E         CALL L0353
483   5EA0 FA AA 5E         JP M, L0340
484   5EA3 DB A8            IN A, (0A8H)
485   5EA5 A1               AND C
486   5EA6 B0               OR B
487   5EA7 D3 A8            OUT (0A8H), A
488   5EA9 C9               RET
489   5EAA              L0340:
490   5EAA E5               PUSH HL
491   5EAB CD E2 5E         CALL L0378
492   5EAE 4F               LD C, A
493   5EAF 06 00            LD B, 0
494   5EB1 7D               LD A, L
495   5EB2 A4               AND H
496   5EB3 B2               OR D
497   5EB4 21 C5 FC         LD HL, 0FCC5H
498   5EB7 09               ADD HL, BC
499   5EB8 77               LD (HL), A
500   5EB9 E1               POP HL
501   5EBA 79               LD A, C
502   5EBB 18 E0            JR LOCAL_ENASLT
503   5EBD              L0353:
504   5EBD F3               DI
505   5EBE F5               PUSH AF
506   5EBF 7C               LD A, H
507   5EC0 07               RLCA
508   5EC1 07               RLCA
509   5EC2 E6 03            AND 3
510   5EC4 5F               LD E, A
511   5EC5 3E C0            LD A, 0C0H
512   5EC7              L035D:
513   5EC7 07               RLCA
514   5EC8 07               RLCA
515   5EC9 1D               DEC E
516   5ECA F2 C7 5E         JP P, L035D
517   5ECD 5F               LD E, A
518   5ECE 2F               CPL
519   5ECF 4F               LD C, A
520   5ED0 F1               POP AF
521   5ED1 F5               PUSH AF
522   5ED2 E6 03            AND 3
523   5ED4 3C               INC A
524   5ED5 47               LD B, A
525   5ED6 3E AB            LD A, 0ABH
526   5ED8              L036E:
527   5ED8 C6 55            ADD A, 055H
528   5EDA 10 FC            DJNZ L036E
529   5EDC 57               LD D, A
530   5EDD A3               AND E
531   5EDE 47               LD B, A
532   5EDF F1               POP AF
533   5EE0 A7               AND A
534   5EE1 C9               RET
535   5EE2              L0378:
536   5EE2 F5               PUSH AF
537   5EE3 7A               LD A, D
538   5EE4 E6 C0            AND 0C0H
539   5EE6 4F               LD C, A
540   5EE7 F1               POP AF
541   5EE8 F5               PUSH AF
542   5EE9 57               LD D, A
543   5EEA DB A8            IN A, (0A8H)
544   5EEC 47               LD B, A
545   5EED E6 3F            AND 03FH
546   5EEF B1               OR C
547   5EF0 D3 A8            OUT (0A8H), A
548   5EF2 7A               LD A, D
549   5EF3 0F               RRCA
550   5EF4 0F               RRCA
551   5EF5 E6 03            AND 3
552   5EF7 57               LD D, A
553   5EF8 3E AB            LD A, 0ABH
554   5EFA              L0390:
555   5EFA C6 55            ADD A, 055H
556   5EFC 15               DEC D
557   5EFD F2 FA 5E         JP P, L0390
558   5F00 A3               AND E
559   5F01 57               LD D, A
560   5F02 7B               LD A, E
561   5F03 2F               CPL
562   5F04 67               LD H, A
563   5F05 3A FF FF         LD A, (0FFFFH)
564   5F08 2F               CPL
565   5F09 6F               LD L, A
566   5F0A A4               AND H
567   5F0B B2               OR D
568   5F0C 32 FF FF         LD (0FFFFH), A
569   5F0F 78               LD A, B
570   5F10 D3 A8            OUT (0A8H), A
571   5F12 F1               POP AF
572   5F13 E6 03            AND 3
573   5F15 C9               RET
574   5F16              ; *******************************************************************************************************
575   5F16
576   5F16              ; *******************************************************************************************************
577   5F16              ; some common code to activate page 0 and place values needed to restore original page on stack
578   5F16              ; input IY=return address
579   5F16              ENABLE_PAGE0:
580   5F16 AF               XOR A
581   5F17 CD 56 5E         CALL GET_PAGE_INFO
582   5F1A C5               PUSH BC
583   5F1B D5               PUSH DE
584   5F1C 3A 41 F3         LD A, (RAMAD0)
585   5F1F 26 00            LD H, 0
586   5F21 CD 9D 5E         CALL LOCAL_ENASLT
587   5F24 FD E9        	JP (IY)
588   5F26              ; *******************************************************************************************************
589   5F26
590   5F26              ; General BASIC CALL-instruction handler
591   5F26              CALLHAND:
592   5F26 E5           	PUSH HL
593   5F27 21 BE 5C     	LD	HL, CMDS ; pointer table based on starting letter
594   5F2A 3A 89 FD         LD A, (PROCNM)
595   5F2D D6 41            SUB 'A'
596   5F2F 87               ADD A, A
597   5F30 16 00            LD D, 0
598   5F32 5F               LD E, A
599   5F33 19               ADD HL, DE
600   5F34 5E               LD E, (HL)
601   5F35 23               INC HL
602   5F36 56               LD D, (HL)
603   5F37 7A               LD A, D
604   5F38 B3               OR E
605   5F39 28 23            JR Z, .CMDNOTRECOGNIZED
606   5F3B EB               EX DE, HL
607   5F3C              .CHKCMD:
608   5F3C 11 89 FD     	LD	DE, PROCNM
609   5F3F 1A           .LOOP:	LD	A,(DE)
610   5F40 BE           	CP	(HL)
611   5F41 20 11        	JR	NZ,.TONEXTCMD	; Not equal
612   5F43 13           	INC	DE
613   5F44 23           	INC	HL
614   5F45 A7           	AND	A
615   5F46 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
616   5F48 5E           	LD	E,(HL)
617   5F49 23           	INC	HL
618   5F4A 56           	LD	D,(HL)
619   5F4B E1           	POP	HL		; routine address
620   5F4C CD 6D 5F     	CALL	GETPREVCHAR
621   5F4F CD 61 5F     	CALL	.CALLDE		; Call routine
622   5F52 A7           	AND	A
623   5F53 C9           	RET
624   5F54
625   5F54              .TONEXTCMD:
626   5F54 0E FF        	LD	C,0FFH
627   5F56 AF           	XOR	A
628   5F57 ED B1        	CPIR			; Skip to end of instruction name
629   5F59 23           	INC	HL
630   5F5A 23           	INC	HL		; Skip address
631   5F5B BE           	CP	(HL)
632   5F5C 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
633   5F5E              .CMDNOTRECOGNIZED:
634   5F5E E1           	POP	HL
635   5F5F 37               SCF
636   5F60 C9           	RET
637   5F61
638   5F61              .CALLDE:
639   5F61 D5           	PUSH	DE
640   5F62 C9           	RET
641   5F63
642   5F63              ;---------------------------
643   5F63
644   5F63              ;GETSTRPNT:
645   5F63              ; OUT:
646   5F63              ; HL = String Address
647   5F63              ; B  = Lenght
648   5F63              ;        LD      HL,(USR)
649   5F63              ;        LD      B,(HL)
650   5F63              ;        INC     HL
651   5F63              ;        LD      E,(HL)
652   5F63              ;        INC     HL
653   5F63              ;        LD      D,(HL)
654   5F63              ;        EX      DE,HL
655   5F63              ;        RET
656   5F63
657   5F63              ;EVALTXTPARAM:
658   5F63              ;	CALL	CHKCHAR
659   5F63              ;	DEFB	"("             ; Check for (
660   5F63              ;	LD	IX,FRMEVL
661   5F63              ;	CALL	CALBAS		; Evaluate expression
662   5F63              ;       LD      A,(VALTYP)
663   5F63              ;        CP      3               ; Text type?
664   5F63              ;        JP      NZ,TYPE_MISMATCH
665   5F63              ;        PUSH	HL
666   5F63              ;        LD	IX,FRESTR         ; Free the temporary string
667   5F63              ;        CALL	CALBAS
668   5F63              ;        POP	HL
669   5F63              ;	CALL	CHKCHAR
670   5F63              ;	DEFB	")"             ; Check for )
671   5F63              ;        RET
672   5F63
673   5F63
674   5F63              CHKCHAR:
675   5F63 CD 6D 5F     	CALL	GETPREVCHAR	; Get previous basic char
676   5F66 E3           	EX	(SP),HL
677   5F67 BE           	CP	(HL) 	        ; Check if good char
678   5F68 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
679   5F6A 23           	INC	HL
680   5F6B E3           	EX	(SP),HL
681   5F6C 23           	INC	HL		; Get next basic char
682   5F6D
683   5F6D              GETPREVCHAR:
684   5F6D 2B           	DEC	HL
685   5F6E DD 21 66 46  	LD	IX,CHRGTR
686   5F72 C3 59 01     	JP      CALBAS
687   5F75
688   5F75
689   5F75              TYPE_MISMATCH:
690   5F75 1E 0D            LD E, 13 ; Type mismatch
691   5F77 18 0A            JR THROW_ERROR
692   5F79              SUBSCRIPT_OUT_OF_RANGE:
693   5F79 1E 09            LD E,9 ; subscript out of range
694   5F7B 18 06        	JR THROW_ERROR
695   5F7D              OVERFLOW:
696   5F7D 1E 06        	LD E,6
697   5F7F 18 02        	JR THROW_ERROR
698   5F81              SYNTAX_ERROR:
699   5F81 1E 02            LD E, 2 ; Syntax error
700   5F83              THROW_ERROR:
701   5F83 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
702   5F87 C3 59 01     	JP	CALBAS
703   5F8A
704   5F8A              ;---------------------------
705   5F8A
706   5F8A              ; *******************************************************************************************************
707   5F8A              ; helper function to get pointer to BASIC array data
708   5F8A              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
709   5F8A              ; input B=dimensions (1 or 2)
710   5F8A              ; input D=minimal first dimension
711   5F8A              ; input E=minimal second dimension, if applicable
712   5F8A              ; returns BC=pointer to first data element
713   5F8A              ; throws BASIC error if invalid type
714   5F8A              GET_BASIC_ARRAY_DATA_POINTER:
715   5F8A D5           	PUSH DE
716   5F8B C5           	PUSH BC
717   5F8C F5           	PUSH AF
718   5F8D 3E 01            LD A,1
719   5F8F 32 A5 F6         LD (SUBFLG),A ; search for arrays only
720   5F92 DD 21 A4 5E  	LD IX, PTRGET
721   5F96 CD 59 01     	CALL CALBAS
722   5F99 AF               XOR A
723   5F9A 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
724   5F9D 3A 63 F6     	LD A,(VALTYP)
725   5FA0 D1           	POP DE ; required type
726   5FA1 BA           	CP D
727   5FA2 C2 75 5F     	JP NZ,TYPE_MISMATCH
728   5FA5 0A           	LD A,(BC)
729   5FA6 03           	INC BC
730   5FA7 D1           	POP DE ; required number of dimensions
731   5FA8 BA           	CP D
732   5FA9 C2 75 5F     	JP NZ,TYPE_MISMATCH
733   5FAC D1           	POP DE ; required minimal array dimensions
734   5FAD 3D           	DEC A
735   5FAE 28 07        	JR Z,.ONE_DIMENSION
736   5FB0              	; 2-dimension array
737   5FB0 0A           	LD A,(BC)
738   5FB1 03          > INC BC
738   5FB2 03          > INC BC
739   5FB3 BB           	CP E
740   5FB4 DA 79 5F     	JP C,SUBSCRIPT_OUT_OF_RANGE
741   5FB7              .ONE_DIMENSION:
742   5FB7 0A           	LD A,(BC)
743   5FB8 03          > INC BC
743   5FB9 03          > INC BC
744   5FBA BA           	CP D
745   5FBB DA 79 5F     	JP C,SUBSCRIPT_OUT_OF_RANGE
746   5FBE C9           	RET
747   5FBF              ; *******************************************************************************************************
748   5FBF
749   5FBF              EXT_END:
750   5FBF
# file closed: asm\main.asm
