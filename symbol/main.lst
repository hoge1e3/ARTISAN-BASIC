# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              BYTEOPS_CMDS   EQU 0
  14  4000              COLL_CMD       EQU 1
  15  4000
  16  4000               DEFINE CMDS_WITH_PARAMETERS
  17  4000
  18  4000              CHPUT   EQU    #A2
  19  4000              CALBAS  EQU		#159
  20  4000              ERRHAND EQU    #406F
  21  4000              FRMEVL  EQU    #4C64
  22  4000              FRESTR  EQU		#67D0
  23  4000              ; FRMQNT = formula quantificator
  24  4000              ; input HL=pointer to current program expression
  25  4000              ; output HL=next address
  26  4000              ; output DE=integer datum
  27  4000              FRMQNT	EQU		#542F
  28  4000              ; GETBYT = get byte parameter
  29  4000              ; input HL=pointer to current program expression
  30  4000              ; output HL=next address
  31  4000              ; output A=E=byte read
  32  4000              GETBYT		EQU	#521C
  33  4000              CHRGTR  	   EQU   #4666
  34  4000              PTRGET		EQU 	#5EA4
  35  4000              SUBFLG		EQU	#F6A5
  36  4000              SYNCHR		EQU	#558C
  37  4000              VALTYP  	   EQU   #F663
  38  4000              DAC         EQU   #F7F6
  39  4000              USR     	   EQU   #F7F8
  40  4000              PROCNM		EQU	#FD89
  41  4000              BIOS_FILVRM EQU   #0056
  42  4000              CLIKSW		EQU	#F3DB
  43  4000
  44  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  45  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  46  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  47  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  48  4000              EXPTBL	   EQU   #FCC1
  49  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  50  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  51  4000              JIFFY	      EQU   #FC9E
  52  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  53  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  54  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  55  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  56  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  57  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  58  4000
  59  4000              ; BASIC error codes
  60  4000              ;01 NEXT without FOR
  61  4000              ;02 Syntax error
  62  4000              ;03 RETURN without GOSUB
  63  4000              ;04 Out of DATA
  64  4000              ;05 Illegal function call
  65  4000              ;06 Overflow
  66  4000              ;07 Out of memory
  67  4000              ;08 Undefined line number
  68  4000              ;09 Subscript out of range
  69  4000              ;10 Redimensioned array
  70  4000              ;11 Division by zero
  71  4000              ;12 Illegal direct
  72  4000              ;13 Type mismatch
  73  4000              ;14 Out of string space
  74  4000              ;15 String too long
  75  4000              ;16 String formula too complex
  76  4000              ;17 Can't CONTINUE
  77  4000              ;18 Undefined user function
  78  4000              ;19 Device I/O error
  79  4000              ;20 Verify error
  80  4000              ;21 No RESUME
  81  4000              ;22 RESUME without error
  82  4000              ;23 Unprintable error
  83  4000              ;24 Missing operand
  84  4000              ;25 Line buffer overflow
  85  4000              ;50 FIELD overflow
  86  4000              ;51 Internal error
  87  4000              ;52 Bad file number
  88  4000              ;53 File not found
  89  4000              ;54 File already open
  90  4000              ;55 Input past end
  91  4000              ;56 Bad file name
  92  4000              ;57 Direct statement in file
  93  4000              ;58 Sequential I/O only
  94  4000              ;59 File not OPEN
  95  4000
  96  4000
  97  4000               ; simulate cartridge with BASIC extension
  98  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  98  4004 56 65 00 00
  98  4008 00 00 00 00
  98  400C 00 00 00 00
  99  4010
 100  4010              ; this location #4010 stores last location used by basic extension
 101  4010              ; free memory after that point
 102  4010              FREEMEMPTR:
 103  4010 F6 65         DW EXT_END
 104  4012
 105  4012              ; this location #4012 stores extension version in DAA format
 106  4012              ; first byte is major version and second minor
 107  4012              VERSION:
 108  4012 00 70         DB #00, #70
 109  4014
 110  4014              ; binary included AKG player compiled at #4014
 111  4014               IF (SOUND_CMDS == 1)
 112  4014              	INCBIN "bin/AKG.bin"
 113  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 114  4CF0               ENDIF
 115  4CF0
 116  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 20 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A 32 59     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13                  ;LD HL,(JIFFY)
  43+ 4D13                  ;INC HL
  44+ 4D13                  ;LD (JIFFY),HL
  45+ 4D13
  46+ 4D13 FD E1            POP IY
  47+ 4D15 DD E1            POP IX
  48+ 4D17 E1               POP HL
  49+ 4D18 D1               POP DE
  50+ 4D19 C1               POP BC
  51+ 4D1A F1               POP AF
  52+ 4D1B 08               EX AF, AF'
  53+ 4D1C D9               EXX
  54+ 4D1D E1               POP HL
  55+ 4D1E D1               POP DE
  56+ 4D1F C1               POP BC
  57+ 4D20               ENDIF
  58+ 4D20
  59+ 4D20              .EXIT:
  60+ 4D20 F1           	POP AF
  61+ 4D21 FB           	EI
  62+ 4D22 ED 4D        	RETI
  63+ 4D24              ; *******************************************************************************************************
  64+ 4D24
  65+ 4D24              ; *******************************************************************************************************
  66+ 4D24              ; H.TIMI function
  67+ 4D24              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D24              MBGE_HTIMI:
  69+ 4D24               EXPORT MBGE_HTIMI
  70+ 4D24
  71+ 4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D24
  73+ 4D24 F5           	PUSH AF
  74+ 4D25
  75+ 4D25              	; enable page 2
  76+ 4D25 3E 02            LD A, 2
  77+ 4D27 CD 86 64         CALL GET_PAGE_INFO
  78+ 4D2A C5               PUSH BC
  79+ 4D2B D5               PUSH DE
  80+ 4D2C 3A 43 F3         LD A, (RAMAD2)
  81+ 4D2F 26 80            LD H, 080H
  82+ 4D31 CD CD 64         CALL LOCAL_ENASLT
  83+ 4D34              	; enable page 0
  84+ 4D34 AF               XOR A
  85+ 4D35 CD 86 64         CALL GET_PAGE_INFO
  86+ 4D38 C5               PUSH BC
  87+ 4D39 D5               PUSH DE
  88+ 4D3A 3A 41 F3         LD A, (RAMAD0)
  89+ 4D3D 26 00            LD H, 0
  90+ 4D3F CD CD 64         CALL LOCAL_ENASLT
  91+ 4D42
  92+ 4D42               IF (SPRITE_CMDS == 1)
  93+ 4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D45               ENDIF
  95+ 4D45
  96+ 4D45               IF (SOUND_CMDS == 1)
  97+ 4D45 3A 32 59     	LD A, (SOUND_ENABLED)
  98+ 4D48 B7           	OR A
  99+ 4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4C               ENDIF
 101+ 4D4C
 102+ 4D4C              	; restore page 0
 103+ 4D4C D1               POP DE
 104+ 4D4D C1               POP BC
 105+ 4D4E CD BD 64         CALL RESTORE_PAGE_INFO
 106+ 4D51              	; restore page 2
 107+ 4D51 D1               POP DE
 108+ 4D52 C1               POP BC
 109+ 4D53 CD BD 64         CALL RESTORE_PAGE_INFO
 110+ 4D56
 111+ 4D56 F1           	POP AF
 112+ 4D57               ENDIF
 113+ 4D57 C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D5A              ; *******************************************************************************************************
 115+ 4D5A
 116+ 4D5A              ; *******************************************************************************************************
 117+ 4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5A              ; also checks if some VRAM modifying command is running
 119+ 4D5A              ; when that checks out calls sprite updates and animation processing
 120+ 4D5A              ; if in an unsupported mode disables sprite handling
 121+ 4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5A              	; check if initialized
 123+ 4D5A 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D5D B7           	OR A
 125+ 4D5E C8           	RET Z
 126+ 4D5F              	; check screen mode
 127+ 4D5F 3A AF FC     	LD A, (SCRMOD)
 128+ 4D62 3D           	DEC A
 129+ 4D63 28 08        	JR Z, .L0 ; screen 1
 130+ 4D65 3D           	DEC A
 131+ 4D66 28 05            JR Z, .L0 ; screen 2
 132+ 4D68              	; unsupported screen mode, disable
 133+ 4D68 AF               XOR A
 134+ 4D69 32 7C 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6C C9               RET
 136+ 4D6D              .L0:
 137+ 4D6D                  ; check if anyone else is working with VRAM
 138+ 4D6D 3A 97 62         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D70 B7               OR A
 140+ 4D71 C0               RET NZ
 141+ 4D72
 142+ 4D72 CD 91 4D         CALL SPRATR_UPDATE
 143+ 4D75
 144+ 4D75               IF (ANIM_CMDS == 1)
 145+ 4D75 CD D6 55         CALL PROCESS_ANIMATIONS
 146+ 4D78 CD A2 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7B               ENDIF
 148+ 4D7B C9               RET
 149+ 4D7C              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 117  4D7C
 118  4D7C               IF (SPRITE_CMDS == 1)
 119  4D7C               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7C              ; commands and variables related to sprites
   2+ 4D7C
   3+ 4D7C              SPRATR_INIT_STATUS:
   4+ 4D7C 00            DB 0
   5+ 4D7D              SPRATR_UPDATE_FLAG:
   6+ 4D7D 00 00         DW 0
   7+ 4D7F              SPRATR_DATA:
   8+ 4D7F 00 00         DW 0
   9+ 4D81              SPRFLICKER_ENABLED:
  10+ 4D81 00            DB 0
  11+ 4D82              ; to support sprite flicker
  12+ 4D82              FLICKER:
  13+ 4D82 00            DB 0
  14+ 4D83
  15+ 4D83              ; to temporarily store stack pointer
  16+ 4D83              TMPSP:
  17+ 4D83 00 00         DW 0
  18+ 4D85
  19+ 4D85              ; *******************************************************************************************************
  20+ 4D85              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D85              ; changes HL,DE;
  22+ 4D85              GETnthSPRATTR:
  23+ 4D85 26 00            LD H,0
  24+ 4D87 6F               LD L,A
  25+ 4D88 CD 82 64         CALL HLx8
  26+ 4D8B ED 5B 7F 4D      LD DE,(SPRATR_DATA)
  27+ 4D8F 19               ADD HL,DE
  28+ 4D90 C9               RET
  29+ 4D91              ; *******************************************************************************************************
  30+ 4D91
  31+ 4D91              ; *******************************************************************************************************
  32+ 4D91              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D91              ; struct {
  34+ 4D91              ; DW y
  35+ 4D91              ; DW x
  36+ 4D91              ; DW pattern (0-63)
  37+ 4D91              ; DW color
  38+ 4D91              ; } [32]
  39+ 4D91              ; will hide sprites whose location is outside of visible area
  40+ 4D91              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D91              ; modifies AF, AF', BC, DE, HL
  42+ 4D91              SPRATR_UPDATE:
  43+ 4D91              	; check if update requested
  44+ 4D91 2A 7D 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D94 7E           	LD A, (HL)
  46+ 4D95 B7           	OR A
  47+ 4D96 C8           	RET Z
  48+ 4D97              .L0:
  49+ 4D97 06 20        	LD B, 32 ; sprite number
  50+ 4D99 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D9B              	; set VDP address
  52+ 4D9B 3A AF FC         LD A,(SCRMOD)
  53+ 4D9E 3D               DEC A
  54+ 4D9F 20 05            JR NZ,.L4
  55+ 4DA1 2A C3 F3         LD HL, (T32ATR)
  56+ 4DA4 18 03            JR .L5
  57+ 4DA6              .L4:
  58+ 4DA6 2A CD F3         LD HL, (GRPATR)
  59+ 4DA9              .L5:
  60+ 4DA9 3A 81 4D     	LD A, (SPRFLICKER_ENABLED)
  61+ 4DAC B7           	OR A
  62+ 4DAD 28 03        	JR Z, .L3
  63+ 4DAF 3A 82 4D     	LD A, (FLICKER)
  64+ 4DB2              .L3:
  65+ 4DB2 5F           	LD E, A
  66+ 4DB3 08           	EX AF, AF'
  67+ 4DB4 7B           	LD A, E
  68+ 4DB5 87           	ADD A, A
  69+ 4DB6 87           	ADD A, A
  70+ 4DB7 16 00        	LD D, 0
  71+ 4DB9 5F           	LD E, A
  72+ 4DBA 19           	ADD HL, DE
  73+ 4DBB CD 6D 64     	CALL SETWRT_LOCAL
  74+ 4DBE ED 73 83 4D  	LD (TMPSP), SP
  75+ 4DC2 ED 7B 7F 4D  	LD SP, (SPRATR_DATA)
  76+ 4DC6
  77+ 4DC6              .LOOP:
  78+ 4DC6 E1           	POP HL
  79+ 4DC7 24           	INC H
  80+ 4DC8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  81+ 4DCA 25           	DEC H
  82+ 4DCB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  83+ 4DCD 7D           	LD A, L
  84+ 4DCE FE C0        	CP 192
  85+ 4DD0 30 10        	JR NC, .OUT3
  86+ 4DD2 3D           	DEC A ; due to VDP rule that top of screen is -1
  87+ 4DD3 57           	LD D, A
  88+ 4DD4 C3 FB 4D     	JP .X
  89+ 4DD7              .L1:
  90+ 4DD7 7D           	LD A, L
  91+ 4DD8 C6 10        	ADD 16
  92+ 4DDA FA E2 4D     	JP M, .OUT3 ; below -16
  93+ 4DDD 2D           	DEC L ; due to VDP rule that top of screen is -1
  94+ 4DDE 55           	LD D, L
  95+ 4DDF C3 FB 4D     	JP .X
  96+ 4DE2              .OUT3:
  97+ 4DE2 E1           	POP HL ; skip x value
  98+ 4DE3              .OUT2:
  99+ 4DE3 E1           	POP HL ; skip pattern
 100+ 4DE4 E1           	POP HL ; skip color
 101+ 4DE5 3E D1        	LD A, #D1
 102+ 4DE7 ED 79        	OUT (C), A ; sprite hidden
 103+ 4DE9 00          > NOP
 103+ 4DEA 00          > NOP
 103+ 4DEB 00          > NOP
 104+ 4DEC ED 79        	OUT (C), A ; value unimportant
 105+ 4DEE 00          > NOP
 105+ 4DEF 00          > NOP
 105+ 4DF0 00          > NOP
 106+ 4DF1 ED 79        	OUT (C), A ; value unimportant
 107+ 4DF3 00          > NOP
 107+ 4DF4 00          > NOP
 107+ 4DF5 00          > NOP
 108+ 4DF6 ED 79        	OUT (C), A ; value unimportant
 109+ 4DF8 C3 26 4E     	JP .NEXT
 110+ 4DFB              .X:
 111+ 4DFB E1           	POP HL
 112+ 4DFC 24           	INC H
 113+ 4DFD 28 08        	JR Z, .L2
 114+ 4DFF 25           	DEC H
 115+ 4E00 20 E1        	JR NZ, .OUT2
 116+ 4E02 1E 00        	LD E, 0 ; EC bit
 117+ 4E04 C3 10 4E     	JP .XY
 118+ 4E07              .L2:
 119+ 4E07 7D           	LD A, L
 120+ 4E08 C6 20        	ADD 32
 121+ 4E0A FA E3 4D     	JP M, .OUT2
 122+ 4E0D 6F           	LD L, A
 123+ 4E0E 1E 80        	LD E, #80
 124+ 4E10              .XY:
 125+ 4E10 ED 51        	OUT (C), D
 126+ 4E12 3A E0 F3     	LD A, (REG1SAV)
 127+ 4E15 E6 02        	AND 2
 128+ 4E17 ED 69        	OUT (C), L
 129+ 4E19 E1           	POP HL ; pattern
 130+ 4E1A 7D           	LD A, L
 131+ 4E1B 28 02        	JR Z, .SMALLSPRITES
 132+ 4E1D 87           	ADD A, A
 133+ 4E1E 87           	ADD A, A ; needs to go at 4x
 134+ 4E1F              .SMALLSPRITES:
 135+ 4E1F D3 98        	OUT (#98), A
 136+ 4E21 E1           	POP HL ; color
 137+ 4E22 7D           	LD A, L
 138+ 4E23 B3           	OR E
 139+ 4E24 D3 98        	OUT (#98), A
 140+ 4E26              .NEXT:
 141+ 4E26 08           	EX AF, AF'
 142+ 4E27 3C           	INC A
 143+ 4E28 E6 1F        	AND 31
 144+ 4E2A C2 49 4E     	JP NZ, .NEXT2
 145+ 4E2D 08           	EX AF, AF'
 146+ 4E2E 3A AF FC         LD A,(SCRMOD)
 147+ 4E31 3D               DEC A
 148+ 4E32 20 05            JR NZ,.L6
 149+ 4E34 2A C3 F3         LD HL, (T32ATR)
 150+ 4E37 18 03            JR .L7
 151+ 4E39              .L6:
 152+ 4E39 2A CD F3         LD HL, (GRPATR)
 153+ 4E3C              .L7:
 154+ 4E3C              	; CALL SETWRT_LOCAL not allowed as SP modified
 155+ 4E3C 7D           	LD	A, L
 156+ 4E3D D3 99        	OUT	(099H), A
 157+ 4E3F 7C           	LD	A, H
 158+ 4E40 E6 3F        	AND	03FH
 159+ 4E42 F6 40        	OR	040H
 160+ 4E44 D3 99        	OUT	(099H), A
 161+ 4E46 C3 4A 4E     	JP .NEXT3
 162+ 4E49              .NEXT2:
 163+ 4E49 08           	EX AF, AF'
 164+ 4E4A              .NEXT3:
 165+ 4E4A 05           	DEC B
 166+ 4E4B C2 C6 4D     	JP NZ, .LOOP
 167+ 4E4E 08           	EX AF, AF'
 168+ 4E4F 3C           	INC A
 169+ 4E50 32 82 4D     	LD (FLICKER), A
 170+ 4E53
 171+ 4E53 ED 7B 83 4D  	LD SP, (TMPSP)
 172+ 4E57 2A 7D 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 173+ 4E5A 36 00        	LD (HL), 0 ; zero out update flag
 174+ 4E5C C9           	RET
 175+ 4E5D              ; *******************************************************************************************************
 176+ 4E5D
 177+ 4E5D              ; *******************************************************************************************************
 178+ 4E5D              ; function to handle CALL SPRENABLE basic extension
 179+ 4E5D              ; initializes sprites handler
 180+ 4E5D              ; _SPRENABLE ( INT[][] sprites_attributes,
 181+ 4E5D              ;			   INT update_variable,
 182+ 4E5D              ;			   BYTE sprite_flicker_enabled )
 183+ 4E5D              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 184+ 4E5D              SPRENABLE:
 185+ 4E5D              	; opening (
 186+ 4E5D CD 94 65     	CALL CHKCHAR
 187+ 4E60 28           	DB '('
 188+ 4E61              	; get address of sprite attribute table DIM SA%(3,31)
 189+ 4E61 3E 02        	LD A,2
 190+ 4E63 06 02        	LD B,2
 191+ 4E65 11 20 04     	LD DE,#0420
 192+ 4E68 CD C1 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 193+ 4E6B C5           	PUSH BC
 194+ 4E6C              	; comma
 195+ 4E6C CD 94 65     	CALL CHKCHAR
 196+ 4E6F 2C           	DB ','
 197+ 4E70              	; get address of sprite update flag
 198+ 4E70 DD 21 A4 5E  	LD IX, PTRGET
 199+ 4E74 CD 59 01     	CALL CALBAS
 200+ 4E77 D5           	PUSH DE
 201+ 4E78              	; comma
 202+ 4E78 CD 94 65     	CALL CHKCHAR
 203+ 4E7B 2C           	DB ','
 204+ 4E7C              	; get flicker enabled flag
 205+ 4E7C DD 21 1C 52  	LD IX, GETBYT
 206+ 4E80 CD 59 01     	CALL CALBAS
 207+ 4E83 F5           	PUSH AF
 208+ 4E84              	; ending )
 209+ 4E84 CD 94 65     	CALL CHKCHAR
 210+ 4E87 29           	DB ')'
 211+ 4E88
 212+ 4E88 F1           	POP AF ; get flicker flag
 213+ 4E89 B7           	OR A
 214+ 4E8A 32 81 4D     	LD (SPRFLICKER_ENABLED), A
 215+ 4E8D
 216+ 4E8D D1           	POP DE ; update variable location
 217+ 4E8E ED 53 7D 4D  	LD (SPRATR_UPDATE_FLAG), DE
 218+ 4E92 D1           	POP DE ; address of sprite attribute table
 219+ 4E93 ED 53 7F 4D  	LD (SPRATR_DATA), DE
 220+ 4E97 3E 01        	LD A, 1
 221+ 4E99 32 7C 4D     	LD (SPRATR_INIT_STATUS), A
 222+ 4E9C C9           	RET
 223+ 4E9D              ; *******************************************************************************************************
 224+ 4E9D
 225+ 4E9D              ; *******************************************************************************************************
 226+ 4E9D              ; function to handle CALL SPRDISABLE basic extension
 227+ 4E9D              ; disables sprites handling
 228+ 4E9D              ; _SPRDISABLE
 229+ 4E9D              ; resets variable SPRATR_INIT_STATUS
 230+ 4E9D              SPRDISABLE:
 231+ 4E9D AF           	XOR A
 232+ 4E9E 32 7C 4D     	LD (SPRATR_INIT_STATUS), A
 233+ 4EA1 C9           	RET
 234+ 4EA2              ; *******************************************************************************************************
 235+ 4EA2
 236+ 4EA2              ; *******************************************************************************************************
 237+ 4EA2              ; function to handle CALL SPRSET basic extension
 238+ 4EA2              ; sets position, and optionally pattern and color of sprite
 239+ 4EA2              ; _SPRSET ( BYTE sprite_num , valid 0-31
 240+ 4EA2              ;			INT x,
 241+ 4EA2              ;			INT y,
 242+ 4EA2              ;			INT pattern, valid 0-63, otherwise ignored
 243+ 4EA2              ;			INT color, valid 0-15, otherwise ignored
 244+ 4EA2              SPRSET:
 245+ 4EA2 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 246+ 4EA5 B7           	OR A
 247+ 4EA6 20 05        	JR NZ, .L1
 248+ 4EA8 1E 05        	LD E, 5 ; illegal function call
 249+ 4EAA C3 BA 65     	JP THROW_ERROR
 250+ 4EAD              .L1:
 251+ 4EAD              	; opening (
 252+ 4EAD CD 94 65     	CALL CHKCHAR
 253+ 4EB0 28           	DB '('
 254+ 4EB1              	; get sprite number
 255+ 4EB1 DD 21 1C 52  	LD IX, GETBYT
 256+ 4EB5 CD 59 01     	CALL CALBAS
 257+ 4EB8 F5           	PUSH AF
 258+ 4EB9              	; comma
 259+ 4EB9 CD 94 65     	CALL CHKCHAR
 260+ 4EBC 2C           	DB ','
 261+ 4EBD              	; get x
 262+ 4EBD DD 21 2F 54  	LD IX, FRMQNT
 263+ 4EC1 CD 59 01     	CALL CALBAS
 264+ 4EC4 D5           	PUSH DE
 265+ 4EC5              	; comma
 266+ 4EC5 CD 94 65     	CALL CHKCHAR
 267+ 4EC8 2C           	DB ','
 268+ 4EC9              	; get y
 269+ 4EC9 DD 21 2F 54  	LD IX, FRMQNT
 270+ 4ECD CD 59 01     	CALL CALBAS
 271+ 4ED0 D5           	PUSH DE
 272+ 4ED1              	; comma
 273+ 4ED1 CD 94 65     	CALL CHKCHAR
 274+ 4ED4 2C           	DB ','
 275+ 4ED5              	; get pattern
 276+ 4ED5 DD 21 2F 54  	LD IX, FRMQNT
 277+ 4ED9 CD 59 01     	CALL CALBAS
 278+ 4EDC D5           	PUSH DE
 279+ 4EDD              	; comma
 280+ 4EDD CD 94 65     	CALL CHKCHAR
 281+ 4EE0 2C           	DB ','
 282+ 4EE1              	; get color
 283+ 4EE1 DD 21 2F 54  	LD IX, FRMQNT
 284+ 4EE5 CD 59 01     	CALL CALBAS
 285+ 4EE8 D5           	PUSH DE
 286+ 4EE9              	; ending )
 287+ 4EE9 CD 94 65     	CALL CHKCHAR
 288+ 4EEC 29           	DB ')'
 289+ 4EED
 290+ 4EED                  ; save position in BASIC text
 291+ 4EED E5           	PUSH HL
 292+ 4EEE DD E1        	POP IX
 293+ 4EF0
 294+ 4EF0 C1           	POP BC ; color
 295+ 4EF1 D1           	POP DE ; pattern
 296+ 4EF2 D9           	EXX
 297+ 4EF3 C1           	POP BC ; y
 298+ 4EF4 D1           	POP DE ; x
 299+ 4EF5 F1           	POP AF ; sprite number
 300+ 4EF6 FE 20        	CP 32
 301+ 4EF8 38 05        	JR C, .L2
 302+ 4EFA 1E 05        	LD E, 5 ; illegal function call
 303+ 4EFC C3 BA 65     	JP THROW_ERROR
 304+ 4EFF              .L2:
 305+ 4EFF              	; find location in sprite attributes table
 306+ 4EFF D5           	PUSH DE
 307+ 4F00 CD 85 4D     	CALL GETnthSPRATTR
 308+ 4F03 D1           	POP DE
 309+ 4F04              	; set y
 310+ 4F04 71           	LD (HL), C
 311+ 4F05 23           	INC HL
 312+ 4F06 70           	LD (HL), B
 313+ 4F07 23           	INC HL
 314+ 4F08              	; set x
 315+ 4F08 73           	LD (HL), E
 316+ 4F09 23           	INC HL
 317+ 4F0A 72           	LD (HL), D
 318+ 4F0B 23           	INC HL
 319+ 4F0C E5           	PUSH HL
 320+ 4F0D D9           	EXX
 321+ 4F0E E1           	POP HL
 322+ 4F0F              	; check if 0<=pattern<64
 323+ 4F0F 7A           	LD A, D
 324+ 4F10 B7           	OR A
 325+ 4F11 20 0B        	JR NZ, .L3
 326+ 4F13 7B           	LD A, E
 327+ 4F14 FE 40        	CP 64
 328+ 4F16 30 06        	JR NC, .L3
 329+ 4F18              	; set pattern
 330+ 4F18              	;ADD A, A
 331+ 4F18              	;ADD A, A
 332+ 4F18              	;ADD A, A
 333+ 4F18 77           	LD (HL), A
 334+ 4F19 23           	INC HL
 335+ 4F1A 72           	LD (HL), D
 336+ 4F1B 23           	INC HL
 337+ 4F1C 18 02        	JR .L4
 338+ 4F1E              .L3:
 339+ 4F1E              	; skip pattern
 340+ 4F1E 23          > INC HL
 340+ 4F1F 23          > INC HL
 341+ 4F20              .L4:
 342+ 4F20              	; check if 0<=color<16
 343+ 4F20 78           	LD A, B
 344+ 4F21 B7           	OR A
 345+ 4F22 20 08        	JR NZ, .L5
 346+ 4F24 79           	LD A, C
 347+ 4F25 FE 10        	CP 16
 348+ 4F27 30 03        	JR NC, .L5
 349+ 4F29              	; set color
 350+ 4F29 71           	LD (HL), C
 351+ 4F2A 23           	INC HL
 352+ 4F2B 70           	LD (HL), B
 353+ 4F2C
 354+ 4F2C              .L5:
 355+ 4F2C DD E5        	PUSH IX
 356+ 4F2E E1           	POP HL
 357+ 4F2F C9           	RET
 358+ 4F30              ; *******************************************************************************************************
 359+ 4F30
 360+ 4F30              ; *******************************************************************************************************
 361+ 4F30              ; function sets sprite location based on initial coordinates and offset provided
 362+ 4F30              ; input A=sprite number in SPRATR_DATA , 0-31
 363+ 4F30              ; input DE=initial x
 364+ 4F30              ; input BC=initial y
 365+ 4F30              ; input IY=location where delta y,x are located
 366+ 4F30              ; modifies AF, HL, IX
 367+ 4F30              SPRSET_DELTA_POS:
 368+ 4F30 D5           	PUSH DE
 369+ 4F31 CD 85 4D     	CALL GETnthSPRATTR
 370+ 4F34 E5           	PUSH HL
 371+ 4F35 DD E1        	POP IX
 372+ 4F37 D1           	POP DE
 373+ 4F38              	; IX=sprite's y location
 374+ 4F38 FD 6E 00     	LD L, (IY)
 375+ 4F3B FD 66 01     	LD H, (IY+1)
 376+ 4F3E 09           	ADD HL, BC
 377+ 4F3F DD 75 00     	LD (IX), L
 378+ 4F42 DD 74 01     	LD (IX+1), H
 379+ 4F45 FD 6E 02     	LD L, (IY+2)
 380+ 4F48 FD 66 03     	LD H, (IY+3)
 381+ 4F4B 19           	ADD HL, DE
 382+ 4F4C DD 75 02     	LD (IX+2), L
 383+ 4F4F DD 74 03     	LD (IX+3), H
 384+ 4F52 C9           	RET
 385+ 4F53              ; *******************************************************************************************************
 386+ 4F53
 387+ 4F53              ; *******************************************************************************************************
 388+ 4F53              ; function to handle CALL SPRGRPMOV basic extension
 389+ 4F53              ; sets position of a group of sprites described with
 390+ 4F53              ; { int sprite_num, int delta_y, int delta_x } [count]
 391+ 4F53              ; _SPRGRPMOV ( INT x,
 392+ 4F53              ;			   INT y,
 393+ 4F53              ;			   BYTE count,
 394+ 4F53              ;			   INT[2][count] data_ptr
 395+ 4F53              ; will put ram in page 0 also, page 1 is already there
 396+ 4F53              SPRGRPMOV:
 397+ 4F53 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
 398+ 4F56 B7           	OR A
 399+ 4F57 CA B4 65     	JP Z,ILLEGAL_FUNCTION
 400+ 4F5A              	; opening (
 401+ 4F5A CD 94 65     	CALL CHKCHAR
 402+ 4F5D 28           	DB '('
 403+ 4F5E              	; get x
 404+ 4F5E DD 21 2F 54  	LD IX, FRMQNT
 405+ 4F62 CD 59 01     	CALL CALBAS
 406+ 4F65 D5           	PUSH DE
 407+ 4F66              	; comma
 408+ 4F66 CD 94 65     	CALL CHKCHAR
 409+ 4F69 2C           	DB ','
 410+ 4F6A              	; get y
 411+ 4F6A DD 21 2F 54  	LD IX, FRMQNT
 412+ 4F6E CD 59 01     	CALL CALBAS
 413+ 4F71 D5           	PUSH DE
 414+ 4F72              	; comma
 415+ 4F72 CD 94 65     	CALL CHKCHAR
 416+ 4F75 2C           	DB ','
 417+ 4F76              	; get count
 418+ 4F76 DD 21 1C 52  	LD IX, GETBYT
 419+ 4F7A CD 59 01     	CALL CALBAS
 420+ 4F7D F5           	PUSH AF
 421+ 4F7E              	; comma
 422+ 4F7E CD 94 65     	CALL CHKCHAR
 423+ 4F81 2C           	DB ','
 424+ 4F82              	; get sprite group definition array data pointer
 425+ 4F82 D1           	POP DE
 426+ 4F83 D5           	PUSH DE
 427+ 4F84 5A           	LD E,D
 428+ 4F85 16 03        	LD D,3
 429+ 4F87 3E 02        	LD A,2
 430+ 4F89 47           	LD B,A
 431+ 4F8A CD C1 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 432+ 4F8D C5           	PUSH BC
 433+ 4F8E              	; ending )
 434+ 4F8E CD 94 65     	CALL CHKCHAR
 435+ 4F91 29           	DB ')'
 436+ 4F92
 437+ 4F92 E5           	PUSH HL
 438+ 4F93 DD E1        	POP IX
 439+ 4F95
 440+ 4F95 E1           	POP HL ; data pointer
 441+ 4F96 C1           	POP BC ; count
 442+ 4F97 D9           	EXX
 443+ 4F98 C1           	POP BC ; y
 444+ 4F99 D1           	POP DE ; x
 445+ 4F9A D9           	EXX
 446+ 4F9B
 447+ 4F9B DD E5        	PUSH IX ; save position in BASIC buffer
 448+ 4F9D
 449+ 4F9D C5           	PUSH BC
 450+ 4F9E E5           	PUSH HL
 451+ 4F9F AF               XOR A
 452+ 4FA0 CD 86 64         CALL GET_PAGE_INFO
 453+ 4FA3 D9           	EXX
 454+ 4FA4 E1           	POP HL
 455+ 4FA5 F1           	POP AF
 456+ 4FA6 D9           	EXX
 457+ 4FA7 C5               PUSH BC
 458+ 4FA8 D5               PUSH DE
 459+ 4FA9 D9           	EXX
 460+ 4FAA F5           	PUSH AF
 461+ 4FAB E5           	PUSH HL
 462+ 4FAC D9           	EXX
 463+ 4FAD 3A 41 F3         LD A, (RAMAD0)
 464+ 4FB0 26 00            LD H, 0
 465+ 4FB2 CD CD 64         CALL LOCAL_ENASLT
 466+ 4FB5 FB           	EI
 467+ 4FB6 E1           	POP HL
 468+ 4FB7 C1           	POP BC
 469+ 4FB8 3E 01        	LD A,1
 470+ 4FBA 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 471+ 4FBD CD CB 4F     	CALL .UPDATE_LOC
 472+ 4FC0 AF           	XOR A
 473+ 4FC1 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 474+ 4FC4 D1               POP DE
 475+ 4FC5 C1               POP BC
 476+ 4FC6 CD BD 64         CALL RESTORE_PAGE_INFO
 477+ 4FC9 E1           	POP HL
 478+ 4FCA C9           	RET
 479+ 4FCB
 480+ 4FCB              .UPDATE_LOC:
 481+ 4FCB 7E           	LD A, (HL)
 482+ 4FCC 23           	INC HL
 483+ 4FCD 23           	INC HL
 484+ 4FCE E5           	PUSH HL
 485+ 4FCF FD E1        	POP IY
 486+ 4FD1 D9           	EXX
 487+ 4FD2 CD 30 4F     	CALL SPRSET_DELTA_POS
 488+ 4FD5 D9           	EXX
 489+ 4FD6 23          > INC HL
 489+ 4FD7 23          > INC HL
 489+ 4FD8 23          > INC HL
 489+ 4FD9 23          > INC HL
 490+ 4FDA 10 EF        	DJNZ .UPDATE_LOC
 491+ 4FDC C9           	RET
 492+ 4FDD              ; *******************************************************************************************************
 493+ 4FDD
# file closed: asm\SPRITES.asm
 120  4FDD               ENDIF
 121  4FDD
 122  4FDD               IF (ANIM_CMDS == 1)
 123  4FDD               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4FDD              ; sprite animation routines
   2+ 4FDD
   3+ 4FDD              ; number of animation items and pointer
   4+ 4FDD              ANIMITEMNUM:
   5+ 4FDD 00            DB 0
   6+ 4FDE              ANIMITEMPTR:
   7+ 4FDE F6 65         DW EXT_END
   8+ 4FE0              ; number of animation definitions and pointer
   9+ 4FE0              ANIMDEFNUM:
  10+ 4FE0 00            DB 0
  11+ 4FE1              ANIMDEFPTR:
  12+ 4FE1 F6 65         DW EXT_END
  13+ 4FE3              ; number of links between sprite and animation definitions
  14+ 4FE3              ANIMSPRNUM:
  15+ 4FE3 00            DB 0
  16+ 4FE4              ANIMSPRPTR:
  17+ 4FE4 F6 65         DW EXT_END
  18+ 4FE6              ; number of automatic sprite group move and animate structures
  19+ 4FE6              AUTOSGAMNUM:
  20+ 4FE6 00            DB 0
  21+ 4FE7              AUTOSGAMPTR:
  22+ 4FE7 F6 65         DW EXT_END
  23+ 4FE9
  24+ 4FE9              ; ANIMATION ITEM
  25+ 4FE9              ; byte type = [0 - pattern and color change
  26+ 4FE9              ;              1 - pattern definition change ]
  27+ 4FE9              ; word ticks - number of ticks to hold this state
  28+ 4FE9              ; for type = 0
  29+ 4FE9              ;   byte pattern;
  30+ 4FE9              ;   byte color;
  31+ 4FE9              ; for type = 1
  32+ 4FE9              ;   work data_pointer;
  33+ 4FE9              ; total size = 5b
  34+ 4FE9
  35+ 4FE9              ; ANIMATION DEFINITION
  36+ 4FE9              ; byte number of items 1-15
  37+ 4FE9              ; byte[15] anim_item;
  38+ 4FE9              ; total size = 16b
  39+ 4FE9
  40+ 4FE9              ; SPRITE/CHAR ANIMATION
  41+ 4FE9              ; +00 byte sprite/char number;
  42+ 4FE9              ; +01 word time;
  43+ 4FE9              ; +03 byte current item;
  44+ 4FE9              ; +04 byte animation definition;
  45+ 4FE9              ; +05 byte cyclic;
  46+ 4FE9              ; +06 byte active;
  47+ 4FE9              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4FE9              ; total size = 8b
  49+ 4FE9
  50+ 4FE9              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4FE9              ; +00 pointer to X variable
  52+ 4FE9              ; +02 pointer to Y variable
  53+ 4FE9              ; +04 minimum value
  54+ 4FE9              ; +06 maximal value
  55+ 4FE9              ; +08 delta value
  56+ 4FE9              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4FE9              ; +11 sprite group size
  58+ 4FE9              ; +12 sprite group pointer
  59+ 4FE9              ; +14 animation list size
  60+ 4FE9              ; +15 animation list pointer for negative delta values
  61+ 4FE9              ; +17 animation list pointer for positive delta values
  62+ 4FE9              ; +19 active flag
  63+ 4FE9              ; +20 ticks for movement
  64+ 4FE9              ; +22 timer
  65+ 4FE9              ; total = 24b
  66+ 4FE9
  67+ 4FE9              ; *******************************************************************************************************
  68+ 4FE9              ; helper function HL=A*5
  69+ 4FE9              ; changes HL,DE;
  70+ 4FE9              Ax5:
  71+ 4FE9 26 00            LD H,0
  72+ 4FEB 6F               LD L,A
  73+ 4FEC 54               LD D,H
  74+ 4FED 5D               LD E,L
  75+ 4FEE 29               ADD HL,HL
  76+ 4FEF 29               ADD HL,HL
  77+ 4FF0 19               ADD HL,DE
  78+ 4FF1 C9               RET
  79+ 4FF2              ; *******************************************************************************************************
  80+ 4FF2
  81+ 4FF2              ; *******************************************************************************************************
  82+ 4FF2              ; helper function gets pointer to n-th animation item
  83+ 4FF2              ; changes HL,DE;
  84+ 4FF2              GETnthANIMITEM:
  85+ 4FF2 CD E9 4F         CALL Ax5
  86+ 4FF5 ED 5B DE 4F      LD DE,(ANIMITEMPTR)
  87+ 4FF9 19               ADD HL,DE
  88+ 4FFA C9               RET
  89+ 4FFB              ; *******************************************************************************************************
  90+ 4FFB
  91+ 4FFB              ; *******************************************************************************************************
  92+ 4FFB              ; helper function gets pointer to n-th entry in animation definition
  93+ 4FFB              ; changes HL,DE;
  94+ 4FFB              GETnthANIMDEF:
  95+ 4FFB 26 00            LD H,0
  96+ 4FFD 6F               LD L,A
  97+ 4FFE CD 81 64         CALL HLx16
  98+ 5001 ED 5B E1 4F      LD DE,(ANIMDEFPTR)
  99+ 5005 19               ADD HL,DE
 100+ 5006 C9               RET
 101+ 5007              ; *******************************************************************************************************
 102+ 5007
 103+ 5007              ; *******************************************************************************************************
 104+ 5007              ; helper function gets pointer to n-th entry in sprite animation
 105+ 5007              ; changes HL,DE;
 106+ 5007              GETnthSPRANIM:
 107+ 5007 26 00            LD H,0
 108+ 5009 6F               LD L,A
 109+ 500A CD 82 64         CALL HLx8
 110+ 500D ED 5B E4 4F      LD DE,(ANIMSPRPTR)
 111+ 5011 19               ADD HL,DE
 112+ 5012 C9               RET
 113+ 5013              ; *******************************************************************************************************
 114+ 5013
 115+ 5013              ; *******************************************************************************************************
 116+ 5013              ; helper function gets pointer to n-th entry in autosgam table
 117+ 5013              ; changes HL,DE;
 118+ 5013              GETnthAUTOSGAM:
 119+ 5013 26 00            LD H,0
 120+ 5015 6F               LD L,A
 121+ 5016 CD 82 64         CALL HLx8
 122+ 5019 54               LD D,H
 123+ 501A 5D               LD E,L
 124+ 501B 29               ADD HL,HL
 125+ 501C 19               ADD HL,DE
 126+ 501D ED 5B E7 4F      LD DE,(AUTOSGAMPTR)
 127+ 5021 19               ADD HL,DE
 128+ 5022 C9               RET
 129+ 5023              ; *******************************************************************************************************
 130+ 5023
 131+ 5023              ; *******************************************************************************************************
 132+ 5023              ; function to handle CALL MAXANIMITEMS basic extension
 133+ 5023              ; MAXANIMITEMS (BYTE number)
 134+ 5023              ; sets new number and moves memory buffers as needed
 135+ 5023              MAXANIMITEMS:
 136+ 5023              	; opening (
 137+ 5023 CD 94 65     	CALL CHKCHAR
 138+ 5026 28           	DB '('
 139+ 5027              	; get value
 140+ 5027 DD 21 1C 52  	LD IX, GETBYT
 141+ 502B CD 59 01     	CALL CALBAS
 142+ 502E F5               PUSH AF
 143+ 502F              	; ending )
 144+ 502F CD 94 65     	CALL CHKCHAR
 145+ 5032 29           	DB ')'
 146+ 5033 F1               POP AF
 147+ 5034
 148+ 5034              	; save position
 149+ 5034 E5           	PUSH HL
 150+ 5035              .ENTRY:
 151+ 5035 47               LD B,A
 152+ 5036 3A DD 4F         LD A,(ANIMITEMNUM)
 153+ 5039 90               SUB B
 154+ 503A 28 28            JR Z, .EXIT; same value as before
 155+ 503C FD 21 E1 4F      LD IY,ANIMDEFPTR
 156+ 5040 FA 67 50         JP M, .INCREASE
 157+ 5043                  ; new value is lower than previous one
 158+ 5043 CD 86 50         CALL .SIZEDIFF
 159+ 5046 CD A1 50         CALL .DECREASE_COMMON
 160+ 5049 2A E4 4F         LD HL,(ANIMSPRPTR)
 161+ 504C AF               XOR A
 162+ 504D ED 42            SBC HL,BC
 163+ 504F 22 E4 4F         LD (ANIMSPRPTR),HL
 164+ 5052              .E1:
 165+ 5052 2A E7 4F         LD HL,(AUTOSGAMPTR)
 166+ 5055 AF               XOR A
 167+ 5056 ED 42            SBC HL,BC
 168+ 5058 22 E7 4F         LD (AUTOSGAMPTR),HL
 169+ 505B              .E3:
 170+ 505B 2A 10 40         LD HL,(FREEMEMPTR)
 171+ 505E AF               XOR A
 172+ 505F ED 42            SBC HL,BC
 173+ 5061 22 10 40         LD (FREEMEMPTR),HL
 174+ 5064              .EXIT:
 175+ 5064 FB               EI
 176+ 5065 E1           	POP HL
 177+ 5066 C9           	RET
 178+ 5067              .INCREASE:
 179+ 5067 ED 44            NEG
 180+ 5069 CD 86 50         CALL .SIZEDIFF
 181+ 506C CD CD 50         CALL .INCREASE_COMMON
 182+ 506F 2A E4 4F         LD HL,(ANIMSPRPTR)
 183+ 5072 09               ADD HL,BC
 184+ 5073 22 E4 4F         LD (ANIMSPRPTR),HL
 185+ 5076              .E2:
 186+ 5076 2A E7 4F         LD HL,(AUTOSGAMPTR)
 187+ 5079 09               ADD HL,BC
 188+ 507A 22 E7 4F         LD (AUTOSGAMPTR),HL
 189+ 507D              .E4:
 190+ 507D 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 5080 09               ADD HL,BC
 192+ 5081 22 10 40         LD (FREEMEMPTR),HL
 193+ 5084 18 DE            JR .EXIT
 194+ 5086              .SIZEDIFF:
 195+ 5086 CD E9 4F         CALL Ax5
 196+ 5089 78               LD A,B
 197+ 508A 32 DD 4F         LD (ANIMITEMNUM),A
 198+ 508D 44               LD B,H
 199+ 508E 4D               LD C,L
 200+ 508F C9               RET ; BC=size difference in bytes
 201+ 5090              .SIZETOMOVE:
 202+ 5090 D5               PUSH DE
 203+ 5091 2A 10 40         LD HL,(FREEMEMPTR)
 204+ 5094 FD 5E 00         LD E,(IY)
 205+ 5097 FD 56 01         LD D,(IY+1)
 206+ 509A AF               XOR A
 207+ 509B ED 52            SBC HL,DE
 208+ 509D 44               LD B,H
 209+ 509E 4D               LD C,L
 210+ 509F D1               POP DE
 211+ 50A0 C9               RET
 212+ 50A1              .DECREASE_COMMON:
 213+ 50A1 FD 6E 00         LD L,(IY)
 214+ 50A4 FD 66 01         LD H,(IY+1)
 215+ 50A7 AF               XOR A
 216+ 50A8 ED 42            SBC HL,BC
 217+ 50AA EB               EX DE,HL
 218+ 50AB C5               PUSH BC
 219+ 50AC CD 90 50         CALL .SIZETOMOVE
 220+ 50AF F3               DI
 221+ 50B0 78               LD A,B
 222+ 50B1 B1               OR C
 223+ 50B2 28 08            JR Z,.L1
 224+ 50B4 FD 6E 00         LD L,(IY)
 225+ 50B7 FD 66 01         LD H,(IY+1)
 226+ 50BA ED B0            LDIR
 227+ 50BC              .L1:
 228+ 50BC C1               POP BC
 229+ 50BD FD 6E 00         LD L,(IY)
 230+ 50C0 FD 66 01         LD H,(IY+1)
 231+ 50C3 AF               XOR A
 232+ 50C4 ED 42            SBC HL,BC
 233+ 50C6 FD 75 00         LD (IY),L
 234+ 50C9 FD 74 01         LD (IY+1),H
 235+ 50CC C9               RET
 236+ 50CD              .INCREASE_COMMON:
 237+ 50CD 2A 10 40         LD HL,(FREEMEMPTR)
 238+ 50D0 2B               DEC HL
 239+ 50D1 AF               XOR A
 240+ 50D2 ED 42            SBC HL,BC
 241+ 50D4 EB               EX DE,HL
 242+ 50D5 C5               PUSH BC
 243+ 50D6 CD 90 50         CALL .SIZETOMOVE
 244+ 50D9 F3               DI
 245+ 50DA 78               LD A,B
 246+ 50DB B1               OR C
 247+ 50DC 28 06            JR Z,.L2
 248+ 50DE 2A 10 40         LD HL,(FREEMEMPTR)
 249+ 50E1 2B               DEC HL
 250+ 50E2 ED B8            LDDR
 251+ 50E4              .L2:
 252+ 50E4 C1               POP BC
 253+ 50E5 FD 6E 00         LD L,(IY)
 254+ 50E8 FD 66 01         LD H,(IY+1)
 255+ 50EB 09               ADD HL,BC
 256+ 50EC FD 75 00         LD (IY),L
 257+ 50EF FD 74 01         LD (IY+1),H
 258+ 50F2 C9               RET
 259+ 50F3              ; *******************************************************************************************************
 260+ 50F3
 261+ 50F3              ; *******************************************************************************************************
 262+ 50F3              ; function to handle CALL ANIMITEMPAT basic extension
 263+ 50F3              ; ANIMITEMPAT ( BYTE id,
 264+ 50F3              ;               INT ticks,
 265+ 50F3              ;               BYTE pattern,
 266+ 50F3              ;               BYTE color )
 267+ 50F3              ; fills animation item data, returns an error if out of bounds
 268+ 50F3              ANIMITEMPAT:
 269+ 50F3                  ; opening (
 270+ 50F3 CD 94 65     	CALL CHKCHAR
 271+ 50F6 28           	DB '('
 272+ 50F7              	; get id
 273+ 50F7 DD 21 1C 52  	LD IX, GETBYT
 274+ 50FB CD 59 01     	CALL CALBAS
 275+ 50FE F5               PUSH AF
 276+ 50FF                  ; check if out of bounds
 277+ 50FF 3C               INC A
 278+ 5100 4F               LD C,A
 279+ 5101 3A DD 4F         LD A,(ANIMITEMNUM)
 280+ 5104 B9               CP C
 281+ 5105 DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 282+ 5108              	; comma
 283+ 5108 CD 94 65     	CALL CHKCHAR
 284+ 510B 2C           	DB ','
 285+ 510C              	; get ticks
 286+ 510C DD 21 2F 54  	LD IX, FRMQNT
 287+ 5110 CD 59 01     	CALL CALBAS
 288+ 5113 D5           	PUSH DE
 289+ 5114              	; comma
 290+ 5114 CD 94 65     	CALL CHKCHAR
 291+ 5117 2C           	DB ','
 292+ 5118              	; get pattern
 293+ 5118 DD 21 1C 52  	LD IX, GETBYT
 294+ 511C CD 59 01     	CALL CALBAS
 295+ 511F F5               PUSH AF
 296+ 5120              	; comma
 297+ 5120 CD 94 65     	CALL CHKCHAR
 298+ 5123 2C           	DB ','
 299+ 5124              	; get color
 300+ 5124 DD 21 1C 52  	LD IX, GETBYT
 301+ 5128 CD 59 01     	CALL CALBAS
 302+ 512B F5               PUSH AF
 303+ 512C              	; ending )
 304+ 512C CD 94 65     	CALL CHKCHAR
 305+ 512F 29           	DB ')'
 306+ 5130              .ENTRY:
 307+ 5130 E5               PUSH HL
 308+ 5131 DD E1            POP IX
 309+ 5133 D9               EXX
 310+ 5134 C1               POP BC ; color
 311+ 5135 D1               POP DE ; pattern
 312+ 5136 E1               POP HL ; ticks
 313+ 5137 D9               EXX
 314+ 5138 F1               POP AF
 315+ 5139 CD F2 4F         CALL GETnthANIMITEM
 316+ 513C E5               PUSH HL
 317+ 513D FD E1            POP IY
 318+ 513F D9               EXX
 319+ 5140 FD 36 00 00      LD (IY),0 ; type=0
 320+ 5144 FD 75 01         LD (IY+1),L
 321+ 5147 FD 74 02         LD (IY+2),H
 322+ 514A FD 72 03         LD (IY+3),D
 323+ 514D FD 70 04         LD (IY+4),B
 324+ 5150
 325+ 5150 DD E5            PUSH IX
 326+ 5152 E1               POP HL
 327+ 5153 C9               RET
 328+ 5154              ; *******************************************************************************************************
 329+ 5154
 330+ 5154              ; *******************************************************************************************************
 331+ 5154              ; function to handle CALL ANIMITEMPTR basic extension
 332+ 5154              ; ANIMITEMPTR ( BYTE id,
 333+ 5154              ;               INT ticks,
 334+ 5154              ;               INT pointer,
 335+ 5154              ; fills animation item data, returns an error if out of bounds
 336+ 5154              ANIMITEMPTR_CMD:
 337+ 5154                  ; opening (
 338+ 5154 CD 94 65     	CALL CHKCHAR
 339+ 5157 28           	DB '('
 340+ 5158              	; get id
 341+ 5158 DD 21 1C 52  	LD IX, GETBYT
 342+ 515C CD 59 01     	CALL CALBAS
 343+ 515F F5               PUSH AF
 344+ 5160                  ; check if out of bounds
 345+ 5160 3C               INC A
 346+ 5161 4F               LD C,A
 347+ 5162 3A DD 4F         LD A,(ANIMITEMNUM)
 348+ 5165 B9               CP C
 349+ 5166 DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 350+ 5169              	; comma
 351+ 5169 CD 94 65     	CALL CHKCHAR
 352+ 516C 2C           	DB ','
 353+ 516D              	; get ticks
 354+ 516D DD 21 2F 54  	LD IX, FRMQNT
 355+ 5171 CD 59 01     	CALL CALBAS
 356+ 5174 D5           	PUSH DE
 357+ 5175              	; comma
 358+ 5175 CD 94 65     	CALL CHKCHAR
 359+ 5178 2C           	DB ','
 360+ 5179              	; get pointer
 361+ 5179 DD 21 2F 54  	LD IX, FRMQNT
 362+ 517D CD 59 01     	CALL CALBAS
 363+ 5180 D5           	PUSH DE
 364+ 5181              	; ending )
 365+ 5181 CD 94 65     	CALL CHKCHAR
 366+ 5184 29           	DB ')'
 367+ 5185              .ENTRY:
 368+ 5185 E5               PUSH HL
 369+ 5186 DD E1            POP IX
 370+ 5188 D9               EXX
 371+ 5189 D1               POP DE ; pointer
 372+ 518A E1               POP HL ; ticks
 373+ 518B D9               EXX
 374+ 518C F1               POP AF
 375+ 518D CD F2 4F         CALL GETnthANIMITEM
 376+ 5190 E5               PUSH HL
 377+ 5191 FD E1            POP IY
 378+ 5193 D9               EXX
 379+ 5194 FD 36 00 01      LD (IY),1 ; type=1
 380+ 5198 FD 75 01         LD (IY+1),L
 381+ 519B FD 74 02         LD (IY+2),H
 382+ 519E FD 73 03         LD (IY+3),E
 383+ 51A1 FD 72 04         LD (IY+4),D
 384+ 51A4
 385+ 51A4 DD E5            PUSH IX
 386+ 51A6 E1               POP HL
 387+ 51A7 C9               RET
 388+ 51A8              ; *******************************************************************************************************
 389+ 51A8
 390+ 51A8              ; *******************************************************************************************************
 391+ 51A8              ; function to handle CALL MAXANIMDEFS basic extension
 392+ 51A8              ; MAXANIMDEFS (BYTE number)
 393+ 51A8              ; sets new number and moves memory buffers as needed
 394+ 51A8              MAXANIMDEFS:
 395+ 51A8              	; opening (
 396+ 51A8 CD 94 65     	CALL CHKCHAR
 397+ 51AB 28           	DB '('
 398+ 51AC              	; get value
 399+ 51AC DD 21 1C 52  	LD IX, GETBYT
 400+ 51B0 CD 59 01     	CALL CALBAS
 401+ 51B3 F5               PUSH AF
 402+ 51B4              	; ending )
 403+ 51B4 CD 94 65     	CALL CHKCHAR
 404+ 51B7 29           	DB ')'
 405+ 51B8 F1               POP AF
 406+ 51B9
 407+ 51B9              	; save position
 408+ 51B9 E5           	PUSH HL
 409+ 51BA              .ENTRY:
 410+ 51BA 47               LD B,A
 411+ 51BB 3A E0 4F         LD A,(ANIMDEFNUM)
 412+ 51BE 90               SUB B
 413+ 51BF CA 64 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 414+ 51C2 FD 21 E4 4F      LD IY,ANIMSPRPTR
 415+ 51C6 FA D2 51         JP M, .INCREASE
 416+ 51C9                  ; new value is lower than previous one
 417+ 51C9 CD DD 51         CALL .SIZEDIFF
 418+ 51CC CD A1 50         CALL MAXANIMITEMS.DECREASE_COMMON
 419+ 51CF C3 52 50         JP MAXANIMITEMS.E1
 420+ 51D2              .INCREASE:
 421+ 51D2 ED 44            NEG
 422+ 51D4 CD DD 51         CALL .SIZEDIFF
 423+ 51D7 CD CD 50         CALL MAXANIMITEMS.INCREASE_COMMON
 424+ 51DA C3 76 50         JP MAXANIMITEMS.E2
 425+ 51DD              .SIZEDIFF:
 426+ 51DD 26 00            LD H,0
 427+ 51DF 6F               LD L,A
 428+ 51E0 CD 81 64         CALL HLx16
 429+ 51E3 78               LD A,B
 430+ 51E4 32 E0 4F         LD (ANIMDEFNUM),A
 431+ 51E7 44               LD B,H
 432+ 51E8 4D               LD C,L
 433+ 51E9 C9               RET ; BC=size difference in bytes
 434+ 51EA              ; *******************************************************************************************************
 435+ 51EA
 436+ 51EA              ; *******************************************************************************************************
 437+ 51EA              ; function to handle CALL ANIMDEF basic extension
 438+ 51EA              ; ANIMITEMPAT ( BYTE id,
 439+ 51EA              ;               BYTE size,
 440+ 51EA              ;               INT[] list )
 441+ 51EA              ; fills animation definition data, returns an error if out of bounds, or invalid type
 442+ 51EA              ANIMDEF:
 443+ 51EA                  ; opening (
 444+ 51EA CD 94 65     	CALL CHKCHAR
 445+ 51ED 28           	DB '('
 446+ 51EE              	; get id
 447+ 51EE DD 21 1C 52  	LD IX, GETBYT
 448+ 51F2 CD 59 01     	CALL CALBAS
 449+ 51F5 F5               PUSH AF
 450+ 51F6                  ; check if out of bounds
 451+ 51F6 3C               INC A
 452+ 51F7 4F               LD C,A
 453+ 51F8 3A E0 4F         LD A,(ANIMDEFNUM)
 454+ 51FB B9               CP C
 455+ 51FC DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 456+ 51FF              	; comma
 457+ 51FF CD 94 65     	CALL CHKCHAR
 458+ 5202 2C           	DB ','
 459+ 5203              	; get size
 460+ 5203 DD 21 1C 52  	LD IX, GETBYT
 461+ 5207 CD 59 01     	CALL CALBAS
 462+ 520A FE 10            CP 16
 463+ 520C D2 B0 65         JP NC, OVERFLOW
 464+ 520F B7               OR A
 465+ 5210 CA B0 65         JP Z, OVERFLOW
 466+ 5213 F5           	PUSH AF
 467+ 5214              	; comma
 468+ 5214 CD 94 65     	CALL CHKCHAR
 469+ 5217 2C           	DB ','
 470+ 5218              	; get pointer to a list of animation items in integer array format
 471+ 5218                  ; get array pointer
 472+ 5218 D1               POP DE
 473+ 5219 D5               PUSH DE
 474+ 521A 3E 02            LD A,2
 475+ 521C 06 01            LD B,1
 476+ 521E CD C1 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 477+ 5221 C5               PUSH BC
 478+ 5222              	; ending )
 479+ 5222 CD 94 65     	CALL CHKCHAR
 480+ 5225 29           	DB ')'
 481+ 5226              .ENTRY:
 482+ 5226 E5               PUSH HL
 483+ 5227 DD E1            POP IX
 484+ 5229 D1               POP DE ; pointer to INT array
 485+ 522A C1               POP BC ; B=item number
 486+ 522B F1               POP AF ; id
 487+ 522C D5               PUSH DE
 488+ 522D CD FB 4F         CALL GETnthANIMDEF
 489+ 5230 D1               POP DE
 490+ 5231 70               LD (HL),B
 491+ 5232              .L1:
 492+ 5232 23               INC HL
 493+ 5233 1A               LD A,(DE)
 494+ 5234 13          > INC DE
 494+ 5235 13          > INC DE
 495+ 5236 77               LD (HL),A
 496+ 5237 10 F9            DJNZ .L1
 497+ 5239 DD E5            PUSH IX
 498+ 523B E1               POP HL
 499+ 523C C9               RET
 500+ 523D              ; *******************************************************************************************************
 501+ 523D
 502+ 523D              ; *******************************************************************************************************
 503+ 523D              ; function to handle CALL MAXANIMSPRS basic extension
 504+ 523D              ; MAXANIMSPRS (BYTE number)
 505+ 523D              ; sets new number and moves memory buffers as needed
 506+ 523D              MAXANIMSPRS:
 507+ 523D              	; opening (
 508+ 523D CD 94 65     	CALL CHKCHAR
 509+ 5240 28           	DB '('
 510+ 5241              	; get value
 511+ 5241 DD 21 1C 52  	LD IX, GETBYT
 512+ 5245 CD 59 01     	CALL CALBAS
 513+ 5248 F5               PUSH AF
 514+ 5249              	; ending )
 515+ 5249 CD 94 65     	CALL CHKCHAR
 516+ 524C 29           	DB ')'
 517+ 524D F1               POP AF
 518+ 524E
 519+ 524E              	; save position
 520+ 524E E5           	PUSH HL
 521+ 524F              .ENTRY:
 522+ 524F 47               LD B,A
 523+ 5250 3A E3 4F         LD A,(ANIMSPRNUM)
 524+ 5253 90               SUB B
 525+ 5254 CA 64 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 526+ 5257 FD 21 E7 4F      LD IY,AUTOSGAMPTR
 527+ 525B FA 67 52         JP M, .INCREASE
 528+ 525E                  ; new value is lower than previous one
 529+ 525E CD 86 52         CALL .SIZEDIFF
 530+ 5261 CD A1 50         CALL MAXANIMITEMS.DECREASE_COMMON
 531+ 5264 C3 5B 50         JP MAXANIMITEMS.E3
 532+ 5267              .INCREASE:
 533+ 5267 ED 44            NEG
 534+ 5269 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 535+ 526A CD 86 52         CALL .SIZEDIFF
 536+ 526D CD CD 50         CALL MAXANIMITEMS.INCREASE_COMMON
 537+ 5270 AF               XOR A
 538+ 5271 ED 42            SBC HL,BC ; location of new stuff
 539+ 5273 F1               POP AF
 540+ 5274 47               LD B,A
 541+ 5275 11 08 00         LD DE,8
 542+ 5278 E5               PUSH HL
 543+ 5279 DD E1            POP IX
 544+ 527B              .L1:
 545+ 527B DD 36 06 00      LD (IX+6),0
 546+ 527F DD 19            ADD IX,DE
 547+ 5281 10 F8            DJNZ .L1
 548+ 5283 C3 7D 50         JP MAXANIMITEMS.E4
 549+ 5286              .SIZEDIFF:
 550+ 5286 26 00            LD H,0
 551+ 5288 6F               LD L,A
 552+ 5289 CD 82 64         CALL HLx8
 553+ 528C 78               LD A,B
 554+ 528D 32 E3 4F         LD (ANIMSPRNUM),A
 555+ 5290 44               LD B,H
 556+ 5291 4D               LD C,L
 557+ 5292 C9               RET ; BC=size difference in bytes
 558+ 5293              ; *******************************************************************************************************
 559+ 5293
 560+ 5293              ; *******************************************************************************************************
 561+ 5293              ; function to handle CALL ANIMSPRITE basic extension
 562+ 5293              ; ANIMSPRITE ( BYTE id,
 563+ 5293              ;              BYTE sprite_number,
 564+ 5293              ;              BYTE animation_definition_id,
 565+ 5293              ;              BYTE cyclic_flag )
 566+ 5293              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 567+ 5293              ANIMSPRITE:
 568+ 5293                  ; opening (
 569+ 5293 CD 94 65     	CALL CHKCHAR
 570+ 5296 28           	DB '('
 571+ 5297              	; get sprite animation id
 572+ 5297 DD 21 1C 52  	LD IX, GETBYT
 573+ 529B CD 59 01     	CALL CALBAS
 574+ 529E F5               PUSH AF
 575+ 529F 3C               INC A
 576+ 52A0 4F               LD C,A
 577+ 52A1 3A E3 4F         LD A,(ANIMSPRNUM)
 578+ 52A4 B9               CP C
 579+ 52A5 DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 580+ 52A8              	; comma
 581+ 52A8 CD 94 65     	CALL CHKCHAR
 582+ 52AB 2C           	DB ','
 583+ 52AC              	; get sprite number
 584+ 52AC DD 21 1C 52  	LD IX, GETBYT
 585+ 52B0 CD 59 01     	CALL CALBAS
 586+ 52B3 F5               PUSH AF
 587+ 52B4                  ; check if out of bounds
 588+ 52B4 FE 20            CP 32
 589+ 52B6 D2 AC 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 590+ 52B9              	; comma
 591+ 52B9 CD 94 65     	CALL CHKCHAR
 592+ 52BC 2C           	DB ','
 593+ 52BD              	; get animation definition id
 594+ 52BD DD 21 1C 52  	LD IX, GETBYT
 595+ 52C1 CD 59 01     	CALL CALBAS
 596+ 52C4 F5               PUSH AF
 597+ 52C5 3C               INC A
 598+ 52C6 4F               LD C,A
 599+ 52C7 3A E0 4F         LD A,(ANIMDEFNUM)
 600+ 52CA B9               CP C
 601+ 52CB DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 602+ 52CE              	; comma
 603+ 52CE CD 94 65     	CALL CHKCHAR
 604+ 52D1 2C           	DB ','
 605+ 52D2              	; get cyclic flag
 606+ 52D2 DD 21 1C 52  	LD IX, GETBYT
 607+ 52D6 CD 59 01         CALL CALBAS
 608+ 52D9 F5           	PUSH AF
 609+ 52DA              	; ending )
 610+ 52DA CD 94 65     	CALL CHKCHAR
 611+ 52DD 29           	DB ')'
 612+ 52DE              .ENTRY:
 613+ 52DE E5               PUSH HL
 614+ 52DF DD E1            POP IX
 615+ 52E1 D9               EXX
 616+ 52E2 D1               POP DE ; cyclic
 617+ 52E3 C1               POP BC ; animation definition id
 618+ 52E4 E1               POP HL ; sprite number
 619+ 52E5 D9               EXX
 620+ 52E6 F1               POP AF ; sprite animation id
 621+ 52E7 CD 07 50         CALL GETnthSPRANIM
 622+ 52EA E5               PUSH HL
 623+ 52EB FD E1            POP IY
 624+ 52ED D9               EXX
 625+ 52EE FD 74 00         LD (IY),H
 626+ 52F1 FD 70 04         LD (IY+4),B
 627+ 52F4 FD 72 05         LD (IY+5),D
 628+ 52F7                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 629+ 52F7                  ; following will do preparation for ANIMSTEP situation
 630+ 52F7                  ; current item set to above limit and timer to 1
 631+ 52F7                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 632+ 52F7 FD 36 03 FF      LD (IY+3),255
 633+ 52FB FD 36 01 01      LD (IY+1),1
 634+ 52FF FD 36 02 00      LD (IY+2),0
 635+ 5303                  ; mark as sprite animation
 636+ 5303 FD 36 07 00      LD (IY+7),0
 637+ 5307 DD E5            PUSH IX
 638+ 5309 E1               POP HL
 639+ 530A C9               RET
 640+ 530B              ; *******************************************************************************************************
 641+ 530B
 642+ 530B              ; *******************************************************************************************************
 643+ 530B              ; function to handle CALL ANIMCHAR basic extension
 644+ 530B              ; ANIMCHAR ( BYTE id,
 645+ 530B              ;            INT character number 0-767,
 646+ 530B              ;            BYTE animation_definition_id,
 647+ 530B              ;            BYTE cyclic_flag )
 648+ 530B              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 649+ 530B              ANIMCHAR:
 650+ 530B                  ; opening (
 651+ 530B CD 94 65     	CALL CHKCHAR
 652+ 530E 28           	DB '('
 653+ 530F              	; get sprite animation id
 654+ 530F DD 21 1C 52  	LD IX, GETBYT
 655+ 5313 CD 59 01     	CALL CALBAS
 656+ 5316 F5               PUSH AF
 657+ 5317 3C               INC A
 658+ 5318 4F               LD C,A
 659+ 5319 3A E3 4F         LD A,(ANIMSPRNUM)
 660+ 531C B9               CP C
 661+ 531D DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 662+ 5320              	; comma
 663+ 5320 CD 94 65     	CALL CHKCHAR
 664+ 5323 2C           	DB ','
 665+ 5324              	; get character number
 666+ 5324 DD 21 2F 54  	LD IX, FRMQNT
 667+ 5328 CD 59 01     	CALL CALBAS
 668+ 532B D5               PUSH DE
 669+ 532C                  ; check if out of bounds
 670+ 532C 7A               LD A,D
 671+ 532D FE 03            CP 3
 672+ 532F D2 AC 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 673+ 5332              	; comma
 674+ 5332 CD 94 65     	CALL CHKCHAR
 675+ 5335 2C           	DB ','
 676+ 5336              	; get animation definition id
 677+ 5336 DD 21 1C 52  	LD IX, GETBYT
 678+ 533A CD 59 01     	CALL CALBAS
 679+ 533D F5               PUSH AF
 680+ 533E 3C               INC A
 681+ 533F 4F               LD C,A
 682+ 5340 3A E0 4F         LD A,(ANIMDEFNUM)
 683+ 5343 B9               CP C
 684+ 5344 DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 685+ 5347              	; comma
 686+ 5347 CD 94 65     	CALL CHKCHAR
 687+ 534A 2C           	DB ','
 688+ 534B              	; get cyclic flag
 689+ 534B DD 21 1C 52  	LD IX, GETBYT
 690+ 534F CD 59 01         CALL CALBAS
 691+ 5352 F5           	PUSH AF
 692+ 5353              	; ending )
 693+ 5353 CD 94 65     	CALL CHKCHAR
 694+ 5356 29           	DB ')'
 695+ 5357              .ENTRY:
 696+ 5357 E5               PUSH HL
 697+ 5358 DD E1            POP IX
 698+ 535A D9               EXX
 699+ 535B D1               POP DE ; cyclic
 700+ 535C C1               POP BC ; animation definition id
 701+ 535D E1               POP HL ; character number
 702+ 535E D9               EXX
 703+ 535F F1               POP AF ; sprite animation id
 704+ 5360 CD 07 50         CALL GETnthSPRANIM
 705+ 5363 E5               PUSH HL
 706+ 5364 FD E1            POP IY
 707+ 5366 D9               EXX
 708+ 5367 FD 75 00         LD (IY),L
 709+ 536A 24               INC H ; save character bank+1
 710+ 536B FD 74 07         LD (IY+7),H
 711+ 536E FD 70 04         LD (IY+4),B
 712+ 5371 FD 72 05         LD (IY+5),D
 713+ 5374                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 714+ 5374                  ; following will do preparation for ANIMSTEP situation
 715+ 5374                  ; current item set to above limit and timer to 1
 716+ 5374                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 717+ 5374 FD 36 03 FF      LD (IY+3),255
 718+ 5378 FD 36 01 01      LD (IY+1),1
 719+ 537C FD 36 02 00      LD (IY+2),0
 720+ 5380 DD E5            PUSH IX
 721+ 5382 E1               POP HL
 722+ 5383 C9               RET
 723+ 5384              ; *******************************************************************************************************
 724+ 5384
 725+ 5384              ; *******************************************************************************************************
 726+ 5384              ; function to handle CALL MAXAUTOSGAMS basic extension
 727+ 5384              ; MAXAUTOSGAMS (BYTE number)
 728+ 5384              ; sets new number and moves memory buffers as needed
 729+ 5384              MAXAUTOSGAMS:
 730+ 5384              	; opening (
 731+ 5384 CD 94 65     	CALL CHKCHAR
 732+ 5387 28           	DB '('
 733+ 5388              	; get value
 734+ 5388 DD 21 1C 52  	LD IX, GETBYT
 735+ 538C CD 59 01     	CALL CALBAS
 736+ 538F F5               PUSH AF
 737+ 5390              	; ending )
 738+ 5390 CD 94 65     	CALL CHKCHAR
 739+ 5393 29           	DB ')'
 740+ 5394 F1               POP AF
 741+ 5395
 742+ 5395              	; save position
 743+ 5395 E5           	PUSH HL
 744+ 5396              .ENTRY:
 745+ 5396 47               LD B,A
 746+ 5397 3A E6 4F         LD A,(AUTOSGAMNUM)
 747+ 539A 90               SUB B
 748+ 539B CA 64 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 749+ 539E FD 21 10 40      LD IY,FREEMEMPTR
 750+ 53A2 FA AE 53         JP M, .INCREASE
 751+ 53A5                  ; new value is lower than previous one
 752+ 53A5 CD CD 53         CALL .SIZEDIFF
 753+ 53A8 CD A1 50         CALL MAXANIMITEMS.DECREASE_COMMON
 754+ 53AB C3 64 50         JP MAXANIMITEMS.EXIT
 755+ 53AE              .INCREASE:
 756+ 53AE ED 44            NEG
 757+ 53B0 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 758+ 53B1 CD CD 53         CALL .SIZEDIFF
 759+ 53B4 CD CD 50         CALL MAXANIMITEMS.INCREASE_COMMON
 760+ 53B7 AF               XOR A
 761+ 53B8 ED 42            SBC HL,BC ; location of new stuff
 762+ 53BA F1               POP AF
 763+ 53BB 47               LD B,A
 764+ 53BC 11 18 00         LD DE,24
 765+ 53BF E5               PUSH HL
 766+ 53C0 DD E1            POP IX
 767+ 53C2              .L1:
 768+ 53C2 DD 36 13 00      LD (IX+19),0 ; active flag
 769+ 53C6 DD 19            ADD IX,DE
 770+ 53C8 10 F8            DJNZ .L1
 771+ 53CA C3 64 50         JP MAXANIMITEMS.EXIT
 772+ 53CD              .SIZEDIFF:
 773+ 53CD 26 00            LD H,0
 774+ 53CF 6F               LD L,A
 775+ 53D0 CD 82 64         CALL HLx8
 776+ 53D3 54               LD D,H
 777+ 53D4 5D               LD E,L
 778+ 53D5 29               ADD HL,HL
 779+ 53D6 19               ADD HL,DE
 780+ 53D7 78               LD A,B
 781+ 53D8 32 E6 4F         LD (AUTOSGAMNUM),A
 782+ 53DB 44               LD B,H
 783+ 53DC 4D               LD C,L
 784+ 53DD C9               RET ; BC=size difference in bytes
 785+ 53DE              ; *******************************************************************************************************
 786+ 53DE
 787+ 53DE              ; *******************************************************************************************************
 788+ 53DE              ; function to handle CALL AUTOSGAMDEF basic extension
 789+ 53DE              ; AUTOSGAMDEF ( BYTE id,
 790+ 53DE              ;               INT VARIABLE x, INT VARIABLE y,
 791+ 53DE              ;               INT minimum, INT maximum, INT delta,
 792+ 53DE              ;               INT direction,
 793+ 53DE              ;               INT ticks,
 794+ 53DE              ;               BYTE sprite_group_count,
 795+ 53DE              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
 796+ 53DE              ;               BYTE item_number,
 797+ 53DE              ;               INT[] VARIABLE sprite_animations_negative_direction,
 798+ 53DE              ;               INT[] VARIABLE sprite_animations_positive_direction
 799+ 53DE              AUTOSGAMDEF:
 800+ 53DE                  ; opening (
 801+ 53DE CD 94 65     	CALL CHKCHAR
 802+ 53E1 28           	DB '('
 803+ 53E2              	; get sprite animation id
 804+ 53E2 DD 21 1C 52  	LD IX, GETBYT
 805+ 53E6 CD 59 01     	CALL CALBAS
 806+ 53E9 F5               PUSH AF
 807+ 53EA 3C               INC A
 808+ 53EB 4F               LD C,A
 809+ 53EC 3A E6 4F         LD A,(AUTOSGAMNUM)
 810+ 53EF B9               CP C
 811+ 53F0 DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 812+ 53F3 F1               POP AF
 813+ 53F4 E5               PUSH HL
 814+ 53F5 CD 13 50         CALL GETnthAUTOSGAM
 815+ 53F8 22 82 62         LD (BLIT_TMP),HL ; for later
 816+ 53FB E1               POP HL
 817+ 53FC              	; comma
 818+ 53FC CD 94 65     	CALL CHKCHAR
 819+ 53FF 2C           	DB ','
 820+ 5400              	; get address of the X coordinate variable
 821+ 5400 DD 21 A4 5E  	LD IX, PTRGET
 822+ 5404 CD 59 01     	CALL CALBAS
 823+ 5407 DD 2A 82 62  	LD IX,(BLIT_TMP)
 824+ 540B DD 73 00         LD (IX+0),E
 825+ 540E DD 72 01         LD (IX+1),D
 826+ 5411              	; comma
 827+ 5411 CD 94 65     	CALL CHKCHAR
 828+ 5414 2C           	DB ','
 829+ 5415              	; get address of the Y coordinate variable
 830+ 5415 DD 21 A4 5E  	LD IX, PTRGET
 831+ 5419 CD 59 01     	CALL CALBAS
 832+ 541C DD 2A 82 62  	LD IX,(BLIT_TMP)
 833+ 5420 DD 73 02         LD (IX+2),E
 834+ 5423 DD 72 03         LD (IX+3),D
 835+ 5426              	; comma
 836+ 5426 CD 94 65     	CALL CHKCHAR
 837+ 5429 2C           	DB ','
 838+ 542A              	; get minimum value
 839+ 542A DD 21 2F 54  	LD IX, FRMQNT
 840+ 542E CD 59 01     	CALL CALBAS
 841+ 5431 DD 2A 82 62  	LD IX,(BLIT_TMP)
 842+ 5435 DD 73 04         LD (IX+4),E
 843+ 5438 DD 72 05         LD (IX+5),D
 844+ 543B              	; comma
 845+ 543B CD 94 65     	CALL CHKCHAR
 846+ 543E 2C           	DB ','
 847+ 543F              	; get maximum value
 848+ 543F DD 21 2F 54  	LD IX, FRMQNT
 849+ 5443 CD 59 01     	CALL CALBAS
 850+ 5446 DD 2A 82 62  	LD IX,(BLIT_TMP)
 851+ 544A DD 73 06         LD (IX+6),E
 852+ 544D DD 72 07         LD (IX+7),D
 853+ 5450              	; comma
 854+ 5450 CD 94 65     	CALL CHKCHAR
 855+ 5453 2C           	DB ','
 856+ 5454              	; get delta value
 857+ 5454 DD 21 2F 54  	LD IX, FRMQNT
 858+ 5458 CD 59 01     	CALL CALBAS
 859+ 545B DD 2A 82 62  	LD IX,(BLIT_TMP)
 860+ 545F DD 73 08         LD (IX+8),E
 861+ 5462 DD 72 09         LD (IX+9),D
 862+ 5465              	; comma
 863+ 5465 CD 94 65     	CALL CHKCHAR
 864+ 5468 2C           	DB ','
 865+ 5469              	; get direction value
 866+ 5469 DD 21 2F 54  	LD IX, FRMQNT
 867+ 546D CD 59 01     	CALL CALBAS
 868+ 5470 DD 2A 82 62  	LD IX,(BLIT_TMP)
 869+ 5474 DD 73 0A         LD (IX+10),E
 870+ 5477 DD 72 0B         LD (IX+11),D
 871+ 547A              	; comma
 872+ 547A CD 94 65     	CALL CHKCHAR
 873+ 547D 2C           	DB ','
 874+ 547E              	; get ticks value
 875+ 547E DD 21 2F 54  	LD IX, FRMQNT
 876+ 5482 CD 59 01     	CALL CALBAS
 877+ 5485 DD 2A 82 62  	LD IX,(BLIT_TMP)
 878+ 5489 DD 73 14         LD (IX+20),E
 879+ 548C DD 72 15         LD (IX+21),D
 880+ 548F              	; comma
 881+ 548F CD 94 65     	CALL CHKCHAR
 882+ 5492 2C           	DB ','
 883+ 5493              	; get sprite group count
 884+ 5493 DD 21 1C 52  	LD IX, GETBYT
 885+ 5497 CD 59 01     	CALL CALBAS
 886+ 549A B7               OR A
 887+ 549B CA AC 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 888+ 549E DD 2A 82 62  	LD IX,(BLIT_TMP)
 889+ 54A2 DD 77 0B         LD (IX+11),A
 890+ 54A5              	; comma
 891+ 54A5 CD 94 65     	CALL CHKCHAR
 892+ 54A8 2C           	DB ','
 893+ 54A9              	; get sprite group definition array data pointer
 894+ 54A9 DD 2A 82 62  	LD IX,(BLIT_TMP)
 895+ 54AD DD 5E 0B         LD E,(IX+11)
 896+ 54B0 16 03        	LD D,3
 897+ 54B2 3E 02        	LD A,2
 898+ 54B4 47           	LD B,A
 899+ 54B5 CD C1 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 900+ 54B8 DD 2A 82 62  	LD IX,(BLIT_TMP)
 901+ 54BC DD 71 0C     	LD (IX+12),C
 902+ 54BF DD 70 0D         LD (IX+13),B
 903+ 54C2              	; comma
 904+ 54C2 CD 94 65     	CALL CHKCHAR
 905+ 54C5 2C           	DB ','
 906+ 54C6              	; get sprite animation array size
 907+ 54C6 DD 21 1C 52  	LD IX,GETBYT
 908+ 54CA CD 59 01     	CALL CALBAS
 909+ 54CD DD 2A 82 62  	LD IX,(BLIT_TMP)
 910+ 54D1 DD 77 0E         LD (IX+14),A
 911+ 54D4 B7               OR A
 912+ 54D5 CA AC 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 913+ 54D8              	; comma
 914+ 54D8 CD 94 65     	CALL CHKCHAR
 915+ 54DB 2C           	DB ','
 916+ 54DC                  ; get array pointer for negative direction
 917+ 54DC DD 2A 82 62  	LD IX,(BLIT_TMP)
 918+ 54E0 DD 56 0E         LD D,(IX+14)
 919+ 54E3 3E 02            LD A,2
 920+ 54E5 06 01            LD B,1
 921+ 54E7 CD C1 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 922+ 54EA DD 2A 82 62  	LD IX,(BLIT_TMP)
 923+ 54EE DD 71 0F         LD (IX+15),C
 924+ 54F1 DD 70 10         LD (IX+16),B
 925+ 54F4              	; comma
 926+ 54F4 CD 94 65     	CALL CHKCHAR
 927+ 54F7 2C           	DB ','
 928+ 54F8                  ; get array pointer for positive direction
 929+ 54F8 DD 2A 82 62  	LD IX,(BLIT_TMP)
 930+ 54FC DD 56 0E         LD D,(IX+14)
 931+ 54FF 3E 02            LD A,2
 932+ 5501 06 01            LD B,1
 933+ 5503 CD C1 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 934+ 5506 DD 2A 82 62  	LD IX,(BLIT_TMP)
 935+ 550A DD 71 11         LD (IX+17),C
 936+ 550D DD 70 12         LD (IX+18),B
 937+ 5510              	; ending )
 938+ 5510 CD 94 65     	CALL CHKCHAR
 939+ 5513 29           	DB ')'
 940+ 5514 C9               RET
 941+ 5515              ; *******************************************************************************************************
 942+ 5515
 943+ 5515              ; *******************************************************************************************************
 944+ 5515              ; function to handle CALL AUTOSGAMSTART basic extension
 945+ 5515              ; AUTOSGAMSTART ( BYTE id )
 946+ 5515              AUTOSGAMSTART:
 947+ 5515 3E 01            LD A,1
 948+ 5517              .COMMON:
 949+ 5517 32 43 55         LD (.SETVALUE+3),A
 950+ 551A                  ; opening (
 951+ 551A CD 94 65     	CALL CHKCHAR
 952+ 551D 28           	DB '('
 953+ 551E              	; get sprite animation id
 954+ 551E DD 21 1C 52  	LD IX, GETBYT
 955+ 5522 CD 59 01     	CALL CALBAS
 956+ 5525 F5               PUSH AF
 957+ 5526 3C               INC A
 958+ 5527 4F               LD C,A
 959+ 5528 3A E6 4F         LD A,(AUTOSGAMNUM)
 960+ 552B B9               CP C
 961+ 552C DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 962+ 552F F1               POP AF
 963+ 5530 E5               PUSH HL
 964+ 5531 CD 13 50         CALL GETnthAUTOSGAM
 965+ 5534 E5               PUSH HL
 966+ 5535 DD E1            POP IX
 967+ 5537 E1               POP HL
 968+ 5538 DD E5            PUSH IX
 969+ 553A              	; ending )
 970+ 553A CD 94 65     	CALL CHKCHAR
 971+ 553D 29           	DB ')'
 972+ 553E
 973+ 553E                  ; so syntax is fine
 974+ 553E DD E1            POP IX
 975+ 5540              .SETVALUE:
 976+ 5540 DD 36 13 01      LD (IX+19),1 ; active flag
 977+ 5544                  ; set initial timer
 978+ 5544 DD 7E 14         LD A,(IX+20)
 979+ 5547 DD 77 16         LD (IX+22),A
 980+ 554A DD 7E 15         LD A,(IX+21)
 981+ 554D DD 77 17         LD (IX+23),A
 982+ 5550 C9               RET
 983+ 5551              ; *******************************************************************************************************
 984+ 5551
 985+ 5551              ; *******************************************************************************************************
 986+ 5551              ; function to handle CALL AUTOSGAMSTOP basic extension
 987+ 5551              ; AUTOSGAMSTOP ( BYTE id )
 988+ 5551              AUTOSGAMSTOP:
 989+ 5551 AF               XOR A
 990+ 5552 18 C3            JR AUTOSGAMSTART.COMMON
 991+ 5554              ; *******************************************************************************************************
 992+ 5554
 993+ 5554              ; *******************************************************************************************************
 994+ 5554              ; function to handle CALL ANIMSTEP basic extension
 995+ 5554              ; two forms
 996+ 5554              ; ANIMSTEP ( BYTE id )
 997+ 5554              ; or
 998+ 5554              ; ANIMSTEP ( BYTE item_number,
 999+ 5554              ;            INT[] sprite_animations )
1000+ 5554              ; sets active flag to 1
1001+ 5554              ANIMSTEP:
1002+ 5554 11 D1 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1003+ 5557 18 08            JR ANIMSTARTSTOP_COMMON
1004+ 5559              ; *******************************************************************************************************
1005+ 5559              ; *******************************************************************************************************
1006+ 5559              ; function to handle CALL ANIMSTART basic extension
1007+ 5559              ; two forms
1008+ 5559              ; ANIMSTART ( BYTE id )
1009+ 5559              ; or
1010+ 5559              ; ANIMSTART ( BYTE item_number,
1011+ 5559              ;             INT[] sprite_animations )
1012+ 5559              ; sets active flag to 1
1013+ 5559              ANIMSTART:
1014+ 5559 11 BF 55         LD DE,ANIMSTARTSTOP_COMMON.START
1015+ 555C 18 03            JR ANIMSTARTSTOP_COMMON
1016+ 555E              ; *******************************************************************************************************
1017+ 555E              ; *******************************************************************************************************
1018+ 555E              ; function to handle CALL ANIMSTOP basic extension
1019+ 555E              ; two forms
1020+ 555E              ; ANIMSTOP ( BYTE id )
1021+ 555E              ; or
1022+ 555E              ; ANIMSTOP ( BYTE item_number,
1023+ 555E              ;            INT[] sprite_animations )
1024+ 555E              ; sets active flag to 1
1025+ 555E              ANIMSTOP:
1026+ 555E 11 CC 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1027+ 5561              ; *******************************************************************************************************
1028+ 5561              ANIMSTARTSTOP_COMMON:
1029+ 5561 ED 53 BD 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1030+ 5565                  ; opening (
1031+ 5565 CD 94 65     	CALL CHKCHAR
1032+ 5568 28           	DB '('
1033+ 5569              	; get sprite animation id or array size
1034+ 5569 DD 21 1C 52  	LD IX,GETBYT
1035+ 556D CD 59 01     	CALL CALBAS
1036+ 5570 F5               PUSH AF
1037+ 5571                  ; check if comma present
1038+ 5571 CD 9E 65         CALL GETPREVCHAR
1039+ 5574 23               INC HL
1040+ 5575 FE 2C            CP ','
1041+ 5577 28 0C            JR Z,.L1
1042+ 5579 FE 29            CP ')'
1043+ 557B C2 B8 65         JP NZ,SYNTAX_ERROR
1044+ 557E                  ; ok so single argument variant
1045+ 557E F1               POP AF
1046+ 557F E5               PUSH HL
1047+ 5580 CD AB 55         CALL .SETVALUE
1048+ 5583 E1               POP HL
1049+ 5584 C9               RET
1050+ 5585              .L1:
1051+ 5585                  ; get array pointer
1052+ 5585 D1               POP DE
1053+ 5586 D5               PUSH DE
1054+ 5587 3E 02            LD A,2
1055+ 5589 06 01            LD B,1
1056+ 558B CD C1 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1057+ 558E C5               PUSH BC
1058+ 558F              	; ending )
1059+ 558F CD 94 65     	CALL CHKCHAR
1060+ 5592 29           	DB ')'
1061+ 5593 D1               POP DE ; array pointer
1062+ 5594 C1               POP BC ; number of items
1063+ 5595 78               LD A,B
1064+ 5596 B7               OR A
1065+ 5597 CA AC 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1066+ 559A E5               PUSH HL
1067+ 559B F3               DI
1068+ 559C              .L2:
1069+ 559C C5               PUSH BC
1070+ 559D 1A               LD A,(DE)
1071+ 559E 13          > INC DE
1071+ 559F 13          > INC DE
1072+ 55A0 D5               PUSH DE
1073+ 55A1 CD AB 55         CALL .SETVALUE
1074+ 55A4 D1               POP DE
1075+ 55A5 C1               POP BC
1076+ 55A6 10 F4            DJNZ .L2
1077+ 55A8 FB               EI
1078+ 55A9 E1               POP HL
1079+ 55AA C9               RET
1080+ 55AB
1081+ 55AB              .SETVALUE:
1082+ 55AB 47               LD B,A
1083+ 55AC 3C               INC A
1084+ 55AD 4F               LD C,A
1085+ 55AE 3A E3 4F         LD A,(ANIMSPRNUM)
1086+ 55B1 B9               CP C
1087+ 55B2 DA AC 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1088+ 55B5 78               LD A,B
1089+ 55B6 CD 07 50         CALL GETnthSPRANIM
1090+ 55B9 E5               PUSH HL
1091+ 55BA DD E1            POP IX
1092+ 55BC              .FN:
1093+ 55BC C3 00 00         JP 0
1094+ 55BF              .START:
1095+ 55BF DD 36 06 01      LD (IX+6),1 ; active flag
1096+ 55C3 DD 36 03 00      LD (IX+3),0 ; current item
1097+ 55C7 06 00            LD B,0 ; setup timer
1098+ 55C9 C3 50 56         JP SETUP_ANIM_STEP
1099+ 55CC              .STOP:
1100+ 55CC DD 36 06 00      LD (IX+6),0 ; active flag
1101+ 55D0 C9               RET
1102+ 55D1              .STEP:
1103+ 55D1 06 00            LD B,0
1104+ 55D3 C3 F4 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1105+ 55D6              ; *******************************************************************************************************
1106+ 55D6
1107+ 55D6              ; *******************************************************************************************************
1108+ 55D6              ; function processes animations during vblank period
1109+ 55D6              PROCESS_ANIMATIONS:
1110+ 55D6 3A E3 4F         LD A,(ANIMSPRNUM)
1111+ 55D9 B7               OR A
1112+ 55DA C8               RET Z; no animations defined
1113+ 55DB 47               LD B,A
1114+ 55DC DD 2A E4 4F      LD IX,(ANIMSPRPTR)
1115+ 55E0              .L1:
1116+ 55E0 C5               PUSH BC
1117+ 55E1 06 00            LD B,0 ; normal mode, change on timer expiry only
1118+ 55E3 CD EF 55         CALL PROCESS_SINGLE_ANIMATION
1119+ 55E6 11 08 00         LD DE,8
1120+ 55E9 DD 19            ADD IX,DE
1121+ 55EB C1               POP BC
1122+ 55EC 10 F2            DJNZ .L1
1123+ 55EE C9               RET
1124+ 55EF              ; *******************************************************************************************************
1125+ 55EF
1126+ 55EF              ; *******************************************************************************************************
1127+ 55EF              ; processes single sprite animation
1128+ 55EF              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1129+ 55EF              ; on timer expiry goes to next animation item
1130+ 55EF              ; input IX=sprite animation pointer
1131+ 55EF              ; input B=1 force mode, activate animation action regardless of expired timer
1132+ 55EF              PROCESS_SINGLE_ANIMATION:
1133+ 55EF DD 7E 06         LD A,(IX+6); active
1134+ 55F2 B7               OR A
1135+ 55F3 C8               RET Z ; inactive animation
1136+ 55F4              .INACTIVE_TOO:
1137+ 55F4 DD 6E 01         LD L,(IX+1)
1138+ 55F7 DD 66 02         LD H,(IX+2) ; HL=end time
1139+ 55FA 2B               DEC HL
1140+ 55FB DD 75 01         LD (IX+1),L
1141+ 55FE DD 74 02         LD (IX+2),H
1142+ 5601 7D               LD A,L
1143+ 5602 B4               OR H
1144+ 5603 28 06            JR Z,.STEP
1145+ 5605 05               DEC B
1146+ 5606 04               INC B
1147+ 5607 C8               RET Z ; not forced mode, return
1148+ 5608 C3 50 56         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1149+ 560B              .STEP:
1150+ 560B 06 00            LD B,0; setup timer
1151+ 560D DD 34 03         INC (IX+3) ; current animation item
1152+ 5610 C3 50 56         JP SETUP_ANIM_STEP
1153+ 5613              ; *******************************************************************************************************
1154+ 5613
1155+ 5613              ; *******************************************************************************************************
1156+ 5613              ; function will setup sprite animation after current item change
1157+ 5613              ; input A=current animation definition
1158+ 5613              ; input IX=pointer to sprite animation
1159+ 5613              ; input B=1 skip timer setup
1160+ 5613              ; output IY=pointer to animation item
1161+ 5613              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1162+ 5613              ; basically sets new end time for current animation
1163+ 5613              INIT_CURRENT_ANIMATION:
1164+ 5613 CD FB 4F         CALL GETnthANIMDEF
1165+ 5616 DD 7E 03         LD A,(IX+3) ; current animation item
1166+ 5619 BE               CP (HL) ; number of animation items in the animation definition
1167+ 561A 38 0A            JR C,.L3 ; last item not reached
1168+ 561C                  ; last item reached
1169+ 561C DD 7E 05         LD A,(IX+5) ; cyclic flag
1170+ 561F B7               OR A
1171+ 5620 28 2C            JR Z,.ERROR ; non-cyclic animation
1172+ 5622                  ; cyclic animation, restart
1173+ 5622 DD 36 03 00      LD (IX+3),0; current item
1174+ 5626              .L3:
1175+ 5626                  ; HL = animation definition
1176+ 5626 23               INC HL ; skip animation definition size field
1177+ 5627 16 00            LD D,0
1178+ 5629 DD 5E 03         LD E,(IX+3); current item
1179+ 562C 19               ADD HL,DE
1180+ 562D 4E               LD C,(HL) ; current animation item
1181+ 562E 0C               INC C
1182+ 562F 3A DD 4F         LD A,(ANIMITEMNUM)
1183+ 5632 B9               CP C
1184+ 5633 38 19            JR C,.ERROR ; invalid animation item, stop animation
1185+ 5635 0D               DEC C
1186+ 5636 79               LD A,C
1187+ 5637 CD F2 4F         CALL GETnthANIMITEM
1188+ 563A E5               PUSH HL
1189+ 563B FD E1            POP IY ; IY=animation item
1190+ 563D 05               DEC B
1191+ 563E 28 0C            JR Z,.EXIT
1192+ 5640 FD 5E 01         LD E,(IY+1)
1193+ 5643 FD 56 02         LD D,(IY+2) ; duration
1194+ 5646 DD 73 01         LD (IX+1),E
1195+ 5649 DD 72 02         LD (IX+2),D
1196+ 564C              .EXIT:
1197+ 564C AF               XOR A
1198+ 564D C9               RET
1199+ 564E              .ERROR:
1200+ 564E 37               SCF
1201+ 564F C9               RET
1202+ 5650              ; *******************************************************************************************************
1203+ 5650
1204+ 5650              ; *******************************************************************************************************
1205+ 5650              ; function will display currect item and set up expiry time
1206+ 5650              ; it will also stop the animation if expired
1207+ 5650              ; sets sprite update flag if any changes in sprite data made
1208+ 5650              ; input IX=current sprite animation
1209+ 5650              ; input B=1 skip timer setup
1210+ 5650              SETUP_ANIM_STEP:
1211+ 5650 DD 4E 04         LD C,(IX+4) ; animation definition ID
1212+ 5653 0C               INC C
1213+ 5654 3A E0 4F         LD A,(ANIMDEFNUM)
1214+ 5657 B9               CP C
1215+ 5658 30 05            JR NC,.L2
1216+ 565A                  ; given animation item is outside of bounds, deactivate animation
1217+ 565A              .STOPANIM:
1218+ 565A DD 36 06 00      LD (IX+6),0
1219+ 565E C9               RET
1220+ 565F              .L2:
1221+ 565F 0D               DEC C
1222+ 5660 79               LD A,C
1223+ 5661 CD 13 56         CALL INIT_CURRENT_ANIMATION
1224+ 5664 38 F4            JR C, .STOPANIM
1225+ 5666 FD 7E 00         LD A,(IY) ; type of animation item
1226+ 5669 B7               OR A
1227+ 566A 28 44            JR Z,.L4 ; change pattern and/or color
1228+ 566C              .PAT:
1229+ 566C                  ; change pattern definition
1230+ 566C                  ; check if sprite or character
1231+ 566C DD 7E 07         LD A,(IX+7)
1232+ 566F B7               OR A
1233+ 5670 20 58            JR NZ,.CHAR
1234+ 5672 DD 7E 00         LD A,(IX) ; sprite number
1235+ 5675 CD 85 4D         CALL GETnthSPRATTR
1236+ 5678 23          > INC HL ; skip y and x
1236+ 5679 23          > INC HL
1236+ 567A 23          > INC HL
1236+ 567B 23          > INC HL
1237+ 567C 7E               LD A,(HL); current pattern
1238+ 567D 26 00            LD H,0
1239+ 567F 6F               LD L,A
1240+ 5680 3A E0 F3         LD A,(REG1SAV)
1241+ 5683 E6 02            AND 2
1242+ 5685 20 07            JR NZ,.L6
1243+ 5687                  ; 8x8 sprite
1244+ 5687 CD 82 64         CALL HLx8
1245+ 568A 06 08            LD B,8
1246+ 568C 18 05            JR .L5
1247+ 568E              .L6:
1248+ 568E CD 80 64         CALL HLx32
1249+ 5691 06 20            LD B,32
1250+ 5693              .L5:
1251+ 5693 3A AF FC         LD A,(SCRMOD)
1252+ 5696 3D               DEC A
1253+ 5697 20 06            JR NZ,.L10
1254+ 5699 ED 5B C5 F3      LD DE,(T32PAT)
1255+ 569D 18 04            JR .L7
1256+ 569F              .L10:
1257+ 569F ED 5B CF F3      LD DE,(GRPPAT)
1258+ 56A3              .L7:
1259+ 56A3 19               ADD HL,DE
1260+ 56A4 CD 6D 64         CALL SETWRT_LOCAL
1261+ 56A7 FD 6E 03         LD L,(IY+3)
1262+ 56AA FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1263+ 56AD C3 78 64         JP BBYTECOPY
1264+ 56B0              .L4:
1265+ 56B0                  ; change pattern and color in sprite attributes table
1266+ 56B0 DD 7E 00         LD A,(IX) ; sprite number
1267+ 56B3 CD 85 4D         CALL GETnthSPRATTR
1268+ 56B6 23          > INC HL ; skip y and x
1268+ 56B7 23          > INC HL
1268+ 56B8 23          > INC HL
1268+ 56B9 23          > INC HL
1269+ 56BA FD 7E 03         LD A,(IY+3) ; new pattern
1270+ 56BD 77               LD (HL),A
1271+ 56BE 23          > INC HL
1271+ 56BF 23          > INC HL
1272+ 56C0 FD 7E 04         LD A,(IY+4) ; new color
1273+ 56C3 77               LD (HL),A
1274+ 56C4 2A 7D 4D         LD HL,(SPRATR_UPDATE_FLAG)
1275+ 56C7 36 01            LD (HL),1
1276+ 56C9 C9               RET
1277+ 56CA              .CHAR:
1278+ 56CA DD 6E 00         LD L,(IX)
1279+ 56CD 3D               DEC A
1280+ 56CE 67               LD H,A
1281+ 56CF CD 82 64         CALL HLx8
1282+ 56D2 3A AF FC         LD A,(SCRMOD)
1283+ 56D5 3D               DEC A
1284+ 56D6 20 06            JR NZ,.L8
1285+ 56D8 ED 5B C1 F3      LD DE,(T32CGP)
1286+ 56DC 18 04            JR .L9
1287+ 56DE              .L8:
1288+ 56DE ED 5B CB F3      LD DE,(GRPCGP)
1289+ 56E2              .L9:
1290+ 56E2 06 08            LD B,8
1291+ 56E4 18 BD            JR .L7
1292+ 56E6              ; *******************************************************************************************************
1293+ 56E6
# file closed: asm\ANIMATION.asm
 124  56E6               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 56E6              ; Sprite Group Animate and Move
   2+ 56E6
   3+ 56E6              ; *******************************************************************************************************
   4+ 56E6              ; shared function to process a list of animations
   5+ 56E6              ; input B=list size
   6+ 56E6              ; input DE=list pointer
   7+ 56E6              SGAM_PROCESS_ANIM_LIST:
   8+ 56E6 21 F9 56         LD HL,.STEP
   9+ 56E9 22 BD 55         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 56EC              .L1:
  11+ 56EC C5               PUSH BC
  12+ 56ED 1A               LD A,(DE)
  13+ 56EE 13          > INC DE
  13+ 56EF 13          > INC DE
  14+ 56F0 D5               PUSH DE
  15+ 56F1 CD AB 55         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 56F4 D1               POP DE
  17+ 56F5 C1               POP BC
  18+ 56F6 10 F4            DJNZ .L1
  19+ 56F8 C9           	RET
  20+ 56F9              .STEP:
  21+ 56F9 06 01            LD B,1
  22+ 56FB C3 F4 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 56FE              ; *******************************************************************************************************
  24+ 56FE
  25+ 56FE              ; *******************************************************************************************************
  26+ 56FE              ; function to handle CALL SGAM basic extension
  27+ 56FE              ; sets position of a group of sprites as described in SPRGRPMOV
  28+ 56FE              ; and manually animate a list of animations
  29+ 56FE              ; _SGAM ( INT x,
  30+ 56FE              ;	      INT y,
  31+ 56FE              ;		  BYTE count,
  32+ 56FE              ;		  INT[2][count] data_ptr,
  33+ 56FE              ;         BYTE item_number,
  34+ 56FE              ;         INT[] sprite_animations )
  35+ 56FE              ; will put ram in page 0 also, page 1 is already there
  36+ 56FE              SGAM:
  37+ 56FE 3A 7C 4D     	LD A, (SPRATR_INIT_STATUS)
  38+ 5701 B7           	OR A
  39+ 5702 CA B4 65     	JP Z,ILLEGAL_FUNCTION
  40+ 5705              	; opening (
  41+ 5705 CD 94 65     	CALL CHKCHAR
  42+ 5708 28           	DB '('
  43+ 5709              	; get x
  44+ 5709 DD 21 2F 54  	LD IX, FRMQNT
  45+ 570D CD 59 01     	CALL CALBAS
  46+ 5710 ED 53 86 62  	LD (BLIT_STRUCT),DE
  47+ 5714              	; comma
  48+ 5714 CD 94 65     	CALL CHKCHAR
  49+ 5717 2C           	DB ','
  50+ 5718              	; get y
  51+ 5718 DD 21 2F 54  	LD IX, FRMQNT
  52+ 571C CD 59 01     	CALL CALBAS
  53+ 571F ED 53 88 62  	LD (BLIT_STRUCT+2),DE
  54+ 5723              	; comma
  55+ 5723 CD 94 65     	CALL CHKCHAR
  56+ 5726 2C           	DB ','
  57+ 5727              	; get count
  58+ 5727 DD 21 1C 52  	LD IX, GETBYT
  59+ 572B CD 59 01     	CALL CALBAS
  60+ 572E B7               OR A
  61+ 572F CA AC 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  62+ 5732 32 8A 62     	LD (BLIT_STRUCT+4),A
  63+ 5735              	; comma
  64+ 5735 CD 94 65     	CALL CHKCHAR
  65+ 5738 2C           	DB ','
  66+ 5739              	; get sprite group definition array data pointer
  67+ 5739 3A 8A 62         LD A,(BLIT_STRUCT+4)
  68+ 573C 5F           	LD E,A
  69+ 573D 16 03        	LD D,3
  70+ 573F 3E 02        	LD A,2
  71+ 5741 47           	LD B,A
  72+ 5742 CD C1 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
  73+ 5745 ED 43 8B 62  	LD (BLIT_STRUCT+5),BC
  74+ 5749              	; comma
  75+ 5749 CD 94 65     	CALL CHKCHAR
  76+ 574C 2C           	DB ','
  77+ 574D              	; get sprite animation array size
  78+ 574D DD 21 1C 52  	LD IX,GETBYT
  79+ 5751 CD 59 01     	CALL CALBAS
  80+ 5754 32 8D 62         LD (BLIT_STRUCT+7),A
  81+ 5757 B7               OR A
  82+ 5758 CA AC 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  83+ 575B              	; comma
  84+ 575B CD 94 65     	CALL CHKCHAR
  85+ 575E 2C           	DB ','
  86+ 575F                  ; get array pointer
  87+ 575F 3A 8D 62         LD A,(BLIT_STRUCT+7)
  88+ 5762 57               LD D,A
  89+ 5763 3E 02            LD A,2
  90+ 5765 06 01            LD B,1
  91+ 5767 CD C1 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  92+ 576A ED 43 8E 62      LD (BLIT_STRUCT+8),BC
  93+ 576E              	; ending )
  94+ 576E CD 94 65     	CALL CHKCHAR
  95+ 5771 29           	DB ')'
  96+ 5772
  97+ 5772 E5               PUSH HL
  98+ 5773 F3               DI
  99+ 5774
 100+ 5774              	; enable page 0
 101+ 5774 FD 21 7B 57  	LD IY, .RET
 102+ 5778 C3 46 65     	JP ENABLE_PAGE0
 103+ 577B              .RET:
 104+ 577B D9               EXX
 105+ 577C ED 5B 86 62      LD DE,(BLIT_STRUCT) ; initial x
 106+ 5780 ED 4B 88 62      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 5784 D9               EXX
 108+ 5785 2A 8B 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5788 3A 8A 62         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 578B 47               LD B,A
 111+ 578C CD CB 4F         CALL SPRGRPMOV.UPDATE_LOC
 112+ 578F
 113+ 578F 3A 8D 62         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5792 47               LD B,A
 115+ 5793 ED 5B 8E 62      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 5797 CD E6 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 579A
 118+ 579A D1               POP DE
 119+ 579B C1               POP BC
 120+ 579C CD BD 64         CALL RESTORE_PAGE_INFO
 121+ 579F FB               EI
 122+ 57A0 E1               POP HL
 123+ 57A1 C9               RET
 124+ 57A2              ; *******************************************************************************************************
 125+ 57A2
 126+ 57A2              ; *******************************************************************************************************
 127+ 57A2              ; handles automatic move and animate sprite groups during interrupt
 128+ 57A2              PROCESS_AUTOSGAMS:
 129+ 57A2 3A E6 4F     	LD A,(AUTOSGAMNUM)
 130+ 57A5 B7           	OR A
 131+ 57A6 C8           	RET Z
 132+ 57A7 47           	LD B,A
 133+ 57A8 DD 2A E7 4F  	LD IX,(AUTOSGAMPTR)
 134+ 57AC              .L1:
 135+ 57AC C5           	PUSH BC
 136+ 57AD DD 7E 13     	LD A,(IX+19) ; active flag
 137+ 57B0 B7           	OR A
 138+ 57B1 28 28        	JR Z,.LOOPEND
 139+ 57B3              	; active, check timer
 140+ 57B3 DD 6E 16     	LD L,(IX+22)
 141+ 57B6 DD 66 17     	LD H,(IX+23) ; timer
 142+ 57B9 2B           	DEC HL
 143+ 57BA 7C           	LD A,H
 144+ 57BB B5           	OR L
 145+ 57BC 28 08        	JR Z,.L2
 146+ 57BE              	; not expired
 147+ 57BE DD 75 16     	LD (IX+22),L
 148+ 57C1 DD 74 17     	LD (IX+23),H
 149+ 57C4 18 15        	JR .LOOPEND
 150+ 57C6              .L2:
 151+ 57C6              	; expired, process
 152+ 57C6
 153+ 57C6                  ; set initial timer
 154+ 57C6 DD 7E 14         LD A,(IX+20)
 155+ 57C9 DD 77 16         LD (IX+22),A
 156+ 57CC DD 7E 15         LD A,(IX+21)
 157+ 57CF DD 77 17         LD (IX+23),A
 158+ 57D2
 159+ 57D2 CD E4 57     	CALL .MOVE
 160+ 57D5 CD 4F 58     	CALL .UPDATELOC
 161+ 57D8 CD 74 58     	CALL .PROCESS_ANIM_LIST
 162+ 57DB
 163+ 57DB              .LOOPEND:
 164+ 57DB 11 18 00     	LD DE,24
 165+ 57DE DD 19        	ADD IX,DE
 166+ 57E0 C1           	POP BC
 167+ 57E1 10 C9        	DJNZ .L1
 168+ 57E3 C9           	RET
 169+ 57E4
 170+ 57E4              .MOVE:
 171+ 57E4              	; process movement
 172+ 57E4 DD 7E 0A     	LD A,(IX+10) ; direction
 173+ 57E7 B7           	OR A
 174+ 57E8 28 08        	JR Z, .MOVE_L1
 175+ 57EA              	; vertical
 176+ 57EA DD 6E 02     	LD L,(IX+2)
 177+ 57ED DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 178+ 57F0 18 06        	JR .MOVE_L2
 179+ 57F2              .MOVE_L1:
 180+ 57F2              	; horizontal
 181+ 57F2 DD 6E 00     	LD L,(IX+0)
 182+ 57F5 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 183+ 57F8              .MOVE_L2:
 184+ 57F8 E5           	PUSH HL
 185+ 57F9 FD E1        	POP IY
 186+ 57FB FD 6E 00     	LD L,(IY+0)
 187+ 57FE FD 66 01     	LD H,(IY+1)
 188+ 5801 DD 5E 08     	LD E,(IX+8)
 189+ 5804 DD 56 09     	LD D,(IX+9) ; delta value
 190+ 5807 19           	ADD HL,DE
 191+ 5808 E5           	PUSH HL
 192+ 5809 DD 5E 04     	LD E,(IX+4)
 193+ 580C DD 56 05     	LD D,(IX+5) ; minimum value
 194+ 580F A7           	AND A
 195+ 5810 ED 52        	SBC HL,DE
 196+ 5812 FA 2C 58     	JP M,.MOVE_L3 ; below minimum
 197+ 5815 E1           	POP HL
 198+ 5816 E5           	PUSH HL
 199+ 5817 DD 5E 06     	LD E,(IX+6)
 200+ 581A DD 56 07     	LD D,(IX+7) ; maximum value
 201+ 581D EB           	EX DE,HL
 202+ 581E A7           	AND A
 203+ 581F ED 52        	SBC HL,DE
 204+ 5821 FA 34 58     	JP M,.MOVE_L4 ; above maximum
 205+ 5824 E1           	POP HL
 206+ 5825              	; within bounds
 207+ 5825              .MOVE_L5:
 208+ 5825 FD 75 00     	LD (IY+0),L
 209+ 5828 FD 74 01     	LD (IY+1),H
 210+ 582B C9           	RET
 211+ 582C              .MOVE_L3:
 212+ 582C E1           	POP HL
 213+ 582D CD 40 58     	CALL .INVERSE_DELTA
 214+ 5830 6B           	LD L,E
 215+ 5831 62           	LD H,D
 216+ 5832 18 F1        	JR .MOVE_L5
 217+ 5834              .MOVE_L4:
 218+ 5834 E1           	POP HL
 219+ 5835 CD 40 58     	CALL .INVERSE_DELTA
 220+ 5838 DD 6E 06     	LD L,(IX+6)
 221+ 583B DD 66 07     	LD H,(IX+7) ; maximum
 222+ 583E 18 E5        	JR .MOVE_L5
 223+ 5840              .INVERSE_DELTA:
 224+ 5840 AF           	XOR A
 225+ 5841 DD 96 08     	SUB (IX+8)
 226+ 5844 DD 77 08     	LD (IX+8),A
 227+ 5847 9F           	SBC A,A
 228+ 5848 DD 96 09     	SUB (IX+9)
 229+ 584B DD 77 09     	LD (IX+9),A
 230+ 584E C9           	RET
 231+ 584F
 232+ 584F              .UPDATELOC:
 233+ 584F DD E5        	PUSH IX
 234+ 5851 D9           	EXX
 235+ 5852 DD 6E 00     	LD L,(IX+0)
 236+ 5855 DD 66 01     	LD H,(IX+1)
 237+ 5858 5E           	LD E,(HL)
 238+ 5859 23           	INC HL
 239+ 585A 56           	LD D,(HL)
 240+ 585B DD 6E 02     	LD L,(IX+2)
 241+ 585E DD 66 03     	LD H,(IX+3)
 242+ 5861 4E           	LD C,(HL)
 243+ 5862 23           	INC HL
 244+ 5863 46           	LD B,(HL)
 245+ 5864 D9           	EXX
 246+ 5865 DD 6E 0C     	LD L,(IX+12)
 247+ 5868 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 248+ 586B DD 46 0B     	LD B,(IX+11) ; sprite group size
 249+ 586E CD CB 4F     	CALL SPRGRPMOV.UPDATE_LOC
 250+ 5871 DD E1        	POP IX
 251+ 5873 C9           	RET
 252+ 5874
 253+ 5874              .PROCESS_ANIM_LIST:
 254+ 5874 DD E5        	PUSH IX
 255+ 5876 DD 46 0E         LD B,(IX+14) ; anim list size
 256+ 5879 DD CB 09 7E  	BIT 7,(IX+9)
 257+ 587D 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 258+ 587F              	; negative direction
 259+ 587F DD 5E 0F     	LD E,(IX+15)
 260+ 5882 DD 56 10     	LD D,(IX+16)
 261+ 5885 18 06        	JR .PROCESS_ANIM_LIST_L2
 262+ 5887              .PROCESS_ANIM_LIST_L1:
 263+ 5887              	; positive direction
 264+ 5887 DD 5E 11     	LD E,(IX+17)
 265+ 588A DD 56 12     	LD D,(IX+18)
 266+ 588D              .PROCESS_ANIM_LIST_L2:
 267+ 588D CD E6 56     	CALL SGAM_PROCESS_ANIM_LIST
 268+ 5890 DD E1        	POP IX
 269+ 5892 C9           	RET
 270+ 5893              ; *******************************************************************************************************
 271+ 5893
# file closed: asm\SGAM.asm
 125  5893               ENDIF
 126  5893
 127  5893               IF (RAM_CMDS == 1)
 128  5893               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5893              ; *******************************************************************************************************
   2+ 5893              ; function to handle CALL MEMCPY basic extension
   3+ 5893              ; _MEMCPY ( INT source,
   4+ 5893              ;			INT destination,
   5+ 5893              ;			INT count,
   6+ 5893              ; will put ram in page 0 also, page 1 is already there
   7+ 5893              MEMCPY:
   8+ 5893              	; opening (
   9+ 5893 CD 94 65     	CALL CHKCHAR
  10+ 5896 28           	DB '('
  11+ 5897              	; get source address
  12+ 5897 DD 21 2F 54  	LD IX, FRMQNT
  13+ 589B CD 59 01     	CALL CALBAS
  14+ 589E D5           	PUSH DE
  15+ 589F              	; comma
  16+ 589F CD 94 65     	CALL CHKCHAR
  17+ 58A2 2C           	DB ','
  18+ 58A3              	; get destination address
  19+ 58A3 DD 21 2F 54  	LD IX, FRMQNT
  20+ 58A7 CD 59 01     	CALL CALBAS
  21+ 58AA D5           	PUSH DE
  22+ 58AB              	; comma
  23+ 58AB CD 94 65     	CALL CHKCHAR
  24+ 58AE 2C           	DB ','
  25+ 58AF              	; get length
  26+ 58AF DD 21 2F 54  	LD IX, FRMQNT
  27+ 58B3 CD 59 01     	CALL CALBAS
  28+ 58B6 D5           	PUSH DE
  29+ 58B7              	; ending )
  30+ 58B7 CD 94 65     	CALL CHKCHAR
  31+ 58BA 29           	DB ')'
  32+ 58BB
  33+ 58BB              	; save position
  34+ 58BB E5           	PUSH HL
  35+ 58BC DD E1        	POP IX
  36+ 58BE
  37+ 58BE C1           	POP BC ; count
  38+ 58BF D1           	POP DE ; destination
  39+ 58C0 E1           	POP HL ; source
  40+ 58C1 D9           	EXX
  41+ 58C2              	; enable page 0
  42+ 58C2 FD 21 C9 58  	LD IY, .RET
  43+ 58C6 C3 46 65     	JP ENABLE_PAGE0
  44+ 58C9              .RET:
  45+ 58C9 FB           	EI
  46+ 58CA D9           	EXX
  47+ 58CB ED B0        	LDIR
  48+ 58CD D1               POP DE
  49+ 58CE C1               POP BC
  50+ 58CF CD BD 64         CALL RESTORE_PAGE_INFO
  51+ 58D2 DD E5        	PUSH IX
  52+ 58D4 E1           	POP HL
  53+ 58D5 C9           	RET
  54+ 58D6              ; *******************************************************************************************************
  55+ 58D6
  56+ 58D6              ; *******************************************************************************************************
  57+ 58D6              ; function to handle CALL FILRAM basic extension
  58+ 58D6              ; FILRAM ( INT start address,
  59+ 58D6              ;		   INT count,
  60+ 58D6              ;		   BYTE value,
  61+ 58D6              ; will put ram in page 0 also, page 1 is already there
  62+ 58D6              FILRAM:
  63+ 58D6              	; opening (
  64+ 58D6 CD 94 65     	CALL CHKCHAR
  65+ 58D9 28           	DB '('
  66+ 58DA              	; get start address
  67+ 58DA DD 21 2F 54  	LD IX, FRMQNT
  68+ 58DE CD 59 01     	CALL CALBAS
  69+ 58E1 D5           	PUSH DE
  70+ 58E2              	; comma
  71+ 58E2 CD 94 65     	CALL CHKCHAR
  72+ 58E5 2C           	DB ','
  73+ 58E6              	; get count
  74+ 58E6 DD 21 2F 54  	LD IX, FRMQNT
  75+ 58EA CD 59 01     	CALL CALBAS
  76+ 58ED D5           	PUSH DE
  77+ 58EE              	; comma
  78+ 58EE CD 94 65     	CALL CHKCHAR
  79+ 58F1 2C           	DB ','
  80+ 58F2              	; get value
  81+ 58F2 DD 21 1C 52  	LD IX, GETBYT
  82+ 58F6 CD 59 01     	CALL CALBAS
  83+ 58F9 F5           	PUSH AF
  84+ 58FA              	; ending )
  85+ 58FA CD 94 65     	CALL CHKCHAR
  86+ 58FD 29           	DB ')'
  87+ 58FE
  88+ 58FE              	; save position
  89+ 58FE E5           	PUSH HL
  90+ 58FF DD E1        	POP IX
  91+ 5901
  92+ 5901 D1           	POP DE ; actually AF
  93+ 5902 C1           	POP BC ; count
  94+ 5903 E1           	POP HL ; start address
  95+ 5904 78           	LD A, B
  96+ 5905 B7           	OR A
  97+ 5906 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
  98+ 5908 B1           	OR C
  99+ 5909 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 100+ 590B 79           	LD A, C
 101+ 590C 3D           	DEC A
 102+ 590D 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 103+ 590F              	; one byte to fill
 104+ 590F 72           	LD (HL), D
 105+ 5910 18 12        	JR .EXIT
 106+ 5912              .L1:
 107+ 5912 D9           	EXX
 108+ 5913              	; enable page 0
 109+ 5913 FD 21 1A 59  	LD IY, .RET
 110+ 5917 C3 46 65     	JP ENABLE_PAGE0
 111+ 591A              .RET:
 112+ 591A FB           	EI
 113+ 591B D9           	EXX
 114+ 591C CD 28 59     	CALL .FILLVALUE
 115+ 591F D1               POP DE
 116+ 5920 C1               POP BC
 117+ 5921 CD BD 64         CALL RESTORE_PAGE_INFO
 118+ 5924              .EXIT:
 119+ 5924 DD E5        	PUSH IX
 120+ 5926 E1           	POP HL
 121+ 5927 C9           	RET
 122+ 5928
 123+ 5928              .FILLVALUE:
 124+ 5928 72               LD (HL), D
 125+ 5929 54               LD D, H
 126+ 592A 5D               LD E, L
 127+ 592B 13               INC DE
 128+ 592C 0B               DEC BC
 129+ 592D ED B0            LDIR
 130+ 592F C9               RET
 131+ 5930              ; *******************************************************************************************************
 132+ 5930
# file closed: asm\MEMORY.asm
 129  5930               ENDIF
 130  5930
 131  5930               IF (SOUND_CMDS == 1)
 132  5930               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5930              MUSIC_INIT_STATUS:
   2+ 5930 00            DB 0
   3+ 5931              SFX_INIT_STATUS:
   4+ 5931 00            DB 0
   5+ 5932              SOUND_ENABLED:
   6+ 5932 00            DB 0
   7+ 5933
   8+ 5933              ; *******************************************************************************************************
   9+ 5933              ; function to handle CALL SNDPLYINIT basic extension
  10+ 5933              ; initializes sound player
  11+ 5933              ; _SNDPLYINIT ( INT music_offset,
  12+ 5933              ;				INT sfx_offset, can be -1 if no SFX
  13+ 5933              ; will put ram in page 0 also, page 1 is already there
  14+ 5933              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 5933              SNDPLYINIT:
  16+ 5933              	; opening (
  17+ 5933 CD 94 65     	CALL CHKCHAR
  18+ 5936 28           	DB '('
  19+ 5937              	; get music address
  20+ 5937 DD 21 2F 54  	LD IX, FRMQNT
  21+ 593B CD 59 01     	CALL CALBAS
  22+ 593E D5           	PUSH DE
  23+ 593F              	; comma
  24+ 593F CD 94 65     	CALL CHKCHAR
  25+ 5942 2C           	DB ','
  26+ 5943              	; get sfx address
  27+ 5943 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5947 CD 59 01     	CALL CALBAS
  29+ 594A D5           	PUSH DE
  30+ 594B              	; ending )
  31+ 594B CD 94 65     	CALL CHKCHAR
  32+ 594E 29           	DB ')'
  33+ 594F
  34+ 594F                  ; save position in BASIC text
  35+ 594F 44           	LD B, H
  36+ 5950 4D           	LD C, L
  37+ 5951
  38+ 5951              	; pop LDIR parameters and store away for later
  39+ 5951 D1           	POP DE ; sfx address
  40+ 5952 E1           	POP HL ; music address
  41+ 5953 C5           	PUSH BC ; basic text location
  42+ 5954 D9           	EXX
  43+ 5955 FD 21 5C 59  	LD IY, .RET
  44+ 5959 C3 46 65     	JP ENABLE_PAGE0
  45+ 595C              .RET:
  46+ 595C D9           	EXX
  47+ 595D
  48+ 595D D5           	PUSH DE
  49+ 595E AF           	XOR A
  50+ 595F              	; HL = music location
  51+ 595F CD 62 41     	CALL PLY_AKG_INIT
  52+ 5962 3E 01        	LD A, 1
  53+ 5964 32 30 59     	LD (MUSIC_INIT_STATUS), A
  54+ 5967
  55+ 5967 E1           	POP HL ; SFX
  56+ 5968              	; check if SFX address -1
  57+ 5968 23           	INC HL
  58+ 5969 7D           	LD A, L
  59+ 596A B4           	OR H
  60+ 596B 28 09        	JR Z,.L1
  61+ 596D 2B           	DEC HL
  62+ 596E CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 5971 3E 01        	LD A, 1
  64+ 5973 32 31 59     	LD (SFX_INIT_STATUS), A
  65+ 5976              .L1:
  66+ 5976 D1               POP DE
  67+ 5977 C1               POP BC
  68+ 5978 CD BD 64         CALL RESTORE_PAGE_INFO
  69+ 597B
  70+ 597B E1           	POP HL
  71+ 597C C9           	RET
  72+ 597D              ; *******************************************************************************************************
  73+ 597D
  74+ 597D              ; *******************************************************************************************************
  75+ 597D              ; function to handle CALL SNDPLYON basic extension
  76+ 597D              ; enables sound player
  77+ 597D              ; _SNDPLYON
  78+ 597D              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 597D              ; if not throws out of data error
  80+ 597D              SNDPLYON:
  81+ 597D 3A 30 59     	LD A, (MUSIC_INIT_STATUS)
  82+ 5980 B7           	OR A
  83+ 5981 20 05        	JR NZ, .L1
  84+ 5983              	; player not initialized, throw error
  85+ 5983 1E 04        	LD E, 04 ; Out of DATA
  86+ 5985 C3 BA 65     	JP THROW_ERROR
  87+ 5988              .L1:
  88+ 5988 32 32 59     	LD (SOUND_ENABLED), A
  89+ 598B              	; disable key click
  90+ 598B AF           	XOR A
  91+ 598C 32 DB F3     	LD (CLIKSW), A
  92+ 598F C9           	RET
  93+ 5990              ; *******************************************************************************************************
  94+ 5990
  95+ 5990              ; *******************************************************************************************************
  96+ 5990              ; function to handle CALL SNDPLYOFF basic extension
  97+ 5990              ; disables sound player
  98+ 5990              ; _SNDPLYOFF
  99+ 5990              ; sets SOUND_ENABLED variable to 0
 100+ 5990              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 5990              SNDPLYOFF:
 102+ 5990 3A 32 59     	LD A, (SOUND_ENABLED)
 103+ 5993 B7           	OR A
 104+ 5994 C8           	RET Z ; already stopped
 105+ 5995 AF           	XOR A
 106+ 5996 32 32 59     	LD (SOUND_ENABLED), A
 107+ 5999 E5           	PUSH HL
 108+ 599A CD 21 42     	CALL PLY_AKG_STOP
 109+ 599D 3A 31 59     	LD A, (SFX_INIT_STATUS)
 110+ 59A0 B7           	OR A
 111+ 59A1 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 59A3 AF           	XOR A
 113+ 59A4 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 59A7 3E 01        	LD A, 1
 115+ 59A9 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 59AC 3E 02        	LD A, 2
 117+ 59AE CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 59B1              .EXIT:
 119+ 59B1 E1           	POP HL
 120+ 59B2 C9           	RET
 121+ 59B3              ; *******************************************************************************************************
 122+ 59B3
 123+ 59B3              ; *******************************************************************************************************
 124+ 59B3              ; function to handle CALL SNDSFX basic extension
 125+ 59B3              ; plays a sound effect
 126+ 59B3              ; _SNDSFX ( BYTE sfx_number, >0
 127+ 59B3              ;			BYTE channel, = 0,1 or 2
 128+ 59B3              ;			BYTE inverted_volume = 0-16, 0 being full volume
 129+ 59B3              ; will put ram in page 0 also, page 1 is already there
 130+ 59B3              ; if sound off throws illegal function call
 131+ 59B3              ; if sfx not initialized, throws out of data
 132+ 59B3              SNDSFX:
 133+ 59B3              	; opening (
 134+ 59B3 CD 94 65     	CALL CHKCHAR
 135+ 59B6 28           	DB '('
 136+ 59B7              	; get sfx_number
 137+ 59B7 DD 21 1C 52  	LD IX, GETBYT
 138+ 59BB CD 59 01     	CALL CALBAS
 139+ 59BE D5           	PUSH DE
 140+ 59BF              	; comma
 141+ 59BF CD 94 65     	CALL CHKCHAR
 142+ 59C2 2C           	DB ','
 143+ 59C3              	; get sfx address
 144+ 59C3 DD 21 1C 52  	LD IX, GETBYT
 145+ 59C7 CD 59 01     	CALL CALBAS
 146+ 59CA D5           	PUSH DE
 147+ 59CB              	; comma
 148+ 59CB CD 94 65     	CALL CHKCHAR
 149+ 59CE 2C           	DB ','
 150+ 59CF              	; get inverted volume
 151+ 59CF DD 21 1C 52  	LD IX, GETBYT
 152+ 59D3 CD 59 01     	CALL CALBAS
 153+ 59D6 D5           	PUSH DE
 154+ 59D7              	; ending )
 155+ 59D7 CD 94 65     	CALL CHKCHAR
 156+ 59DA 29           	DB ')'
 157+ 59DB
 158+ 59DB 3A 32 59     	LD A, (SOUND_ENABLED)
 159+ 59DE B7           	OR A
 160+ 59DF 20 05        	JR NZ, .L1
 161+ 59E1              	; sound disabled, throw illegal function call
 162+ 59E1 1E 05        	LD E, 5
 163+ 59E3 C3 BA 65     	JP THROW_ERROR
 164+ 59E6              .L1:
 165+ 59E6 3A 31 59     	LD A, (SFX_INIT_STATUS)
 166+ 59E9 B7           	OR A
 167+ 59EA 20 05        	JR NZ, .L2
 168+ 59EC              	; sfx data not initialized, throw out of data
 169+ 59EC 1E 04        	LD E, 4
 170+ 59EE C3 BA 65     	JP THROW_ERROR
 171+ 59F1              .L2:
 172+ 59F1              	; pop  parameters and store away for later
 173+ 59F1 D1           	POP DE ; inverted volume
 174+ 59F2 43           	LD B, E
 175+ 59F3 D1           	POP DE ; channel
 176+ 59F4 4B           	LD C, E
 177+ 59F5 D1           	POP DE
 178+ 59F6 7B           	LD A, E
 179+ 59F7 08           	EX AF, AF'
 180+ 59F8 E5           	PUSH HL ; basic text location
 181+ 59F9 D9           	EXX
 182+ 59FA FD 21 01 5A  	LD IY, .RET
 183+ 59FE C3 46 65     	JP ENABLE_PAGE0
 184+ 5A01              .RET:
 185+ 5A01 D9           	EXX
 186+ 5A02 08           	EX AF, AF'
 187+ 5A03 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 188+ 5A06
 189+ 5A06 D1               POP DE
 190+ 5A07 C1               POP BC
 191+ 5A08 CD BD 64         CALL RESTORE_PAGE_INFO
 192+ 5A0B
 193+ 5A0B E1           	POP HL
 194+ 5A0C C9           	RET
 195+ 5A0D              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
 133  5A0D               ENDIF
 134  5A0D
 135  5A0D               IF (VRAM_CMDS == 1)
 136  5A0D               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5A0D              ; *******************************************************************************************************
   2+ 5A0D              ; function to handle CALL FILVRM basic extension
   3+ 5A0D              ; FILVRM ( INT offset,
   4+ 5A0D              ;		   INT count,
   5+ 5A0D              ;		   BYTE value,
   6+ 5A0D              ;		   BYTE wait_vsync) >0 = true
   7+ 5A0D              ; wait_vsync will issue HALT before copying
   8+ 5A0D              FILVRM:
   9+ 5A0D              	; opening (
  10+ 5A0D CD 94 65     	CALL CHKCHAR
  11+ 5A10 28           	DB '('
  12+ 5A11              	; get offset address
  13+ 5A11 DD 21 2F 54  	LD IX, FRMQNT
  14+ 5A15 CD 59 01     	CALL CALBAS
  15+ 5A18 D5           	PUSH DE
  16+ 5A19              	; comma
  17+ 5A19 CD 94 65     	CALL CHKCHAR
  18+ 5A1C 2C           	DB ','
  19+ 5A1D              	; get count
  20+ 5A1D DD 21 2F 54  	LD IX, FRMQNT
  21+ 5A21 CD 59 01     	CALL CALBAS
  22+ 5A24 D5           	PUSH DE
  23+ 5A25              	; comma
  24+ 5A25 CD 94 65     	CALL CHKCHAR
  25+ 5A28 2C           	DB ','
  26+ 5A29              	; get value
  27+ 5A29 DD 21 1C 52  	LD IX, GETBYT
  28+ 5A2D CD 59 01     	CALL CALBAS
  29+ 5A30 F5           	PUSH AF
  30+ 5A31              	; comma
  31+ 5A31 CD 94 65     	CALL CHKCHAR
  32+ 5A34 2C           	DB ','
  33+ 5A35              	; get vsync wait
  34+ 5A35 DD 21 1C 52  	LD IX, GETBYT
  35+ 5A39 CD 59 01     	CALL CALBAS
  36+ 5A3C F5           	PUSH AF
  37+ 5A3D              	; ending )
  38+ 5A3D CD 94 65     	CALL CHKCHAR
  39+ 5A40 29           	DB ')'
  40+ 5A41
  41+ 5A41 FB               EI
  42+ 5A42              	; save position
  43+ 5A42 E5           	PUSH HL
  44+ 5A43 DD E1        	POP IX
  45+ 5A45
  46+ 5A45              	; syntax ok
  47+ 5A45              	; wait for vsync if needed
  48+ 5A45 F1           	POP AF
  49+ 5A46 B7           	OR A
  50+ 5A47 28 01        	JR Z, .L1
  51+ 5A49 76           	HALT
  52+ 5A4A
  53+ 5A4A              .L1:
  54+ 5A4A 3E 01        	LD A,1
  55+ 5A4C 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5A4F F1               POP AF ; value
  57+ 5A50 C1               POP BC ; count
  58+ 5A51 E1               POP HL ; offset
  59+ 5A52 CD 56 00         CALL BIOS_FILVRM
  60+ 5A55 AF           	XOR A
  61+ 5A56 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5A59
  63+ 5A59              .L3:
  64+ 5A59 DD E5        	PUSH IX
  65+ 5A5B E1           	POP HL
  66+ 5A5C C9           	RET
  67+ 5A5D              ; *******************************************************************************************************
  68+ 5A5D
  69+ 5A5D              ; *******************************************************************************************************
  70+ 5A5D              ; function to handle CALL MEMVRM basic extension
  71+ 5A5D              ; copies from RAM to VRAM
  72+ 5A5D              ; _MEMVRM ( INT source,
  73+ 5A5D              ;			INT destination,
  74+ 5A5D              ;			INT count,
  75+ 5A5D              ;			BYTE wait_vsync) >0 = true
  76+ 5A5D              ; will put ram in page 0 also, page 1 is already there
  77+ 5A5D              ; wait_vsync will issue HALT before copying
  78+ 5A5D              MEMVRM:
  79+ 5A5D              	; opening (
  80+ 5A5D CD 94 65     	CALL CHKCHAR
  81+ 5A60 28           	DB '('
  82+ 5A61              	; get source address
  83+ 5A61 DD 21 2F 54  	LD IX, FRMQNT
  84+ 5A65 CD 59 01     	CALL CALBAS
  85+ 5A68 D5           	PUSH DE
  86+ 5A69              	; comma
  87+ 5A69 CD 94 65     	CALL CHKCHAR
  88+ 5A6C 2C           	DB ','
  89+ 5A6D              	; get destination address
  90+ 5A6D DD 21 2F 54  	LD IX, FRMQNT
  91+ 5A71 CD 59 01     	CALL CALBAS
  92+ 5A74 D5           	PUSH DE
  93+ 5A75              	; comma
  94+ 5A75 CD 94 65     	CALL CHKCHAR
  95+ 5A78 2C           	DB ','
  96+ 5A79              	; get length
  97+ 5A79 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5A7D CD 59 01     	CALL CALBAS
  99+ 5A80 D5           	PUSH DE
 100+ 5A81              	; comma
 101+ 5A81 CD 94 65     	CALL CHKCHAR
 102+ 5A84 2C           	DB ','
 103+ 5A85              	; get vsync wait
 104+ 5A85 DD 21 1C 52  	LD IX, GETBYT
 105+ 5A89 CD 59 01     	CALL CALBAS
 106+ 5A8C F5           	PUSH AF
 107+ 5A8D              	; ending )
 108+ 5A8D CD 94 65     	CALL CHKCHAR
 109+ 5A90 29           	DB ')'
 110+ 5A91
 111+ 5A91                  ; save position in BASIC text
 112+ 5A91 E5           	PUSH HL
 113+ 5A92 DD E1        	POP IX
 114+ 5A94
 115+ 5A94 F1           	POP AF ; wait vsync
 116+ 5A95 B7           	OR A
 117+ 5A96 28 03        	JR Z, .L1
 118+ 5A98 FB               EI
 119+ 5A99 76           	HALT
 120+ 5A9A F3           	DI
 121+ 5A9B              .L1:
 122+ 5A9B              	; pop LDIR parameters and store away for later
 123+ 5A9B C1           	POP BC ; count
 124+ 5A9C D1           	POP DE ; vram destination
 125+ 5A9D E1           	POP HL ; ram source
 126+ 5A9E D9           	EXX
 127+ 5A9F FD 21 A6 5A   	LD IY, .RET
 128+ 5AA3 C3 46 65     	JP ENABLE_PAGE0
 129+ 5AA6              .RET:
 130+ 5AA6 FB           	EI
 131+ 5AA7 D9           	EXX
 132+ 5AA8 3E 01        	LD A,1
 133+ 5AAA 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 134+ 5AAD CD BD 5A     	CALL .LDIRVM
 135+ 5AB0 AF           	XOR A
 136+ 5AB1 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 137+ 5AB4 D1               POP DE
 138+ 5AB5 C1               POP BC
 139+ 5AB6 CD BD 64         CALL RESTORE_PAGE_INFO
 140+ 5AB9 DD E5        	PUSH IX
 141+ 5ABB E1           	POP HL
 142+ 5ABC C9           	RET
 143+ 5ABD
 144+ 5ABD              .LDIRVM:
 145+ 5ABD EB           	EX DE, HL
 146+ 5ABE F3           	DI
 147+ 5ABF CD 6D 64     	CALL SETWRT_LOCAL
 148+ 5AC2 FB           	EI
 149+ 5AC3 EB           	EX DE, HL
 150+ 5AC4 78           	LD A, B
 151+ 5AC5 B7           	OR A
 152+ 5AC6 28 0D        	JR Z, .L3
 153+ 5AC8 C5           	PUSH BC
 154+ 5AC9 0E 98        	LD C, #98
 155+ 5ACB              .L2:
 156+ 5ACB 50           	LD D, B
 157+ 5ACC 06 00        	LD B, 0
 158+ 5ACE CD 7A 64     	CALL BBYTECOPY_NO_C
 159+ 5AD1 42           	LD B, D
 160+ 5AD2 10 F7        	DJNZ .L2
 161+ 5AD4 C1           	POP BC
 162+ 5AD5              .L3:
 163+ 5AD5 79           	LD A, C
 164+ 5AD6 B7           	OR A
 165+ 5AD7 C8           	RET Z
 166+ 5AD8 41           	LD B, C
 167+ 5AD9 C3 78 64     	JP BBYTECOPY
 168+ 5ADC              ; *******************************************************************************************************
 169+ 5ADC
 170+ 5ADC              ; *******************************************************************************************************
 171+ 5ADC              ; function to handle CALL VRMMEM basic extension
 172+ 5ADC              ; copies from RAM to VRAM
 173+ 5ADC              ; _VRMMEM ( INT source,
 174+ 5ADC              ;			INT destination,
 175+ 5ADC              ;			INT count
 176+ 5ADC              ; will put ram in page 0 also, page 1 is already there
 177+ 5ADC              VRMMEM:
 178+ 5ADC              	; opening (
 179+ 5ADC CD 94 65     	CALL CHKCHAR
 180+ 5ADF 28           	DB '('
 181+ 5AE0              	; get source address
 182+ 5AE0 DD 21 2F 54  	LD IX, FRMQNT
 183+ 5AE4 CD 59 01     	CALL CALBAS
 184+ 5AE7 D5           	PUSH DE
 185+ 5AE8              	; comma
 186+ 5AE8 CD 94 65     	CALL CHKCHAR
 187+ 5AEB 2C           	DB ','
 188+ 5AEC              	; get destination address
 189+ 5AEC DD 21 2F 54  	LD IX, FRMQNT
 190+ 5AF0 CD 59 01     	CALL CALBAS
 191+ 5AF3 D5           	PUSH DE
 192+ 5AF4              	; comma
 193+ 5AF4 CD 94 65     	CALL CHKCHAR
 194+ 5AF7 2C           	DB ','
 195+ 5AF8              	; get length
 196+ 5AF8 DD 21 2F 54  	LD IX, FRMQNT
 197+ 5AFC CD 59 01     	CALL CALBAS
 198+ 5AFF D5           	PUSH DE
 199+ 5B00              	; ending )
 200+ 5B00 CD 94 65     	CALL CHKCHAR
 201+ 5B03 29           	DB ')'
 202+ 5B04
 203+ 5B04                  ; save position in BASIC text
 204+ 5B04 E5           	PUSH HL
 205+ 5B05 DD E1        	POP IX
 206+ 5B07
 207+ 5B07 C1           	POP BC ; count
 208+ 5B08 D1           	POP DE ; destination
 209+ 5B09 E1           	POP HL ; source
 210+ 5B0A D9           	EXX
 211+ 5B0B FD 21 12 5B  	LD IY, .RET
 212+ 5B0F C3 46 65     	JP ENABLE_PAGE0
 213+ 5B12              .RET:
 214+ 5B12 FB           	EI
 215+ 5B13 D9           	EXX
 216+ 5B14 3E 01        	LD A,1
 217+ 5B16 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 218+ 5B19 CD 29 5B     	CALL .LDIRMV
 219+ 5B1C AF           	XOR A
 220+ 5B1D 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 221+ 5B20 D1               POP DE
 222+ 5B21 C1               POP BC
 223+ 5B22 CD BD 64         CALL RESTORE_PAGE_INFO
 224+ 5B25 DD E5        	PUSH IX
 225+ 5B27 E1           	POP HL
 226+ 5B28 C9           	RET
 227+ 5B29
 228+ 5B29              .LDIRMV:
 229+ 5B29              	; set VRAM address *exactly* as in ROM, otherwise corruption
 230+ 5B29 7D           	LD	A, L
 231+ 5B2A F3           	DI
 232+ 5B2B D3 99        	OUT	(099H), A
 233+ 5B2D 7C           	LD	A, H
 234+ 5B2E E6 3F        	AND	03FH
 235+ 5B30 D3 99        	OUT	(099H), A
 236+ 5B32 FB           	EI
 237+ 5B33              	;EX (SP), HL
 238+ 5B33              	;EX (SP), HL
 239+ 5B33              	;NOP
 240+ 5B33              	;NOP
 241+ 5B33              .L4:
 242+ 5B33 DB 98            IN A, (#98)
 243+ 5B35 12           	LD (DE), A
 244+ 5B36 13               INC DE
 245+ 5B37 0B               DEC BC
 246+ 5B38 79               LD A, C
 247+ 5B39 B0               OR B
 248+ 5B3A 20 F7            JR NZ, .L4
 249+ 5B3C C9               RET
 250+ 5B3D              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 137  5B3D               ENDIF
 138  5B3D
 139  5B3D               IF (GENCAL_CMD == 1)
 140  5B3D               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5B3D              ; *******************************************************************************************************
   2+ 5B3D              ; function to handle CALL GENCAL basic extension
   3+ 5B3D              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5B3D              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5B3D              ; output values of registers will also be stored at reg_list_ptr
   6+ 5B3D              GENCAL_VAR_SP:
   7+ 5B3D 00 00            DW 0
   8+ 5B3F              GENCAL_VAR_SP2:
   9+ 5B3F 00 00            DW 0
  10+ 5B41              GENCAL:
  11+ 5B41              	; opening (
  12+ 5B41 CD 94 65     	CALL CHKCHAR
  13+ 5B44 28           	DB '('
  14+ 5B45              	; get function address
  15+ 5B45 DD 21 2F 54  	LD IX, FRMQNT
  16+ 5B49 CD 59 01     	CALL CALBAS
  17+ 5B4C D5           	PUSH DE
  18+ 5B4D              	; comma
  19+ 5B4D CD 94 65     	CALL CHKCHAR
  20+ 5B50 2C           	DB ','
  21+ 5B51              	; get pointer to register list
  22+ 5B51 3E 02            LD A,2
  23+ 5B53 06 01            LD B,1
  24+ 5B55 11 00 05         LD DE,#0500
  25+ 5B58 CD C1 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  26+ 5B5B C5           	PUSH BC
  27+ 5B5C              	; ending )
  28+ 5B5C CD 94 65     	CALL CHKCHAR
  29+ 5B5F 29           	DB ')'
  30+ 5B60
  31+ 5B60              	; save BASIC token position
  32+ 5B60 E5           	PUSH HL
  33+ 5B61 D9               EXX
  34+ 5B62 E1           	POP HL ; HL'=next basic token
  35+ 5B63 D9               EXX
  36+ 5B64
  37+ 5B64 E1               POP HL ; get pointer to register values
  38+ 5B65 F3           	DI
  39+ 5B66 ED 73 3D 5B      LD (GENCAL_VAR_SP), SP
  40+ 5B6A F9               LD SP, HL
  41+ 5B6B F1               POP AF
  42+ 5B6C C1               POP BC
  43+ 5B6D D1               POP DE
  44+ 5B6E E1               POP HL
  45+ 5B6F DD E1            POP IX
  46+ 5B71 FD E1            POP IY
  47+ 5B73 D9               EXX
  48+ 5B74 ED 73 3F 5B      LD (GENCAL_VAR_SP2), SP
  49+ 5B78 ED 7B 3D 5B      LD SP, (GENCAL_VAR_SP)
  50+ 5B7C FB               EI
  51+ 5B7D D1               POP DE ; get function to call
  52+ 5B7E E5               PUSH HL
  53+ 5B7F CD 9A 5B         CALL .EXXDECALL
  54+ 5B82 F3               DI
  55+ 5B83 ED 73 3D 5B      LD (GENCAL_VAR_SP), SP
  56+ 5B87 ED 7B 3F 5B      LD SP, (GENCAL_VAR_SP2)
  57+ 5B8B FD E5            PUSH IY
  58+ 5B8D DD E5            PUSH IX
  59+ 5B8F E5               PUSH HL
  60+ 5B90 D5               PUSH DE
  61+ 5B91 C5               PUSH BC
  62+ 5B92 F5               PUSH AF
  63+ 5B93 ED 7B 3D 5B      LD SP, (GENCAL_VAR_SP)
  64+ 5B97 FB               EI
  65+ 5B98 E1               POP HL
  66+ 5B99 C9           	RET
  67+ 5B9A
  68+ 5B9A              .EXXDECALL:
  69+ 5B9A D5               PUSH DE
  70+ 5B9B D9               EXX
  71+ 5B9C C9               RET
  72+ 5B9D              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 141  5B9D               ENDIF
 142  5B9D
 143  5B9D               IF (BOX_CMDS == 1)
 144  5B9D               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B9D              ; *******************************************************************************************************
   2+ 5B9D              ; generic function to implement rectangle data copy
   3+ 5B9D              ; should be modified to call appropriate function for memory or vram
   4+ 5B9D              ; input IX=pointer to following structure
   5+ 5B9D              ; +00 source data pointer
   6+ 5B9D              ; +02 num bytes in a row
   7+ 5B9D              ; +04 number of rows
   8+ 5B9D              ; +06 source add-to value till next row
   9+ 5B9D              ; +08 destination address
  10+ 5B9D              ; +10 destination add-to value till next row
  11+ 5B9D              ; modifies AF, BC, DE, HL
  12+ 5B9D              RECTANGLE_COPY:
  13+ 5B9D DD 6E 00     	LD L, (IX+0)
  14+ 5BA0 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5BA3 DD 5E 08     	LD E, (IX+8)
  16+ 5BA6 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5BA9 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5BAC              .L1:
  19+ 5BAC C5           	PUSH BC
  20+ 5BAD E5           		PUSH HL
  21+ 5BAE D5           			PUSH DE
  22+ 5BAF DD 4E 02     				LD C, (IX+2)
  23+ 5BB2 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5BB5              .CALL1:
  25+ 5BB5 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5BB8              .CALL2:
  27+ 5BB8 CD 00 00     				CALL 0 ; copy data fn
  28+ 5BBB E1           			POP HL
  29+ 5BBC DD 4E 0A     			LD C, (IX+10)
  30+ 5BBF DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5BC2 09           			ADD HL, BC
  32+ 5BC3 EB           			EX DE, HL
  33+ 5BC4 E1           		POP HL
  34+ 5BC5 DD 4E 06     		LD C, (IX+6)
  35+ 5BC8 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5BCB 09           		ADD HL, BC
  37+ 5BCC C1           	POP BC
  38+ 5BCD 10 DD        	DJNZ .L1
  39+ 5BCF C9           	RET
  40+ 5BD0              ; *******************************************************************************************************
  41+ 5BD0
  42+ 5BD0              ; *******************************************************************************************************
  43+ 5BD0              ; function to handle CALL BOXMEMCPY basic extension
  44+ 5BD0              ; copies data with window like boundaries within ram
  45+ 5BD0              ; BOXMEMCPY ( INT source data pointer,
  46+ 5BD0              ;			  INT source number of bytes in a row,
  47+ 5BD0              ;			  INT number of rows,
  48+ 5BD0              ;			  INT source add-to value till next row,
  49+ 5BD0              ; 			  INT destination pointer,
  50+ 5BD0              ;			  INT destination add-to value till next row )
  51+ 5BD0              ; request_data_ptr described in RECTANGLE_COPY
  52+ 5BD0              ; will put ram in page 0 also, page 1 is already there
  53+ 5BD0              BOXMEMCPY:
  54+ 5BD0 11 DA 5B     	LD DE,BOXMEMCPY.RET
  55+ 5BD3 ED 53 4E 5C  	LD (BOXCOMMON.ADDR+2), DE
  56+ 5BD7 C3 ED 5B     	JP BOXCOMMON
  57+ 5BDA              .RET:
  58+ 5BDA FB           	EI
  59+ 5BDB              	; set RAM functions to call
  60+ 5BDB 21 00 00     	LD HL, 0
  61+ 5BDE 22 B5 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  62+ 5BE1 22 B7 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  63+ 5BE4 21 ED B0     	LD HL, #B0ED ; LDIR
  64+ 5BE7 22 B9 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  65+ 5BEA C3 53 5C     	JP BOXCOMMON.CALL
  66+ 5BED              ; *******************************************************************************************************
  67+ 5BED
  68+ 5BED              ; *******************************************************************************************************
  69+ 5BED              ; common parts of BOX commands
  70+ 5BED              BOXCOMMON:
  71+ 5BED              	; opening (
  72+ 5BED CD 94 65     	CALL CHKCHAR
  73+ 5BF0 28           	DB '('
  74+ 5BF1              	; get source data pointer
  75+ 5BF1 DD 21 2F 54  	LD IX, FRMQNT
  76+ 5BF5 CD 59 01     	CALL CALBAS
  77+ 5BF8 ED 53 86 62  	LD (BLIT_STRUCT+0), DE
  78+ 5BFC              	; comma
  79+ 5BFC CD 94 65     	CALL CHKCHAR
  80+ 5BFF 2C           	DB ','
  81+ 5C00              	; source number of bytes in a row
  82+ 5C00 DD 21 2F 54  	LD IX, FRMQNT
  83+ 5C04 CD 59 01     	CALL CALBAS
  84+ 5C07 ED 53 88 62  	LD (BLIT_STRUCT+2), DE
  85+ 5C0B              	; comma
  86+ 5C0B CD 94 65     	CALL CHKCHAR
  87+ 5C0E 2C           	DB ','
  88+ 5C0F              	; number of rows
  89+ 5C0F DD 21 2F 54  	LD IX, FRMQNT
  90+ 5C13 CD 59 01     	CALL CALBAS
  91+ 5C16 ED 53 8A 62  	LD (BLIT_STRUCT+4), DE
  92+ 5C1A              	; comma
  93+ 5C1A CD 94 65     	CALL CHKCHAR
  94+ 5C1D 2C           	DB ','
  95+ 5C1E              	; source add-to value till next row
  96+ 5C1E DD 21 2F 54  	LD IX, FRMQNT
  97+ 5C22 CD 59 01     	CALL CALBAS
  98+ 5C25 ED 53 8C 62  	LD (BLIT_STRUCT+6), DE
  99+ 5C29              	; comma
 100+ 5C29 CD 94 65     	CALL CHKCHAR
 101+ 5C2C 2C           	DB ','
 102+ 5C2D              	; destination pointer
 103+ 5C2D DD 21 2F 54  	LD IX, FRMQNT
 104+ 5C31 CD 59 01     	CALL CALBAS
 105+ 5C34 ED 53 8E 62  	LD (BLIT_STRUCT+8), DE
 106+ 5C38              	; comma
 107+ 5C38 CD 94 65     	CALL CHKCHAR
 108+ 5C3B 2C           	DB ','
 109+ 5C3C              	; destination add-to value till next row
 110+ 5C3C DD 21 2F 54  	LD IX, FRMQNT
 111+ 5C40 CD 59 01     	CALL CALBAS
 112+ 5C43 ED 53 90 62  	LD (BLIT_STRUCT+10), DE
 113+ 5C47              	; ending )
 114+ 5C47 CD 94 65     	CALL CHKCHAR
 115+ 5C4A 29           	DB ')'
 116+ 5C4B
 117+ 5C4B E5           	PUSH HL ; save position in BASIC buffer
 118+ 5C4C              .ADDR:
 119+ 5C4C FD 21 00 00  	LD IY, 0
 120+ 5C50 C3 46 65     	JP ENABLE_PAGE0
 121+ 5C53              .CALL:
 122+ 5C53 DD 21 86 62  	LD IX,BLIT_STRUCT
 123+ 5C57 CD 9D 5B     	CALL RECTANGLE_COPY
 124+ 5C5A AF           	XOR A
 125+ 5C5B 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 126+ 5C5E
 127+ 5C5E D1               POP DE
 128+ 5C5F C1               POP BC
 129+ 5C60 CD BD 64         CALL RESTORE_PAGE_INFO
 130+ 5C63
 131+ 5C63 E1           	POP HL
 132+ 5C64 C9           	RET
 133+ 5C65              ; *******************************************************************************************************
 134+ 5C65
 135+ 5C65              ; *******************************************************************************************************
 136+ 5C65              ; function to handle CALL BOXMEMVRM basic extension
 137+ 5C65              ; copies data with window like boundaries from ram to Vram
 138+ 5C65              ; BOXMEMVRM ( INT source data pointer,
 139+ 5C65              ;			  INT source number of bytes in a row,
 140+ 5C65              ;			  INT number of rows,
 141+ 5C65              ;			  INT source add-to value till next row,
 142+ 5C65              ; 			  INT destination pointer,
 143+ 5C65              ;			  INT destination add-to value till next row )
 144+ 5C65              ; request_data_ptr described in RECTANGLE_COPY
 145+ 5C65              ; will put ram in page 0 also, page 1 is already there
 146+ 5C65              BOXMEMVRM:
 147+ 5C65 11 6F 5C     	LD DE,BOXMEMVRM.RET
 148+ 5C68 ED 53 4E 5C  	LD (BOXCOMMON.ADDR+2), DE
 149+ 5C6C C3 ED 5B     	JP BOXCOMMON
 150+ 5C6F              .RET:
 151+ 5C6F FB           	EI
 152+ 5C70              	; set RAM functions to call
 153+ 5C70 21 8A 5C     	LD HL, .SETDEST
 154+ 5C73 22 B6 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 155+ 5C76 21 92 5C     	LD HL, .COPYDATA
 156+ 5C79 22 B9 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 157+ 5C7C 3E CD        	LD A, #CD ; CALL
 158+ 5C7E 32 B5 5B     	LD (RECTANGLE_COPY.CALL1), A
 159+ 5C81 32 B8 5B     	LD (RECTANGLE_COPY.CALL2), A
 160+ 5C84              	;LD A,1
 161+ 5C84 32 97 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 162+ 5C87 C3 53 5C     	JP BOXCOMMON.CALL
 163+ 5C8A              .SETDEST:
 164+ 5C8A EB           	EX DE, HL
 165+ 5C8B F3           	DI
 166+ 5C8C CD 6D 64     	CALL SETWRT_LOCAL
 167+ 5C8F FB           	EI
 168+ 5C90 EB           	EX DE, HL
 169+ 5C91 C9           	RET
 170+ 5C92              .COPYDATA:
 171+ 5C92 41           	LD B, C
 172+ 5C93 C3 78 64     	JP BBYTECOPY
 173+ 5C96              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 145  5C96               ENDIF
 146  5C96
 147  5C96               IF (BLIT_CMDS == 1)
 148  5C96               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C96              ; *******************************************************************************************************
   2+ 5C96              ; function rotates mask and data of several characters and applies to background data
   3+ 5C96              ; this handles x-shift from 0 to 4
   4+ 5C96              ; contains self-modifying code that is set-up from external function
   5+ 5C96              ; input HL=pointer to mask data
   6+ 5C96              ; input HL'=pointer to character data
   7+ 5C96              ; input DE=output buffer containing background data
   8+ 5C96              ; input BC=DE+8
   9+ 5C96              ; input A=number of characters to process
  10+ 5C96              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C96              SHIFT04:
  12+ 5C96 08           	EX AF, AF'
  13+ 5C97 7E           	LD A, (HL) ; get mask
  14+ 5C98 D9           	EXX
  15+ 5C99 57           	LD D, A
  16+ 5C9A 1E FF        	LD E, #FF
  17+ 5C9C 37           	SCF
  18+ 5C9D              .M1:
  19+ 5C9D 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C9F CB 1A        	RR D
  21+ 5CA1 CB 1B        	RR E
  22+ 5CA3 CB 1A        	RR D
  23+ 5CA5 CB 1B        	RR E
  24+ 5CA7 CB 1A        	RR D
  25+ 5CA9 CB 1B        	RR E
  26+ 5CAB CB 1A        	RR D
  27+ 5CAD CB 1B        	RR E
  28+ 5CAF
  29+ 5CAF 46           	LD B, (HL) ; get data
  30+ 5CB0 0E 00        	LD C, 0
  31+ 5CB2              .M2:
  32+ 5CB2 18 FE        	JR .M2 ; also self-modifying part
  33+ 5CB4 CB 38        	SRL B
  34+ 5CB6 CB 19        	RR C
  35+ 5CB8 CB 38        	SRL B
  36+ 5CBA CB 19        	RR C
  37+ 5CBC CB 38        	SRL B
  38+ 5CBE CB 19        	RR C
  39+ 5CC0 CB 38        	SRL B
  40+ 5CC2 CB 19        	RR C
  41+ 5CC4
  42+ 5CC4 D9           	EXX
  43+ 5CC5 1A           	LD A, (DE) ; background
  44+ 5CC6 D9           	EXX
  45+ 5CC7 A2           	AND D
  46+ 5CC8 B0           	OR B
  47+ 5CC9 D9           	EXX
  48+ 5CCA 12           	LD (DE), A
  49+ 5CCB
  50+ 5CCB 0A           	LD A, (BC)
  51+ 5CCC D9           	EXX
  52+ 5CCD A3           	AND E
  53+ 5CCE B1           	OR C
  54+ 5CCF 23           	INC HL
  55+ 5CD0 D9           	EXX
  56+ 5CD1 02           	LD (BC), A
  57+ 5CD2
  58+ 5CD2 23           	INC HL
  59+ 5CD3 13           	INC DE
  60+ 5CD4 03           	INC BC
  61+ 5CD5
  62+ 5CD5 08           	EX AF, AF'
  63+ 5CD6 3D           	DEC A
  64+ 5CD7 C2 96 5C     	JP NZ, SHIFT04
  65+ 5CDA C9           	RET
  66+ 5CDB              ; *******************************************************************************************************
  67+ 5CDB
  68+ 5CDB              ; *******************************************************************************************************
  69+ 5CDB              ; function rotates mask and data of several characters and applies to background data
  70+ 5CDB              ; this handles x-shift from 5 to 8
  71+ 5CDB              ; contains self-modifying code that is set-up from external function
  72+ 5CDB              ; input HL=pointer to mask data
  73+ 5CDB              ; input HL'=pointer to character data
  74+ 5CDB              ; input DE=output buffer containing background data
  75+ 5CDB              ; input BC=DE+8
  76+ 5CDB              ; input A=number of characters to process
  77+ 5CDB              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5CDB              SHIFT58:
  79+ 5CDB 08           	EX AF, AF'
  80+ 5CDC 7E           	LD A, (HL) ; get mask
  81+ 5CDD D9           	EXX
  82+ 5CDE 57           	LD D, A
  83+ 5CDF 1E FF        	LD E, #FF
  84+ 5CE1 37           	SCF
  85+ 5CE2              .M1:
  86+ 5CE2 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5CE4 CB 12        	RL D
  88+ 5CE6 CB 13        	RL E
  89+ 5CE8 CB 12        	RL D
  90+ 5CEA CB 13        	RL E
  91+ 5CEC CB 12        	RL D
  92+ 5CEE CB 13        	RL E
  93+ 5CF0
  94+ 5CF0 46           	LD B, (HL)
  95+ 5CF1 0E 00        	LD C, 0
  96+ 5CF3              .M2:
  97+ 5CF3 18 FE        	JR .M2 ; also self-modifying part
  98+ 5CF5 CB 20        	SLA B
  99+ 5CF7 CB 11        	RL C
 100+ 5CF9 CB 20        	SLA B
 101+ 5CFB CB 11        	RL C
 102+ 5CFD CB 20        	SLA B
 103+ 5CFF CB 11        	RL C
 104+ 5D01
 105+ 5D01 D9           	EXX
 106+ 5D02 1A           	LD A, (DE) ; background
 107+ 5D03 D9           	EXX
 108+ 5D04 A3           	AND E
 109+ 5D05 B1           	OR C
 110+ 5D06 D9           	EXX
 111+ 5D07 12           	LD (DE), A
 112+ 5D08
 113+ 5D08 0A           	LD A, (BC)
 114+ 5D09 D9           	EXX
 115+ 5D0A A2           	AND D
 116+ 5D0B B0           	OR B
 117+ 5D0C 23           	INC HL
 118+ 5D0D D9           	EXX
 119+ 5D0E 02           	LD (BC), A
 120+ 5D0F
 121+ 5D0F 23           	INC HL
 122+ 5D10 13           	INC DE
 123+ 5D11 03           	INC BC
 124+ 5D12
 125+ 5D12 08           	EX AF, AF'
 126+ 5D13 3D           	DEC A
 127+ 5D14 C2 DB 5C     	JP NZ, SHIFT58
 128+ 5D17 C9           	RET
 129+ 5D18              ; *******************************************************************************************************
 130+ 5D18
 131+ 5D18              ; *******************************************************************************************************
 132+ 5D18              ; routine that shifts one row of characters
 133+ 5D18              ; contains self-modifying code that is set-up from external function
 134+ 5D18              ; input HL=pointer to mask data
 135+ 5D18              ; input HL'=pointer to character data
 136+ 5D18              ; input DE=output buffer containing background data
 137+ 5D18              ; input A=number of characters to process
 138+ 5D18              ; input IX=pointer to structure describing input data
 139+ 5D18              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5D18              SHIFT_ROW:
 141+ 5D18 F5           	PUSH AF
 142+ 5D19 ED 53 82 62  		LD (BLIT_TMP1), DE
 143+ 5D1D E5           		PUSH HL
 144+ 5D1E CD 61 5D     			CALL .ADDYSHIFT
 145+ 5D21 E1           		POP HL
 146+ 5D22 ED 53 84 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5D26              .L1:
 148+ 5D26 3E 08        		LD A, 8
 149+ 5D28 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5D2B              .CALL1:
 151+ 5D2B CD 00 00     		CALL 0
 152+ 5D2E DD 7E 02     		LD A, (IX+2); y shift
 153+ 5D31 B7           		OR A
 154+ 5D32 28 26        		JR Z, .DONE
 155+ 5D34 ED 5B 82 62  		LD DE, (BLIT_TMP1)
 156+ 5D38 E5           		PUSH HL
 157+ 5D39 CD 6F 5D     			CALL .DETONEXTROW
 158+ 5D3C E1           		POP HL
 159+ 5D3D              .CALL2:
 160+ 5D3D CD 00 00     		CALL 0
 161+ 5D40 ED 5B 82 62  		LD DE, (BLIT_TMP1)
 162+ 5D44 E5           		PUSH HL
 163+ 5D45 CD 69 5D     			CALL .ADD8
 164+ 5D48 E1           		POP HL
 165+ 5D49 ED 53 82 62  		LD (BLIT_TMP1), DE
 166+ 5D4D ED 5B 84 62  		LD DE, (BLIT_TMP2)
 167+ 5D51 E5           		PUSH HL
 168+ 5D52 CD 69 5D     			CALL .ADD8
 169+ 5D55 E1           		POP HL
 170+ 5D56 ED 53 84 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5D5A              .DONE:
 172+ 5D5A F1           	POP AF
 173+ 5D5B 3D           	DEC A
 174+ 5D5C C8           	RET Z
 175+ 5D5D F5           	PUSH AF
 176+ 5D5E C3 26 5D     	JP .L1
 177+ 5D61              .ADDYSHIFT:
 178+ 5D61 EB           	EX DE, HL
 179+ 5D62 16 00        	LD D, 0
 180+ 5D64 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5D67 18 0C        	JR .MOVDEBC
 182+ 5D69              .ADD8:
 183+ 5D69 21 08 00     	LD HL, 8
 184+ 5D6C C3 75 5D     	JP .MOVDEBC
 185+ 5D6F              .DETONEXTROW:
 186+ 5D6F DD 6E 06     	LD L, (IX+6)
 187+ 5D72 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D75              .MOVDEBC:
 189+ 5D75 19           	ADD HL, DE
 190+ 5D76 54           	LD D, H
 191+ 5D77 5D           	LD E, L
 192+ 5D78 01 08 00     	LD BC, 8
 193+ 5D7B 09           	ADD HL, BC
 194+ 5D7C 44           	LD B, H
 195+ 5D7D 4D           	LD C, L
 196+ 5D7E C9           	RET
 197+ 5D7F              ; *******************************************************************************************************
 198+ 5D7F
 199+ 5D7F              ; *******************************************************************************************************
 200+ 5D7F              ; function rotates mask and character data and applies it to background
 201+ 5D7F              ; input IX=pointer to structure describing input data
 202+ 5D7F              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D7F              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D7F              ; +4  DW background data start;
 205+ 5D7F              ; +6  DW background add to value to next row of background data
 206+ 5D7F              ; +8  DW mask data start;
 207+ 5D7F              ; +10  DW character data start;
 208+ 5D7F              ; +12 DW character&mask add to value to next row of data
 209+ 5D7F              ; +14 DW columns (low byte used)
 210+ 5D7F              ; +16 DW rows (low byte used)
 211+ 5D7F              SHIFT_MERGE_CHARACTER:
 212+ 5D7F DD 7E 00     	LD A, (IX) ; shift
 213+ 5D82 FE 05        	CP 5
 214+ 5D84 38 25        	JR C, .RIGHT
 215+ 5D86              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D86 21 DB 5C     	LD HL, SHIFT58
 217+ 5D89 22 2C 5D     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D8C 22 3E 5D     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D8F D6 05        	SUB 5
 220+ 5D91 28 0D        	JR Z, .L1
 221+ 5D93 87           	ADD A, A
 222+ 5D94 87           	ADD A, A
 223+ 5D95 67           	LD H, A
 224+ 5D96 2E 18        	LD L, #18 ; JR opcode
 225+ 5D98 22 E2 5C     	LD (SHIFT58.M1), HL
 226+ 5D9B 22 F3 5C     	LD (SHIFT58.M2), HL
 227+ 5D9E 18 32        	JR .DO
 228+ 5DA0              .L1:
 229+ 5DA0 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5DA3 22 E2 5C     	LD (SHIFT58.M1), HL
 231+ 5DA6 22 F3 5C     	LD (SHIFT58.M2), HL
 232+ 5DA9 18 27        	JR .DO
 233+ 5DAB              .RIGHT:
 234+ 5DAB              	; shifts 0-4, rotate towards right
 235+ 5DAB 21 96 5C     	LD HL, SHIFT04
 236+ 5DAE 22 2C 5D     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5DB1 22 3E 5D     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5DB4 FE 04        	CP 4
 239+ 5DB6 28 11        	JR Z, .R1
 240+ 5DB8 D6 04        	SUB 4
 241+ 5DBA ED 44        	NEG
 242+ 5DBC 87           	ADD A, A
 243+ 5DBD 87           	ADD A, A
 244+ 5DBE 67           	LD H, A
 245+ 5DBF 2E 18        	LD L, #18 ; JR opcode
 246+ 5DC1 22 9D 5C     	LD (SHIFT04.M1), HL
 247+ 5DC4 22 B2 5C     	LD (SHIFT04.M2), HL
 248+ 5DC7 18 09        	JR .DO
 249+ 5DC9              .R1:
 250+ 5DC9 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5DCC 22 9D 5C     	LD (SHIFT04.M1), HL
 252+ 5DCF 22 B2 5C     	LD (SHIFT04.M2), HL
 253+ 5DD2              .DO:
 254+ 5DD2 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5DD5 DD 6E 08     	LD L, (IX+8)
 256+ 5DD8 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5DDB DD 5E 04     	LD E, (IX+4)
 258+ 5DDE DD 56 05     	LD D, (IX+5) ; background data
 259+ 5DE1 D9           	EXX
 260+ 5DE2 DD 6E 0A     	LD L, (IX+10)
 261+ 5DE5 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5DE8 D9           	EXX
 263+ 5DE9              .LOOP:
 264+ 5DE9 C5           	PUSH BC
 265+ 5DEA E5           		PUSH HL
 266+ 5DEB D5           			PUSH DE
 267+ 5DEC D9           				EXX
 268+ 5DED E5           				PUSH HL
 269+ 5DEE D9           					EXX
 270+ 5DEF DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5DF2              .CALL:
 272+ 5DF2 CD 18 5D     					CALL SHIFT_ROW
 273+ 5DF5 E1           				POP HL
 274+ 5DF6 DD 5E 0C     				LD E, (IX+12)
 275+ 5DF9 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5DFC 19           				ADD HL, DE
 277+ 5DFD D9           				EXX
 278+ 5DFE E1           			POP HL
 279+ 5DFF DD 5E 06     			LD E, (IX+6)
 280+ 5E02 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5E05 19           			ADD HL, DE
 282+ 5E06 EB           			EX DE, HL
 283+ 5E07 E1           		POP HL
 284+ 5E08 DD 4E 0C     		LD C, (IX+12)
 285+ 5E0B DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5E0E 09           		ADD HL, BC
 287+ 5E0F C1           	POP BC
 288+ 5E10 10 D7        	DJNZ .LOOP
 289+ 5E12 C9           	RET
 290+ 5E13              ; *******************************************************************************************************
 291+ 5E13
 292+ 5E13               IFNDEF CMDS_WITH_PARAMETERS
 293+ 5E13 ~            ; *******************************************************************************************************
 294+ 5E13 ~            ; function to handle CALL BLIT basic extension
 295+ 5E13 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 296+ 5E13 ~            ; fuses with background data and applies vertical shift too
 297+ 5E13 ~            ; BLIT ( INT request_data_ptr )
 298+ 5E13 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
 299+ 5E13 ~            ; will put ram in page 0 also, page 1 is already there
 300+ 5E13 ~            BLIT:
 301+ 5E13 ~            	; opening (
 302+ 5E13 ~            	CALL CHKCHAR
 303+ 5E13 ~            	DB '('
 304+ 5E13 ~            	; get pointer to request struct
 305+ 5E13 ~            	LD IX, FRMQNT
 306+ 5E13 ~            	CALL CALBAS
 307+ 5E13 ~            	PUSH DE
 308+ 5E13 ~            	; ending )
 309+ 5E13 ~            	CALL CHKCHAR
 310+ 5E13 ~            	DB ')'
 311+ 5E13 ~
 312+ 5E13 ~            	POP IX ; pointer to request struct
 313+ 5E13 ~
 314+ 5E13 ~            	PUSH HL ; save position in BASIC buffer
 315+ 5E13 ~
 316+ 5E13 ~            	LD IY, .RET
 317+ 5E13 ~            	JP ENABLE_PAGE0
 318+ 5E13 ~            .RET:
 319+ 5E13 ~            	EI
 320+ 5E13 ~            	CALL SHIFT_MERGE_CHARACTER
 321+ 5E13 ~
 322+ 5E13 ~                POP DE
 323+ 5E13 ~                POP BC
 324+ 5E13 ~                CALL RESTORE_PAGE_INFO
 325+ 5E13 ~
 326+ 5E13 ~            	POP HL
 327+ 5E13 ~            	RET
 328+ 5E13 ~            ; *******************************************************************************************************
 329+ 5E13               ENDIF
 330+ 5E13
 331+ 5E13               IFDEF CMDS_WITH_PARAMETERS
 332+ 5E13              ; *******************************************************************************************************
 333+ 5E13              ; function to handle CALL BLIT basic extension
 334+ 5E13              ; rotates 1-bit character drawing horizontally with mask and character data and
 335+ 5E13              ; fuses with background data and applies vertical shift too
 336+ 5E13              ; in form without pointers
 337+ 5E13              ; BLIT ( INT x,
 338+ 5E13              ;		 INT y,
 339+ 5E13              ;		 INT char_data_pointer,
 340+ 5E13              ;		 INT mask_data_pointer,
 341+ 5E13              ;		 INT width (in characters),
 342+ 5E13              ;		 INT height (in characters),
 343+ 5E13              ;		 INT background_pointer (top left),
 344+ 5E13              ;		 INT background_width (in characters),
 345+ 5E13              ;		 INT background_height (in characters))
 346+ 5E13              ; will put ram in page 0 also, page 1 is already there
 347+ 5E13              BLIT:
 348+ 5E13              	; opening (
 349+ 5E13 CD 94 65     	CALL CHKCHAR
 350+ 5E16 28           	DB '('
 351+ 5E17              	; get x coordinate
 352+ 5E17 DD 21 2F 54  	LD IX, FRMQNT
 353+ 5E1B CD 59 01     	CALL CALBAS
 354+ 5E1E 7B           	LD A, E
 355+ 5E1F E6 07        	AND 7
 356+ 5E21 32 86 62     	LD (BLIT_STRUCT+0), A
 357+ 5E24 CD 01 5F     	CALL .DAdiv8
 358+ 5E27 32 82 62     	LD (BLIT_TMP+0),A
 359+ 5E2A              	; comma
 360+ 5E2A CD 94 65     	CALL CHKCHAR
 361+ 5E2D 2C           	DB ','
 362+ 5E2E              	; get y coordinate
 363+ 5E2E DD 21 2F 54  	LD IX, FRMQNT
 364+ 5E32 CD 59 01     	CALL CALBAS
 365+ 5E35 7B           	LD A, E
 366+ 5E36 E6 07        	AND 7
 367+ 5E38 32 88 62     	LD (BLIT_STRUCT+2), A
 368+ 5E3B CD 01 5F     	CALL .DAdiv8
 369+ 5E3E 32 83 62     	LD (BLIT_TMP+1),A
 370+ 5E41              	; comma
 371+ 5E41 CD 94 65     	CALL CHKCHAR
 372+ 5E44 2C           	DB ','
 373+ 5E45              	; get char data pointer
 374+ 5E45 DD 21 2F 54  	LD IX, FRMQNT
 375+ 5E49 CD 59 01     	CALL CALBAS
 376+ 5E4C ED 53 90 62  	LD (BLIT_STRUCT+10), DE
 377+ 5E50              	; comma
 378+ 5E50 CD 94 65     	CALL CHKCHAR
 379+ 5E53 2C           	DB ','
 380+ 5E54              	; get mask data pointer
 381+ 5E54 DD 21 2F 54  	LD IX, FRMQNT
 382+ 5E58 CD 59 01     	CALL CALBAS
 383+ 5E5B ED 53 8E 62  	LD (BLIT_STRUCT+8), DE
 384+ 5E5F              	; comma
 385+ 5E5F CD 94 65     	CALL CHKCHAR
 386+ 5E62 2C           	DB ','
 387+ 5E63              	; get width
 388+ 5E63 DD 21 2F 54  	LD IX, FRMQNT
 389+ 5E67 CD 59 01     	CALL CALBAS
 390+ 5E6A 7B           	LD A, E
 391+ 5E6B 32 94 62     	LD (BLIT_STRUCT+14), A
 392+ 5E6E              	; comma
 393+ 5E6E CD 94 65     	CALL CHKCHAR
 394+ 5E71 2C           	DB ','
 395+ 5E72              	; get height
 396+ 5E72 DD 21 2F 54  	LD IX, FRMQNT
 397+ 5E76 CD 59 01     	CALL CALBAS
 398+ 5E79 7B           	LD A, E
 399+ 5E7A 32 96 62     	LD (BLIT_STRUCT+16), A
 400+ 5E7D              	; comma
 401+ 5E7D CD 94 65     	CALL CHKCHAR
 402+ 5E80 2C           	DB ','
 403+ 5E81              	; get background pointer
 404+ 5E81 DD 21 2F 54  	LD IX, FRMQNT
 405+ 5E85 CD 59 01     	CALL CALBAS
 406+ 5E88 ED 53 8A 62  	LD (BLIT_STRUCT+4), DE
 407+ 5E8C              	; comma
 408+ 5E8C CD 94 65     	CALL CHKCHAR
 409+ 5E8F 2C           	DB ','
 410+ 5E90              	; get background width
 411+ 5E90 DD 21 2F 54  	LD IX, FRMQNT
 412+ 5E94 CD 59 01     	CALL CALBAS
 413+ 5E97 7B           	LD A, E
 414+ 5E98 32 84 62     	LD (BLIT_TMP+2), A
 415+ 5E9B              	; comma
 416+ 5E9B CD 94 65     	CALL CHKCHAR
 417+ 5E9E 2C           	DB ','
 418+ 5E9F              	; get background height
 419+ 5E9F DD 21 2F 54  	LD IX, FRMQNT
 420+ 5EA3 CD 59 01     	CALL CALBAS
 421+ 5EA6 7B           	LD A, E
 422+ 5EA7 32 85 62     	LD (BLIT_TMP+3), A
 423+ 5EAA              	; ending )
 424+ 5EAA CD 94 65     	CALL CHKCHAR
 425+ 5EAD 29           	DB ')'
 426+ 5EAE
 427+ 5EAE E5           	PUSH HL ; save position in BASIC buffer
 428+ 5EAF
 429+ 5EAF              	; calculate char&mask add to value
 430+ 5EAF 26 00        	LD H, 0
 431+ 5EB1 3A 94 62     	LD A, (BLIT_STRUCT+14)
 432+ 5EB4 6F           	LD L, A
 433+ 5EB5 CD 82 64     	CALL HLx8
 434+ 5EB8 22 92 62     	LD (BLIT_STRUCT+12), HL
 435+ 5EBB              	; calculate background add to value
 436+ 5EBB 26 00        	LD H, 0
 437+ 5EBD 3A 84 62     	LD A, (BLIT_TMP+2)
 438+ 5EC0 6F           	LD L, A
 439+ 5EC1 CD 82 64     	CALL HLx8
 440+ 5EC4 22 8C 62     	LD (BLIT_STRUCT+6), HL
 441+ 5EC7              	; calculate pointer to background location
 442+ 5EC7 21 00 00     	LD HL, 0
 443+ 5ECA 3A 83 62     	LD A,(BLIT_TMP+1)
 444+ 5ECD B7           	OR A
 445+ 5ECE 28 08        	JR Z, .L1
 446+ 5ED0 47           	LD B,A
 447+ 5ED1 ED 5B 8C 62  	LD DE,(BLIT_STRUCT+6)
 448+ 5ED5              .L0:
 449+ 5ED5 19           	ADD HL, DE
 450+ 5ED6 10 FD        	DJNZ .L0
 451+ 5ED8              .L1:
 452+ 5ED8 EB           	EX DE,HL
 453+ 5ED9 26 00        	LD H,0
 454+ 5EDB 3A 82 62     	LD A,(BLIT_TMP+0)
 455+ 5EDE 6F           	LD L,A
 456+ 5EDF CD 82 64     	CALL HLx8
 457+ 5EE2 19           	ADD HL,DE
 458+ 5EE3 ED 5B 8A 62  	LD DE,(BLIT_STRUCT+4)
 459+ 5EE7 19           	ADD HL,DE
 460+ 5EE8 22 8A 62     	LD (BLIT_STRUCT+4),HL
 461+ 5EEB
 462+ 5EEB FD 21 F2 5E  	LD IY, .RET
 463+ 5EEF C3 46 65     	JP ENABLE_PAGE0
 464+ 5EF2              .RET:
 465+ 5EF2 FB           	EI
 466+ 5EF3 DD 21 86 62  	LD IX, BLIT_STRUCT
 467+ 5EF7 CD 7F 5D     	CALL SHIFT_MERGE_CHARACTER
 468+ 5EFA
 469+ 5EFA D1               POP DE
 470+ 5EFB C1               POP BC
 471+ 5EFC CD BD 64         CALL RESTORE_PAGE_INFO
 472+ 5EFF
 473+ 5EFF E1           	POP HL
 474+ 5F00 C9           	RET
 475+ 5F01              .DAdiv8:
 476+ 5F01 7B           	LD A,E
 477+ 5F02 CB 2A        	SRA D
 478+ 5F04 CB 1F            RR  A
 479+ 5F06 CB 2A            SRA D
 480+ 5F08 CB 1F            RR  A
 481+ 5F0A CB 2A            SRA D
 482+ 5F0C CB 1F            RR  A
 483+ 5F0E C9           	RET
 484+ 5F0F              ; *******************************************************************************************************
 485+ 5F0F               ENDIF
# file closed: asm\BLIT.asm
 149  5F0F               ENDIF
 150  5F0F
 151  5F0F               IF (TILE_CMDS == 1)
 152  5F0F               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5F0F              ; *******************************************************************************************************
   2+ 5F0F              ; generic function to implement tiling
   3+ 5F0F              ; should be modified to call appropriate function for memory or vram
   4+ 5F0F              ; input IX=pointer to following structure
   5+ 5F0F              ; +00 tile_data_ptr
   6+ 5F0F              ; +02 tile_rows
   7+ 5F0F              ; +04 tile_columns
   8+ 5F0F              ; +06 destination_address
   9+ 5F0F              ; +08 dest_to_next_row_add_to_value
  10+ 5F0F              ; +10 num_horizontal_tiles
  11+ 5F0F              ; +12 num_vertical_tiles
  12+ 5F0F              ; modifies AF, BC, DE, HL
  13+ 5F0F              TILE:
  14+ 5F0F DD 6E 06     	LD L, (IX+6)
  15+ 5F12 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5F15 22 82 62     	LD (TILETMP1), HL
  17+ 5F18 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5F1B              .L1:
  19+ 5F1B C5           	PUSH BC
  20+ 5F1C DD 6E 00     		LD L, (IX+0)
  21+ 5F1F DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5F22 22 84 62     		LD (TILETMP2), HL
  23+ 5F25 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5F28              .L2:
  25+ 5F28 C5           		PUSH BC
  26+ 5F29 CD 00 00     .CALL1:		CALL 0
  27+ 5F2C DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5F2F              .L3:
  29+ 5F2F C5           			PUSH BC
  30+ 5F30 2A 84 62     				LD HL, (TILETMP2)
  31+ 5F33 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5F36              .L4:
  33+ 5F36 C5           				PUSH BC
  34+ 5F37              .CALL2:
  35+ 5F37 CD 00 00     					CALL 0
  36+ 5F3A C1           				POP BC
  37+ 5F3B 10 F9        				DJNZ .L4
  38+ 5F3D C1           			POP BC
  39+ 5F3E 10 EF        			DJNZ .L3
  40+ 5F40 22 84 62     			LD (TILETMP2), HL
  41+ 5F43 2A 82 62     			LD HL, (TILETMP1)
  42+ 5F46 DD 5E 08     			LD E, (IX+8)
  43+ 5F49 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5F4C 19           			ADD HL, DE
  45+ 5F4D 22 82 62     			LD (TILETMP1), HL
  46+ 5F50 C1           		POP BC
  47+ 5F51 10 D5        		DJNZ .L2
  48+ 5F53 C1           	POP BC
  49+ 5F54 10 C5        	DJNZ .L1
  50+ 5F56 C9           	RET
  51+ 5F57              ; *******************************************************************************************************
  52+ 5F57
  53+ 5F57               IFNDEF CMDS_WITH_PARAMETERS
  54+ 5F57 ~            ; *******************************************************************************************************
  55+ 5F57 ~            ; function to handle CALL TILERAM basic extension
  56+ 5F57 ~            ; fills memory with tiles
  57+ 5F57 ~            ; TILERAM ( INT request_data_ptr )
  58+ 5F57 ~            ; request_data_ptr described in TILE
  59+ 5F57 ~            ; will put ram in page 0 also, page 1 is already there
  60+ 5F57 ~            TILERAM:
  61+ 5F57 ~            	; opening (
  62+ 5F57 ~            	CALL CHKCHAR
  63+ 5F57 ~            	DB '('
  64+ 5F57 ~            	; get pointer to request struct
  65+ 5F57 ~            	LD IX, FRMQNT
  66+ 5F57 ~            	CALL CALBAS
  67+ 5F57 ~            	PUSH DE
  68+ 5F57 ~            	; ending )
  69+ 5F57 ~            	CALL CHKCHAR
  70+ 5F57 ~            	DB ')'
  71+ 5F57 ~
  72+ 5F57 ~            	POP IX ; pointer to request struct
  73+ 5F57 ~
  74+ 5F57 ~            	PUSH HL ; save position in BASIC buffer
  75+ 5F57 ~
  76+ 5F57 ~            	LD IY, .RET
  77+ 5F57 ~            	JP ENABLE_PAGE0
  78+ 5F57 ~            .RET:
  79+ 5F57 ~            	EI
  80+ 5F57 ~            	; set RAM functions to call
  81+ 5F57 ~            	LD HL, .TILECOPY
  82+ 5F57 ~            	LD (TILE.CALL2+1), HL
  83+ 5F57 ~            	LD HL, .SETDESTROW
  84+ 5F57 ~            	LD (TILE.CALL1+1), HL
  85+ 5F57 ~            	LD A,1
  86+ 5F57 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 5F57 ~            	CALL TILE
  88+ 5F57 ~            	XOR A
  89+ 5F57 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 5F57 ~
  91+ 5F57 ~                POP DE
  92+ 5F57 ~                POP BC
  93+ 5F57 ~                CALL RESTORE_PAGE_INFO
  94+ 5F57 ~
  95+ 5F57 ~            	POP HL
  96+ 5F57 ~            	RET
  97+ 5F57 ~            .TILECOPY:
  98+ 5F57 ~            	.8 LDI
  99+ 5F57 ~            	RET
 100+ 5F57 ~            .SETDESTROW:
 101+ 5F57 ~            	LD DE, (TILETMP1)
 102+ 5F57 ~            	RET
 103+ 5F57 ~            ; *******************************************************************************************************
 104+ 5F57               ENDIF
 105+ 5F57
 106+ 5F57               IFDEF CMDS_WITH_PARAMETERS
 107+ 5F57              ; *******************************************************************************************************
 108+ 5F57              ; function to handle CALL TILERAM basic extension
 109+ 5F57              ; fills memory with tiles
 110+ 5F57              ; TILERAM ( INT tile_data_pointer,
 111+ 5F57              ;			INT tile_columns,
 112+ 5F57              ;			INT tile_rows,
 113+ 5F57              ;			INT destination_pointer,
 114+ 5F57              ;			INT destination_columns,
 115+ 5F57              ;			INT destination_rows,
 116+ 5F57              ;			INT destination_begin_column,
 117+ 5F57              ;			INT destination_begin_row,
 118+ 5F57              ;			INT number_of_tiles_horizontally,
 119+ 5F57              ;			INT	number_of_tiles_vertically )
 120+ 5F57              ; will put ram in page 0 also, page 1 is already there
 121+ 5F57              TILERAM:
 122+ 5F57              	; opening (
 123+ 5F57 CD 94 65     	CALL CHKCHAR
 124+ 5F5A 28           	DB '('
 125+ 5F5B              	; get tile data pointer coordinate
 126+ 5F5B DD 21 2F 54  	LD IX, FRMQNT
 127+ 5F5F CD 59 01     	CALL CALBAS
 128+ 5F62 ED 53 86 62  	LD (BLIT_STRUCT+0), DE
 129+ 5F66              	; comma
 130+ 5F66 CD 94 65     	CALL CHKCHAR
 131+ 5F69 2C           	DB ','
 132+ 5F6A              	; get tile columns
 133+ 5F6A DD 21 2F 54  	LD IX, FRMQNT
 134+ 5F6E CD 59 01     	CALL CALBAS
 135+ 5F71 ED 53 8A 62  	LD (BLIT_STRUCT+4), DE
 136+ 5F75              	; comma
 137+ 5F75 CD 94 65     	CALL CHKCHAR
 138+ 5F78 2C           	DB ','
 139+ 5F79              	; get tile columns
 140+ 5F79 DD 21 2F 54  	LD IX, FRMQNT
 141+ 5F7D CD 59 01     	CALL CALBAS
 142+ 5F80 ED 53 88 62  	LD (BLIT_STRUCT+2), DE
 143+ 5F84              	; comma
 144+ 5F84 CD 94 65     	CALL CHKCHAR
 145+ 5F87 2C           	DB ','
 146+ 5F88              	; get destintion pointer
 147+ 5F88 DD 21 2F 54  	LD IX, FRMQNT
 148+ 5F8C CD 59 01     	CALL CALBAS
 149+ 5F8F ED 53 8C 62  	LD (BLIT_STRUCT+6), DE
 150+ 5F93              	; comma
 151+ 5F93 CD 94 65     	CALL CHKCHAR
 152+ 5F96 2C           	DB ','
 153+ 5F97              	; get destination columns
 154+ 5F97 DD 21 2F 54  	LD IX, FRMQNT
 155+ 5F9B CD 59 01     	CALL CALBAS
 156+ 5F9E 7B           	LD A, E
 157+ 5F9F 32 82 62     	LD (BLIT_TMP+0), A
 158+ 5FA2              	; comma
 159+ 5FA2 CD 94 65     	CALL CHKCHAR
 160+ 5FA5 2C           	DB ','
 161+ 5FA6              	; get destination rows
 162+ 5FA6 DD 21 2F 54  	LD IX, FRMQNT
 163+ 5FAA CD 59 01     	CALL CALBAS
 164+ 5FAD 7B           	LD A, E
 165+ 5FAE 32 83 62     	LD (BLIT_TMP+1), A
 166+ 5FB1              	; comma
 167+ 5FB1 CD 94 65     	CALL CHKCHAR
 168+ 5FB4 2C           	DB ','
 169+ 5FB5              	; get destination begin column
 170+ 5FB5 DD 21 2F 54  	LD IX, FRMQNT
 171+ 5FB9 CD 59 01     	CALL CALBAS
 172+ 5FBC 7B           	LD A, E
 173+ 5FBD 32 84 62     	LD (BLIT_TMP+2), A
 174+ 5FC0              	; comma
 175+ 5FC0 CD 94 65     	CALL CHKCHAR
 176+ 5FC3 2C           	DB ','
 177+ 5FC4              	; get destination begin row
 178+ 5FC4 DD 21 2F 54  	LD IX, FRMQNT
 179+ 5FC8 CD 59 01     	CALL CALBAS
 180+ 5FCB 7B           	LD A, E
 181+ 5FCC 32 85 62     	LD (BLIT_TMP+3), A
 182+ 5FCF              	; comma
 183+ 5FCF CD 94 65     	CALL CHKCHAR
 184+ 5FD2 2C           	DB ','
 185+ 5FD3              	; get number of tiles horizontally
 186+ 5FD3 DD 21 2F 54  	LD IX, FRMQNT
 187+ 5FD7 CD 59 01     	CALL CALBAS
 188+ 5FDA ED 53 90 62  	LD (BLIT_STRUCT+10), DE
 189+ 5FDE              	; comma
 190+ 5FDE CD 94 65     	CALL CHKCHAR
 191+ 5FE1 2C           	DB ','
 192+ 5FE2              	; get number of tiles vertically
 193+ 5FE2 DD 21 2F 54  	LD IX, FRMQNT
 194+ 5FE6 CD 59 01     	CALL CALBAS
 195+ 5FE9 ED 53 92 62  	LD (BLIT_STRUCT+12), DE
 196+ 5FED              	; ending )
 197+ 5FED CD 94 65     	CALL CHKCHAR
 198+ 5FF0 29           	DB ')'
 199+ 5FF1
 200+ 5FF1 E5           	PUSH HL ; save position in BASIC buffer
 201+ 5FF2
 202+ 5FF2              	; calculate destination add to value
 203+ 5FF2 26 00        	LD H, 0
 204+ 5FF4 3A 82 62     	LD A, (BLIT_TMP+0)
 205+ 5FF7 6F           	LD L, A
 206+ 5FF8 CD 82 64     	CALL HLx8
 207+ 5FFB 22 8E 62     	LD (BLIT_STRUCT+8), HL
 208+ 5FFE              	; calculate pointer to background location
 209+ 5FFE 21 00 00     	LD HL, 0
 210+ 6001 3A 85 62     	LD A,(BLIT_TMP+3)
 211+ 6004 B7           	OR A
 212+ 6005 28 08        	JR Z, .L1
 213+ 6007 47           	LD B,A
 214+ 6008 ED 5B 8E 62  	LD DE,(BLIT_STRUCT+8)
 215+ 600C              .L0:
 216+ 600C 19           	ADD HL, DE
 217+ 600D 10 FD        	DJNZ .L0
 218+ 600F              .L1:
 219+ 600F EB           	EX DE,HL
 220+ 6010 26 00        	LD H,0
 221+ 6012 3A 84 62     	LD A,(BLIT_TMP+2)
 222+ 6015 6F           	LD L,A
 223+ 6016 CD 82 64     	CALL HLx8
 224+ 6019 19           	ADD HL,DE
 225+ 601A ED 5B 8C 62  	LD DE,(BLIT_STRUCT+6)
 226+ 601E 19           	ADD HL,DE
 227+ 601F 22 8C 62     	LD (BLIT_STRUCT+6),HL
 228+ 6022
 229+ 6022 FD 21 29 60  	LD IY, .RET
 230+ 6026 C3 46 65     	JP ENABLE_PAGE0
 231+ 6029              .RET:
 232+ 6029 FB           	EI
 233+ 602A              	; set RAM functions to call
 234+ 602A 21 44 60     	LD HL, .TILECOPY
 235+ 602D 22 38 5F     	LD (TILE.CALL2+1), HL
 236+ 6030 21 55 60     	LD HL, .SETDESTROW
 237+ 6033 22 2A 5F     	LD (TILE.CALL1+1), HL
 238+ 6036 DD 21 86 62  	LD IX,BLIT_STRUCT
 239+ 603A CD 0F 5F     	CALL TILE
 240+ 603D
 241+ 603D D1               POP DE
 242+ 603E C1               POP BC
 243+ 603F CD BD 64         CALL RESTORE_PAGE_INFO
 244+ 6042
 245+ 6042 E1           	POP HL
 246+ 6043 C9           	RET
 247+ 6044              .TILECOPY:
 248+ 6044 ED A0       > LDI
 248+ 6046 ED A0       > LDI
 248+ 6048 ED A0       > LDI
 248+ 604A ED A0       > LDI
 248+ 604C ED A0       > LDI
 248+ 604E ED A0       > LDI
 248+ 6050 ED A0       > LDI
 248+ 6052 ED A0       > LDI
 249+ 6054 C9           	RET
 250+ 6055              .SETDESTROW:
 251+ 6055 ED 5B 82 62  	LD DE, (TILETMP1)
 252+ 6059 C9           	RET
 253+ 605A              ; *******************************************************************************************************
 254+ 605A               ENDIF
 255+ 605A
 256+ 605A               IFDEF CMDS_WITH_PARAMETERS
 257+ 605A              ; *******************************************************************************************************
 258+ 605A              ; function to handle CALL TILEVRM basic extension
 259+ 605A              ; fills vram with tiles
 260+ 605A              ; TILEVRM ( INT tile_data_pointer,
 261+ 605A              ;			INT tile_columns,
 262+ 605A              ;			INT tile_rows,
 263+ 605A              ;			INT destination_begin_column,
 264+ 605A              ;			INT destination_begin_row,
 265+ 605A              ;			INT number_of_tiles_horizontally,
 266+ 605A              ;			INT	number_of_tiles_vertically )
 267+ 605A              ; will put ram in page 0 also, page 1 is already there
 268+ 605A              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 605A              TILEVRM:
 270+ 605A              	; opening (
 271+ 605A CD 94 65     	CALL CHKCHAR
 272+ 605D 28           	DB '('
 273+ 605E              	; get tile data pointer coordinate
 274+ 605E DD 21 2F 54  	LD IX, FRMQNT
 275+ 6062 CD 59 01     	CALL CALBAS
 276+ 6065 ED 53 86 62  	LD (BLIT_STRUCT+0), DE
 277+ 6069              	; comma
 278+ 6069 CD 94 65     	CALL CHKCHAR
 279+ 606C 2C           	DB ','
 280+ 606D              	; get tile columns
 281+ 606D DD 21 2F 54  	LD IX, FRMQNT
 282+ 6071 CD 59 01     	CALL CALBAS
 283+ 6074 ED 53 8A 62  	LD (BLIT_STRUCT+4), DE
 284+ 6078              	; comma
 285+ 6078 CD 94 65     	CALL CHKCHAR
 286+ 607B 2C           	DB ','
 287+ 607C              	; get tile columns
 288+ 607C DD 21 2F 54  	LD IX, FRMQNT
 289+ 6080 CD 59 01     	CALL CALBAS
 290+ 6083 ED 53 88 62  	LD (BLIT_STRUCT+2), DE
 291+ 6087              	; comma
 292+ 6087 CD 94 65     	CALL CHKCHAR
 293+ 608A 2C           	DB ','
 294+ 608B              	; get destination begin column
 295+ 608B DD 21 2F 54  	LD IX, FRMQNT
 296+ 608F CD 59 01     	CALL CALBAS
 297+ 6092 7B           	LD A, E
 298+ 6093 32 84 62     	LD (BLIT_TMP+2), A
 299+ 6096              	; comma
 300+ 6096 CD 94 65     	CALL CHKCHAR
 301+ 6099 2C           	DB ','
 302+ 609A              	; get destination begin row
 303+ 609A DD 21 2F 54  	LD IX, FRMQNT
 304+ 609E CD 59 01     	CALL CALBAS
 305+ 60A1 7B           	LD A, E
 306+ 60A2 32 85 62     	LD (BLIT_TMP+3), A
 307+ 60A5              	; comma
 308+ 60A5 CD 94 65     	CALL CHKCHAR
 309+ 60A8 2C           	DB ','
 310+ 60A9              	; get number of tiles horizontally
 311+ 60A9 DD 21 2F 54  	LD IX, FRMQNT
 312+ 60AD CD 59 01     	CALL CALBAS
 313+ 60B0 ED 53 90 62  	LD (BLIT_STRUCT+10), DE
 314+ 60B4              	; comma
 315+ 60B4 CD 94 65     	CALL CHKCHAR
 316+ 60B7 2C           	DB ','
 317+ 60B8              	; get number of tiles vertically
 318+ 60B8 DD 21 2F 54  	LD IX, FRMQNT
 319+ 60BC CD 59 01     	CALL CALBAS
 320+ 60BF ED 53 92 62  	LD (BLIT_STRUCT+12), DE
 321+ 60C3              	; ending )
 322+ 60C3 CD 94 65     	CALL CHKCHAR
 323+ 60C6 29           	DB ')'
 324+ 60C7
 325+ 60C7 E5           	PUSH HL ; save position in BASIC buffer
 326+ 60C8
 327+ 60C8              	; calculate destination add to value
 328+ 60C8 21 00 01     	LD HL, 256
 329+ 60CB 22 8E 62     	LD (BLIT_STRUCT+8), HL
 330+ 60CE              	; calculate pointer to background location
 331+ 60CE 3A 85 62     	LD A,(BLIT_TMP+3)
 332+ 60D1 67           	LD H,A
 333+ 60D2 2E 00        	LD L,0
 334+ 60D4 EB           	EX DE,HL
 335+ 60D5 26 00        	LD H,0
 336+ 60D7 3A 84 62     	LD A,(BLIT_TMP+2)
 337+ 60DA 6F           	LD L,A
 338+ 60DB CD 82 64     	CALL HLx8
 339+ 60DE 19           	ADD HL,DE
 340+ 60DF ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 60E3 19           	ADD HL,DE
 342+ 60E4 22 8C 62     	LD (BLIT_STRUCT+6),HL
 343+ 60E7
 344+ 60E7 FD 21 EE 60  	LD IY, .RET
 345+ 60EB C3 46 65     	JP ENABLE_PAGE0
 346+ 60EE              .RET:
 347+ 60EE FB           	EI
 348+ 60EF              	; set RAM functions to call
 349+ 60EF 21 09 61     	LD HL, .TILECOPY
 350+ 60F2 22 38 5F     	LD (TILE.CALL2+1), HL
 351+ 60F5 21 0F 61     	LD HL, .SETDESTROW
 352+ 60F8 22 2A 5F     	LD (TILE.CALL1+1), HL
 353+ 60FB DD 21 86 62  	LD IX,BLIT_STRUCT
 354+ 60FF CD 0F 5F     	CALL TILE
 355+ 6102
 356+ 6102 D1               POP DE
 357+ 6103 C1               POP BC
 358+ 6104 CD BD 64         CALL RESTORE_PAGE_INFO
 359+ 6107
 360+ 6107 E1           	POP HL
 361+ 6108 C9           	RET
 362+ 6109              .TILECOPY:
 363+ 6109 01 98 08     	LD BC, #0898
 364+ 610C C3 7A 64     	JP BBYTECOPY_NO_C
 365+ 610F              .SETDESTROW:
 366+ 610F 2A 82 62     	LD HL, (TILETMP1)
 367+ 6112 F3           	DI
 368+ 6113 CD 6D 64     	CALL SETWRT_LOCAL
 369+ 6116 FB           	EI
 370+ 6117 C9           	RET
 371+ 6118              ; *******************************************************************************************************
 372+ 6118               ENDIF
 373+ 6118
 374+ 6118               IFNDEF CMDS_WITH_PARAMETERS
 375+ 6118 ~            ; *******************************************************************************************************
 376+ 6118 ~            ; function to handle CALL TILEVRM basic extension
 377+ 6118 ~            ; fills vram with tiles
 378+ 6118 ~            ; TILEVRM ( INT request_data_ptr )
 379+ 6118 ~            ; request_data_ptr described in TILE
 380+ 6118 ~            ; will put ram in page 0 also, page 1 is already there
 381+ 6118 ~            TILEVRM:
 382+ 6118 ~            	; opening (
 383+ 6118 ~            	CALL CHKCHAR
 384+ 6118 ~            	DB '('
 385+ 6118 ~            	; get pointer to request struct
 386+ 6118 ~            	LD IX, FRMQNT
 387+ 6118 ~            	CALL CALBAS
 388+ 6118 ~            	PUSH DE
 389+ 6118 ~            	; ending )
 390+ 6118 ~            	CALL CHKCHAR
 391+ 6118 ~            	DB ')'
 392+ 6118 ~
 393+ 6118 ~            	POP IX ; pointer to request struct
 394+ 6118 ~
 395+ 6118 ~            	PUSH HL ; save position in BASIC buffer
 396+ 6118 ~
 397+ 6118 ~            	LD IY, .RET
 398+ 6118 ~            	JP ENABLE_PAGE0
 399+ 6118 ~            .RET:
 400+ 6118 ~            	EI
 401+ 6118 ~            	; set RAM functions to call
 402+ 6118 ~            	LD HL, .TILECOPY
 403+ 6118 ~            	LD (TILE.CALL2+1), HL
 404+ 6118 ~            	LD HL, .SETDESTROW
 405+ 6118 ~            	LD (TILE.CALL1+1), HL
 406+ 6118 ~            	CALL TILE
 407+ 6118 ~
 408+ 6118 ~                POP DE
 409+ 6118 ~                POP BC
 410+ 6118 ~                CALL RESTORE_PAGE_INFO
 411+ 6118 ~
 412+ 6118 ~            	POP HL
 413+ 6118 ~            	RET
 414+ 6118 ~            .TILECOPY:
 415+ 6118 ~            	LD BC, #0898
 416+ 6118 ~            	JP BBYTECOPY_NO_C
 417+ 6118 ~            .SETDESTROW:
 418+ 6118 ~            	LD HL, (TILETMP1)
 419+ 6118 ~            	DI
 420+ 6118 ~            	CALL SETWRT_LOCAL
 421+ 6118 ~            	EI
 422+ 6118 ~            	RET
 423+ 6118 ~            ; *******************************************************************************************************
 424+ 6118               ENDIF
# file closed: asm\TILE.asm
 153  6118               ENDIF
 154  6118
 155  6118               IF (BYTEOPS_CMDS == 1)
 156  6118 ~             INCLUDE "BYTEOPS.asm"
 157  6118               ENDIF
 158  6118
 159  6118               IF (COLL_CMD == 1)
 160  6118               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 6118              ; ************************************************************************************************
   2+ 6118              ; quick test if HL<=DE<=HL+BC
   3+ 6118              ; input BC=width, DE=x, HL=min
   4+ 6118              ; if not true flag C set
   5+ 6118              ; modifies AF
   6+ 6118              GENERIC_INNER_CHECK:
   7+ 6118 E5               PUSH HL
   8+ 6119 D5               PUSH DE
   9+ 611A EB               EX DE,HL
  10+ 611B A7               AND A
  11+ 611C ED 52            SBC HL, DE
  12+ 611E FA 2C 61         JP M, .GENERIC_INNER_CHECK_NOT
  13+ 6121 A7               AND A
  14+ 6122 ED 42            SBC HL, BC
  15+ 6124 28 03            JR Z, .L2
  16+ 6126 F2 2C 61         JP P, .GENERIC_INNER_CHECK_NOT
  17+ 6129              .L2:
  18+ 6129 A7               AND A
  19+ 612A 18 01            JR .EXIT
  20+ 612C              .GENERIC_INNER_CHECK_NOT:
  21+ 612C 37               SCF
  22+ 612D              .EXIT:
  23+ 612D D1               POP DE
  24+ 612E E1               POP HL
  25+ 612F C9               RET
  26+ 6130              ; ************************************************************************************************
  27+ 6130
  28+ 6130              ; ************************************************************************************************
  29+ 6130              ; function to check if rectangles are overlapping
  30+ 6130              ; input IX=pointer to struct
  31+ 6130              ;  +00 active flag
  32+ 6130              ;  +02 x coordinate
  33+ 6130              ;  +04 y coordinate
  34+ 6130              ;  +06 x offset where rectangle begins
  35+ 6130              ;  +08 y offset where rectangle begins
  36+ 6130              ;  +10 width
  37+ 6130              ;  +12 height
  38+ 6130              ; input BLIT_STRUCT data
  39+ 6130              ;  +00 x coordinate
  40+ 6130              ;  +02 y coordinate
  41+ 6130              ;  +04 width
  42+ 6130              ;  +06 height
  43+ 6130              ; returns CF=1 if not overlapping, CF=0 if overlapping
  44+ 6130              RECTANGLE_OVERLAP_CHECK:
  45+ 6130                  ; first check which rectanlge is higher
  46+ 6130 DD 6E 0C         LD L,(IX+12)
  47+ 6133 DD 66 0D         LD H,(IX+13)
  48+ 6136 ED 5B 8C 62      LD DE,(BLIT_STRUCT+6)
  49+ 613A A7               AND A
  50+ 613B ED 52            SBC HL,DE
  51+ 613D DD 6E 04         LD L,(IX+4)
  52+ 6140 DD 66 05         LD H,(IX+5)
  53+ 6143 DD 5E 08         LD E,(IX+8)
  54+ 6146 DD 56 09         LD D,(IX+9)
  55+ 6149 FA 69 61         JP M,.L1
  56+ 614C                  ; equally high or IX defined one higher
  57+ 614C                  ; check upper boundary
  58+ 614C 19               ADD HL,DE
  59+ 614D ED 5B 88 62      LD DE,(BLIT_STRUCT+2)
  60+ 6151 DD 4E 0C         LD C,(IX+12)
  61+ 6154 DD 46 0D         LD B,(IX+13)
  62+ 6157 CD 18 61         CALL GENERIC_INNER_CHECK
  63+ 615A 30 29            JR NC,.INSIDE
  64+ 615C                  ; check lower boundary
  65+ 615C E5               PUSH HL
  66+ 615D 2A 8C 62         LD HL,(BLIT_STRUCT+6)
  67+ 6160 19               ADD HL,DE
  68+ 6161 EB               EX DE,HL
  69+ 6162 E1               POP HL
  70+ 6163 CD 18 61         CALL GENERIC_INNER_CHECK
  71+ 6166 30 1D            JR NC,.INSIDE
  72+ 6168 C9               RET ; not overlapping
  73+ 6169              .L1:
  74+ 6169                  ; rectangle defined in BLIT_STRUCT is higher
  75+ 6169 19               ADD HL,DE
  76+ 616A EB               EX DE,HL
  77+ 616B 2A 88 62         LD HL,(BLIT_STRUCT+2)
  78+ 616E ED 4B 8C 62      LD BC,(BLIT_STRUCT+6)
  79+ 6172 CD 18 61         CALL GENERIC_INNER_CHECK
  80+ 6175 30 0E            JR NC,.INSIDE
  81+ 6177 E5               PUSH HL
  82+ 6178 DD 6E 0C         LD L,(IX+12)
  83+ 617B DD 66 0D         LD H,(IX+13)
  84+ 617E 19               ADD HL,DE
  85+ 617F EB               EX DE,HL
  86+ 6180 E1               POP HL
  87+ 6181 CD 18 61         CALL GENERIC_INNER_CHECK
  88+ 6184 D8               RET C
  89+ 6185              .INSIDE:
  90+ 6185                  ; check x coordinate
  91+ 6185                  ; first check which rectangle is wider
  92+ 6185 DD 6E 0A         LD L,(IX+10)
  93+ 6188 DD 66 0B         LD H,(IX+11)
  94+ 618B ED 5B 8A 62      LD DE,(BLIT_STRUCT+4)
  95+ 618F A7               AND A
  96+ 6190 ED 52            SBC HL,DE
  97+ 6192 DD 6E 02         LD L,(IX+2)
  98+ 6195 DD 66 03         LD H,(IX+3)
  99+ 6198 DD 5E 06         LD E,(IX+6)
 100+ 619B DD 56 07         LD D,(IX+7)
 101+ 619E FA BA 61         JP M,.L2
 102+ 61A1                  ; equally wide or IX defined one wider
 103+ 61A1                  ; check left boundary
 104+ 61A1 19               ADD HL,DE
 105+ 61A2 ED 5B 86 62      LD DE,(BLIT_STRUCT+0)
 106+ 61A6 DD 4E 0A         LD C,(IX+10)
 107+ 61A9 DD 46 0B         LD B,(IX+11)
 108+ 61AC CD 18 61         CALL GENERIC_INNER_CHECK
 109+ 61AF D0               RET NC ; overlap
 110+ 61B0                  ; check right boundary
 111+ 61B0 E5               PUSH HL
 112+ 61B1 2A 8A 62         LD HL,(BLIT_STRUCT+4)
 113+ 61B4 19               ADD HL,DE
 114+ 61B5 EB               EX DE,HL
 115+ 61B6 E1               POP HL
 116+ 61B7 C3 18 61         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 117+ 61BA              .L2:
 118+ 61BA                  ; rectangle defined in BLIT_STRUCT is higher
 119+ 61BA 19               ADD HL,DE
 120+ 61BB EB               EX DE,HL
 121+ 61BC 2A 86 62         LD HL,(BLIT_STRUCT+0)
 122+ 61BF ED 4B 8A 62      LD BC,(BLIT_STRUCT+4)
 123+ 61C3 CD 18 61         CALL GENERIC_INNER_CHECK
 124+ 61C6 D0               RET NC ; overlap
 125+ 61C7 E5               PUSH HL
 126+ 61C8 DD 6E 0A         LD L,(IX+10)
 127+ 61CB DD 66 0B         LD H,(IX+11)
 128+ 61CE 19               ADD HL,DE
 129+ 61CF EB               EX DE,HL
 130+ 61D0 E1               POP HL
 131+ 61D1 C3 18 61         JP GENERIC_INNER_CHECK
 132+ 61D4              ; ************************************************************************************************
 133+ 61D4
 134+ 61D4              ; ************************************************************************************************
 135+ 61D4              ; function tries to find rectangle overlap and returns an index if found
 136+ 61D4              ; input BLIT_STRUCT data
 137+ 61D4              ;  +00 x coordinate
 138+ 61D4              ;  +02 y coordinate
 139+ 61D4              ;  +04 width
 140+ 61D4              ;  +06 height
 141+ 61D4              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 142+ 61D4              ;  +09 pointer to first element
 143+ 61D4              ;  +11 pointer to INT result variable
 144+ 61D4              ; returns CF=1 if not overlapping
 145+ 61D4              ; returns A=list index and CF=0 if overlapping
 146+ 61D4              FIND_OVERLAP:
 147+ 61D4 3A 8E 62         LD A,(BLIT_STRUCT+8)
 148+ 61D7 47               LD B,A
 149+ 61D8 DD 2A 8F 62      LD IX,(BLIT_STRUCT+9)
 150+ 61DC              .L1:
 151+ 61DC C5               PUSH BC
 152+ 61DD DD 7E 00         LD A,(IX)
 153+ 61E0 DD B6 01         OR (IX+1)
 154+ 61E3 28 0C            JR Z,.NEXT
 155+ 61E5 CD 30 61         CALL RECTANGLE_OVERLAP_CHECK
 156+ 61E8 38 07            JR C,.NEXT
 157+ 61EA                  ; found
 158+ 61EA C1               POP BC
 159+ 61EB 3A 8E 62         LD A,(BLIT_STRUCT+8)
 160+ 61EE 90               SUB B
 161+ 61EF A7               AND A
 162+ 61F0 C9               RET
 163+ 61F1              .NEXT:
 164+ 61F1 11 0E 00         LD DE,14
 165+ 61F4 DD 19            ADD IX,DE
 166+ 61F6 C1               POP BC
 167+ 61F7 10 E3            DJNZ .L1
 168+ 61F9 37               SCF
 169+ 61FA C9               RET
 170+ 61FB              ; ************************************************************************************************
 171+ 61FB
 172+ 61FB              ; ************************************************************************************************
 173+ 61FB              ; function to handle CALL COLL basic extension
 174+ 61FB              ; checks for collision between player and other rectangles
 175+ 61FB              ; COLL ( INT result variable,
 176+ 61FB              ;	     INT player x value,
 177+ 61FB              ;	     INT player y value,
 178+ 61FB              ;	     INT player width,
 179+ 61FB              ;	     INT player height,
 180+ 61FB              ;	     INT number of items in a list,
 181+ 61FB              ;		 INT[6][n] rectangle struct )
 182+ 61FB              ; will fill result variable with index or -1 if no collision
 183+ 61FB              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 184+ 61FB              COLL:
 185+ 61FB              	; opening (
 186+ 61FB CD 94 65     	CALL CHKCHAR
 187+ 61FE 28           	DB '('
 188+ 61FF              	; get address of result variable
 189+ 61FF DD 21 A4 5E  	LD IX, PTRGET
 190+ 6203 CD 59 01     	CALL CALBAS
 191+ 6206 ED 53 91 62  	LD (BLIT_STRUCT+11),DE
 192+ 620A              	; comma
 193+ 620A CD 94 65     	CALL CHKCHAR
 194+ 620D 2C           	DB ','
 195+ 620E              	; get x
 196+ 620E DD 21 2F 54  	LD IX, FRMQNT
 197+ 6212 CD 59 01     	CALL CALBAS
 198+ 6215 ED 53 86 62  	LD (BLIT_STRUCT+0),DE
 199+ 6219              	; comma
 200+ 6219 CD 94 65     	CALL CHKCHAR
 201+ 621C 2C           	DB ','
 202+ 621D              	; get y
 203+ 621D DD 21 2F 54  	LD IX, FRMQNT
 204+ 6221 CD 59 01     	CALL CALBAS
 205+ 6224 ED 53 88 62  	LD (BLIT_STRUCT+2),DE
 206+ 6228              	; comma
 207+ 6228 CD 94 65     	CALL CHKCHAR
 208+ 622B 2C           	DB ','
 209+ 622C              	; get width
 210+ 622C DD 21 2F 54  	LD IX, FRMQNT
 211+ 6230 CD 59 01     	CALL CALBAS
 212+ 6233 ED 53 8A 62  	LD (BLIT_STRUCT+4),DE
 213+ 6237              	; comma
 214+ 6237 CD 94 65     	CALL CHKCHAR
 215+ 623A 2C           	DB ','
 216+ 623B              	; get height
 217+ 623B DD 21 2F 54  	LD IX, FRMQNT
 218+ 623F CD 59 01     	CALL CALBAS
 219+ 6242 ED 53 8C 62  	LD (BLIT_STRUCT+6),DE
 220+ 6246              	; comma
 221+ 6246 CD 94 65     	CALL CHKCHAR
 222+ 6249 2C           	DB ','
 223+ 624A              	; get number of items in a list
 224+ 624A DD 21 1C 52  	LD IX, GETBYT
 225+ 624E CD 59 01     	CALL CALBAS
 226+ 6251 32 8E 62     	LD (BLIT_STRUCT+8),A
 227+ 6254              	; comma
 228+ 6254 CD 94 65     	CALL CHKCHAR
 229+ 6257 2C           	DB ','
 230+ 6258              	; get address of rectangle structure array DIM R%(6,n)
 231+ 6258 3A 8E 62     	LD A,(BLIT_STRUCT+8)
 232+ 625B 5F               LD E,A
 233+ 625C 3E 02            LD A,2
 234+ 625E 47           	LD B,A
 235+ 625F 16 07        	LD D,7
 236+ 6261 CD C1 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 237+ 6264 ED 43 8F 62  	LD (BLIT_STRUCT+9),BC
 238+ 6268              	; ending )
 239+ 6268 CD 94 65     	CALL CHKCHAR
 240+ 626B 29           	DB ')'
 241+ 626C
 242+ 626C E5               PUSH HL
 243+ 626D CD D4 61         CALL FIND_OVERLAP
 244+ 6270 2A 91 62         LD HL,(BLIT_STRUCT+11)
 245+ 6273 38 06            JR C,.NOTFOUND
 246+ 6275 77               LD (HL),A
 247+ 6276 23               INC HL
 248+ 6277 36 00            LD (HL),0
 249+ 6279 E1               POP HL
 250+ 627A C9               RET
 251+ 627B              .NOTFOUND:
 252+ 627B 36 FF            LD (HL),#FF
 253+ 627D 23               INC HL
 254+ 627E 36 FF            LD (HL),#FF
 255+ 6280 E1               POP HL
 256+ 6281 C9               RET
 257+ 6282              ; ************************************************************************************************
 258+ 6282
# file closed: asm\COLLISION.asm
 161  6282               ENDIF
 162  6282
 163  6282              ; temp variables for BLIT, TILE functions
 164  6282               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 165  6282              BLIT_TMP:
 166  6282              TILETMP1:
 167  6282              BLIT_TMP1:
 168  6282 00 00         DW 0
 169  6284              TILETMP2:
 170  6284              BLIT_TMP2:
 171  6284 00 00         DW 0
 172  6286                IFDEF CMDS_WITH_PARAMETERS
 173  6286              BLIT_STRUCT:
 174  6286 00 00 00...   DS 17
 175  628A                ENDIF
 176  628A               ENDIF
 177  6297
 178  6297               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 179  6297              VRAM_UPDATE_IN_PROGRESS:
 180  6297 00            DB 0
 181  6298               ENDIF
 182  6298
 183  6298              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 184  6298              ; per starting letter, if no commands with this letter, NULL value
 185  6298              CMDS:
 186  6298               IF (ANIM_CMDS == 1)
 187  6298 D7 63        	DW CMDS_A ;
 188  629A               ELSE
 189  629A ~                DW 0 ; A
 190  629A               ENDIF
 191  629A               IF (BLIT_CMDS + BOX_CMDS > 0)
 192  629A A2 63            DW CMDS_B ; B
 193  629C               ELSE
 194  629C ~            	DW 0
 195  629C               ENDIF
 196  629C               IF (COLL_CMD == 1)
 197  629C 65 64        	DW CMDS_C ;
 198  629E               ELSE
 199  629E ~                DW 0 ; C
 200  629E               ENDIF
 201  629E 00 00            DW 0 ; D
 202  62A0 00 00            DW 0 ; E
 203  62A2               IF (VRAM_CMDS + RAM_CMDS > 0)
 204  62A2 19 63            DW CMDS_F; F
 205  62A4               ELSE
 206  62A4 ~            	DW 0
 207  62A4               ENDIF
 208  62A4               IF (GENCAL_CMD > 0)
 209  62A4 2C 63            DW CMDS_G; G
 210  62A6               ELSE
 211  62A6 ~            	DW 0
 212  62A6               ENDIF
 213  62A6               IF (BYTEOPS_CMDS == 1)
 214  62A6 ~                DW CMDS_H; H
 215  62A6               ELSE
 216  62A6 00 00            DW 0
 217  62A8               ENDIF
 218  62A8 00 00            DW 0 ; I
 219  62AA 00 00            DW 0 ; J
 220  62AC 00 00            DW 0 ; K
 221  62AE               IF (BYTEOPS_CMDS == 1)
 222  62AE ~                DW CMDS_L; L
 223  62AE               ELSE
 224  62AE 00 00            DW 0
 225  62B0               ENDIF
 226  62B0               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 227  62B0 CC 62            DW CMDS_M ; M
 228  62B2               ELSE
 229  62B2 ~            	DW 0
 230  62B2               ENDIF
 231  62B2 00 00            DW 0 ; N
 232  62B4 00 00            DW 0 ; O
 233  62B6 00 00            DW 0 ; P
 234  62B8 00 00            DW 0 ; Q
 235  62BA               IF (BYTEOPS_CMDS == 1)
 236  62BA ~                DW CMDS_R; R
 237  62BA               ELSE
 238  62BA 00 00            DW 0
 239  62BC               ENDIF
 240  62BC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 241  62BC 40 63            DW CMDS_S ; S
 242  62BE               ELSE
 243  62BE ~            	DW 0
 244  62BE               ENDIF
 245  62BE               IF (TILE_CMDS > 0)
 246  62BE C2 63            DW CMDS_T ; T
 247  62C0               ELSE
 248  62C0 ~            	DW 0
 249  62C0               ENDIF
 250  62C0 00 00            DW 0 ; U
 251  62C2               IF (VRAM_CMDS > 0)
 252  62C2 36 63            DW CMDS_V ; V
 253  62C4               ELSE
 254  62C4 ~            	DW 0
 255  62C4               ENDIF
 256  62C4               IF (BYTEOPS_CMDS == 1)
 257  62C4 ~                DW CMDS_W; W
 258  62C4               ELSE
 259  62C4 00 00            DW 0
 260  62C6               ENDIF
 261  62C6 00 00            DW 0 ; X
 262  62C8 00 00            DW 0 ; Y
 263  62CA 00 00            DW 0 ; Z
 264  62CC
 265  62CC              CMDS_M:
 266  62CC               IF (VRAM_CMDS == 1)
 267  62CC 4D 45 4D 56      DB "MEMVRM", 0
 267  62D0 52 4D 00
 268  62D3 5D 5A            DW MEMVRM
 269  62D5               ENDIF
 270  62D5               IF (RAM_CMDS == 1)
 271  62D5 4D 45 4D 43  	DB "MEMCPY", 0
 271  62D9 50 59 00
 272  62DC 93 58        	DW MEMCPY
 273  62DE               ENDIF
 274  62DE               IF (ANIM_CMDS == 1)
 275  62DE 4D 41 58 41  	DB "MAXANIMITEMS",0
 275  62E2 4E 49 4D 49
 275  62E6 54 45 4D 53
 275  62EA 00
 276  62EB 23 50        	DW MAXANIMITEMS
 277  62ED 4D 41 58 41  	DB "MAXANIMDEFS",0
 277  62F1 4E 49 4D 44
 277  62F5 45 46 53 00
 278  62F9 A8 51        	DW MAXANIMDEFS
 279  62FB 4D 41 58 41  	DB "MAXANIMSPRS",0
 279  62FF 4E 49 4D 53
 279  6303 50 52 53 00
 280  6307 3D 52        	DW MAXANIMSPRS
 281  6309 4D 41 58 41     DB "MAXAUTOSGAMS",0
 281  630D 55 54 4F 53
 281  6311 47 41 4D 53
 281  6315 00
 282  6316 84 53           DW MAXAUTOSGAMS
 283  6318               ENDIF
 284  6318               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 285  6318 00           	DB 0
 286  6319               ENDIF
 287  6319              CMDS_F:
 288  6319               IF (VRAM_CMDS == 1)
 289  6319 46 49 4C 56      DB "FILVRM", 0
 289  631D 52 4D 00
 290  6320 0D 5A            DW FILVRM
 291  6322               ENDIF
 292  6322               IF (RAM_CMDS == 1)
 293  6322 46 49 4C 52      DB "FILRAM", 0
 293  6326 41 4D 00
 294  6329 D6 58            DW FILRAM
 295  632B               ENDIF
 296  632B               IF (VRAM_CMDS + RAM_CMDS > 0)
 297  632B 00               DB 0
 298  632C               ENDIF
 299  632C              CMDS_G:
 300  632C               IF (GENCAL_CMD == 1)
 301  632C 47 45 4E 43      DB "GENCAL", 0
 301  6330 41 4C 00
 302  6333 41 5B            DW GENCAL
 303  6335               ENDIF
 304  6335               IF (GENCAL_CMD > 0)
 305  6335 00           	DB	0
 306  6336               ENDIF
 307  6336              CMDS_V:
 308  6336               IF (VRAM_CMDS == 1)
 309  6336 56 52 4D 4D  	DB "VRMMEM", 0
 309  633A 45 4D 00
 310  633D DC 5A        	DW VRMMEM
 311  633F               ENDIF
 312  633F               IF (VRAM_CMDS > 0)
 313  633F 00           	DB 0
 314  6340               ENDIF
 315  6340              CMDS_S:
 316  6340               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 317  6340 53 47 41 4D      DB "SGAM",0
 317  6344 00
 318  6345 FE 56            DW SGAM
 319  6347               ENDIF
 320  6347               IF (SPRITE_CMDS == 1)
 321  6347 53 50 52 53   	DB "SPRSET", 0
 321  634B 45 54 00
 322  634E A2 4E        	DW SPRSET
 323  6350 53 50 52 47  	DB "SPRGRPMOV", 0
 323  6354 52 50 4D 4F
 323  6358 56 00
 324  635A 53 4F        	DW SPRGRPMOV
 325  635C               ENDIF
 326  635C               IF (SOUND_CMDS == 1)
 327  635C 53 4E 44 53  	DB "SNDSFX", 0
 327  6360 46 58 00
 328  6363 B3 59        	DW SNDSFX
 329  6365 53 4E 44 50  	DB "SNDPLYON", 0
 329  6369 4C 59 4F 4E
 329  636D 00
 330  636E 7D 59        	DW SNDPLYON
 331  6370 53 4E 44 50  	DB "SNDPLYOFF", 0
 331  6374 4C 59 4F 46
 331  6378 46 00
 332  637A 90 59        	DW SNDPLYOFF
 333  637C 53 4E 44 50  	DB "SNDPLYINI", 0
 333  6380 4C 59 49 4E
 333  6384 49 00
 334  6386 33 59        	DW SNDPLYINIT
 335  6388               ENDIF
 336  6388               IF (SPRITE_CMDS == 1)
 337  6388 53 50 52 45  	DB "SPRENABLE", 0
 337  638C 4E 41 42 4C
 337  6390 45 00
 338  6392 5D 4E        	DW SPRENABLE
 339  6394 53 50 52 44  	DB "SPRDISABLE", 0
 339  6398 49 53 41 42
 339  639C 4C 45 00
 340  639F 9D 4E        	DW SPRDISABLE
 341  63A1               ENDIF
 342  63A1               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 343  63A1 00           	DB 0
 344  63A2               ENDIF
 345  63A2              CMDS_B:
 346  63A2               IF (BLIT_CMDS == 1)
 347  63A2 42 4C 49 54  	DB "BLIT", 0
 347  63A6 00
 348  63A7 13 5E        	DW BLIT
 349  63A9               ENDIF
 350  63A9               IF (BOX_CMDS == 1)
 351  63A9 42 4F 58 4D  	DB "BOXMEMCPY", 0
 351  63AD 45 4D 43 50
 351  63B1 59 00
 352  63B3 D0 5B        	DW BOXMEMCPY
 353  63B5 42 4F 58 4D  	DB "BOXMEMVRM", 0
 353  63B9 45 4D 56 52
 353  63BD 4D 00
 354  63BF 65 5C        	DW BOXMEMVRM
 355  63C1               ENDIF
 356  63C1               IF (BLIT_CMDS + BOX_CMDS > 0)
 357  63C1 00           	DB 0
 358  63C2               ENDIF
 359  63C2              CMDS_T:
 360  63C2               IF (TILE_CMDS == 1)
 361  63C2 54 49 4C 45  	DB "TILERAM", 0
 361  63C6 52 41 4D 00
 362  63CA 57 5F        	DW TILERAM
 363  63CC 54 49 4C 45  	DB "TILEVRM", 0
 363  63D0 56 52 4D 00
 364  63D4 5A 60        	DW TILEVRM
 365  63D6               ENDIF
 366  63D6               IF (TILE_CMDS > 0)
 367  63D6 00           	DB 0
 368  63D7               ENDIF
 369  63D7              CMDS_A:
 370  63D7               IF (ANIM_CMDS == 1)
 371  63D7 41 4E 49 4D     DB "ANIMSTEP",0
 371  63DB 53 54 45 50
 371  63DF 00
 372  63E0 54 55           DW ANIMSTEP
 373  63E2 41 4E 49 4D  	DB "ANIMSTART",0
 373  63E6 53 54 41 52
 373  63EA 54 00
 374  63EC 59 55        	DW ANIMSTART
 375  63EE 41 4E 49 4D  	DB "ANIMSTOP",0
 375  63F2 53 54 4F 50
 375  63F6 00
 376  63F7 5E 55        	DW ANIMSTOP
 377  63F9 41 4E 49 4D  	DB "ANIMITEMPAT",0
 377  63FD 49 54 45 4D
 377  6401 50 41 54 00
 378  6405 F3 50        	DW ANIMITEMPAT
 379  6407 41 4E 49 4D  	DB "ANIMITEMPTR",0
 379  640B 49 54 45 4D
 379  640F 50 54 52 00
 380  6413 54 51        	DW ANIMITEMPTR_CMD
 381  6415 41 4E 49 4D  	DB "ANIMDEF",0
 381  6419 44 45 46 00
 382  641D EA 51        	DW ANIMDEF
 383  641F 41 4E 49 4D  	DB "ANIMSPRITE",0
 383  6423 53 50 52 49
 383  6427 54 45 00
 384  642A 93 52        	DW ANIMSPRITE
 385  642C 41 4E 49 4D     DB "ANIMCHAR",0
 385  6430 43 48 41 52
 385  6434 00
 386  6435 0B 53           DW ANIMCHAR
 387  6437 41 55 54 4F     DB "AUTOSGAMDEF",0
 387  643B 53 47 41 4D
 387  643F 44 45 46 00
 388  6443 DE 53           DW AUTOSGAMDEF
 389  6445 41 55 54 4F     DB "AUTOSGAMSTART",0
 389  6449 53 47 41 4D
 389  644D 53 54 41 52
 389  6451 54 00
 390  6453 15 55           DW AUTOSGAMSTART
 391  6455 41 55 54 4F     DB "AUTOSGAMSTOP",0
 391  6459 53 47 41 4D
 391  645D 53 54 4F 50
 391  6461 00
 392  6462 51 55           DW AUTOSGAMSTOP
 393  6464 00           	DB 0
 394  6465               ENDIF
 395  6465              CMDS_H:
 396  6465               IF (BYTEOPS_CMDS == 1)
 397  6465 ~                DB "HI", 0
 398  6465 ~                DW HI
 399  6465               ENDIF
 400  6465               IF (BYTEOPS_CMDS > 0)
 401  6465 ~            	DB	0
 402  6465               ENDIF
 403  6465              CMDS_L:
 404  6465               IF (BYTEOPS_CMDS == 1)
 405  6465 ~                DB "LO", 0
 406  6465 ~                DW LO
 407  6465               ENDIF
 408  6465               IF (BYTEOPS_CMDS > 0)
 409  6465 ~            	DB	0
 410  6465               ENDIF
 411  6465              CMDS_W:
 412  6465               IF (BYTEOPS_CMDS == 1)
 413  6465 ~                DB "W", 0
 414  6465 ~                DW WORD
 415  6465               ENDIF
 416  6465               IF (BYTEOPS_CMDS > 0)
 417  6465 ~            	DB	0
 418  6465               ENDIF
 419  6465              CMDS_R:
 420  6465               IF (BYTEOPS_CMDS == 1)
 421  6465 ~                DB "RANGE", 0
 422  6465 ~                DW RANGE
 423  6465               ENDIF
 424  6465               IF (BYTEOPS_CMDS > 0)
 425  6465 ~            	DB	0
 426  6465               ENDIF
 427  6465              CMDS_C:
 428  6465               IF (COLL_CMD == 1)
 429  6465 43 4F 4C 4C      DB "COLL", 0
 429  6469 00
 430  646A FB 61            DW COLL
 431  646C               ENDIF
 432  646C               IF (COLL_CMD > 0)
 433  646C 00           	DB	0
 434  646D               ENDIF
 435  646D
 436  646D               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 437  646D              ; ****************************************************************************************************
 438  646D              ; function sets VRAM address
 439  646D              ; input HL=address
 440  646D              ; modifies AF
 441  646D              SETWRT_LOCAL:
 442  646D 7D           	LD	A, L
 443  646E D3 99        	OUT	(099H), A
 444  6470 7C           	LD	A, H
 445  6471 E6 3F        	AND	03FH
 446  6473 F6 40        	OR	040H
 447  6475 D3 99        	OUT	(099H), A
 448  6477 C9           	RET
 449  6478              ; ****************************************************************************************************
 450  6478               ENDIF
 451  6478
 452  6478               IF (VRAM_CMDS + TILE_CMDS > 0)
 453  6478              ; ****************************************************************************************************
 454  6478              ; function copies data from RAM to VRAM
 455  6478              ; input HL=address in RAM
 456  6478              ; input B=count
 457  6478              ; modifies AF, BC, HL
 458  6478              BBYTECOPY:
 459  6478 0E 98        	LD C,#98
 460  647A              BBYTECOPY_NO_C:
 461  647A ED A3        	OUTI
 462  647C C2 7A 64     	JP	NZ, BBYTECOPY_NO_C
 463  647F C9           	RET
 464  6480              ; ****************************************************************************************************
 465  6480               ENDIF
 466  6480
 467  6480              ; ****************************************************************************************************
 468  6480              ; function multiplies HL by 32
 469  6480              HLx32:
 470  6480 29           	ADD HL,HL
 471  6481              ; ****************************************************************************************************
 472  6481              ; function multiplies HL by 16
 473  6481              HLx16:
 474  6481 29           	ADD HL,HL
 475  6482              ; ****************************************************************************************************
 476  6482              ; function multiplies HL by 8
 477  6482              HLx8:
 478  6482 29          > ADD HL, HL
 478  6483 29          > ADD HL, HL
 478  6484 29          > ADD HL, HL
 479  6485 C9           	RET
 480  6486              ; ****************************************************************************************************
 481  6486
 482  6486              ; ****************************************************************************************************
 483  6486              ; function gets slot and subslot data for specific page
 484  6486              ; input A=page (0, 1 or 2)
 485  6486              ; output B = 0A8H register value
 486  6486              ; output D = 0 is no subslots, 1 if yes
 487  6486              ; output C = 0A8H value when page 3 slot equals to requested page slot
 488  6486              ; output E = subslot value if present
 489  6486              ; modifies AF, BC, DE, HL
 490  6486              GET_PAGE_INFO:
 491  6486 6F               LD L, A
 492  6487 C6 C1            ADD A, low (EXPTBL)
 493  6489 32 93 64         LD (GET_PAGE_INFO_L1+1), A
 494  648C DB A8            IN A, (0A8H)
 495  648E 47               LD B, A
 496  648F E6 3F            AND 03FH
 497  6491 4F               LD C, A
 498  6492              GET_PAGE_INFO_L1:
 499  6492 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 500  6495 E6 80            AND 080H
 501  6497 28 1B            JR Z, GET_PAGE_INFO_L2
 502  6499                  ; expanded
 503  6499 2D               DEC L
 504  649A FA B9 64         JP M, GET_PAGE_INFO_L3
 505  649D 2D               DEC L
 506  649E FA B7 64         JP M, GET_PAGE_INFO_L4
 507  64A1                  ; page 2
 508  64A1 07               RLCA
 509  64A2 07               RLCA
 510  64A3              GET_PAGE_INFO_L5:
 511  64A3 E6 C0            AND 0C0H
 512  64A5 B1               OR C
 513  64A6 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 514  64A8 4F               LD C, A
 515  64A9 3A FF FF         LD A, (0FFFFH)
 516  64AC 2F               CPL
 517  64AD 5F               LD E, A
 518  64AE 16 01            LD D, 1
 519  64B0 78               LD A, B ; return stack
 520  64B1 D3 A8            OUT (0A8H), A
 521  64B3 C9               RET
 522  64B4              GET_PAGE_INFO_L2:
 523  64B4                  ; not expanded
 524  64B4 16 00            LD D, 0
 525  64B6 C9               RET
 526  64B7              GET_PAGE_INFO_L4:
 527  64B7                  ; page 1
 528  64B7 0F               RRCA
 529  64B8 0F               RRCA
 530  64B9              GET_PAGE_INFO_L3:
 531  64B9                  ; page 0
 532  64B9 0F               RRCA
 533  64BA 0F               RRCA
 534  64BB 18 E6            JR GET_PAGE_INFO_L5
 535  64BD              ; ****************************************************************************************************
 536  64BD
 537  64BD              ; ****************************************************************************************************
 538  64BD              ; function returns original slot and subslot info
 539  64BD              ; input B = 0A8H register value
 540  64BD              ; input D = 0 is no subslots, 1 if yes
 541  64BD              ; input C = 0A8H value when page 3 slot equals to requested page slot
 542  64BD              ; input E = subslot value if present
 543  64BD              ; modifies AF, disables interrupts
 544  64BD              RESTORE_PAGE_INFO:
 545  64BD 7A              LD A, D
 546  64BE B7              OR A
 547  64BF 28 08           JR Z, RESTORE_PAGE_INFO_L1
 548  64C1 79              LD A, C
 549  64C2 F3           	DI
 550  64C3 D3 A8           OUT (0A8H), A
 551  64C5 7B              LD A, E
 552  64C6 32 FF FF        LD (0FFFFH), A
 553  64C9              RESTORE_PAGE_INFO_L1:
 554  64C9 78              LD A, B
 555  64CA D3 A8           OUT (0A8H), A
 556  64CC C9              RET
 557  64CD              ; ****************************************************************************************************
 558  64CD
 559  64CD              ; *******************************************************************************************************
 560  64CD              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 561  64CD              ; INPUT:  A = SLOT ID: EXXXSSPP
 562  64CD              ; E = EXPANDED FLAG
 563  64CD              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 564  64CD              ; PP = PRIMARY SLOT NUMBER
 565  64CD              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 566  64CD              ; CHANGES: AF, BC, DE
 567  64CD
 568  64CD              LOCAL_ENASLT:
 569  64CD CD ED 64         CALL L0353
 570  64D0 FA DA 64         JP M, L0340
 571  64D3 DB A8            IN A, (0A8H)
 572  64D5 A1               AND C
 573  64D6 B0               OR B
 574  64D7 D3 A8            OUT (0A8H), A
 575  64D9 C9               RET
 576  64DA              L0340:
 577  64DA E5               PUSH HL
 578  64DB CD 12 65         CALL L0378
 579  64DE 4F               LD C, A
 580  64DF 06 00            LD B, 0
 581  64E1 7D               LD A, L
 582  64E2 A4               AND H
 583  64E3 B2               OR D
 584  64E4 21 C5 FC         LD HL, 0FCC5H
 585  64E7 09               ADD HL, BC
 586  64E8 77               LD (HL), A
 587  64E9 E1               POP HL
 588  64EA 79               LD A, C
 589  64EB 18 E0            JR LOCAL_ENASLT
 590  64ED              L0353:
 591  64ED F3               DI
 592  64EE F5               PUSH AF
 593  64EF 7C               LD A, H
 594  64F0 07               RLCA
 595  64F1 07               RLCA
 596  64F2 E6 03            AND 3
 597  64F4 5F               LD E, A
 598  64F5 3E C0            LD A, 0C0H
 599  64F7              L035D:
 600  64F7 07               RLCA
 601  64F8 07               RLCA
 602  64F9 1D               DEC E
 603  64FA F2 F7 64         JP P, L035D
 604  64FD 5F               LD E, A
 605  64FE 2F               CPL
 606  64FF 4F               LD C, A
 607  6500 F1               POP AF
 608  6501 F5               PUSH AF
 609  6502 E6 03            AND 3
 610  6504 3C               INC A
 611  6505 47               LD B, A
 612  6506 3E AB            LD A, 0ABH
 613  6508              L036E:
 614  6508 C6 55            ADD A, 055H
 615  650A 10 FC            DJNZ L036E
 616  650C 57               LD D, A
 617  650D A3               AND E
 618  650E 47               LD B, A
 619  650F F1               POP AF
 620  6510 A7               AND A
 621  6511 C9               RET
 622  6512              L0378:
 623  6512 F5               PUSH AF
 624  6513 7A               LD A, D
 625  6514 E6 C0            AND 0C0H
 626  6516 4F               LD C, A
 627  6517 F1               POP AF
 628  6518 F5               PUSH AF
 629  6519 57               LD D, A
 630  651A DB A8            IN A, (0A8H)
 631  651C 47               LD B, A
 632  651D E6 3F            AND 03FH
 633  651F B1               OR C
 634  6520 D3 A8            OUT (0A8H), A
 635  6522 7A               LD A, D
 636  6523 0F               RRCA
 637  6524 0F               RRCA
 638  6525 E6 03            AND 3
 639  6527 57               LD D, A
 640  6528 3E AB            LD A, 0ABH
 641  652A              L0390:
 642  652A C6 55            ADD A, 055H
 643  652C 15               DEC D
 644  652D F2 2A 65         JP P, L0390
 645  6530 A3               AND E
 646  6531 57               LD D, A
 647  6532 7B               LD A, E
 648  6533 2F               CPL
 649  6534 67               LD H, A
 650  6535 3A FF FF         LD A, (0FFFFH)
 651  6538 2F               CPL
 652  6539 6F               LD L, A
 653  653A A4               AND H
 654  653B B2               OR D
 655  653C 32 FF FF         LD (0FFFFH), A
 656  653F 78               LD A, B
 657  6540 D3 A8            OUT (0A8H), A
 658  6542 F1               POP AF
 659  6543 E6 03            AND 3
 660  6545 C9               RET
 661  6546              ; *******************************************************************************************************
 662  6546
 663  6546              ; *******************************************************************************************************
 664  6546              ; some common code to activate page 0 and place values needed to restore original page on stack
 665  6546              ; input IY=return address
 666  6546              ENABLE_PAGE0:
 667  6546 AF              XOR A
 668  6547 CD 86 64        CALL GET_PAGE_INFO
 669  654A C5              PUSH BC
 670  654B D5              PUSH DE
 671  654C 3A 41 F3        LD A, (RAMAD0)
 672  654F 26 00           LD H, 0
 673  6551 CD CD 64        CALL LOCAL_ENASLT
 674  6554 FD E9        	JP (IY)
 675  6556              ; *******************************************************************************************************
 676  6556
 677  6556              ; General BASIC CALL-instruction handler
 678  6556              CALLHAND:
 679  6556 FB              EI
 680  6557 E5           	PUSH HL
 681  6558 21 98 62     	LD	HL, CMDS ; pointer table based on starting letter
 682  655B 3A 89 FD        LD A, (PROCNM)
 683  655E D6 41           SUB 'A'
 684  6560 87              ADD A, A
 685  6561 16 00           LD D, 0
 686  6563 5F              LD E, A
 687  6564 19              ADD HL, DE
 688  6565 5E              LD E, (HL)
 689  6566 23              INC HL
 690  6567 56              LD D, (HL)
 691  6568 7A              LD A, D
 692  6569 B3              OR E
 693  656A 28 23           JR Z, .CMDNOTRECOGNIZED
 694  656C EB              EX DE, HL
 695  656D              .CHKCMD:
 696  656D 11 89 FD     	LD	DE, PROCNM
 697  6570              .LOOP:
 698  6570 1A              LD	A,(DE)
 699  6571 BE           	CP	(HL)
 700  6572 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 701  6574 13           	INC	DE
 702  6575 23           	INC	HL
 703  6576 A7           	AND	A
 704  6577 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 705  6579 5E           	LD	E,(HL)
 706  657A 23           	INC	HL
 707  657B 56           	LD	D,(HL)
 708  657C E1           	POP	HL		; routine address
 709  657D CD 9E 65     	CALL	GETPREVCHAR
 710  6580 CD 92 65     	CALL	.CALLDE		; Call routine
 711  6583 A7           	AND	A
 712  6584 C9           	RET
 713  6585
 714  6585              .TONEXTCMD:
 715  6585 0E FF        	LD	C,0FFH
 716  6587 AF           	XOR	A
 717  6588 ED B1        	CPIR			; Skip to end of instruction name
 718  658A 23           	INC	HL
 719  658B 23           	INC	HL		; Skip address
 720  658C BE           	CP	(HL)
 721  658D 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 722  658F              .CMDNOTRECOGNIZED:
 723  658F E1           	POP	HL
 724  6590 37              SCF
 725  6591 C9           	RET
 726  6592
 727  6592              .CALLDE:
 728  6592 D5           	PUSH	DE
 729  6593 C9           	RET
 730  6594
 731  6594              ;---------------------------
 732  6594
 733  6594              ;GETSTRPNT:
 734  6594              ; OUT:
 735  6594              ; HL = String Address
 736  6594              ; B  = Lenght
 737  6594              ;        LD      HL,(USR)
 738  6594              ;        LD      B,(HL)
 739  6594              ;        INC     HL
 740  6594              ;        LD      E,(HL)
 741  6594              ;        INC     HL
 742  6594              ;        LD      D,(HL)
 743  6594              ;        EX      DE,HL
 744  6594              ;        RET
 745  6594
 746  6594              ;EVALTXTPARAM:
 747  6594              ;	CALL	CHKCHAR
 748  6594              ;	DEFB	"("             ; Check for (
 749  6594              ;	LD	IX,FRMEVL
 750  6594              ;	CALL	CALBAS		; Evaluate expression
 751  6594              ;       LD      A,(VALTYP)
 752  6594              ;        CP      3               ; Text type?
 753  6594              ;        JP      NZ,TYPE_MISMATCH
 754  6594              ;        PUSH	HL
 755  6594              ;        LD	IX,FRESTR         ; Free the temporary string
 756  6594              ;        CALL	CALBAS
 757  6594              ;        POP	HL
 758  6594              ;	CALL	CHKCHAR
 759  6594              ;	DEFB	")"             ; Check for )
 760  6594              ;        RET
 761  6594
 762  6594
 763  6594              CHKCHAR:
 764  6594 CD 9E 65     	CALL	GETPREVCHAR	; Get previous basic char
 765  6597 E3           	EX	(SP),HL
 766  6598 BE           	CP	(HL) 	        ; Check if good char
 767  6599 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 768  659B 23           	INC	HL
 769  659C E3           	EX	(SP),HL
 770  659D 23           	INC	HL		; Get next basic char
 771  659E
 772  659E              GETPREVCHAR:
 773  659E 2B           	DEC HL
 774  659F DD 21 66 46  	LD	IX,CHRGTR
 775  65A3 CD 59 01     	CALL CALBAS
 776  65A6 FB              EI
 777  65A7 C9              RET
 778  65A8
 779  65A8
 780  65A8              TYPE_MISMATCH:
 781  65A8 1E 0D            LD E, 13 ; Type mismatch
 782  65AA 18 0E            JR THROW_ERROR
 783  65AC              SUBSCRIPT_OUT_OF_RANGE:
 784  65AC 1E 09            LD E,9 ; subscript out of range
 785  65AE 18 0A        	JR THROW_ERROR
 786  65B0              OVERFLOW:
 787  65B0 1E 06        	LD E,6
 788  65B2 18 06        	JR THROW_ERROR
 789  65B4              ILLEGAL_FUNCTION:
 790  65B4 1E 05            LD E, 5 ; illegal function call
 791  65B6 18 02            JR THROW_ERROR
 792  65B8              SYNTAX_ERROR:
 793  65B8 1E 02            LD E, 2 ; Syntax error
 794  65BA              THROW_ERROR:
 795  65BA DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 796  65BE C3 59 01     	JP	CALBAS
 797  65C1
 798  65C1              ;---------------------------
 799  65C1
 800  65C1              ; *******************************************************************************************************
 801  65C1              ; helper function to get pointer to BASIC array data
 802  65C1              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 803  65C1              ; input B=dimensions (1 or 2)
 804  65C1              ; input D=minimal first dimension
 805  65C1              ; input E=minimal second dimension, if applicable
 806  65C1              ; returns BC=pointer to first data element
 807  65C1              ; throws BASIC error if invalid type
 808  65C1              GET_BASIC_ARRAY_DATA_POINTER:
 809  65C1 D5           	PUSH DE
 810  65C2 C5           	PUSH BC
 811  65C3 F5           	PUSH AF
 812  65C4 3E 01           LD A,1
 813  65C6 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 814  65C9 DD 21 A4 5E  	LD IX, PTRGET
 815  65CD CD 59 01     	CALL CALBAS
 816  65D0 AF              XOR A
 817  65D1 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 818  65D4 3A 63 F6     	LD A,(VALTYP)
 819  65D7 D1           	POP DE ; required type
 820  65D8 BA           	CP D
 821  65D9 C2 A8 65     	JP NZ,TYPE_MISMATCH
 822  65DC 0A           	LD A,(BC)
 823  65DD 03           	INC BC
 824  65DE D1           	POP DE ; required number of dimensions
 825  65DF BA           	CP D
 826  65E0 C2 A8 65     	JP NZ,TYPE_MISMATCH
 827  65E3 D1           	POP DE ; required minimal array dimensions
 828  65E4 3D           	DEC A
 829  65E5 28 07        	JR Z,.ONE_DIMENSION
 830  65E7              	; 2-dimension array
 831  65E7 0A           	LD A,(BC)
 832  65E8 03          > INC BC
 832  65E9 03          > INC BC
 833  65EA BB           	CP E
 834  65EB DA AC 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 835  65EE              .ONE_DIMENSION:
 836  65EE 0A           	LD A,(BC)
 837  65EF 03          > INC BC
 837  65F0 03          > INC BC
 838  65F1 BA           	CP D
 839  65F2 DA AC 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 840  65F5 C9           	RET
 841  65F6              ; *******************************************************************************************************
 842  65F6
 843  65F6              EXT_END:
 844  65F6
# file closed: asm\main.asm
