# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              SYNCHR		EQU		#558C
  33  4000              VALTYP  	EQU     #F663
  34  4000              USR     	EQU     #F7F8
  35  4000              PROCNM		EQU		#FD89
  36  4000              BIOS_FILVRM EQU     #0056
  37  4000              CLIKSW		EQU		#F3DB
  38  4000              ATRBAS		EQU		#F928
  39  4000              GRPCGP		EQU		#F3CB
  40  4000
  41  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  42  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  43  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  44  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  45  4000              EXPTBL	EQU #FCC1
  46  4000              SCRMOD	EQU #FCAF ; current screen mode
  47  4000              REG1SAV EQU #F3E0 ; VDP(1)
  48  4000
  49  4000              ; BASIC error codes
  50  4000              ;01 NEXT without FOR
  51  4000              ;02 Syntax error
  52  4000              ;03 RETURN without GOSUB
  53  4000              ;04 Out of DATA
  54  4000              ;05 Illegal function call
  55  4000              ;06 Overflow
  56  4000              ;07 Out of memory
  57  4000              ;08 Undefined line number
  58  4000              ;09 Subscript out of range
  59  4000              ;10 Redimensioned array
  60  4000              ;11 Division by zero
  61  4000              ;12 Illegal direct
  62  4000              ;13 Type mismatch
  63  4000              ;14 Out of string space
  64  4000              ;15 String too long
  65  4000              ;16 String formula too complex
  66  4000              ;17 Can't CONTINUE
  67  4000              ;18 Undefined user function
  68  4000              ;19 Device I/O error
  69  4000              ;20 Verify error
  70  4000              ;21 No RESUME
  71  4000              ;22 RESUME without error
  72  4000              ;23 Unprintable error
  73  4000              ;24 Missing operand
  74  4000              ;25 Line buffer overflow
  75  4000              ;50 FIELD overflow
  76  4000              ;51 Internal error
  77  4000              ;52 Bad file number
  78  4000              ;53 File not found
  79  4000              ;54 File already open
  80  4000              ;55 Input past end
  81  4000              ;56 Bad file name
  82  4000              ;57 Direct statement in file
  83  4000              ;58 Sequential I/O only
  84  4000              ;59 File not OPEN
  85  4000
  86  4000
  87  4000               ; simulate cartridge with BASIC extension
  88  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  88  4004 1A 52 00 00
  88  4008 00 00 00 00
  88  400C 00 00 00 00
  89  4010
  90  4010              ; this location #4010 stores last location used by basic extension
  91  4010              ; free memory after that point
  92  4010              FREEMEMPTR:
  93  4010 F7 5A         DW EXT_END
  94  4012
  95  4012              ; this location #4012 stores extension version in DAA format
  96  4012              ; first byte is major version and second minor
  97  4012              VERSION:
  98  4012 00 70         DB #00, #70
  99  4014
 100  4014              ; binary included AKG player compiled at #4014
 101  4014               IF (SOUND_CMDS == 1)
 102  4014              	INCBIN "bin/AKG.bin"
 103  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 104  4CF0               ENDIF
 105  4CF0
 106  4CF0              ORIG.HTIMI:
 107  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 107  4CF4 00
 108  4CF5               EXPORT ORIG.HTIMI
 109  4CF5
 110  4CF5               IF (SOUND_CMDS == 1)
 111  4CF5              MUSIC_INIT_STATUS:
 112  4CF5 00            DB 0
 113  4CF6              SFX_INIT_STATUS:
 114  4CF6 00            DB 0
 115  4CF7              SOUND_ENABLED:
 116  4CF7 00            DB 0
 117  4CF8               ENDIF
 118  4CF8
 119  4CF8               IF (SPRITE_CMDS == 1)
 120  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 35 51     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 57 52     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 57 52     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 57 52     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 57 52     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 6F 52     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 6F 52     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 6F 52     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 57 52     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 57 52     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 57 52     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 57 52     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 57 52     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 57 52     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 6F 52     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 6F 52     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 57 52     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 57 52     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 57 52     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 57 52     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 57 52     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 4A 51         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD 91 51         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD 81 51         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 121  4F4D               ENDIF
 122  4F4D
 123  4F4D               IF (ANIM_CMDS == 1)
 124  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E F7 5A         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 F7 5A         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 F7 5A         DW EXT_END
  18+ 4F56
  19+ 4F56              ; *******************************************************************************************************
  20+ 4F56              ; function to handle CALL MAXANIMITEMS basic extension
  21+ 4F56              ; MAXANIMITEMS BYTE number
  22+ 4F56              ; sets new number and moves memory buffers as needed
  23+ 4F56              MAXANIMITEMS:
  24+ 4F56              	; opening (
  25+ 4F56 CD 57 52     	CALL CHKCHAR
  26+ 4F59 28           	DB '('
  27+ 4F5A              	; get value
  28+ 4F5A DD 21 1C 52  	LD IX, GETBYT
  29+ 4F5E CD 59 01     	CALL CALBAS
  30+ 4F61 F5               PUSH AF
  31+ 4F62              	; ending )
  32+ 4F62 CD 57 52     	CALL CHKCHAR
  33+ 4F65 29           	DB ')'
  34+ 4F66 F1               POP AF
  35+ 4F67
  36+ 4F67              	; save position
  37+ 4F67 E5           	PUSH HL
  38+ 4F68
  39+ 4F68 47               LD B,A
  40+ 4F69 3A 4D 4F         LD A,(ANIMITEMNUM)
  41+ 4F6C 90               SUB B
  42+ 4F6D 28 23            JR Z, .EXIT; same value as before
  43+ 4F6F DD 21 4E 4F      LD IX,ANIMITEMPTR
  44+ 4F73 FD 21 51 4F      LD IY,ANIMDEFPTR
  45+ 4F77 FA 95 4F         JP M, .INCREASE
  46+ 4F7A                  ; new value is lower than previous one
  47+ 4F7A CD AD 4F         CALL .SIZEDIFF
  48+ 4F7D CD CA 4F         CALL .DECREASE_COMMON
  49+ 4F80 2A 54 4F         LD HL,(ANIMSPRPTR)
  50+ 4F83 AF               XOR A
  51+ 4F84 ED 42            SBC HL,BC
  52+ 4F86 22 54 4F         LD (ANIMSPRPTR),HL
  53+ 4F89 2A 10 40         LD HL,(FREEMEMPTR)
  54+ 4F8C AF               XOR A
  55+ 4F8D ED 42            SBC HL,BC
  56+ 4F8F 22 10 40         LD (FREEMEMPTR),HL
  57+ 4F92              .EXIT:
  58+ 4F92 FB               EI
  59+ 4F93 E1           	POP HL
  60+ 4F94 C9           	RET
  61+ 4F95              .INCREASE:
  62+ 4F95 ED 44            NEG
  63+ 4F97 CD AD 4F         CALL .SIZEDIFF
  64+ 4F9A CD ED 4F         CALL .INCREASE_COMMON
  65+ 4F9D 2A 54 4F         LD HL,(ANIMSPRPTR)
  66+ 4FA0 09               ADD HL,BC
  67+ 4FA1 22 54 4F         LD (ANIMSPRPTR),HL
  68+ 4FA4 2A 10 40         LD HL,(FREEMEMPTR)
  69+ 4FA7 09               ADD HL,BC
  70+ 4FA8 22 10 40         LD (FREEMEMPTR),HL
  71+ 4FAB 18 E5            JR .EXIT
  72+ 4FAD              .SIZEDIFF:
  73+ 4FAD 26 00            LD H,0
  74+ 4FAF 6F               LD L,A
  75+ 4FB0 29               ADD HL,HL
  76+ 4FB1 29               ADD HL,HL
  77+ 4FB2 78               LD A,B
  78+ 4FB3 32 4D 4F         LD (ANIMITEMNUM),A
  79+ 4FB6 44               LD B,H
  80+ 4FB7 4D               LD C,L
  81+ 4FB8 C9               RET ; BC=size difference in bytes
  82+ 4FB9              .SIZETOMOVE:
  83+ 4FB9 D5               PUSH DE
  84+ 4FBA 2A 10 40         LD HL,(FREEMEMPTR)
  85+ 4FBD FD 5E 00         LD E,(IY)
  86+ 4FC0 FD 56 01         LD D,(IY+1)
  87+ 4FC3 AF               XOR A
  88+ 4FC4 ED 52            SBC HL,DE
  89+ 4FC6 44               LD B,H
  90+ 4FC7 4D               LD C,L
  91+ 4FC8 D1               POP DE
  92+ 4FC9 C9               RET
  93+ 4FCA              .DECREASE_COMMON:
  94+ 4FCA FD 6E 00         LD L,(IY)
  95+ 4FCD FD 66 01         LD H,(IY+1)
  96+ 4FD0 AF               XOR A
  97+ 4FD1 ED 42            SBC HL,BC
  98+ 4FD3 EB               EX DE,HL
  99+ 4FD4 C5               PUSH BC
 100+ 4FD5 CD B9 4F         CALL .SIZETOMOVE
 101+ 4FD8 F3               DI
 102+ 4FD9 78               LD A,B
 103+ 4FDA B1               OR C
 104+ 4FDB 28 0E            JR Z,.L1
 105+ 4FDD FD 6E 00         LD L,(IY)
 106+ 4FE0 FD 66 01         LD H,(IY+1)
 107+ 4FE3 DD 73 00         LD (IX),E
 108+ 4FE6 DD 72 01         LD (IX+1),D
 109+ 4FE9 ED B0            LDIR
 110+ 4FEB              .L1:
 111+ 4FEB C1               POP BC
 112+ 4FEC C9               RET
 113+ 4FED              .INCREASE_COMMON:
 114+ 4FED 2A 10 40         LD HL,(FREEMEMPTR)
 115+ 4FF0 2B               DEC HL
 116+ 4FF1 AF               XOR A
 117+ 4FF2 ED 42            SBC HL,BC
 118+ 4FF4 EB               EX DE,HL
 119+ 4FF5 C5               PUSH BC
 120+ 4FF6 CD B9 4F         CALL .SIZETOMOVE
 121+ 4FF9 F3               DI
 122+ 4FFA 78               LD A,B
 123+ 4FFB B1               OR C
 124+ 4FFC 28 06            JR Z,.L2
 125+ 4FFE 2A 10 40         LD HL,(FREEMEMPTR)
 126+ 5001 2B               DEC HL
 127+ 5002 ED B8            LDDR
 128+ 5004              .L2:
 129+ 5004 C1               POP BC
 130+ 5005 DD 6E 00         LD L,(IX)
 131+ 5008 DD 66 01         LD H,(IX+1)
 132+ 500B 09               ADD HL,BC
 133+ 500C DD 75 00         LD (IX),L
 134+ 500F DD 74 01         LD (IX+1),H
 135+ 5012 C9               RET
 136+ 5013              ; *******************************************************************************************************
# file closed: asm\ANIMATION.asm
 125  5013               ENDIF
 126  5013
 127  5013              ; temp variables for BLIT, TILE functions
 128  5013               IF (BLIT_CMDS + TILE_CMDS > 0)
 129  5013              BLIT_TMP:
 130  5013              TILETMP1:
 131  5013              BLIT_TMP1:
 132  5013 00 00         DW 0
 133  5015              TILETMP2:
 134  5015              BLIT_TMP2:
 135  5015 00 00         DW 0
 136  5017                IFDEF CMDS_WITH_PARAMETERS
 137  5017              BLIT_STRUCT:
 138  5017 00 00 00...   DS 17
 139  501B                ENDIF
 140  501B               ENDIF
 141  5028
 142  5028              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 143  5028              ; per starting letter, if no commands with this letter, NULL value
 144  5028              CMDS:
 145  5028 00 00            DW 0 ; A
 146  502A               IF (BLIT_CMDS + BOX_CMDS > 0)
 147  502A 00 51            DW CMDS_B ; B
 148  502C               ELSE
 149  502C ~            	DW 0
 150  502C               ENDIF
 151  502C 00 00            DW 0 ; C
 152  502E 00 00            DW 0 ; D
 153  5030 00 00            DW 0 ; E
 154  5032               IF (VRAM_CMDS + RAM_CMDS > 0)
 155  5032 7E 50            DW CMDS_F; F
 156  5034               ELSE
 157  5034 ~            	DW 0
 158  5034               ENDIF
 159  5034               IF (GENCAL_CMD > 0)
 160  5034 91 50            DW CMDS_G; G
 161  5036               ELSE
 162  5036 ~            	DW 0
 163  5036               ENDIF
 164  5036 00 00            DW 0 ; H
 165  5038 00 00            DW 0 ; I
 166  503A 00 00            DW 0 ; J
 167  503C 00 00            DW 0 ; K
 168  503E 00 00            DW 0 ; L
 169  5040               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 170  5040 5C 50            DW CMDS_M ; M
 171  5042               ELSE
 172  5042 ~            	DW 0
 173  5042               ENDIF
 174  5042 00 00            DW 0 ; N
 175  5044 00 00            DW 0 ; O
 176  5046 00 00            DW 0 ; P
 177  5048 00 00            DW 0 ; Q
 178  504A 00 00            DW 0 ; R
 179  504C               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 180  504C A5 50            DW CMDS_S ; S
 181  504E               ELSE
 182  504E ~            	DW 0
 183  504E               ENDIF
 184  504E               IF (TILE_CMDS > 0)
 185  504E 20 51            DW CMDS_T ; T
 186  5050               ELSE
 187  5050 ~            	DW 0
 188  5050               ENDIF
 189  5050 00 00            DW 0 ; U
 190  5052               IF (VRAM_CMDS > 0)
 191  5052 9B 50            DW CMDS_V ; V
 192  5054               ELSE
 193  5054 ~            	DW 0
 194  5054               ENDIF
 195  5054 00 00            DW 0 ; W
 196  5056 00 00            DW 0 ; X
 197  5058 00 00            DW 0 ; Y
 198  505A 00 00            DW 0 ; Z
 199  505C
 200  505C              CMDS_M:
 201  505C               IF (VRAM_CMDS == 1)
 202  505C 4D 45 4D 56      DB "MEMVRM", 0
 202  5060 52 4D 00
 203  5063 B7 53            DW MEMVRM
 204  5065               ENDIF
 205  5065               IF (RAM_CMDS == 1)
 206  5065 4D 45 4D 43  	DB "MEMCPY", 0
 206  5069 50 59 00
 207  506C 76 52        	DW MEMCPY
 208  506E               ENDIF
 209  506E               IF (ANIM_CMDS == 1)
 210  506E 4D 41 58 41  	DB "MAXANIMITEMS",0
 210  5072 4E 49 4D 49
 210  5076 54 45 4D 53
 210  507A 00
 211  507B 56 4F        	DW MAXANIMITEMS
 212  507D               ENDIF
 213  507D               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 214  507D 00           	DB 0
 215  507E               ENDIF
 216  507E              CMDS_F:
 217  507E               IF (VRAM_CMDS == 1)
 218  507E 46 49 4C 56      DB "FILVRM", 0
 218  5082 52 4D 00
 219  5085 B9 52            DW FILVRM
 220  5087               ENDIF
 221  5087               IF (RAM_CMDS == 1)
 222  5087 46 49 4C 52      DB "FILRAM", 0
 222  508B 41 4D 00
 223  508E 00 53            DW FILRAM
 224  5090               ENDIF
 225  5090               IF (VRAM_CMDS + RAM_CMDS > 0)
 226  5090 00               DB 0
 227  5091               ENDIF
 228  5091              CMDS_G:
 229  5091               IF (GENCAL_CMD == 1)
 230  5091 47 45 4E 43      DB "GENCAL", 0
 230  5095 41 4C 00
 231  5098 5E 53            DW GENCAL
 232  509A               ENDIF
 233  509A               IF (GENCAL_CMD > 0)
 234  509A 00           	DB	0
 235  509B               ENDIF
 236  509B              CMDS_V:
 237  509B               IF (VRAM_CMDS == 1)
 238  509B 56 52 4D 4D  	DB "VRMMEM", 0
 238  509F 45 4D 00
 239  50A2 2F 54        	DW VRMMEM
 240  50A4               ENDIF
 241  50A4               IF (VRAM_CMDS > 0)
 242  50A4 00           	DB 0
 243  50A5               ENDIF
 244  50A5              CMDS_S:
 245  50A5               IF (SPRITE_CMDS == 1)
 246  50A5 53 50 52 53  	DB "SPRSET", 0
 246  50A9 45 54 00
 247  50AC 0E 4E        	DW SPRSET
 248  50AE 53 50 52 47  	DB "SPRGRPMOV", 0
 248  50B2 52 50 4D 4F
 248  50B6 56 00
 249  50B8 CC 4E        	DW SPRGRPMOV
 250  50BA               ENDIF
 251  50BA               IF (SOUND_CMDS == 1)
 252  50BA 53 4E 44 53  	DB "SNDSFX", 0
 252  50BE 46 58 00
 253  50C1 6D 55        	DW SNDSFX
 254  50C3 53 4E 44 50  	DB "SNDPLYON", 0
 254  50C7 4C 59 4F 4E
 254  50CB 00
 255  50CC 37 55        	DW SNDPLYON
 256  50CE 53 4E 44 50  	DB "SNDPLYOFF", 0
 256  50D2 4C 59 4F 46
 256  50D6 46 00
 257  50D8 4A 55        	DW SNDPLYOFF
 258  50DA 53 4E 44 50  	DB "SNDPLYINI", 0
 258  50DE 4C 59 49 4E
 258  50E2 49 00
 259  50E4 ED 54        	DW SNDPLYINIT
 260  50E6               ENDIF
 261  50E6               IF (SPRITE_CMDS == 1)
 262  50E6 53 50 52 45  	DB "SPRENABLE", 0
 262  50EA 4E 41 42 4C
 262  50EE 45 00
 263  50F0 B9 4D        	DW SPRENABLE
 264  50F2 53 50 52 44  	DB "SPRDISABLE", 0
 264  50F6 49 53 41 42
 264  50FA 4C 45 00
 265  50FD 09 4E        	DW SPRDISABLE
 266  50FF               ENDIF
 267  50FF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 268  50FF 00           	DB 0
 269  5100               ENDIF
 270  5100              CMDS_B:
 271  5100               IF (BLIT_CMDS == 1)
 272  5100 42 4C 49 54  	DB "BLIT", 0
 272  5104 00
 273  5105 44 57        	DW BLIT
 274  5107               ENDIF
 275  5107               IF (BOX_CMDS == 1)
 276  5107 42 4F 58 4D  	DB "BOXMEMCPY", 0
 276  510B 45 4D 43 50
 276  510F 59 00
 277  5111 7C 5A        	DW BOXMEMCPY
 278  5113 42 4F 58 4D  	DB "BOXMEMVRM", 0
 278  5117 45 4D 56 52
 278  511B 4D 00
 279  511D B0 5A        	DW BOXMEMVRM
 280  511F               ENDIF
 281  511F               IF (BLIT_CMDS + BOX_CMDS > 0)
 282  511F 00           	DB 0
 283  5120               ENDIF
 284  5120              CMDS_T:
 285  5120               IF (TILE_CMDS == 1)
 286  5120 54 49 4C 45  	DB "TILERAM", 0
 286  5124 52 41 4D 00
 287  5128 88 58        	DW TILERAM
 288  512A 54 49 4C 45  	DB "TILEVRM", 0
 288  512E 56 52 4D 00
 289  5132 8B 59        	DW TILEVRM
 290  5134               ENDIF
 291  5134               IF (TILE_CMDS > 0)
 292  5134 00           	DB 0
 293  5135               ENDIF
 294  5135
 295  5135               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 296  5135              ; ****************************************************************************************************
 297  5135              ; function sets VRAM address
 298  5135              ; input HL=address
 299  5135              ; modifies AF
 300  5135              SETWRT_LOCAL:
 301  5135 7D           	LD	A, L
 302  5136 D3 99        	OUT	(099H), A
 303  5138 7C           	LD	A, H
 304  5139 E6 3F        	AND	03FH
 305  513B F6 40        	OR	040H
 306  513D D3 99        	OUT	(099H), A
 307  513F C9           	RET
 308  5140              ; ****************************************************************************************************
 309  5140               ENDIF
 310  5140
 311  5140               IF (VRAM_CMDS + TILE_CMDS > 0)
 312  5140              ; ****************************************************************************************************
 313  5140              ; function copies data from RAM to VRAM
 314  5140              ; input HL=address in RAM
 315  5140              ; input B=count
 316  5140              ; modifies AF
 317  5140              BBYTECOPY:
 318  5140 ED A3        	OUTI
 319  5142 C2 40 51     	JP	NZ, BBYTECOPY
 320  5145 C9           	RET
 321  5146              ; ****************************************************************************************************
 322  5146               ENDIF
 323  5146
 324  5146              ; ****************************************************************************************************
 325  5146              ; function multiplies HL by 8
 326  5146              HLx8:
 327  5146 29          > ADD HL, HL
 327  5147 29          > ADD HL, HL
 327  5148 29          > ADD HL, HL
 328  5149 C9           	RET
 329  514A              ; ****************************************************************************************************
 330  514A
 331  514A              ; ****************************************************************************************************
 332  514A              ; function gets slot and subslot data for specific page
 333  514A              ; input A=page (0, 1 or 2)
 334  514A              ; output B = 0A8H register value
 335  514A              ; output D = 0 is no subslots, 1 if yes
 336  514A              ; output C = 0A8H value when page 3 slot equals to requested page slot
 337  514A              ; output E = subslot value if present
 338  514A              ; modifies AF, BC, DE, HL
 339  514A              GET_PAGE_INFO:
 340  514A 6F               LD L, A
 341  514B C6 C1            ADD A, low (EXPTBL)
 342  514D 32 57 51         LD (GET_PAGE_INFO_L1+1), A
 343  5150 DB A8            IN A, (0A8H)
 344  5152 47               LD B, A
 345  5153 E6 3F            AND 03FH
 346  5155 4F               LD C, A
 347  5156              GET_PAGE_INFO_L1:
 348  5156 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 349  5159 E6 80            AND 080H
 350  515B 28 1B            JR Z, GET_PAGE_INFO_L2
 351  515D                  ; expanded
 352  515D 2D               DEC L
 353  515E FA 7D 51         JP M, GET_PAGE_INFO_L3
 354  5161 2D               DEC L
 355  5162 FA 7B 51         JP M, GET_PAGE_INFO_L4
 356  5165                  ; page 2
 357  5165 07               RLCA
 358  5166 07               RLCA
 359  5167              GET_PAGE_INFO_L5:
 360  5167 E6 C0            AND 0C0H
 361  5169 B1               OR C
 362  516A D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 363  516C 4F               LD C, A
 364  516D 3A FF FF         LD A, (0FFFFH)
 365  5170 2F               CPL
 366  5171 5F               LD E, A
 367  5172 16 01            LD D, 1
 368  5174 78               LD A, B ; return stack
 369  5175 D3 A8            OUT (0A8H), A
 370  5177 C9               RET
 371  5178              GET_PAGE_INFO_L2:
 372  5178                  ; not expanded
 373  5178 16 00            LD D, 0
 374  517A C9               RET
 375  517B              GET_PAGE_INFO_L4:
 376  517B                  ; page 1
 377  517B 0F               RRCA
 378  517C 0F               RRCA
 379  517D              GET_PAGE_INFO_L3:
 380  517D                  ; page 0
 381  517D 0F               RRCA
 382  517E 0F               RRCA
 383  517F 18 E6            JR GET_PAGE_INFO_L5
 384  5181              ; ****************************************************************************************************
 385  5181
 386  5181              ; ****************************************************************************************************
 387  5181              ; function returns original slot and subslot info
 388  5181              ; input B = 0A8H register value
 389  5181              ; input D = 0 is no subslots, 1 if yes
 390  5181              ; input C = 0A8H value when page 3 slot equals to requested page slot
 391  5181              ; input E = subslot value if present
 392  5181              ; modifies AF, disables interrupts
 393  5181              RESTORE_PAGE_INFO:
 394  5181 7A               LD A, D
 395  5182 B7               OR A
 396  5183 28 08            JR Z, RESTORE_PAGE_INFO_L1
 397  5185 79               LD A, C
 398  5186 F3           	DI
 399  5187 D3 A8            OUT (0A8H), A
 400  5189 7B               LD A, E
 401  518A 32 FF FF         LD (0FFFFH), A
 402  518D              RESTORE_PAGE_INFO_L1:
 403  518D 78               LD A, B
 404  518E D3 A8            OUT (0A8H), A
 405  5190 C9               RET
 406  5191              ; ****************************************************************************************************
 407  5191
 408  5191              ; *******************************************************************************************************
 409  5191              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 410  5191              ; INPUT:  A = SLOT ID: EXXXSSPP
 411  5191              ; E = EXPANDED FLAG
 412  5191              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 413  5191              ; PP = PRIMARY SLOT NUMBER
 414  5191              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 415  5191              ; CHANGES: AF, BC, DE
 416  5191
 417  5191              LOCAL_ENASLT:
 418  5191 CD B1 51         CALL L0353
 419  5194 FA 9E 51         JP M, L0340
 420  5197 DB A8            IN A, (0A8H)
 421  5199 A1               AND C
 422  519A B0               OR B
 423  519B D3 A8            OUT (0A8H), A
 424  519D C9               RET
 425  519E              L0340:
 426  519E E5               PUSH HL
 427  519F CD D6 51         CALL L0378
 428  51A2 4F               LD C, A
 429  51A3 06 00            LD B, 0
 430  51A5 7D               LD A, L
 431  51A6 A4               AND H
 432  51A7 B2               OR D
 433  51A8 21 C5 FC         LD HL, 0FCC5H
 434  51AB 09               ADD HL, BC
 435  51AC 77               LD (HL), A
 436  51AD E1               POP HL
 437  51AE 79               LD A, C
 438  51AF 18 E0            JR LOCAL_ENASLT
 439  51B1              L0353:
 440  51B1 F3               DI
 441  51B2 F5               PUSH AF
 442  51B3 7C               LD A, H
 443  51B4 07               RLCA
 444  51B5 07               RLCA
 445  51B6 E6 03            AND 3
 446  51B8 5F               LD E, A
 447  51B9 3E C0            LD A, 0C0H
 448  51BB              L035D:
 449  51BB 07               RLCA
 450  51BC 07               RLCA
 451  51BD 1D               DEC E
 452  51BE F2 BB 51         JP P, L035D
 453  51C1 5F               LD E, A
 454  51C2 2F               CPL
 455  51C3 4F               LD C, A
 456  51C4 F1               POP AF
 457  51C5 F5               PUSH AF
 458  51C6 E6 03            AND 3
 459  51C8 3C               INC A
 460  51C9 47               LD B, A
 461  51CA 3E AB            LD A, 0ABH
 462  51CC              L036E:
 463  51CC C6 55            ADD A, 055H
 464  51CE 10 FC            DJNZ L036E
 465  51D0 57               LD D, A
 466  51D1 A3               AND E
 467  51D2 47               LD B, A
 468  51D3 F1               POP AF
 469  51D4 A7               AND A
 470  51D5 C9               RET
 471  51D6              L0378:
 472  51D6 F5               PUSH AF
 473  51D7 7A               LD A, D
 474  51D8 E6 C0            AND 0C0H
 475  51DA 4F               LD C, A
 476  51DB F1               POP AF
 477  51DC F5               PUSH AF
 478  51DD 57               LD D, A
 479  51DE DB A8            IN A, (0A8H)
 480  51E0 47               LD B, A
 481  51E1 E6 3F            AND 03FH
 482  51E3 B1               OR C
 483  51E4 D3 A8            OUT (0A8H), A
 484  51E6 7A               LD A, D
 485  51E7 0F               RRCA
 486  51E8 0F               RRCA
 487  51E9 E6 03            AND 3
 488  51EB 57               LD D, A
 489  51EC 3E AB            LD A, 0ABH
 490  51EE              L0390:
 491  51EE C6 55            ADD A, 055H
 492  51F0 15               DEC D
 493  51F1 F2 EE 51         JP P, L0390
 494  51F4 A3               AND E
 495  51F5 57               LD D, A
 496  51F6 7B               LD A, E
 497  51F7 2F               CPL
 498  51F8 67               LD H, A
 499  51F9 3A FF FF         LD A, (0FFFFH)
 500  51FC 2F               CPL
 501  51FD 6F               LD L, A
 502  51FE A4               AND H
 503  51FF B2               OR D
 504  5200 32 FF FF         LD (0FFFFH), A
 505  5203 78               LD A, B
 506  5204 D3 A8            OUT (0A8H), A
 507  5206 F1               POP AF
 508  5207 E6 03            AND 3
 509  5209 C9               RET
 510  520A              ; *******************************************************************************************************
 511  520A
 512  520A              ; *******************************************************************************************************
 513  520A              ; some common code to activate page 0 and place values needed to restore original page on stack
 514  520A              ; input IY=return address
 515  520A              ENABLE_PAGE0:
 516  520A AF               XOR A
 517  520B CD 4A 51         CALL GET_PAGE_INFO
 518  520E C5               PUSH BC
 519  520F D5               PUSH DE
 520  5210 3A 41 F3         LD A, (RAMAD0)
 521  5213 26 00            LD H, 0
 522  5215 CD 91 51         CALL LOCAL_ENASLT
 523  5218 FD E9        	JP (IY)
 524  521A              ; *******************************************************************************************************
 525  521A
 526  521A              ; General BASIC CALL-instruction handler
 527  521A              CALLHAND:
 528  521A E5           	PUSH HL
 529  521B 21 28 50     	LD	HL, CMDS ; pointer table based on starting letter
 530  521E 3A 89 FD         LD A, (PROCNM)
 531  5221 D6 41            SUB 'A'
 532  5223 87               ADD A, A
 533  5224 16 00            LD D, 0
 534  5226 5F               LD E, A
 535  5227 19               ADD HL, DE
 536  5228 5E               LD E, (HL)
 537  5229 23               INC HL
 538  522A 56               LD D, (HL)
 539  522B 7A               LD A, D
 540  522C B3               OR E
 541  522D 28 23            JR Z, .CMDNOTRECOGNIZED
 542  522F EB               EX DE, HL
 543  5230              .CHKCMD:
 544  5230 11 89 FD     	LD	DE, PROCNM
 545  5233 1A           .LOOP:	LD	A,(DE)
 546  5234 BE           	CP	(HL)
 547  5235 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 548  5237 13           	INC	DE
 549  5238 23           	INC	HL
 550  5239 A7           	AND	A
 551  523A 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 552  523C 5E           	LD	E,(HL)
 553  523D 23           	INC	HL
 554  523E 56           	LD	D,(HL)
 555  523F E1           	POP	HL		; routine address
 556  5240 CD 61 52     	CALL	GETPREVCHAR
 557  5243 CD 55 52     	CALL	.CALLDE		; Call routine
 558  5246 A7           	AND	A
 559  5247 C9           	RET
 560  5248
 561  5248              .TONEXTCMD:
 562  5248 0E FF        	LD	C,0FFH
 563  524A AF           	XOR	A
 564  524B ED B1        	CPIR			; Skip to end of instruction name
 565  524D 23           	INC	HL
 566  524E 23           	INC	HL		; Skip address
 567  524F BE           	CP	(HL)
 568  5250 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 569  5252              .CMDNOTRECOGNIZED:
 570  5252 E1           	POP	HL
 571  5253 37               SCF
 572  5254 C9           	RET
 573  5255
 574  5255              .CALLDE:
 575  5255 D5           	PUSH	DE
 576  5256 C9           	RET
 577  5257
 578  5257              ;---------------------------
 579  5257
 580  5257              ;GETSTRPNT:
 581  5257              ; OUT:
 582  5257              ; HL = String Address
 583  5257              ; B  = Lenght
 584  5257              ;        LD      HL,(USR)
 585  5257              ;        LD      B,(HL)
 586  5257              ;        INC     HL
 587  5257              ;        LD      E,(HL)
 588  5257              ;        INC     HL
 589  5257              ;        LD      D,(HL)
 590  5257              ;        EX      DE,HL
 591  5257              ;        RET
 592  5257
 593  5257              ;EVALTXTPARAM:
 594  5257              ;	CALL	CHKCHAR
 595  5257              ;	DEFB	"("             ; Check for (
 596  5257              ;	LD	IX,FRMEVL
 597  5257              ;	CALL	CALBAS		; Evaluate expression
 598  5257              ;       LD      A,(VALTYP)
 599  5257              ;        CP      3               ; Text type?
 600  5257              ;        JP      NZ,TYPE_MISMATCH
 601  5257              ;        PUSH	HL
 602  5257              ;        LD	IX,FRESTR         ; Free the temporary string
 603  5257              ;        CALL	CALBAS
 604  5257              ;        POP	HL
 605  5257              ;	CALL	CHKCHAR
 606  5257              ;	DEFB	")"             ; Check for )
 607  5257              ;        RET
 608  5257
 609  5257
 610  5257              CHKCHAR:
 611  5257 CD 61 52     	CALL	GETPREVCHAR	; Get previous basic char
 612  525A E3           	EX	(SP),HL
 613  525B BE           	CP	(HL) 	        ; Check if good char
 614  525C 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 615  525E 23           	INC	HL
 616  525F E3           	EX	(SP),HL
 617  5260 23           	INC	HL		; Get next basic char
 618  5261
 619  5261              GETPREVCHAR:
 620  5261 2B           	DEC	HL
 621  5262 DD 21 66 46  	LD	IX,CHRGTR
 622  5266 C3 59 01     	JP      CALBAS
 623  5269
 624  5269
 625  5269              TYPE_MISMATCH:
 626  5269 1E 0D            LD E, 13 ; Type mismatch
 627  526B 18 02            JR THROW_ERROR
 628  526D
 629  526D              SYNTAX_ERROR:
 630  526D 1E 02            LD E, 2 ; Syntax error
 631  526F              THROW_ERROR:
 632  526F DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 633  5273 C3 59 01     	JP	CALBAS
 634  5276
 635  5276              ;---------------------------
 636  5276
 637  5276               IF (RAM_CMDS == 1)
 638  5276              ; *******************************************************************************************************
 639  5276              ; function to handle CALL MEMCPY basic extension
 640  5276              ; _MEMCPY ( INT source,
 641  5276              ;			INT destination,
 642  5276              ;			INT count,
 643  5276              ; will put ram in page 0 also, page 1 is already there
 644  5276              MEMCPY:
 645  5276              	; opening (
 646  5276 CD 57 52     	CALL CHKCHAR
 647  5279 28           	DB '('
 648  527A              	; get source address
 649  527A DD 21 2F 54  	LD IX, FRMQNT
 650  527E CD 59 01     	CALL CALBAS
 651  5281 D5           	PUSH DE
 652  5282              	; comma
 653  5282 CD 57 52     	CALL CHKCHAR
 654  5285 2C           	DB ','
 655  5286              	; get destination address
 656  5286 DD 21 2F 54  	LD IX, FRMQNT
 657  528A CD 59 01     	CALL CALBAS
 658  528D D5           	PUSH DE
 659  528E              	; comma
 660  528E CD 57 52     	CALL CHKCHAR
 661  5291 2C           	DB ','
 662  5292              	; get length
 663  5292 DD 21 2F 54  	LD IX, FRMQNT
 664  5296 CD 59 01     	CALL CALBAS
 665  5299 D5           	PUSH DE
 666  529A              	; ending )
 667  529A CD 57 52     	CALL CHKCHAR
 668  529D 29           	DB ')'
 669  529E
 670  529E              	; save position
 671  529E E5           	PUSH HL
 672  529F DD E1        	POP IX
 673  52A1
 674  52A1 C1           	POP BC ; count
 675  52A2 D1           	POP DE ; destination
 676  52A3 E1           	POP HL ; source
 677  52A4 D9           	EXX
 678  52A5              	; enable page 0
 679  52A5 FD 21 AC 52  	LD IY, .RET
 680  52A9 C3 0A 52     	JP ENABLE_PAGE0
 681  52AC              .RET:
 682  52AC FB           	EI
 683  52AD D9           	EXX
 684  52AE ED B0        	LDIR
 685  52B0 D1               POP DE
 686  52B1 C1               POP BC
 687  52B2 CD 81 51         CALL RESTORE_PAGE_INFO
 688  52B5 DD E5        	PUSH IX
 689  52B7 E1           	POP HL
 690  52B8 C9           	RET
 691  52B9              ; *******************************************************************************************************
 692  52B9               ENDIF
 693  52B9
 694  52B9               IF (VRAM_CMDS == 1)
 695  52B9              ; *******************************************************************************************************
 696  52B9              ; function to handle CALL FILVRM basic extension
 697  52B9              ; FILVRM ( INT offset,
 698  52B9              ;		   INT count,
 699  52B9              ;		   BYTE value,
 700  52B9              ;		   BYTE wait_vsync) >0 = true
 701  52B9              ; wait_vsync will issue HALT before copying
 702  52B9              FILVRM:
 703  52B9              	; opening (
 704  52B9 CD 57 52     	CALL CHKCHAR
 705  52BC 28           	DB '('
 706  52BD              	; get offset address
 707  52BD DD 21 2F 54  	LD IX, FRMQNT
 708  52C1 CD 59 01     	CALL CALBAS
 709  52C4 D5           	PUSH DE
 710  52C5              	; comma
 711  52C5 CD 57 52     	CALL CHKCHAR
 712  52C8 2C           	DB ','
 713  52C9              	; get count
 714  52C9 DD 21 2F 54  	LD IX, FRMQNT
 715  52CD CD 59 01     	CALL CALBAS
 716  52D0 D5           	PUSH DE
 717  52D1              	; comma
 718  52D1 CD 57 52     	CALL CHKCHAR
 719  52D4 2C           	DB ','
 720  52D5              	; get value
 721  52D5 DD 21 1C 52  	LD IX, GETBYT
 722  52D9 CD 59 01     	CALL CALBAS
 723  52DC F5           	PUSH AF
 724  52DD              	; comma
 725  52DD CD 57 52     	CALL CHKCHAR
 726  52E0 2C           	DB ','
 727  52E1              	; get vsync wait
 728  52E1 DD 21 1C 52  	LD IX, GETBYT
 729  52E5 CD 59 01     	CALL CALBAS
 730  52E8 F5           	PUSH AF
 731  52E9              	; ending )
 732  52E9 CD 57 52     	CALL CHKCHAR
 733  52EC 29           	DB ')'
 734  52ED
 735  52ED FB               EI
 736  52EE              	; save position
 737  52EE E5           	PUSH HL
 738  52EF DD E1        	POP IX
 739  52F1
 740  52F1              	; syntax ok
 741  52F1              	; wait for vsync if needed
 742  52F1 F1           	POP AF
 743  52F2 B7           	OR A
 744  52F3 28 01        	JR Z, .L1
 745  52F5 76           	HALT
 746  52F6
 747  52F6              .L1:
 748  52F6 F1               POP AF ; value
 749  52F7 C1               POP BC ; count
 750  52F8 E1               POP HL ; offset
 751  52F9 CD 56 00         CALL BIOS_FILVRM
 752  52FC
 753  52FC              .L3:
 754  52FC DD E5        	PUSH IX
 755  52FE E1           	POP HL
 756  52FF C9           	RET
 757  5300              ; *******************************************************************************************************
 758  5300               ENDIF
 759  5300
 760  5300               IF (RAM_CMDS == 1)
 761  5300              ; *******************************************************************************************************
 762  5300              ; function to handle CALL FILRAM basic extension
 763  5300              ; FILRAM ( INT start address,
 764  5300              ;		   INT count,
 765  5300              ;		   BYTE value,
 766  5300              ; will put ram in page 0 also, page 1 is already there
 767  5300              FILRAM:
 768  5300              	; opening (
 769  5300 CD 57 52     	CALL CHKCHAR
 770  5303 28           	DB '('
 771  5304              	; get start address
 772  5304 DD 21 2F 54  	LD IX, FRMQNT
 773  5308 CD 59 01     	CALL CALBAS
 774  530B D5           	PUSH DE
 775  530C              	; comma
 776  530C CD 57 52     	CALL CHKCHAR
 777  530F 2C           	DB ','
 778  5310              	; get count
 779  5310 DD 21 2F 54  	LD IX, FRMQNT
 780  5314 CD 59 01     	CALL CALBAS
 781  5317 D5           	PUSH DE
 782  5318              	; comma
 783  5318 CD 57 52     	CALL CHKCHAR
 784  531B 2C           	DB ','
 785  531C              	; get value
 786  531C DD 21 1C 52  	LD IX, GETBYT
 787  5320 CD 59 01     	CALL CALBAS
 788  5323 F5           	PUSH AF
 789  5324              	; ending )
 790  5324 CD 57 52     	CALL CHKCHAR
 791  5327 29           	DB ')'
 792  5328
 793  5328              	; save position
 794  5328 E5           	PUSH HL
 795  5329 DD E1        	POP IX
 796  532B
 797  532B D1           	POP DE ; actually AF
 798  532C C1           	POP BC ; count
 799  532D E1           	POP HL ; start address
 800  532E 78           	LD A, B
 801  532F B7           	OR A
 802  5330 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 803  5332 B1           	OR C
 804  5333 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 805  5335 79           	LD A, C
 806  5336 3D           	DEC A
 807  5337 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 808  5339              	; one byte to fill
 809  5339 72           	LD (HL), D
 810  533A 18 12        	JR .EXIT
 811  533C              .L1:
 812  533C D9           	EXX
 813  533D              	; enable page 0
 814  533D FD 21 44 53  	LD IY, .RET
 815  5341 C3 0A 52     	JP ENABLE_PAGE0
 816  5344              .RET:
 817  5344 FB           	EI
 818  5345 D9           	EXX
 819  5346 CD 52 53     	CALL .FILLVALUE
 820  5349 D1               POP DE
 821  534A C1               POP BC
 822  534B CD 81 51         CALL RESTORE_PAGE_INFO
 823  534E              .EXIT:
 824  534E DD E5        	PUSH IX
 825  5350 E1           	POP HL
 826  5351 C9           	RET
 827  5352
 828  5352              .FILLVALUE:
 829  5352 72               LD (HL), D
 830  5353 54               LD D, H
 831  5354 5D               LD E, L
 832  5355 13               INC DE
 833  5356 0B               DEC BC
 834  5357 ED B0            LDIR
 835  5359 C9               RET
 836  535A              ; *******************************************************************************************************
 837  535A               ENDIF
 838  535A
 839  535A               IF (GENCAL_CMD == 1)
 840  535A              ; *******************************************************************************************************
 841  535A              ; function to handle CALL GENCAL basic extension
 842  535A              ; GENCAL ( INT fn_addr, = address of the function to call
 843  535A              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 844  535A              ; output values of reristers will also be stored at reg_list_ptr
 845  535A              GENCAL_VAR_SP:
 846  535A 00 00            DW 0
 847  535C              GENCAL_VAR_SP2:
 848  535C 00 00            DW 0
 849  535E              GENCAL:
 850  535E              	; opening (
 851  535E CD 57 52     	CALL CHKCHAR
 852  5361 28           	DB '('
 853  5362              	; get function address
 854  5362 DD 21 2F 54  	LD IX, FRMQNT
 855  5366 CD 59 01     	CALL CALBAS
 856  5369 D5           	PUSH DE
 857  536A              	; comma
 858  536A CD 57 52     	CALL CHKCHAR
 859  536D 2C           	DB ','
 860  536E              	; get pointer to register list
 861  536E DD 21 2F 54  	LD IX, FRMQNT
 862  5372 CD 59 01     	CALL CALBAS
 863  5375 D5           	PUSH DE
 864  5376              	; ending )
 865  5376 CD 57 52     	CALL CHKCHAR
 866  5379 29           	DB ')'
 867  537A
 868  537A              	; save BASIC token position
 869  537A E5           	PUSH HL
 870  537B D9               EXX
 871  537C E1           	POP HL ; HL'=next basic token
 872  537D D9               EXX
 873  537E
 874  537E E1               POP HL ; get pointer to register values
 875  537F F3           	DI
 876  5380 ED 73 5A 53      LD (GENCAL_VAR_SP), SP
 877  5384 F9               LD SP, HL
 878  5385 F1               POP AF
 879  5386 C1               POP BC
 880  5387 D1               POP DE
 881  5388 E1               POP HL
 882  5389 DD E1            POP IX
 883  538B FD E1            POP IY
 884  538D D9               EXX
 885  538E ED 73 5C 53      LD (GENCAL_VAR_SP2), SP
 886  5392 ED 7B 5A 53      LD SP, (GENCAL_VAR_SP)
 887  5396 FB               EI
 888  5397 D1               POP DE ; get function to call
 889  5398 E5               PUSH HL
 890  5399 CD B4 53         CALL .EXXDECALL
 891  539C F3               DI
 892  539D ED 73 5A 53      LD (GENCAL_VAR_SP), SP
 893  53A1 ED 7B 5C 53      LD SP, (GENCAL_VAR_SP2)
 894  53A5 FD E5            PUSH IY
 895  53A7 DD E5            PUSH IX
 896  53A9 E5               PUSH HL
 897  53AA D5               PUSH DE
 898  53AB C5               PUSH BC
 899  53AC F5               PUSH AF
 900  53AD ED 7B 5A 53      LD SP, (GENCAL_VAR_SP)
 901  53B1 FB               EI
 902  53B2 E1               POP HL
 903  53B3 C9           	RET
 904  53B4
 905  53B4              .EXXDECALL:
 906  53B4 D5               PUSH DE
 907  53B5 D9               EXX
 908  53B6 C9               RET
 909  53B7              ; *******************************************************************************************************
 910  53B7               ENDIF
 911  53B7
 912  53B7               IF (VRAM_CMDS == 1)
 913  53B7              ; *******************************************************************************************************
 914  53B7              ; function to handle CALL MEMVRM basic extension
 915  53B7              ; copies from RAM to VRAM
 916  53B7              ; _MEMVRM ( INT source,
 917  53B7              ;			INT destination,
 918  53B7              ;			INT count,
 919  53B7              ;			BYTE wait_vsync) >0 = true
 920  53B7              ; will put ram in page 0 also, page 1 is already there
 921  53B7              ; wait_vsync will issue HALT before copying
 922  53B7              MEMVRM:
 923  53B7              	; opening (
 924  53B7 CD 57 52     	CALL CHKCHAR
 925  53BA 28           	DB '('
 926  53BB              	; get source address
 927  53BB DD 21 2F 54  	LD IX, FRMQNT
 928  53BF CD 59 01     	CALL CALBAS
 929  53C2 D5           	PUSH DE
 930  53C3              	; comma
 931  53C3 CD 57 52     	CALL CHKCHAR
 932  53C6 2C           	DB ','
 933  53C7              	; get destination address
 934  53C7 DD 21 2F 54  	LD IX, FRMQNT
 935  53CB CD 59 01     	CALL CALBAS
 936  53CE D5           	PUSH DE
 937  53CF              	; comma
 938  53CF CD 57 52     	CALL CHKCHAR
 939  53D2 2C           	DB ','
 940  53D3              	; get length
 941  53D3 DD 21 2F 54  	LD IX, FRMQNT
 942  53D7 CD 59 01     	CALL CALBAS
 943  53DA D5           	PUSH DE
 944  53DB              	; comma
 945  53DB CD 57 52     	CALL CHKCHAR
 946  53DE 2C           	DB ','
 947  53DF              	; get vsync wait
 948  53DF DD 21 1C 52  	LD IX, GETBYT
 949  53E3 CD 59 01     	CALL CALBAS
 950  53E6 F5           	PUSH AF
 951  53E7              	; ending )
 952  53E7 CD 57 52     	CALL CHKCHAR
 953  53EA 29           	DB ')'
 954  53EB
 955  53EB                  ; save position in BASIC text
 956  53EB E5           	PUSH HL
 957  53EC DD E1        	POP IX
 958  53EE
 959  53EE F1           	POP AF ; wait vsync
 960  53EF B7           	OR A
 961  53F0 28 03        	JR Z, .L1
 962  53F2 FB               EI
 963  53F3 76           	HALT
 964  53F4 F3           	DI
 965  53F5              .L1:
 966  53F5              	; pop LDIR parameters and store away for later
 967  53F5 C1           	POP BC ; count
 968  53F6 D1           	POP DE ; vram destination
 969  53F7 E1           	POP HL ; ram source
 970  53F8 D9           	EXX
 971  53F9 FD 21 00 54   	LD IY, .RET
 972  53FD C3 0A 52     	JP ENABLE_PAGE0
 973  5400              .RET:
 974  5400 FB           	EI
 975  5401 D9           	EXX
 976  5402 CD 0E 54     	CALL .LDIRVM
 977  5405 D1               POP DE
 978  5406 C1               POP BC
 979  5407 CD 81 51         CALL RESTORE_PAGE_INFO
 980  540A DD E5        	PUSH IX
 981  540C E1           	POP HL
 982  540D C9           	RET
 983  540E
 984  540E              .LDIRVM:
 985  540E EB           	EX DE, HL
 986  540F F3           	DI
 987  5410 CD 35 51     	CALL SETWRT_LOCAL
 988  5413 FB           	EI
 989  5414 EB           	EX DE, HL
 990  5415 78           	LD A, B
 991  5416 B7           	OR A
 992  5417 28 0D        	JR Z, .L3
 993  5419 C5           	PUSH BC
 994  541A 0E 98        	LD C, #98
 995  541C              .L2:
 996  541C 50           	LD D, B
 997  541D 06 00        	LD B, 0
 998  541F CD 40 51     	CALL BBYTECOPY
 999  5422 42           	LD B, D
1000  5423 10 F7        	DJNZ .L2
1001  5425 C1           	POP BC
1002  5426              .L3:
1003  5426 79           	LD A, C
1004  5427 B7           	OR A
1005  5428 C8           	RET Z
1006  5429 41           	LD B, C
1007  542A 0E 98        	LD C, #98
1008  542C C3 40 51     	JP BBYTECOPY
1009  542F              ; *******************************************************************************************************
1010  542F               ENDIF
1011  542F
1012  542F               IF (VRAM_CMDS == 1)
1013  542F              ; *******************************************************************************************************
1014  542F              ; function to handle CALL VRMMEM basic extension
1015  542F              ; copies from RAM to VRAM
1016  542F              ; _VRMMEM ( INT source,
1017  542F              ;			INT destination,
1018  542F              ;			INT count
1019  542F              ; will put ram in page 0 also, page 1 is already there
1020  542F              VRMMEM:
1021  542F              	; opening (
1022  542F CD 57 52     	CALL CHKCHAR
1023  5432 28           	DB '('
1024  5433              	; get source address
1025  5433 DD 21 2F 54  	LD IX, FRMQNT
1026  5437 CD 59 01     	CALL CALBAS
1027  543A D5           	PUSH DE
1028  543B              	; comma
1029  543B CD 57 52     	CALL CHKCHAR
1030  543E 2C           	DB ','
1031  543F              	; get destination address
1032  543F DD 21 2F 54  	LD IX, FRMQNT
1033  5443 CD 59 01     	CALL CALBAS
1034  5446 D5           	PUSH DE
1035  5447              	; comma
1036  5447 CD 57 52     	CALL CHKCHAR
1037  544A 2C           	DB ','
1038  544B              	; get length
1039  544B DD 21 2F 54  	LD IX, FRMQNT
1040  544F CD 59 01     	CALL CALBAS
1041  5452 D5           	PUSH DE
1042  5453              	; ending )
1043  5453 CD 57 52     	CALL CHKCHAR
1044  5456 29           	DB ')'
1045  5457
1046  5457                  ; save position in BASIC text
1047  5457 E5           	PUSH HL
1048  5458 DD E1        	POP IX
1049  545A
1050  545A C1           	POP BC ; count
1051  545B D1           	POP DE ; destination
1052  545C E1           	POP HL ; source
1053  545D D9           	EXX
1054  545E FD 21 65 54  	LD IY, .RET
1055  5462 C3 0A 52     	JP ENABLE_PAGE0
1056  5465              .RET:
1057  5465 FB           	EI
1058  5466 D9           	EXX
1059  5467 CD 73 54     	CALL .LDIRMV
1060  546A D1               POP DE
1061  546B C1               POP BC
1062  546C CD 81 51         CALL RESTORE_PAGE_INFO
1063  546F DD E5        	PUSH IX
1064  5471 E1           	POP HL
1065  5472 C9           	RET
1066  5473
1067  5473              .LDIRMV:
1068  5473              	; set VRAM address *exactly* as in ROM, otherwise corruption
1069  5473 7D           	LD	A, L
1070  5474 F3           	DI
1071  5475 D3 99        	OUT	(099H), A
1072  5477 7C           	LD	A, H
1073  5478 E6 3F        	AND	03FH
1074  547A D3 99        	OUT	(099H), A
1075  547C FB           	EI
1076  547D              	;EX (SP), HL
1077  547D              	;EX (SP), HL
1078  547D              	;NOP
1079  547D              	;NOP
1080  547D              .L4:
1081  547D DB 98            IN A, (#98)
1082  547F 12           	LD (DE), A
1083  5480 13               INC DE
1084  5481 0B               DEC BC
1085  5482 79               LD A, C
1086  5483 B0               OR B
1087  5484 20 F7            JR NZ, .L4
1088  5486 C9               RET
1089  5487              ; *******************************************************************************************************
1090  5487               ENDIF
1091  5487
1092  5487              ; *******************************************************************************************************
1093  5487              ; H.TIMI function
1094  5487              MBGE_HTIMI:
1095  5487               EXPORT MBGE_HTIMI
1096  5487 F5           	PUSH AF
1097  5488
1098  5488               IF (SPRITE_CMDS == 1)
1099  5488 CD 01 4D     	CALL SPRATR_UPDATE
1100  548B               ENDIF
1101  548B
1102  548B               IF (SOUND_CMDS == 1)
1103  548B 3A F7 4C     	LD A, (SOUND_ENABLED)
1104  548E B7           	OR A
1105  548F 28 2A        	JR Z, .EXIT
1106  5491
1107  5491              	; enable page 2
1108  5491 3E 02            LD A, 2
1109  5493 CD 4A 51         CALL GET_PAGE_INFO
1110  5496 C5               PUSH BC
1111  5497 D5               PUSH DE
1112  5498 3A 43 F3         LD A, (RAMAD2)
1113  549B 26 80            LD H, 080H
1114  549D CD 91 51         CALL LOCAL_ENASLT
1115  54A0              	; enable page 0
1116  54A0 AF               XOR A
1117  54A1 CD 4A 51         CALL GET_PAGE_INFO
1118  54A4 C5               PUSH BC
1119  54A5 D5               PUSH DE
1120  54A6 3A 41 F3         LD A, (RAMAD0)
1121  54A9 26 00            LD H, 0
1122  54AB CD 91 51         CALL LOCAL_ENASLT
1123  54AE
1124  54AE CD 33 42     	CALL PLY_AKG_PLAY
1125  54B1
1126  54B1              	; restore page 0
1127  54B1 D1               POP DE
1128  54B2 C1               POP BC
1129  54B3 CD 81 51         CALL RESTORE_PAGE_INFO
1130  54B6              	; restore page 2
1131  54B6 D1               POP DE
1132  54B7 C1               POP BC
1133  54B8 CD 81 51         CALL RESTORE_PAGE_INFO
1134  54BB               ENDIF
1135  54BB
1136  54BB              .EXIT:
1137  54BB F1           	POP AF
1138  54BC C3 F0 4C     	JP ORIG.HTIMI
1139  54BF              ; *******************************************************************************************************
1140  54BF
1141  54BF              ; *******************************************************************************************************
1142  54BF              ; interrupt handler when page 0 enabled
1143  54BF              VBLANK:
1144  54BF              	EXPORT VBLANK
1145  54BF
1146  54BF F5               PUSH AF
1147  54C0              	; is VDP originator ?
1148  54C0 DB 99        	IN	A, (099H)
1149  54C2 A7           	AND	A
1150  54C3 F2 E9 54     	JP P, .EXIT
1151  54C6
1152  54C6               IF (SOUND_CMDS == 1)
1153  54C6 3A F7 4C     	LD A, (SOUND_ENABLED)
1154  54C9 B7           	OR A
1155  54CA 28 1D        	JR Z, .EXIT
1156  54CC
1157  54CC C5               PUSH BC
1158  54CD D5               PUSH DE
1159  54CE E5               PUSH HL
1160  54CF 08               EX AF, AF'
1161  54D0 D9               EXX
1162  54D1 F5               PUSH AF
1163  54D2 C5               PUSH BC
1164  54D3 D5               PUSH DE
1165  54D4 E5               PUSH HL
1166  54D5 DD E5            PUSH IX
1167  54D7 FD E5            PUSH IY
1168  54D9
1169  54D9 CD 33 42     	CALL PLY_AKG_PLAY
1170  54DC
1171  54DC FD E1            POP IY
1172  54DE DD E1            POP IX
1173  54E0 E1               POP HL
1174  54E1 D1               POP DE
1175  54E2 C1               POP BC
1176  54E3 F1               POP AF
1177  54E4 08               EX AF, AF'
1178  54E5 D9               EXX
1179  54E6 E1               POP HL
1180  54E7 D1               POP DE
1181  54E8 C1               POP BC
1182  54E9               ENDIF
1183  54E9
1184  54E9              .EXIT:
1185  54E9 F1           	POP AF
1186  54EA FB           	EI
1187  54EB ED 4D        	RETI
1188  54ED              ; *******************************************************************************************************
1189  54ED
1190  54ED               IF (SOUND_CMDS == 1)
1191  54ED              ; *******************************************************************************************************
1192  54ED              ; function to handle CALL SNDPLYINIT basic extension
1193  54ED              ; initializes sound player
1194  54ED              ; _SNDPLYINIT ( INT music_offset,
1195  54ED              ;				INT sfx_offset, can be -1 if no SFX
1196  54ED              ; will put ram in page 0 also, page 1 is already there
1197  54ED              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1198  54ED              SNDPLYINIT:
1199  54ED              	; opening (
1200  54ED CD 57 52     	CALL CHKCHAR
1201  54F0 28           	DB '('
1202  54F1              	; get music address
1203  54F1 DD 21 2F 54  	LD IX, FRMQNT
1204  54F5 CD 59 01     	CALL CALBAS
1205  54F8 D5           	PUSH DE
1206  54F9              	; comma
1207  54F9 CD 57 52     	CALL CHKCHAR
1208  54FC 2C           	DB ','
1209  54FD              	; get sfx address
1210  54FD DD 21 2F 54  	LD IX, FRMQNT
1211  5501 CD 59 01     	CALL CALBAS
1212  5504 D5           	PUSH DE
1213  5505              	; ending )
1214  5505 CD 57 52     	CALL CHKCHAR
1215  5508 29           	DB ')'
1216  5509
1217  5509                  ; save position in BASIC text
1218  5509 44           	LD B, H
1219  550A 4D           	LD C, L
1220  550B
1221  550B              	; pop LDIR parameters and store away for later
1222  550B D1           	POP DE ; sfx address
1223  550C E1           	POP HL ; music address
1224  550D C5           	PUSH BC ; basic text location
1225  550E D9           	EXX
1226  550F FD 21 16 55  	LD IY, .RET
1227  5513 C3 0A 52     	JP ENABLE_PAGE0
1228  5516              .RET:
1229  5516 D9           	EXX
1230  5517
1231  5517 D5           	PUSH DE
1232  5518 AF           	XOR A
1233  5519              	; HL = music location
1234  5519 CD 62 41     	CALL PLY_AKG_INIT
1235  551C 3E 01        	LD A, 1
1236  551E 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1237  5521
1238  5521 E1           	POP HL ; SFX
1239  5522              	; check if SFX address -1
1240  5522 23           	INC HL
1241  5523 7D           	LD A, L
1242  5524 B4           	OR H
1243  5525 28 09        	JR Z,.L1
1244  5527 2B           	DEC HL
1245  5528 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1246  552B 3E 01        	LD A, 1
1247  552D 32 F6 4C     	LD (SFX_INIT_STATUS), A
1248  5530              .L1:
1249  5530 D1               POP DE
1250  5531 C1               POP BC
1251  5532 CD 81 51         CALL RESTORE_PAGE_INFO
1252  5535
1253  5535 E1           	POP HL
1254  5536 C9           	RET
1255  5537              ; *******************************************************************************************************
1256  5537
1257  5537              ; *******************************************************************************************************
1258  5537              ; function to handle CALL SNDPLYON basic extension
1259  5537              ; enables sound player
1260  5537              ; _SNDPLYON
1261  5537              ; sets SOUND_ENABLED variable to 1 if init call was done
1262  5537              ; if not throws out of data error
1263  5537              SNDPLYON:
1264  5537 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1265  553A B7           	OR A
1266  553B 20 05        	JR NZ, .L1
1267  553D              	; player not initialized, throw error
1268  553D 1E 04        	LD E, 04 ; Out of DATA
1269  553F C3 6F 52     	JP THROW_ERROR
1270  5542              .L1:
1271  5542 32 F7 4C     	LD (SOUND_ENABLED), A
1272  5545              	; disable key click
1273  5545 AF           	XOR A
1274  5546 32 DB F3     	LD (CLIKSW), A
1275  5549 C9           	RET
1276  554A              ; *******************************************************************************************************
1277  554A
1278  554A              ; *******************************************************************************************************
1279  554A              ; function to handle CALL SNDPLYOFF basic extension
1280  554A              ; disables sound player
1281  554A              ; _SNDPLYOFF
1282  554A              ; sets SOUND_ENABLED variable to 0
1283  554A              ; calls AKG to stop music and SFX on all channels if initialized
1284  554A              SNDPLYOFF:
1285  554A 3A F7 4C     	LD A, (SOUND_ENABLED)
1286  554D B7           	OR A
1287  554E C8           	RET Z ; already stopped
1288  554F AF           	XOR A
1289  5550 32 F7 4C     	LD (SOUND_ENABLED), A
1290  5553 E5           	PUSH HL
1291  5554 CD 21 42     	CALL PLY_AKG_STOP
1292  5557 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1293  555A B7           	OR A
1294  555B 28 0E        	JR Z, .EXIT ; SFX not in use
1295  555D AF           	XOR A
1296  555E CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1297  5561 3E 01        	LD A, 1
1298  5563 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1299  5566 3E 02        	LD A, 2
1300  5568 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1301  556B              .EXIT:
1302  556B E1           	POP HL
1303  556C C9           	RET
1304  556D              ; *******************************************************************************************************
1305  556D
1306  556D              ; *******************************************************************************************************
1307  556D              ; function to handle CALL SNDSFX basic extension
1308  556D              ; plays a sound effect
1309  556D              ; _SNDSFX ( BYTE sfx_number, >0
1310  556D              ;			BYTE channel, = 0,1 or 2
1311  556D              ;			BYTE inverted_volume = 0-16, 0 being full volume
1312  556D              ; will put ram in page 0 also, page 1 is already there
1313  556D              ; if sound off throws illegal function call
1314  556D              ; if sfx not initialized, throws out of data
1315  556D              SNDSFX:
1316  556D              	; opening (
1317  556D CD 57 52     	CALL CHKCHAR
1318  5570 28           	DB '('
1319  5571              	; get sfx_number
1320  5571 DD 21 1C 52  	LD IX, GETBYT
1321  5575 CD 59 01     	CALL CALBAS
1322  5578 D5           	PUSH DE
1323  5579              	; comma
1324  5579 CD 57 52     	CALL CHKCHAR
1325  557C 2C           	DB ','
1326  557D              	; get sfx address
1327  557D DD 21 1C 52  	LD IX, GETBYT
1328  5581 CD 59 01     	CALL CALBAS
1329  5584 D5           	PUSH DE
1330  5585              	; comma
1331  5585 CD 57 52     	CALL CHKCHAR
1332  5588 2C           	DB ','
1333  5589              	; get inverted volume
1334  5589 DD 21 1C 52  	LD IX, GETBYT
1335  558D CD 59 01     	CALL CALBAS
1336  5590 D5           	PUSH DE
1337  5591              	; ending )
1338  5591 CD 57 52     	CALL CHKCHAR
1339  5594 29           	DB ')'
1340  5595
1341  5595 3A F7 4C     	LD A, (SOUND_ENABLED)
1342  5598 B7           	OR A
1343  5599 20 05        	JR NZ, .L1
1344  559B              	; sound disabled, throw illegal function call
1345  559B 1E 05        	LD E, 5
1346  559D C3 6F 52     	JP THROW_ERROR
1347  55A0              .L1:
1348  55A0 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1349  55A3 B7           	OR A
1350  55A4 20 05        	JR NZ, .L2
1351  55A6              	; sfx data not initialized, throw out of data
1352  55A6 1E 04        	LD E, 4
1353  55A8 C3 6F 52     	JP THROW_ERROR
1354  55AB              .L2:
1355  55AB              	; pop  parameters and store away for later
1356  55AB D1           	POP DE ; inverted volume
1357  55AC 43           	LD B, E
1358  55AD D1           	POP DE ; channel
1359  55AE 4B           	LD C, E
1360  55AF D1           	POP DE
1361  55B0 7B           	LD A, E
1362  55B1 08           	EX AF, AF'
1363  55B2 E5           	PUSH HL ; basic text location
1364  55B3 D9           	EXX
1365  55B4 FD 21 BB 55  	LD IY, .RET
1366  55B8 C3 0A 52     	JP ENABLE_PAGE0
1367  55BB              .RET:
1368  55BB D9           	EXX
1369  55BC 08           	EX AF, AF'
1370  55BD CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1371  55C0
1372  55C0 D1               POP DE
1373  55C1 C1               POP BC
1374  55C2 CD 81 51         CALL RESTORE_PAGE_INFO
1375  55C5
1376  55C5 E1           	POP HL
1377  55C6 C9           	RET
1378  55C7              ; *******************************************************************************************************
1379  55C7               ENDIF
1380  55C7
1381  55C7               IF (BLIT_CMDS == 1)
1382  55C7              ; *******************************************************************************************************
1383  55C7              ; function rotates mask and data of several characters and applies to background data
1384  55C7              ; this handles x-shift from 0 to 4
1385  55C7              ; contains self-modifying code that is set-up from external function
1386  55C7              ; input HL=pointer to mask data
1387  55C7              ; input HL'=pointer to character data
1388  55C7              ; input DE=output buffer containing background data
1389  55C7              ; input BC=DE+8
1390  55C7              ; input A=number of characters to process
1391  55C7              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1392  55C7              SHIFT04:
1393  55C7 08           	EX AF, AF'
1394  55C8 7E           	LD A, (HL) ; get mask
1395  55C9 D9           	EXX
1396  55CA 57           	LD D, A
1397  55CB 1E FF        	LD E, #FF
1398  55CD 37           	SCF
1399  55CE              .M1:
1400  55CE 18 FE        	JR .M1 ; this is self-modifying part
1401  55D0 CB 1A        	RR D
1402  55D2 CB 1B        	RR E
1403  55D4 CB 1A        	RR D
1404  55D6 CB 1B        	RR E
1405  55D8 CB 1A        	RR D
1406  55DA CB 1B        	RR E
1407  55DC CB 1A        	RR D
1408  55DE CB 1B        	RR E
1409  55E0
1410  55E0 46           	LD B, (HL) ; get data
1411  55E1 0E 00        	LD C, 0
1412  55E3              .M2:
1413  55E3 18 FE        	JR .M2 ; also self-modifying part
1414  55E5 CB 38        	SRL B
1415  55E7 CB 19        	RR C
1416  55E9 CB 38        	SRL B
1417  55EB CB 19        	RR C
1418  55ED CB 38        	SRL B
1419  55EF CB 19        	RR C
1420  55F1 CB 38        	SRL B
1421  55F3 CB 19        	RR C
1422  55F5
1423  55F5 D9           	EXX
1424  55F6 1A           	LD A, (DE) ; background
1425  55F7 D9           	EXX
1426  55F8 A2           	AND D
1427  55F9 B0           	OR B
1428  55FA D9           	EXX
1429  55FB 12           	LD (DE), A
1430  55FC
1431  55FC 0A           	LD A, (BC)
1432  55FD D9           	EXX
1433  55FE A3           	AND E
1434  55FF B1           	OR C
1435  5600 23           	INC HL
1436  5601 D9           	EXX
1437  5602 02           	LD (BC), A
1438  5603
1439  5603 23           	INC HL
1440  5604 13           	INC DE
1441  5605 03           	INC BC
1442  5606
1443  5606 08           	EX AF, AF'
1444  5607 3D           	DEC A
1445  5608 C2 C7 55     	JP NZ, SHIFT04
1446  560B C9           	RET
1447  560C              ; *******************************************************************************************************
1448  560C
1449  560C              ; *******************************************************************************************************
1450  560C              ; function rotates mask and data of several characters and applies to background data
1451  560C              ; this handles x-shift from 5 to 8
1452  560C              ; contains self-modifying code that is set-up from external function
1453  560C              ; input HL=pointer to mask data
1454  560C              ; input HL'=pointer to character data
1455  560C              ; input DE=output buffer containing background data
1456  560C              ; input BC=DE+8
1457  560C              ; input A=number of characters to process
1458  560C              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1459  560C              SHIFT58:
1460  560C 08           	EX AF, AF'
1461  560D 7E           	LD A, (HL) ; get mask
1462  560E D9           	EXX
1463  560F 57           	LD D, A
1464  5610 1E FF        	LD E, #FF
1465  5612 37           	SCF
1466  5613              .M1:
1467  5613 18 FE        	JR .M1 ; this is self-modifying part
1468  5615 CB 12        	RL D
1469  5617 CB 13        	RL E
1470  5619 CB 12        	RL D
1471  561B CB 13        	RL E
1472  561D CB 12        	RL D
1473  561F CB 13        	RL E
1474  5621
1475  5621 46           	LD B, (HL)
1476  5622 0E 00        	LD C, 0
1477  5624              .M2:
1478  5624 18 FE        	JR .M2 ; also self-modifying part
1479  5626 CB 20        	SLA B
1480  5628 CB 11        	RL C
1481  562A CB 20        	SLA B
1482  562C CB 11        	RL C
1483  562E CB 20        	SLA B
1484  5630 CB 11        	RL C
1485  5632
1486  5632 D9           	EXX
1487  5633 1A           	LD A, (DE) ; background
1488  5634 D9           	EXX
1489  5635 A3           	AND E
1490  5636 B1           	OR C
1491  5637 D9           	EXX
1492  5638 12           	LD (DE), A
1493  5639
1494  5639 0A           	LD A, (BC)
1495  563A D9           	EXX
1496  563B A2           	AND D
1497  563C B0           	OR B
1498  563D 23           	INC HL
1499  563E D9           	EXX
1500  563F 02           	LD (BC), A
1501  5640
1502  5640 23           	INC HL
1503  5641 13           	INC DE
1504  5642 03           	INC BC
1505  5643
1506  5643 08           	EX AF, AF'
1507  5644 3D           	DEC A
1508  5645 C2 0C 56     	JP NZ, SHIFT58
1509  5648 C9           	RET
1510  5649              ; *******************************************************************************************************
1511  5649
1512  5649              ; *******************************************************************************************************
1513  5649              ; routine that shifts one row of characters
1514  5649              ; contains self-modifying code that is set-up from external function
1515  5649              ; input HL=pointer to mask data
1516  5649              ; input HL'=pointer to character data
1517  5649              ; input DE=output buffer containing background data
1518  5649              ; input A=number of characters to process
1519  5649              ; input IX=pointer to structure describing input data
1520  5649              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1521  5649              SHIFT_ROW:
1522  5649 F5           	PUSH AF
1523  564A ED 53 13 50  		LD (BLIT_TMP1), DE
1524  564E E5           		PUSH HL
1525  564F CD 92 56     			CALL .ADDYSHIFT
1526  5652 E1           		POP HL
1527  5653 ED 53 15 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1528  5657              .L1:
1529  5657 3E 08        		LD A, 8
1530  5659 DD 96 02     		SUB (IX+2) ; y shift
1531  565C              .CALL1:
1532  565C CD 00 00     		CALL 0
1533  565F DD 7E 02     		LD A, (IX+2); y shift
1534  5662 B7           		OR A
1535  5663 28 26        		JR Z, .DONE
1536  5665 ED 5B 13 50  		LD DE, (BLIT_TMP1)
1537  5669 E5           		PUSH HL
1538  566A CD A0 56     			CALL .DETONEXTROW
1539  566D E1           		POP HL
1540  566E              .CALL2:
1541  566E CD 00 00     		CALL 0
1542  5671 ED 5B 13 50  		LD DE, (BLIT_TMP1)
1543  5675 E5           		PUSH HL
1544  5676 CD 9A 56     			CALL .ADD8
1545  5679 E1           		POP HL
1546  567A ED 53 13 50  		LD (BLIT_TMP1), DE
1547  567E ED 5B 15 50  		LD DE, (BLIT_TMP2)
1548  5682 E5           		PUSH HL
1549  5683 CD 9A 56     			CALL .ADD8
1550  5686 E1           		POP HL
1551  5687 ED 53 15 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1552  568B              .DONE:
1553  568B F1           	POP AF
1554  568C 3D           	DEC A
1555  568D C8           	RET Z
1556  568E F5           	PUSH AF
1557  568F C3 57 56     	JP .L1
1558  5692              .ADDYSHIFT:
1559  5692 EB           	EX DE, HL
1560  5693 16 00        	LD D, 0
1561  5695 DD 5E 02     	LD E, (IX+2); y shift
1562  5698 18 0C        	JR .MOVDEBC
1563  569A              .ADD8:
1564  569A 21 08 00     	LD HL, 8
1565  569D C3 A6 56     	JP .MOVDEBC
1566  56A0              .DETONEXTROW:
1567  56A0 DD 6E 06     	LD L, (IX+6)
1568  56A3 DD 66 07     	LD H, (IX+7) ; bkg add to value
1569  56A6              .MOVDEBC:
1570  56A6 19           	ADD HL, DE
1571  56A7 54           	LD D, H
1572  56A8 5D           	LD E, L
1573  56A9 01 08 00     	LD BC, 8
1574  56AC 09           	ADD HL, BC
1575  56AD 44           	LD B, H
1576  56AE 4D           	LD C, L
1577  56AF C9           	RET
1578  56B0              ; *******************************************************************************************************
1579  56B0
1580  56B0              ; *******************************************************************************************************
1581  56B0              ; function rotates mask and character data and applies it to background
1582  56B0              ; input IX=pointer to structure describing input data
1583  56B0              ; +0  DW horizontal shift count 0-7 (low byte used)
1584  56B0              ; +2  DW vertical shift count 0-7 (low byte used)
1585  56B0              ; +4  DW background data start;
1586  56B0              ; +6  DW background add to value to next row of background data
1587  56B0              ; +8  DW mask data start;
1588  56B0              ; +10  DW character data start;
1589  56B0              ; +12 DW character&mask add to value to next row of data
1590  56B0              ; +14 DW columns (low byte used)
1591  56B0              ; +16 DW rows (low byte used)
1592  56B0              SHIFT_MERGE_CHARACTER:
1593  56B0 DD 7E 00     	LD A, (IX) ; shift
1594  56B3 FE 05        	CP 5
1595  56B5 38 25        	JR C, .RIGHT
1596  56B7              	; shifts 5-7, use rotate towards left 1-3
1597  56B7 21 0C 56     	LD HL, SHIFT58
1598  56BA 22 5D 56     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1599  56BD 22 6F 56     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1600  56C0 D6 05        	SUB 5
1601  56C2 28 0D        	JR Z, .L1
1602  56C4 87           	ADD A, A
1603  56C5 87           	ADD A, A
1604  56C6 67           	LD H, A
1605  56C7 2E 18        	LD L, #18 ; JR opcode
1606  56C9 22 13 56     	LD (SHIFT58.M1), HL
1607  56CC 22 24 56     	LD (SHIFT58.M2), HL
1608  56CF 18 32        	JR .DO
1609  56D1              .L1:
1610  56D1 21 00 00     	LD HL, 0 ; 2xNOP opcode
1611  56D4 22 13 56     	LD (SHIFT58.M1), HL
1612  56D7 22 24 56     	LD (SHIFT58.M2), HL
1613  56DA 18 27        	JR .DO
1614  56DC              .RIGHT:
1615  56DC              	; shifts 0-4, rotate towards right
1616  56DC 21 C7 55     	LD HL, SHIFT04
1617  56DF 22 5D 56     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1618  56E2 22 6F 56     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1619  56E5 FE 04        	CP 4
1620  56E7 28 11        	JR Z, .R1
1621  56E9 D6 04        	SUB 4
1622  56EB ED 44        	NEG
1623  56ED 87           	ADD A, A
1624  56EE 87           	ADD A, A
1625  56EF 67           	LD H, A
1626  56F0 2E 18        	LD L, #18 ; JR opcode
1627  56F2 22 CE 55     	LD (SHIFT04.M1), HL
1628  56F5 22 E3 55     	LD (SHIFT04.M2), HL
1629  56F8 18 09        	JR .DO
1630  56FA              .R1:
1631  56FA 21 00 00     	LD HL, 0 ; 2xNOP opcode
1632  56FD 22 CE 55     	LD (SHIFT04.M1), HL
1633  5700 22 E3 55     	LD (SHIFT04.M2), HL
1634  5703              .DO:
1635  5703 DD 46 10     	LD B, (IX+16) ; rows
1636  5706 DD 6E 08     	LD L, (IX+8)
1637  5709 DD 66 09     	LD H, (IX+9) ; mask data
1638  570C DD 5E 04     	LD E, (IX+4)
1639  570F DD 56 05     	LD D, (IX+5) ; background data
1640  5712 D9           	EXX
1641  5713 DD 6E 0A     	LD L, (IX+10)
1642  5716 DD 66 0B     	LD H, (IX+11) ; character data
1643  5719 D9           	EXX
1644  571A              .LOOP:
1645  571A C5           	PUSH BC
1646  571B E5           		PUSH HL
1647  571C D5           			PUSH DE
1648  571D D9           				EXX
1649  571E E5           				PUSH HL
1650  571F D9           					EXX
1651  5720 DD 7E 0E     					LD A, (IX+14) ; columns
1652  5723              .CALL:
1653  5723 CD 49 56     					CALL SHIFT_ROW
1654  5726 E1           				POP HL
1655  5727 DD 5E 0C     				LD E, (IX+12)
1656  572A DD 56 0D     				LD D, (IX+13) ; char data to next row
1657  572D 19           				ADD HL, DE
1658  572E D9           				EXX
1659  572F E1           			POP HL
1660  5730 DD 5E 06     			LD E, (IX+6)
1661  5733 DD 56 07     			LD D, (IX+7) ; background to next row
1662  5736 19           			ADD HL, DE
1663  5737 EB           			EX DE, HL
1664  5738 E1           		POP HL
1665  5739 DD 4E 0C     		LD C, (IX+12)
1666  573C DD 46 0D     		LD B, (IX+13) ; char data to next row
1667  573F 09           		ADD HL, BC
1668  5740 C1           	POP BC
1669  5741 10 D7        	DJNZ .LOOP
1670  5743 C9           	RET
1671  5744              ; *******************************************************************************************************
1672  5744
1673  5744               IFNDEF CMDS_WITH_PARAMETERS
1674  5744 ~            ; *******************************************************************************************************
1675  5744 ~            ; function to handle CALL BLIT basic extension
1676  5744 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1677  5744 ~            ; fuses with background data and applies vertical shift too
1678  5744 ~            ; BLIT ( INT request_data_ptr )
1679  5744 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1680  5744 ~            ; will put ram in page 0 also, page 1 is already there
1681  5744 ~            BLIT:
1682  5744 ~            	; opening (
1683  5744 ~            	CALL CHKCHAR
1684  5744 ~            	DB '('
1685  5744 ~            	; get pointer to request struct
1686  5744 ~            	LD IX, FRMQNT
1687  5744 ~            	CALL CALBAS
1688  5744 ~            	PUSH DE
1689  5744 ~            	; ending )
1690  5744 ~            	CALL CHKCHAR
1691  5744 ~            	DB ')'
1692  5744 ~
1693  5744 ~            	POP IX ; pointer to request struct
1694  5744 ~
1695  5744 ~            	PUSH HL ; save position in BASIC buffer
1696  5744 ~
1697  5744 ~            	LD IY, .RET
1698  5744 ~            	JP ENABLE_PAGE0
1699  5744 ~            .RET:
1700  5744 ~            	EI
1701  5744 ~            	CALL SHIFT_MERGE_CHARACTER
1702  5744 ~
1703  5744 ~                POP DE
1704  5744 ~                POP BC
1705  5744 ~                CALL RESTORE_PAGE_INFO
1706  5744 ~
1707  5744 ~            	POP HL
1708  5744 ~            	RET
1709  5744 ~            ; *******************************************************************************************************
1710  5744               ENDIF
1711  5744
1712  5744               IFDEF CMDS_WITH_PARAMETERS
1713  5744              ; *******************************************************************************************************
1714  5744              ; function to handle CALL BLIT basic extension
1715  5744              ; rotates 1-bit character drawing horizontally with mask and character data and
1716  5744              ; fuses with background data and applies vertical shift too
1717  5744              ; in form without pointers
1718  5744              ; BLIT ( INT x,
1719  5744              ;		 INT y,
1720  5744              ;		 INT char_data_pointer,
1721  5744              ;		 INT mask_data_pointer,
1722  5744              ;		 INT width (in characters),
1723  5744              ;		 INT height (in characters),
1724  5744              ;		 INT background_pointer (top left),
1725  5744              ;		 INT background_width (in characters),
1726  5744              ;		 INT background_height (in characters))
1727  5744              ; will put ram in page 0 also, page 1 is already there
1728  5744              BLIT:
1729  5744              	; opening (
1730  5744 CD 57 52     	CALL CHKCHAR
1731  5747 28           	DB '('
1732  5748              	; get x coordinate
1733  5748 DD 21 2F 54  	LD IX, FRMQNT
1734  574C CD 59 01     	CALL CALBAS
1735  574F 7B           	LD A, E
1736  5750 E6 07        	AND 7
1737  5752 32 17 50     	LD (BLIT_STRUCT+0), A
1738  5755 CD 32 58     	CALL .DAdiv8
1739  5758 32 13 50     	LD (BLIT_TMP+0),A
1740  575B              	; comma
1741  575B CD 57 52     	CALL CHKCHAR
1742  575E 2C           	DB ','
1743  575F              	; get y coordinate
1744  575F DD 21 2F 54  	LD IX, FRMQNT
1745  5763 CD 59 01     	CALL CALBAS
1746  5766 7B           	LD A, E
1747  5767 E6 07        	AND 7
1748  5769 32 19 50     	LD (BLIT_STRUCT+2), A
1749  576C CD 32 58     	CALL .DAdiv8
1750  576F 32 14 50     	LD (BLIT_TMP+1),A
1751  5772              	; comma
1752  5772 CD 57 52     	CALL CHKCHAR
1753  5775 2C           	DB ','
1754  5776              	; get char data pointer
1755  5776 DD 21 2F 54  	LD IX, FRMQNT
1756  577A CD 59 01     	CALL CALBAS
1757  577D ED 53 21 50  	LD (BLIT_STRUCT+10), DE
1758  5781              	; comma
1759  5781 CD 57 52     	CALL CHKCHAR
1760  5784 2C           	DB ','
1761  5785              	; get mask data pointer
1762  5785 DD 21 2F 54  	LD IX, FRMQNT
1763  5789 CD 59 01     	CALL CALBAS
1764  578C ED 53 1F 50  	LD (BLIT_STRUCT+8), DE
1765  5790              	; comma
1766  5790 CD 57 52     	CALL CHKCHAR
1767  5793 2C           	DB ','
1768  5794              	; get width
1769  5794 DD 21 2F 54  	LD IX, FRMQNT
1770  5798 CD 59 01     	CALL CALBAS
1771  579B 7B           	LD A, E
1772  579C 32 25 50     	LD (BLIT_STRUCT+14), A
1773  579F              	; comma
1774  579F CD 57 52     	CALL CHKCHAR
1775  57A2 2C           	DB ','
1776  57A3              	; get height
1777  57A3 DD 21 2F 54  	LD IX, FRMQNT
1778  57A7 CD 59 01     	CALL CALBAS
1779  57AA 7B           	LD A, E
1780  57AB 32 27 50     	LD (BLIT_STRUCT+16), A
1781  57AE              	; comma
1782  57AE CD 57 52     	CALL CHKCHAR
1783  57B1 2C           	DB ','
1784  57B2              	; get background pointer
1785  57B2 DD 21 2F 54  	LD IX, FRMQNT
1786  57B6 CD 59 01     	CALL CALBAS
1787  57B9 ED 53 1B 50  	LD (BLIT_STRUCT+4), DE
1788  57BD              	; comma
1789  57BD CD 57 52     	CALL CHKCHAR
1790  57C0 2C           	DB ','
1791  57C1              	; get background width
1792  57C1 DD 21 2F 54  	LD IX, FRMQNT
1793  57C5 CD 59 01     	CALL CALBAS
1794  57C8 7B           	LD A, E
1795  57C9 32 15 50     	LD (BLIT_TMP+2), A
1796  57CC              	; comma
1797  57CC CD 57 52     	CALL CHKCHAR
1798  57CF 2C           	DB ','
1799  57D0              	; get background height
1800  57D0 DD 21 2F 54  	LD IX, FRMQNT
1801  57D4 CD 59 01     	CALL CALBAS
1802  57D7 7B           	LD A, E
1803  57D8 32 16 50     	LD (BLIT_TMP+3), A
1804  57DB              	; ending )
1805  57DB CD 57 52     	CALL CHKCHAR
1806  57DE 29           	DB ')'
1807  57DF
1808  57DF E5           	PUSH HL ; save position in BASIC buffer
1809  57E0
1810  57E0              	; calculate char&mask add to value
1811  57E0 26 00        	LD H, 0
1812  57E2 3A 25 50     	LD A, (BLIT_STRUCT+14)
1813  57E5 6F           	LD L, A
1814  57E6 CD 46 51     	CALL HLx8
1815  57E9 22 23 50     	LD (BLIT_STRUCT+12), HL
1816  57EC              	; calculate background add to value
1817  57EC 26 00        	LD H, 0
1818  57EE 3A 15 50     	LD A, (BLIT_TMP+2)
1819  57F1 6F           	LD L, A
1820  57F2 CD 46 51     	CALL HLx8
1821  57F5 22 1D 50     	LD (BLIT_STRUCT+6), HL
1822  57F8              	; calculate pointer to background location
1823  57F8 21 00 00     	LD HL, 0
1824  57FB 3A 14 50     	LD A,(BLIT_TMP+1)
1825  57FE B7           	OR A
1826  57FF 28 08        	JR Z, .L1
1827  5801 47           	LD B,A
1828  5802 ED 5B 1D 50  	LD DE,(BLIT_STRUCT+6)
1829  5806              .L0:
1830  5806 19           	ADD HL, DE
1831  5807 10 FD        	DJNZ .L0
1832  5809              .L1:
1833  5809 EB           	EX DE,HL
1834  580A 26 00        	LD H,0
1835  580C 3A 13 50     	LD A,(BLIT_TMP+0)
1836  580F 6F           	LD L,A
1837  5810 CD 46 51     	CALL HLx8
1838  5813 19           	ADD HL,DE
1839  5814 ED 5B 1B 50  	LD DE,(BLIT_STRUCT+4)
1840  5818 19           	ADD HL,DE
1841  5819 22 1B 50     	LD (BLIT_STRUCT+4),HL
1842  581C
1843  581C FD 21 23 58  	LD IY, .RET
1844  5820 C3 0A 52     	JP ENABLE_PAGE0
1845  5823              .RET:
1846  5823 FB           	EI
1847  5824 DD 21 17 50  	LD IX, BLIT_STRUCT
1848  5828 CD B0 56     	CALL SHIFT_MERGE_CHARACTER
1849  582B
1850  582B D1               POP DE
1851  582C C1               POP BC
1852  582D CD 81 51         CALL RESTORE_PAGE_INFO
1853  5830
1854  5830 E1           	POP HL
1855  5831 C9           	RET
1856  5832              .DAdiv8:
1857  5832 7B           	LD A,E
1858  5833 CB 2A        	SRA D
1859  5835 CB 1F            RR  A
1860  5837 CB 2A            SRA D
1861  5839 CB 1F            RR  A
1862  583B CB 2A            SRA D
1863  583D CB 1F            RR  A
1864  583F C9           	RET
1865  5840              ; *******************************************************************************************************
1866  5840               ENDIF
1867  5840               ENDIF
1868  5840
1869  5840               IF (TILE_CMDS == 1)
1870  5840              ; *******************************************************************************************************
1871  5840              ; generic function to implement tiling
1872  5840              ; should be modified to call appropriate function for memory or vram
1873  5840              ; input IX=pointer to following structure
1874  5840              ; +00 tile_data_ptr
1875  5840              ; +02 tile_rows
1876  5840              ; +04 tile_columns
1877  5840              ; +06 destination_address
1878  5840              ; +08 dest_to_next_row_add_to_value
1879  5840              ; +10 num_horizontal_tiles
1880  5840              ; +12 num_vertical_tiles
1881  5840              ; modifies AF, BC, DE, HL
1882  5840              TILE:
1883  5840 DD 6E 06     	LD L, (IX+6)
1884  5843 DD 66 07     	LD H, (IX+7) ; destination address
1885  5846 22 13 50     	LD (TILETMP1), HL
1886  5849 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1887  584C              .L1:
1888  584C C5           	PUSH BC
1889  584D DD 6E 00     		LD L, (IX+0)
1890  5850 DD 66 01     		LD H, (IX+1) ; tile address
1891  5853 22 15 50     		LD (TILETMP2), HL
1892  5856 DD 46 02     		LD B, (IX+2) ; tile rows
1893  5859              .L2:
1894  5859 C5           		PUSH BC
1895  585A              .CALL1:
1896  585A CD 00 00     			CALL 0
1897  585D DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1898  5860              .L3:
1899  5860 C5           			PUSH BC
1900  5861 2A 15 50     				LD HL, (TILETMP2)
1901  5864 DD 46 04     				LD B, (IX+4) ; tile columns
1902  5867              .L4:
1903  5867 C5           				PUSH BC
1904  5868              .CALL2:
1905  5868 CD 00 00     					CALL 0
1906  586B C1           				POP BC
1907  586C 10 F9        				DJNZ .L4
1908  586E C1           			POP BC
1909  586F 10 EF        			DJNZ .L3
1910  5871 22 15 50     			LD (TILETMP2), HL
1911  5874 2A 13 50     			LD HL, (TILETMP1)
1912  5877 DD 5E 08     			LD E, (IX+8)
1913  587A DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1914  587D 19           			ADD HL, DE
1915  587E 22 13 50     			LD (TILETMP1), HL
1916  5881 C1           		POP BC
1917  5882 10 D5        		DJNZ .L2
1918  5884 C1           	POP BC
1919  5885 10 C5        	DJNZ .L1
1920  5887 C9           	RET
1921  5888              ; *******************************************************************************************************
1922  5888
1923  5888               IFNDEF CMDS_WITH_PARAMETERS
1924  5888 ~            ; *******************************************************************************************************
1925  5888 ~            ; function to handle CALL TILERAM basic extension
1926  5888 ~            ; fills memory with tiles
1927  5888 ~            ; TILERAM ( INT request_data_ptr )
1928  5888 ~            ; request_data_ptr described in TILE
1929  5888 ~            ; will put ram in page 0 also, page 1 is already there
1930  5888 ~            TILERAM:
1931  5888 ~            	; opening (
1932  5888 ~            	CALL CHKCHAR
1933  5888 ~            	DB '('
1934  5888 ~            	; get pointer to request struct
1935  5888 ~            	LD IX, FRMQNT
1936  5888 ~            	CALL CALBAS
1937  5888 ~            	PUSH DE
1938  5888 ~            	; ending )
1939  5888 ~            	CALL CHKCHAR
1940  5888 ~            	DB ')'
1941  5888 ~
1942  5888 ~            	POP IX ; pointer to request struct
1943  5888 ~
1944  5888 ~            	PUSH HL ; save position in BASIC buffer
1945  5888 ~
1946  5888 ~            	LD IY, .RET
1947  5888 ~            	JP ENABLE_PAGE0
1948  5888 ~            .RET:
1949  5888 ~            	EI
1950  5888 ~            	; set RAM functions to call
1951  5888 ~            	LD HL, .TILECOPY
1952  5888 ~            	LD (TILE.CALL2+1), HL
1953  5888 ~            	LD HL, .SETDESTROW
1954  5888 ~            	LD (TILE.CALL1+1), HL
1955  5888 ~            	CALL TILE
1956  5888 ~
1957  5888 ~                POP DE
1958  5888 ~                POP BC
1959  5888 ~                CALL RESTORE_PAGE_INFO
1960  5888 ~
1961  5888 ~            	POP HL
1962  5888 ~            	RET
1963  5888 ~            .TILECOPY:
1964  5888 ~            	.8 LDI
1965  5888 ~            	RET
1966  5888 ~            .SETDESTROW:
1967  5888 ~            	LD DE, (TILETMP1)
1968  5888 ~            	RET
1969  5888 ~            ; *******************************************************************************************************
1970  5888               ENDIF
1971  5888
1972  5888               IFDEF CMDS_WITH_PARAMETERS
1973  5888              ; *******************************************************************************************************
1974  5888              ; function to handle CALL TILERAM basic extension
1975  5888              ; fills memory with tiles
1976  5888              ; TILERAM ( INT tile_data_pointer,
1977  5888              ;			INT tile_columns,
1978  5888              ;			INT tile_rows,
1979  5888              ;			INT destination_pointer,
1980  5888              ;			INT destination_columns,
1981  5888              ;			INT destination_rows,
1982  5888              ;			INT destination_begin_column,
1983  5888              ;			INT destination_begin_row,
1984  5888              ;			INT number_of_tiles_horizontally,
1985  5888              ;			INT	number_of_tiles_vertically )
1986  5888              ; will put ram in page 0 also, page 1 is already there
1987  5888              TILERAM:
1988  5888              	; opening (
1989  5888 CD 57 52     	CALL CHKCHAR
1990  588B 28           	DB '('
1991  588C              	; get tile data pointer coordinate
1992  588C DD 21 2F 54  	LD IX, FRMQNT
1993  5890 CD 59 01     	CALL CALBAS
1994  5893 ED 53 17 50  	LD (BLIT_STRUCT+0), DE
1995  5897              	; comma
1996  5897 CD 57 52     	CALL CHKCHAR
1997  589A 2C           	DB ','
1998  589B              	; get tile columns
1999  589B DD 21 2F 54  	LD IX, FRMQNT
2000  589F CD 59 01     	CALL CALBAS
2001  58A2 ED 53 1B 50  	LD (BLIT_STRUCT+4), DE
2002  58A6              	; comma
2003  58A6 CD 57 52     	CALL CHKCHAR
2004  58A9 2C           	DB ','
2005  58AA              	; get tile columns
2006  58AA DD 21 2F 54  	LD IX, FRMQNT
2007  58AE CD 59 01     	CALL CALBAS
2008  58B1 ED 53 19 50  	LD (BLIT_STRUCT+2), DE
2009  58B5              	; comma
2010  58B5 CD 57 52     	CALL CHKCHAR
2011  58B8 2C           	DB ','
2012  58B9              	; get destintion pointer
2013  58B9 DD 21 2F 54  	LD IX, FRMQNT
2014  58BD CD 59 01     	CALL CALBAS
2015  58C0 ED 53 1D 50  	LD (BLIT_STRUCT+6), DE
2016  58C4              	; comma
2017  58C4 CD 57 52     	CALL CHKCHAR
2018  58C7 2C           	DB ','
2019  58C8              	; get destination columns
2020  58C8 DD 21 2F 54  	LD IX, FRMQNT
2021  58CC CD 59 01     	CALL CALBAS
2022  58CF 7B           	LD A, E
2023  58D0 32 13 50     	LD (BLIT_TMP+0), A
2024  58D3              	; comma
2025  58D3 CD 57 52     	CALL CHKCHAR
2026  58D6 2C           	DB ','
2027  58D7              	; get destination rows
2028  58D7 DD 21 2F 54  	LD IX, FRMQNT
2029  58DB CD 59 01     	CALL CALBAS
2030  58DE 7B           	LD A, E
2031  58DF 32 14 50     	LD (BLIT_TMP+1), A
2032  58E2              	; comma
2033  58E2 CD 57 52     	CALL CHKCHAR
2034  58E5 2C           	DB ','
2035  58E6              	; get destination begin column
2036  58E6 DD 21 2F 54  	LD IX, FRMQNT
2037  58EA CD 59 01     	CALL CALBAS
2038  58ED 7B           	LD A, E
2039  58EE 32 15 50     	LD (BLIT_TMP+2), A
2040  58F1              	; comma
2041  58F1 CD 57 52     	CALL CHKCHAR
2042  58F4 2C           	DB ','
2043  58F5              	; get destination begin row
2044  58F5 DD 21 2F 54  	LD IX, FRMQNT
2045  58F9 CD 59 01     	CALL CALBAS
2046  58FC 7B           	LD A, E
2047  58FD 32 16 50     	LD (BLIT_TMP+3), A
2048  5900              	; comma
2049  5900 CD 57 52     	CALL CHKCHAR
2050  5903 2C           	DB ','
2051  5904              	; get number of tiles horizontally
2052  5904 DD 21 2F 54  	LD IX, FRMQNT
2053  5908 CD 59 01     	CALL CALBAS
2054  590B ED 53 21 50  	LD (BLIT_STRUCT+10), DE
2055  590F              	; comma
2056  590F CD 57 52     	CALL CHKCHAR
2057  5912 2C           	DB ','
2058  5913              	; get number of tiles vertically
2059  5913 DD 21 2F 54  	LD IX, FRMQNT
2060  5917 CD 59 01     	CALL CALBAS
2061  591A ED 53 23 50  	LD (BLIT_STRUCT+12), DE
2062  591E              	; ending )
2063  591E CD 57 52     	CALL CHKCHAR
2064  5921 29           	DB ')'
2065  5922
2066  5922 E5           	PUSH HL ; save position in BASIC buffer
2067  5923
2068  5923              	; calculate destination add to value
2069  5923 26 00        	LD H, 0
2070  5925 3A 13 50     	LD A, (BLIT_TMP+0)
2071  5928 6F           	LD L, A
2072  5929 CD 46 51     	CALL HLx8
2073  592C 22 1F 50     	LD (BLIT_STRUCT+8), HL
2074  592F              	; calculate pointer to background location
2075  592F 21 00 00     	LD HL, 0
2076  5932 3A 16 50     	LD A,(BLIT_TMP+3)
2077  5935 B7           	OR A
2078  5936 28 08        	JR Z, .L1
2079  5938 47           	LD B,A
2080  5939 ED 5B 1F 50  	LD DE,(BLIT_STRUCT+8)
2081  593D              .L0:
2082  593D 19           	ADD HL, DE
2083  593E 10 FD        	DJNZ .L0
2084  5940              .L1:
2085  5940 EB           	EX DE,HL
2086  5941 26 00        	LD H,0
2087  5943 3A 15 50     	LD A,(BLIT_TMP+2)
2088  5946 6F           	LD L,A
2089  5947 CD 46 51     	CALL HLx8
2090  594A 19           	ADD HL,DE
2091  594B ED 5B 1D 50  	LD DE,(BLIT_STRUCT+6)
2092  594F 19           	ADD HL,DE
2093  5950 22 1D 50     	LD (BLIT_STRUCT+6),HL
2094  5953
2095  5953 FD 21 5A 59  	LD IY, .RET
2096  5957 C3 0A 52     	JP ENABLE_PAGE0
2097  595A              .RET:
2098  595A FB           	EI
2099  595B              	; set RAM functions to call
2100  595B 21 75 59     	LD HL, .TILECOPY
2101  595E 22 69 58     	LD (TILE.CALL2+1), HL
2102  5961 21 86 59     	LD HL, .SETDESTROW
2103  5964 22 5B 58     	LD (TILE.CALL1+1), HL
2104  5967 DD 21 17 50  	LD IX,BLIT_STRUCT
2105  596B CD 40 58     	CALL TILE
2106  596E
2107  596E D1               POP DE
2108  596F C1               POP BC
2109  5970 CD 81 51         CALL RESTORE_PAGE_INFO
2110  5973
2111  5973 E1           	POP HL
2112  5974 C9           	RET
2113  5975              .TILECOPY:
2114  5975 ED A0       > LDI
2114  5977 ED A0       > LDI
2114  5979 ED A0       > LDI
2114  597B ED A0       > LDI
2114  597D ED A0       > LDI
2114  597F ED A0       > LDI
2114  5981 ED A0       > LDI
2114  5983 ED A0       > LDI
2115  5985 C9           	RET
2116  5986              .SETDESTROW:
2117  5986 ED 5B 13 50  	LD DE, (TILETMP1)
2118  598A C9           	RET
2119  598B              ; *******************************************************************************************************
2120  598B               ENDIF
2121  598B
2122  598B               IFDEF CMDS_WITH_PARAMETERS
2123  598B              ; *******************************************************************************************************
2124  598B              ; function to handle CALL TILEVRM basic extension
2125  598B              ; fills vram with tiles
2126  598B              ; TILEVRM ( INT tile_data_pointer,
2127  598B              ;			INT tile_columns,
2128  598B              ;			INT tile_rows,
2129  598B              ;			INT destination_begin_column,
2130  598B              ;			INT destination_begin_row,
2131  598B              ;			INT number_of_tiles_horizontally,
2132  598B              ;			INT	number_of_tiles_vertically )
2133  598B              ; will put ram in page 0 also, page 1 is already there
2134  598B              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2135  598B              TILEVRM:
2136  598B              	; opening (
2137  598B CD 57 52     	CALL CHKCHAR
2138  598E 28           	DB '('
2139  598F              	; get tile data pointer coordinate
2140  598F DD 21 2F 54  	LD IX, FRMQNT
2141  5993 CD 59 01     	CALL CALBAS
2142  5996 ED 53 17 50  	LD (BLIT_STRUCT+0), DE
2143  599A              	; comma
2144  599A CD 57 52     	CALL CHKCHAR
2145  599D 2C           	DB ','
2146  599E              	; get tile columns
2147  599E DD 21 2F 54  	LD IX, FRMQNT
2148  59A2 CD 59 01     	CALL CALBAS
2149  59A5 ED 53 1B 50  	LD (BLIT_STRUCT+4), DE
2150  59A9              	; comma
2151  59A9 CD 57 52     	CALL CHKCHAR
2152  59AC 2C           	DB ','
2153  59AD              	; get tile columns
2154  59AD DD 21 2F 54  	LD IX, FRMQNT
2155  59B1 CD 59 01     	CALL CALBAS
2156  59B4 ED 53 19 50  	LD (BLIT_STRUCT+2), DE
2157  59B8              	; comma
2158  59B8 CD 57 52     	CALL CHKCHAR
2159  59BB 2C           	DB ','
2160  59BC              	; get destination begin column
2161  59BC DD 21 2F 54  	LD IX, FRMQNT
2162  59C0 CD 59 01     	CALL CALBAS
2163  59C3 7B           	LD A, E
2164  59C4 32 15 50     	LD (BLIT_TMP+2), A
2165  59C7              	; comma
2166  59C7 CD 57 52     	CALL CHKCHAR
2167  59CA 2C           	DB ','
2168  59CB              	; get destination begin row
2169  59CB DD 21 2F 54  	LD IX, FRMQNT
2170  59CF CD 59 01     	CALL CALBAS
2171  59D2 7B           	LD A, E
2172  59D3 32 16 50     	LD (BLIT_TMP+3), A
2173  59D6              	; comma
2174  59D6 CD 57 52     	CALL CHKCHAR
2175  59D9 2C           	DB ','
2176  59DA              	; get number of tiles horizontally
2177  59DA DD 21 2F 54  	LD IX, FRMQNT
2178  59DE CD 59 01     	CALL CALBAS
2179  59E1 ED 53 21 50  	LD (BLIT_STRUCT+10), DE
2180  59E5              	; comma
2181  59E5 CD 57 52     	CALL CHKCHAR
2182  59E8 2C           	DB ','
2183  59E9              	; get number of tiles vertically
2184  59E9 DD 21 2F 54  	LD IX, FRMQNT
2185  59ED CD 59 01     	CALL CALBAS
2186  59F0 ED 53 23 50  	LD (BLIT_STRUCT+12), DE
2187  59F4              	; ending )
2188  59F4 CD 57 52     	CALL CHKCHAR
2189  59F7 29           	DB ')'
2190  59F8
2191  59F8 E5           	PUSH HL ; save position in BASIC buffer
2192  59F9
2193  59F9              	; calculate destination add to value
2194  59F9 21 00 01     	LD HL, 256
2195  59FC 22 1F 50     	LD (BLIT_STRUCT+8), HL
2196  59FF              	; calculate pointer to background location
2197  59FF 3A 16 50     	LD A,(BLIT_TMP+3)
2198  5A02 67           	LD H,A
2199  5A03 2E 00        	LD L,0
2200  5A05 EB           	EX DE,HL
2201  5A06 26 00        	LD H,0
2202  5A08 3A 15 50     	LD A,(BLIT_TMP+2)
2203  5A0B 6F           	LD L,A
2204  5A0C CD 46 51     	CALL HLx8
2205  5A0F 19           	ADD HL,DE
2206  5A10 ED 5B CB F3  	LD DE,(GRPCGP)
2207  5A14 19           	ADD HL,DE
2208  5A15 22 1D 50     	LD (BLIT_STRUCT+6),HL
2209  5A18
2210  5A18 FD 21 1F 5A  	LD IY, .RET
2211  5A1C C3 0A 52     	JP ENABLE_PAGE0
2212  5A1F              .RET:
2213  5A1F FB           	EI
2214  5A20              	; set RAM functions to call
2215  5A20 21 3A 5A     	LD HL, .TILECOPY
2216  5A23 22 69 58     	LD (TILE.CALL2+1), HL
2217  5A26 21 40 5A     	LD HL, .SETDESTROW
2218  5A29 22 5B 58     	LD (TILE.CALL1+1), HL
2219  5A2C DD 21 17 50  	LD IX,BLIT_STRUCT
2220  5A30 CD 40 58     	CALL TILE
2221  5A33
2222  5A33 D1               POP DE
2223  5A34 C1               POP BC
2224  5A35 CD 81 51         CALL RESTORE_PAGE_INFO
2225  5A38
2226  5A38 E1           	POP HL
2227  5A39 C9           	RET
2228  5A3A              .TILECOPY:
2229  5A3A 01 98 08     	LD BC, #0898
2230  5A3D C3 40 51     	JP BBYTECOPY
2231  5A40              .SETDESTROW:
2232  5A40 2A 13 50     	LD HL, (TILETMP1)
2233  5A43 F3           	DI
2234  5A44 CD 35 51     	CALL SETWRT_LOCAL
2235  5A47 FB           	EI
2236  5A48 C9           	RET
2237  5A49              ; *******************************************************************************************************
2238  5A49               ENDIF
2239  5A49
2240  5A49               IFNDEF CMDS_WITH_PARAMETERS
2241  5A49 ~            ; *******************************************************************************************************
2242  5A49 ~            ; function to handle CALL TILEVRM basic extension
2243  5A49 ~            ; fills vram with tiles
2244  5A49 ~            ; TILEVRM ( INT request_data_ptr )
2245  5A49 ~            ; request_data_ptr described in TILE
2246  5A49 ~            ; will put ram in page 0 also, page 1 is already there
2247  5A49 ~            TILEVRM:
2248  5A49 ~            	; opening (
2249  5A49 ~            	CALL CHKCHAR
2250  5A49 ~            	DB '('
2251  5A49 ~            	; get pointer to request struct
2252  5A49 ~            	LD IX, FRMQNT
2253  5A49 ~            	CALL CALBAS
2254  5A49 ~            	PUSH DE
2255  5A49 ~            	; ending )
2256  5A49 ~            	CALL CHKCHAR
2257  5A49 ~            	DB ')'
2258  5A49 ~
2259  5A49 ~            	POP IX ; pointer to request struct
2260  5A49 ~
2261  5A49 ~            	PUSH HL ; save position in BASIC buffer
2262  5A49 ~
2263  5A49 ~            	LD IY, .RET
2264  5A49 ~            	JP ENABLE_PAGE0
2265  5A49 ~            .RET:
2266  5A49 ~            	EI
2267  5A49 ~            	; set RAM functions to call
2268  5A49 ~            	LD HL, .TILECOPY
2269  5A49 ~            	LD (TILE.CALL2+1), HL
2270  5A49 ~            	LD HL, .SETDESTROW
2271  5A49 ~            	LD (TILE.CALL1+1), HL
2272  5A49 ~            	CALL TILE
2273  5A49 ~
2274  5A49 ~                POP DE
2275  5A49 ~                POP BC
2276  5A49 ~                CALL RESTORE_PAGE_INFO
2277  5A49 ~
2278  5A49 ~            	POP HL
2279  5A49 ~            	RET
2280  5A49 ~            .TILECOPY:
2281  5A49 ~            	LD BC, #0898
2282  5A49 ~            	JP BBYTECOPY
2283  5A49 ~            .SETDESTROW:
2284  5A49 ~            	LD HL, (TILETMP1)
2285  5A49 ~            	DI
2286  5A49 ~            	CALL SETWRT_LOCAL
2287  5A49 ~            	EI
2288  5A49 ~            	RET
2289  5A49 ~            ; *******************************************************************************************************
2290  5A49               ENDIF
2291  5A49               ENDIF
2292  5A49
2293  5A49               IF (BOX_CMDS == 1)
2294  5A49              ; *******************************************************************************************************
2295  5A49              ; generic function to implement rectangle data copy
2296  5A49              ; should be modified to call appropriate function for memory or vram
2297  5A49              ; input IX=pointer to following structure
2298  5A49              ; +00 source data pointer
2299  5A49              ; +02 num bytes in a row
2300  5A49              ; +04 number of rows
2301  5A49              ; +06 source add-to value till next row
2302  5A49              ; +08 destination address
2303  5A49              ; +10 destination add-to value till next row
2304  5A49              ; modifies AF, BC, DE, HL
2305  5A49              RECTANGLE_COPY:
2306  5A49 DD 6E 00     	LD L, (IX+0)
2307  5A4C DD 66 01     	LD H, (IX+1) ; source address
2308  5A4F DD 5E 08     	LD E, (IX+8)
2309  5A52 DD 56 09     	LD D, (IX+9) ; destination
2310  5A55 DD 46 04     	LD B, (IX+4) ; row number
2311  5A58              .L1:
2312  5A58 C5           	PUSH BC
2313  5A59 E5           		PUSH HL
2314  5A5A D5           			PUSH DE
2315  5A5B DD 4E 02     				LD C, (IX+2)
2316  5A5E DD 46 03     				LD B, (IX+3) ; num bytes in a row
2317  5A61              .CALL1:
2318  5A61 CD 00 00     				CALL 0 ; set destination address from DE
2319  5A64              .CALL2:
2320  5A64 CD 00 00     				CALL 0 ; copy data fn
2321  5A67 E1           			POP HL
2322  5A68 DD 4E 0A     			LD C, (IX+10)
2323  5A6B DD 46 0B     			LD B, (IX+11) ; destination add-to
2324  5A6E 09           			ADD HL, BC
2325  5A6F EB           			EX DE, HL
2326  5A70 E1           		POP HL
2327  5A71 DD 4E 06     		LD C, (IX+6)
2328  5A74 DD 46 07     		LD B, (IX+7) ; src add-to
2329  5A77 09           		ADD HL, BC
2330  5A78 C1           	POP BC
2331  5A79 10 DD        	DJNZ .L1
2332  5A7B C9           	RET
2333  5A7C              ; *******************************************************************************************************
2334  5A7C
2335  5A7C              ; *******************************************************************************************************
2336  5A7C              ; function to handle CALL BOXMEMCPY basic extension
2337  5A7C              ; copies data with window like boundaries to ram
2338  5A7C              ; BOXMEMCPY ( INT request_data_ptr )
2339  5A7C              ; request_data_ptr described in RECTANGLE_COPY
2340  5A7C              ; will put ram in page 0 also, page 1 is already there
2341  5A7C              BOXMEMCPY:
2342  5A7C              	; opening (
2343  5A7C CD 57 52     	CALL CHKCHAR
2344  5A7F 28           	DB '('
2345  5A80              	; get pointer to request struct
2346  5A80 DD 21 2F 54  	LD IX, FRMQNT
2347  5A84 CD 59 01     	CALL CALBAS
2348  5A87 D5           	PUSH DE
2349  5A88              	; ending )
2350  5A88 CD 57 52     	CALL CHKCHAR
2351  5A8B 29           	DB ')'
2352  5A8C
2353  5A8C DD E1        	POP IX ; pointer to request struct
2354  5A8E
2355  5A8E E5           	PUSH HL ; save position in BASIC buffer
2356  5A8F
2357  5A8F FD 21 96 5A  	LD IY, .RET
2358  5A93 C3 0A 52     	JP ENABLE_PAGE0
2359  5A96              .RET:
2360  5A96 FB           	EI
2361  5A97              	; set RAM functions to call
2362  5A97 21 00 00     	LD HL, 0
2363  5A9A 22 61 5A     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2364  5A9D 22 63 5A     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2365  5AA0 21 ED B0     	LD HL, #B0ED ; LDIR
2366  5AA3 22 65 5A     	LD (RECTANGLE_COPY.CALL1+4), HL
2367  5AA6 CD 49 5A     	CALL RECTANGLE_COPY
2368  5AA9
2369  5AA9 D1               POP DE
2370  5AAA C1               POP BC
2371  5AAB CD 81 51         CALL RESTORE_PAGE_INFO
2372  5AAE
2373  5AAE E1           	POP HL
2374  5AAF C9           	RET
2375  5AB0              ; *******************************************************************************************************
2376  5AB0
2377  5AB0              ; *******************************************************************************************************
2378  5AB0              ; function to handle CALL BOXMEMVRM basic extension
2379  5AB0              ; copies data with window like boundaries to ram
2380  5AB0              ; BOXMEMVRM ( INT request_data_ptr )
2381  5AB0              ; request_data_ptr described in RECTANGLE_COPY
2382  5AB0              ; will put ram in page 0 also, page 1 is already there
2383  5AB0              BOXMEMVRM:
2384  5AB0              	; opening (
2385  5AB0 CD 57 52     	CALL CHKCHAR
2386  5AB3 28           	DB '('
2387  5AB4              	; get pointer to request struct
2388  5AB4 DD 21 2F 54  	LD IX, FRMQNT
2389  5AB8 CD 59 01     	CALL CALBAS
2390  5ABB D5           	PUSH DE
2391  5ABC              	; ending )
2392  5ABC CD 57 52     	CALL CHKCHAR
2393  5ABF 29           	DB ')'
2394  5AC0
2395  5AC0 DD E1        	POP IX ; pointer to request struct
2396  5AC2
2397  5AC2 E5           	PUSH HL ; save position in BASIC buffer
2398  5AC3
2399  5AC3 FD 21 CA 5A  	LD IY, .RET
2400  5AC7 C3 0A 52     	JP ENABLE_PAGE0
2401  5ACA              .RET:
2402  5ACA FB           	EI
2403  5ACB              	; set RAM functions to call
2404  5ACB 21 E9 5A     	LD HL, .SETDEST
2405  5ACE 22 62 5A     	LD (RECTANGLE_COPY.CALL1+1), HL
2406  5AD1 21 F1 5A     	LD HL, .COPYDATA
2407  5AD4 22 65 5A     	LD (RECTANGLE_COPY.CALL2+1), HL
2408  5AD7 3E CD        	LD A, #CD ; CALL
2409  5AD9 32 61 5A     	LD (RECTANGLE_COPY.CALL1), A
2410  5ADC 32 64 5A     	LD (RECTANGLE_COPY.CALL2), A
2411  5ADF CD 49 5A     	CALL RECTANGLE_COPY
2412  5AE2
2413  5AE2 D1               POP DE
2414  5AE3 C1               POP BC
2415  5AE4 CD 81 51         CALL RESTORE_PAGE_INFO
2416  5AE7
2417  5AE7 E1           	POP HL
2418  5AE8 C9           	RET
2419  5AE9              .SETDEST:
2420  5AE9 EB           	EX DE, HL
2421  5AEA F3           	DI
2422  5AEB CD 35 51     	CALL SETWRT_LOCAL
2423  5AEE FB           	EI
2424  5AEF EB           	EX DE, HL
2425  5AF0 C9           	RET
2426  5AF1              .COPYDATA:
2427  5AF1 41           	LD B, C
2428  5AF2 0E 98        	LD C, #98
2429  5AF4 C3 40 51     	JP BBYTECOPY
2430  5AF7              ; *******************************************************************************************************
2431  5AF7               ENDIF
2432  5AF7
2433  5AF7              EXT_END:
2434  5AF7
# file closed: asm\main.asm
