# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              SYNCHR		EQU		#558C
  33  4000              VALTYP  	EQU     #F663
  34  4000              USR     	EQU     #F7F8
  35  4000              PROCNM		EQU		#FD89
  36  4000              BIOS_FILVRM EQU     #0056
  37  4000              CLIKSW		EQU		#F3DB
  38  4000              ATRBAS		EQU		#F928
  39  4000              GRPCGP		EQU		#F3CB
  40  4000
  41  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  42  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  43  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  44  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  45  4000              EXPTBL	EQU #FCC1
  46  4000              SCRMOD	EQU #FCAF ; current screen mode
  47  4000              REG1SAV EQU #F3E0 ; VDP(1)
  48  4000
  49  4000              ; BASIC error codes
  50  4000              ;01 NEXT without FOR
  51  4000              ;02 Syntax error
  52  4000              ;03 RETURN without GOSUB
  53  4000              ;04 Out of DATA
  54  4000              ;05 Illegal function call
  55  4000              ;06 Overflow
  56  4000              ;07 Out of memory
  57  4000              ;08 Undefined line number
  58  4000              ;09 Subscript out of range
  59  4000              ;10 Redimensioned array
  60  4000              ;11 Division by zero
  61  4000              ;12 Illegal direct
  62  4000              ;13 Type mismatch
  63  4000              ;14 Out of string space
  64  4000              ;15 String too long
  65  4000              ;16 String formula too complex
  66  4000              ;17 Can't CONTINUE
  67  4000              ;18 Undefined user function
  68  4000              ;19 Device I/O error
  69  4000              ;20 Verify error
  70  4000              ;21 No RESUME
  71  4000              ;22 RESUME without error
  72  4000              ;23 Unprintable error
  73  4000              ;24 Missing operand
  74  4000              ;25 Line buffer overflow
  75  4000              ;50 FIELD overflow
  76  4000              ;51 Internal error
  77  4000              ;52 Bad file number
  78  4000              ;53 File not found
  79  4000              ;54 File already open
  80  4000              ;55 Input past end
  81  4000              ;56 Bad file name
  82  4000              ;57 Direct statement in file
  83  4000              ;58 Sequential I/O only
  84  4000              ;59 File not OPEN
  85  4000
  86  4000
  87  4000               ; simulate cartridge with BASIC extension
  88  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  88  4004 63 53 00 00
  88  4008 00 00 00 00
  88  400C 00 00 00 00
  89  4010
  90  4010              ; this location #4010 stores last location used by basic extension
  91  4010              ; free memory after that point
  92  4010              FREEMEMPTR:
  93  4010 40 5C         DW EXT_END
  94  4012
  95  4012              ; this location #4012 stores extension version in DAA format
  96  4012              ; first byte is major version and second minor
  97  4012              VERSION:
  98  4012 00 70         DB #00, #70
  99  4014
 100  4014              ; binary included AKG player compiled at #4014
 101  4014               IF (SOUND_CMDS == 1)
 102  4014              	INCBIN "bin/AKG.bin"
 103  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 104  4CF0               ENDIF
 105  4CF0
 106  4CF0              ORIG.HTIMI:
 107  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 107  4CF4 00
 108  4CF5               EXPORT ORIG.HTIMI
 109  4CF5
 110  4CF5               IF (SOUND_CMDS == 1)
 111  4CF5              MUSIC_INIT_STATUS:
 112  4CF5 00            DB 0
 113  4CF6              SFX_INIT_STATUS:
 114  4CF6 00            DB 0
 115  4CF7              SOUND_ENABLED:
 116  4CF7 00            DB 0
 117  4CF8               ENDIF
 118  4CF8
 119  4CF8               IF (SPRITE_CMDS == 1)
 120  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 7D 52     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD A0 53     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD A0 53     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD A0 53     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD A0 53     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 B8 53     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 B8 53     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 B8 53     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD A0 53     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD A0 53     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD A0 53     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD A0 53     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD A0 53     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD A0 53     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 B8 53     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 B8 53     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD A0 53     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD A0 53     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD A0 53     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD A0 53     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD A0 53     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 93 52         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD DA 52         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD CA 52         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 121  4F4D               ENDIF
 122  4F4D
 123  4F4D               IF (ANIM_CMDS == 1)
 124  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E 40 5C         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 40 5C         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 40 5C         DW EXT_END
  18+ 4F56
  19+ 4F56              ; ANIMATION ITEM
  20+ 4F56              ; byte type = [0 - pattern and color change
  21+ 4F56              ;              1 - pattern definition change ]
  22+ 4F56              ; word ticks - number of ticks to hold this state
  23+ 4F56              ; for type = 0
  24+ 4F56              ;   byte pattern;
  25+ 4F56              ;   byte color;
  26+ 4F56              ; for type = 1
  27+ 4F56              ;   work data_pointer;
  28+ 4F56              ; total size = 5b
  29+ 4F56
  30+ 4F56              ; *******************************************************************************************************
  31+ 4F56              ; helper function HL=A*5
  32+ 4F56              ; changes HL,DE;
  33+ 4F56              Ax5:
  34+ 4F56 26 00            LD H,0
  35+ 4F58 6F               LD L,A
  36+ 4F59 54               LD D,H
  37+ 4F5A 5D               LD E,L
  38+ 4F5B 29               ADD HL,HL
  39+ 4F5C 29               ADD HL,HL
  40+ 4F5D 19               ADD HL,DE
  41+ 4F5E C9               RET
  42+ 4F5F              ; *******************************************************************************************************
  43+ 4F5F
  44+ 4F5F              ; *******************************************************************************************************
  45+ 4F5F              ; function to handle CALL MAXANIMITEMS basic extension
  46+ 4F5F              ; MAXANIMITEMS (BYTE number)
  47+ 4F5F              ; sets new number and moves memory buffers as needed
  48+ 4F5F              MAXANIMITEMS:
  49+ 4F5F              	; opening (
  50+ 4F5F CD A0 53     	CALL CHKCHAR
  51+ 4F62 28           	DB '('
  52+ 4F63              	; get value
  53+ 4F63 DD 21 1C 52  	LD IX, GETBYT
  54+ 4F67 CD 59 01     	CALL CALBAS
  55+ 4F6A F5               PUSH AF
  56+ 4F6B              	; ending )
  57+ 4F6B CD A0 53     	CALL CHKCHAR
  58+ 4F6E 29           	DB ')'
  59+ 4F6F F1               POP AF
  60+ 4F70
  61+ 4F70              	; save position
  62+ 4F70 E5           	PUSH HL
  63+ 4F71              .ENTRY:
  64+ 4F71 47               LD B,A
  65+ 4F72 3A 4D 4F         LD A,(ANIMITEMNUM)
  66+ 4F75 90               SUB B
  67+ 4F76 28 23            JR Z, .EXIT; same value as before
  68+ 4F78 DD 21 4E 4F      LD IX,ANIMITEMPTR
  69+ 4F7C FD 21 51 4F      LD IY,ANIMDEFPTR
  70+ 4F80 FA 9E 4F         JP M, .INCREASE
  71+ 4F83                  ; new value is lower than previous one
  72+ 4F83 CD B6 4F         CALL .SIZEDIFF
  73+ 4F86 CD D1 4F         CALL .DECREASE_COMMON
  74+ 4F89 2A 54 4F         LD HL,(ANIMSPRPTR)
  75+ 4F8C AF               XOR A
  76+ 4F8D ED 42            SBC HL,BC
  77+ 4F8F 22 54 4F         LD (ANIMSPRPTR),HL
  78+ 4F92              .E1:
  79+ 4F92 2A 10 40         LD HL,(FREEMEMPTR)
  80+ 4F95 AF               XOR A
  81+ 4F96 ED 42            SBC HL,BC
  82+ 4F98 22 10 40         LD (FREEMEMPTR),HL
  83+ 4F9B              .EXIT:
  84+ 4F9B FB               EI
  85+ 4F9C E1           	POP HL
  86+ 4F9D C9           	RET
  87+ 4F9E              .INCREASE:
  88+ 4F9E ED 44            NEG
  89+ 4FA0 CD B6 4F         CALL .SIZEDIFF
  90+ 4FA3 CD FD 4F         CALL .INCREASE_COMMON
  91+ 4FA6 2A 54 4F         LD HL,(ANIMSPRPTR)
  92+ 4FA9 09               ADD HL,BC
  93+ 4FAA 22 54 4F         LD (ANIMSPRPTR),HL
  94+ 4FAD              .E2:
  95+ 4FAD 2A 10 40         LD HL,(FREEMEMPTR)
  96+ 4FB0 09               ADD HL,BC
  97+ 4FB1 22 10 40         LD (FREEMEMPTR),HL
  98+ 4FB4 18 E5            JR .EXIT
  99+ 4FB6              .SIZEDIFF:
 100+ 4FB6 CD 56 4F         CALL Ax5
 101+ 4FB9 78               LD A,B
 102+ 4FBA 32 4D 4F         LD (ANIMITEMNUM),A
 103+ 4FBD 44               LD B,H
 104+ 4FBE 4D               LD C,L
 105+ 4FBF C9               RET ; BC=size difference in bytes
 106+ 4FC0              .SIZETOMOVE:
 107+ 4FC0 D5               PUSH DE
 108+ 4FC1 2A 10 40         LD HL,(FREEMEMPTR)
 109+ 4FC4 FD 5E 00         LD E,(IY)
 110+ 4FC7 FD 56 01         LD D,(IY+1)
 111+ 4FCA AF               XOR A
 112+ 4FCB ED 52            SBC HL,DE
 113+ 4FCD 44               LD B,H
 114+ 4FCE 4D               LD C,L
 115+ 4FCF D1               POP DE
 116+ 4FD0 C9               RET
 117+ 4FD1              .DECREASE_COMMON:
 118+ 4FD1 FD 6E 00         LD L,(IY)
 119+ 4FD4 FD 66 01         LD H,(IY+1)
 120+ 4FD7 AF               XOR A
 121+ 4FD8 ED 42            SBC HL,BC
 122+ 4FDA EB               EX DE,HL
 123+ 4FDB C5               PUSH BC
 124+ 4FDC CD C0 4F         CALL .SIZETOMOVE
 125+ 4FDF F3               DI
 126+ 4FE0 78               LD A,B
 127+ 4FE1 B1               OR C
 128+ 4FE2 28 08            JR Z,.L1
 129+ 4FE4 FD 6E 00         LD L,(IY)
 130+ 4FE7 FD 66 01         LD H,(IY+1)
 131+ 4FEA                  ;LD (IX),E
 132+ 4FEA                  ;LD (IX+1),D
 133+ 4FEA ED B0            LDIR
 134+ 4FEC              .L1:
 135+ 4FEC C1               POP BC
 136+ 4FED FD 6E 00         LD L,(IY)
 137+ 4FF0 FD 66 01         LD H,(IY+1)
 138+ 4FF3 AF               XOR A
 139+ 4FF4 ED 42            SBC HL,BC
 140+ 4FF6 FD 75 00         LD (IY),L
 141+ 4FF9 FD 74 01         LD (IY+1),H
 142+ 4FFC C9               RET
 143+ 4FFD              .INCREASE_COMMON:
 144+ 4FFD 2A 10 40         LD HL,(FREEMEMPTR)
 145+ 5000 2B               DEC HL
 146+ 5001 AF               XOR A
 147+ 5002 ED 42            SBC HL,BC
 148+ 5004 EB               EX DE,HL
 149+ 5005 C5               PUSH BC
 150+ 5006 CD C0 4F         CALL .SIZETOMOVE
 151+ 5009 F3               DI
 152+ 500A 78               LD A,B
 153+ 500B B1               OR C
 154+ 500C 28 06            JR Z,.L2
 155+ 500E 2A 10 40         LD HL,(FREEMEMPTR)
 156+ 5011 2B               DEC HL
 157+ 5012 ED B8            LDDR
 158+ 5014              .L2:
 159+ 5014 C1               POP BC
 160+ 5015 FD 6E 00         LD L,(IY)
 161+ 5018 FD 66 01         LD H,(IY+1)
 162+ 501B 09               ADD HL,BC
 163+ 501C FD 75 00         LD (IY),L
 164+ 501F FD 74 01         LD (IY+1),H
 165+ 5022 C9               RET
 166+ 5023              ; *******************************************************************************************************
 167+ 5023
 168+ 5023              ; *******************************************************************************************************
 169+ 5023              ; function to handle CALL ANIMITEMPAT basic extension
 170+ 5023              ; ANIMITEMPAT ( BYTE id,
 171+ 5023              ;               INT ticks,
 172+ 5023              ;               BYTE pattern,
 173+ 5023              ;               BYTE color )
 174+ 5023              ; fills animation item data, returns an error if out of bounds
 175+ 5023              ANIMITEMPAT:
 176+ 5023                  ; opening (
 177+ 5023 CD A0 53     	CALL CHKCHAR
 178+ 5026 28           	DB '('
 179+ 5027              	; get id
 180+ 5027 DD 21 1C 52  	LD IX, GETBYT
 181+ 502B CD 59 01     	CALL CALBAS
 182+ 502E F5               PUSH AF
 183+ 502F                  ; check if out of bounds
 184+ 502F 3C               INC A
 185+ 5030 4F               LD C,A
 186+ 5031 3A 4D 4F         LD A,(ANIMITEMNUM)
 187+ 5034 B9               CP C
 188+ 5035 30 05            JR NC, .L1
 189+ 5037 1E 09            LD E,9 ; subscript out of range
 190+ 5039 C3 B8 53         JP THROW_ERROR
 191+ 503C              .L1:
 192+ 503C              	; comma
 193+ 503C CD A0 53     	CALL CHKCHAR
 194+ 503F 2C           	DB ','
 195+ 5040              	; get ticks
 196+ 5040 DD 21 2F 54  	LD IX, FRMQNT
 197+ 5044 CD 59 01     	CALL CALBAS
 198+ 5047 D5           	PUSH DE
 199+ 5048              	; comma
 200+ 5048 CD A0 53     	CALL CHKCHAR
 201+ 504B 2C           	DB ','
 202+ 504C              	; get pattern
 203+ 504C DD 21 1C 52  	LD IX, GETBYT
 204+ 5050 CD 59 01     	CALL CALBAS
 205+ 5053 F5               PUSH AF
 206+ 5054              	; comma
 207+ 5054 CD A0 53     	CALL CHKCHAR
 208+ 5057 2C           	DB ','
 209+ 5058              	; get color
 210+ 5058 DD 21 1C 52  	LD IX, GETBYT
 211+ 505C CD 59 01     	CALL CALBAS
 212+ 505F F5               PUSH AF
 213+ 5060              	; ending )
 214+ 5060 CD A0 53     	CALL CHKCHAR
 215+ 5063 29           	DB ')'
 216+ 5064              .ENTRY:
 217+ 5064 E5               PUSH HL
 218+ 5065 DD E1            POP IX
 219+ 5067 D9               EXX
 220+ 5068 C1               POP BC ; color
 221+ 5069 D1               POP DE ; pattern
 222+ 506A E1               POP HL ; ticks
 223+ 506B D9               EXX
 224+ 506C F1               POP AF
 225+ 506D CD 56 4F         CALL Ax5
 226+ 5070 ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 227+ 5074 19               ADD HL,DE
 228+ 5075 E5               PUSH HL
 229+ 5076 FD E1            POP IY
 230+ 5078 D9               EXX
 231+ 5079 FD 36 00 00      LD (IY),0 ; type=0
 232+ 507D FD 75 01         LD (IY+1),L
 233+ 5080 FD 74 02         LD (IY+2),H
 234+ 5083 FD 72 03         LD (IY+3),D
 235+ 5086 FD 70 04         LD (IY+4),B
 236+ 5089
 237+ 5089 DD E5            PUSH IX
 238+ 508B E1               POP HL
 239+ 508C C9               RET
 240+ 508D              ; *******************************************************************************************************
 241+ 508D
 242+ 508D              ; *******************************************************************************************************
 243+ 508D              ; function to handle CALL ANIMITEMPTR basic extension
 244+ 508D              ; ANIMITEMPTR ( BYTE id,
 245+ 508D              ;               INT ticks,
 246+ 508D              ;               INT pointer,
 247+ 508D              ; fills animation item data, returns an error if out of bounds
 248+ 508D              ANIMITEMPTR_CMD:
 249+ 508D                  ; opening (
 250+ 508D CD A0 53     	CALL CHKCHAR
 251+ 5090 28           	DB '('
 252+ 5091              	; get id
 253+ 5091 DD 21 1C 52  	LD IX, GETBYT
 254+ 5095 CD 59 01     	CALL CALBAS
 255+ 5098 F5               PUSH AF
 256+ 5099                  ; check if out of bounds
 257+ 5099 3C               INC A
 258+ 509A 4F               LD C,A
 259+ 509B 3A 4D 4F         LD A,(ANIMITEMNUM)
 260+ 509E B9               CP C
 261+ 509F 30 05            JR NC, .L1
 262+ 50A1 1E 09            LD E,9 ; subscript out of range
 263+ 50A3 C3 B8 53         JP THROW_ERROR
 264+ 50A6              .L1:
 265+ 50A6              	; comma
 266+ 50A6 CD A0 53     	CALL CHKCHAR
 267+ 50A9 2C           	DB ','
 268+ 50AA              	; get ticks
 269+ 50AA DD 21 2F 54  	LD IX, FRMQNT
 270+ 50AE CD 59 01     	CALL CALBAS
 271+ 50B1 D5           	PUSH DE
 272+ 50B2              	; comma
 273+ 50B2 CD A0 53     	CALL CHKCHAR
 274+ 50B5 2C           	DB ','
 275+ 50B6              	; get pointer
 276+ 50B6 DD 21 2F 54  	LD IX, FRMQNT
 277+ 50BA CD 59 01     	CALL CALBAS
 278+ 50BD D5           	PUSH DE
 279+ 50BE              	; ending )
 280+ 50BE CD A0 53     	CALL CHKCHAR
 281+ 50C1 29           	DB ')'
 282+ 50C2              .ENTRY:
 283+ 50C2 E5               PUSH HL
 284+ 50C3 DD E1            POP IX
 285+ 50C5 D9               EXX
 286+ 50C6 D1               POP DE ; pointer
 287+ 50C7 E1               POP HL ; ticks
 288+ 50C8 D9               EXX
 289+ 50C9 F1               POP AF
 290+ 50CA CD 56 4F         CALL Ax5
 291+ 50CD ED 5B 4E 4F      LD DE,(ANIMITEMPTR)
 292+ 50D1 19               ADD HL,DE
 293+ 50D2 E5               PUSH HL
 294+ 50D3 FD E1            POP IY
 295+ 50D5 D9               EXX
 296+ 50D6 FD 36 00 01      LD (IY),1 ; type=1
 297+ 50DA FD 75 01         LD (IY+1),L
 298+ 50DD FD 74 02         LD (IY+2),H
 299+ 50E0 FD 73 03         LD (IY+3),E
 300+ 50E3 FD 72 04         LD (IY+4),D
 301+ 50E6
 302+ 50E6 DD E5            PUSH IX
 303+ 50E8 E1               POP HL
 304+ 50E9 C9               RET
 305+ 50EA              ; *******************************************************************************************************
 306+ 50EA
 307+ 50EA              ; *******************************************************************************************************
 308+ 50EA              ; function to handle CALL MAXANIMDEFS basic extension
 309+ 50EA              ; MAXANIMDEFS (BYTE number)
 310+ 50EA              ; sets new number and moves memory buffers as needed
 311+ 50EA              MAXANIMDEFS:
 312+ 50EA              	; opening (
 313+ 50EA CD A0 53     	CALL CHKCHAR
 314+ 50ED 28           	DB '('
 315+ 50EE              	; get value
 316+ 50EE DD 21 1C 52  	LD IX, GETBYT
 317+ 50F2 CD 59 01     	CALL CALBAS
 318+ 50F5 F5               PUSH AF
 319+ 50F6              	; ending )
 320+ 50F6 CD A0 53     	CALL CHKCHAR
 321+ 50F9 29           	DB ')'
 322+ 50FA F1               POP AF
 323+ 50FB
 324+ 50FB              	; save position
 325+ 50FB E5           	PUSH HL
 326+ 50FC              .ENTRY:
 327+ 50FC 47               LD B,A
 328+ 50FD 3A 50 4F         LD A,(ANIMDEFNUM)
 329+ 5100 90               SUB B
 330+ 5101 CA 9B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 331+ 5104 DD 21 51 4F      LD IX,ANIMDEFPTR
 332+ 5108 FD 21 54 4F      LD IY,ANIMSPRPTR
 333+ 510C FA 18 51         JP M, .INCREASE
 334+ 510F                  ; new value is lower than previous one
 335+ 510F CD 23 51         CALL .SIZEDIFF
 336+ 5112 CD D1 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 337+ 5115 C3 92 4F         JP MAXANIMITEMS.E1
 338+ 5118              .INCREASE:
 339+ 5118 ED 44            NEG
 340+ 511A CD 23 51         CALL .SIZEDIFF
 341+ 511D CD FD 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 342+ 5120 C3 AD 4F         JP MAXANIMITEMS.E2
 343+ 5123              .SIZEDIFF:
 344+ 5123 26 00            LD H,0
 345+ 5125 6F               LD L,A
 346+ 5126 CD 8E 52         CALL HLx16
 347+ 5129 78               LD A,B
 348+ 512A 32 50 4F         LD (ANIMDEFNUM),A
 349+ 512D 44               LD B,H
 350+ 512E 4D               LD C,L
 351+ 512F C9               RET ; BC=size difference in bytes
 352+ 5130              ; *******************************************************************************************************
 353+ 5130
# file closed: asm\ANIMATION.asm
 125  5130               ENDIF
 126  5130
 127  5130              ; temp variables for BLIT, TILE functions
 128  5130               IF (BLIT_CMDS + TILE_CMDS > 0)
 129  5130              BLIT_TMP:
 130  5130              TILETMP1:
 131  5130              BLIT_TMP1:
 132  5130 00 00         DW 0
 133  5132              TILETMP2:
 134  5132              BLIT_TMP2:
 135  5132 00 00         DW 0
 136  5134                IFDEF CMDS_WITH_PARAMETERS
 137  5134              BLIT_STRUCT:
 138  5134 00 00 00...   DS 17
 139  5138                ENDIF
 140  5138               ENDIF
 141  5145
 142  5145              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 143  5145              ; per starting letter, if no commands with this letter, NULL value
 144  5145              CMDS:
 145  5145               IF (ANIM_CMDS == 1)
 146  5145 60 52        	DW CMDS_A ;
 147  5147               ELSE
 148  5147 ~                DW 0 ; A
 149  5147               ENDIF
 150  5147               IF (BLIT_CMDS + BOX_CMDS > 0)
 151  5147 2B 52            DW CMDS_B ; B
 152  5149               ELSE
 153  5149 ~            	DW 0
 154  5149               ENDIF
 155  5149 00 00            DW 0 ; C
 156  514B 00 00            DW 0 ; D
 157  514D 00 00            DW 0 ; E
 158  514F               IF (VRAM_CMDS + RAM_CMDS > 0)
 159  514F A9 51            DW CMDS_F; F
 160  5151               ELSE
 161  5151 ~            	DW 0
 162  5151               ENDIF
 163  5151               IF (GENCAL_CMD > 0)
 164  5151 BC 51            DW CMDS_G; G
 165  5153               ELSE
 166  5153 ~            	DW 0
 167  5153               ENDIF
 168  5153 00 00            DW 0 ; H
 169  5155 00 00            DW 0 ; I
 170  5157 00 00            DW 0 ; J
 171  5159 00 00            DW 0 ; K
 172  515B 00 00            DW 0 ; L
 173  515D               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 174  515D 79 51            DW CMDS_M ; M
 175  515F               ELSE
 176  515F ~            	DW 0
 177  515F               ENDIF
 178  515F 00 00            DW 0 ; N
 179  5161 00 00            DW 0 ; O
 180  5163 00 00            DW 0 ; P
 181  5165 00 00            DW 0 ; Q
 182  5167 00 00            DW 0 ; R
 183  5169               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 184  5169 D0 51            DW CMDS_S ; S
 185  516B               ELSE
 186  516B ~            	DW 0
 187  516B               ENDIF
 188  516B               IF (TILE_CMDS > 0)
 189  516B 4B 52            DW CMDS_T ; T
 190  516D               ELSE
 191  516D ~            	DW 0
 192  516D               ENDIF
 193  516D 00 00            DW 0 ; U
 194  516F               IF (VRAM_CMDS > 0)
 195  516F C6 51            DW CMDS_V ; V
 196  5171               ELSE
 197  5171 ~            	DW 0
 198  5171               ENDIF
 199  5171 00 00            DW 0 ; W
 200  5173 00 00            DW 0 ; X
 201  5175 00 00            DW 0 ; Y
 202  5177 00 00            DW 0 ; Z
 203  5179
 204  5179              CMDS_M:
 205  5179               IF (VRAM_CMDS == 1)
 206  5179 4D 45 4D 56      DB "MEMVRM", 0
 206  517D 52 4D 00
 207  5180 00 55            DW MEMVRM
 208  5182               ENDIF
 209  5182               IF (RAM_CMDS == 1)
 210  5182 4D 45 4D 43  	DB "MEMCPY", 0
 210  5186 50 59 00
 211  5189 BF 53        	DW MEMCPY
 212  518B               ENDIF
 213  518B               IF (ANIM_CMDS == 1)
 214  518B 4D 41 58 41  	DB "MAXANIMITEMS",0
 214  518F 4E 49 4D 49
 214  5193 54 45 4D 53
 214  5197 00
 215  5198 5F 4F        	DW MAXANIMITEMS
 216  519A 4D 41 58 41  	DB "MAXANIMDEFS",0
 216  519E 4E 49 4D 44
 216  51A2 45 46 53 00
 217  51A6 EA 50        	DW MAXANIMDEFS
 218  51A8               ENDIF
 219  51A8               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 220  51A8 00           	DB 0
 221  51A9               ENDIF
 222  51A9              CMDS_F:
 223  51A9               IF (VRAM_CMDS == 1)
 224  51A9 46 49 4C 56      DB "FILVRM", 0
 224  51AD 52 4D 00
 225  51B0 02 54            DW FILVRM
 226  51B2               ENDIF
 227  51B2               IF (RAM_CMDS == 1)
 228  51B2 46 49 4C 52      DB "FILRAM", 0
 228  51B6 41 4D 00
 229  51B9 49 54            DW FILRAM
 230  51BB               ENDIF
 231  51BB               IF (VRAM_CMDS + RAM_CMDS > 0)
 232  51BB 00               DB 0
 233  51BC               ENDIF
 234  51BC              CMDS_G:
 235  51BC               IF (GENCAL_CMD == 1)
 236  51BC 47 45 4E 43      DB "GENCAL", 0
 236  51C0 41 4C 00
 237  51C3 A7 54            DW GENCAL
 238  51C5               ENDIF
 239  51C5               IF (GENCAL_CMD > 0)
 240  51C5 00           	DB	0
 241  51C6               ENDIF
 242  51C6              CMDS_V:
 243  51C6               IF (VRAM_CMDS == 1)
 244  51C6 56 52 4D 4D  	DB "VRMMEM", 0
 244  51CA 45 4D 00
 245  51CD 78 55        	DW VRMMEM
 246  51CF               ENDIF
 247  51CF               IF (VRAM_CMDS > 0)
 248  51CF 00           	DB 0
 249  51D0               ENDIF
 250  51D0              CMDS_S:
 251  51D0               IF (SPRITE_CMDS == 1)
 252  51D0 53 50 52 53  	DB "SPRSET", 0
 252  51D4 45 54 00
 253  51D7 0E 4E        	DW SPRSET
 254  51D9 53 50 52 47  	DB "SPRGRPMOV", 0
 254  51DD 52 50 4D 4F
 254  51E1 56 00
 255  51E3 CC 4E        	DW SPRGRPMOV
 256  51E5               ENDIF
 257  51E5               IF (SOUND_CMDS == 1)
 258  51E5 53 4E 44 53  	DB "SNDSFX", 0
 258  51E9 46 58 00
 259  51EC B6 56        	DW SNDSFX
 260  51EE 53 4E 44 50  	DB "SNDPLYON", 0
 260  51F2 4C 59 4F 4E
 260  51F6 00
 261  51F7 80 56        	DW SNDPLYON
 262  51F9 53 4E 44 50  	DB "SNDPLYOFF", 0
 262  51FD 4C 59 4F 46
 262  5201 46 00
 263  5203 93 56        	DW SNDPLYOFF
 264  5205 53 4E 44 50  	DB "SNDPLYINI", 0
 264  5209 4C 59 49 4E
 264  520D 49 00
 265  520F 36 56        	DW SNDPLYINIT
 266  5211               ENDIF
 267  5211               IF (SPRITE_CMDS == 1)
 268  5211 53 50 52 45  	DB "SPRENABLE", 0
 268  5215 4E 41 42 4C
 268  5219 45 00
 269  521B B9 4D        	DW SPRENABLE
 270  521D 53 50 52 44  	DB "SPRDISABLE", 0
 270  5221 49 53 41 42
 270  5225 4C 45 00
 271  5228 09 4E        	DW SPRDISABLE
 272  522A               ENDIF
 273  522A               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 274  522A 00           	DB 0
 275  522B               ENDIF
 276  522B              CMDS_B:
 277  522B               IF (BLIT_CMDS == 1)
 278  522B 42 4C 49 54  	DB "BLIT", 0
 278  522F 00
 279  5230 8D 58        	DW BLIT
 280  5232               ENDIF
 281  5232               IF (BOX_CMDS == 1)
 282  5232 42 4F 58 4D  	DB "BOXMEMCPY", 0
 282  5236 45 4D 43 50
 282  523A 59 00
 283  523C C5 5B        	DW BOXMEMCPY
 284  523E 42 4F 58 4D  	DB "BOXMEMVRM", 0
 284  5242 45 4D 56 52
 284  5246 4D 00
 285  5248 F9 5B        	DW BOXMEMVRM
 286  524A               ENDIF
 287  524A               IF (BLIT_CMDS + BOX_CMDS > 0)
 288  524A 00           	DB 0
 289  524B               ENDIF
 290  524B              CMDS_T:
 291  524B               IF (TILE_CMDS == 1)
 292  524B 54 49 4C 45  	DB "TILERAM", 0
 292  524F 52 41 4D 00
 293  5253 D1 59        	DW TILERAM
 294  5255 54 49 4C 45  	DB "TILEVRM", 0
 294  5259 56 52 4D 00
 295  525D D4 5A        	DW TILEVRM
 296  525F               ENDIF
 297  525F               IF (TILE_CMDS > 0)
 298  525F 00           	DB 0
 299  5260               ENDIF
 300  5260              CMDS_A:
 301  5260               IF (ANIM_CMDS == 1)
 302  5260 41 4E 49 4D  	DB "ANIMITEMPAT",0
 302  5264 49 54 45 4D
 302  5268 50 41 54 00
 303  526C 23 50        	DW ANIMITEMPAT
 304  526E 41 4E 49 4D  	DB "ANIMITEMPTR",0
 304  5272 49 54 45 4D
 304  5276 50 54 52 00
 305  527A 8D 50        	DW ANIMITEMPTR_CMD
 306  527C 00           	DB 0
 307  527D               ENDIF
 308  527D
 309  527D               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 310  527D              ; ****************************************************************************************************
 311  527D              ; function sets VRAM address
 312  527D              ; input HL=address
 313  527D              ; modifies AF
 314  527D              SETWRT_LOCAL:
 315  527D 7D           	LD	A, L
 316  527E D3 99        	OUT	(099H), A
 317  5280 7C           	LD	A, H
 318  5281 E6 3F        	AND	03FH
 319  5283 F6 40        	OR	040H
 320  5285 D3 99        	OUT	(099H), A
 321  5287 C9           	RET
 322  5288              ; ****************************************************************************************************
 323  5288               ENDIF
 324  5288
 325  5288               IF (VRAM_CMDS + TILE_CMDS > 0)
 326  5288              ; ****************************************************************************************************
 327  5288              ; function copies data from RAM to VRAM
 328  5288              ; input HL=address in RAM
 329  5288              ; input B=count
 330  5288              ; modifies AF
 331  5288              BBYTECOPY:
 332  5288 ED A3        	OUTI
 333  528A C2 88 52     	JP	NZ, BBYTECOPY
 334  528D C9           	RET
 335  528E              ; ****************************************************************************************************
 336  528E               ENDIF
 337  528E
 338  528E              ; ****************************************************************************************************
 339  528E              ; function multiplies HL by 16
 340  528E              HLx16:
 341  528E 29           	ADD HL,HL
 342  528F              ; ****************************************************************************************************
 343  528F              ; function multiplies HL by 8
 344  528F              HLx8:
 345  528F 29          > ADD HL, HL
 345  5290 29          > ADD HL, HL
 345  5291 29          > ADD HL, HL
 346  5292 C9           	RET
 347  5293              ; ****************************************************************************************************
 348  5293
 349  5293              ; ****************************************************************************************************
 350  5293              ; function gets slot and subslot data for specific page
 351  5293              ; input A=page (0, 1 or 2)
 352  5293              ; output B = 0A8H register value
 353  5293              ; output D = 0 is no subslots, 1 if yes
 354  5293              ; output C = 0A8H value when page 3 slot equals to requested page slot
 355  5293              ; output E = subslot value if present
 356  5293              ; modifies AF, BC, DE, HL
 357  5293              GET_PAGE_INFO:
 358  5293 6F               LD L, A
 359  5294 C6 C1            ADD A, low (EXPTBL)
 360  5296 32 A0 52         LD (GET_PAGE_INFO_L1+1), A
 361  5299 DB A8            IN A, (0A8H)
 362  529B 47               LD B, A
 363  529C E6 3F            AND 03FH
 364  529E 4F               LD C, A
 365  529F              GET_PAGE_INFO_L1:
 366  529F 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 367  52A2 E6 80            AND 080H
 368  52A4 28 1B            JR Z, GET_PAGE_INFO_L2
 369  52A6                  ; expanded
 370  52A6 2D               DEC L
 371  52A7 FA C6 52         JP M, GET_PAGE_INFO_L3
 372  52AA 2D               DEC L
 373  52AB FA C4 52         JP M, GET_PAGE_INFO_L4
 374  52AE                  ; page 2
 375  52AE 07               RLCA
 376  52AF 07               RLCA
 377  52B0              GET_PAGE_INFO_L5:
 378  52B0 E6 C0            AND 0C0H
 379  52B2 B1               OR C
 380  52B3 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 381  52B5 4F               LD C, A
 382  52B6 3A FF FF         LD A, (0FFFFH)
 383  52B9 2F               CPL
 384  52BA 5F               LD E, A
 385  52BB 16 01            LD D, 1
 386  52BD 78               LD A, B ; return stack
 387  52BE D3 A8            OUT (0A8H), A
 388  52C0 C9               RET
 389  52C1              GET_PAGE_INFO_L2:
 390  52C1                  ; not expanded
 391  52C1 16 00            LD D, 0
 392  52C3 C9               RET
 393  52C4              GET_PAGE_INFO_L4:
 394  52C4                  ; page 1
 395  52C4 0F               RRCA
 396  52C5 0F               RRCA
 397  52C6              GET_PAGE_INFO_L3:
 398  52C6                  ; page 0
 399  52C6 0F               RRCA
 400  52C7 0F               RRCA
 401  52C8 18 E6            JR GET_PAGE_INFO_L5
 402  52CA              ; ****************************************************************************************************
 403  52CA
 404  52CA              ; ****************************************************************************************************
 405  52CA              ; function returns original slot and subslot info
 406  52CA              ; input B = 0A8H register value
 407  52CA              ; input D = 0 is no subslots, 1 if yes
 408  52CA              ; input C = 0A8H value when page 3 slot equals to requested page slot
 409  52CA              ; input E = subslot value if present
 410  52CA              ; modifies AF, disables interrupts
 411  52CA              RESTORE_PAGE_INFO:
 412  52CA 7A               LD A, D
 413  52CB B7               OR A
 414  52CC 28 08            JR Z, RESTORE_PAGE_INFO_L1
 415  52CE 79               LD A, C
 416  52CF F3           	DI
 417  52D0 D3 A8            OUT (0A8H), A
 418  52D2 7B               LD A, E
 419  52D3 32 FF FF         LD (0FFFFH), A
 420  52D6              RESTORE_PAGE_INFO_L1:
 421  52D6 78               LD A, B
 422  52D7 D3 A8            OUT (0A8H), A
 423  52D9 C9               RET
 424  52DA              ; ****************************************************************************************************
 425  52DA
 426  52DA              ; *******************************************************************************************************
 427  52DA              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 428  52DA              ; INPUT:  A = SLOT ID: EXXXSSPP
 429  52DA              ; E = EXPANDED FLAG
 430  52DA              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 431  52DA              ; PP = PRIMARY SLOT NUMBER
 432  52DA              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 433  52DA              ; CHANGES: AF, BC, DE
 434  52DA
 435  52DA              LOCAL_ENASLT:
 436  52DA CD FA 52         CALL L0353
 437  52DD FA E7 52         JP M, L0340
 438  52E0 DB A8            IN A, (0A8H)
 439  52E2 A1               AND C
 440  52E3 B0               OR B
 441  52E4 D3 A8            OUT (0A8H), A
 442  52E6 C9               RET
 443  52E7              L0340:
 444  52E7 E5               PUSH HL
 445  52E8 CD 1F 53         CALL L0378
 446  52EB 4F               LD C, A
 447  52EC 06 00            LD B, 0
 448  52EE 7D               LD A, L
 449  52EF A4               AND H
 450  52F0 B2               OR D
 451  52F1 21 C5 FC         LD HL, 0FCC5H
 452  52F4 09               ADD HL, BC
 453  52F5 77               LD (HL), A
 454  52F6 E1               POP HL
 455  52F7 79               LD A, C
 456  52F8 18 E0            JR LOCAL_ENASLT
 457  52FA              L0353:
 458  52FA F3               DI
 459  52FB F5               PUSH AF
 460  52FC 7C               LD A, H
 461  52FD 07               RLCA
 462  52FE 07               RLCA
 463  52FF E6 03            AND 3
 464  5301 5F               LD E, A
 465  5302 3E C0            LD A, 0C0H
 466  5304              L035D:
 467  5304 07               RLCA
 468  5305 07               RLCA
 469  5306 1D               DEC E
 470  5307 F2 04 53         JP P, L035D
 471  530A 5F               LD E, A
 472  530B 2F               CPL
 473  530C 4F               LD C, A
 474  530D F1               POP AF
 475  530E F5               PUSH AF
 476  530F E6 03            AND 3
 477  5311 3C               INC A
 478  5312 47               LD B, A
 479  5313 3E AB            LD A, 0ABH
 480  5315              L036E:
 481  5315 C6 55            ADD A, 055H
 482  5317 10 FC            DJNZ L036E
 483  5319 57               LD D, A
 484  531A A3               AND E
 485  531B 47               LD B, A
 486  531C F1               POP AF
 487  531D A7               AND A
 488  531E C9               RET
 489  531F              L0378:
 490  531F F5               PUSH AF
 491  5320 7A               LD A, D
 492  5321 E6 C0            AND 0C0H
 493  5323 4F               LD C, A
 494  5324 F1               POP AF
 495  5325 F5               PUSH AF
 496  5326 57               LD D, A
 497  5327 DB A8            IN A, (0A8H)
 498  5329 47               LD B, A
 499  532A E6 3F            AND 03FH
 500  532C B1               OR C
 501  532D D3 A8            OUT (0A8H), A
 502  532F 7A               LD A, D
 503  5330 0F               RRCA
 504  5331 0F               RRCA
 505  5332 E6 03            AND 3
 506  5334 57               LD D, A
 507  5335 3E AB            LD A, 0ABH
 508  5337              L0390:
 509  5337 C6 55            ADD A, 055H
 510  5339 15               DEC D
 511  533A F2 37 53         JP P, L0390
 512  533D A3               AND E
 513  533E 57               LD D, A
 514  533F 7B               LD A, E
 515  5340 2F               CPL
 516  5341 67               LD H, A
 517  5342 3A FF FF         LD A, (0FFFFH)
 518  5345 2F               CPL
 519  5346 6F               LD L, A
 520  5347 A4               AND H
 521  5348 B2               OR D
 522  5349 32 FF FF         LD (0FFFFH), A
 523  534C 78               LD A, B
 524  534D D3 A8            OUT (0A8H), A
 525  534F F1               POP AF
 526  5350 E6 03            AND 3
 527  5352 C9               RET
 528  5353              ; *******************************************************************************************************
 529  5353
 530  5353              ; *******************************************************************************************************
 531  5353              ; some common code to activate page 0 and place values needed to restore original page on stack
 532  5353              ; input IY=return address
 533  5353              ENABLE_PAGE0:
 534  5353 AF               XOR A
 535  5354 CD 93 52         CALL GET_PAGE_INFO
 536  5357 C5               PUSH BC
 537  5358 D5               PUSH DE
 538  5359 3A 41 F3         LD A, (RAMAD0)
 539  535C 26 00            LD H, 0
 540  535E CD DA 52         CALL LOCAL_ENASLT
 541  5361 FD E9        	JP (IY)
 542  5363              ; *******************************************************************************************************
 543  5363
 544  5363              ; General BASIC CALL-instruction handler
 545  5363              CALLHAND:
 546  5363 E5           	PUSH HL
 547  5364 21 45 51     	LD	HL, CMDS ; pointer table based on starting letter
 548  5367 3A 89 FD         LD A, (PROCNM)
 549  536A D6 41            SUB 'A'
 550  536C 87               ADD A, A
 551  536D 16 00            LD D, 0
 552  536F 5F               LD E, A
 553  5370 19               ADD HL, DE
 554  5371 5E               LD E, (HL)
 555  5372 23               INC HL
 556  5373 56               LD D, (HL)
 557  5374 7A               LD A, D
 558  5375 B3               OR E
 559  5376 28 23            JR Z, .CMDNOTRECOGNIZED
 560  5378 EB               EX DE, HL
 561  5379              .CHKCMD:
 562  5379 11 89 FD     	LD	DE, PROCNM
 563  537C 1A           .LOOP:	LD	A,(DE)
 564  537D BE           	CP	(HL)
 565  537E 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 566  5380 13           	INC	DE
 567  5381 23           	INC	HL
 568  5382 A7           	AND	A
 569  5383 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 570  5385 5E           	LD	E,(HL)
 571  5386 23           	INC	HL
 572  5387 56           	LD	D,(HL)
 573  5388 E1           	POP	HL		; routine address
 574  5389 CD AA 53     	CALL	GETPREVCHAR
 575  538C CD 9E 53     	CALL	.CALLDE		; Call routine
 576  538F A7           	AND	A
 577  5390 C9           	RET
 578  5391
 579  5391              .TONEXTCMD:
 580  5391 0E FF        	LD	C,0FFH
 581  5393 AF           	XOR	A
 582  5394 ED B1        	CPIR			; Skip to end of instruction name
 583  5396 23           	INC	HL
 584  5397 23           	INC	HL		; Skip address
 585  5398 BE           	CP	(HL)
 586  5399 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 587  539B              .CMDNOTRECOGNIZED:
 588  539B E1           	POP	HL
 589  539C 37               SCF
 590  539D C9           	RET
 591  539E
 592  539E              .CALLDE:
 593  539E D5           	PUSH	DE
 594  539F C9           	RET
 595  53A0
 596  53A0              ;---------------------------
 597  53A0
 598  53A0              ;GETSTRPNT:
 599  53A0              ; OUT:
 600  53A0              ; HL = String Address
 601  53A0              ; B  = Lenght
 602  53A0              ;        LD      HL,(USR)
 603  53A0              ;        LD      B,(HL)
 604  53A0              ;        INC     HL
 605  53A0              ;        LD      E,(HL)
 606  53A0              ;        INC     HL
 607  53A0              ;        LD      D,(HL)
 608  53A0              ;        EX      DE,HL
 609  53A0              ;        RET
 610  53A0
 611  53A0              ;EVALTXTPARAM:
 612  53A0              ;	CALL	CHKCHAR
 613  53A0              ;	DEFB	"("             ; Check for (
 614  53A0              ;	LD	IX,FRMEVL
 615  53A0              ;	CALL	CALBAS		; Evaluate expression
 616  53A0              ;       LD      A,(VALTYP)
 617  53A0              ;        CP      3               ; Text type?
 618  53A0              ;        JP      NZ,TYPE_MISMATCH
 619  53A0              ;        PUSH	HL
 620  53A0              ;        LD	IX,FRESTR         ; Free the temporary string
 621  53A0              ;        CALL	CALBAS
 622  53A0              ;        POP	HL
 623  53A0              ;	CALL	CHKCHAR
 624  53A0              ;	DEFB	")"             ; Check for )
 625  53A0              ;        RET
 626  53A0
 627  53A0
 628  53A0              CHKCHAR:
 629  53A0 CD AA 53     	CALL	GETPREVCHAR	; Get previous basic char
 630  53A3 E3           	EX	(SP),HL
 631  53A4 BE           	CP	(HL) 	        ; Check if good char
 632  53A5 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 633  53A7 23           	INC	HL
 634  53A8 E3           	EX	(SP),HL
 635  53A9 23           	INC	HL		; Get next basic char
 636  53AA
 637  53AA              GETPREVCHAR:
 638  53AA 2B           	DEC	HL
 639  53AB DD 21 66 46  	LD	IX,CHRGTR
 640  53AF C3 59 01     	JP      CALBAS
 641  53B2
 642  53B2
 643  53B2              TYPE_MISMATCH:
 644  53B2 1E 0D            LD E, 13 ; Type mismatch
 645  53B4 18 02            JR THROW_ERROR
 646  53B6
 647  53B6              SYNTAX_ERROR:
 648  53B6 1E 02            LD E, 2 ; Syntax error
 649  53B8              THROW_ERROR:
 650  53B8 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 651  53BC C3 59 01     	JP	CALBAS
 652  53BF
 653  53BF              ;---------------------------
 654  53BF
 655  53BF               IF (RAM_CMDS == 1)
 656  53BF              ; *******************************************************************************************************
 657  53BF              ; function to handle CALL MEMCPY basic extension
 658  53BF              ; _MEMCPY ( INT source,
 659  53BF              ;			INT destination,
 660  53BF              ;			INT count,
 661  53BF              ; will put ram in page 0 also, page 1 is already there
 662  53BF              MEMCPY:
 663  53BF              	; opening (
 664  53BF CD A0 53     	CALL CHKCHAR
 665  53C2 28           	DB '('
 666  53C3              	; get source address
 667  53C3 DD 21 2F 54  	LD IX, FRMQNT
 668  53C7 CD 59 01     	CALL CALBAS
 669  53CA D5           	PUSH DE
 670  53CB              	; comma
 671  53CB CD A0 53     	CALL CHKCHAR
 672  53CE 2C           	DB ','
 673  53CF              	; get destination address
 674  53CF DD 21 2F 54  	LD IX, FRMQNT
 675  53D3 CD 59 01     	CALL CALBAS
 676  53D6 D5           	PUSH DE
 677  53D7              	; comma
 678  53D7 CD A0 53     	CALL CHKCHAR
 679  53DA 2C           	DB ','
 680  53DB              	; get length
 681  53DB DD 21 2F 54  	LD IX, FRMQNT
 682  53DF CD 59 01     	CALL CALBAS
 683  53E2 D5           	PUSH DE
 684  53E3              	; ending )
 685  53E3 CD A0 53     	CALL CHKCHAR
 686  53E6 29           	DB ')'
 687  53E7
 688  53E7              	; save position
 689  53E7 E5           	PUSH HL
 690  53E8 DD E1        	POP IX
 691  53EA
 692  53EA C1           	POP BC ; count
 693  53EB D1           	POP DE ; destination
 694  53EC E1           	POP HL ; source
 695  53ED D9           	EXX
 696  53EE              	; enable page 0
 697  53EE FD 21 F5 53  	LD IY, .RET
 698  53F2 C3 53 53     	JP ENABLE_PAGE0
 699  53F5              .RET:
 700  53F5 FB           	EI
 701  53F6 D9           	EXX
 702  53F7 ED B0        	LDIR
 703  53F9 D1               POP DE
 704  53FA C1               POP BC
 705  53FB CD CA 52         CALL RESTORE_PAGE_INFO
 706  53FE DD E5        	PUSH IX
 707  5400 E1           	POP HL
 708  5401 C9           	RET
 709  5402              ; *******************************************************************************************************
 710  5402               ENDIF
 711  5402
 712  5402               IF (VRAM_CMDS == 1)
 713  5402              ; *******************************************************************************************************
 714  5402              ; function to handle CALL FILVRM basic extension
 715  5402              ; FILVRM ( INT offset,
 716  5402              ;		   INT count,
 717  5402              ;		   BYTE value,
 718  5402              ;		   BYTE wait_vsync) >0 = true
 719  5402              ; wait_vsync will issue HALT before copying
 720  5402              FILVRM:
 721  5402              	; opening (
 722  5402 CD A0 53     	CALL CHKCHAR
 723  5405 28           	DB '('
 724  5406              	; get offset address
 725  5406 DD 21 2F 54  	LD IX, FRMQNT
 726  540A CD 59 01     	CALL CALBAS
 727  540D D5           	PUSH DE
 728  540E              	; comma
 729  540E CD A0 53     	CALL CHKCHAR
 730  5411 2C           	DB ','
 731  5412              	; get count
 732  5412 DD 21 2F 54  	LD IX, FRMQNT
 733  5416 CD 59 01     	CALL CALBAS
 734  5419 D5           	PUSH DE
 735  541A              	; comma
 736  541A CD A0 53     	CALL CHKCHAR
 737  541D 2C           	DB ','
 738  541E              	; get value
 739  541E DD 21 1C 52  	LD IX, GETBYT
 740  5422 CD 59 01     	CALL CALBAS
 741  5425 F5           	PUSH AF
 742  5426              	; comma
 743  5426 CD A0 53     	CALL CHKCHAR
 744  5429 2C           	DB ','
 745  542A              	; get vsync wait
 746  542A DD 21 1C 52  	LD IX, GETBYT
 747  542E CD 59 01     	CALL CALBAS
 748  5431 F5           	PUSH AF
 749  5432              	; ending )
 750  5432 CD A0 53     	CALL CHKCHAR
 751  5435 29           	DB ')'
 752  5436
 753  5436 FB               EI
 754  5437              	; save position
 755  5437 E5           	PUSH HL
 756  5438 DD E1        	POP IX
 757  543A
 758  543A              	; syntax ok
 759  543A              	; wait for vsync if needed
 760  543A F1           	POP AF
 761  543B B7           	OR A
 762  543C 28 01        	JR Z, .L1
 763  543E 76           	HALT
 764  543F
 765  543F              .L1:
 766  543F F1               POP AF ; value
 767  5440 C1               POP BC ; count
 768  5441 E1               POP HL ; offset
 769  5442 CD 56 00         CALL BIOS_FILVRM
 770  5445
 771  5445              .L3:
 772  5445 DD E5        	PUSH IX
 773  5447 E1           	POP HL
 774  5448 C9           	RET
 775  5449              ; *******************************************************************************************************
 776  5449               ENDIF
 777  5449
 778  5449               IF (RAM_CMDS == 1)
 779  5449              ; *******************************************************************************************************
 780  5449              ; function to handle CALL FILRAM basic extension
 781  5449              ; FILRAM ( INT start address,
 782  5449              ;		   INT count,
 783  5449              ;		   BYTE value,
 784  5449              ; will put ram in page 0 also, page 1 is already there
 785  5449              FILRAM:
 786  5449              	; opening (
 787  5449 CD A0 53     	CALL CHKCHAR
 788  544C 28           	DB '('
 789  544D              	; get start address
 790  544D DD 21 2F 54  	LD IX, FRMQNT
 791  5451 CD 59 01     	CALL CALBAS
 792  5454 D5           	PUSH DE
 793  5455              	; comma
 794  5455 CD A0 53     	CALL CHKCHAR
 795  5458 2C           	DB ','
 796  5459              	; get count
 797  5459 DD 21 2F 54  	LD IX, FRMQNT
 798  545D CD 59 01     	CALL CALBAS
 799  5460 D5           	PUSH DE
 800  5461              	; comma
 801  5461 CD A0 53     	CALL CHKCHAR
 802  5464 2C           	DB ','
 803  5465              	; get value
 804  5465 DD 21 1C 52  	LD IX, GETBYT
 805  5469 CD 59 01     	CALL CALBAS
 806  546C F5           	PUSH AF
 807  546D              	; ending )
 808  546D CD A0 53     	CALL CHKCHAR
 809  5470 29           	DB ')'
 810  5471
 811  5471              	; save position
 812  5471 E5           	PUSH HL
 813  5472 DD E1        	POP IX
 814  5474
 815  5474 D1           	POP DE ; actually AF
 816  5475 C1           	POP BC ; count
 817  5476 E1           	POP HL ; start address
 818  5477 78           	LD A, B
 819  5478 B7           	OR A
 820  5479 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 821  547B B1           	OR C
 822  547C 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 823  547E 79           	LD A, C
 824  547F 3D           	DEC A
 825  5480 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 826  5482              	; one byte to fill
 827  5482 72           	LD (HL), D
 828  5483 18 12        	JR .EXIT
 829  5485              .L1:
 830  5485 D9           	EXX
 831  5486              	; enable page 0
 832  5486 FD 21 8D 54  	LD IY, .RET
 833  548A C3 53 53     	JP ENABLE_PAGE0
 834  548D              .RET:
 835  548D FB           	EI
 836  548E D9           	EXX
 837  548F CD 9B 54     	CALL .FILLVALUE
 838  5492 D1               POP DE
 839  5493 C1               POP BC
 840  5494 CD CA 52         CALL RESTORE_PAGE_INFO
 841  5497              .EXIT:
 842  5497 DD E5        	PUSH IX
 843  5499 E1           	POP HL
 844  549A C9           	RET
 845  549B
 846  549B              .FILLVALUE:
 847  549B 72               LD (HL), D
 848  549C 54               LD D, H
 849  549D 5D               LD E, L
 850  549E 13               INC DE
 851  549F 0B               DEC BC
 852  54A0 ED B0            LDIR
 853  54A2 C9               RET
 854  54A3              ; *******************************************************************************************************
 855  54A3               ENDIF
 856  54A3
 857  54A3               IF (GENCAL_CMD == 1)
 858  54A3              ; *******************************************************************************************************
 859  54A3              ; function to handle CALL GENCAL basic extension
 860  54A3              ; GENCAL ( INT fn_addr, = address of the function to call
 861  54A3              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 862  54A3              ; output values of reristers will also be stored at reg_list_ptr
 863  54A3              GENCAL_VAR_SP:
 864  54A3 00 00            DW 0
 865  54A5              GENCAL_VAR_SP2:
 866  54A5 00 00            DW 0
 867  54A7              GENCAL:
 868  54A7              	; opening (
 869  54A7 CD A0 53     	CALL CHKCHAR
 870  54AA 28           	DB '('
 871  54AB              	; get function address
 872  54AB DD 21 2F 54  	LD IX, FRMQNT
 873  54AF CD 59 01     	CALL CALBAS
 874  54B2 D5           	PUSH DE
 875  54B3              	; comma
 876  54B3 CD A0 53     	CALL CHKCHAR
 877  54B6 2C           	DB ','
 878  54B7              	; get pointer to register list
 879  54B7 DD 21 2F 54  	LD IX, FRMQNT
 880  54BB CD 59 01     	CALL CALBAS
 881  54BE D5           	PUSH DE
 882  54BF              	; ending )
 883  54BF CD A0 53     	CALL CHKCHAR
 884  54C2 29           	DB ')'
 885  54C3
 886  54C3              	; save BASIC token position
 887  54C3 E5           	PUSH HL
 888  54C4 D9               EXX
 889  54C5 E1           	POP HL ; HL'=next basic token
 890  54C6 D9               EXX
 891  54C7
 892  54C7 E1               POP HL ; get pointer to register values
 893  54C8 F3           	DI
 894  54C9 ED 73 A3 54      LD (GENCAL_VAR_SP), SP
 895  54CD F9               LD SP, HL
 896  54CE F1               POP AF
 897  54CF C1               POP BC
 898  54D0 D1               POP DE
 899  54D1 E1               POP HL
 900  54D2 DD E1            POP IX
 901  54D4 FD E1            POP IY
 902  54D6 D9               EXX
 903  54D7 ED 73 A5 54      LD (GENCAL_VAR_SP2), SP
 904  54DB ED 7B A3 54      LD SP, (GENCAL_VAR_SP)
 905  54DF FB               EI
 906  54E0 D1               POP DE ; get function to call
 907  54E1 E5               PUSH HL
 908  54E2 CD FD 54         CALL .EXXDECALL
 909  54E5 F3               DI
 910  54E6 ED 73 A3 54      LD (GENCAL_VAR_SP), SP
 911  54EA ED 7B A5 54      LD SP, (GENCAL_VAR_SP2)
 912  54EE FD E5            PUSH IY
 913  54F0 DD E5            PUSH IX
 914  54F2 E5               PUSH HL
 915  54F3 D5               PUSH DE
 916  54F4 C5               PUSH BC
 917  54F5 F5               PUSH AF
 918  54F6 ED 7B A3 54      LD SP, (GENCAL_VAR_SP)
 919  54FA FB               EI
 920  54FB E1               POP HL
 921  54FC C9           	RET
 922  54FD
 923  54FD              .EXXDECALL:
 924  54FD D5               PUSH DE
 925  54FE D9               EXX
 926  54FF C9               RET
 927  5500              ; *******************************************************************************************************
 928  5500               ENDIF
 929  5500
 930  5500               IF (VRAM_CMDS == 1)
 931  5500              ; *******************************************************************************************************
 932  5500              ; function to handle CALL MEMVRM basic extension
 933  5500              ; copies from RAM to VRAM
 934  5500              ; _MEMVRM ( INT source,
 935  5500              ;			INT destination,
 936  5500              ;			INT count,
 937  5500              ;			BYTE wait_vsync) >0 = true
 938  5500              ; will put ram in page 0 also, page 1 is already there
 939  5500              ; wait_vsync will issue HALT before copying
 940  5500              MEMVRM:
 941  5500              	; opening (
 942  5500 CD A0 53     	CALL CHKCHAR
 943  5503 28           	DB '('
 944  5504              	; get source address
 945  5504 DD 21 2F 54  	LD IX, FRMQNT
 946  5508 CD 59 01     	CALL CALBAS
 947  550B D5           	PUSH DE
 948  550C              	; comma
 949  550C CD A0 53     	CALL CHKCHAR
 950  550F 2C           	DB ','
 951  5510              	; get destination address
 952  5510 DD 21 2F 54  	LD IX, FRMQNT
 953  5514 CD 59 01     	CALL CALBAS
 954  5517 D5           	PUSH DE
 955  5518              	; comma
 956  5518 CD A0 53     	CALL CHKCHAR
 957  551B 2C           	DB ','
 958  551C              	; get length
 959  551C DD 21 2F 54  	LD IX, FRMQNT
 960  5520 CD 59 01     	CALL CALBAS
 961  5523 D5           	PUSH DE
 962  5524              	; comma
 963  5524 CD A0 53     	CALL CHKCHAR
 964  5527 2C           	DB ','
 965  5528              	; get vsync wait
 966  5528 DD 21 1C 52  	LD IX, GETBYT
 967  552C CD 59 01     	CALL CALBAS
 968  552F F5           	PUSH AF
 969  5530              	; ending )
 970  5530 CD A0 53     	CALL CHKCHAR
 971  5533 29           	DB ')'
 972  5534
 973  5534                  ; save position in BASIC text
 974  5534 E5           	PUSH HL
 975  5535 DD E1        	POP IX
 976  5537
 977  5537 F1           	POP AF ; wait vsync
 978  5538 B7           	OR A
 979  5539 28 03        	JR Z, .L1
 980  553B FB               EI
 981  553C 76           	HALT
 982  553D F3           	DI
 983  553E              .L1:
 984  553E              	; pop LDIR parameters and store away for later
 985  553E C1           	POP BC ; count
 986  553F D1           	POP DE ; vram destination
 987  5540 E1           	POP HL ; ram source
 988  5541 D9           	EXX
 989  5542 FD 21 49 55   	LD IY, .RET
 990  5546 C3 53 53     	JP ENABLE_PAGE0
 991  5549              .RET:
 992  5549 FB           	EI
 993  554A D9           	EXX
 994  554B CD 57 55     	CALL .LDIRVM
 995  554E D1               POP DE
 996  554F C1               POP BC
 997  5550 CD CA 52         CALL RESTORE_PAGE_INFO
 998  5553 DD E5        	PUSH IX
 999  5555 E1           	POP HL
1000  5556 C9           	RET
1001  5557
1002  5557              .LDIRVM:
1003  5557 EB           	EX DE, HL
1004  5558 F3           	DI
1005  5559 CD 7D 52     	CALL SETWRT_LOCAL
1006  555C FB           	EI
1007  555D EB           	EX DE, HL
1008  555E 78           	LD A, B
1009  555F B7           	OR A
1010  5560 28 0D        	JR Z, .L3
1011  5562 C5           	PUSH BC
1012  5563 0E 98        	LD C, #98
1013  5565              .L2:
1014  5565 50           	LD D, B
1015  5566 06 00        	LD B, 0
1016  5568 CD 88 52     	CALL BBYTECOPY
1017  556B 42           	LD B, D
1018  556C 10 F7        	DJNZ .L2
1019  556E C1           	POP BC
1020  556F              .L3:
1021  556F 79           	LD A, C
1022  5570 B7           	OR A
1023  5571 C8           	RET Z
1024  5572 41           	LD B, C
1025  5573 0E 98        	LD C, #98
1026  5575 C3 88 52     	JP BBYTECOPY
1027  5578              ; *******************************************************************************************************
1028  5578               ENDIF
1029  5578
1030  5578               IF (VRAM_CMDS == 1)
1031  5578              ; *******************************************************************************************************
1032  5578              ; function to handle CALL VRMMEM basic extension
1033  5578              ; copies from RAM to VRAM
1034  5578              ; _VRMMEM ( INT source,
1035  5578              ;			INT destination,
1036  5578              ;			INT count
1037  5578              ; will put ram in page 0 also, page 1 is already there
1038  5578              VRMMEM:
1039  5578              	; opening (
1040  5578 CD A0 53     	CALL CHKCHAR
1041  557B 28           	DB '('
1042  557C              	; get source address
1043  557C DD 21 2F 54  	LD IX, FRMQNT
1044  5580 CD 59 01     	CALL CALBAS
1045  5583 D5           	PUSH DE
1046  5584              	; comma
1047  5584 CD A0 53     	CALL CHKCHAR
1048  5587 2C           	DB ','
1049  5588              	; get destination address
1050  5588 DD 21 2F 54  	LD IX, FRMQNT
1051  558C CD 59 01     	CALL CALBAS
1052  558F D5           	PUSH DE
1053  5590              	; comma
1054  5590 CD A0 53     	CALL CHKCHAR
1055  5593 2C           	DB ','
1056  5594              	; get length
1057  5594 DD 21 2F 54  	LD IX, FRMQNT
1058  5598 CD 59 01     	CALL CALBAS
1059  559B D5           	PUSH DE
1060  559C              	; ending )
1061  559C CD A0 53     	CALL CHKCHAR
1062  559F 29           	DB ')'
1063  55A0
1064  55A0                  ; save position in BASIC text
1065  55A0 E5           	PUSH HL
1066  55A1 DD E1        	POP IX
1067  55A3
1068  55A3 C1           	POP BC ; count
1069  55A4 D1           	POP DE ; destination
1070  55A5 E1           	POP HL ; source
1071  55A6 D9           	EXX
1072  55A7 FD 21 AE 55  	LD IY, .RET
1073  55AB C3 53 53     	JP ENABLE_PAGE0
1074  55AE              .RET:
1075  55AE FB           	EI
1076  55AF D9           	EXX
1077  55B0 CD BC 55     	CALL .LDIRMV
1078  55B3 D1               POP DE
1079  55B4 C1               POP BC
1080  55B5 CD CA 52         CALL RESTORE_PAGE_INFO
1081  55B8 DD E5        	PUSH IX
1082  55BA E1           	POP HL
1083  55BB C9           	RET
1084  55BC
1085  55BC              .LDIRMV:
1086  55BC              	; set VRAM address *exactly* as in ROM, otherwise corruption
1087  55BC 7D           	LD	A, L
1088  55BD F3           	DI
1089  55BE D3 99        	OUT	(099H), A
1090  55C0 7C           	LD	A, H
1091  55C1 E6 3F        	AND	03FH
1092  55C3 D3 99        	OUT	(099H), A
1093  55C5 FB           	EI
1094  55C6              	;EX (SP), HL
1095  55C6              	;EX (SP), HL
1096  55C6              	;NOP
1097  55C6              	;NOP
1098  55C6              .L4:
1099  55C6 DB 98            IN A, (#98)
1100  55C8 12           	LD (DE), A
1101  55C9 13               INC DE
1102  55CA 0B               DEC BC
1103  55CB 79               LD A, C
1104  55CC B0               OR B
1105  55CD 20 F7            JR NZ, .L4
1106  55CF C9               RET
1107  55D0              ; *******************************************************************************************************
1108  55D0               ENDIF
1109  55D0
1110  55D0              ; *******************************************************************************************************
1111  55D0              ; H.TIMI function
1112  55D0              MBGE_HTIMI:
1113  55D0               EXPORT MBGE_HTIMI
1114  55D0 F5           	PUSH AF
1115  55D1
1116  55D1               IF (SPRITE_CMDS == 1)
1117  55D1 CD 01 4D     	CALL SPRATR_UPDATE
1118  55D4               ENDIF
1119  55D4
1120  55D4               IF (SOUND_CMDS == 1)
1121  55D4 3A F7 4C     	LD A, (SOUND_ENABLED)
1122  55D7 B7           	OR A
1123  55D8 28 2A        	JR Z, .EXIT
1124  55DA
1125  55DA              	; enable page 2
1126  55DA 3E 02            LD A, 2
1127  55DC CD 93 52         CALL GET_PAGE_INFO
1128  55DF C5               PUSH BC
1129  55E0 D5               PUSH DE
1130  55E1 3A 43 F3         LD A, (RAMAD2)
1131  55E4 26 80            LD H, 080H
1132  55E6 CD DA 52         CALL LOCAL_ENASLT
1133  55E9              	; enable page 0
1134  55E9 AF               XOR A
1135  55EA CD 93 52         CALL GET_PAGE_INFO
1136  55ED C5               PUSH BC
1137  55EE D5               PUSH DE
1138  55EF 3A 41 F3         LD A, (RAMAD0)
1139  55F2 26 00            LD H, 0
1140  55F4 CD DA 52         CALL LOCAL_ENASLT
1141  55F7
1142  55F7 CD 33 42     	CALL PLY_AKG_PLAY
1143  55FA
1144  55FA              	; restore page 0
1145  55FA D1               POP DE
1146  55FB C1               POP BC
1147  55FC CD CA 52         CALL RESTORE_PAGE_INFO
1148  55FF              	; restore page 2
1149  55FF D1               POP DE
1150  5600 C1               POP BC
1151  5601 CD CA 52         CALL RESTORE_PAGE_INFO
1152  5604               ENDIF
1153  5604
1154  5604              .EXIT:
1155  5604 F1           	POP AF
1156  5605 C3 F0 4C     	JP ORIG.HTIMI
1157  5608              ; *******************************************************************************************************
1158  5608
1159  5608              ; *******************************************************************************************************
1160  5608              ; interrupt handler when page 0 enabled
1161  5608              VBLANK:
1162  5608              	EXPORT VBLANK
1163  5608
1164  5608 F5               PUSH AF
1165  5609              	; is VDP originator ?
1166  5609 DB 99        	IN	A, (099H)
1167  560B A7           	AND	A
1168  560C F2 32 56     	JP P, .EXIT
1169  560F
1170  560F               IF (SOUND_CMDS == 1)
1171  560F 3A F7 4C     	LD A, (SOUND_ENABLED)
1172  5612 B7           	OR A
1173  5613 28 1D        	JR Z, .EXIT
1174  5615
1175  5615 C5               PUSH BC
1176  5616 D5               PUSH DE
1177  5617 E5               PUSH HL
1178  5618 08               EX AF, AF'
1179  5619 D9               EXX
1180  561A F5               PUSH AF
1181  561B C5               PUSH BC
1182  561C D5               PUSH DE
1183  561D E5               PUSH HL
1184  561E DD E5            PUSH IX
1185  5620 FD E5            PUSH IY
1186  5622
1187  5622 CD 33 42     	CALL PLY_AKG_PLAY
1188  5625
1189  5625 FD E1            POP IY
1190  5627 DD E1            POP IX
1191  5629 E1               POP HL
1192  562A D1               POP DE
1193  562B C1               POP BC
1194  562C F1               POP AF
1195  562D 08               EX AF, AF'
1196  562E D9               EXX
1197  562F E1               POP HL
1198  5630 D1               POP DE
1199  5631 C1               POP BC
1200  5632               ENDIF
1201  5632
1202  5632              .EXIT:
1203  5632 F1           	POP AF
1204  5633 FB           	EI
1205  5634 ED 4D        	RETI
1206  5636              ; *******************************************************************************************************
1207  5636
1208  5636               IF (SOUND_CMDS == 1)
1209  5636              ; *******************************************************************************************************
1210  5636              ; function to handle CALL SNDPLYINIT basic extension
1211  5636              ; initializes sound player
1212  5636              ; _SNDPLYINIT ( INT music_offset,
1213  5636              ;				INT sfx_offset, can be -1 if no SFX
1214  5636              ; will put ram in page 0 also, page 1 is already there
1215  5636              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1216  5636              SNDPLYINIT:
1217  5636              	; opening (
1218  5636 CD A0 53     	CALL CHKCHAR
1219  5639 28           	DB '('
1220  563A              	; get music address
1221  563A DD 21 2F 54  	LD IX, FRMQNT
1222  563E CD 59 01     	CALL CALBAS
1223  5641 D5           	PUSH DE
1224  5642              	; comma
1225  5642 CD A0 53     	CALL CHKCHAR
1226  5645 2C           	DB ','
1227  5646              	; get sfx address
1228  5646 DD 21 2F 54  	LD IX, FRMQNT
1229  564A CD 59 01     	CALL CALBAS
1230  564D D5           	PUSH DE
1231  564E              	; ending )
1232  564E CD A0 53     	CALL CHKCHAR
1233  5651 29           	DB ')'
1234  5652
1235  5652                  ; save position in BASIC text
1236  5652 44           	LD B, H
1237  5653 4D           	LD C, L
1238  5654
1239  5654              	; pop LDIR parameters and store away for later
1240  5654 D1           	POP DE ; sfx address
1241  5655 E1           	POP HL ; music address
1242  5656 C5           	PUSH BC ; basic text location
1243  5657 D9           	EXX
1244  5658 FD 21 5F 56  	LD IY, .RET
1245  565C C3 53 53     	JP ENABLE_PAGE0
1246  565F              .RET:
1247  565F D9           	EXX
1248  5660
1249  5660 D5           	PUSH DE
1250  5661 AF           	XOR A
1251  5662              	; HL = music location
1252  5662 CD 62 41     	CALL PLY_AKG_INIT
1253  5665 3E 01        	LD A, 1
1254  5667 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1255  566A
1256  566A E1           	POP HL ; SFX
1257  566B              	; check if SFX address -1
1258  566B 23           	INC HL
1259  566C 7D           	LD A, L
1260  566D B4           	OR H
1261  566E 28 09        	JR Z,.L1
1262  5670 2B           	DEC HL
1263  5671 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1264  5674 3E 01        	LD A, 1
1265  5676 32 F6 4C     	LD (SFX_INIT_STATUS), A
1266  5679              .L1:
1267  5679 D1               POP DE
1268  567A C1               POP BC
1269  567B CD CA 52         CALL RESTORE_PAGE_INFO
1270  567E
1271  567E E1           	POP HL
1272  567F C9           	RET
1273  5680              ; *******************************************************************************************************
1274  5680
1275  5680              ; *******************************************************************************************************
1276  5680              ; function to handle CALL SNDPLYON basic extension
1277  5680              ; enables sound player
1278  5680              ; _SNDPLYON
1279  5680              ; sets SOUND_ENABLED variable to 1 if init call was done
1280  5680              ; if not throws out of data error
1281  5680              SNDPLYON:
1282  5680 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1283  5683 B7           	OR A
1284  5684 20 05        	JR NZ, .L1
1285  5686              	; player not initialized, throw error
1286  5686 1E 04        	LD E, 04 ; Out of DATA
1287  5688 C3 B8 53     	JP THROW_ERROR
1288  568B              .L1:
1289  568B 32 F7 4C     	LD (SOUND_ENABLED), A
1290  568E              	; disable key click
1291  568E AF           	XOR A
1292  568F 32 DB F3     	LD (CLIKSW), A
1293  5692 C9           	RET
1294  5693              ; *******************************************************************************************************
1295  5693
1296  5693              ; *******************************************************************************************************
1297  5693              ; function to handle CALL SNDPLYOFF basic extension
1298  5693              ; disables sound player
1299  5693              ; _SNDPLYOFF
1300  5693              ; sets SOUND_ENABLED variable to 0
1301  5693              ; calls AKG to stop music and SFX on all channels if initialized
1302  5693              SNDPLYOFF:
1303  5693 3A F7 4C     	LD A, (SOUND_ENABLED)
1304  5696 B7           	OR A
1305  5697 C8           	RET Z ; already stopped
1306  5698 AF           	XOR A
1307  5699 32 F7 4C     	LD (SOUND_ENABLED), A
1308  569C E5           	PUSH HL
1309  569D CD 21 42     	CALL PLY_AKG_STOP
1310  56A0 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1311  56A3 B7           	OR A
1312  56A4 28 0E        	JR Z, .EXIT ; SFX not in use
1313  56A6 AF           	XOR A
1314  56A7 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1315  56AA 3E 01        	LD A, 1
1316  56AC CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1317  56AF 3E 02        	LD A, 2
1318  56B1 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1319  56B4              .EXIT:
1320  56B4 E1           	POP HL
1321  56B5 C9           	RET
1322  56B6              ; *******************************************************************************************************
1323  56B6
1324  56B6              ; *******************************************************************************************************
1325  56B6              ; function to handle CALL SNDSFX basic extension
1326  56B6              ; plays a sound effect
1327  56B6              ; _SNDSFX ( BYTE sfx_number, >0
1328  56B6              ;			BYTE channel, = 0,1 or 2
1329  56B6              ;			BYTE inverted_volume = 0-16, 0 being full volume
1330  56B6              ; will put ram in page 0 also, page 1 is already there
1331  56B6              ; if sound off throws illegal function call
1332  56B6              ; if sfx not initialized, throws out of data
1333  56B6              SNDSFX:
1334  56B6              	; opening (
1335  56B6 CD A0 53     	CALL CHKCHAR
1336  56B9 28           	DB '('
1337  56BA              	; get sfx_number
1338  56BA DD 21 1C 52  	LD IX, GETBYT
1339  56BE CD 59 01     	CALL CALBAS
1340  56C1 D5           	PUSH DE
1341  56C2              	; comma
1342  56C2 CD A0 53     	CALL CHKCHAR
1343  56C5 2C           	DB ','
1344  56C6              	; get sfx address
1345  56C6 DD 21 1C 52  	LD IX, GETBYT
1346  56CA CD 59 01     	CALL CALBAS
1347  56CD D5           	PUSH DE
1348  56CE              	; comma
1349  56CE CD A0 53     	CALL CHKCHAR
1350  56D1 2C           	DB ','
1351  56D2              	; get inverted volume
1352  56D2 DD 21 1C 52  	LD IX, GETBYT
1353  56D6 CD 59 01     	CALL CALBAS
1354  56D9 D5           	PUSH DE
1355  56DA              	; ending )
1356  56DA CD A0 53     	CALL CHKCHAR
1357  56DD 29           	DB ')'
1358  56DE
1359  56DE 3A F7 4C     	LD A, (SOUND_ENABLED)
1360  56E1 B7           	OR A
1361  56E2 20 05        	JR NZ, .L1
1362  56E4              	; sound disabled, throw illegal function call
1363  56E4 1E 05        	LD E, 5
1364  56E6 C3 B8 53     	JP THROW_ERROR
1365  56E9              .L1:
1366  56E9 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1367  56EC B7           	OR A
1368  56ED 20 05        	JR NZ, .L2
1369  56EF              	; sfx data not initialized, throw out of data
1370  56EF 1E 04        	LD E, 4
1371  56F1 C3 B8 53     	JP THROW_ERROR
1372  56F4              .L2:
1373  56F4              	; pop  parameters and store away for later
1374  56F4 D1           	POP DE ; inverted volume
1375  56F5 43           	LD B, E
1376  56F6 D1           	POP DE ; channel
1377  56F7 4B           	LD C, E
1378  56F8 D1           	POP DE
1379  56F9 7B           	LD A, E
1380  56FA 08           	EX AF, AF'
1381  56FB E5           	PUSH HL ; basic text location
1382  56FC D9           	EXX
1383  56FD FD 21 04 57  	LD IY, .RET
1384  5701 C3 53 53     	JP ENABLE_PAGE0
1385  5704              .RET:
1386  5704 D9           	EXX
1387  5705 08           	EX AF, AF'
1388  5706 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1389  5709
1390  5709 D1               POP DE
1391  570A C1               POP BC
1392  570B CD CA 52         CALL RESTORE_PAGE_INFO
1393  570E
1394  570E E1           	POP HL
1395  570F C9           	RET
1396  5710              ; *******************************************************************************************************
1397  5710               ENDIF
1398  5710
1399  5710               IF (BLIT_CMDS == 1)
1400  5710              ; *******************************************************************************************************
1401  5710              ; function rotates mask and data of several characters and applies to background data
1402  5710              ; this handles x-shift from 0 to 4
1403  5710              ; contains self-modifying code that is set-up from external function
1404  5710              ; input HL=pointer to mask data
1405  5710              ; input HL'=pointer to character data
1406  5710              ; input DE=output buffer containing background data
1407  5710              ; input BC=DE+8
1408  5710              ; input A=number of characters to process
1409  5710              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1410  5710              SHIFT04:
1411  5710 08           	EX AF, AF'
1412  5711 7E           	LD A, (HL) ; get mask
1413  5712 D9           	EXX
1414  5713 57           	LD D, A
1415  5714 1E FF        	LD E, #FF
1416  5716 37           	SCF
1417  5717              .M1:
1418  5717 18 FE        	JR .M1 ; this is self-modifying part
1419  5719 CB 1A        	RR D
1420  571B CB 1B        	RR E
1421  571D CB 1A        	RR D
1422  571F CB 1B        	RR E
1423  5721 CB 1A        	RR D
1424  5723 CB 1B        	RR E
1425  5725 CB 1A        	RR D
1426  5727 CB 1B        	RR E
1427  5729
1428  5729 46           	LD B, (HL) ; get data
1429  572A 0E 00        	LD C, 0
1430  572C              .M2:
1431  572C 18 FE        	JR .M2 ; also self-modifying part
1432  572E CB 38        	SRL B
1433  5730 CB 19        	RR C
1434  5732 CB 38        	SRL B
1435  5734 CB 19        	RR C
1436  5736 CB 38        	SRL B
1437  5738 CB 19        	RR C
1438  573A CB 38        	SRL B
1439  573C CB 19        	RR C
1440  573E
1441  573E D9           	EXX
1442  573F 1A           	LD A, (DE) ; background
1443  5740 D9           	EXX
1444  5741 A2           	AND D
1445  5742 B0           	OR B
1446  5743 D9           	EXX
1447  5744 12           	LD (DE), A
1448  5745
1449  5745 0A           	LD A, (BC)
1450  5746 D9           	EXX
1451  5747 A3           	AND E
1452  5748 B1           	OR C
1453  5749 23           	INC HL
1454  574A D9           	EXX
1455  574B 02           	LD (BC), A
1456  574C
1457  574C 23           	INC HL
1458  574D 13           	INC DE
1459  574E 03           	INC BC
1460  574F
1461  574F 08           	EX AF, AF'
1462  5750 3D           	DEC A
1463  5751 C2 10 57     	JP NZ, SHIFT04
1464  5754 C9           	RET
1465  5755              ; *******************************************************************************************************
1466  5755
1467  5755              ; *******************************************************************************************************
1468  5755              ; function rotates mask and data of several characters and applies to background data
1469  5755              ; this handles x-shift from 5 to 8
1470  5755              ; contains self-modifying code that is set-up from external function
1471  5755              ; input HL=pointer to mask data
1472  5755              ; input HL'=pointer to character data
1473  5755              ; input DE=output buffer containing background data
1474  5755              ; input BC=DE+8
1475  5755              ; input A=number of characters to process
1476  5755              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1477  5755              SHIFT58:
1478  5755 08           	EX AF, AF'
1479  5756 7E           	LD A, (HL) ; get mask
1480  5757 D9           	EXX
1481  5758 57           	LD D, A
1482  5759 1E FF        	LD E, #FF
1483  575B 37           	SCF
1484  575C              .M1:
1485  575C 18 FE        	JR .M1 ; this is self-modifying part
1486  575E CB 12        	RL D
1487  5760 CB 13        	RL E
1488  5762 CB 12        	RL D
1489  5764 CB 13        	RL E
1490  5766 CB 12        	RL D
1491  5768 CB 13        	RL E
1492  576A
1493  576A 46           	LD B, (HL)
1494  576B 0E 00        	LD C, 0
1495  576D              .M2:
1496  576D 18 FE        	JR .M2 ; also self-modifying part
1497  576F CB 20        	SLA B
1498  5771 CB 11        	RL C
1499  5773 CB 20        	SLA B
1500  5775 CB 11        	RL C
1501  5777 CB 20        	SLA B
1502  5779 CB 11        	RL C
1503  577B
1504  577B D9           	EXX
1505  577C 1A           	LD A, (DE) ; background
1506  577D D9           	EXX
1507  577E A3           	AND E
1508  577F B1           	OR C
1509  5780 D9           	EXX
1510  5781 12           	LD (DE), A
1511  5782
1512  5782 0A           	LD A, (BC)
1513  5783 D9           	EXX
1514  5784 A2           	AND D
1515  5785 B0           	OR B
1516  5786 23           	INC HL
1517  5787 D9           	EXX
1518  5788 02           	LD (BC), A
1519  5789
1520  5789 23           	INC HL
1521  578A 13           	INC DE
1522  578B 03           	INC BC
1523  578C
1524  578C 08           	EX AF, AF'
1525  578D 3D           	DEC A
1526  578E C2 55 57     	JP NZ, SHIFT58
1527  5791 C9           	RET
1528  5792              ; *******************************************************************************************************
1529  5792
1530  5792              ; *******************************************************************************************************
1531  5792              ; routine that shifts one row of characters
1532  5792              ; contains self-modifying code that is set-up from external function
1533  5792              ; input HL=pointer to mask data
1534  5792              ; input HL'=pointer to character data
1535  5792              ; input DE=output buffer containing background data
1536  5792              ; input A=number of characters to process
1537  5792              ; input IX=pointer to structure describing input data
1538  5792              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1539  5792              SHIFT_ROW:
1540  5792 F5           	PUSH AF
1541  5793 ED 53 30 51  		LD (BLIT_TMP1), DE
1542  5797 E5           		PUSH HL
1543  5798 CD DB 57     			CALL .ADDYSHIFT
1544  579B E1           		POP HL
1545  579C ED 53 32 51  		LD (BLIT_TMP2), DE ; DE+vertical shift
1546  57A0              .L1:
1547  57A0 3E 08        		LD A, 8
1548  57A2 DD 96 02     		SUB (IX+2) ; y shift
1549  57A5              .CALL1:
1550  57A5 CD 00 00     		CALL 0
1551  57A8 DD 7E 02     		LD A, (IX+2); y shift
1552  57AB B7           		OR A
1553  57AC 28 26        		JR Z, .DONE
1554  57AE ED 5B 30 51  		LD DE, (BLIT_TMP1)
1555  57B2 E5           		PUSH HL
1556  57B3 CD E9 57     			CALL .DETONEXTROW
1557  57B6 E1           		POP HL
1558  57B7              .CALL2:
1559  57B7 CD 00 00     		CALL 0
1560  57BA ED 5B 30 51  		LD DE, (BLIT_TMP1)
1561  57BE E5           		PUSH HL
1562  57BF CD E3 57     			CALL .ADD8
1563  57C2 E1           		POP HL
1564  57C3 ED 53 30 51  		LD (BLIT_TMP1), DE
1565  57C7 ED 5B 32 51  		LD DE, (BLIT_TMP2)
1566  57CB E5           		PUSH HL
1567  57CC CD E3 57     			CALL .ADD8
1568  57CF E1           		POP HL
1569  57D0 ED 53 32 51  		LD (BLIT_TMP2), DE ; DE+vertical shift
1570  57D4              .DONE:
1571  57D4 F1           	POP AF
1572  57D5 3D           	DEC A
1573  57D6 C8           	RET Z
1574  57D7 F5           	PUSH AF
1575  57D8 C3 A0 57     	JP .L1
1576  57DB              .ADDYSHIFT:
1577  57DB EB           	EX DE, HL
1578  57DC 16 00        	LD D, 0
1579  57DE DD 5E 02     	LD E, (IX+2); y shift
1580  57E1 18 0C        	JR .MOVDEBC
1581  57E3              .ADD8:
1582  57E3 21 08 00     	LD HL, 8
1583  57E6 C3 EF 57     	JP .MOVDEBC
1584  57E9              .DETONEXTROW:
1585  57E9 DD 6E 06     	LD L, (IX+6)
1586  57EC DD 66 07     	LD H, (IX+7) ; bkg add to value
1587  57EF              .MOVDEBC:
1588  57EF 19           	ADD HL, DE
1589  57F0 54           	LD D, H
1590  57F1 5D           	LD E, L
1591  57F2 01 08 00     	LD BC, 8
1592  57F5 09           	ADD HL, BC
1593  57F6 44           	LD B, H
1594  57F7 4D           	LD C, L
1595  57F8 C9           	RET
1596  57F9              ; *******************************************************************************************************
1597  57F9
1598  57F9              ; *******************************************************************************************************
1599  57F9              ; function rotates mask and character data and applies it to background
1600  57F9              ; input IX=pointer to structure describing input data
1601  57F9              ; +0  DW horizontal shift count 0-7 (low byte used)
1602  57F9              ; +2  DW vertical shift count 0-7 (low byte used)
1603  57F9              ; +4  DW background data start;
1604  57F9              ; +6  DW background add to value to next row of background data
1605  57F9              ; +8  DW mask data start;
1606  57F9              ; +10  DW character data start;
1607  57F9              ; +12 DW character&mask add to value to next row of data
1608  57F9              ; +14 DW columns (low byte used)
1609  57F9              ; +16 DW rows (low byte used)
1610  57F9              SHIFT_MERGE_CHARACTER:
1611  57F9 DD 7E 00     	LD A, (IX) ; shift
1612  57FC FE 05        	CP 5
1613  57FE 38 25        	JR C, .RIGHT
1614  5800              	; shifts 5-7, use rotate towards left 1-3
1615  5800 21 55 57     	LD HL, SHIFT58
1616  5803 22 A6 57     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1617  5806 22 B8 57     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1618  5809 D6 05        	SUB 5
1619  580B 28 0D        	JR Z, .L1
1620  580D 87           	ADD A, A
1621  580E 87           	ADD A, A
1622  580F 67           	LD H, A
1623  5810 2E 18        	LD L, #18 ; JR opcode
1624  5812 22 5C 57     	LD (SHIFT58.M1), HL
1625  5815 22 6D 57     	LD (SHIFT58.M2), HL
1626  5818 18 32        	JR .DO
1627  581A              .L1:
1628  581A 21 00 00     	LD HL, 0 ; 2xNOP opcode
1629  581D 22 5C 57     	LD (SHIFT58.M1), HL
1630  5820 22 6D 57     	LD (SHIFT58.M2), HL
1631  5823 18 27        	JR .DO
1632  5825              .RIGHT:
1633  5825              	; shifts 0-4, rotate towards right
1634  5825 21 10 57     	LD HL, SHIFT04
1635  5828 22 A6 57     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1636  582B 22 B8 57     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1637  582E FE 04        	CP 4
1638  5830 28 11        	JR Z, .R1
1639  5832 D6 04        	SUB 4
1640  5834 ED 44        	NEG
1641  5836 87           	ADD A, A
1642  5837 87           	ADD A, A
1643  5838 67           	LD H, A
1644  5839 2E 18        	LD L, #18 ; JR opcode
1645  583B 22 17 57     	LD (SHIFT04.M1), HL
1646  583E 22 2C 57     	LD (SHIFT04.M2), HL
1647  5841 18 09        	JR .DO
1648  5843              .R1:
1649  5843 21 00 00     	LD HL, 0 ; 2xNOP opcode
1650  5846 22 17 57     	LD (SHIFT04.M1), HL
1651  5849 22 2C 57     	LD (SHIFT04.M2), HL
1652  584C              .DO:
1653  584C DD 46 10     	LD B, (IX+16) ; rows
1654  584F DD 6E 08     	LD L, (IX+8)
1655  5852 DD 66 09     	LD H, (IX+9) ; mask data
1656  5855 DD 5E 04     	LD E, (IX+4)
1657  5858 DD 56 05     	LD D, (IX+5) ; background data
1658  585B D9           	EXX
1659  585C DD 6E 0A     	LD L, (IX+10)
1660  585F DD 66 0B     	LD H, (IX+11) ; character data
1661  5862 D9           	EXX
1662  5863              .LOOP:
1663  5863 C5           	PUSH BC
1664  5864 E5           		PUSH HL
1665  5865 D5           			PUSH DE
1666  5866 D9           				EXX
1667  5867 E5           				PUSH HL
1668  5868 D9           					EXX
1669  5869 DD 7E 0E     					LD A, (IX+14) ; columns
1670  586C              .CALL:
1671  586C CD 92 57     					CALL SHIFT_ROW
1672  586F E1           				POP HL
1673  5870 DD 5E 0C     				LD E, (IX+12)
1674  5873 DD 56 0D     				LD D, (IX+13) ; char data to next row
1675  5876 19           				ADD HL, DE
1676  5877 D9           				EXX
1677  5878 E1           			POP HL
1678  5879 DD 5E 06     			LD E, (IX+6)
1679  587C DD 56 07     			LD D, (IX+7) ; background to next row
1680  587F 19           			ADD HL, DE
1681  5880 EB           			EX DE, HL
1682  5881 E1           		POP HL
1683  5882 DD 4E 0C     		LD C, (IX+12)
1684  5885 DD 46 0D     		LD B, (IX+13) ; char data to next row
1685  5888 09           		ADD HL, BC
1686  5889 C1           	POP BC
1687  588A 10 D7        	DJNZ .LOOP
1688  588C C9           	RET
1689  588D              ; *******************************************************************************************************
1690  588D
1691  588D               IFNDEF CMDS_WITH_PARAMETERS
1692  588D ~            ; *******************************************************************************************************
1693  588D ~            ; function to handle CALL BLIT basic extension
1694  588D ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1695  588D ~            ; fuses with background data and applies vertical shift too
1696  588D ~            ; BLIT ( INT request_data_ptr )
1697  588D ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1698  588D ~            ; will put ram in page 0 also, page 1 is already there
1699  588D ~            BLIT:
1700  588D ~            	; opening (
1701  588D ~            	CALL CHKCHAR
1702  588D ~            	DB '('
1703  588D ~            	; get pointer to request struct
1704  588D ~            	LD IX, FRMQNT
1705  588D ~            	CALL CALBAS
1706  588D ~            	PUSH DE
1707  588D ~            	; ending )
1708  588D ~            	CALL CHKCHAR
1709  588D ~            	DB ')'
1710  588D ~
1711  588D ~            	POP IX ; pointer to request struct
1712  588D ~
1713  588D ~            	PUSH HL ; save position in BASIC buffer
1714  588D ~
1715  588D ~            	LD IY, .RET
1716  588D ~            	JP ENABLE_PAGE0
1717  588D ~            .RET:
1718  588D ~            	EI
1719  588D ~            	CALL SHIFT_MERGE_CHARACTER
1720  588D ~
1721  588D ~                POP DE
1722  588D ~                POP BC
1723  588D ~                CALL RESTORE_PAGE_INFO
1724  588D ~
1725  588D ~            	POP HL
1726  588D ~            	RET
1727  588D ~            ; *******************************************************************************************************
1728  588D               ENDIF
1729  588D
1730  588D               IFDEF CMDS_WITH_PARAMETERS
1731  588D              ; *******************************************************************************************************
1732  588D              ; function to handle CALL BLIT basic extension
1733  588D              ; rotates 1-bit character drawing horizontally with mask and character data and
1734  588D              ; fuses with background data and applies vertical shift too
1735  588D              ; in form without pointers
1736  588D              ; BLIT ( INT x,
1737  588D              ;		 INT y,
1738  588D              ;		 INT char_data_pointer,
1739  588D              ;		 INT mask_data_pointer,
1740  588D              ;		 INT width (in characters),
1741  588D              ;		 INT height (in characters),
1742  588D              ;		 INT background_pointer (top left),
1743  588D              ;		 INT background_width (in characters),
1744  588D              ;		 INT background_height (in characters))
1745  588D              ; will put ram in page 0 also, page 1 is already there
1746  588D              BLIT:
1747  588D              	; opening (
1748  588D CD A0 53     	CALL CHKCHAR
1749  5890 28           	DB '('
1750  5891              	; get x coordinate
1751  5891 DD 21 2F 54  	LD IX, FRMQNT
1752  5895 CD 59 01     	CALL CALBAS
1753  5898 7B           	LD A, E
1754  5899 E6 07        	AND 7
1755  589B 32 34 51     	LD (BLIT_STRUCT+0), A
1756  589E CD 7B 59     	CALL .DAdiv8
1757  58A1 32 30 51     	LD (BLIT_TMP+0),A
1758  58A4              	; comma
1759  58A4 CD A0 53     	CALL CHKCHAR
1760  58A7 2C           	DB ','
1761  58A8              	; get y coordinate
1762  58A8 DD 21 2F 54  	LD IX, FRMQNT
1763  58AC CD 59 01     	CALL CALBAS
1764  58AF 7B           	LD A, E
1765  58B0 E6 07        	AND 7
1766  58B2 32 36 51     	LD (BLIT_STRUCT+2), A
1767  58B5 CD 7B 59     	CALL .DAdiv8
1768  58B8 32 31 51     	LD (BLIT_TMP+1),A
1769  58BB              	; comma
1770  58BB CD A0 53     	CALL CHKCHAR
1771  58BE 2C           	DB ','
1772  58BF              	; get char data pointer
1773  58BF DD 21 2F 54  	LD IX, FRMQNT
1774  58C3 CD 59 01     	CALL CALBAS
1775  58C6 ED 53 3E 51  	LD (BLIT_STRUCT+10), DE
1776  58CA              	; comma
1777  58CA CD A0 53     	CALL CHKCHAR
1778  58CD 2C           	DB ','
1779  58CE              	; get mask data pointer
1780  58CE DD 21 2F 54  	LD IX, FRMQNT
1781  58D2 CD 59 01     	CALL CALBAS
1782  58D5 ED 53 3C 51  	LD (BLIT_STRUCT+8), DE
1783  58D9              	; comma
1784  58D9 CD A0 53     	CALL CHKCHAR
1785  58DC 2C           	DB ','
1786  58DD              	; get width
1787  58DD DD 21 2F 54  	LD IX, FRMQNT
1788  58E1 CD 59 01     	CALL CALBAS
1789  58E4 7B           	LD A, E
1790  58E5 32 42 51     	LD (BLIT_STRUCT+14), A
1791  58E8              	; comma
1792  58E8 CD A0 53     	CALL CHKCHAR
1793  58EB 2C           	DB ','
1794  58EC              	; get height
1795  58EC DD 21 2F 54  	LD IX, FRMQNT
1796  58F0 CD 59 01     	CALL CALBAS
1797  58F3 7B           	LD A, E
1798  58F4 32 44 51     	LD (BLIT_STRUCT+16), A
1799  58F7              	; comma
1800  58F7 CD A0 53     	CALL CHKCHAR
1801  58FA 2C           	DB ','
1802  58FB              	; get background pointer
1803  58FB DD 21 2F 54  	LD IX, FRMQNT
1804  58FF CD 59 01     	CALL CALBAS
1805  5902 ED 53 38 51  	LD (BLIT_STRUCT+4), DE
1806  5906              	; comma
1807  5906 CD A0 53     	CALL CHKCHAR
1808  5909 2C           	DB ','
1809  590A              	; get background width
1810  590A DD 21 2F 54  	LD IX, FRMQNT
1811  590E CD 59 01     	CALL CALBAS
1812  5911 7B           	LD A, E
1813  5912 32 32 51     	LD (BLIT_TMP+2), A
1814  5915              	; comma
1815  5915 CD A0 53     	CALL CHKCHAR
1816  5918 2C           	DB ','
1817  5919              	; get background height
1818  5919 DD 21 2F 54  	LD IX, FRMQNT
1819  591D CD 59 01     	CALL CALBAS
1820  5920 7B           	LD A, E
1821  5921 32 33 51     	LD (BLIT_TMP+3), A
1822  5924              	; ending )
1823  5924 CD A0 53     	CALL CHKCHAR
1824  5927 29           	DB ')'
1825  5928
1826  5928 E5           	PUSH HL ; save position in BASIC buffer
1827  5929
1828  5929              	; calculate char&mask add to value
1829  5929 26 00        	LD H, 0
1830  592B 3A 42 51     	LD A, (BLIT_STRUCT+14)
1831  592E 6F           	LD L, A
1832  592F CD 8F 52     	CALL HLx8
1833  5932 22 40 51     	LD (BLIT_STRUCT+12), HL
1834  5935              	; calculate background add to value
1835  5935 26 00        	LD H, 0
1836  5937 3A 32 51     	LD A, (BLIT_TMP+2)
1837  593A 6F           	LD L, A
1838  593B CD 8F 52     	CALL HLx8
1839  593E 22 3A 51     	LD (BLIT_STRUCT+6), HL
1840  5941              	; calculate pointer to background location
1841  5941 21 00 00     	LD HL, 0
1842  5944 3A 31 51     	LD A,(BLIT_TMP+1)
1843  5947 B7           	OR A
1844  5948 28 08        	JR Z, .L1
1845  594A 47           	LD B,A
1846  594B ED 5B 3A 51  	LD DE,(BLIT_STRUCT+6)
1847  594F              .L0:
1848  594F 19           	ADD HL, DE
1849  5950 10 FD        	DJNZ .L0
1850  5952              .L1:
1851  5952 EB           	EX DE,HL
1852  5953 26 00        	LD H,0
1853  5955 3A 30 51     	LD A,(BLIT_TMP+0)
1854  5958 6F           	LD L,A
1855  5959 CD 8F 52     	CALL HLx8
1856  595C 19           	ADD HL,DE
1857  595D ED 5B 38 51  	LD DE,(BLIT_STRUCT+4)
1858  5961 19           	ADD HL,DE
1859  5962 22 38 51     	LD (BLIT_STRUCT+4),HL
1860  5965
1861  5965 FD 21 6C 59  	LD IY, .RET
1862  5969 C3 53 53     	JP ENABLE_PAGE0
1863  596C              .RET:
1864  596C FB           	EI
1865  596D DD 21 34 51  	LD IX, BLIT_STRUCT
1866  5971 CD F9 57     	CALL SHIFT_MERGE_CHARACTER
1867  5974
1868  5974 D1               POP DE
1869  5975 C1               POP BC
1870  5976 CD CA 52         CALL RESTORE_PAGE_INFO
1871  5979
1872  5979 E1           	POP HL
1873  597A C9           	RET
1874  597B              .DAdiv8:
1875  597B 7B           	LD A,E
1876  597C CB 2A        	SRA D
1877  597E CB 1F            RR  A
1878  5980 CB 2A            SRA D
1879  5982 CB 1F            RR  A
1880  5984 CB 2A            SRA D
1881  5986 CB 1F            RR  A
1882  5988 C9           	RET
1883  5989              ; *******************************************************************************************************
1884  5989               ENDIF
1885  5989               ENDIF
1886  5989
1887  5989               IF (TILE_CMDS == 1)
1888  5989              ; *******************************************************************************************************
1889  5989              ; generic function to implement tiling
1890  5989              ; should be modified to call appropriate function for memory or vram
1891  5989              ; input IX=pointer to following structure
1892  5989              ; +00 tile_data_ptr
1893  5989              ; +02 tile_rows
1894  5989              ; +04 tile_columns
1895  5989              ; +06 destination_address
1896  5989              ; +08 dest_to_next_row_add_to_value
1897  5989              ; +10 num_horizontal_tiles
1898  5989              ; +12 num_vertical_tiles
1899  5989              ; modifies AF, BC, DE, HL
1900  5989              TILE:
1901  5989 DD 6E 06     	LD L, (IX+6)
1902  598C DD 66 07     	LD H, (IX+7) ; destination address
1903  598F 22 30 51     	LD (TILETMP1), HL
1904  5992 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1905  5995              .L1:
1906  5995 C5           	PUSH BC
1907  5996 DD 6E 00     		LD L, (IX+0)
1908  5999 DD 66 01     		LD H, (IX+1) ; tile address
1909  599C 22 32 51     		LD (TILETMP2), HL
1910  599F DD 46 02     		LD B, (IX+2) ; tile rows
1911  59A2              .L2:
1912  59A2 C5           		PUSH BC
1913  59A3              .CALL1:
1914  59A3 CD 00 00     			CALL 0
1915  59A6 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1916  59A9              .L3:
1917  59A9 C5           			PUSH BC
1918  59AA 2A 32 51     				LD HL, (TILETMP2)
1919  59AD DD 46 04     				LD B, (IX+4) ; tile columns
1920  59B0              .L4:
1921  59B0 C5           				PUSH BC
1922  59B1              .CALL2:
1923  59B1 CD 00 00     					CALL 0
1924  59B4 C1           				POP BC
1925  59B5 10 F9        				DJNZ .L4
1926  59B7 C1           			POP BC
1927  59B8 10 EF        			DJNZ .L3
1928  59BA 22 32 51     			LD (TILETMP2), HL
1929  59BD 2A 30 51     			LD HL, (TILETMP1)
1930  59C0 DD 5E 08     			LD E, (IX+8)
1931  59C3 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1932  59C6 19           			ADD HL, DE
1933  59C7 22 30 51     			LD (TILETMP1), HL
1934  59CA C1           		POP BC
1935  59CB 10 D5        		DJNZ .L2
1936  59CD C1           	POP BC
1937  59CE 10 C5        	DJNZ .L1
1938  59D0 C9           	RET
1939  59D1              ; *******************************************************************************************************
1940  59D1
1941  59D1               IFNDEF CMDS_WITH_PARAMETERS
1942  59D1 ~            ; *******************************************************************************************************
1943  59D1 ~            ; function to handle CALL TILERAM basic extension
1944  59D1 ~            ; fills memory with tiles
1945  59D1 ~            ; TILERAM ( INT request_data_ptr )
1946  59D1 ~            ; request_data_ptr described in TILE
1947  59D1 ~            ; will put ram in page 0 also, page 1 is already there
1948  59D1 ~            TILERAM:
1949  59D1 ~            	; opening (
1950  59D1 ~            	CALL CHKCHAR
1951  59D1 ~            	DB '('
1952  59D1 ~            	; get pointer to request struct
1953  59D1 ~            	LD IX, FRMQNT
1954  59D1 ~            	CALL CALBAS
1955  59D1 ~            	PUSH DE
1956  59D1 ~            	; ending )
1957  59D1 ~            	CALL CHKCHAR
1958  59D1 ~            	DB ')'
1959  59D1 ~
1960  59D1 ~            	POP IX ; pointer to request struct
1961  59D1 ~
1962  59D1 ~            	PUSH HL ; save position in BASIC buffer
1963  59D1 ~
1964  59D1 ~            	LD IY, .RET
1965  59D1 ~            	JP ENABLE_PAGE0
1966  59D1 ~            .RET:
1967  59D1 ~            	EI
1968  59D1 ~            	; set RAM functions to call
1969  59D1 ~            	LD HL, .TILECOPY
1970  59D1 ~            	LD (TILE.CALL2+1), HL
1971  59D1 ~            	LD HL, .SETDESTROW
1972  59D1 ~            	LD (TILE.CALL1+1), HL
1973  59D1 ~            	CALL TILE
1974  59D1 ~
1975  59D1 ~                POP DE
1976  59D1 ~                POP BC
1977  59D1 ~                CALL RESTORE_PAGE_INFO
1978  59D1 ~
1979  59D1 ~            	POP HL
1980  59D1 ~            	RET
1981  59D1 ~            .TILECOPY:
1982  59D1 ~            	.8 LDI
1983  59D1 ~            	RET
1984  59D1 ~            .SETDESTROW:
1985  59D1 ~            	LD DE, (TILETMP1)
1986  59D1 ~            	RET
1987  59D1 ~            ; *******************************************************************************************************
1988  59D1               ENDIF
1989  59D1
1990  59D1               IFDEF CMDS_WITH_PARAMETERS
1991  59D1              ; *******************************************************************************************************
1992  59D1              ; function to handle CALL TILERAM basic extension
1993  59D1              ; fills memory with tiles
1994  59D1              ; TILERAM ( INT tile_data_pointer,
1995  59D1              ;			INT tile_columns,
1996  59D1              ;			INT tile_rows,
1997  59D1              ;			INT destination_pointer,
1998  59D1              ;			INT destination_columns,
1999  59D1              ;			INT destination_rows,
2000  59D1              ;			INT destination_begin_column,
2001  59D1              ;			INT destination_begin_row,
2002  59D1              ;			INT number_of_tiles_horizontally,
2003  59D1              ;			INT	number_of_tiles_vertically )
2004  59D1              ; will put ram in page 0 also, page 1 is already there
2005  59D1              TILERAM:
2006  59D1              	; opening (
2007  59D1 CD A0 53     	CALL CHKCHAR
2008  59D4 28           	DB '('
2009  59D5              	; get tile data pointer coordinate
2010  59D5 DD 21 2F 54  	LD IX, FRMQNT
2011  59D9 CD 59 01     	CALL CALBAS
2012  59DC ED 53 34 51  	LD (BLIT_STRUCT+0), DE
2013  59E0              	; comma
2014  59E0 CD A0 53     	CALL CHKCHAR
2015  59E3 2C           	DB ','
2016  59E4              	; get tile columns
2017  59E4 DD 21 2F 54  	LD IX, FRMQNT
2018  59E8 CD 59 01     	CALL CALBAS
2019  59EB ED 53 38 51  	LD (BLIT_STRUCT+4), DE
2020  59EF              	; comma
2021  59EF CD A0 53     	CALL CHKCHAR
2022  59F2 2C           	DB ','
2023  59F3              	; get tile columns
2024  59F3 DD 21 2F 54  	LD IX, FRMQNT
2025  59F7 CD 59 01     	CALL CALBAS
2026  59FA ED 53 36 51  	LD (BLIT_STRUCT+2), DE
2027  59FE              	; comma
2028  59FE CD A0 53     	CALL CHKCHAR
2029  5A01 2C           	DB ','
2030  5A02              	; get destintion pointer
2031  5A02 DD 21 2F 54  	LD IX, FRMQNT
2032  5A06 CD 59 01     	CALL CALBAS
2033  5A09 ED 53 3A 51  	LD (BLIT_STRUCT+6), DE
2034  5A0D              	; comma
2035  5A0D CD A0 53     	CALL CHKCHAR
2036  5A10 2C           	DB ','
2037  5A11              	; get destination columns
2038  5A11 DD 21 2F 54  	LD IX, FRMQNT
2039  5A15 CD 59 01     	CALL CALBAS
2040  5A18 7B           	LD A, E
2041  5A19 32 30 51     	LD (BLIT_TMP+0), A
2042  5A1C              	; comma
2043  5A1C CD A0 53     	CALL CHKCHAR
2044  5A1F 2C           	DB ','
2045  5A20              	; get destination rows
2046  5A20 DD 21 2F 54  	LD IX, FRMQNT
2047  5A24 CD 59 01     	CALL CALBAS
2048  5A27 7B           	LD A, E
2049  5A28 32 31 51     	LD (BLIT_TMP+1), A
2050  5A2B              	; comma
2051  5A2B CD A0 53     	CALL CHKCHAR
2052  5A2E 2C           	DB ','
2053  5A2F              	; get destination begin column
2054  5A2F DD 21 2F 54  	LD IX, FRMQNT
2055  5A33 CD 59 01     	CALL CALBAS
2056  5A36 7B           	LD A, E
2057  5A37 32 32 51     	LD (BLIT_TMP+2), A
2058  5A3A              	; comma
2059  5A3A CD A0 53     	CALL CHKCHAR
2060  5A3D 2C           	DB ','
2061  5A3E              	; get destination begin row
2062  5A3E DD 21 2F 54  	LD IX, FRMQNT
2063  5A42 CD 59 01     	CALL CALBAS
2064  5A45 7B           	LD A, E
2065  5A46 32 33 51     	LD (BLIT_TMP+3), A
2066  5A49              	; comma
2067  5A49 CD A0 53     	CALL CHKCHAR
2068  5A4C 2C           	DB ','
2069  5A4D              	; get number of tiles horizontally
2070  5A4D DD 21 2F 54  	LD IX, FRMQNT
2071  5A51 CD 59 01     	CALL CALBAS
2072  5A54 ED 53 3E 51  	LD (BLIT_STRUCT+10), DE
2073  5A58              	; comma
2074  5A58 CD A0 53     	CALL CHKCHAR
2075  5A5B 2C           	DB ','
2076  5A5C              	; get number of tiles vertically
2077  5A5C DD 21 2F 54  	LD IX, FRMQNT
2078  5A60 CD 59 01     	CALL CALBAS
2079  5A63 ED 53 40 51  	LD (BLIT_STRUCT+12), DE
2080  5A67              	; ending )
2081  5A67 CD A0 53     	CALL CHKCHAR
2082  5A6A 29           	DB ')'
2083  5A6B
2084  5A6B E5           	PUSH HL ; save position in BASIC buffer
2085  5A6C
2086  5A6C              	; calculate destination add to value
2087  5A6C 26 00        	LD H, 0
2088  5A6E 3A 30 51     	LD A, (BLIT_TMP+0)
2089  5A71 6F           	LD L, A
2090  5A72 CD 8F 52     	CALL HLx8
2091  5A75 22 3C 51     	LD (BLIT_STRUCT+8), HL
2092  5A78              	; calculate pointer to background location
2093  5A78 21 00 00     	LD HL, 0
2094  5A7B 3A 33 51     	LD A,(BLIT_TMP+3)
2095  5A7E B7           	OR A
2096  5A7F 28 08        	JR Z, .L1
2097  5A81 47           	LD B,A
2098  5A82 ED 5B 3C 51  	LD DE,(BLIT_STRUCT+8)
2099  5A86              .L0:
2100  5A86 19           	ADD HL, DE
2101  5A87 10 FD        	DJNZ .L0
2102  5A89              .L1:
2103  5A89 EB           	EX DE,HL
2104  5A8A 26 00        	LD H,0
2105  5A8C 3A 32 51     	LD A,(BLIT_TMP+2)
2106  5A8F 6F           	LD L,A
2107  5A90 CD 8F 52     	CALL HLx8
2108  5A93 19           	ADD HL,DE
2109  5A94 ED 5B 3A 51  	LD DE,(BLIT_STRUCT+6)
2110  5A98 19           	ADD HL,DE
2111  5A99 22 3A 51     	LD (BLIT_STRUCT+6),HL
2112  5A9C
2113  5A9C FD 21 A3 5A  	LD IY, .RET
2114  5AA0 C3 53 53     	JP ENABLE_PAGE0
2115  5AA3              .RET:
2116  5AA3 FB           	EI
2117  5AA4              	; set RAM functions to call
2118  5AA4 21 BE 5A     	LD HL, .TILECOPY
2119  5AA7 22 B2 59     	LD (TILE.CALL2+1), HL
2120  5AAA 21 CF 5A     	LD HL, .SETDESTROW
2121  5AAD 22 A4 59     	LD (TILE.CALL1+1), HL
2122  5AB0 DD 21 34 51  	LD IX,BLIT_STRUCT
2123  5AB4 CD 89 59     	CALL TILE
2124  5AB7
2125  5AB7 D1               POP DE
2126  5AB8 C1               POP BC
2127  5AB9 CD CA 52         CALL RESTORE_PAGE_INFO
2128  5ABC
2129  5ABC E1           	POP HL
2130  5ABD C9           	RET
2131  5ABE              .TILECOPY:
2132  5ABE ED A0       > LDI
2132  5AC0 ED A0       > LDI
2132  5AC2 ED A0       > LDI
2132  5AC4 ED A0       > LDI
2132  5AC6 ED A0       > LDI
2132  5AC8 ED A0       > LDI
2132  5ACA ED A0       > LDI
2132  5ACC ED A0       > LDI
2133  5ACE C9           	RET
2134  5ACF              .SETDESTROW:
2135  5ACF ED 5B 30 51  	LD DE, (TILETMP1)
2136  5AD3 C9           	RET
2137  5AD4              ; *******************************************************************************************************
2138  5AD4               ENDIF
2139  5AD4
2140  5AD4               IFDEF CMDS_WITH_PARAMETERS
2141  5AD4              ; *******************************************************************************************************
2142  5AD4              ; function to handle CALL TILEVRM basic extension
2143  5AD4              ; fills vram with tiles
2144  5AD4              ; TILEVRM ( INT tile_data_pointer,
2145  5AD4              ;			INT tile_columns,
2146  5AD4              ;			INT tile_rows,
2147  5AD4              ;			INT destination_begin_column,
2148  5AD4              ;			INT destination_begin_row,
2149  5AD4              ;			INT number_of_tiles_horizontally,
2150  5AD4              ;			INT	number_of_tiles_vertically )
2151  5AD4              ; will put ram in page 0 also, page 1 is already there
2152  5AD4              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2153  5AD4              TILEVRM:
2154  5AD4              	; opening (
2155  5AD4 CD A0 53     	CALL CHKCHAR
2156  5AD7 28           	DB '('
2157  5AD8              	; get tile data pointer coordinate
2158  5AD8 DD 21 2F 54  	LD IX, FRMQNT
2159  5ADC CD 59 01     	CALL CALBAS
2160  5ADF ED 53 34 51  	LD (BLIT_STRUCT+0), DE
2161  5AE3              	; comma
2162  5AE3 CD A0 53     	CALL CHKCHAR
2163  5AE6 2C           	DB ','
2164  5AE7              	; get tile columns
2165  5AE7 DD 21 2F 54  	LD IX, FRMQNT
2166  5AEB CD 59 01     	CALL CALBAS
2167  5AEE ED 53 38 51  	LD (BLIT_STRUCT+4), DE
2168  5AF2              	; comma
2169  5AF2 CD A0 53     	CALL CHKCHAR
2170  5AF5 2C           	DB ','
2171  5AF6              	; get tile columns
2172  5AF6 DD 21 2F 54  	LD IX, FRMQNT
2173  5AFA CD 59 01     	CALL CALBAS
2174  5AFD ED 53 36 51  	LD (BLIT_STRUCT+2), DE
2175  5B01              	; comma
2176  5B01 CD A0 53     	CALL CHKCHAR
2177  5B04 2C           	DB ','
2178  5B05              	; get destination begin column
2179  5B05 DD 21 2F 54  	LD IX, FRMQNT
2180  5B09 CD 59 01     	CALL CALBAS
2181  5B0C 7B           	LD A, E
2182  5B0D 32 32 51     	LD (BLIT_TMP+2), A
2183  5B10              	; comma
2184  5B10 CD A0 53     	CALL CHKCHAR
2185  5B13 2C           	DB ','
2186  5B14              	; get destination begin row
2187  5B14 DD 21 2F 54  	LD IX, FRMQNT
2188  5B18 CD 59 01     	CALL CALBAS
2189  5B1B 7B           	LD A, E
2190  5B1C 32 33 51     	LD (BLIT_TMP+3), A
2191  5B1F              	; comma
2192  5B1F CD A0 53     	CALL CHKCHAR
2193  5B22 2C           	DB ','
2194  5B23              	; get number of tiles horizontally
2195  5B23 DD 21 2F 54  	LD IX, FRMQNT
2196  5B27 CD 59 01     	CALL CALBAS
2197  5B2A ED 53 3E 51  	LD (BLIT_STRUCT+10), DE
2198  5B2E              	; comma
2199  5B2E CD A0 53     	CALL CHKCHAR
2200  5B31 2C           	DB ','
2201  5B32              	; get number of tiles vertically
2202  5B32 DD 21 2F 54  	LD IX, FRMQNT
2203  5B36 CD 59 01     	CALL CALBAS
2204  5B39 ED 53 40 51  	LD (BLIT_STRUCT+12), DE
2205  5B3D              	; ending )
2206  5B3D CD A0 53     	CALL CHKCHAR
2207  5B40 29           	DB ')'
2208  5B41
2209  5B41 E5           	PUSH HL ; save position in BASIC buffer
2210  5B42
2211  5B42              	; calculate destination add to value
2212  5B42 21 00 01     	LD HL, 256
2213  5B45 22 3C 51     	LD (BLIT_STRUCT+8), HL
2214  5B48              	; calculate pointer to background location
2215  5B48 3A 33 51     	LD A,(BLIT_TMP+3)
2216  5B4B 67           	LD H,A
2217  5B4C 2E 00        	LD L,0
2218  5B4E EB           	EX DE,HL
2219  5B4F 26 00        	LD H,0
2220  5B51 3A 32 51     	LD A,(BLIT_TMP+2)
2221  5B54 6F           	LD L,A
2222  5B55 CD 8F 52     	CALL HLx8
2223  5B58 19           	ADD HL,DE
2224  5B59 ED 5B CB F3  	LD DE,(GRPCGP)
2225  5B5D 19           	ADD HL,DE
2226  5B5E 22 3A 51     	LD (BLIT_STRUCT+6),HL
2227  5B61
2228  5B61 FD 21 68 5B  	LD IY, .RET
2229  5B65 C3 53 53     	JP ENABLE_PAGE0
2230  5B68              .RET:
2231  5B68 FB           	EI
2232  5B69              	; set RAM functions to call
2233  5B69 21 83 5B     	LD HL, .TILECOPY
2234  5B6C 22 B2 59     	LD (TILE.CALL2+1), HL
2235  5B6F 21 89 5B     	LD HL, .SETDESTROW
2236  5B72 22 A4 59     	LD (TILE.CALL1+1), HL
2237  5B75 DD 21 34 51  	LD IX,BLIT_STRUCT
2238  5B79 CD 89 59     	CALL TILE
2239  5B7C
2240  5B7C D1               POP DE
2241  5B7D C1               POP BC
2242  5B7E CD CA 52         CALL RESTORE_PAGE_INFO
2243  5B81
2244  5B81 E1           	POP HL
2245  5B82 C9           	RET
2246  5B83              .TILECOPY:
2247  5B83 01 98 08     	LD BC, #0898
2248  5B86 C3 88 52     	JP BBYTECOPY
2249  5B89              .SETDESTROW:
2250  5B89 2A 30 51     	LD HL, (TILETMP1)
2251  5B8C F3           	DI
2252  5B8D CD 7D 52     	CALL SETWRT_LOCAL
2253  5B90 FB           	EI
2254  5B91 C9           	RET
2255  5B92              ; *******************************************************************************************************
2256  5B92               ENDIF
2257  5B92
2258  5B92               IFNDEF CMDS_WITH_PARAMETERS
2259  5B92 ~            ; *******************************************************************************************************
2260  5B92 ~            ; function to handle CALL TILEVRM basic extension
2261  5B92 ~            ; fills vram with tiles
2262  5B92 ~            ; TILEVRM ( INT request_data_ptr )
2263  5B92 ~            ; request_data_ptr described in TILE
2264  5B92 ~            ; will put ram in page 0 also, page 1 is already there
2265  5B92 ~            TILEVRM:
2266  5B92 ~            	; opening (
2267  5B92 ~            	CALL CHKCHAR
2268  5B92 ~            	DB '('
2269  5B92 ~            	; get pointer to request struct
2270  5B92 ~            	LD IX, FRMQNT
2271  5B92 ~            	CALL CALBAS
2272  5B92 ~            	PUSH DE
2273  5B92 ~            	; ending )
2274  5B92 ~            	CALL CHKCHAR
2275  5B92 ~            	DB ')'
2276  5B92 ~
2277  5B92 ~            	POP IX ; pointer to request struct
2278  5B92 ~
2279  5B92 ~            	PUSH HL ; save position in BASIC buffer
2280  5B92 ~
2281  5B92 ~            	LD IY, .RET
2282  5B92 ~            	JP ENABLE_PAGE0
2283  5B92 ~            .RET:
2284  5B92 ~            	EI
2285  5B92 ~            	; set RAM functions to call
2286  5B92 ~            	LD HL, .TILECOPY
2287  5B92 ~            	LD (TILE.CALL2+1), HL
2288  5B92 ~            	LD HL, .SETDESTROW
2289  5B92 ~            	LD (TILE.CALL1+1), HL
2290  5B92 ~            	CALL TILE
2291  5B92 ~
2292  5B92 ~                POP DE
2293  5B92 ~                POP BC
2294  5B92 ~                CALL RESTORE_PAGE_INFO
2295  5B92 ~
2296  5B92 ~            	POP HL
2297  5B92 ~            	RET
2298  5B92 ~            .TILECOPY:
2299  5B92 ~            	LD BC, #0898
2300  5B92 ~            	JP BBYTECOPY
2301  5B92 ~            .SETDESTROW:
2302  5B92 ~            	LD HL, (TILETMP1)
2303  5B92 ~            	DI
2304  5B92 ~            	CALL SETWRT_LOCAL
2305  5B92 ~            	EI
2306  5B92 ~            	RET
2307  5B92 ~            ; *******************************************************************************************************
2308  5B92               ENDIF
2309  5B92               ENDIF
2310  5B92
2311  5B92               IF (BOX_CMDS == 1)
2312  5B92              ; *******************************************************************************************************
2313  5B92              ; generic function to implement rectangle data copy
2314  5B92              ; should be modified to call appropriate function for memory or vram
2315  5B92              ; input IX=pointer to following structure
2316  5B92              ; +00 source data pointer
2317  5B92              ; +02 num bytes in a row
2318  5B92              ; +04 number of rows
2319  5B92              ; +06 source add-to value till next row
2320  5B92              ; +08 destination address
2321  5B92              ; +10 destination add-to value till next row
2322  5B92              ; modifies AF, BC, DE, HL
2323  5B92              RECTANGLE_COPY:
2324  5B92 DD 6E 00     	LD L, (IX+0)
2325  5B95 DD 66 01     	LD H, (IX+1) ; source address
2326  5B98 DD 5E 08     	LD E, (IX+8)
2327  5B9B DD 56 09     	LD D, (IX+9) ; destination
2328  5B9E DD 46 04     	LD B, (IX+4) ; row number
2329  5BA1              .L1:
2330  5BA1 C5           	PUSH BC
2331  5BA2 E5           		PUSH HL
2332  5BA3 D5           			PUSH DE
2333  5BA4 DD 4E 02     				LD C, (IX+2)
2334  5BA7 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2335  5BAA              .CALL1:
2336  5BAA CD 00 00     				CALL 0 ; set destination address from DE
2337  5BAD              .CALL2:
2338  5BAD CD 00 00     				CALL 0 ; copy data fn
2339  5BB0 E1           			POP HL
2340  5BB1 DD 4E 0A     			LD C, (IX+10)
2341  5BB4 DD 46 0B     			LD B, (IX+11) ; destination add-to
2342  5BB7 09           			ADD HL, BC
2343  5BB8 EB           			EX DE, HL
2344  5BB9 E1           		POP HL
2345  5BBA DD 4E 06     		LD C, (IX+6)
2346  5BBD DD 46 07     		LD B, (IX+7) ; src add-to
2347  5BC0 09           		ADD HL, BC
2348  5BC1 C1           	POP BC
2349  5BC2 10 DD        	DJNZ .L1
2350  5BC4 C9           	RET
2351  5BC5              ; *******************************************************************************************************
2352  5BC5
2353  5BC5              ; *******************************************************************************************************
2354  5BC5              ; function to handle CALL BOXMEMCPY basic extension
2355  5BC5              ; copies data with window like boundaries to ram
2356  5BC5              ; BOXMEMCPY ( INT request_data_ptr )
2357  5BC5              ; request_data_ptr described in RECTANGLE_COPY
2358  5BC5              ; will put ram in page 0 also, page 1 is already there
2359  5BC5              BOXMEMCPY:
2360  5BC5              	; opening (
2361  5BC5 CD A0 53     	CALL CHKCHAR
2362  5BC8 28           	DB '('
2363  5BC9              	; get pointer to request struct
2364  5BC9 DD 21 2F 54  	LD IX, FRMQNT
2365  5BCD CD 59 01     	CALL CALBAS
2366  5BD0 D5           	PUSH DE
2367  5BD1              	; ending )
2368  5BD1 CD A0 53     	CALL CHKCHAR
2369  5BD4 29           	DB ')'
2370  5BD5
2371  5BD5 DD E1        	POP IX ; pointer to request struct
2372  5BD7
2373  5BD7 E5           	PUSH HL ; save position in BASIC buffer
2374  5BD8
2375  5BD8 FD 21 DF 5B  	LD IY, .RET
2376  5BDC C3 53 53     	JP ENABLE_PAGE0
2377  5BDF              .RET:
2378  5BDF FB           	EI
2379  5BE0              	; set RAM functions to call
2380  5BE0 21 00 00     	LD HL, 0
2381  5BE3 22 AA 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2382  5BE6 22 AC 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2383  5BE9 21 ED B0     	LD HL, #B0ED ; LDIR
2384  5BEC 22 AE 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
2385  5BEF CD 92 5B     	CALL RECTANGLE_COPY
2386  5BF2
2387  5BF2 D1               POP DE
2388  5BF3 C1               POP BC
2389  5BF4 CD CA 52         CALL RESTORE_PAGE_INFO
2390  5BF7
2391  5BF7 E1           	POP HL
2392  5BF8 C9           	RET
2393  5BF9              ; *******************************************************************************************************
2394  5BF9
2395  5BF9              ; *******************************************************************************************************
2396  5BF9              ; function to handle CALL BOXMEMVRM basic extension
2397  5BF9              ; copies data with window like boundaries to ram
2398  5BF9              ; BOXMEMVRM ( INT request_data_ptr )
2399  5BF9              ; request_data_ptr described in RECTANGLE_COPY
2400  5BF9              ; will put ram in page 0 also, page 1 is already there
2401  5BF9              BOXMEMVRM:
2402  5BF9              	; opening (
2403  5BF9 CD A0 53     	CALL CHKCHAR
2404  5BFC 28           	DB '('
2405  5BFD              	; get pointer to request struct
2406  5BFD DD 21 2F 54  	LD IX, FRMQNT
2407  5C01 CD 59 01     	CALL CALBAS
2408  5C04 D5           	PUSH DE
2409  5C05              	; ending )
2410  5C05 CD A0 53     	CALL CHKCHAR
2411  5C08 29           	DB ')'
2412  5C09
2413  5C09 DD E1        	POP IX ; pointer to request struct
2414  5C0B
2415  5C0B E5           	PUSH HL ; save position in BASIC buffer
2416  5C0C
2417  5C0C FD 21 13 5C  	LD IY, .RET
2418  5C10 C3 53 53     	JP ENABLE_PAGE0
2419  5C13              .RET:
2420  5C13 FB           	EI
2421  5C14              	; set RAM functions to call
2422  5C14 21 32 5C     	LD HL, .SETDEST
2423  5C17 22 AB 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
2424  5C1A 21 3A 5C     	LD HL, .COPYDATA
2425  5C1D 22 AE 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
2426  5C20 3E CD        	LD A, #CD ; CALL
2427  5C22 32 AA 5B     	LD (RECTANGLE_COPY.CALL1), A
2428  5C25 32 AD 5B     	LD (RECTANGLE_COPY.CALL2), A
2429  5C28 CD 92 5B     	CALL RECTANGLE_COPY
2430  5C2B
2431  5C2B D1               POP DE
2432  5C2C C1               POP BC
2433  5C2D CD CA 52         CALL RESTORE_PAGE_INFO
2434  5C30
2435  5C30 E1           	POP HL
2436  5C31 C9           	RET
2437  5C32              .SETDEST:
2438  5C32 EB           	EX DE, HL
2439  5C33 F3           	DI
2440  5C34 CD 7D 52     	CALL SETWRT_LOCAL
2441  5C37 FB           	EI
2442  5C38 EB           	EX DE, HL
2443  5C39 C9           	RET
2444  5C3A              .COPYDATA:
2445  5C3A 41           	LD B, C
2446  5C3B 0E 98        	LD C, #98
2447  5C3D C3 88 52     	JP BBYTECOPY
2448  5C40              ; *******************************************************************************************************
2449  5C40               ENDIF
2450  5C40
2451  5C40              EXT_END:
2452  5C40
# file closed: asm\main.asm
