# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000
  13  4000               DEFINE CMDS_WITH_PARAMETERS
  14  4000
  15  4000              CHPUT   EQU     #A2
  16  4000              CALBAS	EQU		#159
  17  4000              ERRHAND EQU     #406F
  18  4000              FRMEVL  EQU     #4C64
  19  4000              FRESTR	EQU		#67D0
  20  4000              ; FRMQNT = formula quantificator
  21  4000              ; input HL=pointer to current program expression
  22  4000              ; output HL=next address
  23  4000              ; output DE=integer datum
  24  4000              FRMQNT	EQU		#542F
  25  4000              ; GETBYT = get byte parameter
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output A=E=byte read
  29  4000              GETBYT		EQU		#521C
  30  4000              CHRGTR  	EQU     #4666
  31  4000              SYNCHR		EQU		#558C
  32  4000              VALTYP  	EQU     #F663
  33  4000              USR     	EQU     #F7F8
  34  4000              PROCNM		EQU		#FD89
  35  4000              BIOS_FILVRM EQU     #0056
  36  4000              CLIKSW		EQU		#F3DB
  37  4000              ATRBAS		EQU		#F928
  38  4000              GRPCGP		EQU		#F3CB
  39  4000
  40  4000              RAMAD0	EQU	0F341h	; Main-RAM Slot (00000h~03FFFh)
  41  4000              RAMAD1	EQU	0F342h	; Main-RAM Slot (04000h~07FFFh)
  42  4000              RAMAD2	EQU	0F343h	; Main-RAM Slot (08000h~0BFFFh)
  43  4000              RAMAD3	EQU	0F344h	; Main-RAM Slot (0C000h~0FFFFh)
  44  4000              EXPTBL	EQU #FCC1
  45  4000              SCRMOD	EQU #FCAF ; current screen mode
  46  4000              REG1SAV EQU #F3E0 ; VDP(1)
  47  4000
  48  4000              ; BASIC error codes
  49  4000              ;01 NEXT without FOR
  50  4000              ;02 Syntax error
  51  4000              ;03 RETURN without GOSUB
  52  4000              ;04 Out of DATA
  53  4000              ;05 Illegal function call
  54  4000              ;06 Overflow
  55  4000              ;07 Out of memory
  56  4000              ;08 Undefined line number
  57  4000              ;09 Subscript out of range
  58  4000              ;10 Redimensioned array
  59  4000              ;11 Division by zero
  60  4000              ;12 Illegal direct
  61  4000              ;13 Type mismatch
  62  4000              ;14 Out of string space
  63  4000              ;15 String too long
  64  4000              ;16 String formula too complex
  65  4000              ;17 Can't CONTINUE
  66  4000              ;18 Undefined user function
  67  4000              ;19 Device I/O error
  68  4000              ;20 Verify error
  69  4000              ;21 No RESUME
  70  4000              ;22 RESUME without error
  71  4000              ;23 Unprintable error
  72  4000              ;24 Missing operand
  73  4000              ;25 Line buffer overflow
  74  4000              ;50 FIELD overflow
  75  4000              ;51 Internal error
  76  4000              ;52 Bad file number
  77  4000              ;53 File not found
  78  4000              ;54 File already open
  79  4000              ;55 Input past end
  80  4000              ;56 Bad file name
  81  4000              ;57 Direct statement in file
  82  4000              ;58 Sequential I/O only
  83  4000              ;59 File not OPEN
  84  4000
  85  4000
  86  4000               ; simulate cartridge with BASIC extension
  87  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  87  4004 B1 4F 00 00
  87  4008 00 00 00 00
  87  400C 00 00 00 00
  88  4010
  89  4010              ; this location #4010 stores last location used by basic extension
  90  4010              ; free memory after that point
  91  4010 22 5A         DW EXT_END
  92  4012
  93  4012              ; this location #4012 stores extension version in DAA format
  94  4012              ; first byte is major version and second minor
  95  4012 00 70         DB #00, #70
  96  4014
  97  4014              ; binary included AKG player compiled at #4014
  98  4014               IF (SOUND_CMDS == 1)
  99  4014              	INCBIN "bin/AKG.bin"
 100  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 101  4CF0               ENDIF
 102  4CF0
 103  4CF0              ORIG.HTIMI:
 104  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 104  4CF4 00
 105  4CF5               EXPORT ORIG.HTIMI
 106  4CF5
 107  4CF5               IF (SOUND_CMDS == 1)
 108  4CF5              MUSIC_INIT_STATUS:
 109  4CF5 00            DB 0
 110  4CF6              SFX_INIT_STATUS:
 111  4CF6 00            DB 0
 112  4CF7              SOUND_ENABLED:
 113  4CF7 00            DB 0
 114  4CF8               ENDIF
 115  4CF8
 116  4CF8               IF (SPRITE_CMDS == 1)
 117  4CF8              SPRATR_INIT_STATUS:
 118  4CF8 00            DB 0
 119  4CF9              SPRATR_UPDATE_FLAG:
 120  4CF9 00 00         DW 0
 121  4CFB              SPRATR_DATA:
 122  4CFB 00 00         DW 0
 123  4CFD              SPRFLICKER_ENABLED:
 124  4CFD 00            DB 0
 125  4CFE              ; to support sprite flicker
 126  4CFE              FLICKER:
 127  4CFE 00            DB 0
 128  4CFF               ENDIF
 129  4CFF
 130  4CFF              ; to temporarily store stack pointer
 131  4CFF              TMPSP:
 132  4CFF 00 00         DW 0
 133  4D01
 134  4D01              ; temp variables for BLIT, TILE functions
 135  4D01               IF (BLIT_CMDS + TILE_CMDS > 0)
 136  4D01              BLIT_TMP:
 137  4D01              TILETMP1:
 138  4D01              BLIT_TMP1:
 139  4D01 00 00         DW 0
 140  4D03              TILETMP2:
 141  4D03              BLIT_TMP2:
 142  4D03 00 00         DW 0
 143  4D05                IFDEF CMDS_WITH_PARAMETERS
 144  4D05              BLIT_STRUCT:
 145  4D05 00 00 00...   DS 17
 146  4D09                ENDIF
 147  4D09               ENDIF
 148  4D16
 149  4D16              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 150  4D16              ; per starting letter, if no commands with this letter, NULL value
 151  4D16              CMDS:
 152  4D16 00 00            DW 0 ; A
 153  4D18               IF (BLIT_CMDS + BOX_CMDS > 0)
 154  4D18 DF 4D            DW CMDS_B ; B
 155  4D1A               ELSE
 156  4D1A ~            	DW 0
 157  4D1A               ENDIF
 158  4D1A 00 00            DW 0 ; C
 159  4D1C 00 00            DW 0 ; D
 160  4D1E 00 00            DW 0 ; E
 161  4D20               IF (VRAM_CMDS + RAM_CMDS > 0)
 162  4D20 5D 4D            DW CMDS_F; F
 163  4D22               ELSE
 164  4D22 ~            	DW 0
 165  4D22               ENDIF
 166  4D22               IF (GENCAL_CMD > 0)
 167  4D22 70 4D            DW CMDS_G; G
 168  4D24               ELSE
 169  4D24 ~            	DW 0
 170  4D24               ENDIF
 171  4D24 00 00            DW 0 ; H
 172  4D26 00 00            DW 0 ; I
 173  4D28 00 00            DW 0 ; J
 174  4D2A 00 00            DW 0 ; K
 175  4D2C 00 00            DW 0 ; L
 176  4D2E               IF (VRAM_CMDS + RAM_CMDS > 0)
 177  4D2E 4A 4D            DW CMDS_M ; M
 178  4D30               ELSE
 179  4D30 ~            	DW 0
 180  4D30               ENDIF
 181  4D30 00 00            DW 0 ; N
 182  4D32 00 00            DW 0 ; O
 183  4D34 00 00            DW 0 ; P
 184  4D36 00 00            DW 0 ; Q
 185  4D38 00 00            DW 0 ; R
 186  4D3A               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 187  4D3A 84 4D            DW CMDS_S ; S
 188  4D3C               ELSE
 189  4D3C ~            	DW 0
 190  4D3C               ENDIF
 191  4D3C               IF (TILE_CMDS > 0)
 192  4D3C FF 4D            DW CMDS_T ; T
 193  4D3E               ELSE
 194  4D3E ~            	DW 0
 195  4D3E               ENDIF
 196  4D3E 00 00            DW 0 ; U
 197  4D40               IF (VRAM_CMDS > 0)
 198  4D40 7A 4D            DW CMDS_V ; V
 199  4D42               ELSE
 200  4D42 ~            	DW 0
 201  4D42               ENDIF
 202  4D42 00 00            DW 0 ; W
 203  4D44 00 00            DW 0 ; X
 204  4D46 00 00            DW 0 ; Y
 205  4D48 00 00            DW 0 ; Z
 206  4D4A
 207  4D4A              CMDS_M:
 208  4D4A               IF (VRAM_CMDS == 1)
 209  4D4A 4D 45 4D 56      DB "MEMVRM", 0
 209  4D4E 52 4D 00
 210  4D51 4E 51            DW MEMVRM
 211  4D53               ENDIF
 212  4D53               IF (RAM_CMDS == 1)
 213  4D53 4D 45 4D 43  	DB "MEMCPY", 0
 213  4D57 50 59 00
 214  4D5A 0D 50        	DW MEMCPY
 215  4D5C               ENDIF
 216  4D5C               IF (VRAM_CMDS + RAM_CMDS > 0)
 217  4D5C 00           	DB 0
 218  4D5D               ENDIF
 219  4D5D              CMDS_F:
 220  4D5D               IF (VRAM_CMDS == 1)
 221  4D5D 46 49 4C 56      DB "FILVRM", 0
 221  4D61 52 4D 00
 222  4D64 50 50            DW FILVRM
 223  4D66               ENDIF
 224  4D66               IF (RAM_CMDS == 1)
 225  4D66 46 49 4C 52      DB "FILRAM", 0
 225  4D6A 41 4D 00
 226  4D6D 97 50            DW FILRAM
 227  4D6F               ENDIF
 228  4D6F               IF (VRAM_CMDS + RAM_CMDS > 0)
 229  4D6F 00               DB 0
 230  4D70               ENDIF
 231  4D70              CMDS_G:
 232  4D70               IF (GENCAL_CMD == 1)
 233  4D70 47 45 4E 43      DB "GENCAL", 0
 233  4D74 41 4C 00
 234  4D77 F5 50            DW GENCAL
 235  4D79               ENDIF
 236  4D79               IF (GENCAL_CMD > 0)
 237  4D79 00           	DB	0
 238  4D7A               ENDIF
 239  4D7A              CMDS_V:
 240  4D7A               IF (VRAM_CMDS == 1)
 241  4D7A 56 52 4D 4D  	DB "VRMMEM", 0
 241  4D7E 45 4D 00
 242  4D81 C6 51        	DW VRMMEM
 243  4D83               ENDIF
 244  4D83               IF (VRAM_CMDS > 0)
 245  4D83 00           	DB 0
 246  4D84               ENDIF
 247  4D84              CMDS_S:
 248  4D84               IF (SPRITE_CMDS == 1)
 249  4D84 53 50 52 53  	DB "SPRSET", 0
 249  4D88 45 54 00
 250  4D8B B3 53        	DW SPRSET
 251  4D8D 53 50 52 47  	DB "SPRGRPMOV", 0
 251  4D91 52 50 4D 4F
 251  4D95 56 00
 252  4D97 71 54        	DW SPRGRPMOV
 253  4D99               ENDIF
 254  4D99               IF (SOUND_CMDS == 1)
 255  4D99 53 4E 44 53  	DB "SNDSFX", 0
 255  4D9D 46 58 00
 256  4DA0 04 53        	DW SNDSFX
 257  4DA2 53 4E 44 50  	DB "SNDPLYON", 0
 257  4DA6 4C 59 4F 4E
 257  4DAA 00
 258  4DAB CE 52        	DW SNDPLYON
 259  4DAD 53 4E 44 50  	DB "SNDPLYOFF", 0
 259  4DB1 4C 59 4F 46
 259  4DB5 46 00
 260  4DB7 E1 52        	DW SNDPLYOFF
 261  4DB9 53 4E 44 50  	DB "SNDPLYINI", 0
 261  4DBD 4C 59 49 4E
 261  4DC1 49 00
 262  4DC3 84 52        	DW SNDPLYINIT
 263  4DC5               ENDIF
 264  4DC5               IF (SPRITE_CMDS == 1)
 265  4DC5 53 50 52 45  	DB "SPRENABLE", 0
 265  4DC9 4E 41 42 4C
 265  4DCD 45 00
 266  4DCF 5E 53        	DW SPRENABLE
 267  4DD1 53 50 52 44  	DB "SPRDISABLE", 0
 267  4DD5 49 53 41 42
 267  4DD9 4C 45 00
 268  4DDC AE 53        	DW SPRDISABLE
 269  4DDE               ENDIF
 270  4DDE               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 271  4DDE 00           	DB 0
 272  4DDF               ENDIF
 273  4DDF              CMDS_B:
 274  4DDF               IF (BLIT_CMDS == 1)
 275  4DDF 42 4C 49 54  	DB "BLIT", 0
 275  4DE3 00
 276  4DE4 6F 56        	DW BLIT
 277  4DE6               ENDIF
 278  4DE6               IF (BOX_CMDS == 1)
 279  4DE6 42 4F 58 4D  	DB "BOXMEMCPY", 0
 279  4DEA 45 4D 43 50
 279  4DEE 59 00
 280  4DF0 A7 59        	DW BOXMEMCPY
 281  4DF2 42 4F 58 4D  	DB "BOXMEMVRM", 0
 281  4DF6 45 4D 56 52
 281  4DFA 4D 00
 282  4DFC DB 59        	DW BOXMEMVRM
 283  4DFE               ENDIF
 284  4DFE               IF (BLIT_CMDS + BOX_CMDS > 0)
 285  4DFE 00           	DB 0
 286  4DFF               ENDIF
 287  4DFF              CMDS_T:
 288  4DFF               IF (TILE_CMDS == 1)
 289  4DFF 54 49 4C 45  	DB "TILERAM", 0
 289  4E03 52 41 4D 00
 290  4E07 B3 57        	DW TILERAM
 291  4E09 54 49 4C 45  	DB "TILEVRM", 0
 291  4E0D 56 52 4D 00
 292  4E11 B6 58        	DW TILEVRM
 293  4E13               ENDIF
 294  4E13               IF (TILE_CMDS > 0)
 295  4E13 00           	DB 0
 296  4E14               ENDIF
 297  4E14
 298  4E14               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 299  4E14              ; ****************************************************************************************************
 300  4E14              ; function sets VRAM address
 301  4E14              ; input HL=address
 302  4E14              ; modifies AF
 303  4E14              SETWRT_LOCAL:
 304  4E14 7D           	LD	A, L
 305  4E15 D3 99        	OUT	(099H), A
 306  4E17 7C           	LD	A, H
 307  4E18 E6 3F        	AND	03FH
 308  4E1A F6 40        	OR	040H
 309  4E1C D3 99        	OUT	(099H), A
 310  4E1E C9           	RET
 311  4E1F              ; ****************************************************************************************************
 312  4E1F               ENDIF
 313  4E1F
 314  4E1F               IF (VRAM_CMDS + TILE_CMDS > 0)
 315  4E1F              ; ****************************************************************************************************
 316  4E1F              ; function copies data from RAM to VRAM
 317  4E1F              ; input HL=address in RAM
 318  4E1F              ; input B=count
 319  4E1F              ; modifies AF
 320  4E1F              BBYTECOPY:
 321  4E1F ED A3        	OUTI
 322  4E21 C2 1F 4E     	JP	NZ, BBYTECOPY
 323  4E24 C9           	RET
 324  4E25              ; ****************************************************************************************************
 325  4E25               ENDIF
 326  4E25
 327  4E25              ; ****************************************************************************************************
 328  4E25              ; function multiplies HL by 8
 329  4E25              HLx8:
 330  4E25 29          > ADD HL, HL
 330  4E26 29          > ADD HL, HL
 330  4E27 29          > ADD HL, HL
 331  4E28 C9           	RET
 332  4E29              ; ****************************************************************************************************
 333  4E29
 334  4E29              ; ****************************************************************************************************
 335  4E29              ; function gets slot and subslot data for specific page
 336  4E29              ; input A=page (0, 1 or 2)
 337  4E29              ; output B = 0A8H register value
 338  4E29              ; output D = 0 is no subslots, 1 if yes
 339  4E29              ; output C = 0A8H value when page 3 slot equals to requested page slot
 340  4E29              ; output E = subslot value if present
 341  4E29              ; modifies AF, BC, DE, HL
 342  4E29              GET_PAGE_INFO:
 343  4E29 6F               LD L, A
 344  4E2A C6 C1            ADD A, low (EXPTBL)
 345  4E2C 32 36 4E         LD (GET_PAGE_INFO_L1+1), A
 346  4E2F DB A8            IN A, (0A8H)
 347  4E31 47               LD B, A
 348  4E32 E6 3F            AND 03FH
 349  4E34 4F               LD C, A
 350  4E35              GET_PAGE_INFO_L1:
 351  4E35 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 352  4E38 E6 80            AND 080H
 353  4E3A 28 1B            JR Z, GET_PAGE_INFO_L2
 354  4E3C                  ; expanded
 355  4E3C 2D               DEC L
 356  4E3D FA 5C 4E         JP M, GET_PAGE_INFO_L3
 357  4E40 2D               DEC L
 358  4E41 FA 5A 4E         JP M, GET_PAGE_INFO_L4
 359  4E44                  ; page 2
 360  4E44 07               RLCA
 361  4E45 07               RLCA
 362  4E46              GET_PAGE_INFO_L5:
 363  4E46 E6 C0            AND 0C0H
 364  4E48 B1               OR C
 365  4E49 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 366  4E4B 4F               LD C, A
 367  4E4C 3A FF FF         LD A, (0FFFFH)
 368  4E4F 2F               CPL
 369  4E50 5F               LD E, A
 370  4E51 16 01            LD D, 1
 371  4E53 78               LD A, B ; return stack
 372  4E54 D3 A8            OUT (0A8H), A
 373  4E56 C9               RET
 374  4E57              GET_PAGE_INFO_L2:
 375  4E57                  ; not expanded
 376  4E57 16 00            LD D, 0
 377  4E59 C9               RET
 378  4E5A              GET_PAGE_INFO_L4:
 379  4E5A                  ; page 1
 380  4E5A 0F               RRCA
 381  4E5B 0F               RRCA
 382  4E5C              GET_PAGE_INFO_L3:
 383  4E5C                  ; page 0
 384  4E5C 0F               RRCA
 385  4E5D 0F               RRCA
 386  4E5E 18 E6            JR GET_PAGE_INFO_L5
 387  4E60              ; ****************************************************************************************************
 388  4E60
 389  4E60              ; ****************************************************************************************************
 390  4E60              ; function returns original slot and subslot info
 391  4E60              ; input B = 0A8H register value
 392  4E60              ; input D = 0 is no subslots, 1 if yes
 393  4E60              ; input C = 0A8H value when page 3 slot equals to requested page slot
 394  4E60              ; input E = subslot value if present
 395  4E60              ; modifies AF, disables interrupts
 396  4E60              RESTORE_PAGE_INFO:
 397  4E60 7A               LD A, D
 398  4E61 B7               OR A
 399  4E62 28 08            JR Z, RESTORE_PAGE_INFO_L1
 400  4E64 79               LD A, C
 401  4E65 F3           	DI
 402  4E66 D3 A8            OUT (0A8H), A
 403  4E68 7B               LD A, E
 404  4E69 32 FF FF         LD (0FFFFH), A
 405  4E6C              RESTORE_PAGE_INFO_L1:
 406  4E6C 78               LD A, B
 407  4E6D D3 A8            OUT (0A8H), A
 408  4E6F C9               RET
 409  4E70              ; ****************************************************************************************************
 410  4E70
 411  4E70              ; *******************************************************************************************************
 412  4E70              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 413  4E70              ; INPUT:  A = SLOT ID: EXXXSSPP
 414  4E70              ; E = EXPANDED FLAG
 415  4E70              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 416  4E70              ; PP = PRIMARY SLOT NUMBER
 417  4E70              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 418  4E70              ; CHANGES: AF, BC, DE
 419  4E70
 420  4E70              LOCAL_ENASLT:
 421  4E70 CD 90 4E         CALL L0353
 422  4E73 FA 7D 4E         JP M, L0340
 423  4E76 DB A8            IN A, (0A8H)
 424  4E78 A1               AND C
 425  4E79 B0               OR B
 426  4E7A D3 A8            OUT (0A8H), A
 427  4E7C C9               RET
 428  4E7D              L0340:
 429  4E7D E5               PUSH HL
 430  4E7E CD B5 4E         CALL L0378
 431  4E81 4F               LD C, A
 432  4E82 06 00            LD B, 0
 433  4E84 7D               LD A, L
 434  4E85 A4               AND H
 435  4E86 B2               OR D
 436  4E87 21 C5 FC         LD HL, 0FCC5H
 437  4E8A 09               ADD HL, BC
 438  4E8B 77               LD (HL), A
 439  4E8C E1               POP HL
 440  4E8D 79               LD A, C
 441  4E8E 18 E0            JR LOCAL_ENASLT
 442  4E90              L0353:
 443  4E90 F3               DI
 444  4E91 F5               PUSH AF
 445  4E92 7C               LD A, H
 446  4E93 07               RLCA
 447  4E94 07               RLCA
 448  4E95 E6 03            AND 3
 449  4E97 5F               LD E, A
 450  4E98 3E C0            LD A, 0C0H
 451  4E9A              L035D:
 452  4E9A 07               RLCA
 453  4E9B 07               RLCA
 454  4E9C 1D               DEC E
 455  4E9D F2 9A 4E         JP P, L035D
 456  4EA0 5F               LD E, A
 457  4EA1 2F               CPL
 458  4EA2 4F               LD C, A
 459  4EA3 F1               POP AF
 460  4EA4 F5               PUSH AF
 461  4EA5 E6 03            AND 3
 462  4EA7 3C               INC A
 463  4EA8 47               LD B, A
 464  4EA9 3E AB            LD A, 0ABH
 465  4EAB              L036E:
 466  4EAB C6 55            ADD A, 055H
 467  4EAD 10 FC            DJNZ L036E
 468  4EAF 57               LD D, A
 469  4EB0 A3               AND E
 470  4EB1 47               LD B, A
 471  4EB2 F1               POP AF
 472  4EB3 A7               AND A
 473  4EB4 C9               RET
 474  4EB5              L0378:
 475  4EB5 F5               PUSH AF
 476  4EB6 7A               LD A, D
 477  4EB7 E6 C0            AND 0C0H
 478  4EB9 4F               LD C, A
 479  4EBA F1               POP AF
 480  4EBB F5               PUSH AF
 481  4EBC 57               LD D, A
 482  4EBD DB A8            IN A, (0A8H)
 483  4EBF 47               LD B, A
 484  4EC0 E6 3F            AND 03FH
 485  4EC2 B1               OR C
 486  4EC3 D3 A8            OUT (0A8H), A
 487  4EC5 7A               LD A, D
 488  4EC6 0F               RRCA
 489  4EC7 0F               RRCA
 490  4EC8 E6 03            AND 3
 491  4ECA 57               LD D, A
 492  4ECB 3E AB            LD A, 0ABH
 493  4ECD              L0390:
 494  4ECD C6 55            ADD A, 055H
 495  4ECF 15               DEC D
 496  4ED0 F2 CD 4E         JP P, L0390
 497  4ED3 A3               AND E
 498  4ED4 57               LD D, A
 499  4ED5 7B               LD A, E
 500  4ED6 2F               CPL
 501  4ED7 67               LD H, A
 502  4ED8 3A FF FF         LD A, (0FFFFH)
 503  4EDB 2F               CPL
 504  4EDC 6F               LD L, A
 505  4EDD A4               AND H
 506  4EDE B2               OR D
 507  4EDF 32 FF FF         LD (0FFFFH), A
 508  4EE2 78               LD A, B
 509  4EE3 D3 A8            OUT (0A8H), A
 510  4EE5 F1               POP AF
 511  4EE6 E6 03            AND 3
 512  4EE8 C9               RET
 513  4EE9              ; *******************************************************************************************************
 514  4EE9
 515  4EE9              ; *******************************************************************************************************
 516  4EE9              ; some common code to activate page 0 and place values needed to restore original page on stack
 517  4EE9              ; input IY=return address
 518  4EE9              ENABLE_PAGE0:
 519  4EE9 AF               XOR A
 520  4EEA CD 29 4E         CALL GET_PAGE_INFO
 521  4EED C5               PUSH BC
 522  4EEE D5               PUSH DE
 523  4EEF 3A 41 F3         LD A, (RAMAD0)
 524  4EF2 26 00            LD H, 0
 525  4EF4 CD 70 4E         CALL LOCAL_ENASLT
 526  4EF7 FD E9        	JP (IY)
 527  4EF9              ; *******************************************************************************************************
 528  4EF9
 529  4EF9               IF (SPRITE_CMDS == 1)
 530  4EF9              ; *******************************************************************************************************
 531  4EF9              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 532  4EF9              ; struct {
 533  4EF9              ; DW y
 534  4EF9              ; DW x
 535  4EF9              ; DW pattern (0-63)
 536  4EF9              ; DW color
 537  4EF9              ; } [32]
 538  4EF9              ; will hide sprites whose location is outside of visible area
 539  4EF9              ; works in screen 1 and 2
 540  4EF9              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 541  4EF9              ; modifies AF, AF', BC, DE, HL
 542  4EF9              SPRATR_UPDATE:
 543  4EF9              	; check if initialized
 544  4EF9 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 545  4EFC B7           	OR A
 546  4EFD C8           	RET Z
 547  4EFE              	; check if update requested
 548  4EFE 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 549  4F01 7E           	LD A, (HL)
 550  4F02 B7           	OR A
 551  4F03 C8           	RET Z
 552  4F04              	; check screen mode
 553  4F04 3A AF FC     	LD A, (SCRMOD)
 554  4F07 3D           	DEC A
 555  4F08 28 02        	JR Z, .L0 ; screen 1
 556  4F0A 3D           	DEC A
 557  4F0B C0           	RET NZ ; not screen 2
 558  4F0C              .L0:
 559  4F0C 06 20        	LD B, 32 ; sprite number
 560  4F0E 0E 98        	LD C, #98 ; register for vdp data output
 561  4F10              	; set VDP address
 562  4F10 2A 28 F9     	LD HL, (ATRBAS)
 563  4F13 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
 564  4F16 B7           	OR A
 565  4F17 28 03        	JR Z, .L3
 566  4F19 3A FE 4C     	LD A, (FLICKER)
 567  4F1C              .L3:
 568  4F1C 5F           	LD E, A
 569  4F1D 08           	EX AF, AF'
 570  4F1E 7B           	LD A, E
 571  4F1F 87           	ADD A, A
 572  4F20 87           	ADD A, A
 573  4F21 16 00        	LD D, 0
 574  4F23 5F           	LD E, A
 575  4F24 19           	ADD HL, DE
 576  4F25 CD 14 4E     	CALL SETWRT_LOCAL
 577  4F28 ED 73 FF 4C  	LD (TMPSP), SP
 578  4F2C ED 7B FB 4C  	LD SP, (SPRATR_DATA)
 579  4F30
 580  4F30              .LOOP:
 581  4F30 E1           	POP HL
 582  4F31 24           	INC H
 583  4F32 28 0D        	JR Z, .L1 ; negative number above -256
 584  4F34 25           	DEC H
 585  4F35 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 586  4F37 7D           	LD A, L
 587  4F38 FE C0        	CP 192
 588  4F3A 30 10        	JR NC, .OUT3
 589  4F3C 3D           	DEC A ; due to VDP rule that top of screen is -1
 590  4F3D 57           	LD D, A
 591  4F3E C3 5C 4F     	JP .X
 592  4F41              .L1:
 593  4F41 7D           	LD A, L
 594  4F42 C6 10        	ADD 16
 595  4F44 FA 4C 4F     	JP M, .OUT3 ; below -16
 596  4F47 2D           	DEC L ; due to VDP rule that top of screen is -1
 597  4F48 55           	LD D, L
 598  4F49 C3 5C 4F     	JP .X
 599  4F4C              .OUT3:
 600  4F4C E1           	POP HL ; skip x value
 601  4F4D              .OUT2:
 602  4F4D E1           	POP HL ; skip pattern
 603  4F4E E1           	POP HL ; skip color
 604  4F4F 3E D1        	LD A, #D1
 605  4F51 D3 98        	OUT (#98), A ; sprite hidden
 606  4F53 D3 98        	OUT (#98), A ; value unimportant
 607  4F55 D3 98        	OUT (#98), A ; value unimportant
 608  4F57 D3 98        	OUT (#98), A ; value unimportant
 609  4F59 C3 87 4F     	JP .NEXT
 610  4F5C              .X:
 611  4F5C E1           	POP HL
 612  4F5D 24           	INC H
 613  4F5E 28 08        	JR Z, .L2
 614  4F60 25           	DEC H
 615  4F61 20 EA        	JR NZ, .OUT2
 616  4F63 1E 00        	LD E, 0 ; EC bit
 617  4F65 C3 71 4F     	JP .XY
 618  4F68              .L2:
 619  4F68 7D           	LD A, L
 620  4F69 C6 20        	ADD 32
 621  4F6B FA 4D 4F     	JP M, .OUT2
 622  4F6E 6F           	LD L, A
 623  4F6F 1E 80        	LD E, #80
 624  4F71              .XY:
 625  4F71 ED 51        	OUT (C), D
 626  4F73 ED 69        	OUT (C), L
 627  4F75 E1           	POP HL ; pattern
 628  4F76 3A E0 F3     	LD A, (REG1SAV)
 629  4F79 E6 02        	AND 2
 630  4F7B 7D           	LD A, L
 631  4F7C 28 02        	JR Z, .SMALLSPRITES
 632  4F7E 87           	ADD A, A
 633  4F7F 87           	ADD A, A ; needs to go at 4x
 634  4F80              .SMALLSPRITES:
 635  4F80 D3 98        	OUT (#98), A
 636  4F82 E1           	POP HL ; color
 637  4F83 7D           	LD A, L
 638  4F84 B3           	OR E
 639  4F85 D3 98        	OUT (#98), A
 640  4F87              .NEXT:
 641  4F87 08           	EX AF, AF'
 642  4F88 3C           	INC A
 643  4F89 E6 1F        	AND 31
 644  4F8B C2 9F 4F     	JP NZ, .NEXT2
 645  4F8E 08           	EX AF, AF'
 646  4F8F 2A 28 F9     	LD HL, (ATRBAS)
 647  4F92              	; CALL SETWRT_LOCAL not allowed as SP modified
 648  4F92 7D           	LD	A, L
 649  4F93 D3 99        	OUT	(099H), A
 650  4F95 7C           	LD	A, H
 651  4F96 E6 3F        	AND	03FH
 652  4F98 F6 40        	OR	040H
 653  4F9A D3 99        	OUT	(099H), A
 654  4F9C C3 A0 4F     	JP .NEXT3
 655  4F9F              .NEXT2:
 656  4F9F 08           	EX AF, AF'
 657  4FA0              .NEXT3:
 658  4FA0 10 8E        	DJNZ .LOOP
 659  4FA2 08           	EX AF, AF'
 660  4FA3 3C           	INC A
 661  4FA4 32 FE 4C     	LD (FLICKER), A
 662  4FA7
 663  4FA7 ED 7B FF 4C  	LD SP, (TMPSP)
 664  4FAB 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 665  4FAE 36 00        	LD (HL), 0 ; zero out update flag
 666  4FB0 C9           	RET
 667  4FB1              ; *******************************************************************************************************
 668  4FB1               ENDIF
 669  4FB1
 670  4FB1              ; General BASIC CALL-instruction handler
 671  4FB1              CALLHAND:
 672  4FB1 E5           	PUSH HL
 673  4FB2 21 16 4D     	LD	HL, CMDS ; pointer table based on starting letter
 674  4FB5 3A 89 FD         LD A, (PROCNM)
 675  4FB8 D6 41            SUB 'A'
 676  4FBA 87               ADD A, A
 677  4FBB 16 00            LD D, 0
 678  4FBD 5F               LD E, A
 679  4FBE 19               ADD HL, DE
 680  4FBF 5E               LD E, (HL)
 681  4FC0 23               INC HL
 682  4FC1 56               LD D, (HL)
 683  4FC2 7A               LD A, D
 684  4FC3 B3               OR E
 685  4FC4 28 23            JR Z, .CMDNOTRECOGNIZED
 686  4FC6 EB               EX DE, HL
 687  4FC7              .CHKCMD:
 688  4FC7 11 89 FD     	LD	DE, PROCNM
 689  4FCA 1A           .LOOP:	LD	A,(DE)
 690  4FCB BE           	CP	(HL)
 691  4FCC 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 692  4FCE 13           	INC	DE
 693  4FCF 23           	INC	HL
 694  4FD0 A7           	AND	A
 695  4FD1 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 696  4FD3 5E           	LD	E,(HL)
 697  4FD4 23           	INC	HL
 698  4FD5 56           	LD	D,(HL)
 699  4FD6 E1           	POP	HL		; routine address
 700  4FD7 CD F8 4F     	CALL	GETPREVCHAR
 701  4FDA CD EC 4F     	CALL	.CALLDE		; Call routine
 702  4FDD A7           	AND	A
 703  4FDE C9           	RET
 704  4FDF
 705  4FDF              .TONEXTCMD:
 706  4FDF 0E FF        	LD	C,0FFH
 707  4FE1 AF           	XOR	A
 708  4FE2 ED B1        	CPIR			; Skip to end of instruction name
 709  4FE4 23           	INC	HL
 710  4FE5 23           	INC	HL		; Skip address
 711  4FE6 BE           	CP	(HL)
 712  4FE7 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 713  4FE9              .CMDNOTRECOGNIZED:
 714  4FE9 E1           	POP	HL
 715  4FEA 37               SCF
 716  4FEB C9           	RET
 717  4FEC
 718  4FEC              .CALLDE:
 719  4FEC D5           	PUSH	DE
 720  4FED C9           	RET
 721  4FEE
 722  4FEE              ;---------------------------
 723  4FEE
 724  4FEE              ;GETSTRPNT:
 725  4FEE              ; OUT:
 726  4FEE              ; HL = String Address
 727  4FEE              ; B  = Lenght
 728  4FEE              ;        LD      HL,(USR)
 729  4FEE              ;        LD      B,(HL)
 730  4FEE              ;        INC     HL
 731  4FEE              ;        LD      E,(HL)
 732  4FEE              ;        INC     HL
 733  4FEE              ;        LD      D,(HL)
 734  4FEE              ;        EX      DE,HL
 735  4FEE              ;        RET
 736  4FEE
 737  4FEE              ;EVALTXTPARAM:
 738  4FEE              ;	CALL	CHKCHAR
 739  4FEE              ;	DEFB	"("             ; Check for (
 740  4FEE              ;	LD	IX,FRMEVL
 741  4FEE              ;	CALL	CALBAS		; Evaluate expression
 742  4FEE              ;       LD      A,(VALTYP)
 743  4FEE              ;        CP      3               ; Text type?
 744  4FEE              ;        JP      NZ,TYPE_MISMATCH
 745  4FEE              ;        PUSH	HL
 746  4FEE              ;        LD	IX,FRESTR         ; Free the temporary string
 747  4FEE              ;        CALL	CALBAS
 748  4FEE              ;        POP	HL
 749  4FEE              ;	CALL	CHKCHAR
 750  4FEE              ;	DEFB	")"             ; Check for )
 751  4FEE              ;        RET
 752  4FEE
 753  4FEE
 754  4FEE              CHKCHAR:
 755  4FEE CD F8 4F     	CALL	GETPREVCHAR	; Get previous basic char
 756  4FF1 E3           	EX	(SP),HL
 757  4FF2 BE           	CP	(HL) 	        ; Check if good char
 758  4FF3 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 759  4FF5 23           	INC	HL
 760  4FF6 E3           	EX	(SP),HL
 761  4FF7 23           	INC	HL		; Get next basic char
 762  4FF8
 763  4FF8              GETPREVCHAR:
 764  4FF8 2B           	DEC	HL
 765  4FF9 DD 21 66 46  	LD	IX,CHRGTR
 766  4FFD C3 59 01     	JP      CALBAS
 767  5000
 768  5000
 769  5000              TYPE_MISMATCH:
 770  5000 1E 0D            LD E, 13 ; Type mismatch
 771  5002 18 02            JR THROW_ERROR
 772  5004
 773  5004              SYNTAX_ERROR:
 774  5004 1E 02            LD E, 2 ; Syntax error
 775  5006              THROW_ERROR:
 776  5006 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 777  500A C3 59 01     	JP	CALBAS
 778  500D
 779  500D              ;---------------------------
 780  500D
 781  500D               IF (RAM_CMDS == 1)
 782  500D              ; *******************************************************************************************************
 783  500D              ; function to handle CALL MEMCPY basic extension
 784  500D              ; _MEMCPY ( INT source,
 785  500D              ;			INT destination,
 786  500D              ;			INT count,
 787  500D              ; will put ram in page 0 also, page 1 is already there
 788  500D              MEMCPY:
 789  500D              	; opening (
 790  500D CD EE 4F     	CALL CHKCHAR
 791  5010 28           	DB '('
 792  5011              	; get source address
 793  5011 DD 21 2F 54  	LD IX, FRMQNT
 794  5015 CD 59 01     	CALL CALBAS
 795  5018 D5           	PUSH DE
 796  5019              	; comma
 797  5019 CD EE 4F     	CALL CHKCHAR
 798  501C 2C           	DB ','
 799  501D              	; get destination address
 800  501D DD 21 2F 54  	LD IX, FRMQNT
 801  5021 CD 59 01     	CALL CALBAS
 802  5024 D5           	PUSH DE
 803  5025              	; comma
 804  5025 CD EE 4F     	CALL CHKCHAR
 805  5028 2C           	DB ','
 806  5029              	; get length
 807  5029 DD 21 2F 54  	LD IX, FRMQNT
 808  502D CD 59 01     	CALL CALBAS
 809  5030 D5           	PUSH DE
 810  5031              	; ending )
 811  5031 CD EE 4F     	CALL CHKCHAR
 812  5034 29           	DB ')'
 813  5035
 814  5035              	; save position
 815  5035 E5           	PUSH HL
 816  5036 DD E1        	POP IX
 817  5038
 818  5038 C1           	POP BC ; count
 819  5039 D1           	POP DE ; destination
 820  503A E1           	POP HL ; source
 821  503B D9           	EXX
 822  503C              	; enable page 0
 823  503C FD 21 43 50  	LD IY, .RET
 824  5040 C3 E9 4E     	JP ENABLE_PAGE0
 825  5043              .RET:
 826  5043 FB           	EI
 827  5044 D9           	EXX
 828  5045 ED B0        	LDIR
 829  5047 D1               POP DE
 830  5048 C1               POP BC
 831  5049 CD 60 4E         CALL RESTORE_PAGE_INFO
 832  504C DD E5        	PUSH IX
 833  504E E1           	POP HL
 834  504F C9           	RET
 835  5050              ; *******************************************************************************************************
 836  5050               ENDIF
 837  5050
 838  5050               IF (VRAM_CMDS == 1)
 839  5050              ; *******************************************************************************************************
 840  5050              ; function to handle CALL FILVRM basic extension
 841  5050              ; FILVRM ( INT offset,
 842  5050              ;		   INT count,
 843  5050              ;		   BYTE value,
 844  5050              ;		   BYTE wait_vsync) >0 = true
 845  5050              ; wait_vsync will issue HALT before copying
 846  5050              FILVRM:
 847  5050              	; opening (
 848  5050 CD EE 4F     	CALL CHKCHAR
 849  5053 28           	DB '('
 850  5054              	; get offset address
 851  5054 DD 21 2F 54  	LD IX, FRMQNT
 852  5058 CD 59 01     	CALL CALBAS
 853  505B D5           	PUSH DE
 854  505C              	; comma
 855  505C CD EE 4F     	CALL CHKCHAR
 856  505F 2C           	DB ','
 857  5060              	; get count
 858  5060 DD 21 2F 54  	LD IX, FRMQNT
 859  5064 CD 59 01     	CALL CALBAS
 860  5067 D5           	PUSH DE
 861  5068              	; comma
 862  5068 CD EE 4F     	CALL CHKCHAR
 863  506B 2C           	DB ','
 864  506C              	; get value
 865  506C DD 21 1C 52  	LD IX, GETBYT
 866  5070 CD 59 01     	CALL CALBAS
 867  5073 F5           	PUSH AF
 868  5074              	; comma
 869  5074 CD EE 4F     	CALL CHKCHAR
 870  5077 2C           	DB ','
 871  5078              	; get vsync wait
 872  5078 DD 21 1C 52  	LD IX, GETBYT
 873  507C CD 59 01     	CALL CALBAS
 874  507F F5           	PUSH AF
 875  5080              	; ending )
 876  5080 CD EE 4F     	CALL CHKCHAR
 877  5083 29           	DB ')'
 878  5084
 879  5084 FB               EI
 880  5085              	; save position
 881  5085 E5           	PUSH HL
 882  5086 DD E1        	POP IX
 883  5088
 884  5088              	; syntax ok
 885  5088              	; wait for vsync if needed
 886  5088 F1           	POP AF
 887  5089 B7           	OR A
 888  508A 28 01        	JR Z, .L1
 889  508C 76           	HALT
 890  508D
 891  508D              .L1:
 892  508D F1               POP AF ; value
 893  508E C1               POP BC ; count
 894  508F E1               POP HL ; offset
 895  5090 CD 56 00         CALL BIOS_FILVRM
 896  5093
 897  5093              .L3:
 898  5093 DD E5        	PUSH IX
 899  5095 E1           	POP HL
 900  5096 C9           	RET
 901  5097              ; *******************************************************************************************************
 902  5097               ENDIF
 903  5097
 904  5097               IF (RAM_CMDS == 1)
 905  5097              ; *******************************************************************************************************
 906  5097              ; function to handle CALL FILRAM basic extension
 907  5097              ; FILRAM ( INT start address,
 908  5097              ;		   INT count,
 909  5097              ;		   BYTE value,
 910  5097              ; will put ram in page 0 also, page 1 is already there
 911  5097              FILRAM:
 912  5097              	; opening (
 913  5097 CD EE 4F     	CALL CHKCHAR
 914  509A 28           	DB '('
 915  509B              	; get start address
 916  509B DD 21 2F 54  	LD IX, FRMQNT
 917  509F CD 59 01     	CALL CALBAS
 918  50A2 D5           	PUSH DE
 919  50A3              	; comma
 920  50A3 CD EE 4F     	CALL CHKCHAR
 921  50A6 2C           	DB ','
 922  50A7              	; get count
 923  50A7 DD 21 2F 54  	LD IX, FRMQNT
 924  50AB CD 59 01     	CALL CALBAS
 925  50AE D5           	PUSH DE
 926  50AF              	; comma
 927  50AF CD EE 4F     	CALL CHKCHAR
 928  50B2 2C           	DB ','
 929  50B3              	; get value
 930  50B3 DD 21 1C 52  	LD IX, GETBYT
 931  50B7 CD 59 01     	CALL CALBAS
 932  50BA F5           	PUSH AF
 933  50BB              	; ending )
 934  50BB CD EE 4F     	CALL CHKCHAR
 935  50BE 29           	DB ')'
 936  50BF
 937  50BF              	; save position
 938  50BF E5           	PUSH HL
 939  50C0 DD E1        	POP IX
 940  50C2
 941  50C2 D1           	POP DE ; actually AF
 942  50C3 C1           	POP BC ; count
 943  50C4 E1           	POP HL ; start address
 944  50C5 78           	LD A, B
 945  50C6 B7           	OR A
 946  50C7 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 947  50C9 B1           	OR C
 948  50CA 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 949  50CC 79           	LD A, C
 950  50CD 3D           	DEC A
 951  50CE 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 952  50D0              	; one byte to fill
 953  50D0 72           	LD (HL), D
 954  50D1 18 12        	JR .EXIT
 955  50D3              .L1:
 956  50D3 D9           	EXX
 957  50D4              	; enable page 0
 958  50D4 FD 21 DB 50  	LD IY, .RET
 959  50D8 C3 E9 4E     	JP ENABLE_PAGE0
 960  50DB              .RET:
 961  50DB FB           	EI
 962  50DC D9           	EXX
 963  50DD CD E9 50     	CALL .FILLVALUE
 964  50E0 D1               POP DE
 965  50E1 C1               POP BC
 966  50E2 CD 60 4E         CALL RESTORE_PAGE_INFO
 967  50E5              .EXIT:
 968  50E5 DD E5        	PUSH IX
 969  50E7 E1           	POP HL
 970  50E8 C9           	RET
 971  50E9
 972  50E9              .FILLVALUE:
 973  50E9 72               LD (HL), D
 974  50EA 54               LD D, H
 975  50EB 5D               LD E, L
 976  50EC 13               INC DE
 977  50ED 0B               DEC BC
 978  50EE ED B0            LDIR
 979  50F0 C9               RET
 980  50F1              ; *******************************************************************************************************
 981  50F1               ENDIF
 982  50F1
 983  50F1               IF (GENCAL_CMD == 1)
 984  50F1              ; *******************************************************************************************************
 985  50F1              ; function to handle CALL GENCAL basic extension
 986  50F1              ; GENCAL ( INT fn_addr, = address of the function to call
 987  50F1              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 988  50F1              ; output values of reristers will also be stored at reg_list_ptr
 989  50F1              GENCAL_VAR_SP:
 990  50F1 00 00            DW 0
 991  50F3              GENCAL_VAR_SP2:
 992  50F3 00 00            DW 0
 993  50F5              GENCAL:
 994  50F5              	; opening (
 995  50F5 CD EE 4F     	CALL CHKCHAR
 996  50F8 28           	DB '('
 997  50F9              	; get function address
 998  50F9 DD 21 2F 54  	LD IX, FRMQNT
 999  50FD CD 59 01     	CALL CALBAS
1000  5100 D5           	PUSH DE
1001  5101              	; comma
1002  5101 CD EE 4F     	CALL CHKCHAR
1003  5104 2C           	DB ','
1004  5105              	; get pointer to register list
1005  5105 DD 21 2F 54  	LD IX, FRMQNT
1006  5109 CD 59 01     	CALL CALBAS
1007  510C D5           	PUSH DE
1008  510D              	; ending )
1009  510D CD EE 4F     	CALL CHKCHAR
1010  5110 29           	DB ')'
1011  5111
1012  5111              	; save BASIC token position
1013  5111 E5           	PUSH HL
1014  5112 D9               EXX
1015  5113 E1           	POP HL ; HL'=next basic token
1016  5114 D9               EXX
1017  5115
1018  5115 E1               POP HL ; get pointer to register values
1019  5116 F3           	DI
1020  5117 ED 73 F1 50      LD (GENCAL_VAR_SP), SP
1021  511B F9               LD SP, HL
1022  511C F1               POP AF
1023  511D C1               POP BC
1024  511E D1               POP DE
1025  511F E1               POP HL
1026  5120 DD E1            POP IX
1027  5122 FD E1            POP IY
1028  5124 D9               EXX
1029  5125 ED 73 F3 50      LD (GENCAL_VAR_SP2), SP
1030  5129 ED 7B F1 50      LD SP, (GENCAL_VAR_SP)
1031  512D FB               EI
1032  512E D1               POP DE ; get function to call
1033  512F E5               PUSH HL
1034  5130 CD 4B 51         CALL .EXXDECALL
1035  5133 F3               DI
1036  5134 ED 73 F1 50      LD (GENCAL_VAR_SP), SP
1037  5138 ED 7B F3 50      LD SP, (GENCAL_VAR_SP2)
1038  513C FD E5            PUSH IY
1039  513E DD E5            PUSH IX
1040  5140 E5               PUSH HL
1041  5141 D5               PUSH DE
1042  5142 C5               PUSH BC
1043  5143 F5               PUSH AF
1044  5144 ED 7B F1 50      LD SP, (GENCAL_VAR_SP)
1045  5148 FB               EI
1046  5149 E1               POP HL
1047  514A C9           	RET
1048  514B
1049  514B              .EXXDECALL:
1050  514B D5               PUSH DE
1051  514C D9               EXX
1052  514D C9               RET
1053  514E              ; *******************************************************************************************************
1054  514E               ENDIF
1055  514E
1056  514E               IF (VRAM_CMDS == 1)
1057  514E              ; *******************************************************************************************************
1058  514E              ; function to handle CALL MEMVRM basic extension
1059  514E              ; copies from RAM to VRAM
1060  514E              ; _MEMVRM ( INT source,
1061  514E              ;			INT destination,
1062  514E              ;			INT count,
1063  514E              ;			BYTE wait_vsync) >0 = true
1064  514E              ; will put ram in page 0 also, page 1 is already there
1065  514E              ; wait_vsync will issue HALT before copying
1066  514E              MEMVRM:
1067  514E              	; opening (
1068  514E CD EE 4F     	CALL CHKCHAR
1069  5151 28           	DB '('
1070  5152              	; get source address
1071  5152 DD 21 2F 54  	LD IX, FRMQNT
1072  5156 CD 59 01     	CALL CALBAS
1073  5159 D5           	PUSH DE
1074  515A              	; comma
1075  515A CD EE 4F     	CALL CHKCHAR
1076  515D 2C           	DB ','
1077  515E              	; get destination address
1078  515E DD 21 2F 54  	LD IX, FRMQNT
1079  5162 CD 59 01     	CALL CALBAS
1080  5165 D5           	PUSH DE
1081  5166              	; comma
1082  5166 CD EE 4F     	CALL CHKCHAR
1083  5169 2C           	DB ','
1084  516A              	; get length
1085  516A DD 21 2F 54  	LD IX, FRMQNT
1086  516E CD 59 01     	CALL CALBAS
1087  5171 D5           	PUSH DE
1088  5172              	; comma
1089  5172 CD EE 4F     	CALL CHKCHAR
1090  5175 2C           	DB ','
1091  5176              	; get vsync wait
1092  5176 DD 21 1C 52  	LD IX, GETBYT
1093  517A CD 59 01     	CALL CALBAS
1094  517D F5           	PUSH AF
1095  517E              	; ending )
1096  517E CD EE 4F     	CALL CHKCHAR
1097  5181 29           	DB ')'
1098  5182
1099  5182                  ; save position in BASIC text
1100  5182 E5           	PUSH HL
1101  5183 DD E1        	POP IX
1102  5185
1103  5185 F1           	POP AF ; wait vsync
1104  5186 B7           	OR A
1105  5187 28 03        	JR Z, .L1
1106  5189 FB               EI
1107  518A 76           	HALT
1108  518B F3           	DI
1109  518C              .L1:
1110  518C              	; pop LDIR parameters and store away for later
1111  518C C1           	POP BC ; count
1112  518D D1           	POP DE ; vram destination
1113  518E E1           	POP HL ; ram source
1114  518F D9           	EXX
1115  5190 FD 21 97 51   	LD IY, .RET
1116  5194 C3 E9 4E     	JP ENABLE_PAGE0
1117  5197              .RET:
1118  5197 FB           	EI
1119  5198 D9           	EXX
1120  5199 CD A5 51     	CALL .LDIRVM
1121  519C D1               POP DE
1122  519D C1               POP BC
1123  519E CD 60 4E         CALL RESTORE_PAGE_INFO
1124  51A1 DD E5        	PUSH IX
1125  51A3 E1           	POP HL
1126  51A4 C9           	RET
1127  51A5
1128  51A5              .LDIRVM:
1129  51A5 EB           	EX DE, HL
1130  51A6 F3           	DI
1131  51A7 CD 14 4E     	CALL SETWRT_LOCAL
1132  51AA FB           	EI
1133  51AB EB           	EX DE, HL
1134  51AC 78           	LD A, B
1135  51AD B7           	OR A
1136  51AE 28 0D        	JR Z, .L3
1137  51B0 C5           	PUSH BC
1138  51B1 0E 98        	LD C, #98
1139  51B3              .L2:
1140  51B3 50           	LD D, B
1141  51B4 06 00        	LD B, 0
1142  51B6 CD 1F 4E     	CALL BBYTECOPY
1143  51B9 42           	LD B, D
1144  51BA 10 F7        	DJNZ .L2
1145  51BC C1           	POP BC
1146  51BD              .L3:
1147  51BD 79           	LD A, C
1148  51BE B7           	OR A
1149  51BF C8           	RET Z
1150  51C0 41           	LD B, C
1151  51C1 0E 98        	LD C, #98
1152  51C3 C3 1F 4E     	JP BBYTECOPY
1153  51C6              ; *******************************************************************************************************
1154  51C6               ENDIF
1155  51C6
1156  51C6               IF (VRAM_CMDS == 1)
1157  51C6              ; *******************************************************************************************************
1158  51C6              ; function to handle CALL VRMMEM basic extension
1159  51C6              ; copies from RAM to VRAM
1160  51C6              ; _VRMMEM ( INT source,
1161  51C6              ;			INT destination,
1162  51C6              ;			INT count
1163  51C6              ; will put ram in page 0 also, page 1 is already there
1164  51C6              VRMMEM:
1165  51C6              	; opening (
1166  51C6 CD EE 4F     	CALL CHKCHAR
1167  51C9 28           	DB '('
1168  51CA              	; get source address
1169  51CA DD 21 2F 54  	LD IX, FRMQNT
1170  51CE CD 59 01     	CALL CALBAS
1171  51D1 D5           	PUSH DE
1172  51D2              	; comma
1173  51D2 CD EE 4F     	CALL CHKCHAR
1174  51D5 2C           	DB ','
1175  51D6              	; get destination address
1176  51D6 DD 21 2F 54  	LD IX, FRMQNT
1177  51DA CD 59 01     	CALL CALBAS
1178  51DD D5           	PUSH DE
1179  51DE              	; comma
1180  51DE CD EE 4F     	CALL CHKCHAR
1181  51E1 2C           	DB ','
1182  51E2              	; get length
1183  51E2 DD 21 2F 54  	LD IX, FRMQNT
1184  51E6 CD 59 01     	CALL CALBAS
1185  51E9 D5           	PUSH DE
1186  51EA              	; ending )
1187  51EA CD EE 4F     	CALL CHKCHAR
1188  51ED 29           	DB ')'
1189  51EE
1190  51EE                  ; save position in BASIC text
1191  51EE E5           	PUSH HL
1192  51EF DD E1        	POP IX
1193  51F1
1194  51F1 C1           	POP BC ; count
1195  51F2 D1           	POP DE ; destination
1196  51F3 E1           	POP HL ; source
1197  51F4 D9           	EXX
1198  51F5 FD 21 FC 51  	LD IY, .RET
1199  51F9 C3 E9 4E     	JP ENABLE_PAGE0
1200  51FC              .RET:
1201  51FC FB           	EI
1202  51FD D9           	EXX
1203  51FE CD 0A 52     	CALL .LDIRMV
1204  5201 D1               POP DE
1205  5202 C1               POP BC
1206  5203 CD 60 4E         CALL RESTORE_PAGE_INFO
1207  5206 DD E5        	PUSH IX
1208  5208 E1           	POP HL
1209  5209 C9           	RET
1210  520A
1211  520A              .LDIRMV:
1212  520A              	; set VRAM address *exactly* as in ROM, otherwise corruption
1213  520A 7D           	LD	A, L
1214  520B F3           	DI
1215  520C D3 99        	OUT	(099H), A
1216  520E 7C           	LD	A, H
1217  520F E6 3F        	AND	03FH
1218  5211 D3 99        	OUT	(099H), A
1219  5213 FB           	EI
1220  5214              	;EX (SP), HL
1221  5214              	;EX (SP), HL
1222  5214              	;NOP
1223  5214              	;NOP
1224  5214              .L4:
1225  5214 DB 98            IN A, (#98)
1226  5216 12           	LD (DE), A
1227  5217 13               INC DE
1228  5218 0B               DEC BC
1229  5219 79               LD A, C
1230  521A B0               OR B
1231  521B 20 F7            JR NZ, .L4
1232  521D C9               RET
1233  521E              ; *******************************************************************************************************
1234  521E               ENDIF
1235  521E
1236  521E              ; *******************************************************************************************************
1237  521E              ; H.TIMI function
1238  521E              MBGE_HTIMI:
1239  521E               EXPORT MBGE_HTIMI
1240  521E F5           	PUSH AF
1241  521F
1242  521F               IF (SPRITE_CMDS == 1)
1243  521F CD F9 4E     	CALL SPRATR_UPDATE
1244  5222               ENDIF
1245  5222
1246  5222               IF (SOUND_CMDS == 1)
1247  5222 3A F7 4C     	LD A, (SOUND_ENABLED)
1248  5225 B7           	OR A
1249  5226 28 2A        	JR Z, .EXIT
1250  5228
1251  5228              	; enable page 2
1252  5228 3E 02            LD A, 2
1253  522A CD 29 4E         CALL GET_PAGE_INFO
1254  522D C5               PUSH BC
1255  522E D5               PUSH DE
1256  522F 3A 43 F3         LD A, (RAMAD2)
1257  5232 26 80            LD H, 080H
1258  5234 CD 70 4E         CALL LOCAL_ENASLT
1259  5237              	; enable page 0
1260  5237 AF               XOR A
1261  5238 CD 29 4E         CALL GET_PAGE_INFO
1262  523B C5               PUSH BC
1263  523C D5               PUSH DE
1264  523D 3A 41 F3         LD A, (RAMAD0)
1265  5240 26 00            LD H, 0
1266  5242 CD 70 4E         CALL LOCAL_ENASLT
1267  5245
1268  5245 CD 33 42     	CALL PLY_AKG_PLAY
1269  5248
1270  5248              	; restore page 0
1271  5248 D1               POP DE
1272  5249 C1               POP BC
1273  524A CD 60 4E         CALL RESTORE_PAGE_INFO
1274  524D              	; restore page 2
1275  524D D1               POP DE
1276  524E C1               POP BC
1277  524F CD 60 4E         CALL RESTORE_PAGE_INFO
1278  5252               ENDIF
1279  5252
1280  5252              .EXIT:
1281  5252 F1           	POP AF
1282  5253 C3 F0 4C     	JP ORIG.HTIMI
1283  5256              ; *******************************************************************************************************
1284  5256
1285  5256              ; *******************************************************************************************************
1286  5256              ; interrupt handler when page 0 enabled
1287  5256              VBLANK:
1288  5256              	EXPORT VBLANK
1289  5256
1290  5256 F5               PUSH AF
1291  5257              	; is VDP originator ?
1292  5257 DB 99        	IN	A, (099H)
1293  5259 A7           	AND	A
1294  525A F2 80 52     	JP P, .EXIT
1295  525D
1296  525D               IF (SOUND_CMDS == 1)
1297  525D 3A F7 4C     	LD A, (SOUND_ENABLED)
1298  5260 B7           	OR A
1299  5261 28 1D        	JR Z, .EXIT
1300  5263
1301  5263 C5               PUSH BC
1302  5264 D5               PUSH DE
1303  5265 E5               PUSH HL
1304  5266 08               EX AF, AF'
1305  5267 D9               EXX
1306  5268 F5               PUSH AF
1307  5269 C5               PUSH BC
1308  526A D5               PUSH DE
1309  526B E5               PUSH HL
1310  526C DD E5            PUSH IX
1311  526E FD E5            PUSH IY
1312  5270
1313  5270 CD 33 42     	CALL PLY_AKG_PLAY
1314  5273
1315  5273 FD E1            POP IY
1316  5275 DD E1            POP IX
1317  5277 E1               POP HL
1318  5278 D1               POP DE
1319  5279 C1               POP BC
1320  527A F1               POP AF
1321  527B 08               EX AF, AF'
1322  527C D9               EXX
1323  527D E1               POP HL
1324  527E D1               POP DE
1325  527F C1               POP BC
1326  5280               ENDIF
1327  5280
1328  5280              .EXIT:
1329  5280 F1           	POP AF
1330  5281 FB           	EI
1331  5282 ED 4D        	RETI
1332  5284              ; *******************************************************************************************************
1333  5284
1334  5284               IF (SOUND_CMDS == 1)
1335  5284              ; *******************************************************************************************************
1336  5284              ; function to handle CALL SNDPLYINIT basic extension
1337  5284              ; initializes sound player
1338  5284              ; _SNDPLYINIT ( INT music_offset,
1339  5284              ;				INT sfx_offset, can be -1 if no SFX
1340  5284              ; will put ram in page 0 also, page 1 is already there
1341  5284              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1342  5284              SNDPLYINIT:
1343  5284              	; opening (
1344  5284 CD EE 4F     	CALL CHKCHAR
1345  5287 28           	DB '('
1346  5288              	; get music address
1347  5288 DD 21 2F 54  	LD IX, FRMQNT
1348  528C CD 59 01     	CALL CALBAS
1349  528F D5           	PUSH DE
1350  5290              	; comma
1351  5290 CD EE 4F     	CALL CHKCHAR
1352  5293 2C           	DB ','
1353  5294              	; get sfx address
1354  5294 DD 21 2F 54  	LD IX, FRMQNT
1355  5298 CD 59 01     	CALL CALBAS
1356  529B D5           	PUSH DE
1357  529C              	; ending )
1358  529C CD EE 4F     	CALL CHKCHAR
1359  529F 29           	DB ')'
1360  52A0
1361  52A0                  ; save position in BASIC text
1362  52A0 44           	LD B, H
1363  52A1 4D           	LD C, L
1364  52A2
1365  52A2              	; pop LDIR parameters and store away for later
1366  52A2 D1           	POP DE ; sfx address
1367  52A3 E1           	POP HL ; music address
1368  52A4 C5           	PUSH BC ; basic text location
1369  52A5 D9           	EXX
1370  52A6 FD 21 AD 52  	LD IY, .RET
1371  52AA C3 E9 4E     	JP ENABLE_PAGE0
1372  52AD              .RET:
1373  52AD D9           	EXX
1374  52AE
1375  52AE D5           	PUSH DE
1376  52AF AF           	XOR A
1377  52B0              	; HL = music location
1378  52B0 CD 62 41     	CALL PLY_AKG_INIT
1379  52B3 3E 01        	LD A, 1
1380  52B5 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1381  52B8
1382  52B8 E1           	POP HL ; SFX
1383  52B9              	; check if SFX address -1
1384  52B9 23           	INC HL
1385  52BA 7D           	LD A, L
1386  52BB B4           	OR H
1387  52BC 28 09        	JR Z,.L1
1388  52BE 2B           	DEC HL
1389  52BF CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1390  52C2 3E 01        	LD A, 1
1391  52C4 32 F6 4C     	LD (SFX_INIT_STATUS), A
1392  52C7              .L1:
1393  52C7 D1               POP DE
1394  52C8 C1               POP BC
1395  52C9 CD 60 4E         CALL RESTORE_PAGE_INFO
1396  52CC
1397  52CC E1           	POP HL
1398  52CD C9           	RET
1399  52CE              ; *******************************************************************************************************
1400  52CE
1401  52CE              ; *******************************************************************************************************
1402  52CE              ; function to handle CALL SNDPLYON basic extension
1403  52CE              ; enables sound player
1404  52CE              ; _SNDPLYON
1405  52CE              ; sets SOUND_ENABLED variable to 1 if init call was done
1406  52CE              ; if not throws out of data error
1407  52CE              SNDPLYON:
1408  52CE 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1409  52D1 B7           	OR A
1410  52D2 20 05        	JR NZ, .L1
1411  52D4              	; player not initialized, throw error
1412  52D4 1E 04        	LD E, 04 ; Out of DATA
1413  52D6 C3 06 50     	JP THROW_ERROR
1414  52D9              .L1:
1415  52D9 32 F7 4C     	LD (SOUND_ENABLED), A
1416  52DC              	; disable key click
1417  52DC AF           	XOR A
1418  52DD 32 DB F3     	LD (CLIKSW), A
1419  52E0 C9           	RET
1420  52E1              ; *******************************************************************************************************
1421  52E1
1422  52E1              ; *******************************************************************************************************
1423  52E1              ; function to handle CALL SNDPLYOFF basic extension
1424  52E1              ; disables sound player
1425  52E1              ; _SNDPLYOFF
1426  52E1              ; sets SOUND_ENABLED variable to 0
1427  52E1              ; calls AKG to stop music and SFX on all channels if initialized
1428  52E1              SNDPLYOFF:
1429  52E1 3A F7 4C     	LD A, (SOUND_ENABLED)
1430  52E4 B7           	OR A
1431  52E5 C8           	RET Z ; already stopped
1432  52E6 AF           	XOR A
1433  52E7 32 F7 4C     	LD (SOUND_ENABLED), A
1434  52EA E5           	PUSH HL
1435  52EB CD 21 42     	CALL PLY_AKG_STOP
1436  52EE 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1437  52F1 B7           	OR A
1438  52F2 28 0E        	JR Z, .EXIT ; SFX not in use
1439  52F4 AF           	XOR A
1440  52F5 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1441  52F8 3E 01        	LD A, 1
1442  52FA CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1443  52FD 3E 02        	LD A, 2
1444  52FF CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1445  5302              .EXIT:
1446  5302 E1           	POP HL
1447  5303 C9           	RET
1448  5304              ; *******************************************************************************************************
1449  5304
1450  5304              ; *******************************************************************************************************
1451  5304              ; function to handle CALL SNDSFX basic extension
1452  5304              ; plays a sound effect
1453  5304              ; _SNDSFX ( BYTE sfx_number, >0
1454  5304              ;			BYTE channel, = 0,1 or 2
1455  5304              ;			BYTE inverted_volume = 0-16, 0 being full volume
1456  5304              ; will put ram in page 0 also, page 1 is already there
1457  5304              ; if sound off throws illegal function call
1458  5304              ; if sfx not initialized, throws out of data
1459  5304              SNDSFX:
1460  5304              	; opening (
1461  5304 CD EE 4F     	CALL CHKCHAR
1462  5307 28           	DB '('
1463  5308              	; get sfx_number
1464  5308 DD 21 1C 52  	LD IX, GETBYT
1465  530C CD 59 01     	CALL CALBAS
1466  530F D5           	PUSH DE
1467  5310              	; comma
1468  5310 CD EE 4F     	CALL CHKCHAR
1469  5313 2C           	DB ','
1470  5314              	; get sfx address
1471  5314 DD 21 1C 52  	LD IX, GETBYT
1472  5318 CD 59 01     	CALL CALBAS
1473  531B D5           	PUSH DE
1474  531C              	; comma
1475  531C CD EE 4F     	CALL CHKCHAR
1476  531F 2C           	DB ','
1477  5320              	; get inverted volume
1478  5320 DD 21 1C 52  	LD IX, GETBYT
1479  5324 CD 59 01     	CALL CALBAS
1480  5327 D5           	PUSH DE
1481  5328              	; ending )
1482  5328 CD EE 4F     	CALL CHKCHAR
1483  532B 29           	DB ')'
1484  532C
1485  532C 3A F7 4C     	LD A, (SOUND_ENABLED)
1486  532F B7           	OR A
1487  5330 20 05        	JR NZ, .L1
1488  5332              	; sound disabled, throw illegal function call
1489  5332 1E 05        	LD E, 5
1490  5334 C3 06 50     	JP THROW_ERROR
1491  5337              .L1:
1492  5337 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1493  533A B7           	OR A
1494  533B 20 05        	JR NZ, .L2
1495  533D              	; sfx data not initialized, throw out of data
1496  533D 1E 04        	LD E, 4
1497  533F C3 06 50     	JP THROW_ERROR
1498  5342              .L2:
1499  5342              	; pop  parameters and store away for later
1500  5342 D1           	POP DE ; inverted volume
1501  5343 43           	LD B, E
1502  5344 D1           	POP DE ; channel
1503  5345 4B           	LD C, E
1504  5346 D1           	POP DE
1505  5347 7B           	LD A, E
1506  5348 08           	EX AF, AF'
1507  5349 E5           	PUSH HL ; basic text location
1508  534A D9           	EXX
1509  534B FD 21 52 53  	LD IY, .RET
1510  534F C3 E9 4E     	JP ENABLE_PAGE0
1511  5352              .RET:
1512  5352 D9           	EXX
1513  5353 08           	EX AF, AF'
1514  5354 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1515  5357
1516  5357 D1               POP DE
1517  5358 C1               POP BC
1518  5359 CD 60 4E         CALL RESTORE_PAGE_INFO
1519  535C
1520  535C E1           	POP HL
1521  535D C9           	RET
1522  535E              ; *******************************************************************************************************
1523  535E               ENDIF
1524  535E
1525  535E               IF (SPRITE_CMDS == 1)
1526  535E              ; *******************************************************************************************************
1527  535E              ; function to handle CALL SPRENABLE basic extension
1528  535E              ; initializes sprites handler
1529  535E              ; _SPRENABLE ( INT sprites_attributes_data,
1530  535E              ;			   INT update_variable_location,
1531  535E              ;			   INT sprite_flicker_enabled )
1532  535E              ; expects both locations to be in range #8000+ or throws an error
1533  535E              ; since these should be BASIC variables
1534  535E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
1535  535E              SPRENABLE:
1536  535E              	; opening (
1537  535E CD EE 4F     	CALL CHKCHAR
1538  5361 28           	DB '('
1539  5362              	; get address of sprite attribute table DIM SA%(3,31)
1540  5362 DD 21 2F 54  	LD IX, FRMQNT
1541  5366 CD 59 01     	CALL CALBAS
1542  5369 D5           	PUSH DE
1543  536A              	; comma
1544  536A CD EE 4F     	CALL CHKCHAR
1545  536D 2C           	DB ','
1546  536E              	; get address of sprite update flag location
1547  536E DD 21 2F 54  	LD IX, FRMQNT
1548  5372 CD 59 01     	CALL CALBAS
1549  5375 D5           	PUSH DE
1550  5376              	; comma
1551  5376 CD EE 4F     	CALL CHKCHAR
1552  5379 2C           	DB ','
1553  537A              	; get flicker enabled flag
1554  537A DD 21 2F 54  	LD IX, FRMQNT
1555  537E CD 59 01     	CALL CALBAS
1556  5381 D5           	PUSH DE
1557  5382              	; ending )
1558  5382 CD EE 4F     	CALL CHKCHAR
1559  5385 29           	DB ')'
1560  5386
1561  5386 D1           	POP DE ; get flicker flag
1562  5387 7A           	LD A, D
1563  5388 B3           	OR E
1564  5389 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
1565  538C
1566  538C D1           	POP DE ; update variable location
1567  538D CB 7A        	BIT 7, D ; is address >= &h8000
1568  538F 20 05        	JR NZ, .L1
1569  5391 1E 05        	LD E, 5 ; illegal function call
1570  5393 C3 06 50     	JP THROW_ERROR
1571  5396              .L1:
1572  5396 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
1573  539A D1           	POP DE ; address of sprite attribute table
1574  539B CB 7A        	BIT 7, D ; is address >= &h8000
1575  539D 20 05        	JR NZ, .L2
1576  539F 1E 05        	LD E, 5 ; illegal function call
1577  53A1 C3 06 50     	JP THROW_ERROR
1578  53A4              .L2:
1579  53A4 ED 53 FB 4C  	LD (SPRATR_DATA), DE
1580  53A8 3E 01        	LD A, 1
1581  53AA 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1582  53AD C9           	RET
1583  53AE              ; *******************************************************************************************************
1584  53AE
1585  53AE              ; *******************************************************************************************************
1586  53AE              ; function to handle CALL SPRDISABLE basic extension
1587  53AE              ; disables sprites handling
1588  53AE              ; _SPRDISABLE
1589  53AE              ; resets variable SPRATR_INIT_STATUS
1590  53AE              SPRDISABLE:
1591  53AE AF           	XOR A
1592  53AF 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
1593  53B2 C9           	RET
1594  53B3              ; *******************************************************************************************************
1595  53B3
1596  53B3              ; *******************************************************************************************************
1597  53B3              ; function to handle CALL SPRSET basic extension
1598  53B3              ; sets position, and optionally pattern and color of sprite
1599  53B3              ; _SPRSET ( BYTE sprite_num , valid 0-31
1600  53B3              ;			INT x,
1601  53B3              ;			INT y,
1602  53B3              ;			INT pattern, valid 0-63, otherwise ignored
1603  53B3              ;			INT color, valid 0-15, otherwise ignored
1604  53B3              SPRSET:
1605  53B3 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1606  53B6 B7           	OR A
1607  53B7 20 05        	JR NZ, .L1
1608  53B9 1E 05        	LD E, 5 ; illegal function call
1609  53BB C3 06 50     	JP THROW_ERROR
1610  53BE              .L1:
1611  53BE              	; opening (
1612  53BE CD EE 4F     	CALL CHKCHAR
1613  53C1 28           	DB '('
1614  53C2              	; get sprite number
1615  53C2 DD 21 1C 52  	LD IX, GETBYT
1616  53C6 CD 59 01     	CALL CALBAS
1617  53C9 F5           	PUSH AF
1618  53CA              	; comma
1619  53CA CD EE 4F     	CALL CHKCHAR
1620  53CD 2C           	DB ','
1621  53CE              	; get x
1622  53CE DD 21 2F 54  	LD IX, FRMQNT
1623  53D2 CD 59 01     	CALL CALBAS
1624  53D5 D5           	PUSH DE
1625  53D6              	; comma
1626  53D6 CD EE 4F     	CALL CHKCHAR
1627  53D9 2C           	DB ','
1628  53DA              	; get y
1629  53DA DD 21 2F 54  	LD IX, FRMQNT
1630  53DE CD 59 01     	CALL CALBAS
1631  53E1 D5           	PUSH DE
1632  53E2              	; comma
1633  53E2 CD EE 4F     	CALL CHKCHAR
1634  53E5 2C           	DB ','
1635  53E6              	; get pattern
1636  53E6 DD 21 2F 54  	LD IX, FRMQNT
1637  53EA CD 59 01     	CALL CALBAS
1638  53ED D5           	PUSH DE
1639  53EE              	; comma
1640  53EE CD EE 4F     	CALL CHKCHAR
1641  53F1 2C           	DB ','
1642  53F2              	; get color
1643  53F2 DD 21 2F 54  	LD IX, FRMQNT
1644  53F6 CD 59 01     	CALL CALBAS
1645  53F9 D5           	PUSH DE
1646  53FA              	; ending )
1647  53FA CD EE 4F     	CALL CHKCHAR
1648  53FD 29           	DB ')'
1649  53FE
1650  53FE                  ; save position in BASIC text
1651  53FE E5           	PUSH HL
1652  53FF DD E1        	POP IX
1653  5401
1654  5401 C1           	POP BC ; color
1655  5402 D1           	POP DE ; pattern
1656  5403 D9           	EXX
1657  5404 C1           	POP BC ; y
1658  5405 D1           	POP DE ; x
1659  5406 F1           	POP AF ; sprite number
1660  5407 FE 20        	CP 32
1661  5409 38 05        	JR C, .L2
1662  540B 1E 05        	LD E, 5 ; illegal function call
1663  540D C3 06 50     	JP THROW_ERROR
1664  5410              .L2:
1665  5410              	; find location in sprite attributes table
1666  5410 87          > ADD A, A
1666  5411 87          > ADD A, A
1666  5412 87          > ADD A, A
1667  5413 D5           	PUSH DE
1668  5414 16 00        	LD D, 0
1669  5416 5F           	LD E, A
1670  5417 2A FB 4C     	LD HL, (SPRATR_DATA)
1671  541A 19           	ADD HL, DE
1672  541B D1           	POP DE
1673  541C              	; set y
1674  541C 71           	LD (HL), C
1675  541D 23           	INC HL
1676  541E 70           	LD (HL), B
1677  541F 23           	INC HL
1678  5420              	; set x
1679  5420 73           	LD (HL), E
1680  5421 23           	INC HL
1681  5422 72           	LD (HL), D
1682  5423 23           	INC HL
1683  5424 E5           	PUSH HL
1684  5425 D9           	EXX
1685  5426 E1           	POP HL
1686  5427              	; check if 0<=pattern<64
1687  5427 7A           	LD A, D
1688  5428 B7           	OR A
1689  5429 20 0B        	JR NZ, .L3
1690  542B 7B           	LD A, E
1691  542C FE 40        	CP 64
1692  542E 30 06        	JR NC, .L3
1693  5430              	; set pattern
1694  5430              	;ADD A, A
1695  5430              	;ADD A, A
1696  5430              	;ADD A, A
1697  5430 77           	LD (HL), A
1698  5431 23           	INC HL
1699  5432 72           	LD (HL), D
1700  5433 23           	INC HL
1701  5434 18 02        	JR .L4
1702  5436              .L3:
1703  5436              	; skip pattern
1704  5436 23          > INC HL
1704  5437 23          > INC HL
1705  5438              .L4:
1706  5438              	; check if 0<=color<16
1707  5438 78           	LD A, B
1708  5439 B7           	OR A
1709  543A 20 08        	JR NZ, .L5
1710  543C 79           	LD A, C
1711  543D FE 10        	CP 16
1712  543F 30 03        	JR NC, .L5
1713  5441              	; set color
1714  5441 71           	LD (HL), C
1715  5442 23           	INC HL
1716  5443 70           	LD (HL), B
1717  5444
1718  5444              .L5:
1719  5444 DD E5        	PUSH IX
1720  5446 E1           	POP HL
1721  5447 C9           	RET
1722  5448              ; *******************************************************************************************************
1723  5448
1724  5448              ; *******************************************************************************************************
1725  5448              ; function sets sprite location based on initial coordinates and offset provided
1726  5448              ; input A=sprite number in SPRATR_DATA , 0-31
1727  5448              ; input DE=initial x
1728  5448              ; input BC=initial y
1729  5448              ; input IY=location where delta y,x are located
1730  5448              ; modifies AF, HL, IX
1731  5448              SPRSET_DELTA_POS:
1732  5448 87          > ADD A, A
1732  5449 87          > ADD A, A
1732  544A 87          > ADD A, A
1733  544B D5           	PUSH DE
1734  544C 16 00        	LD D, 0
1735  544E 5F           	LD E, A
1736  544F DD 2A FB 4C  	LD IX, (SPRATR_DATA)
1737  5453 DD 19        	ADD IX, DE
1738  5455 D1           	POP DE
1739  5456              	; IX=sprite's y location
1740  5456 FD 6E 00     	LD L, (IY)
1741  5459 FD 66 01     	LD H, (IY+1)
1742  545C 09           	ADD HL, BC
1743  545D DD 75 00     	LD (IX), L
1744  5460 DD 74 01     	LD (IX+1), H
1745  5463 FD 6E 02     	LD L, (IY+2)
1746  5466 FD 66 03     	LD H, (IY+3)
1747  5469 19           	ADD HL, DE
1748  546A DD 75 02     	LD (IX+2), L
1749  546D DD 74 03     	LD (IX+3), H
1750  5470 C9           	RET
1751  5471              ; *******************************************************************************************************
1752  5471
1753  5471              ; *******************************************************************************************************
1754  5471              ; function to handle CALL SPRGRPMOV basic extension
1755  5471              ; sets position of a group of sprites described with
1756  5471              ; { int sprite_num, int delta_y, int delta_x } [count]
1757  5471              ; _SPRGRPMOV ( INT x,
1758  5471              ;			   INT y,
1759  5471              ;			   INT data_ptr,
1760  5471              ;			   BYTE count,
1761  5471              ; will put ram in page 0 also, page 1 is already there
1762  5471              SPRGRPMOV:
1763  5471 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
1764  5474 B7           	OR A
1765  5475 20 05        	JR NZ, .L1
1766  5477 1E 05        	LD E, 5 ; illegal function call
1767  5479 C3 06 50     	JP THROW_ERROR
1768  547C              .L1:
1769  547C              	; opening (
1770  547C CD EE 4F     	CALL CHKCHAR
1771  547F 28           	DB '('
1772  5480              	; get x
1773  5480 DD 21 2F 54  	LD IX, FRMQNT
1774  5484 CD 59 01     	CALL CALBAS
1775  5487 D5           	PUSH DE
1776  5488              	; comma
1777  5488 CD EE 4F     	CALL CHKCHAR
1778  548B 2C           	DB ','
1779  548C              	; get y
1780  548C DD 21 2F 54  	LD IX, FRMQNT
1781  5490 CD 59 01     	CALL CALBAS
1782  5493 D5           	PUSH DE
1783  5494              	; comma
1784  5494 CD EE 4F     	CALL CHKCHAR
1785  5497 2C           	DB ','
1786  5498              	; get data pointer
1787  5498 DD 21 2F 54  	LD IX, FRMQNT
1788  549C CD 59 01     	CALL CALBAS
1789  549F D5           	PUSH DE
1790  54A0              	; comma
1791  54A0 CD EE 4F     	CALL CHKCHAR
1792  54A3 2C           	DB ','
1793  54A4              	; get count
1794  54A4 DD 21 1C 52  	LD IX, GETBYT
1795  54A8 CD 59 01     	CALL CALBAS
1796  54AB F5           	PUSH AF
1797  54AC              	; ending )
1798  54AC CD EE 4F     	CALL CHKCHAR
1799  54AF 29           	DB ')'
1800  54B0
1801  54B0 E5           	PUSH HL
1802  54B1 DD E1        	POP IX
1803  54B3
1804  54B3 C1           	POP BC ; count
1805  54B4 E1           	POP HL ; data pointer
1806  54B5 D9           	EXX
1807  54B6 C1           	POP BC ; y
1808  54B7 D1           	POP DE ; x
1809  54B8 D9           	EXX
1810  54B9
1811  54B9 DD E5        	PUSH IX ; save position in BASIC buffer
1812  54BB
1813  54BB C5           	PUSH BC
1814  54BC E5           	PUSH HL
1815  54BD AF               XOR A
1816  54BE CD 29 4E         CALL GET_PAGE_INFO
1817  54C1 D9           	EXX
1818  54C2 E1           	POP HL
1819  54C3 F1           	POP AF
1820  54C4 D9           	EXX
1821  54C5 C5               PUSH BC
1822  54C6 D5               PUSH DE
1823  54C7 D9           	EXX
1824  54C8 F5           	PUSH AF
1825  54C9 E5           	PUSH HL
1826  54CA D9           	EXX
1827  54CB 3A 41 F3         LD A, (RAMAD0)
1828  54CE 26 00            LD H, 0
1829  54D0 CD 70 4E         CALL LOCAL_ENASLT
1830  54D3 FB           	EI
1831  54D4 E1           	POP HL
1832  54D5 C1           	POP BC
1833  54D6 CD E0 54     	CALL .UPDATE_LOC
1834  54D9 D1               POP DE
1835  54DA C1               POP BC
1836  54DB CD 60 4E         CALL RESTORE_PAGE_INFO
1837  54DE E1           	POP HL
1838  54DF C9           	RET
1839  54E0
1840  54E0              .UPDATE_LOC:
1841  54E0              .L4:
1842  54E0 7E           	LD A, (HL)
1843  54E1 23           	INC HL
1844  54E2 23           	INC HL
1845  54E3 E5           	PUSH HL
1846  54E4 FD E1        	POP IY
1847  54E6 D9           	EXX
1848  54E7 CD 48 54     	CALL SPRSET_DELTA_POS
1849  54EA D9           	EXX
1850  54EB 23          > INC HL
1850  54EC 23          > INC HL
1850  54ED 23          > INC HL
1850  54EE 23          > INC HL
1851  54EF 10 EF        	DJNZ .L4
1852  54F1 C9           	RET
1853  54F2              ; *******************************************************************************************************
1854  54F2               ENDIF
1855  54F2
1856  54F2               IF (BLIT_CMDS == 1)
1857  54F2              ; *******************************************************************************************************
1858  54F2              ; function rotates mask and data of several characters and applies to background data
1859  54F2              ; this handles x-shift from 0 to 4
1860  54F2              ; contains self-modifying code that is set-up from external function
1861  54F2              ; input HL=pointer to mask data
1862  54F2              ; input HL'=pointer to character data
1863  54F2              ; input DE=output buffer containing background data
1864  54F2              ; input BC=DE+8
1865  54F2              ; input A=number of characters to process
1866  54F2              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1867  54F2              SHIFT04:
1868  54F2 08           	EX AF, AF'
1869  54F3 7E           	LD A, (HL) ; get mask
1870  54F4 D9           	EXX
1871  54F5 57           	LD D, A
1872  54F6 1E FF        	LD E, #FF
1873  54F8 37           	SCF
1874  54F9              .M1:
1875  54F9 18 FE        	JR .M1 ; this is self-modifying part
1876  54FB CB 1A        	RR D
1877  54FD CB 1B        	RR E
1878  54FF CB 1A        	RR D
1879  5501 CB 1B        	RR E
1880  5503 CB 1A        	RR D
1881  5505 CB 1B        	RR E
1882  5507 CB 1A        	RR D
1883  5509 CB 1B        	RR E
1884  550B
1885  550B 46           	LD B, (HL) ; get data
1886  550C 0E 00        	LD C, 0
1887  550E              .M2:
1888  550E 18 FE        	JR .M2 ; also self-modifying part
1889  5510 CB 38        	SRL B
1890  5512 CB 19        	RR C
1891  5514 CB 38        	SRL B
1892  5516 CB 19        	RR C
1893  5518 CB 38        	SRL B
1894  551A CB 19        	RR C
1895  551C CB 38        	SRL B
1896  551E CB 19        	RR C
1897  5520
1898  5520 D9           	EXX
1899  5521 1A           	LD A, (DE) ; background
1900  5522 D9           	EXX
1901  5523 A2           	AND D
1902  5524 B0           	OR B
1903  5525 D9           	EXX
1904  5526 12           	LD (DE), A
1905  5527
1906  5527 0A           	LD A, (BC)
1907  5528 D9           	EXX
1908  5529 A3           	AND E
1909  552A B1           	OR C
1910  552B 23           	INC HL
1911  552C D9           	EXX
1912  552D 02           	LD (BC), A
1913  552E
1914  552E 23           	INC HL
1915  552F 13           	INC DE
1916  5530 03           	INC BC
1917  5531
1918  5531 08           	EX AF, AF'
1919  5532 3D           	DEC A
1920  5533 C2 F2 54     	JP NZ, SHIFT04
1921  5536 C9           	RET
1922  5537              ; *******************************************************************************************************
1923  5537
1924  5537              ; *******************************************************************************************************
1925  5537              ; function rotates mask and data of several characters and applies to background data
1926  5537              ; this handles x-shift from 5 to 8
1927  5537              ; contains self-modifying code that is set-up from external function
1928  5537              ; input HL=pointer to mask data
1929  5537              ; input HL'=pointer to character data
1930  5537              ; input DE=output buffer containing background data
1931  5537              ; input BC=DE+8
1932  5537              ; input A=number of characters to process
1933  5537              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1934  5537              SHIFT58:
1935  5537 08           	EX AF, AF'
1936  5538 7E           	LD A, (HL) ; get mask
1937  5539 D9           	EXX
1938  553A 57           	LD D, A
1939  553B 1E FF        	LD E, #FF
1940  553D 37           	SCF
1941  553E              .M1:
1942  553E 18 FE        	JR .M1 ; this is self-modifying part
1943  5540 CB 12        	RL D
1944  5542 CB 13        	RL E
1945  5544 CB 12        	RL D
1946  5546 CB 13        	RL E
1947  5548 CB 12        	RL D
1948  554A CB 13        	RL E
1949  554C
1950  554C 46           	LD B, (HL)
1951  554D 0E 00        	LD C, 0
1952  554F              .M2:
1953  554F 18 FE        	JR .M2 ; also self-modifying part
1954  5551 CB 20        	SLA B
1955  5553 CB 11        	RL C
1956  5555 CB 20        	SLA B
1957  5557 CB 11        	RL C
1958  5559 CB 20        	SLA B
1959  555B CB 11        	RL C
1960  555D
1961  555D D9           	EXX
1962  555E 1A           	LD A, (DE) ; background
1963  555F D9           	EXX
1964  5560 A3           	AND E
1965  5561 B1           	OR C
1966  5562 D9           	EXX
1967  5563 12           	LD (DE), A
1968  5564
1969  5564 0A           	LD A, (BC)
1970  5565 D9           	EXX
1971  5566 A2           	AND D
1972  5567 B0           	OR B
1973  5568 23           	INC HL
1974  5569 D9           	EXX
1975  556A 02           	LD (BC), A
1976  556B
1977  556B 23           	INC HL
1978  556C 13           	INC DE
1979  556D 03           	INC BC
1980  556E
1981  556E 08           	EX AF, AF'
1982  556F 3D           	DEC A
1983  5570 C2 37 55     	JP NZ, SHIFT58
1984  5573 C9           	RET
1985  5574              ; *******************************************************************************************************
1986  5574
1987  5574              ; *******************************************************************************************************
1988  5574              ; routine that shifts one row of characters
1989  5574              ; contains self-modifying code that is set-up from external function
1990  5574              ; input HL=pointer to mask data
1991  5574              ; input HL'=pointer to character data
1992  5574              ; input DE=output buffer containing background data
1993  5574              ; input A=number of characters to process
1994  5574              ; input IX=pointer to structure describing input data
1995  5574              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1996  5574              SHIFT_ROW:
1997  5574 F5           	PUSH AF
1998  5575 ED 53 01 4D  		LD (BLIT_TMP1), DE
1999  5579 E5           		PUSH HL
2000  557A CD BD 55     			CALL .ADDYSHIFT
2001  557D E1           		POP HL
2002  557E ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
2003  5582              .L1:
2004  5582 3E 08        		LD A, 8
2005  5584 DD 96 02     		SUB (IX+2) ; y shift
2006  5587              .CALL1:
2007  5587 CD 00 00     		CALL 0
2008  558A DD 7E 02     		LD A, (IX+2); y shift
2009  558D B7           		OR A
2010  558E 28 26        		JR Z, .DONE
2011  5590 ED 5B 01 4D  		LD DE, (BLIT_TMP1)
2012  5594 E5           		PUSH HL
2013  5595 CD CB 55     			CALL .DETONEXTROW
2014  5598 E1           		POP HL
2015  5599              .CALL2:
2016  5599 CD 00 00     		CALL 0
2017  559C ED 5B 01 4D  		LD DE, (BLIT_TMP1)
2018  55A0 E5           		PUSH HL
2019  55A1 CD C5 55     			CALL .ADD8
2020  55A4 E1           		POP HL
2021  55A5 ED 53 01 4D  		LD (BLIT_TMP1), DE
2022  55A9 ED 5B 03 4D  		LD DE, (BLIT_TMP2)
2023  55AD E5           		PUSH HL
2024  55AE CD C5 55     			CALL .ADD8
2025  55B1 E1           		POP HL
2026  55B2 ED 53 03 4D  		LD (BLIT_TMP2), DE ; DE+vertical shift
2027  55B6              .DONE:
2028  55B6 F1           	POP AF
2029  55B7 3D           	DEC A
2030  55B8 C8           	RET Z
2031  55B9 F5           	PUSH AF
2032  55BA C3 82 55     	JP .L1
2033  55BD              .ADDYSHIFT:
2034  55BD EB           	EX DE, HL
2035  55BE 16 00        	LD D, 0
2036  55C0 DD 5E 02     	LD E, (IX+2); y shift
2037  55C3 18 0C        	JR .MOVDEBC
2038  55C5              .ADD8:
2039  55C5 21 08 00     	LD HL, 8
2040  55C8 C3 D1 55     	JP .MOVDEBC
2041  55CB              .DETONEXTROW:
2042  55CB DD 6E 06     	LD L, (IX+6)
2043  55CE DD 66 07     	LD H, (IX+7) ; bkg add to value
2044  55D1              .MOVDEBC:
2045  55D1 19           	ADD HL, DE
2046  55D2 54           	LD D, H
2047  55D3 5D           	LD E, L
2048  55D4 01 08 00     	LD BC, 8
2049  55D7 09           	ADD HL, BC
2050  55D8 44           	LD B, H
2051  55D9 4D           	LD C, L
2052  55DA C9           	RET
2053  55DB              ; *******************************************************************************************************
2054  55DB
2055  55DB              ; *******************************************************************************************************
2056  55DB              ; function rotates mask and character data and applies it to background
2057  55DB              ; input IX=pointer to structure describing input data
2058  55DB              ; +0  DW horizontal shift count 0-7 (low byte used)
2059  55DB              ; +2  DW vertical shift count 0-7 (low byte used)
2060  55DB              ; +4  DW background data start;
2061  55DB              ; +6  DW background add to value to next row of background data
2062  55DB              ; +8  DW mask data start;
2063  55DB              ; +10  DW character data start;
2064  55DB              ; +12 DW character&mask add to value to next row of data
2065  55DB              ; +14 DW columns (low byte used)
2066  55DB              ; +16 DW rows (low byte used)
2067  55DB              SHIFT_MERGE_CHARACTER:
2068  55DB DD 7E 00     	LD A, (IX) ; shift
2069  55DE FE 05        	CP 5
2070  55E0 38 25        	JR C, .RIGHT
2071  55E2              	; shifts 5-7, use rotate towards left 1-3
2072  55E2 21 37 55     	LD HL, SHIFT58
2073  55E5 22 88 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2074  55E8 22 9A 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2075  55EB D6 05        	SUB 5
2076  55ED 28 0D        	JR Z, .L1
2077  55EF 87           	ADD A, A
2078  55F0 87           	ADD A, A
2079  55F1 67           	LD H, A
2080  55F2 2E 18        	LD L, #18 ; JR opcode
2081  55F4 22 3E 55     	LD (SHIFT58.M1), HL
2082  55F7 22 4F 55     	LD (SHIFT58.M2), HL
2083  55FA 18 32        	JR .DO
2084  55FC              .L1:
2085  55FC 21 00 00     	LD HL, 0 ; 2xNOP opcode
2086  55FF 22 3E 55     	LD (SHIFT58.M1), HL
2087  5602 22 4F 55     	LD (SHIFT58.M2), HL
2088  5605 18 27        	JR .DO
2089  5607              .RIGHT:
2090  5607              	; shifts 0-4, rotate towards right
2091  5607 21 F2 54     	LD HL, SHIFT04
2092  560A 22 88 55     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
2093  560D 22 9A 55     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
2094  5610 FE 04        	CP 4
2095  5612 28 11        	JR Z, .R1
2096  5614 D6 04        	SUB 4
2097  5616 ED 44        	NEG
2098  5618 87           	ADD A, A
2099  5619 87           	ADD A, A
2100  561A 67           	LD H, A
2101  561B 2E 18        	LD L, #18 ; JR opcode
2102  561D 22 F9 54     	LD (SHIFT04.M1), HL
2103  5620 22 0E 55     	LD (SHIFT04.M2), HL
2104  5623 18 09        	JR .DO
2105  5625              .R1:
2106  5625 21 00 00     	LD HL, 0 ; 2xNOP opcode
2107  5628 22 F9 54     	LD (SHIFT04.M1), HL
2108  562B 22 0E 55     	LD (SHIFT04.M2), HL
2109  562E              .DO:
2110  562E DD 46 10     	LD B, (IX+16) ; rows
2111  5631 DD 6E 08     	LD L, (IX+8)
2112  5634 DD 66 09     	LD H, (IX+9) ; mask data
2113  5637 DD 5E 04     	LD E, (IX+4)
2114  563A DD 56 05     	LD D, (IX+5) ; background data
2115  563D D9           	EXX
2116  563E DD 6E 0A     	LD L, (IX+10)
2117  5641 DD 66 0B     	LD H, (IX+11) ; character data
2118  5644 D9           	EXX
2119  5645              .LOOP:
2120  5645 C5           	PUSH BC
2121  5646 E5           		PUSH HL
2122  5647 D5           			PUSH DE
2123  5648 D9           				EXX
2124  5649 E5           				PUSH HL
2125  564A D9           					EXX
2126  564B DD 7E 0E     					LD A, (IX+14) ; columns
2127  564E              .CALL:
2128  564E CD 74 55     					CALL SHIFT_ROW
2129  5651 E1           				POP HL
2130  5652 DD 5E 0C     				LD E, (IX+12)
2131  5655 DD 56 0D     				LD D, (IX+13) ; char data to next row
2132  5658 19           				ADD HL, DE
2133  5659 D9           				EXX
2134  565A E1           			POP HL
2135  565B DD 5E 06     			LD E, (IX+6)
2136  565E DD 56 07     			LD D, (IX+7) ; background to next row
2137  5661 19           			ADD HL, DE
2138  5662 EB           			EX DE, HL
2139  5663 E1           		POP HL
2140  5664 DD 4E 0C     		LD C, (IX+12)
2141  5667 DD 46 0D     		LD B, (IX+13) ; char data to next row
2142  566A 09           		ADD HL, BC
2143  566B C1           	POP BC
2144  566C 10 D7        	DJNZ .LOOP
2145  566E C9           	RET
2146  566F              ; *******************************************************************************************************
2147  566F
2148  566F               IFNDEF CMDS_WITH_PARAMETERS
2149  566F ~            ; *******************************************************************************************************
2150  566F ~            ; function to handle CALL BLIT basic extension
2151  566F ~            ; rotates 1-bit character drawing horizontally with mask and character data and
2152  566F ~            ; fuses with background data and applies vertical shift too
2153  566F ~            ; BLIT ( INT request_data_ptr )
2154  566F ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
2155  566F ~            ; will put ram in page 0 also, page 1 is already there
2156  566F ~            BLIT:
2157  566F ~            	; opening (
2158  566F ~            	CALL CHKCHAR
2159  566F ~            	DB '('
2160  566F ~            	; get pointer to request struct
2161  566F ~            	LD IX, FRMQNT
2162  566F ~            	CALL CALBAS
2163  566F ~            	PUSH DE
2164  566F ~            	; ending )
2165  566F ~            	CALL CHKCHAR
2166  566F ~            	DB ')'
2167  566F ~
2168  566F ~            	POP IX ; pointer to request struct
2169  566F ~
2170  566F ~            	PUSH HL ; save position in BASIC buffer
2171  566F ~
2172  566F ~            	LD IY, .RET
2173  566F ~            	JP ENABLE_PAGE0
2174  566F ~            .RET:
2175  566F ~            	EI
2176  566F ~            	CALL SHIFT_MERGE_CHARACTER
2177  566F ~
2178  566F ~                POP DE
2179  566F ~                POP BC
2180  566F ~                CALL RESTORE_PAGE_INFO
2181  566F ~
2182  566F ~            	POP HL
2183  566F ~            	RET
2184  566F ~            ; *******************************************************************************************************
2185  566F               ENDIF
2186  566F
2187  566F               IFDEF CMDS_WITH_PARAMETERS
2188  566F              ; *******************************************************************************************************
2189  566F              ; function to handle CALL BLIT basic extension
2190  566F              ; rotates 1-bit character drawing horizontally with mask and character data and
2191  566F              ; fuses with background data and applies vertical shift too
2192  566F              ; in form without pointers
2193  566F              ; BLIT ( INT x,
2194  566F              ;		 INT y,
2195  566F              ;		 INT char_data_pointer,
2196  566F              ;		 INT mask_data_pointer,
2197  566F              ;		 INT width (in characters),
2198  566F              ;		 INT height (in characters),
2199  566F              ;		 INT background_pointer (top left),
2200  566F              ;		 INT background_width (in characters),
2201  566F              ;		 INT background_height (in characters))
2202  566F              ; will put ram in page 0 also, page 1 is already there
2203  566F              BLIT:
2204  566F              	; opening (
2205  566F CD EE 4F     	CALL CHKCHAR
2206  5672 28           	DB '('
2207  5673              	; get x coordinate
2208  5673 DD 21 2F 54  	LD IX, FRMQNT
2209  5677 CD 59 01     	CALL CALBAS
2210  567A 7B           	LD A, E
2211  567B E6 07        	AND 7
2212  567D 32 05 4D     	LD (BLIT_STRUCT+0), A
2213  5680 CD 5D 57     	CALL .DAdiv8
2214  5683 32 01 4D     	LD (BLIT_TMP+0),A
2215  5686              	; comma
2216  5686 CD EE 4F     	CALL CHKCHAR
2217  5689 2C           	DB ','
2218  568A              	; get y coordinate
2219  568A DD 21 2F 54  	LD IX, FRMQNT
2220  568E CD 59 01     	CALL CALBAS
2221  5691 7B           	LD A, E
2222  5692 E6 07        	AND 7
2223  5694 32 07 4D     	LD (BLIT_STRUCT+2), A
2224  5697 CD 5D 57     	CALL .DAdiv8
2225  569A 32 02 4D     	LD (BLIT_TMP+1),A
2226  569D              	; comma
2227  569D CD EE 4F     	CALL CHKCHAR
2228  56A0 2C           	DB ','
2229  56A1              	; get char data pointer
2230  56A1 DD 21 2F 54  	LD IX, FRMQNT
2231  56A5 CD 59 01     	CALL CALBAS
2232  56A8 ED 53 0F 4D  	LD (BLIT_STRUCT+10), DE
2233  56AC              	; comma
2234  56AC CD EE 4F     	CALL CHKCHAR
2235  56AF 2C           	DB ','
2236  56B0              	; get mask data pointer
2237  56B0 DD 21 2F 54  	LD IX, FRMQNT
2238  56B4 CD 59 01     	CALL CALBAS
2239  56B7 ED 53 0D 4D  	LD (BLIT_STRUCT+8), DE
2240  56BB              	; comma
2241  56BB CD EE 4F     	CALL CHKCHAR
2242  56BE 2C           	DB ','
2243  56BF              	; get width
2244  56BF DD 21 2F 54  	LD IX, FRMQNT
2245  56C3 CD 59 01     	CALL CALBAS
2246  56C6 7B           	LD A, E
2247  56C7 32 13 4D     	LD (BLIT_STRUCT+14), A
2248  56CA              	; comma
2249  56CA CD EE 4F     	CALL CHKCHAR
2250  56CD 2C           	DB ','
2251  56CE              	; get height
2252  56CE DD 21 2F 54  	LD IX, FRMQNT
2253  56D2 CD 59 01     	CALL CALBAS
2254  56D5 7B           	LD A, E
2255  56D6 32 15 4D     	LD (BLIT_STRUCT+16), A
2256  56D9              	; comma
2257  56D9 CD EE 4F     	CALL CHKCHAR
2258  56DC 2C           	DB ','
2259  56DD              	; get background pointer
2260  56DD DD 21 2F 54  	LD IX, FRMQNT
2261  56E1 CD 59 01     	CALL CALBAS
2262  56E4 ED 53 09 4D  	LD (BLIT_STRUCT+4), DE
2263  56E8              	; comma
2264  56E8 CD EE 4F     	CALL CHKCHAR
2265  56EB 2C           	DB ','
2266  56EC              	; get background width
2267  56EC DD 21 2F 54  	LD IX, FRMQNT
2268  56F0 CD 59 01     	CALL CALBAS
2269  56F3 7B           	LD A, E
2270  56F4 32 03 4D     	LD (BLIT_TMP+2), A
2271  56F7              	; comma
2272  56F7 CD EE 4F     	CALL CHKCHAR
2273  56FA 2C           	DB ','
2274  56FB              	; get background height
2275  56FB DD 21 2F 54  	LD IX, FRMQNT
2276  56FF CD 59 01     	CALL CALBAS
2277  5702 7B           	LD A, E
2278  5703 32 04 4D     	LD (BLIT_TMP+3), A
2279  5706              	; ending )
2280  5706 CD EE 4F     	CALL CHKCHAR
2281  5709 29           	DB ')'
2282  570A
2283  570A E5           	PUSH HL ; save position in BASIC buffer
2284  570B
2285  570B              	; calculate char&mask add to value
2286  570B 26 00        	LD H, 0
2287  570D 3A 13 4D     	LD A, (BLIT_STRUCT+14)
2288  5710 6F           	LD L, A
2289  5711 CD 25 4E     	CALL HLx8
2290  5714 22 11 4D     	LD (BLIT_STRUCT+12), HL
2291  5717              	; calculate background add to value
2292  5717 26 00        	LD H, 0
2293  5719 3A 03 4D     	LD A, (BLIT_TMP+2)
2294  571C 6F           	LD L, A
2295  571D CD 25 4E     	CALL HLx8
2296  5720 22 0B 4D     	LD (BLIT_STRUCT+6), HL
2297  5723              	; calculate pointer to background location
2298  5723 21 00 00     	LD HL, 0
2299  5726 3A 02 4D     	LD A,(BLIT_TMP+1)
2300  5729 B7           	OR A
2301  572A 28 08        	JR Z, .L1
2302  572C 47           	LD B,A
2303  572D ED 5B 0B 4D  	LD DE,(BLIT_STRUCT+6)
2304  5731              .L0:
2305  5731 19           	ADD HL, DE
2306  5732 10 FD        	DJNZ .L0
2307  5734              .L1:
2308  5734 EB           	EX DE,HL
2309  5735 26 00        	LD H,0
2310  5737 3A 01 4D     	LD A,(BLIT_TMP+0)
2311  573A 6F           	LD L,A
2312  573B CD 25 4E     	CALL HLx8
2313  573E 19           	ADD HL,DE
2314  573F ED 5B 09 4D  	LD DE,(BLIT_STRUCT+4)
2315  5743 19           	ADD HL,DE
2316  5744 22 09 4D     	LD (BLIT_STRUCT+4),HL
2317  5747
2318  5747 FD 21 4E 57  	LD IY, .RET
2319  574B C3 E9 4E     	JP ENABLE_PAGE0
2320  574E              .RET:
2321  574E FB           	EI
2322  574F DD 21 05 4D  	LD IX, BLIT_STRUCT
2323  5753 CD DB 55     	CALL SHIFT_MERGE_CHARACTER
2324  5756
2325  5756 D1               POP DE
2326  5757 C1               POP BC
2327  5758 CD 60 4E         CALL RESTORE_PAGE_INFO
2328  575B
2329  575B E1           	POP HL
2330  575C C9           	RET
2331  575D              .DAdiv8:
2332  575D 7B           	LD A,E
2333  575E CB 2A        	SRA D
2334  5760 CB 1F            RR  A
2335  5762 CB 2A            SRA D
2336  5764 CB 1F            RR  A
2337  5766 CB 2A            SRA D
2338  5768 CB 1F            RR  A
2339  576A C9           	RET
2340  576B              ; *******************************************************************************************************
2341  576B               ENDIF
2342  576B               ENDIF
2343  576B
2344  576B               IF (TILE_CMDS == 1)
2345  576B              ; *******************************************************************************************************
2346  576B              ; generic function to implement tiling
2347  576B              ; should be modified to call appropriate function for memory or vram
2348  576B              ; input IX=pointer to following structure
2349  576B              ; +00 tile_data_ptr
2350  576B              ; +02 tile_rows
2351  576B              ; +04 tile_columns
2352  576B              ; +06 destination_address
2353  576B              ; +08 dest_to_next_row_add_to_value
2354  576B              ; +10 num_horizontal_tiles
2355  576B              ; +12 num_vertical_tiles
2356  576B              ; modifies AF, BC, DE, HL
2357  576B              TILE:
2358  576B DD 6E 06     	LD L, (IX+6)
2359  576E DD 66 07     	LD H, (IX+7) ; destination address
2360  5771 22 01 4D     	LD (TILETMP1), HL
2361  5774 DD 46 0C     	LD B, (IX+12) ; vertical tile number
2362  5777              .L1:
2363  5777 C5           	PUSH BC
2364  5778 DD 6E 00     		LD L, (IX+0)
2365  577B DD 66 01     		LD H, (IX+1) ; tile address
2366  577E 22 03 4D     		LD (TILETMP2), HL
2367  5781 DD 46 02     		LD B, (IX+2) ; tile rows
2368  5784              .L2:
2369  5784 C5           		PUSH BC
2370  5785              .CALL1:
2371  5785 CD 00 00     			CALL 0
2372  5788 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
2373  578B              .L3:
2374  578B C5           			PUSH BC
2375  578C 2A 03 4D     				LD HL, (TILETMP2)
2376  578F DD 46 04     				LD B, (IX+4) ; tile columns
2377  5792              .L4:
2378  5792 C5           				PUSH BC
2379  5793              .CALL2:
2380  5793 CD 00 00     					CALL 0
2381  5796 C1           				POP BC
2382  5797 10 F9        				DJNZ .L4
2383  5799 C1           			POP BC
2384  579A 10 EF        			DJNZ .L3
2385  579C 22 03 4D     			LD (TILETMP2), HL
2386  579F 2A 01 4D     			LD HL, (TILETMP1)
2387  57A2 DD 5E 08     			LD E, (IX+8)
2388  57A5 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
2389  57A8 19           			ADD HL, DE
2390  57A9 22 01 4D     			LD (TILETMP1), HL
2391  57AC C1           		POP BC
2392  57AD 10 D5        		DJNZ .L2
2393  57AF C1           	POP BC
2394  57B0 10 C5        	DJNZ .L1
2395  57B2 C9           	RET
2396  57B3              ; *******************************************************************************************************
2397  57B3
2398  57B3               IFNDEF CMDS_WITH_PARAMETERS
2399  57B3 ~            ; *******************************************************************************************************
2400  57B3 ~            ; function to handle CALL TILERAM basic extension
2401  57B3 ~            ; fills memory with tiles
2402  57B3 ~            ; TILERAM ( INT request_data_ptr )
2403  57B3 ~            ; request_data_ptr described in TILE
2404  57B3 ~            ; will put ram in page 0 also, page 1 is already there
2405  57B3 ~            TILERAM:
2406  57B3 ~            	; opening (
2407  57B3 ~            	CALL CHKCHAR
2408  57B3 ~            	DB '('
2409  57B3 ~            	; get pointer to request struct
2410  57B3 ~            	LD IX, FRMQNT
2411  57B3 ~            	CALL CALBAS
2412  57B3 ~            	PUSH DE
2413  57B3 ~            	; ending )
2414  57B3 ~            	CALL CHKCHAR
2415  57B3 ~            	DB ')'
2416  57B3 ~
2417  57B3 ~            	POP IX ; pointer to request struct
2418  57B3 ~
2419  57B3 ~            	PUSH HL ; save position in BASIC buffer
2420  57B3 ~
2421  57B3 ~            	LD IY, .RET
2422  57B3 ~            	JP ENABLE_PAGE0
2423  57B3 ~            .RET:
2424  57B3 ~            	EI
2425  57B3 ~            	; set RAM functions to call
2426  57B3 ~            	LD HL, .TILECOPY
2427  57B3 ~            	LD (TILE.CALL2+1), HL
2428  57B3 ~            	LD HL, .SETDESTROW
2429  57B3 ~            	LD (TILE.CALL1+1), HL
2430  57B3 ~            	CALL TILE
2431  57B3 ~
2432  57B3 ~                POP DE
2433  57B3 ~                POP BC
2434  57B3 ~                CALL RESTORE_PAGE_INFO
2435  57B3 ~
2436  57B3 ~            	POP HL
2437  57B3 ~            	RET
2438  57B3 ~            .TILECOPY:
2439  57B3 ~            	.8 LDI
2440  57B3 ~            	RET
2441  57B3 ~            .SETDESTROW:
2442  57B3 ~            	LD DE, (TILETMP1)
2443  57B3 ~            	RET
2444  57B3 ~            ; *******************************************************************************************************
2445  57B3               ENDIF
2446  57B3
2447  57B3               IFDEF CMDS_WITH_PARAMETERS
2448  57B3              ; *******************************************************************************************************
2449  57B3              ; function to handle CALL TILERAM basic extension
2450  57B3              ; fills memory with tiles
2451  57B3              ; TILERAM ( INT tile_data_pointer,
2452  57B3              ;			INT tile_columns,
2453  57B3              ;			INT tile_rows,
2454  57B3              ;			INT destination_pointer,
2455  57B3              ;			INT destination_columns,
2456  57B3              ;			INT destination_rows,
2457  57B3              ;			INT destination_begin_column,
2458  57B3              ;			INT destination_begin_row,
2459  57B3              ;			INT number_of_tiles_horizontally,
2460  57B3              ;			INT	number_of_tiles_vertically )
2461  57B3              ; will put ram in page 0 also, page 1 is already there
2462  57B3              TILERAM:
2463  57B3              	; opening (
2464  57B3 CD EE 4F     	CALL CHKCHAR
2465  57B6 28           	DB '('
2466  57B7              	; get tile data pointer coordinate
2467  57B7 DD 21 2F 54  	LD IX, FRMQNT
2468  57BB CD 59 01     	CALL CALBAS
2469  57BE ED 53 05 4D  	LD (BLIT_STRUCT+0), DE
2470  57C2              	; comma
2471  57C2 CD EE 4F     	CALL CHKCHAR
2472  57C5 2C           	DB ','
2473  57C6              	; get tile columns
2474  57C6 DD 21 2F 54  	LD IX, FRMQNT
2475  57CA CD 59 01     	CALL CALBAS
2476  57CD ED 53 09 4D  	LD (BLIT_STRUCT+4), DE
2477  57D1              	; comma
2478  57D1 CD EE 4F     	CALL CHKCHAR
2479  57D4 2C           	DB ','
2480  57D5              	; get tile columns
2481  57D5 DD 21 2F 54  	LD IX, FRMQNT
2482  57D9 CD 59 01     	CALL CALBAS
2483  57DC ED 53 07 4D  	LD (BLIT_STRUCT+2), DE
2484  57E0              	; comma
2485  57E0 CD EE 4F     	CALL CHKCHAR
2486  57E3 2C           	DB ','
2487  57E4              	; get destintion pointer
2488  57E4 DD 21 2F 54  	LD IX, FRMQNT
2489  57E8 CD 59 01     	CALL CALBAS
2490  57EB ED 53 0B 4D  	LD (BLIT_STRUCT+6), DE
2491  57EF              	; comma
2492  57EF CD EE 4F     	CALL CHKCHAR
2493  57F2 2C           	DB ','
2494  57F3              	; get destination columns
2495  57F3 DD 21 2F 54  	LD IX, FRMQNT
2496  57F7 CD 59 01     	CALL CALBAS
2497  57FA 7B           	LD A, E
2498  57FB 32 01 4D     	LD (BLIT_TMP+0), A
2499  57FE              	; comma
2500  57FE CD EE 4F     	CALL CHKCHAR
2501  5801 2C           	DB ','
2502  5802              	; get destination rows
2503  5802 DD 21 2F 54  	LD IX, FRMQNT
2504  5806 CD 59 01     	CALL CALBAS
2505  5809 7B           	LD A, E
2506  580A 32 02 4D     	LD (BLIT_TMP+1), A
2507  580D              	; comma
2508  580D CD EE 4F     	CALL CHKCHAR
2509  5810 2C           	DB ','
2510  5811              	; get destination begin column
2511  5811 DD 21 2F 54  	LD IX, FRMQNT
2512  5815 CD 59 01     	CALL CALBAS
2513  5818 7B           	LD A, E
2514  5819 32 03 4D     	LD (BLIT_TMP+2), A
2515  581C              	; comma
2516  581C CD EE 4F     	CALL CHKCHAR
2517  581F 2C           	DB ','
2518  5820              	; get destination begin row
2519  5820 DD 21 2F 54  	LD IX, FRMQNT
2520  5824 CD 59 01     	CALL CALBAS
2521  5827 7B           	LD A, E
2522  5828 32 04 4D     	LD (BLIT_TMP+3), A
2523  582B              	; comma
2524  582B CD EE 4F     	CALL CHKCHAR
2525  582E 2C           	DB ','
2526  582F              	; get number of tiles horizontally
2527  582F DD 21 2F 54  	LD IX, FRMQNT
2528  5833 CD 59 01     	CALL CALBAS
2529  5836 ED 53 0F 4D  	LD (BLIT_STRUCT+10), DE
2530  583A              	; comma
2531  583A CD EE 4F     	CALL CHKCHAR
2532  583D 2C           	DB ','
2533  583E              	; get number of tiles vertically
2534  583E DD 21 2F 54  	LD IX, FRMQNT
2535  5842 CD 59 01     	CALL CALBAS
2536  5845 ED 53 11 4D  	LD (BLIT_STRUCT+12), DE
2537  5849              	; ending )
2538  5849 CD EE 4F     	CALL CHKCHAR
2539  584C 29           	DB ')'
2540  584D
2541  584D E5           	PUSH HL ; save position in BASIC buffer
2542  584E
2543  584E              	; calculate destination add to value
2544  584E 26 00        	LD H, 0
2545  5850 3A 01 4D     	LD A, (BLIT_TMP+0)
2546  5853 6F           	LD L, A
2547  5854 CD 25 4E     	CALL HLx8
2548  5857 22 0D 4D     	LD (BLIT_STRUCT+8), HL
2549  585A              	; calculate pointer to background location
2550  585A 21 00 00     	LD HL, 0
2551  585D 3A 04 4D     	LD A,(BLIT_TMP+3)
2552  5860 B7           	OR A
2553  5861 28 08        	JR Z, .L1
2554  5863 47           	LD B,A
2555  5864 ED 5B 0D 4D  	LD DE,(BLIT_STRUCT+8)
2556  5868              .L0:
2557  5868 19           	ADD HL, DE
2558  5869 10 FD        	DJNZ .L0
2559  586B              .L1:
2560  586B EB           	EX DE,HL
2561  586C 26 00        	LD H,0
2562  586E 3A 03 4D     	LD A,(BLIT_TMP+2)
2563  5871 6F           	LD L,A
2564  5872 CD 25 4E     	CALL HLx8
2565  5875 19           	ADD HL,DE
2566  5876 ED 5B 0B 4D  	LD DE,(BLIT_STRUCT+6)
2567  587A 19           	ADD HL,DE
2568  587B 22 0B 4D     	LD (BLIT_STRUCT+6),HL
2569  587E
2570  587E FD 21 85 58  	LD IY, .RET
2571  5882 C3 E9 4E     	JP ENABLE_PAGE0
2572  5885              .RET:
2573  5885 FB           	EI
2574  5886              	; set RAM functions to call
2575  5886 21 A0 58     	LD HL, .TILECOPY
2576  5889 22 94 57     	LD (TILE.CALL2+1), HL
2577  588C 21 B1 58     	LD HL, .SETDESTROW
2578  588F 22 86 57     	LD (TILE.CALL1+1), HL
2579  5892 DD 21 05 4D  	LD IX,BLIT_STRUCT
2580  5896 CD 6B 57     	CALL TILE
2581  5899
2582  5899 D1               POP DE
2583  589A C1               POP BC
2584  589B CD 60 4E         CALL RESTORE_PAGE_INFO
2585  589E
2586  589E E1           	POP HL
2587  589F C9           	RET
2588  58A0              .TILECOPY:
2589  58A0 ED A0       > LDI
2589  58A2 ED A0       > LDI
2589  58A4 ED A0       > LDI
2589  58A6 ED A0       > LDI
2589  58A8 ED A0       > LDI
2589  58AA ED A0       > LDI
2589  58AC ED A0       > LDI
2589  58AE ED A0       > LDI
2590  58B0 C9           	RET
2591  58B1              .SETDESTROW:
2592  58B1 ED 5B 01 4D  	LD DE, (TILETMP1)
2593  58B5 C9           	RET
2594  58B6              ; *******************************************************************************************************
2595  58B6               ENDIF
2596  58B6
2597  58B6               IFDEF CMDS_WITH_PARAMETERS
2598  58B6              ; *******************************************************************************************************
2599  58B6              ; function to handle CALL TILEVRM basic extension
2600  58B6              ; fills vram with tiles
2601  58B6              ; TILEVRM ( INT tile_data_pointer,
2602  58B6              ;			INT tile_columns,
2603  58B6              ;			INT tile_rows,
2604  58B6              ;			INT destination_begin_column,
2605  58B6              ;			INT destination_begin_row,
2606  58B6              ;			INT number_of_tiles_horizontally,
2607  58B6              ;			INT	number_of_tiles_vertically )
2608  58B6              ; will put ram in page 0 also, page 1 is already there
2609  58B6              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2610  58B6              TILEVRM:
2611  58B6              	; opening (
2612  58B6 CD EE 4F     	CALL CHKCHAR
2613  58B9 28           	DB '('
2614  58BA              	; get tile data pointer coordinate
2615  58BA DD 21 2F 54  	LD IX, FRMQNT
2616  58BE CD 59 01     	CALL CALBAS
2617  58C1 ED 53 05 4D  	LD (BLIT_STRUCT+0), DE
2618  58C5              	; comma
2619  58C5 CD EE 4F     	CALL CHKCHAR
2620  58C8 2C           	DB ','
2621  58C9              	; get tile columns
2622  58C9 DD 21 2F 54  	LD IX, FRMQNT
2623  58CD CD 59 01     	CALL CALBAS
2624  58D0 ED 53 09 4D  	LD (BLIT_STRUCT+4), DE
2625  58D4              	; comma
2626  58D4 CD EE 4F     	CALL CHKCHAR
2627  58D7 2C           	DB ','
2628  58D8              	; get tile columns
2629  58D8 DD 21 2F 54  	LD IX, FRMQNT
2630  58DC CD 59 01     	CALL CALBAS
2631  58DF ED 53 07 4D  	LD (BLIT_STRUCT+2), DE
2632  58E3              	; comma
2633  58E3 CD EE 4F     	CALL CHKCHAR
2634  58E6 2C           	DB ','
2635  58E7              	; get destination begin column
2636  58E7 DD 21 2F 54  	LD IX, FRMQNT
2637  58EB CD 59 01     	CALL CALBAS
2638  58EE 7B           	LD A, E
2639  58EF 32 03 4D     	LD (BLIT_TMP+2), A
2640  58F2              	; comma
2641  58F2 CD EE 4F     	CALL CHKCHAR
2642  58F5 2C           	DB ','
2643  58F6              	; get destination begin row
2644  58F6 DD 21 2F 54  	LD IX, FRMQNT
2645  58FA CD 59 01     	CALL CALBAS
2646  58FD 7B           	LD A, E
2647  58FE 32 04 4D     	LD (BLIT_TMP+3), A
2648  5901              	; comma
2649  5901 CD EE 4F     	CALL CHKCHAR
2650  5904 2C           	DB ','
2651  5905              	; get number of tiles horizontally
2652  5905 DD 21 2F 54  	LD IX, FRMQNT
2653  5909 CD 59 01     	CALL CALBAS
2654  590C ED 53 0F 4D  	LD (BLIT_STRUCT+10), DE
2655  5910              	; comma
2656  5910 CD EE 4F     	CALL CHKCHAR
2657  5913 2C           	DB ','
2658  5914              	; get number of tiles vertically
2659  5914 DD 21 2F 54  	LD IX, FRMQNT
2660  5918 CD 59 01     	CALL CALBAS
2661  591B ED 53 11 4D  	LD (BLIT_STRUCT+12), DE
2662  591F              	; ending )
2663  591F CD EE 4F     	CALL CHKCHAR
2664  5922 29           	DB ')'
2665  5923
2666  5923 E5           	PUSH HL ; save position in BASIC buffer
2667  5924
2668  5924              	; calculate destination add to value
2669  5924 21 00 01     	LD HL, 256
2670  5927 22 0D 4D     	LD (BLIT_STRUCT+8), HL
2671  592A              	; calculate pointer to background location
2672  592A 3A 04 4D     	LD A,(BLIT_TMP+3)
2673  592D 67           	LD H,A
2674  592E 2E 00        	LD L,0
2675  5930 EB           	EX DE,HL
2676  5931 26 00        	LD H,0
2677  5933 3A 03 4D     	LD A,(BLIT_TMP+2)
2678  5936 6F           	LD L,A
2679  5937 CD 25 4E     	CALL HLx8
2680  593A 19           	ADD HL,DE
2681  593B ED 5B CB F3  	LD DE,(GRPCGP)
2682  593F 19           	ADD HL,DE
2683  5940 22 0B 4D     	LD (BLIT_STRUCT+6),HL
2684  5943
2685  5943 FD 21 4A 59  	LD IY, .RET
2686  5947 C3 E9 4E     	JP ENABLE_PAGE0
2687  594A              .RET:
2688  594A FB           	EI
2689  594B              	; set RAM functions to call
2690  594B 21 65 59     	LD HL, .TILECOPY
2691  594E 22 94 57     	LD (TILE.CALL2+1), HL
2692  5951 21 6B 59     	LD HL, .SETDESTROW
2693  5954 22 86 57     	LD (TILE.CALL1+1), HL
2694  5957 DD 21 05 4D  	LD IX,BLIT_STRUCT
2695  595B CD 6B 57     	CALL TILE
2696  595E
2697  595E D1               POP DE
2698  595F C1               POP BC
2699  5960 CD 60 4E         CALL RESTORE_PAGE_INFO
2700  5963
2701  5963 E1           	POP HL
2702  5964 C9           	RET
2703  5965              .TILECOPY:
2704  5965 01 98 08     	LD BC, #0898
2705  5968 C3 1F 4E     	JP BBYTECOPY
2706  596B              .SETDESTROW:
2707  596B 2A 01 4D     	LD HL, (TILETMP1)
2708  596E F3           	DI
2709  596F CD 14 4E     	CALL SETWRT_LOCAL
2710  5972 FB           	EI
2711  5973 C9           	RET
2712  5974              ; *******************************************************************************************************
2713  5974               ENDIF
2714  5974
2715  5974               IFNDEF CMDS_WITH_PARAMETERS
2716  5974 ~            ; *******************************************************************************************************
2717  5974 ~            ; function to handle CALL TILEVRM basic extension
2718  5974 ~            ; fills vram with tiles
2719  5974 ~            ; TILEVRM ( INT request_data_ptr )
2720  5974 ~            ; request_data_ptr described in TILE
2721  5974 ~            ; will put ram in page 0 also, page 1 is already there
2722  5974 ~            TILEVRM:
2723  5974 ~            	; opening (
2724  5974 ~            	CALL CHKCHAR
2725  5974 ~            	DB '('
2726  5974 ~            	; get pointer to request struct
2727  5974 ~            	LD IX, FRMQNT
2728  5974 ~            	CALL CALBAS
2729  5974 ~            	PUSH DE
2730  5974 ~            	; ending )
2731  5974 ~            	CALL CHKCHAR
2732  5974 ~            	DB ')'
2733  5974 ~
2734  5974 ~            	POP IX ; pointer to request struct
2735  5974 ~
2736  5974 ~            	PUSH HL ; save position in BASIC buffer
2737  5974 ~
2738  5974 ~            	LD IY, .RET
2739  5974 ~            	JP ENABLE_PAGE0
2740  5974 ~            .RET:
2741  5974 ~            	EI
2742  5974 ~            	; set RAM functions to call
2743  5974 ~            	LD HL, .TILECOPY
2744  5974 ~            	LD (TILE.CALL2+1), HL
2745  5974 ~            	LD HL, .SETDESTROW
2746  5974 ~            	LD (TILE.CALL1+1), HL
2747  5974 ~            	CALL TILE
2748  5974 ~
2749  5974 ~                POP DE
2750  5974 ~                POP BC
2751  5974 ~                CALL RESTORE_PAGE_INFO
2752  5974 ~
2753  5974 ~            	POP HL
2754  5974 ~            	RET
2755  5974 ~            .TILECOPY:
2756  5974 ~            	LD BC, #0898
2757  5974 ~            	JP BBYTECOPY
2758  5974 ~            .SETDESTROW:
2759  5974 ~            	LD HL, (TILETMP1)
2760  5974 ~            	DI
2761  5974 ~            	CALL SETWRT_LOCAL
2762  5974 ~            	EI
2763  5974 ~            	RET
2764  5974 ~            ; *******************************************************************************************************
2765  5974               ENDIF
2766  5974               ENDIF
2767  5974
2768  5974               IF (BOX_CMDS == 1)
2769  5974              ; *******************************************************************************************************
2770  5974              ; generic function to implement rectangle data copy
2771  5974              ; should be modified to call appropriate function for memory or vram
2772  5974              ; input IX=pointer to following structure
2773  5974              ; +00 source data pointer
2774  5974              ; +02 num bytes in a row
2775  5974              ; +04 number of rows
2776  5974              ; +06 source add-to value till next row
2777  5974              ; +08 destination address
2778  5974              ; +10 destination add-to value till next row
2779  5974              ; modifies AF, BC, DE, HL
2780  5974              RECTANGLE_COPY:
2781  5974 DD 6E 00     	LD L, (IX+0)
2782  5977 DD 66 01     	LD H, (IX+1) ; source address
2783  597A DD 5E 08     	LD E, (IX+8)
2784  597D DD 56 09     	LD D, (IX+9) ; destination
2785  5980 DD 46 04     	LD B, (IX+4) ; row number
2786  5983              .L1:
2787  5983 C5           	PUSH BC
2788  5984 E5           		PUSH HL
2789  5985 D5           			PUSH DE
2790  5986 DD 4E 02     				LD C, (IX+2)
2791  5989 DD 46 03     				LD B, (IX+3) ; num bytes in a row
2792  598C              .CALL1:
2793  598C CD 00 00     				CALL 0 ; set destination address from DE
2794  598F              .CALL2:
2795  598F CD 00 00     				CALL 0 ; copy data fn
2796  5992 E1           			POP HL
2797  5993 DD 4E 0A     			LD C, (IX+10)
2798  5996 DD 46 0B     			LD B, (IX+11) ; destination add-to
2799  5999 09           			ADD HL, BC
2800  599A EB           			EX DE, HL
2801  599B E1           		POP HL
2802  599C DD 4E 06     		LD C, (IX+6)
2803  599F DD 46 07     		LD B, (IX+7) ; src add-to
2804  59A2 09           		ADD HL, BC
2805  59A3 C1           	POP BC
2806  59A4 10 DD        	DJNZ .L1
2807  59A6 C9           	RET
2808  59A7              ; *******************************************************************************************************
2809  59A7
2810  59A7              ; *******************************************************************************************************
2811  59A7              ; function to handle CALL BOXMEMCPY basic extension
2812  59A7              ; copies data with window like boundaries to ram
2813  59A7              ; BOXMEMCPY ( INT request_data_ptr )
2814  59A7              ; request_data_ptr described in RECTANGLE_COPY
2815  59A7              ; will put ram in page 0 also, page 1 is already there
2816  59A7              BOXMEMCPY:
2817  59A7              	; opening (
2818  59A7 CD EE 4F     	CALL CHKCHAR
2819  59AA 28           	DB '('
2820  59AB              	; get pointer to request struct
2821  59AB DD 21 2F 54  	LD IX, FRMQNT
2822  59AF CD 59 01     	CALL CALBAS
2823  59B2 D5           	PUSH DE
2824  59B3              	; ending )
2825  59B3 CD EE 4F     	CALL CHKCHAR
2826  59B6 29           	DB ')'
2827  59B7
2828  59B7 DD E1        	POP IX ; pointer to request struct
2829  59B9
2830  59B9 E5           	PUSH HL ; save position in BASIC buffer
2831  59BA
2832  59BA FD 21 C1 59  	LD IY, .RET
2833  59BE C3 E9 4E     	JP ENABLE_PAGE0
2834  59C1              .RET:
2835  59C1 FB           	EI
2836  59C2              	; set RAM functions to call
2837  59C2 21 00 00     	LD HL, 0
2838  59C5 22 8C 59     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2839  59C8 22 8E 59     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2840  59CB 21 ED B0     	LD HL, #B0ED ; LDIR
2841  59CE 22 90 59     	LD (RECTANGLE_COPY.CALL1+4), HL
2842  59D1 CD 74 59     	CALL RECTANGLE_COPY
2843  59D4
2844  59D4 D1               POP DE
2845  59D5 C1               POP BC
2846  59D6 CD 60 4E         CALL RESTORE_PAGE_INFO
2847  59D9
2848  59D9 E1           	POP HL
2849  59DA C9           	RET
2850  59DB              ; *******************************************************************************************************
2851  59DB
2852  59DB              ; *******************************************************************************************************
2853  59DB              ; function to handle CALL BOXMEMVRM basic extension
2854  59DB              ; copies data with window like boundaries to ram
2855  59DB              ; BOXMEMVRM ( INT request_data_ptr )
2856  59DB              ; request_data_ptr described in RECTANGLE_COPY
2857  59DB              ; will put ram in page 0 also, page 1 is already there
2858  59DB              BOXMEMVRM:
2859  59DB              	; opening (
2860  59DB CD EE 4F     	CALL CHKCHAR
2861  59DE 28           	DB '('
2862  59DF              	; get pointer to request struct
2863  59DF DD 21 2F 54  	LD IX, FRMQNT
2864  59E3 CD 59 01     	CALL CALBAS
2865  59E6 D5           	PUSH DE
2866  59E7              	; ending )
2867  59E7 CD EE 4F     	CALL CHKCHAR
2868  59EA 29           	DB ')'
2869  59EB
2870  59EB DD E1        	POP IX ; pointer to request struct
2871  59ED
2872  59ED E5           	PUSH HL ; save position in BASIC buffer
2873  59EE
2874  59EE FD 21 F5 59  	LD IY, .RET
2875  59F2 C3 E9 4E     	JP ENABLE_PAGE0
2876  59F5              .RET:
2877  59F5 FB           	EI
2878  59F6              	; set RAM functions to call
2879  59F6 21 14 5A     	LD HL, .SETDEST
2880  59F9 22 8D 59     	LD (RECTANGLE_COPY.CALL1+1), HL
2881  59FC 21 1C 5A     	LD HL, .COPYDATA
2882  59FF 22 90 59     	LD (RECTANGLE_COPY.CALL2+1), HL
2883  5A02 3E CD        	LD A, #CD ; CALL
2884  5A04 32 8C 59     	LD (RECTANGLE_COPY.CALL1), A
2885  5A07 32 8F 59     	LD (RECTANGLE_COPY.CALL2), A
2886  5A0A CD 74 59     	CALL RECTANGLE_COPY
2887  5A0D
2888  5A0D D1               POP DE
2889  5A0E C1               POP BC
2890  5A0F CD 60 4E         CALL RESTORE_PAGE_INFO
2891  5A12
2892  5A12 E1           	POP HL
2893  5A13 C9           	RET
2894  5A14              .SETDEST:
2895  5A14 EB           	EX DE, HL
2896  5A15 F3           	DI
2897  5A16 CD 14 4E     	CALL SETWRT_LOCAL
2898  5A19 FB           	EI
2899  5A1A EB           	EX DE, HL
2900  5A1B C9           	RET
2901  5A1C              .COPYDATA:
2902  5A1C 41           	LD B, C
2903  5A1D 0E 98        	LD C, #98
2904  5A1F C3 1F 4E     	JP BBYTECOPY
2905  5A22              ; *******************************************************************************************************
2906  5A22               ENDIF
2907  5A22
2908  5A22              EXT_END:
2909  5A22
# file closed: asm\main.asm
