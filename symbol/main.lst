# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000
 14   4000               DEFINE CMDS_WITH_PARAMETERS
 15   4000
 16   4000              CHPUT   EQU     #A2
 17   4000              CALBAS	EQU		#159
 18   4000              ERRHAND EQU     #406F
 19   4000              FRMEVL  EQU     #4C64
 20   4000              FRESTR	EQU		#67D0
 21   4000              ; FRMQNT = formula quantificator
 22   4000              ; input HL=pointer to current program expression
 23   4000              ; output HL=next address
 24   4000              ; output DE=integer datum
 25   4000              FRMQNT	EQU		#542F
 26   4000              ; GETBYT = get byte parameter
 27   4000              ; input HL=pointer to current program expression
 28   4000              ; output HL=next address
 29   4000              ; output A=E=byte read
 30   4000              GETBYT		EQU		#521C
 31   4000              CHRGTR  	EQU     #4666
 32   4000              PTRGET		EQU 	#5EA4
 33   4000              SUBFLG		EQU		#F6A5
 34   4000              SYNCHR		EQU		#558C
 35   4000              VALTYP  	EQU     #F663
 36   4000              USR     	EQU     #F7F8
 37   4000              PROCNM		EQU		#FD89
 38   4000              BIOS_FILVRM EQU     #0056
 39   4000              CLIKSW		EQU		#F3DB
 40   4000              ATRBAS		EQU		#F928
 41   4000              GRPCGP		EQU		#F3CB
 42   4000
 43   4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 44   4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 45   4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 46   4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 47   4000              EXPTBL	EQU #FCC1
 48   4000              SCRMOD	EQU #FCAF ; current screen mode
 49   4000              REG1SAV EQU #F3E0 ; VDP(1)
 50   4000              JIFFY	EQU #FC9E
 51   4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
 52   4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
 53   4000              PATBAS  EQU #F926 ; current sprite generator table address
 54   4000              CGPBAS  EQU #F924 ; current pattern generator table address
 55   4000
 56   4000              ; BASIC error codes
 57   4000              ;01 NEXT without FOR
 58   4000              ;02 Syntax error
 59   4000              ;03 RETURN without GOSUB
 60   4000              ;04 Out of DATA
 61   4000              ;05 Illegal function call
 62   4000              ;06 Overflow
 63   4000              ;07 Out of memory
 64   4000              ;08 Undefined line number
 65   4000              ;09 Subscript out of range
 66   4000              ;10 Redimensioned array
 67   4000              ;11 Division by zero
 68   4000              ;12 Illegal direct
 69   4000              ;13 Type mismatch
 70   4000              ;14 Out of string space
 71   4000              ;15 String too long
 72   4000              ;16 String formula too complex
 73   4000              ;17 Can't CONTINUE
 74   4000              ;18 Undefined user function
 75   4000              ;19 Device I/O error
 76   4000              ;20 Verify error
 77   4000              ;21 No RESUME
 78   4000              ;22 RESUME without error
 79   4000              ;23 Unprintable error
 80   4000              ;24 Missing operand
 81   4000              ;25 Line buffer overflow
 82   4000              ;50 FIELD overflow
 83   4000              ;51 Internal error
 84   4000              ;52 Bad file number
 85   4000              ;53 File not found
 86   4000              ;54 File already open
 87   4000              ;55 Input past end
 88   4000              ;56 Bad file name
 89   4000              ;57 Direct statement in file
 90   4000              ;58 Sequential I/O only
 91   4000              ;59 File not OPEN
 92   4000
 93   4000
 94   4000               ; simulate cartridge with BASIC extension
 95   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 95   4004 C3 5F 00 00
 95   4008 00 00 00 00
 95   400C 00 00 00 00
 96   4010
 97   4010              ; this location #4010 stores last location used by basic extension
 98   4010              ; free memory after that point
 99   4010              FREEMEMPTR:
100   4010 5C 60         DW EXT_END
101   4012
102   4012              ; this location #4012 stores extension version in DAA format
103   4012              ; first byte is major version and second minor
104   4012              VERSION:
105   4012 00 70         DB #00, #70
106   4014
107   4014              ; binary included AKG player compiled at #4014
108   4014               IF (SOUND_CMDS == 1)
109   4014              	INCBIN "bin/AKG.bin"
110   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
111   4CF0               ENDIF
112   4CF0
113   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A 54 55     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD F3 5E         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD 3A 5F         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD F3 5E         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD 3A 5F         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A 54 55     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD 2A 5F         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD 2A 5F         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A 4F 5D         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD BD 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
114   4D73
115   4D73               IF (SPRITE_CMDS == 1)
116   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD EF 5E         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D95 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D98 B7           	OR A
 55+  4D99 28 03        	JR Z, .L3
 56+  4D9B 3A 79 4D     	LD A, (FLICKER)
 57+  4D9E              .L3:
 58+  4D9E 5F           	LD E, A
 59+  4D9F 08           	EX AF, AF'
 60+  4DA0 7B           	LD A, E
 61+  4DA1 87           	ADD A, A
 62+  4DA2 87           	ADD A, A
 63+  4DA3 16 00        	LD D, 0
 64+  4DA5 5F           	LD E, A
 65+  4DA6 19           	ADD HL, DE
 66+  4DA7 CD DA 5E     	CALL SETWRT_LOCAL
 67+  4DAA ED 73 7A 4D  	LD (TMPSP), SP
 68+  4DAE ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 69+  4DB2
 70+  4DB2              .LOOP:
 71+  4DB2 E1           	POP HL
 72+  4DB3 24           	INC H
 73+  4DB4 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DB6 25           	DEC H
 75+  4DB7 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DB9 7D           	LD A, L
 77+  4DBA FE C0        	CP 192
 78+  4DBC 30 10        	JR NC, .OUT3
 79+  4DBE 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DBF 57           	LD D, A
 81+  4DC0 C3 E7 4D     	JP .X
 82+  4DC3              .L1:
 83+  4DC3 7D           	LD A, L
 84+  4DC4 C6 10        	ADD 16
 85+  4DC6 FA CE 4D     	JP M, .OUT3 ; below -16
 86+  4DC9 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DCA 55           	LD D, L
 88+  4DCB C3 E7 4D     	JP .X
 89+  4DCE              .OUT3:
 90+  4DCE E1           	POP HL ; skip x value
 91+  4DCF              .OUT2:
 92+  4DCF E1           	POP HL ; skip pattern
 93+  4DD0 E1           	POP HL ; skip color
 94+  4DD1 3E D1        	LD A, #D1
 95+  4DD3 ED 79        	OUT (C), A ; sprite hidden
 96+  4DD5 00          > NOP
 96+  4DD6 00          > NOP
 96+  4DD7 00          > NOP
 97+  4DD8 ED 79        	OUT (C), A ; value unimportant
 98+  4DDA 00          > NOP
 98+  4DDB 00          > NOP
 98+  4DDC 00          > NOP
 99+  4DDD ED 79        	OUT (C), A ; value unimportant
100+  4DDF 00          > NOP
100+  4DE0 00          > NOP
100+  4DE1 00          > NOP
101+  4DE2 ED 79        	OUT (C), A ; value unimportant
102+  4DE4 C3 12 4E     	JP .NEXT
103+  4DE7              .X:
104+  4DE7 E1           	POP HL
105+  4DE8 24           	INC H
106+  4DE9 28 08        	JR Z, .L2
107+  4DEB 25           	DEC H
108+  4DEC 20 E1        	JR NZ, .OUT2
109+  4DEE 1E 00        	LD E, 0 ; EC bit
110+  4DF0 C3 FC 4D     	JP .XY
111+  4DF3              .L2:
112+  4DF3 7D           	LD A, L
113+  4DF4 C6 20        	ADD 32
114+  4DF6 FA CF 4D     	JP M, .OUT2
115+  4DF9 6F           	LD L, A
116+  4DFA 1E 80        	LD E, #80
117+  4DFC              .XY:
118+  4DFC ED 51        	OUT (C), D
119+  4DFE 3A E0 F3     	LD A, (REG1SAV)
120+  4E01 E6 02        	AND 2
121+  4E03 ED 69        	OUT (C), L
122+  4E05 E1           	POP HL ; pattern
123+  4E06 7D           	LD A, L
124+  4E07 28 02        	JR Z, .SMALLSPRITES
125+  4E09 87           	ADD A, A
126+  4E0A 87           	ADD A, A ; needs to go at 4x
127+  4E0B              .SMALLSPRITES:
128+  4E0B D3 98        	OUT (#98), A
129+  4E0D E1           	POP HL ; color
130+  4E0E 7D           	LD A, L
131+  4E0F B3           	OR E
132+  4E10 D3 98        	OUT (#98), A
133+  4E12              .NEXT:
134+  4E12 08           	EX AF, AF'
135+  4E13 3C           	INC A
136+  4E14 E6 1F        	AND 31
137+  4E16 C2 2A 4E     	JP NZ, .NEXT2
138+  4E19 08           	EX AF, AF'
139+  4E1A 2A 28 F9     	LD HL, (ATRBAS)
140+  4E1D              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E1D 7D           	LD	A, L
142+  4E1E D3 99        	OUT	(099H), A
143+  4E20 7C           	LD	A, H
144+  4E21 E6 3F        	AND	03FH
145+  4E23 F6 40        	OR	040H
146+  4E25 D3 99        	OUT	(099H), A
147+  4E27 C3 2B 4E     	JP .NEXT3
148+  4E2A              .NEXT2:
149+  4E2A 08           	EX AF, AF'
150+  4E2B              .NEXT3:
151+  4E2B 10 85        	DJNZ .LOOP
152+  4E2D 08           	EX AF, AF'
153+  4E2E 3C           	INC A
154+  4E2F 32 79 4D     	LD (FLICKER), A
155+  4E32
156+  4E32 ED 7B 7A 4D  	LD SP, (TMPSP)
157+  4E36 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E39 36 00        	LD (HL), 0 ; zero out update flag
159+  4E3B C9           	RET
160+  4E3C              ; *******************************************************************************************************
161+  4E3C
162+  4E3C              ; *******************************************************************************************************
163+  4E3C              ; function to handle CALL SPRENABLE basic extension
164+  4E3C              ; initializes sprites handler
165+  4E3C              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E3C              ;			   INT update_variable,
167+  4E3C              ;			   BYTE sprite_flicker_enabled )
168+  4E3C              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E3C              SPRENABLE:
170+  4E3C              	; opening (
171+  4E3C CD 00 60     	CALL CHKCHAR
172+  4E3F 28           	DB '('
173+  4E40              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E40 3E 02        	LD A,2
175+  4E42 06 02        	LD B,2
176+  4E44 11 20 04     	LD DE,#0420
177+  4E47 CD 27 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E4A C5           	PUSH BC
179+  4E4B              	; comma
180+  4E4B CD 00 60     	CALL CHKCHAR
181+  4E4E 2C           	DB ','
182+  4E4F              	; get address of sprite update flag
183+  4E4F DD 21 A4 5E  	LD IX, PTRGET
184+  4E53 CD 59 01     	CALL CALBAS
185+  4E56 D5           	PUSH DE
186+  4E57              	; comma
187+  4E57 CD 00 60     	CALL CHKCHAR
188+  4E5A 2C           	DB ','
189+  4E5B              	; get flicker enabled flag
190+  4E5B DD 21 1C 52  	LD IX, GETBYT
191+  4E5F CD 59 01     	CALL CALBAS
192+  4E62 F5           	PUSH AF
193+  4E63              	; ending )
194+  4E63 CD 00 60     	CALL CHKCHAR
195+  4E66 29           	DB ')'
196+  4E67
197+  4E67 F1           	POP AF ; get flicker flag
198+  4E68 B7           	OR A
199+  4E69 32 78 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E6C
201+  4E6C D1           	POP DE ; update variable location
202+  4E6D ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E71 D1           	POP DE ; address of sprite attribute table
204+  4E72 ED 53 76 4D  	LD (SPRATR_DATA), DE
205+  4E76 3E 01        	LD A, 1
206+  4E78 32 73 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E7B C9           	RET
208+  4E7C              ; *******************************************************************************************************
209+  4E7C
210+  4E7C              ; *******************************************************************************************************
211+  4E7C              ; function to handle CALL SPRDISABLE basic extension
212+  4E7C              ; disables sprites handling
213+  4E7C              ; _SPRDISABLE
214+  4E7C              ; resets variable SPRATR_INIT_STATUS
215+  4E7C              SPRDISABLE:
216+  4E7C AF           	XOR A
217+  4E7D 32 73 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E80 C9           	RET
219+  4E81              ; *******************************************************************************************************
220+  4E81
221+  4E81              ; *******************************************************************************************************
222+  4E81              ; function to handle CALL SPRSET basic extension
223+  4E81              ; sets position, and optionally pattern and color of sprite
224+  4E81              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E81              ;			INT x,
226+  4E81              ;			INT y,
227+  4E81              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E81              ;			INT color, valid 0-15, otherwise ignored
229+  4E81              SPRSET:
230+  4E81 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E84 B7           	OR A
232+  4E85 20 05        	JR NZ, .L1
233+  4E87 1E 05        	LD E, 5 ; illegal function call
234+  4E89 C3 20 60     	JP THROW_ERROR
235+  4E8C              .L1:
236+  4E8C              	; opening (
237+  4E8C CD 00 60     	CALL CHKCHAR
238+  4E8F 28           	DB '('
239+  4E90              	; get sprite number
240+  4E90 DD 21 1C 52  	LD IX, GETBYT
241+  4E94 CD 59 01     	CALL CALBAS
242+  4E97 F5           	PUSH AF
243+  4E98              	; comma
244+  4E98 CD 00 60     	CALL CHKCHAR
245+  4E9B 2C           	DB ','
246+  4E9C              	; get x
247+  4E9C DD 21 2F 54  	LD IX, FRMQNT
248+  4EA0 CD 59 01     	CALL CALBAS
249+  4EA3 D5           	PUSH DE
250+  4EA4              	; comma
251+  4EA4 CD 00 60     	CALL CHKCHAR
252+  4EA7 2C           	DB ','
253+  4EA8              	; get y
254+  4EA8 DD 21 2F 54  	LD IX, FRMQNT
255+  4EAC CD 59 01     	CALL CALBAS
256+  4EAF D5           	PUSH DE
257+  4EB0              	; comma
258+  4EB0 CD 00 60     	CALL CHKCHAR
259+  4EB3 2C           	DB ','
260+  4EB4              	; get pattern
261+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
262+  4EB8 CD 59 01     	CALL CALBAS
263+  4EBB D5           	PUSH DE
264+  4EBC              	; comma
265+  4EBC CD 00 60     	CALL CHKCHAR
266+  4EBF 2C           	DB ','
267+  4EC0              	; get color
268+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
269+  4EC4 CD 59 01     	CALL CALBAS
270+  4EC7 D5           	PUSH DE
271+  4EC8              	; ending )
272+  4EC8 CD 00 60     	CALL CHKCHAR
273+  4ECB 29           	DB ')'
274+  4ECC
275+  4ECC                  ; save position in BASIC text
276+  4ECC E5           	PUSH HL
277+  4ECD DD E1        	POP IX
278+  4ECF
279+  4ECF C1           	POP BC ; color
280+  4ED0 D1           	POP DE ; pattern
281+  4ED1 D9           	EXX
282+  4ED2 C1           	POP BC ; y
283+  4ED3 D1           	POP DE ; x
284+  4ED4 F1           	POP AF ; sprite number
285+  4ED5 FE 20        	CP 32
286+  4ED7 38 05        	JR C, .L2
287+  4ED9 1E 05        	LD E, 5 ; illegal function call
288+  4EDB C3 20 60     	JP THROW_ERROR
289+  4EDE              .L2:
290+  4EDE              	; find location in sprite attributes table
291+  4EDE D5           	PUSH DE
292+  4EDF CD 7C 4D     	CALL GETnthSPRATTR
293+  4EE2 D1           	POP DE
294+  4EE3              	; set y
295+  4EE3 71           	LD (HL), C
296+  4EE4 23           	INC HL
297+  4EE5 70           	LD (HL), B
298+  4EE6 23           	INC HL
299+  4EE7              	; set x
300+  4EE7 73           	LD (HL), E
301+  4EE8 23           	INC HL
302+  4EE9 72           	LD (HL), D
303+  4EEA 23           	INC HL
304+  4EEB E5           	PUSH HL
305+  4EEC D9           	EXX
306+  4EED E1           	POP HL
307+  4EEE              	; check if 0<=pattern<64
308+  4EEE 7A           	LD A, D
309+  4EEF B7           	OR A
310+  4EF0 20 0B        	JR NZ, .L3
311+  4EF2 7B           	LD A, E
312+  4EF3 FE 40        	CP 64
313+  4EF5 30 06        	JR NC, .L3
314+  4EF7              	; set pattern
315+  4EF7              	;ADD A, A
316+  4EF7              	;ADD A, A
317+  4EF7              	;ADD A, A
318+  4EF7 77           	LD (HL), A
319+  4EF8 23           	INC HL
320+  4EF9 72           	LD (HL), D
321+  4EFA 23           	INC HL
322+  4EFB 18 02        	JR .L4
323+  4EFD              .L3:
324+  4EFD              	; skip pattern
325+  4EFD 23          > INC HL
325+  4EFE 23          > INC HL
326+  4EFF              .L4:
327+  4EFF              	; check if 0<=color<16
328+  4EFF 78           	LD A, B
329+  4F00 B7           	OR A
330+  4F01 20 08        	JR NZ, .L5
331+  4F03 79           	LD A, C
332+  4F04 FE 10        	CP 16
333+  4F06 30 03        	JR NC, .L5
334+  4F08              	; set color
335+  4F08 71           	LD (HL), C
336+  4F09 23           	INC HL
337+  4F0A 70           	LD (HL), B
338+  4F0B
339+  4F0B              .L5:
340+  4F0B DD E5        	PUSH IX
341+  4F0D E1           	POP HL
342+  4F0E C9           	RET
343+  4F0F              ; *******************************************************************************************************
344+  4F0F
345+  4F0F              ; *******************************************************************************************************
346+  4F0F              ; function sets sprite location based on initial coordinates and offset provided
347+  4F0F              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F0F              ; input DE=initial x
349+  4F0F              ; input BC=initial y
350+  4F0F              ; input IY=location where delta y,x are located
351+  4F0F              ; modifies AF, HL, IX
352+  4F0F              SPRSET_DELTA_POS:
353+  4F0F D5           	PUSH DE
354+  4F10 CD 7C 4D     	CALL GETnthSPRATTR
355+  4F13 E5           	PUSH HL
356+  4F14 DD E1        	POP IX
357+  4F16 D1           	POP DE
358+  4F17              	; IX=sprite's y location
359+  4F17 FD 6E 00     	LD L, (IY)
360+  4F1A FD 66 01     	LD H, (IY+1)
361+  4F1D 09           	ADD HL, BC
362+  4F1E DD 75 00     	LD (IX), L
363+  4F21 DD 74 01     	LD (IX+1), H
364+  4F24 FD 6E 02     	LD L, (IY+2)
365+  4F27 FD 66 03     	LD H, (IY+3)
366+  4F2A 19           	ADD HL, DE
367+  4F2B DD 75 02     	LD (IX+2), L
368+  4F2E DD 74 03     	LD (IX+3), H
369+  4F31 C9           	RET
370+  4F32              ; *******************************************************************************************************
371+  4F32
372+  4F32              ; *******************************************************************************************************
373+  4F32              ; function to handle CALL SPRGRPMOV basic extension
374+  4F32              ; sets position of a group of sprites described with
375+  4F32              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F32              ; _SPRGRPMOV ( INT x,
377+  4F32              ;			   INT y,
378+  4F32              ;			   BYTE count,
379+  4F32              ;			   INT[2][count] data_ptr
380+  4F32              ; will put ram in page 0 also, page 1 is already there
381+  4F32              SPRGRPMOV:
382+  4F32 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F35 B7           	OR A
384+  4F36 20 05        	JR NZ, .L1
385+  4F38 1E 05        	LD E, 5 ; illegal function call
386+  4F3A C3 20 60     	JP THROW_ERROR
387+  4F3D              .L1:
388+  4F3D              	; opening (
389+  4F3D CD 00 60     	CALL CHKCHAR
390+  4F40 28           	DB '('
391+  4F41              	; get x
392+  4F41 DD 21 2F 54  	LD IX, FRMQNT
393+  4F45 CD 59 01     	CALL CALBAS
394+  4F48 D5           	PUSH DE
395+  4F49              	; comma
396+  4F49 CD 00 60     	CALL CHKCHAR
397+  4F4C 2C           	DB ','
398+  4F4D              	; get y
399+  4F4D DD 21 2F 54  	LD IX, FRMQNT
400+  4F51 CD 59 01     	CALL CALBAS
401+  4F54 D5           	PUSH DE
402+  4F55              	; comma
403+  4F55 CD 00 60     	CALL CHKCHAR
404+  4F58 2C           	DB ','
405+  4F59              	; get count
406+  4F59 DD 21 1C 52  	LD IX, GETBYT
407+  4F5D CD 59 01     	CALL CALBAS
408+  4F60 F5           	PUSH AF
409+  4F61              	; comma
410+  4F61 CD 00 60     	CALL CHKCHAR
411+  4F64 2C           	DB ','
412+  4F65              	; get sprite group definition array data pointer
413+  4F65 D1           	POP DE
414+  4F66 D5           	PUSH DE
415+  4F67 5A           	LD E,D
416+  4F68 16 03        	LD D,3
417+  4F6A 3E 02        	LD A,2
418+  4F6C 47           	LD B,A
419+  4F6D CD 27 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
420+  4F70 C5           	PUSH BC
421+  4F71              	; ending )
422+  4F71 CD 00 60     	CALL CHKCHAR
423+  4F74 29           	DB ')'
424+  4F75
425+  4F75 E5           	PUSH HL
426+  4F76 DD E1        	POP IX
427+  4F78
428+  4F78 E1           	POP HL ; data pointer
429+  4F79 C1           	POP BC ; count
430+  4F7A D9           	EXX
431+  4F7B C1           	POP BC ; y
432+  4F7C D1           	POP DE ; x
433+  4F7D D9           	EXX
434+  4F7E
435+  4F7E DD E5        	PUSH IX ; save position in BASIC buffer
436+  4F80
437+  4F80 C5           	PUSH BC
438+  4F81 E5           	PUSH HL
439+  4F82 AF               XOR A
440+  4F83 CD F3 5E         CALL GET_PAGE_INFO
441+  4F86 D9           	EXX
442+  4F87 E1           	POP HL
443+  4F88 F1           	POP AF
444+  4F89 D9           	EXX
445+  4F8A C5               PUSH BC
446+  4F8B D5               PUSH DE
447+  4F8C D9           	EXX
448+  4F8D F5           	PUSH AF
449+  4F8E E5           	PUSH HL
450+  4F8F D9           	EXX
451+  4F90 3A 41 F3         LD A, (RAMAD0)
452+  4F93 26 00            LD H, 0
453+  4F95 CD 3A 5F         CALL LOCAL_ENASLT
454+  4F98 FB           	EI
455+  4F99 E1           	POP HL
456+  4F9A C1           	POP BC
457+  4F9B CD A5 4F     	CALL .UPDATE_LOC
458+  4F9E D1               POP DE
459+  4F9F C1               POP BC
460+  4FA0 CD 2A 5F         CALL RESTORE_PAGE_INFO
461+  4FA3 E1           	POP HL
462+  4FA4 C9           	RET
463+  4FA5
464+  4FA5              .UPDATE_LOC:
465+  4FA5              .L4:
466+  4FA5 7E           	LD A, (HL)
467+  4FA6 23           	INC HL
468+  4FA7 23           	INC HL
469+  4FA8 E5           	PUSH HL
470+  4FA9 FD E1        	POP IY
471+  4FAB D9           	EXX
472+  4FAC CD 0F 4F     	CALL SPRSET_DELTA_POS
473+  4FAF D9           	EXX
474+  4FB0 23          > INC HL
474+  4FB1 23          > INC HL
474+  4FB2 23          > INC HL
474+  4FB3 23          > INC HL
475+  4FB4 10 EF        	DJNZ .L4
476+  4FB6 C9           	RET
477+  4FB7              ; *******************************************************************************************************
478+  4FB7
# file closed: asm\SPRITES.asm
117   4FB7               ENDIF
118   4FB7
119   4FB7               IF (ANIM_CMDS == 1)
120   4FB7               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FB7              ; sprite animation routines
  2+  4FB7
  3+  4FB7              ; number of animation items and pointer
  4+  4FB7              ANIMITEMNUM:
  5+  4FB7 00            DB 0
  6+  4FB8              ANIMITEMPTR:
  7+  4FB8 5C 60         DW EXT_END
  8+  4FBA              ; number of animation definitions and pointer
  9+  4FBA              ANIMDEFNUM:
 10+  4FBA 00            DB 0
 11+  4FBB              ANIMDEFPTR:
 12+  4FBB 5C 60         DW EXT_END
 13+  4FBD              ; number of links between sprite and animation definitions
 14+  4FBD              ANIMSPRNUM:
 15+  4FBD 00            DB 0
 16+  4FBE              ANIMSPRPTR:
 17+  4FBE 5C 60         DW EXT_END
 18+  4FC0
 19+  4FC0              ; ANIMATION ITEM
 20+  4FC0              ; byte type = [0 - pattern and color change
 21+  4FC0              ;              1 - pattern definition change ]
 22+  4FC0              ; word ticks - number of ticks to hold this state
 23+  4FC0              ; for type = 0
 24+  4FC0              ;   byte pattern;
 25+  4FC0              ;   byte color;
 26+  4FC0              ; for type = 1
 27+  4FC0              ;   work data_pointer;
 28+  4FC0              ; total size = 5b
 29+  4FC0
 30+  4FC0              ; ANIMATION DEFINITION
 31+  4FC0              ; byte number of items 1-15
 32+  4FC0              ; byte[15] anim_item;
 33+  4FC0              ; total size = 16b
 34+  4FC0
 35+  4FC0              ; SPRITE/CHAR ANIMATION
 36+  4FC0              ; +00 byte sprite/char number;
 37+  4FC0              ; +01 word time;
 38+  4FC0              ; +03 byte current item;
 39+  4FC0              ; +04 byte animation definition;
 40+  4FC0              ; +05 byte cyclic;
 41+  4FC0              ; +06 byte active;
 42+  4FC0              ; +07 byte 0=sprite, 1-3 character bank
 43+  4FC0              ; total size = 8b
 44+  4FC0
 45+  4FC0              ; *******************************************************************************************************
 46+  4FC0              ; helper function HL=A*5
 47+  4FC0              ; changes HL,DE;
 48+  4FC0              Ax5:
 49+  4FC0 26 00            LD H,0
 50+  4FC2 6F               LD L,A
 51+  4FC3 54               LD D,H
 52+  4FC4 5D               LD E,L
 53+  4FC5 29               ADD HL,HL
 54+  4FC6 29               ADD HL,HL
 55+  4FC7 19               ADD HL,DE
 56+  4FC8 C9               RET
 57+  4FC9              ; *******************************************************************************************************
 58+  4FC9
 59+  4FC9              ; *******************************************************************************************************
 60+  4FC9              ; helper function gets pointer to n-th animation item
 61+  4FC9              ; changes HL,DE;
 62+  4FC9              GETnthANIMITEM:
 63+  4FC9 CD C0 4F         CALL Ax5
 64+  4FCC ED 5B B8 4F      LD DE,(ANIMITEMPTR)
 65+  4FD0 19               ADD HL,DE
 66+  4FD1 C9               RET
 67+  4FD2              ; *******************************************************************************************************
 68+  4FD2
 69+  4FD2              ; *******************************************************************************************************
 70+  4FD2              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD2              ; changes HL,DE;
 72+  4FD2              GETnthANIMDEF:
 73+  4FD2 26 00            LD H,0
 74+  4FD4 6F               LD L,A
 75+  4FD5 CD EE 5E         CALL HLx16
 76+  4FD8 ED 5B BB 4F      LD DE,(ANIMDEFPTR)
 77+  4FDC 19               ADD HL,DE
 78+  4FDD C9               RET
 79+  4FDE              ; *******************************************************************************************************
 80+  4FDE
 81+  4FDE              ; *******************************************************************************************************
 82+  4FDE              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FDE              ; changes HL,DE;
 84+  4FDE              GETnthSPRANIM:
 85+  4FDE 26 00            LD H,0
 86+  4FE0 6F               LD L,A
 87+  4FE1 CD EF 5E         CALL HLx8
 88+  4FE4 ED 5B BE 4F      LD DE,(ANIMSPRPTR)
 89+  4FE8 19               ADD HL,DE
 90+  4FE9 C9               RET
 91+  4FEA              ; *******************************************************************************************************
 92+  4FEA
 93+  4FEA              ; *******************************************************************************************************
 94+  4FEA              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FEA              ; MAXANIMITEMS (BYTE number)
 96+  4FEA              ; sets new number and moves memory buffers as needed
 97+  4FEA              MAXANIMITEMS:
 98+  4FEA              	; opening (
 99+  4FEA CD 00 60     	CALL CHKCHAR
100+  4FED 28           	DB '('
101+  4FEE              	; get value
102+  4FEE DD 21 1C 52  	LD IX, GETBYT
103+  4FF2 CD 59 01     	CALL CALBAS
104+  4FF5 F5               PUSH AF
105+  4FF6              	; ending )
106+  4FF6 CD 00 60     	CALL CHKCHAR
107+  4FF9 29           	DB ')'
108+  4FFA F1               POP AF
109+  4FFB
110+  4FFB              	; save position
111+  4FFB E5           	PUSH HL
112+  4FFC              .ENTRY:
113+  4FFC 47               LD B,A
114+  4FFD 3A B7 4F         LD A,(ANIMITEMNUM)
115+  5000 90               SUB B
116+  5001 28 1F            JR Z, .EXIT; same value as before
117+  5003 FD 21 BB 4F      LD IY,ANIMDEFPTR
118+  5007 FA 25 50         JP M, .INCREASE
119+  500A                  ; new value is lower than previous one
120+  500A CD 3D 50         CALL .SIZEDIFF
121+  500D CD 58 50         CALL .DECREASE_COMMON
122+  5010 2A BE 4F         LD HL,(ANIMSPRPTR)
123+  5013 AF               XOR A
124+  5014 ED 42            SBC HL,BC
125+  5016 22 BE 4F         LD (ANIMSPRPTR),HL
126+  5019              .E1:
127+  5019 2A 10 40         LD HL,(FREEMEMPTR)
128+  501C AF               XOR A
129+  501D ED 42            SBC HL,BC
130+  501F 22 10 40         LD (FREEMEMPTR),HL
131+  5022              .EXIT:
132+  5022 FB               EI
133+  5023 E1           	POP HL
134+  5024 C9           	RET
135+  5025              .INCREASE:
136+  5025 ED 44            NEG
137+  5027 CD 3D 50         CALL .SIZEDIFF
138+  502A CD 84 50         CALL .INCREASE_COMMON
139+  502D 2A BE 4F         LD HL,(ANIMSPRPTR)
140+  5030 09               ADD HL,BC
141+  5031 22 BE 4F         LD (ANIMSPRPTR),HL
142+  5034              .E2:
143+  5034 2A 10 40         LD HL,(FREEMEMPTR)
144+  5037 09               ADD HL,BC
145+  5038 22 10 40         LD (FREEMEMPTR),HL
146+  503B 18 E5            JR .EXIT
147+  503D              .SIZEDIFF:
148+  503D CD C0 4F         CALL Ax5
149+  5040 78               LD A,B
150+  5041 32 B7 4F         LD (ANIMITEMNUM),A
151+  5044 44               LD B,H
152+  5045 4D               LD C,L
153+  5046 C9               RET ; BC=size difference in bytes
154+  5047              .SIZETOMOVE:
155+  5047 D5               PUSH DE
156+  5048 2A 10 40         LD HL,(FREEMEMPTR)
157+  504B FD 5E 00         LD E,(IY)
158+  504E FD 56 01         LD D,(IY+1)
159+  5051 AF               XOR A
160+  5052 ED 52            SBC HL,DE
161+  5054 44               LD B,H
162+  5055 4D               LD C,L
163+  5056 D1               POP DE
164+  5057 C9               RET
165+  5058              .DECREASE_COMMON:
166+  5058 FD 6E 00         LD L,(IY)
167+  505B FD 66 01         LD H,(IY+1)
168+  505E AF               XOR A
169+  505F ED 42            SBC HL,BC
170+  5061 EB               EX DE,HL
171+  5062 C5               PUSH BC
172+  5063 CD 47 50         CALL .SIZETOMOVE
173+  5066 F3               DI
174+  5067 78               LD A,B
175+  5068 B1               OR C
176+  5069 28 08            JR Z,.L1
177+  506B FD 6E 00         LD L,(IY)
178+  506E FD 66 01         LD H,(IY+1)
179+  5071 ED B0            LDIR
180+  5073              .L1:
181+  5073 C1               POP BC
182+  5074 FD 6E 00         LD L,(IY)
183+  5077 FD 66 01         LD H,(IY+1)
184+  507A AF               XOR A
185+  507B ED 42            SBC HL,BC
186+  507D FD 75 00         LD (IY),L
187+  5080 FD 74 01         LD (IY+1),H
188+  5083 C9               RET
189+  5084              .INCREASE_COMMON:
190+  5084 2A 10 40         LD HL,(FREEMEMPTR)
191+  5087 2B               DEC HL
192+  5088 AF               XOR A
193+  5089 ED 42            SBC HL,BC
194+  508B EB               EX DE,HL
195+  508C C5               PUSH BC
196+  508D CD 47 50         CALL .SIZETOMOVE
197+  5090 F3               DI
198+  5091 78               LD A,B
199+  5092 B1               OR C
200+  5093 28 06            JR Z,.L2
201+  5095 2A 10 40         LD HL,(FREEMEMPTR)
202+  5098 2B               DEC HL
203+  5099 ED B8            LDDR
204+  509B              .L2:
205+  509B C1               POP BC
206+  509C FD 6E 00         LD L,(IY)
207+  509F FD 66 01         LD H,(IY+1)
208+  50A2 09               ADD HL,BC
209+  50A3 FD 75 00         LD (IY),L
210+  50A6 FD 74 01         LD (IY+1),H
211+  50A9 C9               RET
212+  50AA              ; *******************************************************************************************************
213+  50AA
214+  50AA              ; *******************************************************************************************************
215+  50AA              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AA              ; ANIMITEMPAT ( BYTE id,
217+  50AA              ;               INT ticks,
218+  50AA              ;               BYTE pattern,
219+  50AA              ;               BYTE color )
220+  50AA              ; fills animation item data, returns an error if out of bounds
221+  50AA              ANIMITEMPAT:
222+  50AA                  ; opening (
223+  50AA CD 00 60     	CALL CHKCHAR
224+  50AD 28           	DB '('
225+  50AE              	; get id
226+  50AE DD 21 1C 52  	LD IX, GETBYT
227+  50B2 CD 59 01     	CALL CALBAS
228+  50B5 F5               PUSH AF
229+  50B6                  ; check if out of bounds
230+  50B6 3C               INC A
231+  50B7 4F               LD C,A
232+  50B8 3A B7 4F         LD A,(ANIMITEMNUM)
233+  50BB B9               CP C
234+  50BC DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50BF              	; comma
236+  50BF CD 00 60     	CALL CHKCHAR
237+  50C2 2C           	DB ','
238+  50C3              	; get ticks
239+  50C3 DD 21 2F 54  	LD IX, FRMQNT
240+  50C7 CD 59 01     	CALL CALBAS
241+  50CA D5           	PUSH DE
242+  50CB              	; comma
243+  50CB CD 00 60     	CALL CHKCHAR
244+  50CE 2C           	DB ','
245+  50CF              	; get pattern
246+  50CF DD 21 1C 52  	LD IX, GETBYT
247+  50D3 CD 59 01     	CALL CALBAS
248+  50D6 F5               PUSH AF
249+  50D7              	; comma
250+  50D7 CD 00 60     	CALL CHKCHAR
251+  50DA 2C           	DB ','
252+  50DB              	; get color
253+  50DB DD 21 1C 52  	LD IX, GETBYT
254+  50DF CD 59 01     	CALL CALBAS
255+  50E2 F5               PUSH AF
256+  50E3              	; ending )
257+  50E3 CD 00 60     	CALL CHKCHAR
258+  50E6 29           	DB ')'
259+  50E7              .ENTRY:
260+  50E7 E5               PUSH HL
261+  50E8 DD E1            POP IX
262+  50EA D9               EXX
263+  50EB C1               POP BC ; color
264+  50EC D1               POP DE ; pattern
265+  50ED E1               POP HL ; ticks
266+  50EE D9               EXX
267+  50EF F1               POP AF
268+  50F0 CD C9 4F         CALL GETnthANIMITEM
269+  50F3 E5               PUSH HL
270+  50F4 FD E1            POP IY
271+  50F6 D9               EXX
272+  50F7 FD 36 00 00      LD (IY),0 ; type=0
273+  50FB FD 75 01         LD (IY+1),L
274+  50FE FD 74 02         LD (IY+2),H
275+  5101 FD 72 03         LD (IY+3),D
276+  5104 FD 70 04         LD (IY+4),B
277+  5107
278+  5107 DD E5            PUSH IX
279+  5109 E1               POP HL
280+  510A C9               RET
281+  510B              ; *******************************************************************************************************
282+  510B
283+  510B              ; *******************************************************************************************************
284+  510B              ; function to handle CALL ANIMITEMPTR basic extension
285+  510B              ; ANIMITEMPTR ( BYTE id,
286+  510B              ;               INT ticks,
287+  510B              ;               INT pointer,
288+  510B              ; fills animation item data, returns an error if out of bounds
289+  510B              ANIMITEMPTR_CMD:
290+  510B                  ; opening (
291+  510B CD 00 60     	CALL CHKCHAR
292+  510E 28           	DB '('
293+  510F              	; get id
294+  510F DD 21 1C 52  	LD IX, GETBYT
295+  5113 CD 59 01     	CALL CALBAS
296+  5116 F5               PUSH AF
297+  5117                  ; check if out of bounds
298+  5117 3C               INC A
299+  5118 4F               LD C,A
300+  5119 3A B7 4F         LD A,(ANIMITEMNUM)
301+  511C B9               CP C
302+  511D DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5120              	; comma
304+  5120 CD 00 60     	CALL CHKCHAR
305+  5123 2C           	DB ','
306+  5124              	; get ticks
307+  5124 DD 21 2F 54  	LD IX, FRMQNT
308+  5128 CD 59 01     	CALL CALBAS
309+  512B D5           	PUSH DE
310+  512C              	; comma
311+  512C CD 00 60     	CALL CHKCHAR
312+  512F 2C           	DB ','
313+  5130              	; get pointer
314+  5130 DD 21 2F 54  	LD IX, FRMQNT
315+  5134 CD 59 01     	CALL CALBAS
316+  5137 D5           	PUSH DE
317+  5138              	; ending )
318+  5138 CD 00 60     	CALL CHKCHAR
319+  513B 29           	DB ')'
320+  513C              .ENTRY:
321+  513C E5               PUSH HL
322+  513D DD E1            POP IX
323+  513F D9               EXX
324+  5140 D1               POP DE ; pointer
325+  5141 E1               POP HL ; ticks
326+  5142 D9               EXX
327+  5143 F1               POP AF
328+  5144 CD C9 4F         CALL GETnthANIMITEM
329+  5147 E5               PUSH HL
330+  5148 FD E1            POP IY
331+  514A D9               EXX
332+  514B FD 36 00 01      LD (IY),1 ; type=1
333+  514F FD 75 01         LD (IY+1),L
334+  5152 FD 74 02         LD (IY+2),H
335+  5155 FD 73 03         LD (IY+3),E
336+  5158 FD 72 04         LD (IY+4),D
337+  515B
338+  515B DD E5            PUSH IX
339+  515D E1               POP HL
340+  515E C9               RET
341+  515F              ; *******************************************************************************************************
342+  515F
343+  515F              ; *******************************************************************************************************
344+  515F              ; function to handle CALL MAXANIMDEFS basic extension
345+  515F              ; MAXANIMDEFS (BYTE number)
346+  515F              ; sets new number and moves memory buffers as needed
347+  515F              MAXANIMDEFS:
348+  515F              	; opening (
349+  515F CD 00 60     	CALL CHKCHAR
350+  5162 28           	DB '('
351+  5163              	; get value
352+  5163 DD 21 1C 52  	LD IX, GETBYT
353+  5167 CD 59 01     	CALL CALBAS
354+  516A F5               PUSH AF
355+  516B              	; ending )
356+  516B CD 00 60     	CALL CHKCHAR
357+  516E 29           	DB ')'
358+  516F F1               POP AF
359+  5170
360+  5170              	; save position
361+  5170 E5           	PUSH HL
362+  5171              .ENTRY:
363+  5171 47               LD B,A
364+  5172 3A BA 4F         LD A,(ANIMDEFNUM)
365+  5175 90               SUB B
366+  5176 CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  5179 FD 21 BE 4F      LD IY,ANIMSPRPTR
368+  517D FA 89 51         JP M, .INCREASE
369+  5180                  ; new value is lower than previous one
370+  5180 CD 94 51         CALL .SIZEDIFF
371+  5183 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  5186 C3 19 50         JP MAXANIMITEMS.E1
373+  5189              .INCREASE:
374+  5189 ED 44            NEG
375+  518B CD 94 51         CALL .SIZEDIFF
376+  518E CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5191 C3 34 50         JP MAXANIMITEMS.E2
378+  5194              .SIZEDIFF:
379+  5194 26 00            LD H,0
380+  5196 6F               LD L,A
381+  5197 CD EE 5E         CALL HLx16
382+  519A 78               LD A,B
383+  519B 32 BA 4F         LD (ANIMDEFNUM),A
384+  519E 44               LD B,H
385+  519F 4D               LD C,L
386+  51A0 C9               RET ; BC=size difference in bytes
387+  51A1              ; *******************************************************************************************************
388+  51A1
389+  51A1              ; *******************************************************************************************************
390+  51A1              ; function to handle CALL ANIMDEF basic extension
391+  51A1              ; ANIMITEMPAT ( BYTE id,
392+  51A1              ;               BYTE size,
393+  51A1              ;               INT[] list )
394+  51A1              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A1              ANIMDEF:
396+  51A1                  ; opening (
397+  51A1 CD 00 60     	CALL CHKCHAR
398+  51A4 28           	DB '('
399+  51A5              	; get id
400+  51A5 DD 21 1C 52  	LD IX, GETBYT
401+  51A9 CD 59 01     	CALL CALBAS
402+  51AC F5               PUSH AF
403+  51AD                  ; check if out of bounds
404+  51AD 3C               INC A
405+  51AE 4F               LD C,A
406+  51AF 3A BA 4F         LD A,(ANIMDEFNUM)
407+  51B2 B9               CP C
408+  51B3 DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51B6              	; comma
410+  51B6 CD 00 60     	CALL CHKCHAR
411+  51B9 2C           	DB ','
412+  51BA              	; get size
413+  51BA DD 21 1C 52  	LD IX, GETBYT
414+  51BE CD 59 01     	CALL CALBAS
415+  51C1 FE 10            CP 16
416+  51C3 D2 1A 60         JP NC, OVERFLOW
417+  51C6 B7               OR A
418+  51C7 CA 1A 60         JP Z, OVERFLOW
419+  51CA F5           	PUSH AF
420+  51CB              	; comma
421+  51CB CD 00 60     	CALL CHKCHAR
422+  51CE 2C           	DB ','
423+  51CF              	; get pointer to a list of animation items in integer array format
424+  51CF                  ; get array pointer
425+  51CF D1               POP DE
426+  51D0 D5               PUSH DE
427+  51D1 3E 02            LD A,2
428+  51D3 06 01            LD B,1
429+  51D5 CD 27 60         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51D8 C5               PUSH BC
431+  51D9              	; ending )
432+  51D9 CD 00 60     	CALL CHKCHAR
433+  51DC 29           	DB ')'
434+  51DD              .ENTRY:
435+  51DD E5               PUSH HL
436+  51DE DD E1            POP IX
437+  51E0 D1               POP DE ; pointer to INT array
438+  51E1 C1               POP BC ; B=item number
439+  51E2 F1               POP AF ; id
440+  51E3 D5               PUSH DE
441+  51E4 CD D2 4F         CALL GETnthANIMDEF
442+  51E7 D1               POP DE
443+  51E8 70               LD (HL),B
444+  51E9              .L1:
445+  51E9 23               INC HL
446+  51EA 1A               LD A,(DE)
447+  51EB 13          > INC DE
447+  51EC 13          > INC DE
448+  51ED 77               LD (HL),A
449+  51EE 10 F9            DJNZ .L1
450+  51F0 DD E5            PUSH IX
451+  51F2 E1               POP HL
452+  51F3 C9               RET
453+  51F4              ; *******************************************************************************************************
454+  51F4
455+  51F4              ; *******************************************************************************************************
456+  51F4              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F4              ; MAXANIMSPRS (BYTE number)
458+  51F4              ; sets new number and moves memory buffers as needed
459+  51F4              MAXANIMSPRS:
460+  51F4              	; opening (
461+  51F4 CD 00 60     	CALL CHKCHAR
462+  51F7 28           	DB '('
463+  51F8              	; get value
464+  51F8 DD 21 1C 52  	LD IX, GETBYT
465+  51FC CD 59 01     	CALL CALBAS
466+  51FF F5               PUSH AF
467+  5200              	; ending )
468+  5200 CD 00 60     	CALL CHKCHAR
469+  5203 29           	DB ')'
470+  5204 F1               POP AF
471+  5205
472+  5205              	; save position
473+  5205 E5           	PUSH HL
474+  5206              .ENTRY:
475+  5206 47               LD B,A
476+  5207 3A BD 4F         LD A,(ANIMSPRNUM)
477+  520A 90               SUB B
478+  520B CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  520E FD 21 10 40      LD IY,FREEMEMPTR
480+  5212 FA 1E 52         JP M, .INCREASE
481+  5215                  ; new value is lower than previous one
482+  5215 CD 3D 52         CALL .SIZEDIFF
483+  5218 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  521B C3 22 50         JP MAXANIMITEMS.EXIT
485+  521E              .INCREASE:
486+  521E ED 44            NEG
487+  5220 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5221 CD 3D 52         CALL .SIZEDIFF
489+  5224 CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  5227 AF               XOR A
491+  5228 ED 42            SBC HL,BC ; location of new stuff
492+  522A F1               POP AF
493+  522B 47               LD B,A
494+  522C 11 08 00         LD DE,8
495+  522F E5               PUSH HL
496+  5230 DD E1            POP IX
497+  5232              .L1:
498+  5232 DD 36 06 00      LD (IX+6),0
499+  5236 DD 19            ADD IX,DE
500+  5238 10 F8            DJNZ .L1
501+  523A C3 22 50         JP MAXANIMITEMS.EXIT
502+  523D              .SIZEDIFF:
503+  523D 26 00            LD H,0
504+  523F 6F               LD L,A
505+  5240 CD EF 5E         CALL HLx8
506+  5243 78               LD A,B
507+  5244 32 BD 4F         LD (ANIMSPRNUM),A
508+  5247 44               LD B,H
509+  5248 4D               LD C,L
510+  5249 C9               RET ; BC=size difference in bytes
511+  524A              ; *******************************************************************************************************
512+  524A
513+  524A              ; *******************************************************************************************************
514+  524A              ; function to handle CALL ANIMSPRITE basic extension
515+  524A              ; ANIMSPRITE ( BYTE id,
516+  524A              ;              BYTE sprite_number,
517+  524A              ;              BYTE animation_definition_id,
518+  524A              ;              BYTE cyclic_flag )
519+  524A              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524A              ANIMSPRITE:
521+  524A                  ; opening (
522+  524A CD 00 60     	CALL CHKCHAR
523+  524D 28           	DB '('
524+  524E              	; get sprite animation id
525+  524E DD 21 1C 52  	LD IX, GETBYT
526+  5252 CD 59 01     	CALL CALBAS
527+  5255 F5               PUSH AF
528+  5256 3C               INC A
529+  5257 4F               LD C,A
530+  5258 3A BD 4F         LD A,(ANIMSPRNUM)
531+  525B B9               CP C
532+  525C DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  525F              	; comma
534+  525F CD 00 60     	CALL CHKCHAR
535+  5262 2C           	DB ','
536+  5263              	; get sprite number
537+  5263 DD 21 1C 52  	LD IX, GETBYT
538+  5267 CD 59 01     	CALL CALBAS
539+  526A F5               PUSH AF
540+  526B                  ; check if out of bounds
541+  526B FE 20            CP 32
542+  526D D2 16 60         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5270              	; comma
544+  5270 CD 00 60     	CALL CHKCHAR
545+  5273 2C           	DB ','
546+  5274              	; get animation definition id
547+  5274 DD 21 1C 52  	LD IX, GETBYT
548+  5278 CD 59 01     	CALL CALBAS
549+  527B F5               PUSH AF
550+  527C 3C               INC A
551+  527D 4F               LD C,A
552+  527E 3A BA 4F         LD A,(ANIMDEFNUM)
553+  5281 B9               CP C
554+  5282 DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  5285              	; comma
556+  5285 CD 00 60     	CALL CHKCHAR
557+  5288 2C           	DB ','
558+  5289              	; get cyclic flag
559+  5289 DD 21 1C 52  	LD IX, GETBYT
560+  528D CD 59 01         CALL CALBAS
561+  5290 F5           	PUSH AF
562+  5291              	; ending )
563+  5291 CD 00 60     	CALL CHKCHAR
564+  5294 29           	DB ')'
565+  5295              .ENTRY:
566+  5295 E5               PUSH HL
567+  5296 DD E1            POP IX
568+  5298 D9               EXX
569+  5299 D1               POP DE ; cyclic
570+  529A C1               POP BC ; animation definition id
571+  529B E1               POP HL ; sprite number
572+  529C D9               EXX
573+  529D F1               POP AF ; sprite animation id
574+  529E CD DE 4F         CALL GETnthSPRANIM
575+  52A1 E5               PUSH HL
576+  52A2 FD E1            POP IY
577+  52A4 D9               EXX
578+  52A5 FD 74 00         LD (IY),H
579+  52A8 FD 70 04         LD (IY+4),B
580+  52AB FD 72 05         LD (IY+5),D
581+  52AE                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
582+  52AE                  ; following will do preparation for ANIMSTEP situation
583+  52AE                  ; current item set to above limit and timer to 1
584+  52AE                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
585+  52AE FD 36 03 FF      LD (IY+3),255
586+  52B2 FD 36 01 01      LD (IY+1),1
587+  52B6 FD 36 02 00      LD (IY+2),0
588+  52BA                  ; mark as sprite animation
589+  52BA FD 36 07 00      LD (IY+7),0
590+  52BE DD E5            PUSH IX
591+  52C0 E1               POP HL
592+  52C1 C9               RET
593+  52C2              ; *******************************************************************************************************
594+  52C2
595+  52C2              ; *******************************************************************************************************
596+  52C2              ; function to handle CALL ANIMCHAR basic extension
597+  52C2              ; ANIMCHAR ( BYTE id,
598+  52C2              ;            INT character number 0-767,
599+  52C2              ;            BYTE animation_definition_id,
600+  52C2              ;            BYTE cyclic_flag )
601+  52C2              ; fills sprite animation data, returns an error if out of bounds, or invalid type
602+  52C2              ANIMCHAR:
603+  52C2                  ; opening (
604+  52C2 CD 00 60     	CALL CHKCHAR
605+  52C5 28           	DB '('
606+  52C6              	; get sprite animation id
607+  52C6 DD 21 1C 52  	LD IX, GETBYT
608+  52CA CD 59 01     	CALL CALBAS
609+  52CD F5               PUSH AF
610+  52CE 3C               INC A
611+  52CF 4F               LD C,A
612+  52D0 3A BD 4F         LD A,(ANIMSPRNUM)
613+  52D3 B9               CP C
614+  52D4 DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
615+  52D7              	; comma
616+  52D7 CD 00 60     	CALL CHKCHAR
617+  52DA 2C           	DB ','
618+  52DB              	; get character number
619+  52DB DD 21 2F 54  	LD IX, FRMQNT
620+  52DF CD 59 01     	CALL CALBAS
621+  52E2 D5               PUSH DE
622+  52E3                  ; check if out of bounds
623+  52E3 7A               LD A,D
624+  52E4 FE 03            CP 3
625+  52E6 D2 16 60         JP NC, SUBSCRIPT_OUT_OF_RANGE
626+  52E9              	; comma
627+  52E9 CD 00 60     	CALL CHKCHAR
628+  52EC 2C           	DB ','
629+  52ED              	; get animation definition id
630+  52ED DD 21 1C 52  	LD IX, GETBYT
631+  52F1 CD 59 01     	CALL CALBAS
632+  52F4 F5               PUSH AF
633+  52F5 3C               INC A
634+  52F6 4F               LD C,A
635+  52F7 3A BA 4F         LD A,(ANIMDEFNUM)
636+  52FA B9               CP C
637+  52FB DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
638+  52FE              	; comma
639+  52FE CD 00 60     	CALL CHKCHAR
640+  5301 2C           	DB ','
641+  5302              	; get cyclic flag
642+  5302 DD 21 1C 52  	LD IX, GETBYT
643+  5306 CD 59 01         CALL CALBAS
644+  5309 F5           	PUSH AF
645+  530A              	; ending )
646+  530A CD 00 60     	CALL CHKCHAR
647+  530D 29           	DB ')'
648+  530E              .ENTRY:
649+  530E E5               PUSH HL
650+  530F DD E1            POP IX
651+  5311 D9               EXX
652+  5312 D1               POP DE ; cyclic
653+  5313 C1               POP BC ; animation definition id
654+  5314 E1               POP HL ; character number
655+  5315 D9               EXX
656+  5316 F1               POP AF ; sprite animation id
657+  5317 CD DE 4F         CALL GETnthSPRANIM
658+  531A E5               PUSH HL
659+  531B FD E1            POP IY
660+  531D D9               EXX
661+  531E FD 75 00         LD (IY),L
662+  5321 24               INC H ; save character bank+1
663+  5322 FD 74 07         LD (IY+7),H
664+  5325 FD 70 04         LD (IY+4),B
665+  5328 FD 72 05         LD (IY+5),D
666+  532B                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
667+  532B                  ; following will do preparation for ANIMSTEP situation
668+  532B                  ; current item set to above limit and timer to 1
669+  532B                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
670+  532B FD 36 03 FF      LD (IY+3),255
671+  532F FD 36 01 01      LD (IY+1),1
672+  5333 FD 36 02 00      LD (IY+2),0
673+  5337 DD E5            PUSH IX
674+  5339 E1               POP HL
675+  533A C9               RET
676+  533B              ; *******************************************************************************************************
677+  533B
678+  533B              ; *******************************************************************************************************
679+  533B              ; function to handle CALL ANIMSTEP basic extension
680+  533B              ; two forms
681+  533B              ; ANIMSTEP ( BYTE id )
682+  533B              ; or
683+  533B              ; ANIMSTEP ( BYTE item_number,
684+  533B              ;            INT[] sprite_animations )
685+  533B              ; sets active flag to 1
686+  533B              ANIMSTEP:
687+  533B 11 B8 53         LD DE,ANIMSTARTSTOP_COMMON.STEP
688+  533E 18 08            JR ANIMSTARTSTOP_COMMON
689+  5340              ; *******************************************************************************************************
690+  5340              ; *******************************************************************************************************
691+  5340              ; function to handle CALL ANIMSTART basic extension
692+  5340              ; two forms
693+  5340              ; ANIMSTART ( BYTE id )
694+  5340              ; or
695+  5340              ; ANIMSTART ( BYTE item_number,
696+  5340              ;             INT[] sprite_animations )
697+  5340              ; sets active flag to 1
698+  5340              ANIMSTART:
699+  5340 11 A6 53         LD DE,ANIMSTARTSTOP_COMMON.START
700+  5343 18 03            JR ANIMSTARTSTOP_COMMON
701+  5345              ; *******************************************************************************************************
702+  5345              ; *******************************************************************************************************
703+  5345              ; function to handle CALL ANIMSTOP basic extension
704+  5345              ; two forms
705+  5345              ; ANIMSTOP ( BYTE id )
706+  5345              ; or
707+  5345              ; ANIMSTOP ( BYTE item_number,
708+  5345              ;            INT[] sprite_animations )
709+  5345              ; sets active flag to 1
710+  5345              ANIMSTOP:
711+  5345 11 B3 53         LD DE,ANIMSTARTSTOP_COMMON.STOP
712+  5348              ; *******************************************************************************************************
713+  5348              ANIMSTARTSTOP_COMMON:
714+  5348 ED 53 A4 53      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
715+  534C                  ; opening (
716+  534C CD 00 60     	CALL CHKCHAR
717+  534F 28           	DB '('
718+  5350              	; get sprite animation id or array size
719+  5350 DD 21 1C 52  	LD IX,GETBYT
720+  5354 CD 59 01     	CALL CALBAS
721+  5357 F5               PUSH AF
722+  5358                  ; check if comma present
723+  5358 CD 0A 60         CALL GETPREVCHAR
724+  535B 23               INC HL
725+  535C FE 2C            CP ','
726+  535E 28 0C            JR Z,.L1
727+  5360 FE 29            CP ')'
728+  5362 C2 1E 60         JP NZ,SYNTAX_ERROR
729+  5365                  ; ok so single argument variant
730+  5365 F1               POP AF
731+  5366 E5               PUSH HL
732+  5367 CD 92 53         CALL .SETVALUE
733+  536A E1               POP HL
734+  536B C9               RET
735+  536C              .L1:
736+  536C                  ; get array pointer
737+  536C D1               POP DE
738+  536D D5               PUSH DE
739+  536E 3E 02            LD A,2
740+  5370 06 01            LD B,1
741+  5372 CD 27 60         CALL GET_BASIC_ARRAY_DATA_POINTER
742+  5375 C5               PUSH BC
743+  5376              	; ending )
744+  5376 CD 00 60     	CALL CHKCHAR
745+  5379 29           	DB ')'
746+  537A D1               POP DE ; array pointer
747+  537B C1               POP BC ; number of items
748+  537C 78               LD A,B
749+  537D B7               OR A
750+  537E CA 16 60         JP Z,SUBSCRIPT_OUT_OF_RANGE
751+  5381 E5               PUSH HL
752+  5382 F3               DI
753+  5383              .L2:
754+  5383 C5               PUSH BC
755+  5384 1A               LD A,(DE)
756+  5385 13          > INC DE
756+  5386 13          > INC DE
757+  5387 D5               PUSH DE
758+  5388 CD 92 53         CALL .SETVALUE
759+  538B D1               POP DE
760+  538C C1               POP BC
761+  538D 10 F4            DJNZ .L2
762+  538F FB               EI
763+  5390 E1               POP HL
764+  5391 C9               RET
765+  5392
766+  5392              .SETVALUE:
767+  5392 47               LD B,A
768+  5393 3C               INC A
769+  5394 4F               LD C,A
770+  5395 3A BD 4F         LD A,(ANIMSPRNUM)
771+  5398 B9               CP C
772+  5399 DA 16 60         JP C,SUBSCRIPT_OUT_OF_RANGE
773+  539C 78               LD A,B
774+  539D CD DE 4F         CALL GETnthSPRANIM
775+  53A0 E5               PUSH HL
776+  53A1 DD E1            POP IX
777+  53A3              .FN:
778+  53A3 C3 00 00         JP 0
779+  53A6              .START:
780+  53A6 DD 36 06 01      LD (IX+6),1 ; active flag
781+  53AA DD 36 03 00      LD (IX+3),0 ; current item
782+  53AE 06 00            LD B,0 ; setup timer
783+  53B0 C3 37 54         JP SETUP_ANIM_STEP
784+  53B3              .STOP:
785+  53B3 DD 36 06 00      LD (IX+6),0 ; active flag
786+  53B7 C9               RET
787+  53B8              .STEP:
788+  53B8 06 00            LD B,0
789+  53BA C3 DB 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
790+  53BD              ; *******************************************************************************************************
791+  53BD
792+  53BD              ; *******************************************************************************************************
793+  53BD              ; function processes animations during vblank period
794+  53BD              PROCESS_ANIMATIONS:
795+  53BD 3A BD 4F         LD A,(ANIMSPRNUM)
796+  53C0 B7               OR A
797+  53C1 C8               RET Z; no animations defined
798+  53C2 47               LD B,A
799+  53C3 DD 2A BE 4F      LD IX,(ANIMSPRPTR)
800+  53C7              .L1:
801+  53C7 C5               PUSH BC
802+  53C8 06 00            LD B,0 ; normal mode, change on timer expiry only
803+  53CA CD D6 53         CALL PROCESS_SINGLE_ANIMATION
804+  53CD 11 08 00         LD DE,8
805+  53D0 DD 19            ADD IX,DE
806+  53D2 C1               POP BC
807+  53D3 10 F2            DJNZ .L1
808+  53D5 C9               RET
809+  53D6              ; *******************************************************************************************************
810+  53D6
811+  53D6              ; *******************************************************************************************************
812+  53D6              ; processes single sprite animation
813+  53D6              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
814+  53D6              ; on timer expiry goes to next animation item
815+  53D6              ; input IX=sprite animation pointer
816+  53D6              ; input B=1 force mode, activate animation action regardless of expired timer
817+  53D6              PROCESS_SINGLE_ANIMATION:
818+  53D6 DD 7E 06         LD A,(IX+6); active
819+  53D9 B7               OR A
820+  53DA C8               RET Z ; inactive animation
821+  53DB              .INACTIVE_TOO:
822+  53DB DD 6E 01         LD L,(IX+1)
823+  53DE DD 66 02         LD H,(IX+2) ; HL=end time
824+  53E1 2B               DEC HL
825+  53E2 DD 75 01         LD (IX+1),L
826+  53E5 DD 74 02         LD (IX+2),H
827+  53E8 7D               LD A,L
828+  53E9 B4               OR H
829+  53EA 28 06            JR Z,.STEP
830+  53EC 05               DEC B
831+  53ED 04               INC B
832+  53EE C8               RET Z ; not forced mode, return
833+  53EF C3 37 54         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
834+  53F2              .STEP:
835+  53F2 06 00            LD B,0; setup timer
836+  53F4 DD 34 03         INC (IX+3) ; current animation item
837+  53F7 C3 37 54         JP SETUP_ANIM_STEP
838+  53FA              ; *******************************************************************************************************
839+  53FA
840+  53FA              ; *******************************************************************************************************
841+  53FA              ; function will setup sprite animation after current item change
842+  53FA              ; input A=current animation definition
843+  53FA              ; input IX=pointer to sprite animation
844+  53FA              ; input B=1 skip timer setup
845+  53FA              ; output IY=pointer to animation item
846+  53FA              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
847+  53FA              ; basically sets new end time for current animation
848+  53FA              INIT_CURRENT_ANIMATION:
849+  53FA CD D2 4F         CALL GETnthANIMDEF
850+  53FD DD 7E 03         LD A,(IX+3) ; current animation item
851+  5400 BE               CP (HL) ; number of animation items in the animation definition
852+  5401 38 0A            JR C,.L3 ; last item not reached
853+  5403                  ; last item reached
854+  5403 DD 7E 05         LD A,(IX+5) ; cyclic flag
855+  5406 B7               OR A
856+  5407 28 2C            JR Z,.ERROR ; non-cyclic animation
857+  5409                  ; cyclic animation, restart
858+  5409 DD 36 03 00      LD (IX+3),0; current item
859+  540D              .L3:
860+  540D                  ; HL = animation definition
861+  540D 23               INC HL ; skip animation definition size field
862+  540E 16 00            LD D,0
863+  5410 DD 5E 03         LD E,(IX+3); current item
864+  5413 19               ADD HL,DE
865+  5414 4E               LD C,(HL) ; current animation item
866+  5415 0C               INC C
867+  5416 3A B7 4F         LD A,(ANIMITEMNUM)
868+  5419 B9               CP C
869+  541A 38 19            JR C,.ERROR ; invalid animation item, stop animation
870+  541C 0D               DEC C
871+  541D 79               LD A,C
872+  541E CD C9 4F         CALL GETnthANIMITEM
873+  5421 E5               PUSH HL
874+  5422 FD E1            POP IY ; IY=animation item
875+  5424 05               DEC B
876+  5425 28 0C            JR Z,.EXIT
877+  5427 FD 5E 01         LD E,(IY+1)
878+  542A FD 56 02         LD D,(IY+2) ; duration
879+  542D DD 73 01         LD (IX+1),E
880+  5430 DD 72 02         LD (IX+2),D
881+  5433              .EXIT:
882+  5433 AF               XOR A
883+  5434 C9               RET
884+  5435              .ERROR:
885+  5435 37               SCF
886+  5436 C9               RET
887+  5437              ; *******************************************************************************************************
888+  5437
889+  5437              ; *******************************************************************************************************
890+  5437              ; function will display currect item and set up expiry time
891+  5437              ; it will also stop the animation if expired
892+  5437              ; sets sprite update flag if any changes in sprite data made
893+  5437              ; input IX=current sprite animation
894+  5437              ; input B=1 skip timer setup
895+  5437              SETUP_ANIM_STEP:
896+  5437 DD 4E 04         LD C,(IX+4) ; animation definition ID
897+  543A 0C               INC C
898+  543B 3A BA 4F         LD A,(ANIMDEFNUM)
899+  543E B9               CP C
900+  543F 30 05            JR NC,.L2
901+  5441                  ; given animation item is outside of bounds, deactivate animation
902+  5441              .STOPANIM:
903+  5441 DD 36 06 00      LD (IX+6),0
904+  5445 C9               RET
905+  5446              .L2:
906+  5446 0D               DEC C
907+  5447 79               LD A,C
908+  5448 CD FA 53         CALL INIT_CURRENT_ANIMATION
909+  544B 38 F4            JR C, .STOPANIM
910+  544D FD 7E 00         LD A,(IY) ; type of animation item
911+  5450 B7               OR A
912+  5451 28 38            JR Z,.L4 ; change pattern and/or color
913+  5453              .PAT:
914+  5453                  ; change pattern definition
915+  5453                  ; check if sprite or character
916+  5453 DD 7E 07         LD A,(IX+7)
917+  5456 B7               OR A
918+  5457 20 4C            JR NZ,.CHAR
919+  5459 DD 7E 00         LD A,(IX) ; sprite number
920+  545C CD 7C 4D         CALL GETnthSPRATTR
921+  545F 23          > INC HL ; skip y and x
921+  5460 23          > INC HL
921+  5461 23          > INC HL
921+  5462 23          > INC HL
922+  5463 7E               LD A,(HL); current pattern
923+  5464 26 00            LD H,0
924+  5466 6F               LD L,A
925+  5467 3A E0 F3         LD A,(REG1SAV)
926+  546A E6 02            AND 2
927+  546C 20 07            JR NZ,.L6
928+  546E                  ; 8x8 sprite
929+  546E CD EF 5E         CALL HLx8
930+  5471 06 08            LD B,8
931+  5473 18 05            JR .L5
932+  5475              .L6:
933+  5475 CD ED 5E         CALL HLx32
934+  5478 06 20            LD B,32
935+  547A              .L5:
936+  547A ED 5B 26 F9      LD DE,(PATBAS)
937+  547E              .L7:
938+  547E 19               ADD HL,DE
939+  547F CD DA 5E         CALL SETWRT_LOCAL
940+  5482 FD 6E 03         LD L,(IY+3)
941+  5485 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
942+  5488 C3 E5 5E         JP BBYTECOPY
943+  548B              .L4:
944+  548B                  ; change pattern and color in sprite attributes table
945+  548B DD 7E 00         LD A,(IX) ; sprite number
946+  548E CD 7C 4D         CALL GETnthSPRATTR
947+  5491 23          > INC HL ; skip y and x
947+  5492 23          > INC HL
947+  5493 23          > INC HL
947+  5494 23          > INC HL
948+  5495 FD 7E 03         LD A,(IY+3) ; new pattern
949+  5498 77               LD (HL),A
950+  5499 23          > INC HL
950+  549A 23          > INC HL
951+  549B FD 7E 04         LD A,(IY+4) ; new color
952+  549E 77               LD (HL),A
953+  549F 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
954+  54A2 36 01            LD (HL),1
955+  54A4 C9               RET
956+  54A5              .CHAR:
957+  54A5 DD 6E 00         LD L,(IX)
958+  54A8 3D               DEC A
959+  54A9 67               LD H,A
960+  54AA CD EF 5E         CALL HLx8
961+  54AD ED 5B 24 F9      LD DE,(CGPBAS)
962+  54B1 06 08            LD B,8
963+  54B3 18 C9            JR .L7
964+  54B5              ; *******************************************************************************************************
965+  54B5
# file closed: asm\ANIMATION.asm
121   54B5               ENDIF
122   54B5
123   54B5               IF (RAM_CMDS == 1)
124   54B5               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  54B5              ; *******************************************************************************************************
  2+  54B5              ; function to handle CALL MEMCPY basic extension
  3+  54B5              ; _MEMCPY ( INT source,
  4+  54B5              ;			INT destination,
  5+  54B5              ;			INT count,
  6+  54B5              ; will put ram in page 0 also, page 1 is already there
  7+  54B5              MEMCPY:
  8+  54B5              	; opening (
  9+  54B5 CD 00 60     	CALL CHKCHAR
 10+  54B8 28           	DB '('
 11+  54B9              	; get source address
 12+  54B9 DD 21 2F 54  	LD IX, FRMQNT
 13+  54BD CD 59 01     	CALL CALBAS
 14+  54C0 D5           	PUSH DE
 15+  54C1              	; comma
 16+  54C1 CD 00 60     	CALL CHKCHAR
 17+  54C4 2C           	DB ','
 18+  54C5              	; get destination address
 19+  54C5 DD 21 2F 54  	LD IX, FRMQNT
 20+  54C9 CD 59 01     	CALL CALBAS
 21+  54CC D5           	PUSH DE
 22+  54CD              	; comma
 23+  54CD CD 00 60     	CALL CHKCHAR
 24+  54D0 2C           	DB ','
 25+  54D1              	; get length
 26+  54D1 DD 21 2F 54  	LD IX, FRMQNT
 27+  54D5 CD 59 01     	CALL CALBAS
 28+  54D8 D5           	PUSH DE
 29+  54D9              	; ending )
 30+  54D9 CD 00 60     	CALL CHKCHAR
 31+  54DC 29           	DB ')'
 32+  54DD
 33+  54DD              	; save position
 34+  54DD E5           	PUSH HL
 35+  54DE DD E1        	POP IX
 36+  54E0
 37+  54E0 C1           	POP BC ; count
 38+  54E1 D1           	POP DE ; destination
 39+  54E2 E1           	POP HL ; source
 40+  54E3 D9           	EXX
 41+  54E4              	; enable page 0
 42+  54E4 FD 21 EB 54  	LD IY, .RET
 43+  54E8 C3 B3 5F     	JP ENABLE_PAGE0
 44+  54EB              .RET:
 45+  54EB FB           	EI
 46+  54EC D9           	EXX
 47+  54ED ED B0        	LDIR
 48+  54EF D1               POP DE
 49+  54F0 C1               POP BC
 50+  54F1 CD 2A 5F         CALL RESTORE_PAGE_INFO
 51+  54F4 DD E5        	PUSH IX
 52+  54F6 E1           	POP HL
 53+  54F7 C9           	RET
 54+  54F8              ; *******************************************************************************************************
 55+  54F8
 56+  54F8              ; *******************************************************************************************************
 57+  54F8              ; function to handle CALL FILRAM basic extension
 58+  54F8              ; FILRAM ( INT start address,
 59+  54F8              ;		   INT count,
 60+  54F8              ;		   BYTE value,
 61+  54F8              ; will put ram in page 0 also, page 1 is already there
 62+  54F8              FILRAM:
 63+  54F8              	; opening (
 64+  54F8 CD 00 60     	CALL CHKCHAR
 65+  54FB 28           	DB '('
 66+  54FC              	; get start address
 67+  54FC DD 21 2F 54  	LD IX, FRMQNT
 68+  5500 CD 59 01     	CALL CALBAS
 69+  5503 D5           	PUSH DE
 70+  5504              	; comma
 71+  5504 CD 00 60     	CALL CHKCHAR
 72+  5507 2C           	DB ','
 73+  5508              	; get count
 74+  5508 DD 21 2F 54  	LD IX, FRMQNT
 75+  550C CD 59 01     	CALL CALBAS
 76+  550F D5           	PUSH DE
 77+  5510              	; comma
 78+  5510 CD 00 60     	CALL CHKCHAR
 79+  5513 2C           	DB ','
 80+  5514              	; get value
 81+  5514 DD 21 1C 52  	LD IX, GETBYT
 82+  5518 CD 59 01     	CALL CALBAS
 83+  551B F5           	PUSH AF
 84+  551C              	; ending )
 85+  551C CD 00 60     	CALL CHKCHAR
 86+  551F 29           	DB ')'
 87+  5520
 88+  5520              	; save position
 89+  5520 E5           	PUSH HL
 90+  5521 DD E1        	POP IX
 91+  5523
 92+  5523 D1           	POP DE ; actually AF
 93+  5524 C1           	POP BC ; count
 94+  5525 E1           	POP HL ; start address
 95+  5526 78           	LD A, B
 96+  5527 B7           	OR A
 97+  5528 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  552A B1           	OR C
 99+  552B 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  552D 79           	LD A, C
101+  552E 3D           	DEC A
102+  552F 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  5531              	; one byte to fill
104+  5531 72           	LD (HL), D
105+  5532 18 12        	JR .EXIT
106+  5534              .L1:
107+  5534 D9           	EXX
108+  5535              	; enable page 0
109+  5535 FD 21 3C 55  	LD IY, .RET
110+  5539 C3 B3 5F     	JP ENABLE_PAGE0
111+  553C              .RET:
112+  553C FB           	EI
113+  553D D9           	EXX
114+  553E CD 4A 55     	CALL .FILLVALUE
115+  5541 D1               POP DE
116+  5542 C1               POP BC
117+  5543 CD 2A 5F         CALL RESTORE_PAGE_INFO
118+  5546              .EXIT:
119+  5546 DD E5        	PUSH IX
120+  5548 E1           	POP HL
121+  5549 C9           	RET
122+  554A
123+  554A              .FILLVALUE:
124+  554A 72               LD (HL), D
125+  554B 54               LD D, H
126+  554C 5D               LD E, L
127+  554D 13               INC DE
128+  554E 0B               DEC BC
129+  554F ED B0            LDIR
130+  5551 C9               RET
131+  5552              ; *******************************************************************************************************
132+  5552
# file closed: asm\MEMORY.asm
125   5552               ENDIF
126   5552
127   5552               IF (SOUND_CMDS == 1)
128   5552               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  5552              MUSIC_INIT_STATUS:
  2+  5552 00            DB 0
  3+  5553              SFX_INIT_STATUS:
  4+  5553 00            DB 0
  5+  5554              SOUND_ENABLED:
  6+  5554 00            DB 0
  7+  5555
  8+  5555              ; *******************************************************************************************************
  9+  5555              ; function to handle CALL SNDPLYINIT basic extension
 10+  5555              ; initializes sound player
 11+  5555              ; _SNDPLYINIT ( INT music_offset,
 12+  5555              ;				INT sfx_offset, can be -1 if no SFX
 13+  5555              ; will put ram in page 0 also, page 1 is already there
 14+  5555              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  5555              SNDPLYINIT:
 16+  5555              	; opening (
 17+  5555 CD 00 60     	CALL CHKCHAR
 18+  5558 28           	DB '('
 19+  5559              	; get music address
 20+  5559 DD 21 2F 54  	LD IX, FRMQNT
 21+  555D CD 59 01     	CALL CALBAS
 22+  5560 D5           	PUSH DE
 23+  5561              	; comma
 24+  5561 CD 00 60     	CALL CHKCHAR
 25+  5564 2C           	DB ','
 26+  5565              	; get sfx address
 27+  5565 DD 21 2F 54  	LD IX, FRMQNT
 28+  5569 CD 59 01     	CALL CALBAS
 29+  556C D5           	PUSH DE
 30+  556D              	; ending )
 31+  556D CD 00 60     	CALL CHKCHAR
 32+  5570 29           	DB ')'
 33+  5571
 34+  5571                  ; save position in BASIC text
 35+  5571 44           	LD B, H
 36+  5572 4D           	LD C, L
 37+  5573
 38+  5573              	; pop LDIR parameters and store away for later
 39+  5573 D1           	POP DE ; sfx address
 40+  5574 E1           	POP HL ; music address
 41+  5575 C5           	PUSH BC ; basic text location
 42+  5576 D9           	EXX
 43+  5577 FD 21 7E 55  	LD IY, .RET
 44+  557B C3 B3 5F     	JP ENABLE_PAGE0
 45+  557E              .RET:
 46+  557E D9           	EXX
 47+  557F
 48+  557F D5           	PUSH DE
 49+  5580 AF           	XOR A
 50+  5581              	; HL = music location
 51+  5581 CD 62 41     	CALL PLY_AKG_INIT
 52+  5584 3E 01        	LD A, 1
 53+  5586 32 52 55     	LD (MUSIC_INIT_STATUS), A
 54+  5589
 55+  5589 E1           	POP HL ; SFX
 56+  558A              	; check if SFX address -1
 57+  558A 23           	INC HL
 58+  558B 7D           	LD A, L
 59+  558C B4           	OR H
 60+  558D 28 09        	JR Z,.L1
 61+  558F 2B           	DEC HL
 62+  5590 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  5593 3E 01        	LD A, 1
 64+  5595 32 53 55     	LD (SFX_INIT_STATUS), A
 65+  5598              .L1:
 66+  5598 D1               POP DE
 67+  5599 C1               POP BC
 68+  559A CD 2A 5F         CALL RESTORE_PAGE_INFO
 69+  559D
 70+  559D E1           	POP HL
 71+  559E C9           	RET
 72+  559F              ; *******************************************************************************************************
 73+  559F
 74+  559F              ; *******************************************************************************************************
 75+  559F              ; function to handle CALL SNDPLYON basic extension
 76+  559F              ; enables sound player
 77+  559F              ; _SNDPLYON
 78+  559F              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  559F              ; if not throws out of data error
 80+  559F              SNDPLYON:
 81+  559F 3A 52 55     	LD A, (MUSIC_INIT_STATUS)
 82+  55A2 B7           	OR A
 83+  55A3 20 05        	JR NZ, .L1
 84+  55A5              	; player not initialized, throw error
 85+  55A5 1E 04        	LD E, 04 ; Out of DATA
 86+  55A7 C3 20 60     	JP THROW_ERROR
 87+  55AA              .L1:
 88+  55AA 32 54 55     	LD (SOUND_ENABLED), A
 89+  55AD              	; disable key click
 90+  55AD AF           	XOR A
 91+  55AE 32 DB F3     	LD (CLIKSW), A
 92+  55B1 C9           	RET
 93+  55B2              ; *******************************************************************************************************
 94+  55B2
 95+  55B2              ; *******************************************************************************************************
 96+  55B2              ; function to handle CALL SNDPLYOFF basic extension
 97+  55B2              ; disables sound player
 98+  55B2              ; _SNDPLYOFF
 99+  55B2              ; sets SOUND_ENABLED variable to 0
100+  55B2              ; calls AKG to stop music and SFX on all channels if initialized
101+  55B2              SNDPLYOFF:
102+  55B2 3A 54 55     	LD A, (SOUND_ENABLED)
103+  55B5 B7           	OR A
104+  55B6 C8           	RET Z ; already stopped
105+  55B7 AF           	XOR A
106+  55B8 32 54 55     	LD (SOUND_ENABLED), A
107+  55BB E5           	PUSH HL
108+  55BC CD 21 42     	CALL PLY_AKG_STOP
109+  55BF 3A 53 55     	LD A, (SFX_INIT_STATUS)
110+  55C2 B7           	OR A
111+  55C3 28 0E        	JR Z, .EXIT ; SFX not in use
112+  55C5 AF           	XOR A
113+  55C6 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  55C9 3E 01        	LD A, 1
115+  55CB CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  55CE 3E 02        	LD A, 2
117+  55D0 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  55D3              .EXIT:
119+  55D3 E1           	POP HL
120+  55D4 C9           	RET
121+  55D5              ; *******************************************************************************************************
122+  55D5
123+  55D5              ; *******************************************************************************************************
124+  55D5              ; function to handle CALL SNDSFX basic extension
125+  55D5              ; plays a sound effect
126+  55D5              ; _SNDSFX ( BYTE sfx_number, >0
127+  55D5              ;			BYTE channel, = 0,1 or 2
128+  55D5              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  55D5              ; will put ram in page 0 also, page 1 is already there
130+  55D5              ; if sound off throws illegal function call
131+  55D5              ; if sfx not initialized, throws out of data
132+  55D5              SNDSFX:
133+  55D5              	; opening (
134+  55D5 CD 00 60     	CALL CHKCHAR
135+  55D8 28           	DB '('
136+  55D9              	; get sfx_number
137+  55D9 DD 21 1C 52  	LD IX, GETBYT
138+  55DD CD 59 01     	CALL CALBAS
139+  55E0 D5           	PUSH DE
140+  55E1              	; comma
141+  55E1 CD 00 60     	CALL CHKCHAR
142+  55E4 2C           	DB ','
143+  55E5              	; get sfx address
144+  55E5 DD 21 1C 52  	LD IX, GETBYT
145+  55E9 CD 59 01     	CALL CALBAS
146+  55EC D5           	PUSH DE
147+  55ED              	; comma
148+  55ED CD 00 60     	CALL CHKCHAR
149+  55F0 2C           	DB ','
150+  55F1              	; get inverted volume
151+  55F1 DD 21 1C 52  	LD IX, GETBYT
152+  55F5 CD 59 01     	CALL CALBAS
153+  55F8 D5           	PUSH DE
154+  55F9              	; ending )
155+  55F9 CD 00 60     	CALL CHKCHAR
156+  55FC 29           	DB ')'
157+  55FD
158+  55FD 3A 54 55     	LD A, (SOUND_ENABLED)
159+  5600 B7           	OR A
160+  5601 20 05        	JR NZ, .L1
161+  5603              	; sound disabled, throw illegal function call
162+  5603 1E 05        	LD E, 5
163+  5605 C3 20 60     	JP THROW_ERROR
164+  5608              .L1:
165+  5608 3A 53 55     	LD A, (SFX_INIT_STATUS)
166+  560B B7           	OR A
167+  560C 20 05        	JR NZ, .L2
168+  560E              	; sfx data not initialized, throw out of data
169+  560E 1E 04        	LD E, 4
170+  5610 C3 20 60     	JP THROW_ERROR
171+  5613              .L2:
172+  5613              	; pop  parameters and store away for later
173+  5613 D1           	POP DE ; inverted volume
174+  5614 43           	LD B, E
175+  5615 D1           	POP DE ; channel
176+  5616 4B           	LD C, E
177+  5617 D1           	POP DE
178+  5618 7B           	LD A, E
179+  5619 08           	EX AF, AF'
180+  561A E5           	PUSH HL ; basic text location
181+  561B D9           	EXX
182+  561C FD 21 23 56  	LD IY, .RET
183+  5620 C3 B3 5F     	JP ENABLE_PAGE0
184+  5623              .RET:
185+  5623 D9           	EXX
186+  5624 08           	EX AF, AF'
187+  5625 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  5628
189+  5628 D1               POP DE
190+  5629 C1               POP BC
191+  562A CD 2A 5F         CALL RESTORE_PAGE_INFO
192+  562D
193+  562D E1           	POP HL
194+  562E C9           	RET
195+  562F              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
129   562F               ENDIF
130   562F
131   562F               IF (VRAM_CMDS == 1)
132   562F               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  562F              ; *******************************************************************************************************
  2+  562F              ; function to handle CALL FILVRM basic extension
  3+  562F              ; FILVRM ( INT offset,
  4+  562F              ;		   INT count,
  5+  562F              ;		   BYTE value,
  6+  562F              ;		   BYTE wait_vsync) >0 = true
  7+  562F              ; wait_vsync will issue HALT before copying
  8+  562F              FILVRM:
  9+  562F              	; opening (
 10+  562F CD 00 60     	CALL CHKCHAR
 11+  5632 28           	DB '('
 12+  5633              	; get offset address
 13+  5633 DD 21 2F 54  	LD IX, FRMQNT
 14+  5637 CD 59 01     	CALL CALBAS
 15+  563A D5           	PUSH DE
 16+  563B              	; comma
 17+  563B CD 00 60     	CALL CHKCHAR
 18+  563E 2C           	DB ','
 19+  563F              	; get count
 20+  563F DD 21 2F 54  	LD IX, FRMQNT
 21+  5643 CD 59 01     	CALL CALBAS
 22+  5646 D5           	PUSH DE
 23+  5647              	; comma
 24+  5647 CD 00 60     	CALL CHKCHAR
 25+  564A 2C           	DB ','
 26+  564B              	; get value
 27+  564B DD 21 1C 52  	LD IX, GETBYT
 28+  564F CD 59 01     	CALL CALBAS
 29+  5652 F5           	PUSH AF
 30+  5653              	; comma
 31+  5653 CD 00 60     	CALL CHKCHAR
 32+  5656 2C           	DB ','
 33+  5657              	; get vsync wait
 34+  5657 DD 21 1C 52  	LD IX, GETBYT
 35+  565B CD 59 01     	CALL CALBAS
 36+  565E F5           	PUSH AF
 37+  565F              	; ending )
 38+  565F CD 00 60     	CALL CHKCHAR
 39+  5662 29           	DB ')'
 40+  5663
 41+  5663 FB               EI
 42+  5664              	; save position
 43+  5664 E5           	PUSH HL
 44+  5665 DD E1        	POP IX
 45+  5667
 46+  5667              	; syntax ok
 47+  5667              	; wait for vsync if needed
 48+  5667 F1           	POP AF
 49+  5668 B7           	OR A
 50+  5669 28 01        	JR Z, .L1
 51+  566B 76           	HALT
 52+  566C
 53+  566C              .L1:
 54+  566C 3E 01        	LD A,1
 55+  566E 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  5671 F1               POP AF ; value
 57+  5672 C1               POP BC ; count
 58+  5673 E1               POP HL ; offset
 59+  5674 CD 56 00         CALL BIOS_FILVRM
 60+  5677 AF           	XOR A
 61+  5678 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  567B
 63+  567B              .L3:
 64+  567B DD E5        	PUSH IX
 65+  567D E1           	POP HL
 66+  567E C9           	RET
 67+  567F              ; *******************************************************************************************************
 68+  567F
 69+  567F              ; *******************************************************************************************************
 70+  567F              ; function to handle CALL MEMVRM basic extension
 71+  567F              ; copies from RAM to VRAM
 72+  567F              ; _MEMVRM ( INT source,
 73+  567F              ;			INT destination,
 74+  567F              ;			INT count,
 75+  567F              ;			BYTE wait_vsync) >0 = true
 76+  567F              ; will put ram in page 0 also, page 1 is already there
 77+  567F              ; wait_vsync will issue HALT before copying
 78+  567F              MEMVRM:
 79+  567F              	; opening (
 80+  567F CD 00 60     	CALL CHKCHAR
 81+  5682 28           	DB '('
 82+  5683              	; get source address
 83+  5683 DD 21 2F 54  	LD IX, FRMQNT
 84+  5687 CD 59 01     	CALL CALBAS
 85+  568A D5           	PUSH DE
 86+  568B              	; comma
 87+  568B CD 00 60     	CALL CHKCHAR
 88+  568E 2C           	DB ','
 89+  568F              	; get destination address
 90+  568F DD 21 2F 54  	LD IX, FRMQNT
 91+  5693 CD 59 01     	CALL CALBAS
 92+  5696 D5           	PUSH DE
 93+  5697              	; comma
 94+  5697 CD 00 60     	CALL CHKCHAR
 95+  569A 2C           	DB ','
 96+  569B              	; get length
 97+  569B DD 21 2F 54  	LD IX, FRMQNT
 98+  569F CD 59 01     	CALL CALBAS
 99+  56A2 D5           	PUSH DE
100+  56A3              	; comma
101+  56A3 CD 00 60     	CALL CHKCHAR
102+  56A6 2C           	DB ','
103+  56A7              	; get vsync wait
104+  56A7 DD 21 1C 52  	LD IX, GETBYT
105+  56AB CD 59 01     	CALL CALBAS
106+  56AE F5           	PUSH AF
107+  56AF              	; ending )
108+  56AF CD 00 60     	CALL CHKCHAR
109+  56B2 29           	DB ')'
110+  56B3
111+  56B3                  ; save position in BASIC text
112+  56B3 E5           	PUSH HL
113+  56B4 DD E1        	POP IX
114+  56B6
115+  56B6 F1           	POP AF ; wait vsync
116+  56B7 B7           	OR A
117+  56B8 28 03        	JR Z, .L1
118+  56BA FB               EI
119+  56BB 76           	HALT
120+  56BC F3           	DI
121+  56BD              .L1:
122+  56BD              	; pop LDIR parameters and store away for later
123+  56BD C1           	POP BC ; count
124+  56BE D1           	POP DE ; vram destination
125+  56BF E1           	POP HL ; ram source
126+  56C0 D9           	EXX
127+  56C1 FD 21 C8 56   	LD IY, .RET
128+  56C5 C3 B3 5F     	JP ENABLE_PAGE0
129+  56C8              .RET:
130+  56C8 FB           	EI
131+  56C9 D9           	EXX
132+  56CA 3E 01        	LD A,1
133+  56CC 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  56CF CD DF 56     	CALL .LDIRVM
135+  56D2 AF           	XOR A
136+  56D3 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  56D6 D1               POP DE
138+  56D7 C1               POP BC
139+  56D8 CD 2A 5F         CALL RESTORE_PAGE_INFO
140+  56DB DD E5        	PUSH IX
141+  56DD E1           	POP HL
142+  56DE C9           	RET
143+  56DF
144+  56DF              .LDIRVM:
145+  56DF EB           	EX DE, HL
146+  56E0 F3           	DI
147+  56E1 CD DA 5E     	CALL SETWRT_LOCAL
148+  56E4 FB           	EI
149+  56E5 EB           	EX DE, HL
150+  56E6 78           	LD A, B
151+  56E7 B7           	OR A
152+  56E8 28 0D        	JR Z, .L3
153+  56EA C5           	PUSH BC
154+  56EB 0E 98        	LD C, #98
155+  56ED              .L2:
156+  56ED 50           	LD D, B
157+  56EE 06 00        	LD B, 0
158+  56F0 CD E7 5E     	CALL BBYTECOPY_NO_C
159+  56F3 42           	LD B, D
160+  56F4 10 F7        	DJNZ .L2
161+  56F6 C1           	POP BC
162+  56F7              .L3:
163+  56F7 79           	LD A, C
164+  56F8 B7           	OR A
165+  56F9 C8           	RET Z
166+  56FA 41           	LD B, C
167+  56FB C3 E5 5E     	JP BBYTECOPY
168+  56FE              ; *******************************************************************************************************
169+  56FE
170+  56FE              ; *******************************************************************************************************
171+  56FE              ; function to handle CALL VRMMEM basic extension
172+  56FE              ; copies from RAM to VRAM
173+  56FE              ; _VRMMEM ( INT source,
174+  56FE              ;			INT destination,
175+  56FE              ;			INT count
176+  56FE              ; will put ram in page 0 also, page 1 is already there
177+  56FE              VRMMEM:
178+  56FE              	; opening (
179+  56FE CD 00 60     	CALL CHKCHAR
180+  5701 28           	DB '('
181+  5702              	; get source address
182+  5702 DD 21 2F 54  	LD IX, FRMQNT
183+  5706 CD 59 01     	CALL CALBAS
184+  5709 D5           	PUSH DE
185+  570A              	; comma
186+  570A CD 00 60     	CALL CHKCHAR
187+  570D 2C           	DB ','
188+  570E              	; get destination address
189+  570E DD 21 2F 54  	LD IX, FRMQNT
190+  5712 CD 59 01     	CALL CALBAS
191+  5715 D5           	PUSH DE
192+  5716              	; comma
193+  5716 CD 00 60     	CALL CHKCHAR
194+  5719 2C           	DB ','
195+  571A              	; get length
196+  571A DD 21 2F 54  	LD IX, FRMQNT
197+  571E CD 59 01     	CALL CALBAS
198+  5721 D5           	PUSH DE
199+  5722              	; ending )
200+  5722 CD 00 60     	CALL CHKCHAR
201+  5725 29           	DB ')'
202+  5726
203+  5726                  ; save position in BASIC text
204+  5726 E5           	PUSH HL
205+  5727 DD E1        	POP IX
206+  5729
207+  5729 C1           	POP BC ; count
208+  572A D1           	POP DE ; destination
209+  572B E1           	POP HL ; source
210+  572C D9           	EXX
211+  572D FD 21 34 57  	LD IY, .RET
212+  5731 C3 B3 5F     	JP ENABLE_PAGE0
213+  5734              .RET:
214+  5734 FB           	EI
215+  5735 D9           	EXX
216+  5736 3E 01        	LD A,1
217+  5738 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  573B CD 4B 57     	CALL .LDIRMV
219+  573E AF           	XOR A
220+  573F 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  5742 D1               POP DE
222+  5743 C1               POP BC
223+  5744 CD 2A 5F         CALL RESTORE_PAGE_INFO
224+  5747 DD E5        	PUSH IX
225+  5749 E1           	POP HL
226+  574A C9           	RET
227+  574B
228+  574B              .LDIRMV:
229+  574B              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  574B 7D           	LD	A, L
231+  574C F3           	DI
232+  574D D3 99        	OUT	(099H), A
233+  574F 7C           	LD	A, H
234+  5750 E6 3F        	AND	03FH
235+  5752 D3 99        	OUT	(099H), A
236+  5754 FB           	EI
237+  5755              	;EX (SP), HL
238+  5755              	;EX (SP), HL
239+  5755              	;NOP
240+  5755              	;NOP
241+  5755              .L4:
242+  5755 DB 98            IN A, (#98)
243+  5757 12           	LD (DE), A
244+  5758 13               INC DE
245+  5759 0B               DEC BC
246+  575A 79               LD A, C
247+  575B B0               OR B
248+  575C 20 F7            JR NZ, .L4
249+  575E C9               RET
250+  575F              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
133   575F               ENDIF
134   575F
135   575F               IF (GENCAL_CMD == 1)
136   575F               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  575F              ; *******************************************************************************************************
  2+  575F              ; function to handle CALL GENCAL basic extension
  3+  575F              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  575F              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  575F              ; output values of registers will also be stored at reg_list_ptr
  6+  575F              GENCAL_VAR_SP:
  7+  575F 00 00            DW 0
  8+  5761              GENCAL_VAR_SP2:
  9+  5761 00 00            DW 0
 10+  5763              GENCAL:
 11+  5763              	; opening (
 12+  5763 CD 00 60     	CALL CHKCHAR
 13+  5766 28           	DB '('
 14+  5767              	; get function address
 15+  5767 DD 21 2F 54  	LD IX, FRMQNT
 16+  576B CD 59 01     	CALL CALBAS
 17+  576E D5           	PUSH DE
 18+  576F              	; comma
 19+  576F CD 00 60     	CALL CHKCHAR
 20+  5772 2C           	DB ','
 21+  5773              	; get pointer to register list
 22+  5773 3E 02            LD A,2
 23+  5775 06 01            LD B,1
 24+  5777 11 00 05         LD DE,#0500
 25+  577A CD 27 60         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  577D C5           	PUSH BC
 27+  577E              	; ending )
 28+  577E CD 00 60     	CALL CHKCHAR
 29+  5781 29           	DB ')'
 30+  5782
 31+  5782              	; save BASIC token position
 32+  5782 E5           	PUSH HL
 33+  5783 D9               EXX
 34+  5784 E1           	POP HL ; HL'=next basic token
 35+  5785 D9               EXX
 36+  5786
 37+  5786 E1               POP HL ; get pointer to register values
 38+  5787 F3           	DI
 39+  5788 ED 73 5F 57      LD (GENCAL_VAR_SP), SP
 40+  578C F9               LD SP, HL
 41+  578D F1               POP AF
 42+  578E C1               POP BC
 43+  578F D1               POP DE
 44+  5790 E1               POP HL
 45+  5791 DD E1            POP IX
 46+  5793 FD E1            POP IY
 47+  5795 D9               EXX
 48+  5796 ED 73 61 57      LD (GENCAL_VAR_SP2), SP
 49+  579A ED 7B 5F 57      LD SP, (GENCAL_VAR_SP)
 50+  579E FB               EI
 51+  579F D1               POP DE ; get function to call
 52+  57A0 E5               PUSH HL
 53+  57A1 CD BC 57         CALL .EXXDECALL
 54+  57A4 F3               DI
 55+  57A5 ED 73 5F 57      LD (GENCAL_VAR_SP), SP
 56+  57A9 ED 7B 61 57      LD SP, (GENCAL_VAR_SP2)
 57+  57AD FD E5            PUSH IY
 58+  57AF DD E5            PUSH IX
 59+  57B1 E5               PUSH HL
 60+  57B2 D5               PUSH DE
 61+  57B3 C5               PUSH BC
 62+  57B4 F5               PUSH AF
 63+  57B5 ED 7B 5F 57      LD SP, (GENCAL_VAR_SP)
 64+  57B9 FB               EI
 65+  57BA E1               POP HL
 66+  57BB C9           	RET
 67+  57BC
 68+  57BC              .EXXDECALL:
 69+  57BC D5               PUSH DE
 70+  57BD D9               EXX
 71+  57BE C9               RET
 72+  57BF              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
137   57BF               ENDIF
138   57BF
139   57BF               IF (BOX_CMDS == 1)
140   57BF               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  57BF              ; *******************************************************************************************************
  2+  57BF              ; generic function to implement rectangle data copy
  3+  57BF              ; should be modified to call appropriate function for memory or vram
  4+  57BF              ; input IX=pointer to following structure
  5+  57BF              ; +00 source data pointer
  6+  57BF              ; +02 num bytes in a row
  7+  57BF              ; +04 number of rows
  8+  57BF              ; +06 source add-to value till next row
  9+  57BF              ; +08 destination address
 10+  57BF              ; +10 destination add-to value till next row
 11+  57BF              ; modifies AF, BC, DE, HL
 12+  57BF              RECTANGLE_COPY:
 13+  57BF DD 6E 00     	LD L, (IX+0)
 14+  57C2 DD 66 01     	LD H, (IX+1) ; source address
 15+  57C5 DD 5E 08     	LD E, (IX+8)
 16+  57C8 DD 56 09     	LD D, (IX+9) ; destination
 17+  57CB DD 46 04     	LD B, (IX+4) ; row number
 18+  57CE              .L1:
 19+  57CE C5           	PUSH BC
 20+  57CF E5           		PUSH HL
 21+  57D0 D5           			PUSH DE
 22+  57D1 DD 4E 02     				LD C, (IX+2)
 23+  57D4 DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  57D7              .CALL1:
 25+  57D7 CD 00 00     				CALL 0 ; set destination address from DE
 26+  57DA              .CALL2:
 27+  57DA CD 00 00     				CALL 0 ; copy data fn
 28+  57DD E1           			POP HL
 29+  57DE DD 4E 0A     			LD C, (IX+10)
 30+  57E1 DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  57E4 09           			ADD HL, BC
 32+  57E5 EB           			EX DE, HL
 33+  57E6 E1           		POP HL
 34+  57E7 DD 4E 06     		LD C, (IX+6)
 35+  57EA DD 46 07     		LD B, (IX+7) ; src add-to
 36+  57ED 09           		ADD HL, BC
 37+  57EE C1           	POP BC
 38+  57EF 10 DD        	DJNZ .L1
 39+  57F1 C9           	RET
 40+  57F2              ; *******************************************************************************************************
 41+  57F2
 42+  57F2              ; *******************************************************************************************************
 43+  57F2              ; function to handle CALL BOXMEMCPY basic extension
 44+  57F2              ; copies data with window like boundaries within ram
 45+  57F2              ; BOXMEMCPY ( INT source data pointer,
 46+  57F2              ;			  INT source number of bytes in a row,
 47+  57F2              ;			  INT number of rows,
 48+  57F2              ;			  INT source add-to value till next row,
 49+  57F2              ; 			  INT destination pointer,
 50+  57F2              ;			  INT destination add-to value till next row )
 51+  57F2              ; request_data_ptr described in RECTANGLE_COPY
 52+  57F2              ; will put ram in page 0 also, page 1 is already there
 53+  57F2              BOXMEMCPY:
 54+  57F2 11 FC 57     	LD DE,BOXMEMCPY.RET
 55+  57F5 ED 53 70 58  	LD (BOXCOMMON.ADDR+2), DE
 56+  57F9 C3 0F 58     	JP BOXCOMMON
 57+  57FC              .RET:
 58+  57FC FB           	EI
 59+  57FD              	; set RAM functions to call
 60+  57FD 21 00 00     	LD HL, 0
 61+  5800 22 D7 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 62+  5803 22 D9 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 63+  5806 21 ED B0     	LD HL, #B0ED ; LDIR
 64+  5809 22 DB 57     	LD (RECTANGLE_COPY.CALL1+4), HL
 65+  580C C3 75 58     	JP BOXCOMMON.CALL
 66+  580F              ; *******************************************************************************************************
 67+  580F
 68+  580F              ; *******************************************************************************************************
 69+  580F              ; common parts of BOX commands
 70+  580F              BOXCOMMON:
 71+  580F              	; opening (
 72+  580F CD 00 60     	CALL CHKCHAR
 73+  5812 28           	DB '('
 74+  5813              	; get source data pointer
 75+  5813 DD 21 2F 54  	LD IX, FRMQNT
 76+  5817 CD 59 01     	CALL CALBAS
 77+  581A ED 53 3E 5D  	LD (BLIT_STRUCT+0), DE
 78+  581E              	; comma
 79+  581E CD 00 60     	CALL CHKCHAR
 80+  5821 2C           	DB ','
 81+  5822              	; source number of bytes in a row
 82+  5822 DD 21 2F 54  	LD IX, FRMQNT
 83+  5826 CD 59 01     	CALL CALBAS
 84+  5829 ED 53 40 5D  	LD (BLIT_STRUCT+2), DE
 85+  582D              	; comma
 86+  582D CD 00 60     	CALL CHKCHAR
 87+  5830 2C           	DB ','
 88+  5831              	; number of rows
 89+  5831 DD 21 2F 54  	LD IX, FRMQNT
 90+  5835 CD 59 01     	CALL CALBAS
 91+  5838 ED 53 42 5D  	LD (BLIT_STRUCT+4), DE
 92+  583C              	; comma
 93+  583C CD 00 60     	CALL CHKCHAR
 94+  583F 2C           	DB ','
 95+  5840              	; source add-to value till next row
 96+  5840 DD 21 2F 54  	LD IX, FRMQNT
 97+  5844 CD 59 01     	CALL CALBAS
 98+  5847 ED 53 44 5D  	LD (BLIT_STRUCT+6), DE
 99+  584B              	; comma
100+  584B CD 00 60     	CALL CHKCHAR
101+  584E 2C           	DB ','
102+  584F              	; destination pointer
103+  584F DD 21 2F 54  	LD IX, FRMQNT
104+  5853 CD 59 01     	CALL CALBAS
105+  5856 ED 53 46 5D  	LD (BLIT_STRUCT+8), DE
106+  585A              	; comma
107+  585A CD 00 60     	CALL CHKCHAR
108+  585D 2C           	DB ','
109+  585E              	; destination add-to value till next row
110+  585E DD 21 2F 54  	LD IX, FRMQNT
111+  5862 CD 59 01     	CALL CALBAS
112+  5865 ED 53 48 5D  	LD (BLIT_STRUCT+10), DE
113+  5869              	; ending )
114+  5869 CD 00 60     	CALL CHKCHAR
115+  586C 29           	DB ')'
116+  586D
117+  586D E5           	PUSH HL ; save position in BASIC buffer
118+  586E              .ADDR:
119+  586E FD 21 00 00  	LD IY, 0
120+  5872 C3 B3 5F     	JP ENABLE_PAGE0
121+  5875              .CALL:
122+  5875 DD 21 3E 5D  	LD IX,BLIT_STRUCT
123+  5879 CD BF 57     	CALL RECTANGLE_COPY
124+  587C AF           	XOR A
125+  587D 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
126+  5880
127+  5880 D1               POP DE
128+  5881 C1               POP BC
129+  5882 CD 2A 5F         CALL RESTORE_PAGE_INFO
130+  5885
131+  5885 E1           	POP HL
132+  5886 C9           	RET
133+  5887              ; *******************************************************************************************************
134+  5887
135+  5887              ; *******************************************************************************************************
136+  5887              ; function to handle CALL BOXMEMVRM basic extension
137+  5887              ; copies data with window like boundaries from ram to Vram
138+  5887              ; BOXMEMVRM ( INT source data pointer,
139+  5887              ;			  INT source number of bytes in a row,
140+  5887              ;			  INT number of rows,
141+  5887              ;			  INT source add-to value till next row,
142+  5887              ; 			  INT destination pointer,
143+  5887              ;			  INT destination add-to value till next row )
144+  5887              ; request_data_ptr described in RECTANGLE_COPY
145+  5887              ; will put ram in page 0 also, page 1 is already there
146+  5887              BOXMEMVRM:
147+  5887 11 91 58     	LD DE,BOXMEMVRM.RET
148+  588A ED 53 70 58  	LD (BOXCOMMON.ADDR+2), DE
149+  588E C3 0F 58     	JP BOXCOMMON
150+  5891              .RET:
151+  5891 FB           	EI
152+  5892              	; set RAM functions to call
153+  5892 21 AC 58     	LD HL, .SETDEST
154+  5895 22 D8 57     	LD (RECTANGLE_COPY.CALL1+1), HL
155+  5898 21 B4 58     	LD HL, .COPYDATA
156+  589B 22 DB 57     	LD (RECTANGLE_COPY.CALL2+1), HL
157+  589E 3E CD        	LD A, #CD ; CALL
158+  58A0 32 D7 57     	LD (RECTANGLE_COPY.CALL1), A
159+  58A3 32 DA 57     	LD (RECTANGLE_COPY.CALL2), A
160+  58A6              	;LD A,1
161+  58A6 32 4F 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
162+  58A9 C3 75 58     	JP BOXCOMMON.CALL
163+  58AC              .SETDEST:
164+  58AC EB           	EX DE, HL
165+  58AD F3           	DI
166+  58AE CD DA 5E     	CALL SETWRT_LOCAL
167+  58B1 FB           	EI
168+  58B2 EB           	EX DE, HL
169+  58B3 C9           	RET
170+  58B4              .COPYDATA:
171+  58B4 41           	LD B, C
172+  58B5 C3 E5 5E     	JP BBYTECOPY
173+  58B8              ; *******************************************************************************************************
# file closed: asm\BOX.asm
141   58B8               ENDIF
142   58B8
143   58B8               IF (BLIT_CMDS == 1)
144   58B8               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  58B8              ; *******************************************************************************************************
  2+  58B8              ; function rotates mask and data of several characters and applies to background data
  3+  58B8              ; this handles x-shift from 0 to 4
  4+  58B8              ; contains self-modifying code that is set-up from external function
  5+  58B8              ; input HL=pointer to mask data
  6+  58B8              ; input HL'=pointer to character data
  7+  58B8              ; input DE=output buffer containing background data
  8+  58B8              ; input BC=DE+8
  9+  58B8              ; input A=number of characters to process
 10+  58B8              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  58B8              SHIFT04:
 12+  58B8 08           	EX AF, AF'
 13+  58B9 7E           	LD A, (HL) ; get mask
 14+  58BA D9           	EXX
 15+  58BB 57           	LD D, A
 16+  58BC 1E FF        	LD E, #FF
 17+  58BE 37           	SCF
 18+  58BF              .M1:
 19+  58BF 18 FE        	JR .M1 ; this is self-modifying part
 20+  58C1 CB 1A        	RR D
 21+  58C3 CB 1B        	RR E
 22+  58C5 CB 1A        	RR D
 23+  58C7 CB 1B        	RR E
 24+  58C9 CB 1A        	RR D
 25+  58CB CB 1B        	RR E
 26+  58CD CB 1A        	RR D
 27+  58CF CB 1B        	RR E
 28+  58D1
 29+  58D1 46           	LD B, (HL) ; get data
 30+  58D2 0E 00        	LD C, 0
 31+  58D4              .M2:
 32+  58D4 18 FE        	JR .M2 ; also self-modifying part
 33+  58D6 CB 38        	SRL B
 34+  58D8 CB 19        	RR C
 35+  58DA CB 38        	SRL B
 36+  58DC CB 19        	RR C
 37+  58DE CB 38        	SRL B
 38+  58E0 CB 19        	RR C
 39+  58E2 CB 38        	SRL B
 40+  58E4 CB 19        	RR C
 41+  58E6
 42+  58E6 D9           	EXX
 43+  58E7 1A           	LD A, (DE) ; background
 44+  58E8 D9           	EXX
 45+  58E9 A2           	AND D
 46+  58EA B0           	OR B
 47+  58EB D9           	EXX
 48+  58EC 12           	LD (DE), A
 49+  58ED
 50+  58ED 0A           	LD A, (BC)
 51+  58EE D9           	EXX
 52+  58EF A3           	AND E
 53+  58F0 B1           	OR C
 54+  58F1 23           	INC HL
 55+  58F2 D9           	EXX
 56+  58F3 02           	LD (BC), A
 57+  58F4
 58+  58F4 23           	INC HL
 59+  58F5 13           	INC DE
 60+  58F6 03           	INC BC
 61+  58F7
 62+  58F7 08           	EX AF, AF'
 63+  58F8 3D           	DEC A
 64+  58F9 C2 B8 58     	JP NZ, SHIFT04
 65+  58FC C9           	RET
 66+  58FD              ; *******************************************************************************************************
 67+  58FD
 68+  58FD              ; *******************************************************************************************************
 69+  58FD              ; function rotates mask and data of several characters and applies to background data
 70+  58FD              ; this handles x-shift from 5 to 8
 71+  58FD              ; contains self-modifying code that is set-up from external function
 72+  58FD              ; input HL=pointer to mask data
 73+  58FD              ; input HL'=pointer to character data
 74+  58FD              ; input DE=output buffer containing background data
 75+  58FD              ; input BC=DE+8
 76+  58FD              ; input A=number of characters to process
 77+  58FD              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  58FD              SHIFT58:
 79+  58FD 08           	EX AF, AF'
 80+  58FE 7E           	LD A, (HL) ; get mask
 81+  58FF D9           	EXX
 82+  5900 57           	LD D, A
 83+  5901 1E FF        	LD E, #FF
 84+  5903 37           	SCF
 85+  5904              .M1:
 86+  5904 18 FE        	JR .M1 ; this is self-modifying part
 87+  5906 CB 12        	RL D
 88+  5908 CB 13        	RL E
 89+  590A CB 12        	RL D
 90+  590C CB 13        	RL E
 91+  590E CB 12        	RL D
 92+  5910 CB 13        	RL E
 93+  5912
 94+  5912 46           	LD B, (HL)
 95+  5913 0E 00        	LD C, 0
 96+  5915              .M2:
 97+  5915 18 FE        	JR .M2 ; also self-modifying part
 98+  5917 CB 20        	SLA B
 99+  5919 CB 11        	RL C
100+  591B CB 20        	SLA B
101+  591D CB 11        	RL C
102+  591F CB 20        	SLA B
103+  5921 CB 11        	RL C
104+  5923
105+  5923 D9           	EXX
106+  5924 1A           	LD A, (DE) ; background
107+  5925 D9           	EXX
108+  5926 A3           	AND E
109+  5927 B1           	OR C
110+  5928 D9           	EXX
111+  5929 12           	LD (DE), A
112+  592A
113+  592A 0A           	LD A, (BC)
114+  592B D9           	EXX
115+  592C A2           	AND D
116+  592D B0           	OR B
117+  592E 23           	INC HL
118+  592F D9           	EXX
119+  5930 02           	LD (BC), A
120+  5931
121+  5931 23           	INC HL
122+  5932 13           	INC DE
123+  5933 03           	INC BC
124+  5934
125+  5934 08           	EX AF, AF'
126+  5935 3D           	DEC A
127+  5936 C2 FD 58     	JP NZ, SHIFT58
128+  5939 C9           	RET
129+  593A              ; *******************************************************************************************************
130+  593A
131+  593A              ; *******************************************************************************************************
132+  593A              ; routine that shifts one row of characters
133+  593A              ; contains self-modifying code that is set-up from external function
134+  593A              ; input HL=pointer to mask data
135+  593A              ; input HL'=pointer to character data
136+  593A              ; input DE=output buffer containing background data
137+  593A              ; input A=number of characters to process
138+  593A              ; input IX=pointer to structure describing input data
139+  593A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  593A              SHIFT_ROW:
141+  593A F5           	PUSH AF
142+  593B ED 53 3A 5D  		LD (BLIT_TMP1), DE
143+  593F E5           		PUSH HL
144+  5940 CD 83 59     			CALL .ADDYSHIFT
145+  5943 E1           		POP HL
146+  5944 ED 53 3C 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  5948              .L1:
148+  5948 3E 08        		LD A, 8
149+  594A DD 96 02     		SUB (IX+2) ; y shift
150+  594D              .CALL1:
151+  594D CD 00 00     		CALL 0
152+  5950 DD 7E 02     		LD A, (IX+2); y shift
153+  5953 B7           		OR A
154+  5954 28 26        		JR Z, .DONE
155+  5956 ED 5B 3A 5D  		LD DE, (BLIT_TMP1)
156+  595A E5           		PUSH HL
157+  595B CD 91 59     			CALL .DETONEXTROW
158+  595E E1           		POP HL
159+  595F              .CALL2:
160+  595F CD 00 00     		CALL 0
161+  5962 ED 5B 3A 5D  		LD DE, (BLIT_TMP1)
162+  5966 E5           		PUSH HL
163+  5967 CD 8B 59     			CALL .ADD8
164+  596A E1           		POP HL
165+  596B ED 53 3A 5D  		LD (BLIT_TMP1), DE
166+  596F ED 5B 3C 5D  		LD DE, (BLIT_TMP2)
167+  5973 E5           		PUSH HL
168+  5974 CD 8B 59     			CALL .ADD8
169+  5977 E1           		POP HL
170+  5978 ED 53 3C 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  597C              .DONE:
172+  597C F1           	POP AF
173+  597D 3D           	DEC A
174+  597E C8           	RET Z
175+  597F F5           	PUSH AF
176+  5980 C3 48 59     	JP .L1
177+  5983              .ADDYSHIFT:
178+  5983 EB           	EX DE, HL
179+  5984 16 00        	LD D, 0
180+  5986 DD 5E 02     	LD E, (IX+2); y shift
181+  5989 18 0C        	JR .MOVDEBC
182+  598B              .ADD8:
183+  598B 21 08 00     	LD HL, 8
184+  598E C3 97 59     	JP .MOVDEBC
185+  5991              .DETONEXTROW:
186+  5991 DD 6E 06     	LD L, (IX+6)
187+  5994 DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5997              .MOVDEBC:
189+  5997 19           	ADD HL, DE
190+  5998 54           	LD D, H
191+  5999 5D           	LD E, L
192+  599A 01 08 00     	LD BC, 8
193+  599D 09           	ADD HL, BC
194+  599E 44           	LD B, H
195+  599F 4D           	LD C, L
196+  59A0 C9           	RET
197+  59A1              ; *******************************************************************************************************
198+  59A1
199+  59A1              ; *******************************************************************************************************
200+  59A1              ; function rotates mask and character data and applies it to background
201+  59A1              ; input IX=pointer to structure describing input data
202+  59A1              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  59A1              ; +2  DW vertical shift count 0-7 (low byte used)
204+  59A1              ; +4  DW background data start;
205+  59A1              ; +6  DW background add to value to next row of background data
206+  59A1              ; +8  DW mask data start;
207+  59A1              ; +10  DW character data start;
208+  59A1              ; +12 DW character&mask add to value to next row of data
209+  59A1              ; +14 DW columns (low byte used)
210+  59A1              ; +16 DW rows (low byte used)
211+  59A1              SHIFT_MERGE_CHARACTER:
212+  59A1 DD 7E 00     	LD A, (IX) ; shift
213+  59A4 FE 05        	CP 5
214+  59A6 38 25        	JR C, .RIGHT
215+  59A8              	; shifts 5-7, use rotate towards left 1-3
216+  59A8 21 FD 58     	LD HL, SHIFT58
217+  59AB 22 4E 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  59AE 22 60 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  59B1 D6 05        	SUB 5
220+  59B3 28 0D        	JR Z, .L1
221+  59B5 87           	ADD A, A
222+  59B6 87           	ADD A, A
223+  59B7 67           	LD H, A
224+  59B8 2E 18        	LD L, #18 ; JR opcode
225+  59BA 22 04 59     	LD (SHIFT58.M1), HL
226+  59BD 22 15 59     	LD (SHIFT58.M2), HL
227+  59C0 18 32        	JR .DO
228+  59C2              .L1:
229+  59C2 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  59C5 22 04 59     	LD (SHIFT58.M1), HL
231+  59C8 22 15 59     	LD (SHIFT58.M2), HL
232+  59CB 18 27        	JR .DO
233+  59CD              .RIGHT:
234+  59CD              	; shifts 0-4, rotate towards right
235+  59CD 21 B8 58     	LD HL, SHIFT04
236+  59D0 22 4E 59     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  59D3 22 60 59     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  59D6 FE 04        	CP 4
239+  59D8 28 11        	JR Z, .R1
240+  59DA D6 04        	SUB 4
241+  59DC ED 44        	NEG
242+  59DE 87           	ADD A, A
243+  59DF 87           	ADD A, A
244+  59E0 67           	LD H, A
245+  59E1 2E 18        	LD L, #18 ; JR opcode
246+  59E3 22 BF 58     	LD (SHIFT04.M1), HL
247+  59E6 22 D4 58     	LD (SHIFT04.M2), HL
248+  59E9 18 09        	JR .DO
249+  59EB              .R1:
250+  59EB 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  59EE 22 BF 58     	LD (SHIFT04.M1), HL
252+  59F1 22 D4 58     	LD (SHIFT04.M2), HL
253+  59F4              .DO:
254+  59F4 DD 46 10     	LD B, (IX+16) ; rows
255+  59F7 DD 6E 08     	LD L, (IX+8)
256+  59FA DD 66 09     	LD H, (IX+9) ; mask data
257+  59FD DD 5E 04     	LD E, (IX+4)
258+  5A00 DD 56 05     	LD D, (IX+5) ; background data
259+  5A03 D9           	EXX
260+  5A04 DD 6E 0A     	LD L, (IX+10)
261+  5A07 DD 66 0B     	LD H, (IX+11) ; character data
262+  5A0A D9           	EXX
263+  5A0B              .LOOP:
264+  5A0B C5           	PUSH BC
265+  5A0C E5           		PUSH HL
266+  5A0D D5           			PUSH DE
267+  5A0E D9           				EXX
268+  5A0F E5           				PUSH HL
269+  5A10 D9           					EXX
270+  5A11 DD 7E 0E     					LD A, (IX+14) ; columns
271+  5A14              .CALL:
272+  5A14 CD 3A 59     					CALL SHIFT_ROW
273+  5A17 E1           				POP HL
274+  5A18 DD 5E 0C     				LD E, (IX+12)
275+  5A1B DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  5A1E 19           				ADD HL, DE
277+  5A1F D9           				EXX
278+  5A20 E1           			POP HL
279+  5A21 DD 5E 06     			LD E, (IX+6)
280+  5A24 DD 56 07     			LD D, (IX+7) ; background to next row
281+  5A27 19           			ADD HL, DE
282+  5A28 EB           			EX DE, HL
283+  5A29 E1           		POP HL
284+  5A2A DD 4E 0C     		LD C, (IX+12)
285+  5A2D DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  5A30 09           		ADD HL, BC
287+  5A31 C1           	POP BC
288+  5A32 10 D7        	DJNZ .LOOP
289+  5A34 C9           	RET
290+  5A35              ; *******************************************************************************************************
291+  5A35
292+  5A35               IFNDEF CMDS_WITH_PARAMETERS
293+  5A35 ~            ; *******************************************************************************************************
294+  5A35 ~            ; function to handle CALL BLIT basic extension
295+  5A35 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  5A35 ~            ; fuses with background data and applies vertical shift too
297+  5A35 ~            ; BLIT ( INT request_data_ptr )
298+  5A35 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  5A35 ~            ; will put ram in page 0 also, page 1 is already there
300+  5A35 ~            BLIT:
301+  5A35 ~            	; opening (
302+  5A35 ~            	CALL CHKCHAR
303+  5A35 ~            	DB '('
304+  5A35 ~            	; get pointer to request struct
305+  5A35 ~            	LD IX, FRMQNT
306+  5A35 ~            	CALL CALBAS
307+  5A35 ~            	PUSH DE
308+  5A35 ~            	; ending )
309+  5A35 ~            	CALL CHKCHAR
310+  5A35 ~            	DB ')'
311+  5A35 ~
312+  5A35 ~            	POP IX ; pointer to request struct
313+  5A35 ~
314+  5A35 ~            	PUSH HL ; save position in BASIC buffer
315+  5A35 ~
316+  5A35 ~            	LD IY, .RET
317+  5A35 ~            	JP ENABLE_PAGE0
318+  5A35 ~            .RET:
319+  5A35 ~            	EI
320+  5A35 ~            	CALL SHIFT_MERGE_CHARACTER
321+  5A35 ~
322+  5A35 ~                POP DE
323+  5A35 ~                POP BC
324+  5A35 ~                CALL RESTORE_PAGE_INFO
325+  5A35 ~
326+  5A35 ~            	POP HL
327+  5A35 ~            	RET
328+  5A35 ~            ; *******************************************************************************************************
329+  5A35               ENDIF
330+  5A35
331+  5A35               IFDEF CMDS_WITH_PARAMETERS
332+  5A35              ; *******************************************************************************************************
333+  5A35              ; function to handle CALL BLIT basic extension
334+  5A35              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  5A35              ; fuses with background data and applies vertical shift too
336+  5A35              ; in form without pointers
337+  5A35              ; BLIT ( INT x,
338+  5A35              ;		 INT y,
339+  5A35              ;		 INT char_data_pointer,
340+  5A35              ;		 INT mask_data_pointer,
341+  5A35              ;		 INT width (in characters),
342+  5A35              ;		 INT height (in characters),
343+  5A35              ;		 INT background_pointer (top left),
344+  5A35              ;		 INT background_width (in characters),
345+  5A35              ;		 INT background_height (in characters))
346+  5A35              ; will put ram in page 0 also, page 1 is already there
347+  5A35              BLIT:
348+  5A35              	; opening (
349+  5A35 CD 00 60     	CALL CHKCHAR
350+  5A38 28           	DB '('
351+  5A39              	; get x coordinate
352+  5A39 DD 21 2F 54  	LD IX, FRMQNT
353+  5A3D CD 59 01     	CALL CALBAS
354+  5A40 7B           	LD A, E
355+  5A41 E6 07        	AND 7
356+  5A43 32 3E 5D     	LD (BLIT_STRUCT+0), A
357+  5A46 CD 23 5B     	CALL .DAdiv8
358+  5A49 32 3A 5D     	LD (BLIT_TMP+0),A
359+  5A4C              	; comma
360+  5A4C CD 00 60     	CALL CHKCHAR
361+  5A4F 2C           	DB ','
362+  5A50              	; get y coordinate
363+  5A50 DD 21 2F 54  	LD IX, FRMQNT
364+  5A54 CD 59 01     	CALL CALBAS
365+  5A57 7B           	LD A, E
366+  5A58 E6 07        	AND 7
367+  5A5A 32 40 5D     	LD (BLIT_STRUCT+2), A
368+  5A5D CD 23 5B     	CALL .DAdiv8
369+  5A60 32 3B 5D     	LD (BLIT_TMP+1),A
370+  5A63              	; comma
371+  5A63 CD 00 60     	CALL CHKCHAR
372+  5A66 2C           	DB ','
373+  5A67              	; get char data pointer
374+  5A67 DD 21 2F 54  	LD IX, FRMQNT
375+  5A6B CD 59 01     	CALL CALBAS
376+  5A6E ED 53 48 5D  	LD (BLIT_STRUCT+10), DE
377+  5A72              	; comma
378+  5A72 CD 00 60     	CALL CHKCHAR
379+  5A75 2C           	DB ','
380+  5A76              	; get mask data pointer
381+  5A76 DD 21 2F 54  	LD IX, FRMQNT
382+  5A7A CD 59 01     	CALL CALBAS
383+  5A7D ED 53 46 5D  	LD (BLIT_STRUCT+8), DE
384+  5A81              	; comma
385+  5A81 CD 00 60     	CALL CHKCHAR
386+  5A84 2C           	DB ','
387+  5A85              	; get width
388+  5A85 DD 21 2F 54  	LD IX, FRMQNT
389+  5A89 CD 59 01     	CALL CALBAS
390+  5A8C 7B           	LD A, E
391+  5A8D 32 4C 5D     	LD (BLIT_STRUCT+14), A
392+  5A90              	; comma
393+  5A90 CD 00 60     	CALL CHKCHAR
394+  5A93 2C           	DB ','
395+  5A94              	; get height
396+  5A94 DD 21 2F 54  	LD IX, FRMQNT
397+  5A98 CD 59 01     	CALL CALBAS
398+  5A9B 7B           	LD A, E
399+  5A9C 32 4E 5D     	LD (BLIT_STRUCT+16), A
400+  5A9F              	; comma
401+  5A9F CD 00 60     	CALL CHKCHAR
402+  5AA2 2C           	DB ','
403+  5AA3              	; get background pointer
404+  5AA3 DD 21 2F 54  	LD IX, FRMQNT
405+  5AA7 CD 59 01     	CALL CALBAS
406+  5AAA ED 53 42 5D  	LD (BLIT_STRUCT+4), DE
407+  5AAE              	; comma
408+  5AAE CD 00 60     	CALL CHKCHAR
409+  5AB1 2C           	DB ','
410+  5AB2              	; get background width
411+  5AB2 DD 21 2F 54  	LD IX, FRMQNT
412+  5AB6 CD 59 01     	CALL CALBAS
413+  5AB9 7B           	LD A, E
414+  5ABA 32 3C 5D     	LD (BLIT_TMP+2), A
415+  5ABD              	; comma
416+  5ABD CD 00 60     	CALL CHKCHAR
417+  5AC0 2C           	DB ','
418+  5AC1              	; get background height
419+  5AC1 DD 21 2F 54  	LD IX, FRMQNT
420+  5AC5 CD 59 01     	CALL CALBAS
421+  5AC8 7B           	LD A, E
422+  5AC9 32 3D 5D     	LD (BLIT_TMP+3), A
423+  5ACC              	; ending )
424+  5ACC CD 00 60     	CALL CHKCHAR
425+  5ACF 29           	DB ')'
426+  5AD0
427+  5AD0 E5           	PUSH HL ; save position in BASIC buffer
428+  5AD1
429+  5AD1              	; calculate char&mask add to value
430+  5AD1 26 00        	LD H, 0
431+  5AD3 3A 4C 5D     	LD A, (BLIT_STRUCT+14)
432+  5AD6 6F           	LD L, A
433+  5AD7 CD EF 5E     	CALL HLx8
434+  5ADA 22 4A 5D     	LD (BLIT_STRUCT+12), HL
435+  5ADD              	; calculate background add to value
436+  5ADD 26 00        	LD H, 0
437+  5ADF 3A 3C 5D     	LD A, (BLIT_TMP+2)
438+  5AE2 6F           	LD L, A
439+  5AE3 CD EF 5E     	CALL HLx8
440+  5AE6 22 44 5D     	LD (BLIT_STRUCT+6), HL
441+  5AE9              	; calculate pointer to background location
442+  5AE9 21 00 00     	LD HL, 0
443+  5AEC 3A 3B 5D     	LD A,(BLIT_TMP+1)
444+  5AEF B7           	OR A
445+  5AF0 28 08        	JR Z, .L1
446+  5AF2 47           	LD B,A
447+  5AF3 ED 5B 44 5D  	LD DE,(BLIT_STRUCT+6)
448+  5AF7              .L0:
449+  5AF7 19           	ADD HL, DE
450+  5AF8 10 FD        	DJNZ .L0
451+  5AFA              .L1:
452+  5AFA EB           	EX DE,HL
453+  5AFB 26 00        	LD H,0
454+  5AFD 3A 3A 5D     	LD A,(BLIT_TMP+0)
455+  5B00 6F           	LD L,A
456+  5B01 CD EF 5E     	CALL HLx8
457+  5B04 19           	ADD HL,DE
458+  5B05 ED 5B 42 5D  	LD DE,(BLIT_STRUCT+4)
459+  5B09 19           	ADD HL,DE
460+  5B0A 22 42 5D     	LD (BLIT_STRUCT+4),HL
461+  5B0D
462+  5B0D FD 21 14 5B  	LD IY, .RET
463+  5B11 C3 B3 5F     	JP ENABLE_PAGE0
464+  5B14              .RET:
465+  5B14 FB           	EI
466+  5B15 DD 21 3E 5D  	LD IX, BLIT_STRUCT
467+  5B19 CD A1 59     	CALL SHIFT_MERGE_CHARACTER
468+  5B1C
469+  5B1C D1               POP DE
470+  5B1D C1               POP BC
471+  5B1E CD 2A 5F         CALL RESTORE_PAGE_INFO
472+  5B21
473+  5B21 E1           	POP HL
474+  5B22 C9           	RET
475+  5B23              .DAdiv8:
476+  5B23 7B           	LD A,E
477+  5B24 CB 2A        	SRA D
478+  5B26 CB 1F            RR  A
479+  5B28 CB 2A            SRA D
480+  5B2A CB 1F            RR  A
481+  5B2C CB 2A            SRA D
482+  5B2E CB 1F            RR  A
483+  5B30 C9           	RET
484+  5B31              ; *******************************************************************************************************
485+  5B31               ENDIF
# file closed: asm\BLIT.asm
145   5B31               ENDIF
146   5B31
147   5B31               IF (TILE_CMDS == 1)
148   5B31               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5B31              ; *******************************************************************************************************
  2+  5B31              ; generic function to implement tiling
  3+  5B31              ; should be modified to call appropriate function for memory or vram
  4+  5B31              ; input IX=pointer to following structure
  5+  5B31              ; +00 tile_data_ptr
  6+  5B31              ; +02 tile_rows
  7+  5B31              ; +04 tile_columns
  8+  5B31              ; +06 destination_address
  9+  5B31              ; +08 dest_to_next_row_add_to_value
 10+  5B31              ; +10 num_horizontal_tiles
 11+  5B31              ; +12 num_vertical_tiles
 12+  5B31              ; modifies AF, BC, DE, HL
 13+  5B31              TILE:
 14+  5B31 DD 6E 06     	LD L, (IX+6)
 15+  5B34 DD 66 07     	LD H, (IX+7) ; destination address
 16+  5B37 22 3A 5D     	LD (TILETMP1), HL
 17+  5B3A DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5B3D              .L1:
 19+  5B3D C5           	PUSH BC
 20+  5B3E DD 6E 00     		LD L, (IX+0)
 21+  5B41 DD 66 01     		LD H, (IX+1) ; tile address
 22+  5B44 22 3C 5D     		LD (TILETMP2), HL
 23+  5B47 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5B4A              .L2:
 25+  5B4A C5           		PUSH BC
 26+  5B4B CD 00 00     .CALL1:		CALL 0
 27+  5B4E DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5B51              .L3:
 29+  5B51 C5           			PUSH BC
 30+  5B52 2A 3C 5D     				LD HL, (TILETMP2)
 31+  5B55 DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5B58              .L4:
 33+  5B58 C5           				PUSH BC
 34+  5B59              .CALL2:
 35+  5B59 CD 00 00     					CALL 0
 36+  5B5C C1           				POP BC
 37+  5B5D 10 F9        				DJNZ .L4
 38+  5B5F C1           			POP BC
 39+  5B60 10 EF        			DJNZ .L3
 40+  5B62 22 3C 5D     			LD (TILETMP2), HL
 41+  5B65 2A 3A 5D     			LD HL, (TILETMP1)
 42+  5B68 DD 5E 08     			LD E, (IX+8)
 43+  5B6B DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5B6E 19           			ADD HL, DE
 45+  5B6F 22 3A 5D     			LD (TILETMP1), HL
 46+  5B72 C1           		POP BC
 47+  5B73 10 D5        		DJNZ .L2
 48+  5B75 C1           	POP BC
 49+  5B76 10 C5        	DJNZ .L1
 50+  5B78 C9           	RET
 51+  5B79              ; *******************************************************************************************************
 52+  5B79
 53+  5B79               IFNDEF CMDS_WITH_PARAMETERS
 54+  5B79 ~            ; *******************************************************************************************************
 55+  5B79 ~            ; function to handle CALL TILERAM basic extension
 56+  5B79 ~            ; fills memory with tiles
 57+  5B79 ~            ; TILERAM ( INT request_data_ptr )
 58+  5B79 ~            ; request_data_ptr described in TILE
 59+  5B79 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5B79 ~            TILERAM:
 61+  5B79 ~            	; opening (
 62+  5B79 ~            	CALL CHKCHAR
 63+  5B79 ~            	DB '('
 64+  5B79 ~            	; get pointer to request struct
 65+  5B79 ~            	LD IX, FRMQNT
 66+  5B79 ~            	CALL CALBAS
 67+  5B79 ~            	PUSH DE
 68+  5B79 ~            	; ending )
 69+  5B79 ~            	CALL CHKCHAR
 70+  5B79 ~            	DB ')'
 71+  5B79 ~
 72+  5B79 ~            	POP IX ; pointer to request struct
 73+  5B79 ~
 74+  5B79 ~            	PUSH HL ; save position in BASIC buffer
 75+  5B79 ~
 76+  5B79 ~            	LD IY, .RET
 77+  5B79 ~            	JP ENABLE_PAGE0
 78+  5B79 ~            .RET:
 79+  5B79 ~            	EI
 80+  5B79 ~            	; set RAM functions to call
 81+  5B79 ~            	LD HL, .TILECOPY
 82+  5B79 ~            	LD (TILE.CALL2+1), HL
 83+  5B79 ~            	LD HL, .SETDESTROW
 84+  5B79 ~            	LD (TILE.CALL1+1), HL
 85+  5B79 ~            	LD A,1
 86+  5B79 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5B79 ~            	CALL TILE
 88+  5B79 ~            	XOR A
 89+  5B79 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5B79 ~
 91+  5B79 ~                POP DE
 92+  5B79 ~                POP BC
 93+  5B79 ~                CALL RESTORE_PAGE_INFO
 94+  5B79 ~
 95+  5B79 ~            	POP HL
 96+  5B79 ~            	RET
 97+  5B79 ~            .TILECOPY:
 98+  5B79 ~            	.8 LDI
 99+  5B79 ~            	RET
100+  5B79 ~            .SETDESTROW:
101+  5B79 ~            	LD DE, (TILETMP1)
102+  5B79 ~            	RET
103+  5B79 ~            ; *******************************************************************************************************
104+  5B79               ENDIF
105+  5B79
106+  5B79               IFDEF CMDS_WITH_PARAMETERS
107+  5B79              ; *******************************************************************************************************
108+  5B79              ; function to handle CALL TILERAM basic extension
109+  5B79              ; fills memory with tiles
110+  5B79              ; TILERAM ( INT tile_data_pointer,
111+  5B79              ;			INT tile_columns,
112+  5B79              ;			INT tile_rows,
113+  5B79              ;			INT destination_pointer,
114+  5B79              ;			INT destination_columns,
115+  5B79              ;			INT destination_rows,
116+  5B79              ;			INT destination_begin_column,
117+  5B79              ;			INT destination_begin_row,
118+  5B79              ;			INT number_of_tiles_horizontally,
119+  5B79              ;			INT	number_of_tiles_vertically )
120+  5B79              ; will put ram in page 0 also, page 1 is already there
121+  5B79              TILERAM:
122+  5B79              	; opening (
123+  5B79 CD 00 60     	CALL CHKCHAR
124+  5B7C 28           	DB '('
125+  5B7D              	; get tile data pointer coordinate
126+  5B7D DD 21 2F 54  	LD IX, FRMQNT
127+  5B81 CD 59 01     	CALL CALBAS
128+  5B84 ED 53 3E 5D  	LD (BLIT_STRUCT+0), DE
129+  5B88              	; comma
130+  5B88 CD 00 60     	CALL CHKCHAR
131+  5B8B 2C           	DB ','
132+  5B8C              	; get tile columns
133+  5B8C DD 21 2F 54  	LD IX, FRMQNT
134+  5B90 CD 59 01     	CALL CALBAS
135+  5B93 ED 53 42 5D  	LD (BLIT_STRUCT+4), DE
136+  5B97              	; comma
137+  5B97 CD 00 60     	CALL CHKCHAR
138+  5B9A 2C           	DB ','
139+  5B9B              	; get tile columns
140+  5B9B DD 21 2F 54  	LD IX, FRMQNT
141+  5B9F CD 59 01     	CALL CALBAS
142+  5BA2 ED 53 40 5D  	LD (BLIT_STRUCT+2), DE
143+  5BA6              	; comma
144+  5BA6 CD 00 60     	CALL CHKCHAR
145+  5BA9 2C           	DB ','
146+  5BAA              	; get destintion pointer
147+  5BAA DD 21 2F 54  	LD IX, FRMQNT
148+  5BAE CD 59 01     	CALL CALBAS
149+  5BB1 ED 53 44 5D  	LD (BLIT_STRUCT+6), DE
150+  5BB5              	; comma
151+  5BB5 CD 00 60     	CALL CHKCHAR
152+  5BB8 2C           	DB ','
153+  5BB9              	; get destination columns
154+  5BB9 DD 21 2F 54  	LD IX, FRMQNT
155+  5BBD CD 59 01     	CALL CALBAS
156+  5BC0 7B           	LD A, E
157+  5BC1 32 3A 5D     	LD (BLIT_TMP+0), A
158+  5BC4              	; comma
159+  5BC4 CD 00 60     	CALL CHKCHAR
160+  5BC7 2C           	DB ','
161+  5BC8              	; get destination rows
162+  5BC8 DD 21 2F 54  	LD IX, FRMQNT
163+  5BCC CD 59 01     	CALL CALBAS
164+  5BCF 7B           	LD A, E
165+  5BD0 32 3B 5D     	LD (BLIT_TMP+1), A
166+  5BD3              	; comma
167+  5BD3 CD 00 60     	CALL CHKCHAR
168+  5BD6 2C           	DB ','
169+  5BD7              	; get destination begin column
170+  5BD7 DD 21 2F 54  	LD IX, FRMQNT
171+  5BDB CD 59 01     	CALL CALBAS
172+  5BDE 7B           	LD A, E
173+  5BDF 32 3C 5D     	LD (BLIT_TMP+2), A
174+  5BE2              	; comma
175+  5BE2 CD 00 60     	CALL CHKCHAR
176+  5BE5 2C           	DB ','
177+  5BE6              	; get destination begin row
178+  5BE6 DD 21 2F 54  	LD IX, FRMQNT
179+  5BEA CD 59 01     	CALL CALBAS
180+  5BED 7B           	LD A, E
181+  5BEE 32 3D 5D     	LD (BLIT_TMP+3), A
182+  5BF1              	; comma
183+  5BF1 CD 00 60     	CALL CHKCHAR
184+  5BF4 2C           	DB ','
185+  5BF5              	; get number of tiles horizontally
186+  5BF5 DD 21 2F 54  	LD IX, FRMQNT
187+  5BF9 CD 59 01     	CALL CALBAS
188+  5BFC ED 53 48 5D  	LD (BLIT_STRUCT+10), DE
189+  5C00              	; comma
190+  5C00 CD 00 60     	CALL CHKCHAR
191+  5C03 2C           	DB ','
192+  5C04              	; get number of tiles vertically
193+  5C04 DD 21 2F 54  	LD IX, FRMQNT
194+  5C08 CD 59 01     	CALL CALBAS
195+  5C0B ED 53 4A 5D  	LD (BLIT_STRUCT+12), DE
196+  5C0F              	; ending )
197+  5C0F CD 00 60     	CALL CHKCHAR
198+  5C12 29           	DB ')'
199+  5C13
200+  5C13 E5           	PUSH HL ; save position in BASIC buffer
201+  5C14
202+  5C14              	; calculate destination add to value
203+  5C14 26 00        	LD H, 0
204+  5C16 3A 3A 5D     	LD A, (BLIT_TMP+0)
205+  5C19 6F           	LD L, A
206+  5C1A CD EF 5E     	CALL HLx8
207+  5C1D 22 46 5D     	LD (BLIT_STRUCT+8), HL
208+  5C20              	; calculate pointer to background location
209+  5C20 21 00 00     	LD HL, 0
210+  5C23 3A 3D 5D     	LD A,(BLIT_TMP+3)
211+  5C26 B7           	OR A
212+  5C27 28 08        	JR Z, .L1
213+  5C29 47           	LD B,A
214+  5C2A ED 5B 46 5D  	LD DE,(BLIT_STRUCT+8)
215+  5C2E              .L0:
216+  5C2E 19           	ADD HL, DE
217+  5C2F 10 FD        	DJNZ .L0
218+  5C31              .L1:
219+  5C31 EB           	EX DE,HL
220+  5C32 26 00        	LD H,0
221+  5C34 3A 3C 5D     	LD A,(BLIT_TMP+2)
222+  5C37 6F           	LD L,A
223+  5C38 CD EF 5E     	CALL HLx8
224+  5C3B 19           	ADD HL,DE
225+  5C3C ED 5B 44 5D  	LD DE,(BLIT_STRUCT+6)
226+  5C40 19           	ADD HL,DE
227+  5C41 22 44 5D     	LD (BLIT_STRUCT+6),HL
228+  5C44
229+  5C44 FD 21 4B 5C  	LD IY, .RET
230+  5C48 C3 B3 5F     	JP ENABLE_PAGE0
231+  5C4B              .RET:
232+  5C4B FB           	EI
233+  5C4C              	; set RAM functions to call
234+  5C4C 21 66 5C     	LD HL, .TILECOPY
235+  5C4F 22 5A 5B     	LD (TILE.CALL2+1), HL
236+  5C52 21 77 5C     	LD HL, .SETDESTROW
237+  5C55 22 4C 5B     	LD (TILE.CALL1+1), HL
238+  5C58 DD 21 3E 5D  	LD IX,BLIT_STRUCT
239+  5C5C CD 31 5B     	CALL TILE
240+  5C5F
241+  5C5F D1               POP DE
242+  5C60 C1               POP BC
243+  5C61 CD 2A 5F         CALL RESTORE_PAGE_INFO
244+  5C64
245+  5C64 E1           	POP HL
246+  5C65 C9           	RET
247+  5C66              .TILECOPY:
248+  5C66 ED A0       > LDI
248+  5C68 ED A0       > LDI
248+  5C6A ED A0       > LDI
248+  5C6C ED A0       > LDI
248+  5C6E ED A0       > LDI
248+  5C70 ED A0       > LDI
248+  5C72 ED A0       > LDI
248+  5C74 ED A0       > LDI
249+  5C76 C9           	RET
250+  5C77              .SETDESTROW:
251+  5C77 ED 5B 3A 5D  	LD DE, (TILETMP1)
252+  5C7B C9           	RET
253+  5C7C              ; *******************************************************************************************************
254+  5C7C               ENDIF
255+  5C7C
256+  5C7C               IFDEF CMDS_WITH_PARAMETERS
257+  5C7C              ; *******************************************************************************************************
258+  5C7C              ; function to handle CALL TILEVRM basic extension
259+  5C7C              ; fills vram with tiles
260+  5C7C              ; TILEVRM ( INT tile_data_pointer,
261+  5C7C              ;			INT tile_columns,
262+  5C7C              ;			INT tile_rows,
263+  5C7C              ;			INT destination_begin_column,
264+  5C7C              ;			INT destination_begin_row,
265+  5C7C              ;			INT number_of_tiles_horizontally,
266+  5C7C              ;			INT	number_of_tiles_vertically )
267+  5C7C              ; will put ram in page 0 also, page 1 is already there
268+  5C7C              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5C7C              TILEVRM:
270+  5C7C              	; opening (
271+  5C7C CD 00 60     	CALL CHKCHAR
272+  5C7F 28           	DB '('
273+  5C80              	; get tile data pointer coordinate
274+  5C80 DD 21 2F 54  	LD IX, FRMQNT
275+  5C84 CD 59 01     	CALL CALBAS
276+  5C87 ED 53 3E 5D  	LD (BLIT_STRUCT+0), DE
277+  5C8B              	; comma
278+  5C8B CD 00 60     	CALL CHKCHAR
279+  5C8E 2C           	DB ','
280+  5C8F              	; get tile columns
281+  5C8F DD 21 2F 54  	LD IX, FRMQNT
282+  5C93 CD 59 01     	CALL CALBAS
283+  5C96 ED 53 42 5D  	LD (BLIT_STRUCT+4), DE
284+  5C9A              	; comma
285+  5C9A CD 00 60     	CALL CHKCHAR
286+  5C9D 2C           	DB ','
287+  5C9E              	; get tile columns
288+  5C9E DD 21 2F 54  	LD IX, FRMQNT
289+  5CA2 CD 59 01     	CALL CALBAS
290+  5CA5 ED 53 40 5D  	LD (BLIT_STRUCT+2), DE
291+  5CA9              	; comma
292+  5CA9 CD 00 60     	CALL CHKCHAR
293+  5CAC 2C           	DB ','
294+  5CAD              	; get destination begin column
295+  5CAD DD 21 2F 54  	LD IX, FRMQNT
296+  5CB1 CD 59 01     	CALL CALBAS
297+  5CB4 7B           	LD A, E
298+  5CB5 32 3C 5D     	LD (BLIT_TMP+2), A
299+  5CB8              	; comma
300+  5CB8 CD 00 60     	CALL CHKCHAR
301+  5CBB 2C           	DB ','
302+  5CBC              	; get destination begin row
303+  5CBC DD 21 2F 54  	LD IX, FRMQNT
304+  5CC0 CD 59 01     	CALL CALBAS
305+  5CC3 7B           	LD A, E
306+  5CC4 32 3D 5D     	LD (BLIT_TMP+3), A
307+  5CC7              	; comma
308+  5CC7 CD 00 60     	CALL CHKCHAR
309+  5CCA 2C           	DB ','
310+  5CCB              	; get number of tiles horizontally
311+  5CCB DD 21 2F 54  	LD IX, FRMQNT
312+  5CCF CD 59 01     	CALL CALBAS
313+  5CD2 ED 53 48 5D  	LD (BLIT_STRUCT+10), DE
314+  5CD6              	; comma
315+  5CD6 CD 00 60     	CALL CHKCHAR
316+  5CD9 2C           	DB ','
317+  5CDA              	; get number of tiles vertically
318+  5CDA DD 21 2F 54  	LD IX, FRMQNT
319+  5CDE CD 59 01     	CALL CALBAS
320+  5CE1 ED 53 4A 5D  	LD (BLIT_STRUCT+12), DE
321+  5CE5              	; ending )
322+  5CE5 CD 00 60     	CALL CHKCHAR
323+  5CE8 29           	DB ')'
324+  5CE9
325+  5CE9 E5           	PUSH HL ; save position in BASIC buffer
326+  5CEA
327+  5CEA              	; calculate destination add to value
328+  5CEA 21 00 01     	LD HL, 256
329+  5CED 22 46 5D     	LD (BLIT_STRUCT+8), HL
330+  5CF0              	; calculate pointer to background location
331+  5CF0 3A 3D 5D     	LD A,(BLIT_TMP+3)
332+  5CF3 67           	LD H,A
333+  5CF4 2E 00        	LD L,0
334+  5CF6 EB           	EX DE,HL
335+  5CF7 26 00        	LD H,0
336+  5CF9 3A 3C 5D     	LD A,(BLIT_TMP+2)
337+  5CFC 6F           	LD L,A
338+  5CFD CD EF 5E     	CALL HLx8
339+  5D00 19           	ADD HL,DE
340+  5D01 ED 5B CB F3  	LD DE,(GRPCGP)
341+  5D05 19           	ADD HL,DE
342+  5D06 22 44 5D     	LD (BLIT_STRUCT+6),HL
343+  5D09
344+  5D09 FD 21 10 5D  	LD IY, .RET
345+  5D0D C3 B3 5F     	JP ENABLE_PAGE0
346+  5D10              .RET:
347+  5D10 FB           	EI
348+  5D11              	; set RAM functions to call
349+  5D11 21 2B 5D     	LD HL, .TILECOPY
350+  5D14 22 5A 5B     	LD (TILE.CALL2+1), HL
351+  5D17 21 31 5D     	LD HL, .SETDESTROW
352+  5D1A 22 4C 5B     	LD (TILE.CALL1+1), HL
353+  5D1D DD 21 3E 5D  	LD IX,BLIT_STRUCT
354+  5D21 CD 31 5B     	CALL TILE
355+  5D24
356+  5D24 D1               POP DE
357+  5D25 C1               POP BC
358+  5D26 CD 2A 5F         CALL RESTORE_PAGE_INFO
359+  5D29
360+  5D29 E1           	POP HL
361+  5D2A C9           	RET
362+  5D2B              .TILECOPY:
363+  5D2B 01 98 08     	LD BC, #0898
364+  5D2E C3 E7 5E     	JP BBYTECOPY_NO_C
365+  5D31              .SETDESTROW:
366+  5D31 2A 3A 5D     	LD HL, (TILETMP1)
367+  5D34 F3           	DI
368+  5D35 CD DA 5E     	CALL SETWRT_LOCAL
369+  5D38 FB           	EI
370+  5D39 C9           	RET
371+  5D3A              ; *******************************************************************************************************
372+  5D3A               ENDIF
373+  5D3A
374+  5D3A               IFNDEF CMDS_WITH_PARAMETERS
375+  5D3A ~            ; *******************************************************************************************************
376+  5D3A ~            ; function to handle CALL TILEVRM basic extension
377+  5D3A ~            ; fills vram with tiles
378+  5D3A ~            ; TILEVRM ( INT request_data_ptr )
379+  5D3A ~            ; request_data_ptr described in TILE
380+  5D3A ~            ; will put ram in page 0 also, page 1 is already there
381+  5D3A ~            TILEVRM:
382+  5D3A ~            	; opening (
383+  5D3A ~            	CALL CHKCHAR
384+  5D3A ~            	DB '('
385+  5D3A ~            	; get pointer to request struct
386+  5D3A ~            	LD IX, FRMQNT
387+  5D3A ~            	CALL CALBAS
388+  5D3A ~            	PUSH DE
389+  5D3A ~            	; ending )
390+  5D3A ~            	CALL CHKCHAR
391+  5D3A ~            	DB ')'
392+  5D3A ~
393+  5D3A ~            	POP IX ; pointer to request struct
394+  5D3A ~
395+  5D3A ~            	PUSH HL ; save position in BASIC buffer
396+  5D3A ~
397+  5D3A ~            	LD IY, .RET
398+  5D3A ~            	JP ENABLE_PAGE0
399+  5D3A ~            .RET:
400+  5D3A ~            	EI
401+  5D3A ~            	; set RAM functions to call
402+  5D3A ~            	LD HL, .TILECOPY
403+  5D3A ~            	LD (TILE.CALL2+1), HL
404+  5D3A ~            	LD HL, .SETDESTROW
405+  5D3A ~            	LD (TILE.CALL1+1), HL
406+  5D3A ~            	CALL TILE
407+  5D3A ~
408+  5D3A ~                POP DE
409+  5D3A ~                POP BC
410+  5D3A ~                CALL RESTORE_PAGE_INFO
411+  5D3A ~
412+  5D3A ~            	POP HL
413+  5D3A ~            	RET
414+  5D3A ~            .TILECOPY:
415+  5D3A ~            	LD BC, #0898
416+  5D3A ~            	JP BBYTECOPY_NO_C
417+  5D3A ~            .SETDESTROW:
418+  5D3A ~            	LD HL, (TILETMP1)
419+  5D3A ~            	DI
420+  5D3A ~            	CALL SETWRT_LOCAL
421+  5D3A ~            	EI
422+  5D3A ~            	RET
423+  5D3A ~            ; *******************************************************************************************************
424+  5D3A               ENDIF
# file closed: asm\TILE.asm
149   5D3A               ENDIF
150   5D3A
151   5D3A              ; temp variables for BLIT, TILE functions
152   5D3A               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS > 0)
153   5D3A              BLIT_TMP:
154   5D3A              TILETMP1:
155   5D3A              BLIT_TMP1:
156   5D3A 00 00         DW 0
157   5D3C              TILETMP2:
158   5D3C              BLIT_TMP2:
159   5D3C 00 00         DW 0
160   5D3E                IFDEF CMDS_WITH_PARAMETERS
161   5D3E              BLIT_STRUCT:
162   5D3E 00 00 00...   DS 17
163   5D42                ENDIF
164   5D42               ENDIF
165   5D4F
166   5D4F               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS > 0)
167   5D4F              VRAM_UPDATE_IN_PROGRESS:
168   5D4F 00            DB 0
169   5D50               ENDIF
170   5D50
171   5D50              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
172   5D50              ; per starting letter, if no commands with this letter, NULL value
173   5D50              CMDS:
174   5D50               IF (ANIM_CMDS == 1)
175   5D50 79 5E        	DW CMDS_A ;
176   5D52               ELSE
177   5D52 ~                DW 0 ; A
178   5D52               ENDIF
179   5D52               IF (BLIT_CMDS + BOX_CMDS > 0)
180   5D52 44 5E            DW CMDS_B ; B
181   5D54               ELSE
182   5D54 ~            	DW 0
183   5D54               ENDIF
184   5D54 00 00            DW 0 ; C
185   5D56 00 00            DW 0 ; D
186   5D58 00 00            DW 0 ; E
187   5D5A               IF (VRAM_CMDS + RAM_CMDS > 0)
188   5D5A C2 5D            DW CMDS_F; F
189   5D5C               ELSE
190   5D5C ~            	DW 0
191   5D5C               ENDIF
192   5D5C               IF (GENCAL_CMD > 0)
193   5D5C D5 5D            DW CMDS_G; G
194   5D5E               ELSE
195   5D5E ~            	DW 0
196   5D5E               ENDIF
197   5D5E 00 00            DW 0 ; H
198   5D60 00 00            DW 0 ; I
199   5D62 00 00            DW 0 ; J
200   5D64 00 00            DW 0 ; K
201   5D66 00 00            DW 0 ; L
202   5D68               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
203   5D68 84 5D            DW CMDS_M ; M
204   5D6A               ELSE
205   5D6A ~            	DW 0
206   5D6A               ENDIF
207   5D6A 00 00            DW 0 ; N
208   5D6C 00 00            DW 0 ; O
209   5D6E 00 00            DW 0 ; P
210   5D70 00 00            DW 0 ; Q
211   5D72 00 00            DW 0 ; R
212   5D74               IF (SOUND_CMDS + SPRITE_CMDS > 0)
213   5D74 E9 5D            DW CMDS_S ; S
214   5D76               ELSE
215   5D76 ~            	DW 0
216   5D76               ENDIF
217   5D76               IF (TILE_CMDS > 0)
218   5D76 64 5E            DW CMDS_T ; T
219   5D78               ELSE
220   5D78 ~            	DW 0
221   5D78               ENDIF
222   5D78 00 00            DW 0 ; U
223   5D7A               IF (VRAM_CMDS > 0)
224   5D7A DF 5D            DW CMDS_V ; V
225   5D7C               ELSE
226   5D7C ~            	DW 0
227   5D7C               ENDIF
228   5D7C 00 00            DW 0 ; W
229   5D7E 00 00            DW 0 ; X
230   5D80 00 00            DW 0 ; Y
231   5D82 00 00            DW 0 ; Z
232   5D84
233   5D84              CMDS_M:
234   5D84               IF (VRAM_CMDS == 1)
235   5D84 4D 45 4D 56      DB "MEMVRM", 0
235   5D88 52 4D 00
236   5D8B 7F 56            DW MEMVRM
237   5D8D               ENDIF
238   5D8D               IF (RAM_CMDS == 1)
239   5D8D 4D 45 4D 43  	DB "MEMCPY", 0
239   5D91 50 59 00
240   5D94 B5 54        	DW MEMCPY
241   5D96               ENDIF
242   5D96               IF (ANIM_CMDS == 1)
243   5D96 4D 41 58 41  	DB "MAXANIMITEMS",0
243   5D9A 4E 49 4D 49
243   5D9E 54 45 4D 53
243   5DA2 00
244   5DA3 EA 4F        	DW MAXANIMITEMS
245   5DA5 4D 41 58 41  	DB "MAXANIMDEFS",0
245   5DA9 4E 49 4D 44
245   5DAD 45 46 53 00
246   5DB1 5F 51        	DW MAXANIMDEFS
247   5DB3 4D 41 58 41  	DB "MAXANIMSPRS",0
247   5DB7 4E 49 4D 53
247   5DBB 50 52 53 00
248   5DBF F4 51        	DW MAXANIMSPRS
249   5DC1               ENDIF
250   5DC1               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
251   5DC1 00           	DB 0
252   5DC2               ENDIF
253   5DC2              CMDS_F:
254   5DC2               IF (VRAM_CMDS == 1)
255   5DC2 46 49 4C 56      DB "FILVRM", 0
255   5DC6 52 4D 00
256   5DC9 2F 56            DW FILVRM
257   5DCB               ENDIF
258   5DCB               IF (RAM_CMDS == 1)
259   5DCB 46 49 4C 52      DB "FILRAM", 0
259   5DCF 41 4D 00
260   5DD2 F8 54            DW FILRAM
261   5DD4               ENDIF
262   5DD4               IF (VRAM_CMDS + RAM_CMDS > 0)
263   5DD4 00               DB 0
264   5DD5               ENDIF
265   5DD5              CMDS_G:
266   5DD5               IF (GENCAL_CMD == 1)
267   5DD5 47 45 4E 43      DB "GENCAL", 0
267   5DD9 41 4C 00
268   5DDC 63 57            DW GENCAL
269   5DDE               ENDIF
270   5DDE               IF (GENCAL_CMD > 0)
271   5DDE 00           	DB	0
272   5DDF               ENDIF
273   5DDF              CMDS_V:
274   5DDF               IF (VRAM_CMDS == 1)
275   5DDF 56 52 4D 4D  	DB "VRMMEM", 0
275   5DE3 45 4D 00
276   5DE6 FE 56        	DW VRMMEM
277   5DE8               ENDIF
278   5DE8               IF (VRAM_CMDS > 0)
279   5DE8 00           	DB 0
280   5DE9               ENDIF
281   5DE9              CMDS_S:
282   5DE9               IF (SPRITE_CMDS == 1)
283   5DE9 53 50 52 53  	DB "SPRSET", 0
283   5DED 45 54 00
284   5DF0 81 4E        	DW SPRSET
285   5DF2 53 50 52 47  	DB "SPRGRPMOV", 0
285   5DF6 52 50 4D 4F
285   5DFA 56 00
286   5DFC 32 4F        	DW SPRGRPMOV
287   5DFE               ENDIF
288   5DFE               IF (SOUND_CMDS == 1)
289   5DFE 53 4E 44 53  	DB "SNDSFX", 0
289   5E02 46 58 00
290   5E05 D5 55        	DW SNDSFX
291   5E07 53 4E 44 50  	DB "SNDPLYON", 0
291   5E0B 4C 59 4F 4E
291   5E0F 00
292   5E10 9F 55        	DW SNDPLYON
293   5E12 53 4E 44 50  	DB "SNDPLYOFF", 0
293   5E16 4C 59 4F 46
293   5E1A 46 00
294   5E1C B2 55        	DW SNDPLYOFF
295   5E1E 53 4E 44 50  	DB "SNDPLYINI", 0
295   5E22 4C 59 49 4E
295   5E26 49 00
296   5E28 55 55        	DW SNDPLYINIT
297   5E2A               ENDIF
298   5E2A               IF (SPRITE_CMDS == 1)
299   5E2A 53 50 52 45  	DB "SPRENABLE", 0
299   5E2E 4E 41 42 4C
299   5E32 45 00
300   5E34 3C 4E        	DW SPRENABLE
301   5E36 53 50 52 44  	DB "SPRDISABLE", 0
301   5E3A 49 53 41 42
301   5E3E 4C 45 00
302   5E41 7C 4E        	DW SPRDISABLE
303   5E43               ENDIF
304   5E43               IF (SOUND_CMDS + SPRITE_CMDS > 0)
305   5E43 00           	DB 0
306   5E44               ENDIF
307   5E44              CMDS_B:
308   5E44               IF (BLIT_CMDS == 1)
309   5E44 42 4C 49 54  	DB "BLIT", 0
309   5E48 00
310   5E49 35 5A        	DW BLIT
311   5E4B               ENDIF
312   5E4B               IF (BOX_CMDS == 1)
313   5E4B 42 4F 58 4D  	DB "BOXMEMCPY", 0
313   5E4F 45 4D 43 50
313   5E53 59 00
314   5E55 F2 57        	DW BOXMEMCPY
315   5E57 42 4F 58 4D  	DB "BOXMEMVRM", 0
315   5E5B 45 4D 56 52
315   5E5F 4D 00
316   5E61 87 58        	DW BOXMEMVRM
317   5E63               ENDIF
318   5E63               IF (BLIT_CMDS + BOX_CMDS > 0)
319   5E63 00           	DB 0
320   5E64               ENDIF
321   5E64              CMDS_T:
322   5E64               IF (TILE_CMDS == 1)
323   5E64 54 49 4C 45  	DB "TILERAM", 0
323   5E68 52 41 4D 00
324   5E6C 79 5B        	DW TILERAM
325   5E6E 54 49 4C 45  	DB "TILEVRM", 0
325   5E72 56 52 4D 00
326   5E76 7C 5C        	DW TILEVRM
327   5E78               ENDIF
328   5E78               IF (TILE_CMDS > 0)
329   5E78 00           	DB 0
330   5E79               ENDIF
331   5E79              CMDS_A:
332   5E79               IF (ANIM_CMDS == 1)
333   5E79 41 4E 49 4D      DB "ANIMSTEP",0
333   5E7D 53 54 45 50
333   5E81 00
334   5E82 3B 53            DW ANIMSTEP
335   5E84 41 4E 49 4D  	DB "ANIMSTART",0
335   5E88 53 54 41 52
335   5E8C 54 00
336   5E8E 40 53        	DW ANIMSTART
337   5E90 41 4E 49 4D  	DB "ANIMSTOP",0
337   5E94 53 54 4F 50
337   5E98 00
338   5E99 45 53        	DW ANIMSTOP
339   5E9B 41 4E 49 4D  	DB "ANIMITEMPAT",0
339   5E9F 49 54 45 4D
339   5EA3 50 41 54 00
340   5EA7 AA 50        	DW ANIMITEMPAT
341   5EA9 41 4E 49 4D  	DB "ANIMITEMPTR",0
341   5EAD 49 54 45 4D
341   5EB1 50 54 52 00
342   5EB5 0B 51        	DW ANIMITEMPTR_CMD
343   5EB7 41 4E 49 4D  	DB "ANIMDEF",0
343   5EBB 44 45 46 00
344   5EBF A1 51        	DW ANIMDEF
345   5EC1 41 4E 49 4D  	DB "ANIMSPRITE",0
345   5EC5 53 50 52 49
345   5EC9 54 45 00
346   5ECC 4A 52        	DW ANIMSPRITE
347   5ECE 41 4E 49 4D      DB "ANIMCHAR",0
347   5ED2 43 48 41 52
347   5ED6 00
348   5ED7 C2 52            DW ANIMCHAR
349   5ED9 00           	DB 0
350   5EDA               ENDIF
351   5EDA
352   5EDA               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
353   5EDA              ; ****************************************************************************************************
354   5EDA              ; function sets VRAM address
355   5EDA              ; input HL=address
356   5EDA              ; modifies AF
357   5EDA              SETWRT_LOCAL:
358   5EDA 7D           	LD	A, L
359   5EDB D3 99        	OUT	(099H), A
360   5EDD 7C           	LD	A, H
361   5EDE E6 3F        	AND	03FH
362   5EE0 F6 40        	OR	040H
363   5EE2 D3 99        	OUT	(099H), A
364   5EE4 C9           	RET
365   5EE5              ; ****************************************************************************************************
366   5EE5               ENDIF
367   5EE5
368   5EE5               IF (VRAM_CMDS + TILE_CMDS > 0)
369   5EE5              ; ****************************************************************************************************
370   5EE5              ; function copies data from RAM to VRAM
371   5EE5              ; input HL=address in RAM
372   5EE5              ; input B=count
373   5EE5              ; modifies AF, BC, HL
374   5EE5              BBYTECOPY:
375   5EE5 0E 98        	LD C,#98
376   5EE7              BBYTECOPY_NO_C:
377   5EE7 ED A3        	OUTI
378   5EE9 C2 E7 5E     	JP	NZ, BBYTECOPY_NO_C
379   5EEC C9           	RET
380   5EED              ; ****************************************************************************************************
381   5EED               ENDIF
382   5EED
383   5EED              ; ****************************************************************************************************
384   5EED              ; function multiplies HL by 32
385   5EED              HLx32:
386   5EED 29           	ADD HL,HL
387   5EEE              ; ****************************************************************************************************
388   5EEE              ; function multiplies HL by 16
389   5EEE              HLx16:
390   5EEE 29           	ADD HL,HL
391   5EEF              ; ****************************************************************************************************
392   5EEF              ; function multiplies HL by 8
393   5EEF              HLx8:
394   5EEF 29          > ADD HL, HL
394   5EF0 29          > ADD HL, HL
394   5EF1 29          > ADD HL, HL
395   5EF2 C9           	RET
396   5EF3              ; ****************************************************************************************************
397   5EF3
398   5EF3              ; ****************************************************************************************************
399   5EF3              ; function gets slot and subslot data for specific page
400   5EF3              ; input A=page (0, 1 or 2)
401   5EF3              ; output B = 0A8H register value
402   5EF3              ; output D = 0 is no subslots, 1 if yes
403   5EF3              ; output C = 0A8H value when page 3 slot equals to requested page slot
404   5EF3              ; output E = subslot value if present
405   5EF3              ; modifies AF, BC, DE, HL
406   5EF3              GET_PAGE_INFO:
407   5EF3 6F               LD L, A
408   5EF4 C6 C1            ADD A, low (EXPTBL)
409   5EF6 32 00 5F         LD (GET_PAGE_INFO_L1+1), A
410   5EF9 DB A8            IN A, (0A8H)
411   5EFB 47               LD B, A
412   5EFC E6 3F            AND 03FH
413   5EFE 4F               LD C, A
414   5EFF              GET_PAGE_INFO_L1:
415   5EFF 3A C1 FC         LD A, (EXPTBL) ; modified by code above
416   5F02 E6 80            AND 080H
417   5F04 28 1B            JR Z, GET_PAGE_INFO_L2
418   5F06                  ; expanded
419   5F06 2D               DEC L
420   5F07 FA 26 5F         JP M, GET_PAGE_INFO_L3
421   5F0A 2D               DEC L
422   5F0B FA 24 5F         JP M, GET_PAGE_INFO_L4
423   5F0E                  ; page 2
424   5F0E 07               RLCA
425   5F0F 07               RLCA
426   5F10              GET_PAGE_INFO_L5:
427   5F10 E6 C0            AND 0C0H
428   5F12 B1               OR C
429   5F13 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
430   5F15 4F               LD C, A
431   5F16 3A FF FF         LD A, (0FFFFH)
432   5F19 2F               CPL
433   5F1A 5F               LD E, A
434   5F1B 16 01            LD D, 1
435   5F1D 78               LD A, B ; return stack
436   5F1E D3 A8            OUT (0A8H), A
437   5F20 C9               RET
438   5F21              GET_PAGE_INFO_L2:
439   5F21                  ; not expanded
440   5F21 16 00            LD D, 0
441   5F23 C9               RET
442   5F24              GET_PAGE_INFO_L4:
443   5F24                  ; page 1
444   5F24 0F               RRCA
445   5F25 0F               RRCA
446   5F26              GET_PAGE_INFO_L3:
447   5F26                  ; page 0
448   5F26 0F               RRCA
449   5F27 0F               RRCA
450   5F28 18 E6            JR GET_PAGE_INFO_L5
451   5F2A              ; ****************************************************************************************************
452   5F2A
453   5F2A              ; ****************************************************************************************************
454   5F2A              ; function returns original slot and subslot info
455   5F2A              ; input B = 0A8H register value
456   5F2A              ; input D = 0 is no subslots, 1 if yes
457   5F2A              ; input C = 0A8H value when page 3 slot equals to requested page slot
458   5F2A              ; input E = subslot value if present
459   5F2A              ; modifies AF, disables interrupts
460   5F2A              RESTORE_PAGE_INFO:
461   5F2A 7A               LD A, D
462   5F2B B7               OR A
463   5F2C 28 08            JR Z, RESTORE_PAGE_INFO_L1
464   5F2E 79               LD A, C
465   5F2F F3           	DI
466   5F30 D3 A8            OUT (0A8H), A
467   5F32 7B               LD A, E
468   5F33 32 FF FF         LD (0FFFFH), A
469   5F36              RESTORE_PAGE_INFO_L1:
470   5F36 78               LD A, B
471   5F37 D3 A8            OUT (0A8H), A
472   5F39 C9               RET
473   5F3A              ; ****************************************************************************************************
474   5F3A
475   5F3A              ; *******************************************************************************************************
476   5F3A              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
477   5F3A              ; INPUT:  A = SLOT ID: EXXXSSPP
478   5F3A              ; E = EXPANDED FLAG
479   5F3A              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
480   5F3A              ; PP = PRIMARY SLOT NUMBER
481   5F3A              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
482   5F3A              ; CHANGES: AF, BC, DE
483   5F3A
484   5F3A              LOCAL_ENASLT:
485   5F3A CD 5A 5F         CALL L0353
486   5F3D FA 47 5F         JP M, L0340
487   5F40 DB A8            IN A, (0A8H)
488   5F42 A1               AND C
489   5F43 B0               OR B
490   5F44 D3 A8            OUT (0A8H), A
491   5F46 C9               RET
492   5F47              L0340:
493   5F47 E5               PUSH HL
494   5F48 CD 7F 5F         CALL L0378
495   5F4B 4F               LD C, A
496   5F4C 06 00            LD B, 0
497   5F4E 7D               LD A, L
498   5F4F A4               AND H
499   5F50 B2               OR D
500   5F51 21 C5 FC         LD HL, 0FCC5H
501   5F54 09               ADD HL, BC
502   5F55 77               LD (HL), A
503   5F56 E1               POP HL
504   5F57 79               LD A, C
505   5F58 18 E0            JR LOCAL_ENASLT
506   5F5A              L0353:
507   5F5A F3               DI
508   5F5B F5               PUSH AF
509   5F5C 7C               LD A, H
510   5F5D 07               RLCA
511   5F5E 07               RLCA
512   5F5F E6 03            AND 3
513   5F61 5F               LD E, A
514   5F62 3E C0            LD A, 0C0H
515   5F64              L035D:
516   5F64 07               RLCA
517   5F65 07               RLCA
518   5F66 1D               DEC E
519   5F67 F2 64 5F         JP P, L035D
520   5F6A 5F               LD E, A
521   5F6B 2F               CPL
522   5F6C 4F               LD C, A
523   5F6D F1               POP AF
524   5F6E F5               PUSH AF
525   5F6F E6 03            AND 3
526   5F71 3C               INC A
527   5F72 47               LD B, A
528   5F73 3E AB            LD A, 0ABH
529   5F75              L036E:
530   5F75 C6 55            ADD A, 055H
531   5F77 10 FC            DJNZ L036E
532   5F79 57               LD D, A
533   5F7A A3               AND E
534   5F7B 47               LD B, A
535   5F7C F1               POP AF
536   5F7D A7               AND A
537   5F7E C9               RET
538   5F7F              L0378:
539   5F7F F5               PUSH AF
540   5F80 7A               LD A, D
541   5F81 E6 C0            AND 0C0H
542   5F83 4F               LD C, A
543   5F84 F1               POP AF
544   5F85 F5               PUSH AF
545   5F86 57               LD D, A
546   5F87 DB A8            IN A, (0A8H)
547   5F89 47               LD B, A
548   5F8A E6 3F            AND 03FH
549   5F8C B1               OR C
550   5F8D D3 A8            OUT (0A8H), A
551   5F8F 7A               LD A, D
552   5F90 0F               RRCA
553   5F91 0F               RRCA
554   5F92 E6 03            AND 3
555   5F94 57               LD D, A
556   5F95 3E AB            LD A, 0ABH
557   5F97              L0390:
558   5F97 C6 55            ADD A, 055H
559   5F99 15               DEC D
560   5F9A F2 97 5F         JP P, L0390
561   5F9D A3               AND E
562   5F9E 57               LD D, A
563   5F9F 7B               LD A, E
564   5FA0 2F               CPL
565   5FA1 67               LD H, A
566   5FA2 3A FF FF         LD A, (0FFFFH)
567   5FA5 2F               CPL
568   5FA6 6F               LD L, A
569   5FA7 A4               AND H
570   5FA8 B2               OR D
571   5FA9 32 FF FF         LD (0FFFFH), A
572   5FAC 78               LD A, B
573   5FAD D3 A8            OUT (0A8H), A
574   5FAF F1               POP AF
575   5FB0 E6 03            AND 3
576   5FB2 C9               RET
577   5FB3              ; *******************************************************************************************************
578   5FB3
579   5FB3              ; *******************************************************************************************************
580   5FB3              ; some common code to activate page 0 and place values needed to restore original page on stack
581   5FB3              ; input IY=return address
582   5FB3              ENABLE_PAGE0:
583   5FB3 AF               XOR A
584   5FB4 CD F3 5E         CALL GET_PAGE_INFO
585   5FB7 C5               PUSH BC
586   5FB8 D5               PUSH DE
587   5FB9 3A 41 F3         LD A, (RAMAD0)
588   5FBC 26 00            LD H, 0
589   5FBE CD 3A 5F         CALL LOCAL_ENASLT
590   5FC1 FD E9        	JP (IY)
591   5FC3              ; *******************************************************************************************************
592   5FC3
593   5FC3              ; General BASIC CALL-instruction handler
594   5FC3              CALLHAND:
595   5FC3 E5           	PUSH HL
596   5FC4 21 50 5D     	LD	HL, CMDS ; pointer table based on starting letter
597   5FC7 3A 89 FD         LD A, (PROCNM)
598   5FCA D6 41            SUB 'A'
599   5FCC 87               ADD A, A
600   5FCD 16 00            LD D, 0
601   5FCF 5F               LD E, A
602   5FD0 19               ADD HL, DE
603   5FD1 5E               LD E, (HL)
604   5FD2 23               INC HL
605   5FD3 56               LD D, (HL)
606   5FD4 7A               LD A, D
607   5FD5 B3               OR E
608   5FD6 28 23            JR Z, .CMDNOTRECOGNIZED
609   5FD8 EB               EX DE, HL
610   5FD9              .CHKCMD:
611   5FD9 11 89 FD     	LD	DE, PROCNM
612   5FDC 1A           .LOOP:	LD	A,(DE)
613   5FDD BE           	CP	(HL)
614   5FDE 20 11        	JR	NZ,.TONEXTCMD	; Not equal
615   5FE0 13           	INC	DE
616   5FE1 23           	INC	HL
617   5FE2 A7           	AND	A
618   5FE3 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
619   5FE5 5E           	LD	E,(HL)
620   5FE6 23           	INC	HL
621   5FE7 56           	LD	D,(HL)
622   5FE8 E1           	POP	HL		; routine address
623   5FE9 CD 0A 60     	CALL	GETPREVCHAR
624   5FEC CD FE 5F     	CALL	.CALLDE		; Call routine
625   5FEF A7           	AND	A
626   5FF0 C9           	RET
627   5FF1
628   5FF1              .TONEXTCMD:
629   5FF1 0E FF        	LD	C,0FFH
630   5FF3 AF           	XOR	A
631   5FF4 ED B1        	CPIR			; Skip to end of instruction name
632   5FF6 23           	INC	HL
633   5FF7 23           	INC	HL		; Skip address
634   5FF8 BE           	CP	(HL)
635   5FF9 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
636   5FFB              .CMDNOTRECOGNIZED:
637   5FFB E1           	POP	HL
638   5FFC 37               SCF
639   5FFD C9           	RET
640   5FFE
641   5FFE              .CALLDE:
642   5FFE D5           	PUSH	DE
643   5FFF C9           	RET
644   6000
645   6000              ;---------------------------
646   6000
647   6000              ;GETSTRPNT:
648   6000              ; OUT:
649   6000              ; HL = String Address
650   6000              ; B  = Lenght
651   6000              ;        LD      HL,(USR)
652   6000              ;        LD      B,(HL)
653   6000              ;        INC     HL
654   6000              ;        LD      E,(HL)
655   6000              ;        INC     HL
656   6000              ;        LD      D,(HL)
657   6000              ;        EX      DE,HL
658   6000              ;        RET
659   6000
660   6000              ;EVALTXTPARAM:
661   6000              ;	CALL	CHKCHAR
662   6000              ;	DEFB	"("             ; Check for (
663   6000              ;	LD	IX,FRMEVL
664   6000              ;	CALL	CALBAS		; Evaluate expression
665   6000              ;       LD      A,(VALTYP)
666   6000              ;        CP      3               ; Text type?
667   6000              ;        JP      NZ,TYPE_MISMATCH
668   6000              ;        PUSH	HL
669   6000              ;        LD	IX,FRESTR         ; Free the temporary string
670   6000              ;        CALL	CALBAS
671   6000              ;        POP	HL
672   6000              ;	CALL	CHKCHAR
673   6000              ;	DEFB	")"             ; Check for )
674   6000              ;        RET
675   6000
676   6000
677   6000              CHKCHAR:
678   6000 CD 0A 60     	CALL	GETPREVCHAR	; Get previous basic char
679   6003 E3           	EX	(SP),HL
680   6004 BE           	CP	(HL) 	        ; Check if good char
681   6005 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
682   6007 23           	INC	HL
683   6008 E3           	EX	(SP),HL
684   6009 23           	INC	HL		; Get next basic char
685   600A
686   600A              GETPREVCHAR:
687   600A 2B           	DEC	HL
688   600B DD 21 66 46  	LD	IX,CHRGTR
689   600F C3 59 01     	JP      CALBAS
690   6012
691   6012
692   6012              TYPE_MISMATCH:
693   6012 1E 0D            LD E, 13 ; Type mismatch
694   6014 18 0A            JR THROW_ERROR
695   6016              SUBSCRIPT_OUT_OF_RANGE:
696   6016 1E 09            LD E,9 ; subscript out of range
697   6018 18 06        	JR THROW_ERROR
698   601A              OVERFLOW:
699   601A 1E 06        	LD E,6
700   601C 18 02        	JR THROW_ERROR
701   601E              SYNTAX_ERROR:
702   601E 1E 02            LD E, 2 ; Syntax error
703   6020              THROW_ERROR:
704   6020 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
705   6024 C3 59 01     	JP	CALBAS
706   6027
707   6027              ;---------------------------
708   6027
709   6027              ; *******************************************************************************************************
710   6027              ; helper function to get pointer to BASIC array data
711   6027              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
712   6027              ; input B=dimensions (1 or 2)
713   6027              ; input D=minimal first dimension
714   6027              ; input E=minimal second dimension, if applicable
715   6027              ; returns BC=pointer to first data element
716   6027              ; throws BASIC error if invalid type
717   6027              GET_BASIC_ARRAY_DATA_POINTER:
718   6027 D5           	PUSH DE
719   6028 C5           	PUSH BC
720   6029 F5           	PUSH AF
721   602A 3E 01            LD A,1
722   602C 32 A5 F6         LD (SUBFLG),A ; search for arrays only
723   602F DD 21 A4 5E  	LD IX, PTRGET
724   6033 CD 59 01     	CALL CALBAS
725   6036 AF               XOR A
726   6037 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
727   603A 3A 63 F6     	LD A,(VALTYP)
728   603D D1           	POP DE ; required type
729   603E BA           	CP D
730   603F C2 12 60     	JP NZ,TYPE_MISMATCH
731   6042 0A           	LD A,(BC)
732   6043 03           	INC BC
733   6044 D1           	POP DE ; required number of dimensions
734   6045 BA           	CP D
735   6046 C2 12 60     	JP NZ,TYPE_MISMATCH
736   6049 D1           	POP DE ; required minimal array dimensions
737   604A 3D           	DEC A
738   604B 28 07        	JR Z,.ONE_DIMENSION
739   604D              	; 2-dimension array
740   604D 0A           	LD A,(BC)
741   604E 03          > INC BC
741   604F 03          > INC BC
742   6050 BB           	CP E
743   6051 DA 16 60     	JP C,SUBSCRIPT_OUT_OF_RANGE
744   6054              .ONE_DIMENSION:
745   6054 0A           	LD A,(BC)
746   6055 03          > INC BC
746   6056 03          > INC BC
747   6057 BA           	CP D
748   6058 DA 16 60     	JP C,SUBSCRIPT_OUT_OF_RANGE
749   605B C9           	RET
750   605C              ; *******************************************************************************************************
751   605C
752   605C              EXT_END:
753   605C
# file closed: asm\main.asm
