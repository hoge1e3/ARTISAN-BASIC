# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		   EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000              BYTEOPS_CMDS   EQU 0
 14   4000              COLL_CMD       EQU 1
 15   4000
 16   4000               DEFINE CMDS_WITH_PARAMETERS
 17   4000
 18   4000              CHPUT   EQU     #A2
 19   4000              CALBAS	EQU		#159
 20   4000              ERRHAND EQU     #406F
 21   4000              FRMEVL  EQU     #4C64
 22   4000              FRESTR	EQU		#67D0
 23   4000              ; FRMQNT = formula quantificator
 24   4000              ; input HL=pointer to current program expression
 25   4000              ; output HL=next address
 26   4000              ; output DE=integer datum
 27   4000              FRMQNT	EQU		#542F
 28   4000              ; GETBYT = get byte parameter
 29   4000              ; input HL=pointer to current program expression
 30   4000              ; output HL=next address
 31   4000              ; output A=E=byte read
 32   4000              GETBYT		EQU	#521C
 33   4000              CHRGTR  	   EQU   #4666
 34   4000              PTRGET		EQU 	#5EA4
 35   4000              SUBFLG		EQU	#F6A5
 36   4000              SYNCHR		EQU	#558C
 37   4000              VALTYP  	   EQU   #F663
 38   4000              DAC         EQU   #F7F6
 39   4000              USR     	   EQU   #F7F8
 40   4000              PROCNM		EQU	#FD89
 41   4000              BIOS_FILVRM EQU   #0056
 42   4000              CLIKSW		EQU	#F3DB
 43   4000              ATRBAS		EQU	#F928
 44   4000              GRPCGP		EQU	#F3CB
 45   4000
 46   4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 47   4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 48   4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 49   4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 50   4000              EXPTBL	   EQU   #FCC1
 51   4000              SCRMOD	   EQU   #FCAF ; current screen mode
 52   4000              REG1SAV     EQU   #F3E0 ; VDP(1)
 53   4000              JIFFY	      EQU   #FC9E
 54   4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
 55   4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
 56   4000              PATBAS      EQU   #F926 ; current sprite generator table address
 57   4000              CGPBAS      EQU   #F924 ; current pattern generator table address
 58   4000
 59   4000              ; BASIC error codes
 60   4000              ;01 NEXT without FOR
 61   4000              ;02 Syntax error
 62   4000              ;03 RETURN without GOSUB
 63   4000              ;04 Out of DATA
 64   4000              ;05 Illegal function call
 65   4000              ;06 Overflow
 66   4000              ;07 Out of memory
 67   4000              ;08 Undefined line number
 68   4000              ;09 Subscript out of range
 69   4000              ;10 Redimensioned array
 70   4000              ;11 Division by zero
 71   4000              ;12 Illegal direct
 72   4000              ;13 Type mismatch
 73   4000              ;14 Out of string space
 74   4000              ;15 String too long
 75   4000              ;16 String formula too complex
 76   4000              ;17 Can't CONTINUE
 77   4000              ;18 Undefined user function
 78   4000              ;19 Device I/O error
 79   4000              ;20 Verify error
 80   4000              ;21 No RESUME
 81   4000              ;22 RESUME without error
 82   4000              ;23 Unprintable error
 83   4000              ;24 Missing operand
 84   4000              ;25 Line buffer overflow
 85   4000              ;50 FIELD overflow
 86   4000              ;51 Internal error
 87   4000              ;52 Bad file number
 88   4000              ;53 File not found
 89   4000              ;54 File already open
 90   4000              ;55 Input past end
 91   4000              ;56 Bad file name
 92   4000              ;57 Direct statement in file
 93   4000              ;58 Sequential I/O only
 94   4000              ;59 File not OPEN
 95   4000
 96   4000
 97   4000               ; simulate cartridge with BASIC extension
 98   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 98   4004 97 60 00 00
 98   4008 00 00 00 00
 98   400C 00 00 00 00
 99   4010
100   4010              ; this location #4010 stores last location used by basic extension
101   4010              ; free memory after that point
102   4010              FREEMEMPTR:
103   4010 34 61         DW EXT_END
104   4012
105   4012              ; this location #4012 stores extension version in DAA format
106   4012              ; first byte is major version and second minor
107   4012              VERSION:
108   4012 00 70         DB #00, #70
109   4014
110   4014              ; binary included AKG player compiled at #4014
111   4014               IF (SOUND_CMDS == 1)
112   4014              	INCBIN "bin/AKG.bin"
113   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
114   4CF0               ENDIF
115   4CF0
116   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A 11 56     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD C7 5F         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD 0E 60         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD C7 5F         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD 0E 60         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A 11 56     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD FE 5F         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD FE 5F         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A 1C 5E         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD C2 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
117   4D73
118   4D73               IF (SPRITE_CMDS == 1)
119   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD C3 5F         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D95 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D98 B7           	OR A
 55+  4D99 28 03        	JR Z, .L3
 56+  4D9B 3A 79 4D     	LD A, (FLICKER)
 57+  4D9E              .L3:
 58+  4D9E 5F           	LD E, A
 59+  4D9F 08           	EX AF, AF'
 60+  4DA0 7B           	LD A, E
 61+  4DA1 87           	ADD A, A
 62+  4DA2 87           	ADD A, A
 63+  4DA3 16 00        	LD D, 0
 64+  4DA5 5F           	LD E, A
 65+  4DA6 19           	ADD HL, DE
 66+  4DA7 CD AE 5F     	CALL SETWRT_LOCAL
 67+  4DAA ED 73 7A 4D  	LD (TMPSP), SP
 68+  4DAE ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 69+  4DB2
 70+  4DB2              .LOOP:
 71+  4DB2 E1           	POP HL
 72+  4DB3 24           	INC H
 73+  4DB4 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DB6 25           	DEC H
 75+  4DB7 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DB9 7D           	LD A, L
 77+  4DBA FE C0        	CP 192
 78+  4DBC 30 10        	JR NC, .OUT3
 79+  4DBE 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DBF 57           	LD D, A
 81+  4DC0 C3 E7 4D     	JP .X
 82+  4DC3              .L1:
 83+  4DC3 7D           	LD A, L
 84+  4DC4 C6 10        	ADD 16
 85+  4DC6 FA CE 4D     	JP M, .OUT3 ; below -16
 86+  4DC9 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DCA 55           	LD D, L
 88+  4DCB C3 E7 4D     	JP .X
 89+  4DCE              .OUT3:
 90+  4DCE E1           	POP HL ; skip x value
 91+  4DCF              .OUT2:
 92+  4DCF E1           	POP HL ; skip pattern
 93+  4DD0 E1           	POP HL ; skip color
 94+  4DD1 3E D1        	LD A, #D1
 95+  4DD3 ED 79        	OUT (C), A ; sprite hidden
 96+  4DD5 00          > NOP
 96+  4DD6 00          > NOP
 96+  4DD7 00          > NOP
 97+  4DD8 ED 79        	OUT (C), A ; value unimportant
 98+  4DDA 00          > NOP
 98+  4DDB 00          > NOP
 98+  4DDC 00          > NOP
 99+  4DDD ED 79        	OUT (C), A ; value unimportant
100+  4DDF 00          > NOP
100+  4DE0 00          > NOP
100+  4DE1 00          > NOP
101+  4DE2 ED 79        	OUT (C), A ; value unimportant
102+  4DE4 C3 12 4E     	JP .NEXT
103+  4DE7              .X:
104+  4DE7 E1           	POP HL
105+  4DE8 24           	INC H
106+  4DE9 28 08        	JR Z, .L2
107+  4DEB 25           	DEC H
108+  4DEC 20 E1        	JR NZ, .OUT2
109+  4DEE 1E 00        	LD E, 0 ; EC bit
110+  4DF0 C3 FC 4D     	JP .XY
111+  4DF3              .L2:
112+  4DF3 7D           	LD A, L
113+  4DF4 C6 20        	ADD 32
114+  4DF6 FA CF 4D     	JP M, .OUT2
115+  4DF9 6F           	LD L, A
116+  4DFA 1E 80        	LD E, #80
117+  4DFC              .XY:
118+  4DFC ED 51        	OUT (C), D
119+  4DFE 3A E0 F3     	LD A, (REG1SAV)
120+  4E01 E6 02        	AND 2
121+  4E03 ED 69        	OUT (C), L
122+  4E05 E1           	POP HL ; pattern
123+  4E06 7D           	LD A, L
124+  4E07 28 02        	JR Z, .SMALLSPRITES
125+  4E09 87           	ADD A, A
126+  4E0A 87           	ADD A, A ; needs to go at 4x
127+  4E0B              .SMALLSPRITES:
128+  4E0B D3 98        	OUT (#98), A
129+  4E0D E1           	POP HL ; color
130+  4E0E 7D           	LD A, L
131+  4E0F B3           	OR E
132+  4E10 D3 98        	OUT (#98), A
133+  4E12              .NEXT:
134+  4E12 08           	EX AF, AF'
135+  4E13 3C           	INC A
136+  4E14 E6 1F        	AND 31
137+  4E16 C2 2A 4E     	JP NZ, .NEXT2
138+  4E19 08           	EX AF, AF'
139+  4E1A 2A 28 F9     	LD HL, (ATRBAS)
140+  4E1D              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E1D 7D           	LD	A, L
142+  4E1E D3 99        	OUT	(099H), A
143+  4E20 7C           	LD	A, H
144+  4E21 E6 3F        	AND	03FH
145+  4E23 F6 40        	OR	040H
146+  4E25 D3 99        	OUT	(099H), A
147+  4E27 C3 2B 4E     	JP .NEXT3
148+  4E2A              .NEXT2:
149+  4E2A 08           	EX AF, AF'
150+  4E2B              .NEXT3:
151+  4E2B 10 85        	DJNZ .LOOP
152+  4E2D 08           	EX AF, AF'
153+  4E2E 3C           	INC A
154+  4E2F 32 79 4D     	LD (FLICKER), A
155+  4E32
156+  4E32 ED 7B 7A 4D  	LD SP, (TMPSP)
157+  4E36 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E39 36 00        	LD (HL), 0 ; zero out update flag
159+  4E3B C9           	RET
160+  4E3C              ; *******************************************************************************************************
161+  4E3C
162+  4E3C              ; *******************************************************************************************************
163+  4E3C              ; function to handle CALL SPRENABLE basic extension
164+  4E3C              ; initializes sprites handler
165+  4E3C              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E3C              ;			   INT update_variable,
167+  4E3C              ;			   BYTE sprite_flicker_enabled )
168+  4E3C              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E3C              SPRENABLE:
170+  4E3C              	; opening (
171+  4E3C CD D4 60     	CALL CHKCHAR
172+  4E3F 28           	DB '('
173+  4E40              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E40 3E 02        	LD A,2
175+  4E42 06 02        	LD B,2
176+  4E44 11 20 04     	LD DE,#0420
177+  4E47 CD FF 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E4A C5           	PUSH BC
179+  4E4B              	; comma
180+  4E4B CD D4 60     	CALL CHKCHAR
181+  4E4E 2C           	DB ','
182+  4E4F              	; get address of sprite update flag
183+  4E4F DD 21 A4 5E  	LD IX, PTRGET
184+  4E53 CD 59 01     	CALL CALBAS
185+  4E56 D5           	PUSH DE
186+  4E57              	; comma
187+  4E57 CD D4 60     	CALL CHKCHAR
188+  4E5A 2C           	DB ','
189+  4E5B              	; get flicker enabled flag
190+  4E5B DD 21 1C 52  	LD IX, GETBYT
191+  4E5F CD 59 01     	CALL CALBAS
192+  4E62 F5           	PUSH AF
193+  4E63              	; ending )
194+  4E63 CD D4 60     	CALL CHKCHAR
195+  4E66 29           	DB ')'
196+  4E67
197+  4E67 F1           	POP AF ; get flicker flag
198+  4E68 B7           	OR A
199+  4E69 32 78 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E6C
201+  4E6C D1           	POP DE ; update variable location
202+  4E6D ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E71 D1           	POP DE ; address of sprite attribute table
204+  4E72 ED 53 76 4D  	LD (SPRATR_DATA), DE
205+  4E76 3E 01        	LD A, 1
206+  4E78 32 73 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E7B C9           	RET
208+  4E7C              ; *******************************************************************************************************
209+  4E7C
210+  4E7C              ; *******************************************************************************************************
211+  4E7C              ; function to handle CALL SPRDISABLE basic extension
212+  4E7C              ; disables sprites handling
213+  4E7C              ; _SPRDISABLE
214+  4E7C              ; resets variable SPRATR_INIT_STATUS
215+  4E7C              SPRDISABLE:
216+  4E7C AF           	XOR A
217+  4E7D 32 73 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E80 C9           	RET
219+  4E81              ; *******************************************************************************************************
220+  4E81
221+  4E81              ; *******************************************************************************************************
222+  4E81              ; function to handle CALL SPRSET basic extension
223+  4E81              ; sets position, and optionally pattern and color of sprite
224+  4E81              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E81              ;			INT x,
226+  4E81              ;			INT y,
227+  4E81              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E81              ;			INT color, valid 0-15, otherwise ignored
229+  4E81              SPRSET:
230+  4E81 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E84 B7           	OR A
232+  4E85 20 05        	JR NZ, .L1
233+  4E87 1E 05        	LD E, 5 ; illegal function call
234+  4E89 C3 F8 60     	JP THROW_ERROR
235+  4E8C              .L1:
236+  4E8C              	; opening (
237+  4E8C CD D4 60     	CALL CHKCHAR
238+  4E8F 28           	DB '('
239+  4E90              	; get sprite number
240+  4E90 DD 21 1C 52  	LD IX, GETBYT
241+  4E94 CD 59 01     	CALL CALBAS
242+  4E97 F5           	PUSH AF
243+  4E98              	; comma
244+  4E98 CD D4 60     	CALL CHKCHAR
245+  4E9B 2C           	DB ','
246+  4E9C              	; get x
247+  4E9C DD 21 2F 54  	LD IX, FRMQNT
248+  4EA0 CD 59 01     	CALL CALBAS
249+  4EA3 D5           	PUSH DE
250+  4EA4              	; comma
251+  4EA4 CD D4 60     	CALL CHKCHAR
252+  4EA7 2C           	DB ','
253+  4EA8              	; get y
254+  4EA8 DD 21 2F 54  	LD IX, FRMQNT
255+  4EAC CD 59 01     	CALL CALBAS
256+  4EAF D5           	PUSH DE
257+  4EB0              	; comma
258+  4EB0 CD D4 60     	CALL CHKCHAR
259+  4EB3 2C           	DB ','
260+  4EB4              	; get pattern
261+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
262+  4EB8 CD 59 01     	CALL CALBAS
263+  4EBB D5           	PUSH DE
264+  4EBC              	; comma
265+  4EBC CD D4 60     	CALL CHKCHAR
266+  4EBF 2C           	DB ','
267+  4EC0              	; get color
268+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
269+  4EC4 CD 59 01     	CALL CALBAS
270+  4EC7 D5           	PUSH DE
271+  4EC8              	; ending )
272+  4EC8 CD D4 60     	CALL CHKCHAR
273+  4ECB 29           	DB ')'
274+  4ECC
275+  4ECC                  ; save position in BASIC text
276+  4ECC E5           	PUSH HL
277+  4ECD DD E1        	POP IX
278+  4ECF
279+  4ECF C1           	POP BC ; color
280+  4ED0 D1           	POP DE ; pattern
281+  4ED1 D9           	EXX
282+  4ED2 C1           	POP BC ; y
283+  4ED3 D1           	POP DE ; x
284+  4ED4 F1           	POP AF ; sprite number
285+  4ED5 FE 20        	CP 32
286+  4ED7 38 05        	JR C, .L2
287+  4ED9 1E 05        	LD E, 5 ; illegal function call
288+  4EDB C3 F8 60     	JP THROW_ERROR
289+  4EDE              .L2:
290+  4EDE              	; find location in sprite attributes table
291+  4EDE D5           	PUSH DE
292+  4EDF CD 7C 4D     	CALL GETnthSPRATTR
293+  4EE2 D1           	POP DE
294+  4EE3              	; set y
295+  4EE3 71           	LD (HL), C
296+  4EE4 23           	INC HL
297+  4EE5 70           	LD (HL), B
298+  4EE6 23           	INC HL
299+  4EE7              	; set x
300+  4EE7 73           	LD (HL), E
301+  4EE8 23           	INC HL
302+  4EE9 72           	LD (HL), D
303+  4EEA 23           	INC HL
304+  4EEB E5           	PUSH HL
305+  4EEC D9           	EXX
306+  4EED E1           	POP HL
307+  4EEE              	; check if 0<=pattern<64
308+  4EEE 7A           	LD A, D
309+  4EEF B7           	OR A
310+  4EF0 20 0B        	JR NZ, .L3
311+  4EF2 7B           	LD A, E
312+  4EF3 FE 40        	CP 64
313+  4EF5 30 06        	JR NC, .L3
314+  4EF7              	; set pattern
315+  4EF7              	;ADD A, A
316+  4EF7              	;ADD A, A
317+  4EF7              	;ADD A, A
318+  4EF7 77           	LD (HL), A
319+  4EF8 23           	INC HL
320+  4EF9 72           	LD (HL), D
321+  4EFA 23           	INC HL
322+  4EFB 18 02        	JR .L4
323+  4EFD              .L3:
324+  4EFD              	; skip pattern
325+  4EFD 23          > INC HL
325+  4EFE 23          > INC HL
326+  4EFF              .L4:
327+  4EFF              	; check if 0<=color<16
328+  4EFF 78           	LD A, B
329+  4F00 B7           	OR A
330+  4F01 20 08        	JR NZ, .L5
331+  4F03 79           	LD A, C
332+  4F04 FE 10        	CP 16
333+  4F06 30 03        	JR NC, .L5
334+  4F08              	; set color
335+  4F08 71           	LD (HL), C
336+  4F09 23           	INC HL
337+  4F0A 70           	LD (HL), B
338+  4F0B
339+  4F0B              .L5:
340+  4F0B DD E5        	PUSH IX
341+  4F0D E1           	POP HL
342+  4F0E C9           	RET
343+  4F0F              ; *******************************************************************************************************
344+  4F0F
345+  4F0F              ; *******************************************************************************************************
346+  4F0F              ; function sets sprite location based on initial coordinates and offset provided
347+  4F0F              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F0F              ; input DE=initial x
349+  4F0F              ; input BC=initial y
350+  4F0F              ; input IY=location where delta y,x are located
351+  4F0F              ; modifies AF, HL, IX
352+  4F0F              SPRSET_DELTA_POS:
353+  4F0F D5           	PUSH DE
354+  4F10 CD 7C 4D     	CALL GETnthSPRATTR
355+  4F13 E5           	PUSH HL
356+  4F14 DD E1        	POP IX
357+  4F16 D1           	POP DE
358+  4F17              	; IX=sprite's y location
359+  4F17 FD 6E 00     	LD L, (IY)
360+  4F1A FD 66 01     	LD H, (IY+1)
361+  4F1D 09           	ADD HL, BC
362+  4F1E DD 75 00     	LD (IX), L
363+  4F21 DD 74 01     	LD (IX+1), H
364+  4F24 FD 6E 02     	LD L, (IY+2)
365+  4F27 FD 66 03     	LD H, (IY+3)
366+  4F2A 19           	ADD HL, DE
367+  4F2B DD 75 02     	LD (IX+2), L
368+  4F2E DD 74 03     	LD (IX+3), H
369+  4F31 C9           	RET
370+  4F32              ; *******************************************************************************************************
371+  4F32
372+  4F32              ; *******************************************************************************************************
373+  4F32              ; function to handle CALL SPRGRPMOV basic extension
374+  4F32              ; sets position of a group of sprites described with
375+  4F32              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F32              ; _SPRGRPMOV ( INT x,
377+  4F32              ;			   INT y,
378+  4F32              ;			   BYTE count,
379+  4F32              ;			   INT[2][count] data_ptr
380+  4F32              ; will put ram in page 0 also, page 1 is already there
381+  4F32              SPRGRPMOV:
382+  4F32 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F35 B7           	OR A
384+  4F36 CA F2 60     	JP Z,ILLEGAL_FUNCTION
385+  4F39              	; opening (
386+  4F39 CD D4 60     	CALL CHKCHAR
387+  4F3C 28           	DB '('
388+  4F3D              	; get x
389+  4F3D DD 21 2F 54  	LD IX, FRMQNT
390+  4F41 CD 59 01     	CALL CALBAS
391+  4F44 D5           	PUSH DE
392+  4F45              	; comma
393+  4F45 CD D4 60     	CALL CHKCHAR
394+  4F48 2C           	DB ','
395+  4F49              	; get y
396+  4F49 DD 21 2F 54  	LD IX, FRMQNT
397+  4F4D CD 59 01     	CALL CALBAS
398+  4F50 D5           	PUSH DE
399+  4F51              	; comma
400+  4F51 CD D4 60     	CALL CHKCHAR
401+  4F54 2C           	DB ','
402+  4F55              	; get count
403+  4F55 DD 21 1C 52  	LD IX, GETBYT
404+  4F59 CD 59 01     	CALL CALBAS
405+  4F5C F5           	PUSH AF
406+  4F5D              	; comma
407+  4F5D CD D4 60     	CALL CHKCHAR
408+  4F60 2C           	DB ','
409+  4F61              	; get sprite group definition array data pointer
410+  4F61 D1           	POP DE
411+  4F62 D5           	PUSH DE
412+  4F63 5A           	LD E,D
413+  4F64 16 03        	LD D,3
414+  4F66 3E 02        	LD A,2
415+  4F68 47           	LD B,A
416+  4F69 CD FF 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
417+  4F6C C5           	PUSH BC
418+  4F6D              	; ending )
419+  4F6D CD D4 60     	CALL CHKCHAR
420+  4F70 29           	DB ')'
421+  4F71
422+  4F71 E5           	PUSH HL
423+  4F72 DD E1        	POP IX
424+  4F74
425+  4F74 E1           	POP HL ; data pointer
426+  4F75 C1           	POP BC ; count
427+  4F76 D9           	EXX
428+  4F77 C1           	POP BC ; y
429+  4F78 D1           	POP DE ; x
430+  4F79 D9           	EXX
431+  4F7A
432+  4F7A DD E5        	PUSH IX ; save position in BASIC buffer
433+  4F7C
434+  4F7C C5           	PUSH BC
435+  4F7D E5           	PUSH HL
436+  4F7E AF               XOR A
437+  4F7F CD C7 5F         CALL GET_PAGE_INFO
438+  4F82 D9           	EXX
439+  4F83 E1           	POP HL
440+  4F84 F1           	POP AF
441+  4F85 D9           	EXX
442+  4F86 C5               PUSH BC
443+  4F87 D5               PUSH DE
444+  4F88 D9           	EXX
445+  4F89 F5           	PUSH AF
446+  4F8A E5           	PUSH HL
447+  4F8B D9           	EXX
448+  4F8C 3A 41 F3         LD A, (RAMAD0)
449+  4F8F 26 00            LD H, 0
450+  4F91 CD 0E 60         CALL LOCAL_ENASLT
451+  4F94 FB           	EI
452+  4F95 E1           	POP HL
453+  4F96 C1           	POP BC
454+  4F97 3E 01        	LD A,1
455+  4F99 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
456+  4F9C CD AA 4F     	CALL .UPDATE_LOC
457+  4F9F AF           	XOR A
458+  4FA0 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
459+  4FA3 D1               POP DE
460+  4FA4 C1               POP BC
461+  4FA5 CD FE 5F         CALL RESTORE_PAGE_INFO
462+  4FA8 E1           	POP HL
463+  4FA9 C9           	RET
464+  4FAA
465+  4FAA              .UPDATE_LOC:
466+  4FAA 7E           	LD A, (HL)
467+  4FAB 23           	INC HL
468+  4FAC 23           	INC HL
469+  4FAD E5           	PUSH HL
470+  4FAE FD E1        	POP IY
471+  4FB0 D9           	EXX
472+  4FB1 CD 0F 4F     	CALL SPRSET_DELTA_POS
473+  4FB4 D9           	EXX
474+  4FB5 23          > INC HL
474+  4FB6 23          > INC HL
474+  4FB7 23          > INC HL
474+  4FB8 23          > INC HL
475+  4FB9 10 EF        	DJNZ .UPDATE_LOC
476+  4FBB C9           	RET
477+  4FBC              ; *******************************************************************************************************
478+  4FBC
# file closed: asm\SPRITES.asm
120   4FBC               ENDIF
121   4FBC
122   4FBC               IF (ANIM_CMDS == 1)
123   4FBC               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FBC              ; sprite animation routines
  2+  4FBC
  3+  4FBC              ; number of animation items and pointer
  4+  4FBC              ANIMITEMNUM:
  5+  4FBC 00            DB 0
  6+  4FBD              ANIMITEMPTR:
  7+  4FBD 34 61         DW EXT_END
  8+  4FBF              ; number of animation definitions and pointer
  9+  4FBF              ANIMDEFNUM:
 10+  4FBF 00            DB 0
 11+  4FC0              ANIMDEFPTR:
 12+  4FC0 34 61         DW EXT_END
 13+  4FC2              ; number of links between sprite and animation definitions
 14+  4FC2              ANIMSPRNUM:
 15+  4FC2 00            DB 0
 16+  4FC3              ANIMSPRPTR:
 17+  4FC3 34 61         DW EXT_END
 18+  4FC5
 19+  4FC5              ; ANIMATION ITEM
 20+  4FC5              ; byte type = [0 - pattern and color change
 21+  4FC5              ;              1 - pattern definition change ]
 22+  4FC5              ; word ticks - number of ticks to hold this state
 23+  4FC5              ; for type = 0
 24+  4FC5              ;   byte pattern;
 25+  4FC5              ;   byte color;
 26+  4FC5              ; for type = 1
 27+  4FC5              ;   work data_pointer;
 28+  4FC5              ; total size = 5b
 29+  4FC5
 30+  4FC5              ; ANIMATION DEFINITION
 31+  4FC5              ; byte number of items 1-15
 32+  4FC5              ; byte[15] anim_item;
 33+  4FC5              ; total size = 16b
 34+  4FC5
 35+  4FC5              ; SPRITE/CHAR ANIMATION
 36+  4FC5              ; +00 byte sprite/char number;
 37+  4FC5              ; +01 word time;
 38+  4FC5              ; +03 byte current item;
 39+  4FC5              ; +04 byte animation definition;
 40+  4FC5              ; +05 byte cyclic;
 41+  4FC5              ; +06 byte active;
 42+  4FC5              ; +07 byte 0=sprite, 1-3 character bank
 43+  4FC5              ; total size = 8b
 44+  4FC5
 45+  4FC5              ; *******************************************************************************************************
 46+  4FC5              ; helper function HL=A*5
 47+  4FC5              ; changes HL,DE;
 48+  4FC5              Ax5:
 49+  4FC5 26 00            LD H,0
 50+  4FC7 6F               LD L,A
 51+  4FC8 54               LD D,H
 52+  4FC9 5D               LD E,L
 53+  4FCA 29               ADD HL,HL
 54+  4FCB 29               ADD HL,HL
 55+  4FCC 19               ADD HL,DE
 56+  4FCD C9               RET
 57+  4FCE              ; *******************************************************************************************************
 58+  4FCE
 59+  4FCE              ; *******************************************************************************************************
 60+  4FCE              ; helper function gets pointer to n-th animation item
 61+  4FCE              ; changes HL,DE;
 62+  4FCE              GETnthANIMITEM:
 63+  4FCE CD C5 4F         CALL Ax5
 64+  4FD1 ED 5B BD 4F      LD DE,(ANIMITEMPTR)
 65+  4FD5 19               ADD HL,DE
 66+  4FD6 C9               RET
 67+  4FD7              ; *******************************************************************************************************
 68+  4FD7
 69+  4FD7              ; *******************************************************************************************************
 70+  4FD7              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD7              ; changes HL,DE;
 72+  4FD7              GETnthANIMDEF:
 73+  4FD7 26 00            LD H,0
 74+  4FD9 6F               LD L,A
 75+  4FDA CD C2 5F         CALL HLx16
 76+  4FDD ED 5B C0 4F      LD DE,(ANIMDEFPTR)
 77+  4FE1 19               ADD HL,DE
 78+  4FE2 C9               RET
 79+  4FE3              ; *******************************************************************************************************
 80+  4FE3
 81+  4FE3              ; *******************************************************************************************************
 82+  4FE3              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FE3              ; changes HL,DE;
 84+  4FE3              GETnthSPRANIM:
 85+  4FE3 26 00            LD H,0
 86+  4FE5 6F               LD L,A
 87+  4FE6 CD C3 5F         CALL HLx8
 88+  4FE9 ED 5B C3 4F      LD DE,(ANIMSPRPTR)
 89+  4FED 19               ADD HL,DE
 90+  4FEE C9               RET
 91+  4FEF              ; *******************************************************************************************************
 92+  4FEF
 93+  4FEF              ; *******************************************************************************************************
 94+  4FEF              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FEF              ; MAXANIMITEMS (BYTE number)
 96+  4FEF              ; sets new number and moves memory buffers as needed
 97+  4FEF              MAXANIMITEMS:
 98+  4FEF              	; opening (
 99+  4FEF CD D4 60     	CALL CHKCHAR
100+  4FF2 28           	DB '('
101+  4FF3              	; get value
102+  4FF3 DD 21 1C 52  	LD IX, GETBYT
103+  4FF7 CD 59 01     	CALL CALBAS
104+  4FFA F5               PUSH AF
105+  4FFB              	; ending )
106+  4FFB CD D4 60     	CALL CHKCHAR
107+  4FFE 29           	DB ')'
108+  4FFF F1               POP AF
109+  5000
110+  5000              	; save position
111+  5000 E5           	PUSH HL
112+  5001              .ENTRY:
113+  5001 47               LD B,A
114+  5002 3A BC 4F         LD A,(ANIMITEMNUM)
115+  5005 90               SUB B
116+  5006 28 1F            JR Z, .EXIT; same value as before
117+  5008 FD 21 C0 4F      LD IY,ANIMDEFPTR
118+  500C FA 2A 50         JP M, .INCREASE
119+  500F                  ; new value is lower than previous one
120+  500F CD 42 50         CALL .SIZEDIFF
121+  5012 CD 5D 50         CALL .DECREASE_COMMON
122+  5015 2A C3 4F         LD HL,(ANIMSPRPTR)
123+  5018 AF               XOR A
124+  5019 ED 42            SBC HL,BC
125+  501B 22 C3 4F         LD (ANIMSPRPTR),HL
126+  501E              .E1:
127+  501E 2A 10 40         LD HL,(FREEMEMPTR)
128+  5021 AF               XOR A
129+  5022 ED 42            SBC HL,BC
130+  5024 22 10 40         LD (FREEMEMPTR),HL
131+  5027              .EXIT:
132+  5027 FB               EI
133+  5028 E1           	POP HL
134+  5029 C9           	RET
135+  502A              .INCREASE:
136+  502A ED 44            NEG
137+  502C CD 42 50         CALL .SIZEDIFF
138+  502F CD 89 50         CALL .INCREASE_COMMON
139+  5032 2A C3 4F         LD HL,(ANIMSPRPTR)
140+  5035 09               ADD HL,BC
141+  5036 22 C3 4F         LD (ANIMSPRPTR),HL
142+  5039              .E2:
143+  5039 2A 10 40         LD HL,(FREEMEMPTR)
144+  503C 09               ADD HL,BC
145+  503D 22 10 40         LD (FREEMEMPTR),HL
146+  5040 18 E5            JR .EXIT
147+  5042              .SIZEDIFF:
148+  5042 CD C5 4F         CALL Ax5
149+  5045 78               LD A,B
150+  5046 32 BC 4F         LD (ANIMITEMNUM),A
151+  5049 44               LD B,H
152+  504A 4D               LD C,L
153+  504B C9               RET ; BC=size difference in bytes
154+  504C              .SIZETOMOVE:
155+  504C D5               PUSH DE
156+  504D 2A 10 40         LD HL,(FREEMEMPTR)
157+  5050 FD 5E 00         LD E,(IY)
158+  5053 FD 56 01         LD D,(IY+1)
159+  5056 AF               XOR A
160+  5057 ED 52            SBC HL,DE
161+  5059 44               LD B,H
162+  505A 4D               LD C,L
163+  505B D1               POP DE
164+  505C C9               RET
165+  505D              .DECREASE_COMMON:
166+  505D FD 6E 00         LD L,(IY)
167+  5060 FD 66 01         LD H,(IY+1)
168+  5063 AF               XOR A
169+  5064 ED 42            SBC HL,BC
170+  5066 EB               EX DE,HL
171+  5067 C5               PUSH BC
172+  5068 CD 4C 50         CALL .SIZETOMOVE
173+  506B F3               DI
174+  506C 78               LD A,B
175+  506D B1               OR C
176+  506E 28 08            JR Z,.L1
177+  5070 FD 6E 00         LD L,(IY)
178+  5073 FD 66 01         LD H,(IY+1)
179+  5076 ED B0            LDIR
180+  5078              .L1:
181+  5078 C1               POP BC
182+  5079 FD 6E 00         LD L,(IY)
183+  507C FD 66 01         LD H,(IY+1)
184+  507F AF               XOR A
185+  5080 ED 42            SBC HL,BC
186+  5082 FD 75 00         LD (IY),L
187+  5085 FD 74 01         LD (IY+1),H
188+  5088 C9               RET
189+  5089              .INCREASE_COMMON:
190+  5089 2A 10 40         LD HL,(FREEMEMPTR)
191+  508C 2B               DEC HL
192+  508D AF               XOR A
193+  508E ED 42            SBC HL,BC
194+  5090 EB               EX DE,HL
195+  5091 C5               PUSH BC
196+  5092 CD 4C 50         CALL .SIZETOMOVE
197+  5095 F3               DI
198+  5096 78               LD A,B
199+  5097 B1               OR C
200+  5098 28 06            JR Z,.L2
201+  509A 2A 10 40         LD HL,(FREEMEMPTR)
202+  509D 2B               DEC HL
203+  509E ED B8            LDDR
204+  50A0              .L2:
205+  50A0 C1               POP BC
206+  50A1 FD 6E 00         LD L,(IY)
207+  50A4 FD 66 01         LD H,(IY+1)
208+  50A7 09               ADD HL,BC
209+  50A8 FD 75 00         LD (IY),L
210+  50AB FD 74 01         LD (IY+1),H
211+  50AE C9               RET
212+  50AF              ; *******************************************************************************************************
213+  50AF
214+  50AF              ; *******************************************************************************************************
215+  50AF              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AF              ; ANIMITEMPAT ( BYTE id,
217+  50AF              ;               INT ticks,
218+  50AF              ;               BYTE pattern,
219+  50AF              ;               BYTE color )
220+  50AF              ; fills animation item data, returns an error if out of bounds
221+  50AF              ANIMITEMPAT:
222+  50AF                  ; opening (
223+  50AF CD D4 60     	CALL CHKCHAR
224+  50B2 28           	DB '('
225+  50B3              	; get id
226+  50B3 DD 21 1C 52  	LD IX, GETBYT
227+  50B7 CD 59 01     	CALL CALBAS
228+  50BA F5               PUSH AF
229+  50BB                  ; check if out of bounds
230+  50BB 3C               INC A
231+  50BC 4F               LD C,A
232+  50BD 3A BC 4F         LD A,(ANIMITEMNUM)
233+  50C0 B9               CP C
234+  50C1 DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50C4              	; comma
236+  50C4 CD D4 60     	CALL CHKCHAR
237+  50C7 2C           	DB ','
238+  50C8              	; get ticks
239+  50C8 DD 21 2F 54  	LD IX, FRMQNT
240+  50CC CD 59 01     	CALL CALBAS
241+  50CF D5           	PUSH DE
242+  50D0              	; comma
243+  50D0 CD D4 60     	CALL CHKCHAR
244+  50D3 2C           	DB ','
245+  50D4              	; get pattern
246+  50D4 DD 21 1C 52  	LD IX, GETBYT
247+  50D8 CD 59 01     	CALL CALBAS
248+  50DB F5               PUSH AF
249+  50DC              	; comma
250+  50DC CD D4 60     	CALL CHKCHAR
251+  50DF 2C           	DB ','
252+  50E0              	; get color
253+  50E0 DD 21 1C 52  	LD IX, GETBYT
254+  50E4 CD 59 01     	CALL CALBAS
255+  50E7 F5               PUSH AF
256+  50E8              	; ending )
257+  50E8 CD D4 60     	CALL CHKCHAR
258+  50EB 29           	DB ')'
259+  50EC              .ENTRY:
260+  50EC E5               PUSH HL
261+  50ED DD E1            POP IX
262+  50EF D9               EXX
263+  50F0 C1               POP BC ; color
264+  50F1 D1               POP DE ; pattern
265+  50F2 E1               POP HL ; ticks
266+  50F3 D9               EXX
267+  50F4 F1               POP AF
268+  50F5 CD CE 4F         CALL GETnthANIMITEM
269+  50F8 E5               PUSH HL
270+  50F9 FD E1            POP IY
271+  50FB D9               EXX
272+  50FC FD 36 00 00      LD (IY),0 ; type=0
273+  5100 FD 75 01         LD (IY+1),L
274+  5103 FD 74 02         LD (IY+2),H
275+  5106 FD 72 03         LD (IY+3),D
276+  5109 FD 70 04         LD (IY+4),B
277+  510C
278+  510C DD E5            PUSH IX
279+  510E E1               POP HL
280+  510F C9               RET
281+  5110              ; *******************************************************************************************************
282+  5110
283+  5110              ; *******************************************************************************************************
284+  5110              ; function to handle CALL ANIMITEMPTR basic extension
285+  5110              ; ANIMITEMPTR ( BYTE id,
286+  5110              ;               INT ticks,
287+  5110              ;               INT pointer,
288+  5110              ; fills animation item data, returns an error if out of bounds
289+  5110              ANIMITEMPTR_CMD:
290+  5110                  ; opening (
291+  5110 CD D4 60     	CALL CHKCHAR
292+  5113 28           	DB '('
293+  5114              	; get id
294+  5114 DD 21 1C 52  	LD IX, GETBYT
295+  5118 CD 59 01     	CALL CALBAS
296+  511B F5               PUSH AF
297+  511C                  ; check if out of bounds
298+  511C 3C               INC A
299+  511D 4F               LD C,A
300+  511E 3A BC 4F         LD A,(ANIMITEMNUM)
301+  5121 B9               CP C
302+  5122 DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5125              	; comma
304+  5125 CD D4 60     	CALL CHKCHAR
305+  5128 2C           	DB ','
306+  5129              	; get ticks
307+  5129 DD 21 2F 54  	LD IX, FRMQNT
308+  512D CD 59 01     	CALL CALBAS
309+  5130 D5           	PUSH DE
310+  5131              	; comma
311+  5131 CD D4 60     	CALL CHKCHAR
312+  5134 2C           	DB ','
313+  5135              	; get pointer
314+  5135 DD 21 2F 54  	LD IX, FRMQNT
315+  5139 CD 59 01     	CALL CALBAS
316+  513C D5           	PUSH DE
317+  513D              	; ending )
318+  513D CD D4 60     	CALL CHKCHAR
319+  5140 29           	DB ')'
320+  5141              .ENTRY:
321+  5141 E5               PUSH HL
322+  5142 DD E1            POP IX
323+  5144 D9               EXX
324+  5145 D1               POP DE ; pointer
325+  5146 E1               POP HL ; ticks
326+  5147 D9               EXX
327+  5148 F1               POP AF
328+  5149 CD CE 4F         CALL GETnthANIMITEM
329+  514C E5               PUSH HL
330+  514D FD E1            POP IY
331+  514F D9               EXX
332+  5150 FD 36 00 01      LD (IY),1 ; type=1
333+  5154 FD 75 01         LD (IY+1),L
334+  5157 FD 74 02         LD (IY+2),H
335+  515A FD 73 03         LD (IY+3),E
336+  515D FD 72 04         LD (IY+4),D
337+  5160
338+  5160 DD E5            PUSH IX
339+  5162 E1               POP HL
340+  5163 C9               RET
341+  5164              ; *******************************************************************************************************
342+  5164
343+  5164              ; *******************************************************************************************************
344+  5164              ; function to handle CALL MAXANIMDEFS basic extension
345+  5164              ; MAXANIMDEFS (BYTE number)
346+  5164              ; sets new number and moves memory buffers as needed
347+  5164              MAXANIMDEFS:
348+  5164              	; opening (
349+  5164 CD D4 60     	CALL CHKCHAR
350+  5167 28           	DB '('
351+  5168              	; get value
352+  5168 DD 21 1C 52  	LD IX, GETBYT
353+  516C CD 59 01     	CALL CALBAS
354+  516F F5               PUSH AF
355+  5170              	; ending )
356+  5170 CD D4 60     	CALL CHKCHAR
357+  5173 29           	DB ')'
358+  5174 F1               POP AF
359+  5175
360+  5175              	; save position
361+  5175 E5           	PUSH HL
362+  5176              .ENTRY:
363+  5176 47               LD B,A
364+  5177 3A BF 4F         LD A,(ANIMDEFNUM)
365+  517A 90               SUB B
366+  517B CA 27 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  517E FD 21 C3 4F      LD IY,ANIMSPRPTR
368+  5182 FA 8E 51         JP M, .INCREASE
369+  5185                  ; new value is lower than previous one
370+  5185 CD 99 51         CALL .SIZEDIFF
371+  5188 CD 5D 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  518B C3 1E 50         JP MAXANIMITEMS.E1
373+  518E              .INCREASE:
374+  518E ED 44            NEG
375+  5190 CD 99 51         CALL .SIZEDIFF
376+  5193 CD 89 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5196 C3 39 50         JP MAXANIMITEMS.E2
378+  5199              .SIZEDIFF:
379+  5199 26 00            LD H,0
380+  519B 6F               LD L,A
381+  519C CD C2 5F         CALL HLx16
382+  519F 78               LD A,B
383+  51A0 32 BF 4F         LD (ANIMDEFNUM),A
384+  51A3 44               LD B,H
385+  51A4 4D               LD C,L
386+  51A5 C9               RET ; BC=size difference in bytes
387+  51A6              ; *******************************************************************************************************
388+  51A6
389+  51A6              ; *******************************************************************************************************
390+  51A6              ; function to handle CALL ANIMDEF basic extension
391+  51A6              ; ANIMITEMPAT ( BYTE id,
392+  51A6              ;               BYTE size,
393+  51A6              ;               INT[] list )
394+  51A6              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A6              ANIMDEF:
396+  51A6                  ; opening (
397+  51A6 CD D4 60     	CALL CHKCHAR
398+  51A9 28           	DB '('
399+  51AA              	; get id
400+  51AA DD 21 1C 52  	LD IX, GETBYT
401+  51AE CD 59 01     	CALL CALBAS
402+  51B1 F5               PUSH AF
403+  51B2                  ; check if out of bounds
404+  51B2 3C               INC A
405+  51B3 4F               LD C,A
406+  51B4 3A BF 4F         LD A,(ANIMDEFNUM)
407+  51B7 B9               CP C
408+  51B8 DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51BB              	; comma
410+  51BB CD D4 60     	CALL CHKCHAR
411+  51BE 2C           	DB ','
412+  51BF              	; get size
413+  51BF DD 21 1C 52  	LD IX, GETBYT
414+  51C3 CD 59 01     	CALL CALBAS
415+  51C6 FE 10            CP 16
416+  51C8 D2 EE 60         JP NC, OVERFLOW
417+  51CB B7               OR A
418+  51CC CA EE 60         JP Z, OVERFLOW
419+  51CF F5           	PUSH AF
420+  51D0              	; comma
421+  51D0 CD D4 60     	CALL CHKCHAR
422+  51D3 2C           	DB ','
423+  51D4              	; get pointer to a list of animation items in integer array format
424+  51D4                  ; get array pointer
425+  51D4 D1               POP DE
426+  51D5 D5               PUSH DE
427+  51D6 3E 02            LD A,2
428+  51D8 06 01            LD B,1
429+  51DA CD FF 60         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51DD C5               PUSH BC
431+  51DE              	; ending )
432+  51DE CD D4 60     	CALL CHKCHAR
433+  51E1 29           	DB ')'
434+  51E2              .ENTRY:
435+  51E2 E5               PUSH HL
436+  51E3 DD E1            POP IX
437+  51E5 D1               POP DE ; pointer to INT array
438+  51E6 C1               POP BC ; B=item number
439+  51E7 F1               POP AF ; id
440+  51E8 D5               PUSH DE
441+  51E9 CD D7 4F         CALL GETnthANIMDEF
442+  51EC D1               POP DE
443+  51ED 70               LD (HL),B
444+  51EE              .L1:
445+  51EE 23               INC HL
446+  51EF 1A               LD A,(DE)
447+  51F0 13          > INC DE
447+  51F1 13          > INC DE
448+  51F2 77               LD (HL),A
449+  51F3 10 F9            DJNZ .L1
450+  51F5 DD E5            PUSH IX
451+  51F7 E1               POP HL
452+  51F8 C9               RET
453+  51F9              ; *******************************************************************************************************
454+  51F9
455+  51F9              ; *******************************************************************************************************
456+  51F9              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F9              ; MAXANIMSPRS (BYTE number)
458+  51F9              ; sets new number and moves memory buffers as needed
459+  51F9              MAXANIMSPRS:
460+  51F9              	; opening (
461+  51F9 CD D4 60     	CALL CHKCHAR
462+  51FC 28           	DB '('
463+  51FD              	; get value
464+  51FD DD 21 1C 52  	LD IX, GETBYT
465+  5201 CD 59 01     	CALL CALBAS
466+  5204 F5               PUSH AF
467+  5205              	; ending )
468+  5205 CD D4 60     	CALL CHKCHAR
469+  5208 29           	DB ')'
470+  5209 F1               POP AF
471+  520A
472+  520A              	; save position
473+  520A E5           	PUSH HL
474+  520B              .ENTRY:
475+  520B 47               LD B,A
476+  520C 3A C2 4F         LD A,(ANIMSPRNUM)
477+  520F 90               SUB B
478+  5210 CA 27 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  5213 FD 21 10 40      LD IY,FREEMEMPTR
480+  5217 FA 23 52         JP M, .INCREASE
481+  521A                  ; new value is lower than previous one
482+  521A CD 42 52         CALL .SIZEDIFF
483+  521D CD 5D 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  5220 C3 27 50         JP MAXANIMITEMS.EXIT
485+  5223              .INCREASE:
486+  5223 ED 44            NEG
487+  5225 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5226 CD 42 52         CALL .SIZEDIFF
489+  5229 CD 89 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  522C AF               XOR A
491+  522D ED 42            SBC HL,BC ; location of new stuff
492+  522F F1               POP AF
493+  5230 47               LD B,A
494+  5231 11 08 00         LD DE,8
495+  5234 E5               PUSH HL
496+  5235 DD E1            POP IX
497+  5237              .L1:
498+  5237 DD 36 06 00      LD (IX+6),0
499+  523B DD 19            ADD IX,DE
500+  523D 10 F8            DJNZ .L1
501+  523F C3 27 50         JP MAXANIMITEMS.EXIT
502+  5242              .SIZEDIFF:
503+  5242 26 00            LD H,0
504+  5244 6F               LD L,A
505+  5245 CD C3 5F         CALL HLx8
506+  5248 78               LD A,B
507+  5249 32 C2 4F         LD (ANIMSPRNUM),A
508+  524C 44               LD B,H
509+  524D 4D               LD C,L
510+  524E C9               RET ; BC=size difference in bytes
511+  524F              ; *******************************************************************************************************
512+  524F
513+  524F              ; *******************************************************************************************************
514+  524F              ; function to handle CALL ANIMSPRITE basic extension
515+  524F              ; ANIMSPRITE ( BYTE id,
516+  524F              ;              BYTE sprite_number,
517+  524F              ;              BYTE animation_definition_id,
518+  524F              ;              BYTE cyclic_flag )
519+  524F              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524F              ANIMSPRITE:
521+  524F                  ; opening (
522+  524F CD D4 60     	CALL CHKCHAR
523+  5252 28           	DB '('
524+  5253              	; get sprite animation id
525+  5253 DD 21 1C 52  	LD IX, GETBYT
526+  5257 CD 59 01     	CALL CALBAS
527+  525A F5               PUSH AF
528+  525B 3C               INC A
529+  525C 4F               LD C,A
530+  525D 3A C2 4F         LD A,(ANIMSPRNUM)
531+  5260 B9               CP C
532+  5261 DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  5264              	; comma
534+  5264 CD D4 60     	CALL CHKCHAR
535+  5267 2C           	DB ','
536+  5268              	; get sprite number
537+  5268 DD 21 1C 52  	LD IX, GETBYT
538+  526C CD 59 01     	CALL CALBAS
539+  526F F5               PUSH AF
540+  5270                  ; check if out of bounds
541+  5270 FE 20            CP 32
542+  5272 D2 EA 60         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5275              	; comma
544+  5275 CD D4 60     	CALL CHKCHAR
545+  5278 2C           	DB ','
546+  5279              	; get animation definition id
547+  5279 DD 21 1C 52  	LD IX, GETBYT
548+  527D CD 59 01     	CALL CALBAS
549+  5280 F5               PUSH AF
550+  5281 3C               INC A
551+  5282 4F               LD C,A
552+  5283 3A BF 4F         LD A,(ANIMDEFNUM)
553+  5286 B9               CP C
554+  5287 DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  528A              	; comma
556+  528A CD D4 60     	CALL CHKCHAR
557+  528D 2C           	DB ','
558+  528E              	; get cyclic flag
559+  528E DD 21 1C 52  	LD IX, GETBYT
560+  5292 CD 59 01         CALL CALBAS
561+  5295 F5           	PUSH AF
562+  5296              	; ending )
563+  5296 CD D4 60     	CALL CHKCHAR
564+  5299 29           	DB ')'
565+  529A              .ENTRY:
566+  529A E5               PUSH HL
567+  529B DD E1            POP IX
568+  529D D9               EXX
569+  529E D1               POP DE ; cyclic
570+  529F C1               POP BC ; animation definition id
571+  52A0 E1               POP HL ; sprite number
572+  52A1 D9               EXX
573+  52A2 F1               POP AF ; sprite animation id
574+  52A3 CD E3 4F         CALL GETnthSPRANIM
575+  52A6 E5               PUSH HL
576+  52A7 FD E1            POP IY
577+  52A9 D9               EXX
578+  52AA FD 74 00         LD (IY),H
579+  52AD FD 70 04         LD (IY+4),B
580+  52B0 FD 72 05         LD (IY+5),D
581+  52B3                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
582+  52B3                  ; following will do preparation for ANIMSTEP situation
583+  52B3                  ; current item set to above limit and timer to 1
584+  52B3                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
585+  52B3 FD 36 03 FF      LD (IY+3),255
586+  52B7 FD 36 01 01      LD (IY+1),1
587+  52BB FD 36 02 00      LD (IY+2),0
588+  52BF                  ; mark as sprite animation
589+  52BF FD 36 07 00      LD (IY+7),0
590+  52C3 DD E5            PUSH IX
591+  52C5 E1               POP HL
592+  52C6 C9               RET
593+  52C7              ; *******************************************************************************************************
594+  52C7
595+  52C7              ; *******************************************************************************************************
596+  52C7              ; function to handle CALL ANIMCHAR basic extension
597+  52C7              ; ANIMCHAR ( BYTE id,
598+  52C7              ;            INT character number 0-767,
599+  52C7              ;            BYTE animation_definition_id,
600+  52C7              ;            BYTE cyclic_flag )
601+  52C7              ; fills sprite animation data, returns an error if out of bounds, or invalid type
602+  52C7              ANIMCHAR:
603+  52C7                  ; opening (
604+  52C7 CD D4 60     	CALL CHKCHAR
605+  52CA 28           	DB '('
606+  52CB              	; get sprite animation id
607+  52CB DD 21 1C 52  	LD IX, GETBYT
608+  52CF CD 59 01     	CALL CALBAS
609+  52D2 F5               PUSH AF
610+  52D3 3C               INC A
611+  52D4 4F               LD C,A
612+  52D5 3A C2 4F         LD A,(ANIMSPRNUM)
613+  52D8 B9               CP C
614+  52D9 DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
615+  52DC              	; comma
616+  52DC CD D4 60     	CALL CHKCHAR
617+  52DF 2C           	DB ','
618+  52E0              	; get character number
619+  52E0 DD 21 2F 54  	LD IX, FRMQNT
620+  52E4 CD 59 01     	CALL CALBAS
621+  52E7 D5               PUSH DE
622+  52E8                  ; check if out of bounds
623+  52E8 7A               LD A,D
624+  52E9 FE 03            CP 3
625+  52EB D2 EA 60         JP NC, SUBSCRIPT_OUT_OF_RANGE
626+  52EE              	; comma
627+  52EE CD D4 60     	CALL CHKCHAR
628+  52F1 2C           	DB ','
629+  52F2              	; get animation definition id
630+  52F2 DD 21 1C 52  	LD IX, GETBYT
631+  52F6 CD 59 01     	CALL CALBAS
632+  52F9 F5               PUSH AF
633+  52FA 3C               INC A
634+  52FB 4F               LD C,A
635+  52FC 3A BF 4F         LD A,(ANIMDEFNUM)
636+  52FF B9               CP C
637+  5300 DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
638+  5303              	; comma
639+  5303 CD D4 60     	CALL CHKCHAR
640+  5306 2C           	DB ','
641+  5307              	; get cyclic flag
642+  5307 DD 21 1C 52  	LD IX, GETBYT
643+  530B CD 59 01         CALL CALBAS
644+  530E F5           	PUSH AF
645+  530F              	; ending )
646+  530F CD D4 60     	CALL CHKCHAR
647+  5312 29           	DB ')'
648+  5313              .ENTRY:
649+  5313 E5               PUSH HL
650+  5314 DD E1            POP IX
651+  5316 D9               EXX
652+  5317 D1               POP DE ; cyclic
653+  5318 C1               POP BC ; animation definition id
654+  5319 E1               POP HL ; character number
655+  531A D9               EXX
656+  531B F1               POP AF ; sprite animation id
657+  531C CD E3 4F         CALL GETnthSPRANIM
658+  531F E5               PUSH HL
659+  5320 FD E1            POP IY
660+  5322 D9               EXX
661+  5323 FD 75 00         LD (IY),L
662+  5326 24               INC H ; save character bank+1
663+  5327 FD 74 07         LD (IY+7),H
664+  532A FD 70 04         LD (IY+4),B
665+  532D FD 72 05         LD (IY+5),D
666+  5330                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
667+  5330                  ; following will do preparation for ANIMSTEP situation
668+  5330                  ; current item set to above limit and timer to 1
669+  5330                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
670+  5330 FD 36 03 FF      LD (IY+3),255
671+  5334 FD 36 01 01      LD (IY+1),1
672+  5338 FD 36 02 00      LD (IY+2),0
673+  533C DD E5            PUSH IX
674+  533E E1               POP HL
675+  533F C9               RET
676+  5340              ; *******************************************************************************************************
677+  5340
678+  5340              ; *******************************************************************************************************
679+  5340              ; function to handle CALL ANIMSTEP basic extension
680+  5340              ; two forms
681+  5340              ; ANIMSTEP ( BYTE id )
682+  5340              ; or
683+  5340              ; ANIMSTEP ( BYTE item_number,
684+  5340              ;            INT[] sprite_animations )
685+  5340              ; sets active flag to 1
686+  5340              ANIMSTEP:
687+  5340 11 BD 53         LD DE,ANIMSTARTSTOP_COMMON.STEP
688+  5343 18 08            JR ANIMSTARTSTOP_COMMON
689+  5345              ; *******************************************************************************************************
690+  5345              ; *******************************************************************************************************
691+  5345              ; function to handle CALL ANIMSTART basic extension
692+  5345              ; two forms
693+  5345              ; ANIMSTART ( BYTE id )
694+  5345              ; or
695+  5345              ; ANIMSTART ( BYTE item_number,
696+  5345              ;             INT[] sprite_animations )
697+  5345              ; sets active flag to 1
698+  5345              ANIMSTART:
699+  5345 11 AB 53         LD DE,ANIMSTARTSTOP_COMMON.START
700+  5348 18 03            JR ANIMSTARTSTOP_COMMON
701+  534A              ; *******************************************************************************************************
702+  534A              ; *******************************************************************************************************
703+  534A              ; function to handle CALL ANIMSTOP basic extension
704+  534A              ; two forms
705+  534A              ; ANIMSTOP ( BYTE id )
706+  534A              ; or
707+  534A              ; ANIMSTOP ( BYTE item_number,
708+  534A              ;            INT[] sprite_animations )
709+  534A              ; sets active flag to 1
710+  534A              ANIMSTOP:
711+  534A 11 B8 53         LD DE,ANIMSTARTSTOP_COMMON.STOP
712+  534D              ; *******************************************************************************************************
713+  534D              ANIMSTARTSTOP_COMMON:
714+  534D ED 53 A9 53      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
715+  5351                  ; opening (
716+  5351 CD D4 60     	CALL CHKCHAR
717+  5354 28           	DB '('
718+  5355              	; get sprite animation id or array size
719+  5355 DD 21 1C 52  	LD IX,GETBYT
720+  5359 CD 59 01     	CALL CALBAS
721+  535C F5               PUSH AF
722+  535D                  ; check if comma present
723+  535D CD DE 60         CALL GETPREVCHAR
724+  5360 23               INC HL
725+  5361 FE 2C            CP ','
726+  5363 28 0C            JR Z,.L1
727+  5365 FE 29            CP ')'
728+  5367 C2 F6 60         JP NZ,SYNTAX_ERROR
729+  536A                  ; ok so single argument variant
730+  536A F1               POP AF
731+  536B E5               PUSH HL
732+  536C CD 97 53         CALL .SETVALUE
733+  536F E1               POP HL
734+  5370 C9               RET
735+  5371              .L1:
736+  5371                  ; get array pointer
737+  5371 D1               POP DE
738+  5372 D5               PUSH DE
739+  5373 3E 02            LD A,2
740+  5375 06 01            LD B,1
741+  5377 CD FF 60         CALL GET_BASIC_ARRAY_DATA_POINTER
742+  537A C5               PUSH BC
743+  537B              	; ending )
744+  537B CD D4 60     	CALL CHKCHAR
745+  537E 29           	DB ')'
746+  537F D1               POP DE ; array pointer
747+  5380 C1               POP BC ; number of items
748+  5381 78               LD A,B
749+  5382 B7               OR A
750+  5383 CA EA 60         JP Z,SUBSCRIPT_OUT_OF_RANGE
751+  5386 E5               PUSH HL
752+  5387 F3               DI
753+  5388              .L2:
754+  5388 C5               PUSH BC
755+  5389 1A               LD A,(DE)
756+  538A 13          > INC DE
756+  538B 13          > INC DE
757+  538C D5               PUSH DE
758+  538D CD 97 53         CALL .SETVALUE
759+  5390 D1               POP DE
760+  5391 C1               POP BC
761+  5392 10 F4            DJNZ .L2
762+  5394 FB               EI
763+  5395 E1               POP HL
764+  5396 C9               RET
765+  5397
766+  5397              .SETVALUE:
767+  5397 47               LD B,A
768+  5398 3C               INC A
769+  5399 4F               LD C,A
770+  539A 3A C2 4F         LD A,(ANIMSPRNUM)
771+  539D B9               CP C
772+  539E DA EA 60         JP C,SUBSCRIPT_OUT_OF_RANGE
773+  53A1 78               LD A,B
774+  53A2 CD E3 4F         CALL GETnthSPRANIM
775+  53A5 E5               PUSH HL
776+  53A6 DD E1            POP IX
777+  53A8              .FN:
778+  53A8 C3 00 00         JP 0
779+  53AB              .START:
780+  53AB DD 36 06 01      LD (IX+6),1 ; active flag
781+  53AF DD 36 03 00      LD (IX+3),0 ; current item
782+  53B3 06 00            LD B,0 ; setup timer
783+  53B5 C3 3C 54         JP SETUP_ANIM_STEP
784+  53B8              .STOP:
785+  53B8 DD 36 06 00      LD (IX+6),0 ; active flag
786+  53BC C9               RET
787+  53BD              .STEP:
788+  53BD 06 00            LD B,0
789+  53BF C3 E0 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
790+  53C2              ; *******************************************************************************************************
791+  53C2
792+  53C2              ; *******************************************************************************************************
793+  53C2              ; function processes animations during vblank period
794+  53C2              PROCESS_ANIMATIONS:
795+  53C2 3A C2 4F         LD A,(ANIMSPRNUM)
796+  53C5 B7               OR A
797+  53C6 C8               RET Z; no animations defined
798+  53C7 47               LD B,A
799+  53C8 DD 2A C3 4F      LD IX,(ANIMSPRPTR)
800+  53CC              .L1:
801+  53CC C5               PUSH BC
802+  53CD 06 00            LD B,0 ; normal mode, change on timer expiry only
803+  53CF CD DB 53         CALL PROCESS_SINGLE_ANIMATION
804+  53D2 11 08 00         LD DE,8
805+  53D5 DD 19            ADD IX,DE
806+  53D7 C1               POP BC
807+  53D8 10 F2            DJNZ .L1
808+  53DA C9               RET
809+  53DB              ; *******************************************************************************************************
810+  53DB
811+  53DB              ; *******************************************************************************************************
812+  53DB              ; processes single sprite animation
813+  53DB              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
814+  53DB              ; on timer expiry goes to next animation item
815+  53DB              ; input IX=sprite animation pointer
816+  53DB              ; input B=1 force mode, activate animation action regardless of expired timer
817+  53DB              PROCESS_SINGLE_ANIMATION:
818+  53DB DD 7E 06         LD A,(IX+6); active
819+  53DE B7               OR A
820+  53DF C8               RET Z ; inactive animation
821+  53E0              .INACTIVE_TOO:
822+  53E0 DD 6E 01         LD L,(IX+1)
823+  53E3 DD 66 02         LD H,(IX+2) ; HL=end time
824+  53E6 2B               DEC HL
825+  53E7 DD 75 01         LD (IX+1),L
826+  53EA DD 74 02         LD (IX+2),H
827+  53ED 7D               LD A,L
828+  53EE B4               OR H
829+  53EF 28 06            JR Z,.STEP
830+  53F1 05               DEC B
831+  53F2 04               INC B
832+  53F3 C8               RET Z ; not forced mode, return
833+  53F4 C3 3C 54         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
834+  53F7              .STEP:
835+  53F7 06 00            LD B,0; setup timer
836+  53F9 DD 34 03         INC (IX+3) ; current animation item
837+  53FC C3 3C 54         JP SETUP_ANIM_STEP
838+  53FF              ; *******************************************************************************************************
839+  53FF
840+  53FF              ; *******************************************************************************************************
841+  53FF              ; function will setup sprite animation after current item change
842+  53FF              ; input A=current animation definition
843+  53FF              ; input IX=pointer to sprite animation
844+  53FF              ; input B=1 skip timer setup
845+  53FF              ; output IY=pointer to animation item
846+  53FF              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
847+  53FF              ; basically sets new end time for current animation
848+  53FF              INIT_CURRENT_ANIMATION:
849+  53FF CD D7 4F         CALL GETnthANIMDEF
850+  5402 DD 7E 03         LD A,(IX+3) ; current animation item
851+  5405 BE               CP (HL) ; number of animation items in the animation definition
852+  5406 38 0A            JR C,.L3 ; last item not reached
853+  5408                  ; last item reached
854+  5408 DD 7E 05         LD A,(IX+5) ; cyclic flag
855+  540B B7               OR A
856+  540C 28 2C            JR Z,.ERROR ; non-cyclic animation
857+  540E                  ; cyclic animation, restart
858+  540E DD 36 03 00      LD (IX+3),0; current item
859+  5412              .L3:
860+  5412                  ; HL = animation definition
861+  5412 23               INC HL ; skip animation definition size field
862+  5413 16 00            LD D,0
863+  5415 DD 5E 03         LD E,(IX+3); current item
864+  5418 19               ADD HL,DE
865+  5419 4E               LD C,(HL) ; current animation item
866+  541A 0C               INC C
867+  541B 3A BC 4F         LD A,(ANIMITEMNUM)
868+  541E B9               CP C
869+  541F 38 19            JR C,.ERROR ; invalid animation item, stop animation
870+  5421 0D               DEC C
871+  5422 79               LD A,C
872+  5423 CD CE 4F         CALL GETnthANIMITEM
873+  5426 E5               PUSH HL
874+  5427 FD E1            POP IY ; IY=animation item
875+  5429 05               DEC B
876+  542A 28 0C            JR Z,.EXIT
877+  542C FD 5E 01         LD E,(IY+1)
878+  542F FD 56 02         LD D,(IY+2) ; duration
879+  5432 DD 73 01         LD (IX+1),E
880+  5435 DD 72 02         LD (IX+2),D
881+  5438              .EXIT:
882+  5438 AF               XOR A
883+  5439 C9               RET
884+  543A              .ERROR:
885+  543A 37               SCF
886+  543B C9               RET
887+  543C              ; *******************************************************************************************************
888+  543C
889+  543C              ; *******************************************************************************************************
890+  543C              ; function will display currect item and set up expiry time
891+  543C              ; it will also stop the animation if expired
892+  543C              ; sets sprite update flag if any changes in sprite data made
893+  543C              ; input IX=current sprite animation
894+  543C              ; input B=1 skip timer setup
895+  543C              SETUP_ANIM_STEP:
896+  543C DD 4E 04         LD C,(IX+4) ; animation definition ID
897+  543F 0C               INC C
898+  5440 3A BF 4F         LD A,(ANIMDEFNUM)
899+  5443 B9               CP C
900+  5444 30 05            JR NC,.L2
901+  5446                  ; given animation item is outside of bounds, deactivate animation
902+  5446              .STOPANIM:
903+  5446 DD 36 06 00      LD (IX+6),0
904+  544A C9               RET
905+  544B              .L2:
906+  544B 0D               DEC C
907+  544C 79               LD A,C
908+  544D CD FF 53         CALL INIT_CURRENT_ANIMATION
909+  5450 38 F4            JR C, .STOPANIM
910+  5452 FD 7E 00         LD A,(IY) ; type of animation item
911+  5455 B7               OR A
912+  5456 28 38            JR Z,.L4 ; change pattern and/or color
913+  5458              .PAT:
914+  5458                  ; change pattern definition
915+  5458                  ; check if sprite or character
916+  5458 DD 7E 07         LD A,(IX+7)
917+  545B B7               OR A
918+  545C 20 4C            JR NZ,.CHAR
919+  545E DD 7E 00         LD A,(IX) ; sprite number
920+  5461 CD 7C 4D         CALL GETnthSPRATTR
921+  5464 23          > INC HL ; skip y and x
921+  5465 23          > INC HL
921+  5466 23          > INC HL
921+  5467 23          > INC HL
922+  5468 7E               LD A,(HL); current pattern
923+  5469 26 00            LD H,0
924+  546B 6F               LD L,A
925+  546C 3A E0 F3         LD A,(REG1SAV)
926+  546F E6 02            AND 2
927+  5471 20 07            JR NZ,.L6
928+  5473                  ; 8x8 sprite
929+  5473 CD C3 5F         CALL HLx8
930+  5476 06 08            LD B,8
931+  5478 18 05            JR .L5
932+  547A              .L6:
933+  547A CD C1 5F         CALL HLx32
934+  547D 06 20            LD B,32
935+  547F              .L5:
936+  547F ED 5B 26 F9      LD DE,(PATBAS)
937+  5483              .L7:
938+  5483 19               ADD HL,DE
939+  5484 CD AE 5F         CALL SETWRT_LOCAL
940+  5487 FD 6E 03         LD L,(IY+3)
941+  548A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
942+  548D C3 B9 5F         JP BBYTECOPY
943+  5490              .L4:
944+  5490                  ; change pattern and color in sprite attributes table
945+  5490 DD 7E 00         LD A,(IX) ; sprite number
946+  5493 CD 7C 4D         CALL GETnthSPRATTR
947+  5496 23          > INC HL ; skip y and x
947+  5497 23          > INC HL
947+  5498 23          > INC HL
947+  5499 23          > INC HL
948+  549A FD 7E 03         LD A,(IY+3) ; new pattern
949+  549D 77               LD (HL),A
950+  549E 23          > INC HL
950+  549F 23          > INC HL
951+  54A0 FD 7E 04         LD A,(IY+4) ; new color
952+  54A3 77               LD (HL),A
953+  54A4 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
954+  54A7 36 01            LD (HL),1
955+  54A9 C9               RET
956+  54AA              .CHAR:
957+  54AA DD 6E 00         LD L,(IX)
958+  54AD 3D               DEC A
959+  54AE 67               LD H,A
960+  54AF CD C3 5F         CALL HLx8
961+  54B2 ED 5B 24 F9      LD DE,(CGPBAS)
962+  54B6 06 08            LD B,8
963+  54B8 18 C9            JR .L7
964+  54BA              ; *******************************************************************************************************
965+  54BA
# file closed: asm\ANIMATION.asm
124   54BA               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
  1+  54BA              ; Sprite Group Animate and Move
  2+  54BA
  3+  54BA              ; *******************************************************************************************************
  4+  54BA              ; function to handle CALL SGAM basic extension
  5+  54BA              ; sets position of a group of sprites as described in SPRGRPMOV
  6+  54BA              ; and manually animate a list of animations
  7+  54BA              ; _SGAM ( INT x,
  8+  54BA              ;	      INT y,
  9+  54BA              ;		  BYTE count,
 10+  54BA              ;		  INT[2][count] data_ptr,
 11+  54BA              ;         BYTE item_number,
 12+  54BA              ;         INT[] sprite_animations )
 13+  54BA              ; will put ram in page 0 also, page 1 is already there
 14+  54BA              SGAM:
 15+  54BA 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
 16+  54BD B7           	OR A
 17+  54BE CA F2 60     	JP Z,ILLEGAL_FUNCTION
 18+  54C1              	; opening (
 19+  54C1 CD D4 60     	CALL CHKCHAR
 20+  54C4 28           	DB '('
 21+  54C5              	; get x
 22+  54C5 DD 21 2F 54  	LD IX, FRMQNT
 23+  54C9 CD 59 01     	CALL CALBAS
 24+  54CC ED 53 0B 5E  	LD (BLIT_STRUCT),DE
 25+  54D0              	; comma
 26+  54D0 CD D4 60     	CALL CHKCHAR
 27+  54D3 2C           	DB ','
 28+  54D4              	; get y
 29+  54D4 DD 21 2F 54  	LD IX, FRMQNT
 30+  54D8 CD 59 01     	CALL CALBAS
 31+  54DB ED 53 0D 5E  	LD (BLIT_STRUCT+2),DE
 32+  54DF              	; comma
 33+  54DF CD D4 60     	CALL CHKCHAR
 34+  54E2 2C           	DB ','
 35+  54E3              	; get count
 36+  54E3 DD 21 1C 52  	LD IX, GETBYT
 37+  54E7 CD 59 01     	CALL CALBAS
 38+  54EA B7               OR A
 39+  54EB CA EA 60         JP Z,SUBSCRIPT_OUT_OF_RANGE
 40+  54EE 32 0F 5E     	LD (BLIT_STRUCT+4),A
 41+  54F1              	; comma
 42+  54F1 CD D4 60     	CALL CHKCHAR
 43+  54F4 2C           	DB ','
 44+  54F5              	; get sprite group definition array data pointer
 45+  54F5 3A 0F 5E         LD A,(BLIT_STRUCT+4)
 46+  54F8 5F           	LD E,A
 47+  54F9 16 03        	LD D,3
 48+  54FB 3E 02        	LD A,2
 49+  54FD 47           	LD B,A
 50+  54FE CD FF 60     	CALL GET_BASIC_ARRAY_DATA_POINTER
 51+  5501 ED 43 10 5E  	LD (BLIT_STRUCT+5),BC
 52+  5505              	; comma
 53+  5505 CD D4 60     	CALL CHKCHAR
 54+  5508 2C           	DB ','
 55+  5509              	; get sprite animation array size
 56+  5509 DD 21 1C 52  	LD IX,GETBYT
 57+  550D CD 59 01     	CALL CALBAS
 58+  5510 32 12 5E         LD (BLIT_STRUCT+7),A
 59+  5513 B7               OR A
 60+  5514 CA EA 60         JP Z,SUBSCRIPT_OUT_OF_RANGE
 61+  5517              	; comma
 62+  5517 CD D4 60     	CALL CHKCHAR
 63+  551A 2C           	DB ','
 64+  551B                  ; get array pointer
 65+  551B 3A 12 5E         LD A,(BLIT_STRUCT+7)
 66+  551E 57               LD D,A
 67+  551F 3E 02            LD A,2
 68+  5521 06 01            LD B,1
 69+  5523 CD FF 60         CALL GET_BASIC_ARRAY_DATA_POINTER
 70+  5526 ED 43 13 5E      LD (BLIT_STRUCT+8),BC
 71+  552A              	; ending )
 72+  552A CD D4 60     	CALL CHKCHAR
 73+  552D 29           	DB ')'
 74+  552E
 75+  552E E5               PUSH HL
 76+  552F F3               DI
 77+  5530
 78+  5530              	; enable page 0
 79+  5530 FD 21 37 55  	LD IY, .RET
 80+  5534 C3 87 60     	JP ENABLE_PAGE0
 81+  5537              .RET:
 82+  5537 D9               EXX
 83+  5538 ED 5B 0B 5E      LD DE,(BLIT_STRUCT) ; initial x
 84+  553C ED 4B 0D 5E      LD BC,(BLIT_STRUCT+2) ; initial y
 85+  5540 D9               EXX
 86+  5541 2A 10 5E         LD HL,(BLIT_STRUCT+5) ; pointer to data
 87+  5544 3A 0F 5E         LD A,(BLIT_STRUCT+4) ; number of entries
 88+  5547 47               LD B,A
 89+  5548 CD AA 4F         CALL SPRGRPMOV.UPDATE_LOC
 90+  554B
 91+  554B 21 6D 55         LD HL,.STEP
 92+  554E 22 A9 53         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
 93+  5551 3A 12 5E         LD A,(BLIT_STRUCT+7) ; anim number
 94+  5554 47               LD B,A
 95+  5555 ED 5B 13 5E      LD DE,(BLIT_STRUCT+8) ; anim list
 96+  5559              .L1:
 97+  5559 C5               PUSH BC
 98+  555A 1A               LD A,(DE)
 99+  555B 13          > INC DE
 99+  555C 13          > INC DE
100+  555D D5               PUSH DE
101+  555E CD 97 53         CALL ANIMSTARTSTOP_COMMON.SETVALUE
102+  5561 D1               POP DE
103+  5562 C1               POP BC
104+  5563 10 F4            DJNZ .L1
105+  5565
106+  5565 D1               POP DE
107+  5566 C1               POP BC
108+  5567 CD FE 5F         CALL RESTORE_PAGE_INFO
109+  556A FB               EI
110+  556B E1               POP HL
111+  556C C9               RET
112+  556D              .STEP:
113+  556D 06 01            LD B,1
114+  556F C3 E0 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
115+  5572              ; *******************************************************************************************************
116+  5572
# file closed: asm\SGAM.asm
125   5572               ENDIF
126   5572
127   5572               IF (RAM_CMDS == 1)
128   5572               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  5572              ; *******************************************************************************************************
  2+  5572              ; function to handle CALL MEMCPY basic extension
  3+  5572              ; _MEMCPY ( INT source,
  4+  5572              ;			INT destination,
  5+  5572              ;			INT count,
  6+  5572              ; will put ram in page 0 also, page 1 is already there
  7+  5572              MEMCPY:
  8+  5572              	; opening (
  9+  5572 CD D4 60     	CALL CHKCHAR
 10+  5575 28           	DB '('
 11+  5576              	; get source address
 12+  5576 DD 21 2F 54  	LD IX, FRMQNT
 13+  557A CD 59 01     	CALL CALBAS
 14+  557D D5           	PUSH DE
 15+  557E              	; comma
 16+  557E CD D4 60     	CALL CHKCHAR
 17+  5581 2C           	DB ','
 18+  5582              	; get destination address
 19+  5582 DD 21 2F 54  	LD IX, FRMQNT
 20+  5586 CD 59 01     	CALL CALBAS
 21+  5589 D5           	PUSH DE
 22+  558A              	; comma
 23+  558A CD D4 60     	CALL CHKCHAR
 24+  558D 2C           	DB ','
 25+  558E              	; get length
 26+  558E DD 21 2F 54  	LD IX, FRMQNT
 27+  5592 CD 59 01     	CALL CALBAS
 28+  5595 D5           	PUSH DE
 29+  5596              	; ending )
 30+  5596 CD D4 60     	CALL CHKCHAR
 31+  5599 29           	DB ')'
 32+  559A
 33+  559A              	; save position
 34+  559A E5           	PUSH HL
 35+  559B DD E1        	POP IX
 36+  559D
 37+  559D C1           	POP BC ; count
 38+  559E D1           	POP DE ; destination
 39+  559F E1           	POP HL ; source
 40+  55A0 D9           	EXX
 41+  55A1              	; enable page 0
 42+  55A1 FD 21 A8 55  	LD IY, .RET
 43+  55A5 C3 87 60     	JP ENABLE_PAGE0
 44+  55A8              .RET:
 45+  55A8 FB           	EI
 46+  55A9 D9           	EXX
 47+  55AA ED B0        	LDIR
 48+  55AC D1               POP DE
 49+  55AD C1               POP BC
 50+  55AE CD FE 5F         CALL RESTORE_PAGE_INFO
 51+  55B1 DD E5        	PUSH IX
 52+  55B3 E1           	POP HL
 53+  55B4 C9           	RET
 54+  55B5              ; *******************************************************************************************************
 55+  55B5
 56+  55B5              ; *******************************************************************************************************
 57+  55B5              ; function to handle CALL FILRAM basic extension
 58+  55B5              ; FILRAM ( INT start address,
 59+  55B5              ;		   INT count,
 60+  55B5              ;		   BYTE value,
 61+  55B5              ; will put ram in page 0 also, page 1 is already there
 62+  55B5              FILRAM:
 63+  55B5              	; opening (
 64+  55B5 CD D4 60     	CALL CHKCHAR
 65+  55B8 28           	DB '('
 66+  55B9              	; get start address
 67+  55B9 DD 21 2F 54  	LD IX, FRMQNT
 68+  55BD CD 59 01     	CALL CALBAS
 69+  55C0 D5           	PUSH DE
 70+  55C1              	; comma
 71+  55C1 CD D4 60     	CALL CHKCHAR
 72+  55C4 2C           	DB ','
 73+  55C5              	; get count
 74+  55C5 DD 21 2F 54  	LD IX, FRMQNT
 75+  55C9 CD 59 01     	CALL CALBAS
 76+  55CC D5           	PUSH DE
 77+  55CD              	; comma
 78+  55CD CD D4 60     	CALL CHKCHAR
 79+  55D0 2C           	DB ','
 80+  55D1              	; get value
 81+  55D1 DD 21 1C 52  	LD IX, GETBYT
 82+  55D5 CD 59 01     	CALL CALBAS
 83+  55D8 F5           	PUSH AF
 84+  55D9              	; ending )
 85+  55D9 CD D4 60     	CALL CHKCHAR
 86+  55DC 29           	DB ')'
 87+  55DD
 88+  55DD              	; save position
 89+  55DD E5           	PUSH HL
 90+  55DE DD E1        	POP IX
 91+  55E0
 92+  55E0 D1           	POP DE ; actually AF
 93+  55E1 C1           	POP BC ; count
 94+  55E2 E1           	POP HL ; start address
 95+  55E3 78           	LD A, B
 96+  55E4 B7           	OR A
 97+  55E5 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  55E7 B1           	OR C
 99+  55E8 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  55EA 79           	LD A, C
101+  55EB 3D           	DEC A
102+  55EC 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  55EE              	; one byte to fill
104+  55EE 72           	LD (HL), D
105+  55EF 18 12        	JR .EXIT
106+  55F1              .L1:
107+  55F1 D9           	EXX
108+  55F2              	; enable page 0
109+  55F2 FD 21 F9 55  	LD IY, .RET
110+  55F6 C3 87 60     	JP ENABLE_PAGE0
111+  55F9              .RET:
112+  55F9 FB           	EI
113+  55FA D9           	EXX
114+  55FB CD 07 56     	CALL .FILLVALUE
115+  55FE D1               POP DE
116+  55FF C1               POP BC
117+  5600 CD FE 5F         CALL RESTORE_PAGE_INFO
118+  5603              .EXIT:
119+  5603 DD E5        	PUSH IX
120+  5605 E1           	POP HL
121+  5606 C9           	RET
122+  5607
123+  5607              .FILLVALUE:
124+  5607 72               LD (HL), D
125+  5608 54               LD D, H
126+  5609 5D               LD E, L
127+  560A 13               INC DE
128+  560B 0B               DEC BC
129+  560C ED B0            LDIR
130+  560E C9               RET
131+  560F              ; *******************************************************************************************************
132+  560F
# file closed: asm\MEMORY.asm
129   560F               ENDIF
130   560F
131   560F               IF (SOUND_CMDS == 1)
132   560F               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  560F              MUSIC_INIT_STATUS:
  2+  560F 00            DB 0
  3+  5610              SFX_INIT_STATUS:
  4+  5610 00            DB 0
  5+  5611              SOUND_ENABLED:
  6+  5611 00            DB 0
  7+  5612
  8+  5612              ; *******************************************************************************************************
  9+  5612              ; function to handle CALL SNDPLYINIT basic extension
 10+  5612              ; initializes sound player
 11+  5612              ; _SNDPLYINIT ( INT music_offset,
 12+  5612              ;				INT sfx_offset, can be -1 if no SFX
 13+  5612              ; will put ram in page 0 also, page 1 is already there
 14+  5612              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  5612              SNDPLYINIT:
 16+  5612              	; opening (
 17+  5612 CD D4 60     	CALL CHKCHAR
 18+  5615 28           	DB '('
 19+  5616              	; get music address
 20+  5616 DD 21 2F 54  	LD IX, FRMQNT
 21+  561A CD 59 01     	CALL CALBAS
 22+  561D D5           	PUSH DE
 23+  561E              	; comma
 24+  561E CD D4 60     	CALL CHKCHAR
 25+  5621 2C           	DB ','
 26+  5622              	; get sfx address
 27+  5622 DD 21 2F 54  	LD IX, FRMQNT
 28+  5626 CD 59 01     	CALL CALBAS
 29+  5629 D5           	PUSH DE
 30+  562A              	; ending )
 31+  562A CD D4 60     	CALL CHKCHAR
 32+  562D 29           	DB ')'
 33+  562E
 34+  562E                  ; save position in BASIC text
 35+  562E 44           	LD B, H
 36+  562F 4D           	LD C, L
 37+  5630
 38+  5630              	; pop LDIR parameters and store away for later
 39+  5630 D1           	POP DE ; sfx address
 40+  5631 E1           	POP HL ; music address
 41+  5632 C5           	PUSH BC ; basic text location
 42+  5633 D9           	EXX
 43+  5634 FD 21 3B 56  	LD IY, .RET
 44+  5638 C3 87 60     	JP ENABLE_PAGE0
 45+  563B              .RET:
 46+  563B D9           	EXX
 47+  563C
 48+  563C D5           	PUSH DE
 49+  563D AF           	XOR A
 50+  563E              	; HL = music location
 51+  563E CD 62 41     	CALL PLY_AKG_INIT
 52+  5641 3E 01        	LD A, 1
 53+  5643 32 0F 56     	LD (MUSIC_INIT_STATUS), A
 54+  5646
 55+  5646 E1           	POP HL ; SFX
 56+  5647              	; check if SFX address -1
 57+  5647 23           	INC HL
 58+  5648 7D           	LD A, L
 59+  5649 B4           	OR H
 60+  564A 28 09        	JR Z,.L1
 61+  564C 2B           	DEC HL
 62+  564D CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  5650 3E 01        	LD A, 1
 64+  5652 32 10 56     	LD (SFX_INIT_STATUS), A
 65+  5655              .L1:
 66+  5655 D1               POP DE
 67+  5656 C1               POP BC
 68+  5657 CD FE 5F         CALL RESTORE_PAGE_INFO
 69+  565A
 70+  565A E1           	POP HL
 71+  565B C9           	RET
 72+  565C              ; *******************************************************************************************************
 73+  565C
 74+  565C              ; *******************************************************************************************************
 75+  565C              ; function to handle CALL SNDPLYON basic extension
 76+  565C              ; enables sound player
 77+  565C              ; _SNDPLYON
 78+  565C              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  565C              ; if not throws out of data error
 80+  565C              SNDPLYON:
 81+  565C 3A 0F 56     	LD A, (MUSIC_INIT_STATUS)
 82+  565F B7           	OR A
 83+  5660 20 05        	JR NZ, .L1
 84+  5662              	; player not initialized, throw error
 85+  5662 1E 04        	LD E, 04 ; Out of DATA
 86+  5664 C3 F8 60     	JP THROW_ERROR
 87+  5667              .L1:
 88+  5667 32 11 56     	LD (SOUND_ENABLED), A
 89+  566A              	; disable key click
 90+  566A AF           	XOR A
 91+  566B 32 DB F3     	LD (CLIKSW), A
 92+  566E C9           	RET
 93+  566F              ; *******************************************************************************************************
 94+  566F
 95+  566F              ; *******************************************************************************************************
 96+  566F              ; function to handle CALL SNDPLYOFF basic extension
 97+  566F              ; disables sound player
 98+  566F              ; _SNDPLYOFF
 99+  566F              ; sets SOUND_ENABLED variable to 0
100+  566F              ; calls AKG to stop music and SFX on all channels if initialized
101+  566F              SNDPLYOFF:
102+  566F 3A 11 56     	LD A, (SOUND_ENABLED)
103+  5672 B7           	OR A
104+  5673 C8           	RET Z ; already stopped
105+  5674 AF           	XOR A
106+  5675 32 11 56     	LD (SOUND_ENABLED), A
107+  5678 E5           	PUSH HL
108+  5679 CD 21 42     	CALL PLY_AKG_STOP
109+  567C 3A 10 56     	LD A, (SFX_INIT_STATUS)
110+  567F B7           	OR A
111+  5680 28 0E        	JR Z, .EXIT ; SFX not in use
112+  5682 AF           	XOR A
113+  5683 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  5686 3E 01        	LD A, 1
115+  5688 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  568B 3E 02        	LD A, 2
117+  568D CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  5690              .EXIT:
119+  5690 E1           	POP HL
120+  5691 C9           	RET
121+  5692              ; *******************************************************************************************************
122+  5692
123+  5692              ; *******************************************************************************************************
124+  5692              ; function to handle CALL SNDSFX basic extension
125+  5692              ; plays a sound effect
126+  5692              ; _SNDSFX ( BYTE sfx_number, >0
127+  5692              ;			BYTE channel, = 0,1 or 2
128+  5692              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  5692              ; will put ram in page 0 also, page 1 is already there
130+  5692              ; if sound off throws illegal function call
131+  5692              ; if sfx not initialized, throws out of data
132+  5692              SNDSFX:
133+  5692              	; opening (
134+  5692 CD D4 60     	CALL CHKCHAR
135+  5695 28           	DB '('
136+  5696              	; get sfx_number
137+  5696 DD 21 1C 52  	LD IX, GETBYT
138+  569A CD 59 01     	CALL CALBAS
139+  569D D5           	PUSH DE
140+  569E              	; comma
141+  569E CD D4 60     	CALL CHKCHAR
142+  56A1 2C           	DB ','
143+  56A2              	; get sfx address
144+  56A2 DD 21 1C 52  	LD IX, GETBYT
145+  56A6 CD 59 01     	CALL CALBAS
146+  56A9 D5           	PUSH DE
147+  56AA              	; comma
148+  56AA CD D4 60     	CALL CHKCHAR
149+  56AD 2C           	DB ','
150+  56AE              	; get inverted volume
151+  56AE DD 21 1C 52  	LD IX, GETBYT
152+  56B2 CD 59 01     	CALL CALBAS
153+  56B5 D5           	PUSH DE
154+  56B6              	; ending )
155+  56B6 CD D4 60     	CALL CHKCHAR
156+  56B9 29           	DB ')'
157+  56BA
158+  56BA 3A 11 56     	LD A, (SOUND_ENABLED)
159+  56BD B7           	OR A
160+  56BE 20 05        	JR NZ, .L1
161+  56C0              	; sound disabled, throw illegal function call
162+  56C0 1E 05        	LD E, 5
163+  56C2 C3 F8 60     	JP THROW_ERROR
164+  56C5              .L1:
165+  56C5 3A 10 56     	LD A, (SFX_INIT_STATUS)
166+  56C8 B7           	OR A
167+  56C9 20 05        	JR NZ, .L2
168+  56CB              	; sfx data not initialized, throw out of data
169+  56CB 1E 04        	LD E, 4
170+  56CD C3 F8 60     	JP THROW_ERROR
171+  56D0              .L2:
172+  56D0              	; pop  parameters and store away for later
173+  56D0 D1           	POP DE ; inverted volume
174+  56D1 43           	LD B, E
175+  56D2 D1           	POP DE ; channel
176+  56D3 4B           	LD C, E
177+  56D4 D1           	POP DE
178+  56D5 7B           	LD A, E
179+  56D6 08           	EX AF, AF'
180+  56D7 E5           	PUSH HL ; basic text location
181+  56D8 D9           	EXX
182+  56D9 FD 21 E0 56  	LD IY, .RET
183+  56DD C3 87 60     	JP ENABLE_PAGE0
184+  56E0              .RET:
185+  56E0 D9           	EXX
186+  56E1 08           	EX AF, AF'
187+  56E2 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  56E5
189+  56E5 D1               POP DE
190+  56E6 C1               POP BC
191+  56E7 CD FE 5F         CALL RESTORE_PAGE_INFO
192+  56EA
193+  56EA E1           	POP HL
194+  56EB C9           	RET
195+  56EC              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
133   56EC               ENDIF
134   56EC
135   56EC               IF (VRAM_CMDS == 1)
136   56EC               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  56EC              ; *******************************************************************************************************
  2+  56EC              ; function to handle CALL FILVRM basic extension
  3+  56EC              ; FILVRM ( INT offset,
  4+  56EC              ;		   INT count,
  5+  56EC              ;		   BYTE value,
  6+  56EC              ;		   BYTE wait_vsync) >0 = true
  7+  56EC              ; wait_vsync will issue HALT before copying
  8+  56EC              FILVRM:
  9+  56EC              	; opening (
 10+  56EC CD D4 60     	CALL CHKCHAR
 11+  56EF 28           	DB '('
 12+  56F0              	; get offset address
 13+  56F0 DD 21 2F 54  	LD IX, FRMQNT
 14+  56F4 CD 59 01     	CALL CALBAS
 15+  56F7 D5           	PUSH DE
 16+  56F8              	; comma
 17+  56F8 CD D4 60     	CALL CHKCHAR
 18+  56FB 2C           	DB ','
 19+  56FC              	; get count
 20+  56FC DD 21 2F 54  	LD IX, FRMQNT
 21+  5700 CD 59 01     	CALL CALBAS
 22+  5703 D5           	PUSH DE
 23+  5704              	; comma
 24+  5704 CD D4 60     	CALL CHKCHAR
 25+  5707 2C           	DB ','
 26+  5708              	; get value
 27+  5708 DD 21 1C 52  	LD IX, GETBYT
 28+  570C CD 59 01     	CALL CALBAS
 29+  570F F5           	PUSH AF
 30+  5710              	; comma
 31+  5710 CD D4 60     	CALL CHKCHAR
 32+  5713 2C           	DB ','
 33+  5714              	; get vsync wait
 34+  5714 DD 21 1C 52  	LD IX, GETBYT
 35+  5718 CD 59 01     	CALL CALBAS
 36+  571B F5           	PUSH AF
 37+  571C              	; ending )
 38+  571C CD D4 60     	CALL CHKCHAR
 39+  571F 29           	DB ')'
 40+  5720
 41+  5720 FB               EI
 42+  5721              	; save position
 43+  5721 E5           	PUSH HL
 44+  5722 DD E1        	POP IX
 45+  5724
 46+  5724              	; syntax ok
 47+  5724              	; wait for vsync if needed
 48+  5724 F1           	POP AF
 49+  5725 B7           	OR A
 50+  5726 28 01        	JR Z, .L1
 51+  5728 76           	HALT
 52+  5729
 53+  5729              .L1:
 54+  5729 3E 01        	LD A,1
 55+  572B 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  572E F1               POP AF ; value
 57+  572F C1               POP BC ; count
 58+  5730 E1               POP HL ; offset
 59+  5731 CD 56 00         CALL BIOS_FILVRM
 60+  5734 AF           	XOR A
 61+  5735 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  5738
 63+  5738              .L3:
 64+  5738 DD E5        	PUSH IX
 65+  573A E1           	POP HL
 66+  573B C9           	RET
 67+  573C              ; *******************************************************************************************************
 68+  573C
 69+  573C              ; *******************************************************************************************************
 70+  573C              ; function to handle CALL MEMVRM basic extension
 71+  573C              ; copies from RAM to VRAM
 72+  573C              ; _MEMVRM ( INT source,
 73+  573C              ;			INT destination,
 74+  573C              ;			INT count,
 75+  573C              ;			BYTE wait_vsync) >0 = true
 76+  573C              ; will put ram in page 0 also, page 1 is already there
 77+  573C              ; wait_vsync will issue HALT before copying
 78+  573C              MEMVRM:
 79+  573C              	; opening (
 80+  573C CD D4 60     	CALL CHKCHAR
 81+  573F 28           	DB '('
 82+  5740              	; get source address
 83+  5740 DD 21 2F 54  	LD IX, FRMQNT
 84+  5744 CD 59 01     	CALL CALBAS
 85+  5747 D5           	PUSH DE
 86+  5748              	; comma
 87+  5748 CD D4 60     	CALL CHKCHAR
 88+  574B 2C           	DB ','
 89+  574C              	; get destination address
 90+  574C DD 21 2F 54  	LD IX, FRMQNT
 91+  5750 CD 59 01     	CALL CALBAS
 92+  5753 D5           	PUSH DE
 93+  5754              	; comma
 94+  5754 CD D4 60     	CALL CHKCHAR
 95+  5757 2C           	DB ','
 96+  5758              	; get length
 97+  5758 DD 21 2F 54  	LD IX, FRMQNT
 98+  575C CD 59 01     	CALL CALBAS
 99+  575F D5           	PUSH DE
100+  5760              	; comma
101+  5760 CD D4 60     	CALL CHKCHAR
102+  5763 2C           	DB ','
103+  5764              	; get vsync wait
104+  5764 DD 21 1C 52  	LD IX, GETBYT
105+  5768 CD 59 01     	CALL CALBAS
106+  576B F5           	PUSH AF
107+  576C              	; ending )
108+  576C CD D4 60     	CALL CHKCHAR
109+  576F 29           	DB ')'
110+  5770
111+  5770                  ; save position in BASIC text
112+  5770 E5           	PUSH HL
113+  5771 DD E1        	POP IX
114+  5773
115+  5773 F1           	POP AF ; wait vsync
116+  5774 B7           	OR A
117+  5775 28 03        	JR Z, .L1
118+  5777 FB               EI
119+  5778 76           	HALT
120+  5779 F3           	DI
121+  577A              .L1:
122+  577A              	; pop LDIR parameters and store away for later
123+  577A C1           	POP BC ; count
124+  577B D1           	POP DE ; vram destination
125+  577C E1           	POP HL ; ram source
126+  577D D9           	EXX
127+  577E FD 21 85 57   	LD IY, .RET
128+  5782 C3 87 60     	JP ENABLE_PAGE0
129+  5785              .RET:
130+  5785 FB           	EI
131+  5786 D9           	EXX
132+  5787 3E 01        	LD A,1
133+  5789 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  578C CD 9C 57     	CALL .LDIRVM
135+  578F AF           	XOR A
136+  5790 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  5793 D1               POP DE
138+  5794 C1               POP BC
139+  5795 CD FE 5F         CALL RESTORE_PAGE_INFO
140+  5798 DD E5        	PUSH IX
141+  579A E1           	POP HL
142+  579B C9           	RET
143+  579C
144+  579C              .LDIRVM:
145+  579C EB           	EX DE, HL
146+  579D F3           	DI
147+  579E CD AE 5F     	CALL SETWRT_LOCAL
148+  57A1 FB           	EI
149+  57A2 EB           	EX DE, HL
150+  57A3 78           	LD A, B
151+  57A4 B7           	OR A
152+  57A5 28 0D        	JR Z, .L3
153+  57A7 C5           	PUSH BC
154+  57A8 0E 98        	LD C, #98
155+  57AA              .L2:
156+  57AA 50           	LD D, B
157+  57AB 06 00        	LD B, 0
158+  57AD CD BB 5F     	CALL BBYTECOPY_NO_C
159+  57B0 42           	LD B, D
160+  57B1 10 F7        	DJNZ .L2
161+  57B3 C1           	POP BC
162+  57B4              .L3:
163+  57B4 79           	LD A, C
164+  57B5 B7           	OR A
165+  57B6 C8           	RET Z
166+  57B7 41           	LD B, C
167+  57B8 C3 B9 5F     	JP BBYTECOPY
168+  57BB              ; *******************************************************************************************************
169+  57BB
170+  57BB              ; *******************************************************************************************************
171+  57BB              ; function to handle CALL VRMMEM basic extension
172+  57BB              ; copies from RAM to VRAM
173+  57BB              ; _VRMMEM ( INT source,
174+  57BB              ;			INT destination,
175+  57BB              ;			INT count
176+  57BB              ; will put ram in page 0 also, page 1 is already there
177+  57BB              VRMMEM:
178+  57BB              	; opening (
179+  57BB CD D4 60     	CALL CHKCHAR
180+  57BE 28           	DB '('
181+  57BF              	; get source address
182+  57BF DD 21 2F 54  	LD IX, FRMQNT
183+  57C3 CD 59 01     	CALL CALBAS
184+  57C6 D5           	PUSH DE
185+  57C7              	; comma
186+  57C7 CD D4 60     	CALL CHKCHAR
187+  57CA 2C           	DB ','
188+  57CB              	; get destination address
189+  57CB DD 21 2F 54  	LD IX, FRMQNT
190+  57CF CD 59 01     	CALL CALBAS
191+  57D2 D5           	PUSH DE
192+  57D3              	; comma
193+  57D3 CD D4 60     	CALL CHKCHAR
194+  57D6 2C           	DB ','
195+  57D7              	; get length
196+  57D7 DD 21 2F 54  	LD IX, FRMQNT
197+  57DB CD 59 01     	CALL CALBAS
198+  57DE D5           	PUSH DE
199+  57DF              	; ending )
200+  57DF CD D4 60     	CALL CHKCHAR
201+  57E2 29           	DB ')'
202+  57E3
203+  57E3                  ; save position in BASIC text
204+  57E3 E5           	PUSH HL
205+  57E4 DD E1        	POP IX
206+  57E6
207+  57E6 C1           	POP BC ; count
208+  57E7 D1           	POP DE ; destination
209+  57E8 E1           	POP HL ; source
210+  57E9 D9           	EXX
211+  57EA FD 21 F1 57  	LD IY, .RET
212+  57EE C3 87 60     	JP ENABLE_PAGE0
213+  57F1              .RET:
214+  57F1 FB           	EI
215+  57F2 D9           	EXX
216+  57F3 3E 01        	LD A,1
217+  57F5 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  57F8 CD 08 58     	CALL .LDIRMV
219+  57FB AF           	XOR A
220+  57FC 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  57FF D1               POP DE
222+  5800 C1               POP BC
223+  5801 CD FE 5F         CALL RESTORE_PAGE_INFO
224+  5804 DD E5        	PUSH IX
225+  5806 E1           	POP HL
226+  5807 C9           	RET
227+  5808
228+  5808              .LDIRMV:
229+  5808              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  5808 7D           	LD	A, L
231+  5809 F3           	DI
232+  580A D3 99        	OUT	(099H), A
233+  580C 7C           	LD	A, H
234+  580D E6 3F        	AND	03FH
235+  580F D3 99        	OUT	(099H), A
236+  5811 FB           	EI
237+  5812              	;EX (SP), HL
238+  5812              	;EX (SP), HL
239+  5812              	;NOP
240+  5812              	;NOP
241+  5812              .L4:
242+  5812 DB 98            IN A, (#98)
243+  5814 12           	LD (DE), A
244+  5815 13               INC DE
245+  5816 0B               DEC BC
246+  5817 79               LD A, C
247+  5818 B0               OR B
248+  5819 20 F7            JR NZ, .L4
249+  581B C9               RET
250+  581C              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
137   581C               ENDIF
138   581C
139   581C               IF (GENCAL_CMD == 1)
140   581C               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  581C              ; *******************************************************************************************************
  2+  581C              ; function to handle CALL GENCAL basic extension
  3+  581C              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  581C              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  581C              ; output values of registers will also be stored at reg_list_ptr
  6+  581C              GENCAL_VAR_SP:
  7+  581C 00 00            DW 0
  8+  581E              GENCAL_VAR_SP2:
  9+  581E 00 00            DW 0
 10+  5820              GENCAL:
 11+  5820              	; opening (
 12+  5820 CD D4 60     	CALL CHKCHAR
 13+  5823 28           	DB '('
 14+  5824              	; get function address
 15+  5824 DD 21 2F 54  	LD IX, FRMQNT
 16+  5828 CD 59 01     	CALL CALBAS
 17+  582B D5           	PUSH DE
 18+  582C              	; comma
 19+  582C CD D4 60     	CALL CHKCHAR
 20+  582F 2C           	DB ','
 21+  5830              	; get pointer to register list
 22+  5830 3E 02            LD A,2
 23+  5832 06 01            LD B,1
 24+  5834 11 00 05         LD DE,#0500
 25+  5837 CD FF 60         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  583A C5           	PUSH BC
 27+  583B              	; ending )
 28+  583B CD D4 60     	CALL CHKCHAR
 29+  583E 29           	DB ')'
 30+  583F
 31+  583F              	; save BASIC token position
 32+  583F E5           	PUSH HL
 33+  5840 D9               EXX
 34+  5841 E1           	POP HL ; HL'=next basic token
 35+  5842 D9               EXX
 36+  5843
 37+  5843 E1               POP HL ; get pointer to register values
 38+  5844 F3           	DI
 39+  5845 ED 73 1C 58      LD (GENCAL_VAR_SP), SP
 40+  5849 F9               LD SP, HL
 41+  584A F1               POP AF
 42+  584B C1               POP BC
 43+  584C D1               POP DE
 44+  584D E1               POP HL
 45+  584E DD E1            POP IX
 46+  5850 FD E1            POP IY
 47+  5852 D9               EXX
 48+  5853 ED 73 1E 58      LD (GENCAL_VAR_SP2), SP
 49+  5857 ED 7B 1C 58      LD SP, (GENCAL_VAR_SP)
 50+  585B FB               EI
 51+  585C D1               POP DE ; get function to call
 52+  585D E5               PUSH HL
 53+  585E CD 79 58         CALL .EXXDECALL
 54+  5861 F3               DI
 55+  5862 ED 73 1C 58      LD (GENCAL_VAR_SP), SP
 56+  5866 ED 7B 1E 58      LD SP, (GENCAL_VAR_SP2)
 57+  586A FD E5            PUSH IY
 58+  586C DD E5            PUSH IX
 59+  586E E5               PUSH HL
 60+  586F D5               PUSH DE
 61+  5870 C5               PUSH BC
 62+  5871 F5               PUSH AF
 63+  5872 ED 7B 1C 58      LD SP, (GENCAL_VAR_SP)
 64+  5876 FB               EI
 65+  5877 E1               POP HL
 66+  5878 C9           	RET
 67+  5879
 68+  5879              .EXXDECALL:
 69+  5879 D5               PUSH DE
 70+  587A D9               EXX
 71+  587B C9               RET
 72+  587C              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
141   587C               ENDIF
142   587C
143   587C               IF (BOX_CMDS == 1)
144   587C               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  587C              ; *******************************************************************************************************
  2+  587C              ; generic function to implement rectangle data copy
  3+  587C              ; should be modified to call appropriate function for memory or vram
  4+  587C              ; input IX=pointer to following structure
  5+  587C              ; +00 source data pointer
  6+  587C              ; +02 num bytes in a row
  7+  587C              ; +04 number of rows
  8+  587C              ; +06 source add-to value till next row
  9+  587C              ; +08 destination address
 10+  587C              ; +10 destination add-to value till next row
 11+  587C              ; modifies AF, BC, DE, HL
 12+  587C              RECTANGLE_COPY:
 13+  587C DD 6E 00     	LD L, (IX+0)
 14+  587F DD 66 01     	LD H, (IX+1) ; source address
 15+  5882 DD 5E 08     	LD E, (IX+8)
 16+  5885 DD 56 09     	LD D, (IX+9) ; destination
 17+  5888 DD 46 04     	LD B, (IX+4) ; row number
 18+  588B              .L1:
 19+  588B C5           	PUSH BC
 20+  588C E5           		PUSH HL
 21+  588D D5           			PUSH DE
 22+  588E DD 4E 02     				LD C, (IX+2)
 23+  5891 DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  5894              .CALL1:
 25+  5894 CD 00 00     				CALL 0 ; set destination address from DE
 26+  5897              .CALL2:
 27+  5897 CD 00 00     				CALL 0 ; copy data fn
 28+  589A E1           			POP HL
 29+  589B DD 4E 0A     			LD C, (IX+10)
 30+  589E DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  58A1 09           			ADD HL, BC
 32+  58A2 EB           			EX DE, HL
 33+  58A3 E1           		POP HL
 34+  58A4 DD 4E 06     		LD C, (IX+6)
 35+  58A7 DD 46 07     		LD B, (IX+7) ; src add-to
 36+  58AA 09           		ADD HL, BC
 37+  58AB C1           	POP BC
 38+  58AC 10 DD        	DJNZ .L1
 39+  58AE C9           	RET
 40+  58AF              ; *******************************************************************************************************
 41+  58AF
 42+  58AF              ; *******************************************************************************************************
 43+  58AF              ; function to handle CALL BOXMEMCPY basic extension
 44+  58AF              ; copies data with window like boundaries within ram
 45+  58AF              ; BOXMEMCPY ( INT source data pointer,
 46+  58AF              ;			  INT source number of bytes in a row,
 47+  58AF              ;			  INT number of rows,
 48+  58AF              ;			  INT source add-to value till next row,
 49+  58AF              ; 			  INT destination pointer,
 50+  58AF              ;			  INT destination add-to value till next row )
 51+  58AF              ; request_data_ptr described in RECTANGLE_COPY
 52+  58AF              ; will put ram in page 0 also, page 1 is already there
 53+  58AF              BOXMEMCPY:
 54+  58AF 11 B9 58     	LD DE,BOXMEMCPY.RET
 55+  58B2 ED 53 2D 59  	LD (BOXCOMMON.ADDR+2), DE
 56+  58B6 C3 CC 58     	JP BOXCOMMON
 57+  58B9              .RET:
 58+  58B9 FB           	EI
 59+  58BA              	; set RAM functions to call
 60+  58BA 21 00 00     	LD HL, 0
 61+  58BD 22 94 58     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 62+  58C0 22 96 58     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 63+  58C3 21 ED B0     	LD HL, #B0ED ; LDIR
 64+  58C6 22 98 58     	LD (RECTANGLE_COPY.CALL1+4), HL
 65+  58C9 C3 32 59     	JP BOXCOMMON.CALL
 66+  58CC              ; *******************************************************************************************************
 67+  58CC
 68+  58CC              ; *******************************************************************************************************
 69+  58CC              ; common parts of BOX commands
 70+  58CC              BOXCOMMON:
 71+  58CC              	; opening (
 72+  58CC CD D4 60     	CALL CHKCHAR
 73+  58CF 28           	DB '('
 74+  58D0              	; get source data pointer
 75+  58D0 DD 21 2F 54  	LD IX, FRMQNT
 76+  58D4 CD 59 01     	CALL CALBAS
 77+  58D7 ED 53 0B 5E  	LD (BLIT_STRUCT+0), DE
 78+  58DB              	; comma
 79+  58DB CD D4 60     	CALL CHKCHAR
 80+  58DE 2C           	DB ','
 81+  58DF              	; source number of bytes in a row
 82+  58DF DD 21 2F 54  	LD IX, FRMQNT
 83+  58E3 CD 59 01     	CALL CALBAS
 84+  58E6 ED 53 0D 5E  	LD (BLIT_STRUCT+2), DE
 85+  58EA              	; comma
 86+  58EA CD D4 60     	CALL CHKCHAR
 87+  58ED 2C           	DB ','
 88+  58EE              	; number of rows
 89+  58EE DD 21 2F 54  	LD IX, FRMQNT
 90+  58F2 CD 59 01     	CALL CALBAS
 91+  58F5 ED 53 0F 5E  	LD (BLIT_STRUCT+4), DE
 92+  58F9              	; comma
 93+  58F9 CD D4 60     	CALL CHKCHAR
 94+  58FC 2C           	DB ','
 95+  58FD              	; source add-to value till next row
 96+  58FD DD 21 2F 54  	LD IX, FRMQNT
 97+  5901 CD 59 01     	CALL CALBAS
 98+  5904 ED 53 11 5E  	LD (BLIT_STRUCT+6), DE
 99+  5908              	; comma
100+  5908 CD D4 60     	CALL CHKCHAR
101+  590B 2C           	DB ','
102+  590C              	; destination pointer
103+  590C DD 21 2F 54  	LD IX, FRMQNT
104+  5910 CD 59 01     	CALL CALBAS
105+  5913 ED 53 13 5E  	LD (BLIT_STRUCT+8), DE
106+  5917              	; comma
107+  5917 CD D4 60     	CALL CHKCHAR
108+  591A 2C           	DB ','
109+  591B              	; destination add-to value till next row
110+  591B DD 21 2F 54  	LD IX, FRMQNT
111+  591F CD 59 01     	CALL CALBAS
112+  5922 ED 53 15 5E  	LD (BLIT_STRUCT+10), DE
113+  5926              	; ending )
114+  5926 CD D4 60     	CALL CHKCHAR
115+  5929 29           	DB ')'
116+  592A
117+  592A E5           	PUSH HL ; save position in BASIC buffer
118+  592B              .ADDR:
119+  592B FD 21 00 00  	LD IY, 0
120+  592F C3 87 60     	JP ENABLE_PAGE0
121+  5932              .CALL:
122+  5932 DD 21 0B 5E  	LD IX,BLIT_STRUCT
123+  5936 CD 7C 58     	CALL RECTANGLE_COPY
124+  5939 AF           	XOR A
125+  593A 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
126+  593D
127+  593D D1               POP DE
128+  593E C1               POP BC
129+  593F CD FE 5F         CALL RESTORE_PAGE_INFO
130+  5942
131+  5942 E1           	POP HL
132+  5943 C9           	RET
133+  5944              ; *******************************************************************************************************
134+  5944
135+  5944              ; *******************************************************************************************************
136+  5944              ; function to handle CALL BOXMEMVRM basic extension
137+  5944              ; copies data with window like boundaries from ram to Vram
138+  5944              ; BOXMEMVRM ( INT source data pointer,
139+  5944              ;			  INT source number of bytes in a row,
140+  5944              ;			  INT number of rows,
141+  5944              ;			  INT source add-to value till next row,
142+  5944              ; 			  INT destination pointer,
143+  5944              ;			  INT destination add-to value till next row )
144+  5944              ; request_data_ptr described in RECTANGLE_COPY
145+  5944              ; will put ram in page 0 also, page 1 is already there
146+  5944              BOXMEMVRM:
147+  5944 11 4E 59     	LD DE,BOXMEMVRM.RET
148+  5947 ED 53 2D 59  	LD (BOXCOMMON.ADDR+2), DE
149+  594B C3 CC 58     	JP BOXCOMMON
150+  594E              .RET:
151+  594E FB           	EI
152+  594F              	; set RAM functions to call
153+  594F 21 69 59     	LD HL, .SETDEST
154+  5952 22 95 58     	LD (RECTANGLE_COPY.CALL1+1), HL
155+  5955 21 71 59     	LD HL, .COPYDATA
156+  5958 22 98 58     	LD (RECTANGLE_COPY.CALL2+1), HL
157+  595B 3E CD        	LD A, #CD ; CALL
158+  595D 32 94 58     	LD (RECTANGLE_COPY.CALL1), A
159+  5960 32 97 58     	LD (RECTANGLE_COPY.CALL2), A
160+  5963              	;LD A,1
161+  5963 32 1C 5E     	LD (VRAM_UPDATE_IN_PROGRESS),A
162+  5966 C3 32 59     	JP BOXCOMMON.CALL
163+  5969              .SETDEST:
164+  5969 EB           	EX DE, HL
165+  596A F3           	DI
166+  596B CD AE 5F     	CALL SETWRT_LOCAL
167+  596E FB           	EI
168+  596F EB           	EX DE, HL
169+  5970 C9           	RET
170+  5971              .COPYDATA:
171+  5971 41           	LD B, C
172+  5972 C3 B9 5F     	JP BBYTECOPY
173+  5975              ; *******************************************************************************************************
# file closed: asm\BOX.asm
145   5975               ENDIF
146   5975
147   5975               IF (BLIT_CMDS == 1)
148   5975               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  5975              ; *******************************************************************************************************
  2+  5975              ; function rotates mask and data of several characters and applies to background data
  3+  5975              ; this handles x-shift from 0 to 4
  4+  5975              ; contains self-modifying code that is set-up from external function
  5+  5975              ; input HL=pointer to mask data
  6+  5975              ; input HL'=pointer to character data
  7+  5975              ; input DE=output buffer containing background data
  8+  5975              ; input BC=DE+8
  9+  5975              ; input A=number of characters to process
 10+  5975              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  5975              SHIFT04:
 12+  5975 08           	EX AF, AF'
 13+  5976 7E           	LD A, (HL) ; get mask
 14+  5977 D9           	EXX
 15+  5978 57           	LD D, A
 16+  5979 1E FF        	LD E, #FF
 17+  597B 37           	SCF
 18+  597C              .M1:
 19+  597C 18 FE        	JR .M1 ; this is self-modifying part
 20+  597E CB 1A        	RR D
 21+  5980 CB 1B        	RR E
 22+  5982 CB 1A        	RR D
 23+  5984 CB 1B        	RR E
 24+  5986 CB 1A        	RR D
 25+  5988 CB 1B        	RR E
 26+  598A CB 1A        	RR D
 27+  598C CB 1B        	RR E
 28+  598E
 29+  598E 46           	LD B, (HL) ; get data
 30+  598F 0E 00        	LD C, 0
 31+  5991              .M2:
 32+  5991 18 FE        	JR .M2 ; also self-modifying part
 33+  5993 CB 38        	SRL B
 34+  5995 CB 19        	RR C
 35+  5997 CB 38        	SRL B
 36+  5999 CB 19        	RR C
 37+  599B CB 38        	SRL B
 38+  599D CB 19        	RR C
 39+  599F CB 38        	SRL B
 40+  59A1 CB 19        	RR C
 41+  59A3
 42+  59A3 D9           	EXX
 43+  59A4 1A           	LD A, (DE) ; background
 44+  59A5 D9           	EXX
 45+  59A6 A2           	AND D
 46+  59A7 B0           	OR B
 47+  59A8 D9           	EXX
 48+  59A9 12           	LD (DE), A
 49+  59AA
 50+  59AA 0A           	LD A, (BC)
 51+  59AB D9           	EXX
 52+  59AC A3           	AND E
 53+  59AD B1           	OR C
 54+  59AE 23           	INC HL
 55+  59AF D9           	EXX
 56+  59B0 02           	LD (BC), A
 57+  59B1
 58+  59B1 23           	INC HL
 59+  59B2 13           	INC DE
 60+  59B3 03           	INC BC
 61+  59B4
 62+  59B4 08           	EX AF, AF'
 63+  59B5 3D           	DEC A
 64+  59B6 C2 75 59     	JP NZ, SHIFT04
 65+  59B9 C9           	RET
 66+  59BA              ; *******************************************************************************************************
 67+  59BA
 68+  59BA              ; *******************************************************************************************************
 69+  59BA              ; function rotates mask and data of several characters and applies to background data
 70+  59BA              ; this handles x-shift from 5 to 8
 71+  59BA              ; contains self-modifying code that is set-up from external function
 72+  59BA              ; input HL=pointer to mask data
 73+  59BA              ; input HL'=pointer to character data
 74+  59BA              ; input DE=output buffer containing background data
 75+  59BA              ; input BC=DE+8
 76+  59BA              ; input A=number of characters to process
 77+  59BA              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  59BA              SHIFT58:
 79+  59BA 08           	EX AF, AF'
 80+  59BB 7E           	LD A, (HL) ; get mask
 81+  59BC D9           	EXX
 82+  59BD 57           	LD D, A
 83+  59BE 1E FF        	LD E, #FF
 84+  59C0 37           	SCF
 85+  59C1              .M1:
 86+  59C1 18 FE        	JR .M1 ; this is self-modifying part
 87+  59C3 CB 12        	RL D
 88+  59C5 CB 13        	RL E
 89+  59C7 CB 12        	RL D
 90+  59C9 CB 13        	RL E
 91+  59CB CB 12        	RL D
 92+  59CD CB 13        	RL E
 93+  59CF
 94+  59CF 46           	LD B, (HL)
 95+  59D0 0E 00        	LD C, 0
 96+  59D2              .M2:
 97+  59D2 18 FE        	JR .M2 ; also self-modifying part
 98+  59D4 CB 20        	SLA B
 99+  59D6 CB 11        	RL C
100+  59D8 CB 20        	SLA B
101+  59DA CB 11        	RL C
102+  59DC CB 20        	SLA B
103+  59DE CB 11        	RL C
104+  59E0
105+  59E0 D9           	EXX
106+  59E1 1A           	LD A, (DE) ; background
107+  59E2 D9           	EXX
108+  59E3 A3           	AND E
109+  59E4 B1           	OR C
110+  59E5 D9           	EXX
111+  59E6 12           	LD (DE), A
112+  59E7
113+  59E7 0A           	LD A, (BC)
114+  59E8 D9           	EXX
115+  59E9 A2           	AND D
116+  59EA B0           	OR B
117+  59EB 23           	INC HL
118+  59EC D9           	EXX
119+  59ED 02           	LD (BC), A
120+  59EE
121+  59EE 23           	INC HL
122+  59EF 13           	INC DE
123+  59F0 03           	INC BC
124+  59F1
125+  59F1 08           	EX AF, AF'
126+  59F2 3D           	DEC A
127+  59F3 C2 BA 59     	JP NZ, SHIFT58
128+  59F6 C9           	RET
129+  59F7              ; *******************************************************************************************************
130+  59F7
131+  59F7              ; *******************************************************************************************************
132+  59F7              ; routine that shifts one row of characters
133+  59F7              ; contains self-modifying code that is set-up from external function
134+  59F7              ; input HL=pointer to mask data
135+  59F7              ; input HL'=pointer to character data
136+  59F7              ; input DE=output buffer containing background data
137+  59F7              ; input A=number of characters to process
138+  59F7              ; input IX=pointer to structure describing input data
139+  59F7              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  59F7              SHIFT_ROW:
141+  59F7 F5           	PUSH AF
142+  59F8 ED 53 07 5E  		LD (BLIT_TMP1), DE
143+  59FC E5           		PUSH HL
144+  59FD CD 40 5A     			CALL .ADDYSHIFT
145+  5A00 E1           		POP HL
146+  5A01 ED 53 09 5E  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  5A05              .L1:
148+  5A05 3E 08        		LD A, 8
149+  5A07 DD 96 02     		SUB (IX+2) ; y shift
150+  5A0A              .CALL1:
151+  5A0A CD 00 00     		CALL 0
152+  5A0D DD 7E 02     		LD A, (IX+2); y shift
153+  5A10 B7           		OR A
154+  5A11 28 26        		JR Z, .DONE
155+  5A13 ED 5B 07 5E  		LD DE, (BLIT_TMP1)
156+  5A17 E5           		PUSH HL
157+  5A18 CD 4E 5A     			CALL .DETONEXTROW
158+  5A1B E1           		POP HL
159+  5A1C              .CALL2:
160+  5A1C CD 00 00     		CALL 0
161+  5A1F ED 5B 07 5E  		LD DE, (BLIT_TMP1)
162+  5A23 E5           		PUSH HL
163+  5A24 CD 48 5A     			CALL .ADD8
164+  5A27 E1           		POP HL
165+  5A28 ED 53 07 5E  		LD (BLIT_TMP1), DE
166+  5A2C ED 5B 09 5E  		LD DE, (BLIT_TMP2)
167+  5A30 E5           		PUSH HL
168+  5A31 CD 48 5A     			CALL .ADD8
169+  5A34 E1           		POP HL
170+  5A35 ED 53 09 5E  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  5A39              .DONE:
172+  5A39 F1           	POP AF
173+  5A3A 3D           	DEC A
174+  5A3B C8           	RET Z
175+  5A3C F5           	PUSH AF
176+  5A3D C3 05 5A     	JP .L1
177+  5A40              .ADDYSHIFT:
178+  5A40 EB           	EX DE, HL
179+  5A41 16 00        	LD D, 0
180+  5A43 DD 5E 02     	LD E, (IX+2); y shift
181+  5A46 18 0C        	JR .MOVDEBC
182+  5A48              .ADD8:
183+  5A48 21 08 00     	LD HL, 8
184+  5A4B C3 54 5A     	JP .MOVDEBC
185+  5A4E              .DETONEXTROW:
186+  5A4E DD 6E 06     	LD L, (IX+6)
187+  5A51 DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  5A54              .MOVDEBC:
189+  5A54 19           	ADD HL, DE
190+  5A55 54           	LD D, H
191+  5A56 5D           	LD E, L
192+  5A57 01 08 00     	LD BC, 8
193+  5A5A 09           	ADD HL, BC
194+  5A5B 44           	LD B, H
195+  5A5C 4D           	LD C, L
196+  5A5D C9           	RET
197+  5A5E              ; *******************************************************************************************************
198+  5A5E
199+  5A5E              ; *******************************************************************************************************
200+  5A5E              ; function rotates mask and character data and applies it to background
201+  5A5E              ; input IX=pointer to structure describing input data
202+  5A5E              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  5A5E              ; +2  DW vertical shift count 0-7 (low byte used)
204+  5A5E              ; +4  DW background data start;
205+  5A5E              ; +6  DW background add to value to next row of background data
206+  5A5E              ; +8  DW mask data start;
207+  5A5E              ; +10  DW character data start;
208+  5A5E              ; +12 DW character&mask add to value to next row of data
209+  5A5E              ; +14 DW columns (low byte used)
210+  5A5E              ; +16 DW rows (low byte used)
211+  5A5E              SHIFT_MERGE_CHARACTER:
212+  5A5E DD 7E 00     	LD A, (IX) ; shift
213+  5A61 FE 05        	CP 5
214+  5A63 38 25        	JR C, .RIGHT
215+  5A65              	; shifts 5-7, use rotate towards left 1-3
216+  5A65 21 BA 59     	LD HL, SHIFT58
217+  5A68 22 0B 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  5A6B 22 1D 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  5A6E D6 05        	SUB 5
220+  5A70 28 0D        	JR Z, .L1
221+  5A72 87           	ADD A, A
222+  5A73 87           	ADD A, A
223+  5A74 67           	LD H, A
224+  5A75 2E 18        	LD L, #18 ; JR opcode
225+  5A77 22 C1 59     	LD (SHIFT58.M1), HL
226+  5A7A 22 D2 59     	LD (SHIFT58.M2), HL
227+  5A7D 18 32        	JR .DO
228+  5A7F              .L1:
229+  5A7F 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  5A82 22 C1 59     	LD (SHIFT58.M1), HL
231+  5A85 22 D2 59     	LD (SHIFT58.M2), HL
232+  5A88 18 27        	JR .DO
233+  5A8A              .RIGHT:
234+  5A8A              	; shifts 0-4, rotate towards right
235+  5A8A 21 75 59     	LD HL, SHIFT04
236+  5A8D 22 0B 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  5A90 22 1D 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  5A93 FE 04        	CP 4
239+  5A95 28 11        	JR Z, .R1
240+  5A97 D6 04        	SUB 4
241+  5A99 ED 44        	NEG
242+  5A9B 87           	ADD A, A
243+  5A9C 87           	ADD A, A
244+  5A9D 67           	LD H, A
245+  5A9E 2E 18        	LD L, #18 ; JR opcode
246+  5AA0 22 7C 59     	LD (SHIFT04.M1), HL
247+  5AA3 22 91 59     	LD (SHIFT04.M2), HL
248+  5AA6 18 09        	JR .DO
249+  5AA8              .R1:
250+  5AA8 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  5AAB 22 7C 59     	LD (SHIFT04.M1), HL
252+  5AAE 22 91 59     	LD (SHIFT04.M2), HL
253+  5AB1              .DO:
254+  5AB1 DD 46 10     	LD B, (IX+16) ; rows
255+  5AB4 DD 6E 08     	LD L, (IX+8)
256+  5AB7 DD 66 09     	LD H, (IX+9) ; mask data
257+  5ABA DD 5E 04     	LD E, (IX+4)
258+  5ABD DD 56 05     	LD D, (IX+5) ; background data
259+  5AC0 D9           	EXX
260+  5AC1 DD 6E 0A     	LD L, (IX+10)
261+  5AC4 DD 66 0B     	LD H, (IX+11) ; character data
262+  5AC7 D9           	EXX
263+  5AC8              .LOOP:
264+  5AC8 C5           	PUSH BC
265+  5AC9 E5           		PUSH HL
266+  5ACA D5           			PUSH DE
267+  5ACB D9           				EXX
268+  5ACC E5           				PUSH HL
269+  5ACD D9           					EXX
270+  5ACE DD 7E 0E     					LD A, (IX+14) ; columns
271+  5AD1              .CALL:
272+  5AD1 CD F7 59     					CALL SHIFT_ROW
273+  5AD4 E1           				POP HL
274+  5AD5 DD 5E 0C     				LD E, (IX+12)
275+  5AD8 DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  5ADB 19           				ADD HL, DE
277+  5ADC D9           				EXX
278+  5ADD E1           			POP HL
279+  5ADE DD 5E 06     			LD E, (IX+6)
280+  5AE1 DD 56 07     			LD D, (IX+7) ; background to next row
281+  5AE4 19           			ADD HL, DE
282+  5AE5 EB           			EX DE, HL
283+  5AE6 E1           		POP HL
284+  5AE7 DD 4E 0C     		LD C, (IX+12)
285+  5AEA DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  5AED 09           		ADD HL, BC
287+  5AEE C1           	POP BC
288+  5AEF 10 D7        	DJNZ .LOOP
289+  5AF1 C9           	RET
290+  5AF2              ; *******************************************************************************************************
291+  5AF2
292+  5AF2               IFNDEF CMDS_WITH_PARAMETERS
293+  5AF2 ~            ; *******************************************************************************************************
294+  5AF2 ~            ; function to handle CALL BLIT basic extension
295+  5AF2 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  5AF2 ~            ; fuses with background data and applies vertical shift too
297+  5AF2 ~            ; BLIT ( INT request_data_ptr )
298+  5AF2 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  5AF2 ~            ; will put ram in page 0 also, page 1 is already there
300+  5AF2 ~            BLIT:
301+  5AF2 ~            	; opening (
302+  5AF2 ~            	CALL CHKCHAR
303+  5AF2 ~            	DB '('
304+  5AF2 ~            	; get pointer to request struct
305+  5AF2 ~            	LD IX, FRMQNT
306+  5AF2 ~            	CALL CALBAS
307+  5AF2 ~            	PUSH DE
308+  5AF2 ~            	; ending )
309+  5AF2 ~            	CALL CHKCHAR
310+  5AF2 ~            	DB ')'
311+  5AF2 ~
312+  5AF2 ~            	POP IX ; pointer to request struct
313+  5AF2 ~
314+  5AF2 ~            	PUSH HL ; save position in BASIC buffer
315+  5AF2 ~
316+  5AF2 ~            	LD IY, .RET
317+  5AF2 ~            	JP ENABLE_PAGE0
318+  5AF2 ~            .RET:
319+  5AF2 ~            	EI
320+  5AF2 ~            	CALL SHIFT_MERGE_CHARACTER
321+  5AF2 ~
322+  5AF2 ~                POP DE
323+  5AF2 ~                POP BC
324+  5AF2 ~                CALL RESTORE_PAGE_INFO
325+  5AF2 ~
326+  5AF2 ~            	POP HL
327+  5AF2 ~            	RET
328+  5AF2 ~            ; *******************************************************************************************************
329+  5AF2               ENDIF
330+  5AF2
331+  5AF2               IFDEF CMDS_WITH_PARAMETERS
332+  5AF2              ; *******************************************************************************************************
333+  5AF2              ; function to handle CALL BLIT basic extension
334+  5AF2              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  5AF2              ; fuses with background data and applies vertical shift too
336+  5AF2              ; in form without pointers
337+  5AF2              ; BLIT ( INT x,
338+  5AF2              ;		 INT y,
339+  5AF2              ;		 INT char_data_pointer,
340+  5AF2              ;		 INT mask_data_pointer,
341+  5AF2              ;		 INT width (in characters),
342+  5AF2              ;		 INT height (in characters),
343+  5AF2              ;		 INT background_pointer (top left),
344+  5AF2              ;		 INT background_width (in characters),
345+  5AF2              ;		 INT background_height (in characters))
346+  5AF2              ; will put ram in page 0 also, page 1 is already there
347+  5AF2              BLIT:
348+  5AF2              	; opening (
349+  5AF2 CD D4 60     	CALL CHKCHAR
350+  5AF5 28           	DB '('
351+  5AF6              	; get x coordinate
352+  5AF6 DD 21 2F 54  	LD IX, FRMQNT
353+  5AFA CD 59 01     	CALL CALBAS
354+  5AFD 7B           	LD A, E
355+  5AFE E6 07        	AND 7
356+  5B00 32 0B 5E     	LD (BLIT_STRUCT+0), A
357+  5B03 CD E0 5B     	CALL .DAdiv8
358+  5B06 32 07 5E     	LD (BLIT_TMP+0),A
359+  5B09              	; comma
360+  5B09 CD D4 60     	CALL CHKCHAR
361+  5B0C 2C           	DB ','
362+  5B0D              	; get y coordinate
363+  5B0D DD 21 2F 54  	LD IX, FRMQNT
364+  5B11 CD 59 01     	CALL CALBAS
365+  5B14 7B           	LD A, E
366+  5B15 E6 07        	AND 7
367+  5B17 32 0D 5E     	LD (BLIT_STRUCT+2), A
368+  5B1A CD E0 5B     	CALL .DAdiv8
369+  5B1D 32 08 5E     	LD (BLIT_TMP+1),A
370+  5B20              	; comma
371+  5B20 CD D4 60     	CALL CHKCHAR
372+  5B23 2C           	DB ','
373+  5B24              	; get char data pointer
374+  5B24 DD 21 2F 54  	LD IX, FRMQNT
375+  5B28 CD 59 01     	CALL CALBAS
376+  5B2B ED 53 15 5E  	LD (BLIT_STRUCT+10), DE
377+  5B2F              	; comma
378+  5B2F CD D4 60     	CALL CHKCHAR
379+  5B32 2C           	DB ','
380+  5B33              	; get mask data pointer
381+  5B33 DD 21 2F 54  	LD IX, FRMQNT
382+  5B37 CD 59 01     	CALL CALBAS
383+  5B3A ED 53 13 5E  	LD (BLIT_STRUCT+8), DE
384+  5B3E              	; comma
385+  5B3E CD D4 60     	CALL CHKCHAR
386+  5B41 2C           	DB ','
387+  5B42              	; get width
388+  5B42 DD 21 2F 54  	LD IX, FRMQNT
389+  5B46 CD 59 01     	CALL CALBAS
390+  5B49 7B           	LD A, E
391+  5B4A 32 19 5E     	LD (BLIT_STRUCT+14), A
392+  5B4D              	; comma
393+  5B4D CD D4 60     	CALL CHKCHAR
394+  5B50 2C           	DB ','
395+  5B51              	; get height
396+  5B51 DD 21 2F 54  	LD IX, FRMQNT
397+  5B55 CD 59 01     	CALL CALBAS
398+  5B58 7B           	LD A, E
399+  5B59 32 1B 5E     	LD (BLIT_STRUCT+16), A
400+  5B5C              	; comma
401+  5B5C CD D4 60     	CALL CHKCHAR
402+  5B5F 2C           	DB ','
403+  5B60              	; get background pointer
404+  5B60 DD 21 2F 54  	LD IX, FRMQNT
405+  5B64 CD 59 01     	CALL CALBAS
406+  5B67 ED 53 0F 5E  	LD (BLIT_STRUCT+4), DE
407+  5B6B              	; comma
408+  5B6B CD D4 60     	CALL CHKCHAR
409+  5B6E 2C           	DB ','
410+  5B6F              	; get background width
411+  5B6F DD 21 2F 54  	LD IX, FRMQNT
412+  5B73 CD 59 01     	CALL CALBAS
413+  5B76 7B           	LD A, E
414+  5B77 32 09 5E     	LD (BLIT_TMP+2), A
415+  5B7A              	; comma
416+  5B7A CD D4 60     	CALL CHKCHAR
417+  5B7D 2C           	DB ','
418+  5B7E              	; get background height
419+  5B7E DD 21 2F 54  	LD IX, FRMQNT
420+  5B82 CD 59 01     	CALL CALBAS
421+  5B85 7B           	LD A, E
422+  5B86 32 0A 5E     	LD (BLIT_TMP+3), A
423+  5B89              	; ending )
424+  5B89 CD D4 60     	CALL CHKCHAR
425+  5B8C 29           	DB ')'
426+  5B8D
427+  5B8D E5           	PUSH HL ; save position in BASIC buffer
428+  5B8E
429+  5B8E              	; calculate char&mask add to value
430+  5B8E 26 00        	LD H, 0
431+  5B90 3A 19 5E     	LD A, (BLIT_STRUCT+14)
432+  5B93 6F           	LD L, A
433+  5B94 CD C3 5F     	CALL HLx8
434+  5B97 22 17 5E     	LD (BLIT_STRUCT+12), HL
435+  5B9A              	; calculate background add to value
436+  5B9A 26 00        	LD H, 0
437+  5B9C 3A 09 5E     	LD A, (BLIT_TMP+2)
438+  5B9F 6F           	LD L, A
439+  5BA0 CD C3 5F     	CALL HLx8
440+  5BA3 22 11 5E     	LD (BLIT_STRUCT+6), HL
441+  5BA6              	; calculate pointer to background location
442+  5BA6 21 00 00     	LD HL, 0
443+  5BA9 3A 08 5E     	LD A,(BLIT_TMP+1)
444+  5BAC B7           	OR A
445+  5BAD 28 08        	JR Z, .L1
446+  5BAF 47           	LD B,A
447+  5BB0 ED 5B 11 5E  	LD DE,(BLIT_STRUCT+6)
448+  5BB4              .L0:
449+  5BB4 19           	ADD HL, DE
450+  5BB5 10 FD        	DJNZ .L0
451+  5BB7              .L1:
452+  5BB7 EB           	EX DE,HL
453+  5BB8 26 00        	LD H,0
454+  5BBA 3A 07 5E     	LD A,(BLIT_TMP+0)
455+  5BBD 6F           	LD L,A
456+  5BBE CD C3 5F     	CALL HLx8
457+  5BC1 19           	ADD HL,DE
458+  5BC2 ED 5B 0F 5E  	LD DE,(BLIT_STRUCT+4)
459+  5BC6 19           	ADD HL,DE
460+  5BC7 22 0F 5E     	LD (BLIT_STRUCT+4),HL
461+  5BCA
462+  5BCA FD 21 D1 5B  	LD IY, .RET
463+  5BCE C3 87 60     	JP ENABLE_PAGE0
464+  5BD1              .RET:
465+  5BD1 FB           	EI
466+  5BD2 DD 21 0B 5E  	LD IX, BLIT_STRUCT
467+  5BD6 CD 5E 5A     	CALL SHIFT_MERGE_CHARACTER
468+  5BD9
469+  5BD9 D1               POP DE
470+  5BDA C1               POP BC
471+  5BDB CD FE 5F         CALL RESTORE_PAGE_INFO
472+  5BDE
473+  5BDE E1           	POP HL
474+  5BDF C9           	RET
475+  5BE0              .DAdiv8:
476+  5BE0 7B           	LD A,E
477+  5BE1 CB 2A        	SRA D
478+  5BE3 CB 1F            RR  A
479+  5BE5 CB 2A            SRA D
480+  5BE7 CB 1F            RR  A
481+  5BE9 CB 2A            SRA D
482+  5BEB CB 1F            RR  A
483+  5BED C9           	RET
484+  5BEE              ; *******************************************************************************************************
485+  5BEE               ENDIF
# file closed: asm\BLIT.asm
149   5BEE               ENDIF
150   5BEE
151   5BEE               IF (TILE_CMDS == 1)
152   5BEE               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5BEE              ; *******************************************************************************************************
  2+  5BEE              ; generic function to implement tiling
  3+  5BEE              ; should be modified to call appropriate function for memory or vram
  4+  5BEE              ; input IX=pointer to following structure
  5+  5BEE              ; +00 tile_data_ptr
  6+  5BEE              ; +02 tile_rows
  7+  5BEE              ; +04 tile_columns
  8+  5BEE              ; +06 destination_address
  9+  5BEE              ; +08 dest_to_next_row_add_to_value
 10+  5BEE              ; +10 num_horizontal_tiles
 11+  5BEE              ; +12 num_vertical_tiles
 12+  5BEE              ; modifies AF, BC, DE, HL
 13+  5BEE              TILE:
 14+  5BEE DD 6E 06     	LD L, (IX+6)
 15+  5BF1 DD 66 07     	LD H, (IX+7) ; destination address
 16+  5BF4 22 07 5E     	LD (TILETMP1), HL
 17+  5BF7 DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5BFA              .L1:
 19+  5BFA C5           	PUSH BC
 20+  5BFB DD 6E 00     		LD L, (IX+0)
 21+  5BFE DD 66 01     		LD H, (IX+1) ; tile address
 22+  5C01 22 09 5E     		LD (TILETMP2), HL
 23+  5C04 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5C07              .L2:
 25+  5C07 C5           		PUSH BC
 26+  5C08 CD 00 00     .CALL1:		CALL 0
 27+  5C0B DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5C0E              .L3:
 29+  5C0E C5           			PUSH BC
 30+  5C0F 2A 09 5E     				LD HL, (TILETMP2)
 31+  5C12 DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5C15              .L4:
 33+  5C15 C5           				PUSH BC
 34+  5C16              .CALL2:
 35+  5C16 CD 00 00     					CALL 0
 36+  5C19 C1           				POP BC
 37+  5C1A 10 F9        				DJNZ .L4
 38+  5C1C C1           			POP BC
 39+  5C1D 10 EF        			DJNZ .L3
 40+  5C1F 22 09 5E     			LD (TILETMP2), HL
 41+  5C22 2A 07 5E     			LD HL, (TILETMP1)
 42+  5C25 DD 5E 08     			LD E, (IX+8)
 43+  5C28 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5C2B 19           			ADD HL, DE
 45+  5C2C 22 07 5E     			LD (TILETMP1), HL
 46+  5C2F C1           		POP BC
 47+  5C30 10 D5        		DJNZ .L2
 48+  5C32 C1           	POP BC
 49+  5C33 10 C5        	DJNZ .L1
 50+  5C35 C9           	RET
 51+  5C36              ; *******************************************************************************************************
 52+  5C36
 53+  5C36               IFNDEF CMDS_WITH_PARAMETERS
 54+  5C36 ~            ; *******************************************************************************************************
 55+  5C36 ~            ; function to handle CALL TILERAM basic extension
 56+  5C36 ~            ; fills memory with tiles
 57+  5C36 ~            ; TILERAM ( INT request_data_ptr )
 58+  5C36 ~            ; request_data_ptr described in TILE
 59+  5C36 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5C36 ~            TILERAM:
 61+  5C36 ~            	; opening (
 62+  5C36 ~            	CALL CHKCHAR
 63+  5C36 ~            	DB '('
 64+  5C36 ~            	; get pointer to request struct
 65+  5C36 ~            	LD IX, FRMQNT
 66+  5C36 ~            	CALL CALBAS
 67+  5C36 ~            	PUSH DE
 68+  5C36 ~            	; ending )
 69+  5C36 ~            	CALL CHKCHAR
 70+  5C36 ~            	DB ')'
 71+  5C36 ~
 72+  5C36 ~            	POP IX ; pointer to request struct
 73+  5C36 ~
 74+  5C36 ~            	PUSH HL ; save position in BASIC buffer
 75+  5C36 ~
 76+  5C36 ~            	LD IY, .RET
 77+  5C36 ~            	JP ENABLE_PAGE0
 78+  5C36 ~            .RET:
 79+  5C36 ~            	EI
 80+  5C36 ~            	; set RAM functions to call
 81+  5C36 ~            	LD HL, .TILECOPY
 82+  5C36 ~            	LD (TILE.CALL2+1), HL
 83+  5C36 ~            	LD HL, .SETDESTROW
 84+  5C36 ~            	LD (TILE.CALL1+1), HL
 85+  5C36 ~            	LD A,1
 86+  5C36 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5C36 ~            	CALL TILE
 88+  5C36 ~            	XOR A
 89+  5C36 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5C36 ~
 91+  5C36 ~                POP DE
 92+  5C36 ~                POP BC
 93+  5C36 ~                CALL RESTORE_PAGE_INFO
 94+  5C36 ~
 95+  5C36 ~            	POP HL
 96+  5C36 ~            	RET
 97+  5C36 ~            .TILECOPY:
 98+  5C36 ~            	.8 LDI
 99+  5C36 ~            	RET
100+  5C36 ~            .SETDESTROW:
101+  5C36 ~            	LD DE, (TILETMP1)
102+  5C36 ~            	RET
103+  5C36 ~            ; *******************************************************************************************************
104+  5C36               ENDIF
105+  5C36
106+  5C36               IFDEF CMDS_WITH_PARAMETERS
107+  5C36              ; *******************************************************************************************************
108+  5C36              ; function to handle CALL TILERAM basic extension
109+  5C36              ; fills memory with tiles
110+  5C36              ; TILERAM ( INT tile_data_pointer,
111+  5C36              ;			INT tile_columns,
112+  5C36              ;			INT tile_rows,
113+  5C36              ;			INT destination_pointer,
114+  5C36              ;			INT destination_columns,
115+  5C36              ;			INT destination_rows,
116+  5C36              ;			INT destination_begin_column,
117+  5C36              ;			INT destination_begin_row,
118+  5C36              ;			INT number_of_tiles_horizontally,
119+  5C36              ;			INT	number_of_tiles_vertically )
120+  5C36              ; will put ram in page 0 also, page 1 is already there
121+  5C36              TILERAM:
122+  5C36              	; opening (
123+  5C36 CD D4 60     	CALL CHKCHAR
124+  5C39 28           	DB '('
125+  5C3A              	; get tile data pointer coordinate
126+  5C3A DD 21 2F 54  	LD IX, FRMQNT
127+  5C3E CD 59 01     	CALL CALBAS
128+  5C41 ED 53 0B 5E  	LD (BLIT_STRUCT+0), DE
129+  5C45              	; comma
130+  5C45 CD D4 60     	CALL CHKCHAR
131+  5C48 2C           	DB ','
132+  5C49              	; get tile columns
133+  5C49 DD 21 2F 54  	LD IX, FRMQNT
134+  5C4D CD 59 01     	CALL CALBAS
135+  5C50 ED 53 0F 5E  	LD (BLIT_STRUCT+4), DE
136+  5C54              	; comma
137+  5C54 CD D4 60     	CALL CHKCHAR
138+  5C57 2C           	DB ','
139+  5C58              	; get tile columns
140+  5C58 DD 21 2F 54  	LD IX, FRMQNT
141+  5C5C CD 59 01     	CALL CALBAS
142+  5C5F ED 53 0D 5E  	LD (BLIT_STRUCT+2), DE
143+  5C63              	; comma
144+  5C63 CD D4 60     	CALL CHKCHAR
145+  5C66 2C           	DB ','
146+  5C67              	; get destintion pointer
147+  5C67 DD 21 2F 54  	LD IX, FRMQNT
148+  5C6B CD 59 01     	CALL CALBAS
149+  5C6E ED 53 11 5E  	LD (BLIT_STRUCT+6), DE
150+  5C72              	; comma
151+  5C72 CD D4 60     	CALL CHKCHAR
152+  5C75 2C           	DB ','
153+  5C76              	; get destination columns
154+  5C76 DD 21 2F 54  	LD IX, FRMQNT
155+  5C7A CD 59 01     	CALL CALBAS
156+  5C7D 7B           	LD A, E
157+  5C7E 32 07 5E     	LD (BLIT_TMP+0), A
158+  5C81              	; comma
159+  5C81 CD D4 60     	CALL CHKCHAR
160+  5C84 2C           	DB ','
161+  5C85              	; get destination rows
162+  5C85 DD 21 2F 54  	LD IX, FRMQNT
163+  5C89 CD 59 01     	CALL CALBAS
164+  5C8C 7B           	LD A, E
165+  5C8D 32 08 5E     	LD (BLIT_TMP+1), A
166+  5C90              	; comma
167+  5C90 CD D4 60     	CALL CHKCHAR
168+  5C93 2C           	DB ','
169+  5C94              	; get destination begin column
170+  5C94 DD 21 2F 54  	LD IX, FRMQNT
171+  5C98 CD 59 01     	CALL CALBAS
172+  5C9B 7B           	LD A, E
173+  5C9C 32 09 5E     	LD (BLIT_TMP+2), A
174+  5C9F              	; comma
175+  5C9F CD D4 60     	CALL CHKCHAR
176+  5CA2 2C           	DB ','
177+  5CA3              	; get destination begin row
178+  5CA3 DD 21 2F 54  	LD IX, FRMQNT
179+  5CA7 CD 59 01     	CALL CALBAS
180+  5CAA 7B           	LD A, E
181+  5CAB 32 0A 5E     	LD (BLIT_TMP+3), A
182+  5CAE              	; comma
183+  5CAE CD D4 60     	CALL CHKCHAR
184+  5CB1 2C           	DB ','
185+  5CB2              	; get number of tiles horizontally
186+  5CB2 DD 21 2F 54  	LD IX, FRMQNT
187+  5CB6 CD 59 01     	CALL CALBAS
188+  5CB9 ED 53 15 5E  	LD (BLIT_STRUCT+10), DE
189+  5CBD              	; comma
190+  5CBD CD D4 60     	CALL CHKCHAR
191+  5CC0 2C           	DB ','
192+  5CC1              	; get number of tiles vertically
193+  5CC1 DD 21 2F 54  	LD IX, FRMQNT
194+  5CC5 CD 59 01     	CALL CALBAS
195+  5CC8 ED 53 17 5E  	LD (BLIT_STRUCT+12), DE
196+  5CCC              	; ending )
197+  5CCC CD D4 60     	CALL CHKCHAR
198+  5CCF 29           	DB ')'
199+  5CD0
200+  5CD0 E5           	PUSH HL ; save position in BASIC buffer
201+  5CD1
202+  5CD1              	; calculate destination add to value
203+  5CD1 26 00        	LD H, 0
204+  5CD3 3A 07 5E     	LD A, (BLIT_TMP+0)
205+  5CD6 6F           	LD L, A
206+  5CD7 CD C3 5F     	CALL HLx8
207+  5CDA 22 13 5E     	LD (BLIT_STRUCT+8), HL
208+  5CDD              	; calculate pointer to background location
209+  5CDD 21 00 00     	LD HL, 0
210+  5CE0 3A 0A 5E     	LD A,(BLIT_TMP+3)
211+  5CE3 B7           	OR A
212+  5CE4 28 08        	JR Z, .L1
213+  5CE6 47           	LD B,A
214+  5CE7 ED 5B 13 5E  	LD DE,(BLIT_STRUCT+8)
215+  5CEB              .L0:
216+  5CEB 19           	ADD HL, DE
217+  5CEC 10 FD        	DJNZ .L0
218+  5CEE              .L1:
219+  5CEE EB           	EX DE,HL
220+  5CEF 26 00        	LD H,0
221+  5CF1 3A 09 5E     	LD A,(BLIT_TMP+2)
222+  5CF4 6F           	LD L,A
223+  5CF5 CD C3 5F     	CALL HLx8
224+  5CF8 19           	ADD HL,DE
225+  5CF9 ED 5B 11 5E  	LD DE,(BLIT_STRUCT+6)
226+  5CFD 19           	ADD HL,DE
227+  5CFE 22 11 5E     	LD (BLIT_STRUCT+6),HL
228+  5D01
229+  5D01 FD 21 08 5D  	LD IY, .RET
230+  5D05 C3 87 60     	JP ENABLE_PAGE0
231+  5D08              .RET:
232+  5D08 FB           	EI
233+  5D09              	; set RAM functions to call
234+  5D09 21 23 5D     	LD HL, .TILECOPY
235+  5D0C 22 17 5C     	LD (TILE.CALL2+1), HL
236+  5D0F 21 34 5D     	LD HL, .SETDESTROW
237+  5D12 22 09 5C     	LD (TILE.CALL1+1), HL
238+  5D15 DD 21 0B 5E  	LD IX,BLIT_STRUCT
239+  5D19 CD EE 5B     	CALL TILE
240+  5D1C
241+  5D1C D1               POP DE
242+  5D1D C1               POP BC
243+  5D1E CD FE 5F         CALL RESTORE_PAGE_INFO
244+  5D21
245+  5D21 E1           	POP HL
246+  5D22 C9           	RET
247+  5D23              .TILECOPY:
248+  5D23 ED A0       > LDI
248+  5D25 ED A0       > LDI
248+  5D27 ED A0       > LDI
248+  5D29 ED A0       > LDI
248+  5D2B ED A0       > LDI
248+  5D2D ED A0       > LDI
248+  5D2F ED A0       > LDI
248+  5D31 ED A0       > LDI
249+  5D33 C9           	RET
250+  5D34              .SETDESTROW:
251+  5D34 ED 5B 07 5E  	LD DE, (TILETMP1)
252+  5D38 C9           	RET
253+  5D39              ; *******************************************************************************************************
254+  5D39               ENDIF
255+  5D39
256+  5D39               IFDEF CMDS_WITH_PARAMETERS
257+  5D39              ; *******************************************************************************************************
258+  5D39              ; function to handle CALL TILEVRM basic extension
259+  5D39              ; fills vram with tiles
260+  5D39              ; TILEVRM ( INT tile_data_pointer,
261+  5D39              ;			INT tile_columns,
262+  5D39              ;			INT tile_rows,
263+  5D39              ;			INT destination_begin_column,
264+  5D39              ;			INT destination_begin_row,
265+  5D39              ;			INT number_of_tiles_horizontally,
266+  5D39              ;			INT	number_of_tiles_vertically )
267+  5D39              ; will put ram in page 0 also, page 1 is already there
268+  5D39              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5D39              TILEVRM:
270+  5D39              	; opening (
271+  5D39 CD D4 60     	CALL CHKCHAR
272+  5D3C 28           	DB '('
273+  5D3D              	; get tile data pointer coordinate
274+  5D3D DD 21 2F 54  	LD IX, FRMQNT
275+  5D41 CD 59 01     	CALL CALBAS
276+  5D44 ED 53 0B 5E  	LD (BLIT_STRUCT+0), DE
277+  5D48              	; comma
278+  5D48 CD D4 60     	CALL CHKCHAR
279+  5D4B 2C           	DB ','
280+  5D4C              	; get tile columns
281+  5D4C DD 21 2F 54  	LD IX, FRMQNT
282+  5D50 CD 59 01     	CALL CALBAS
283+  5D53 ED 53 0F 5E  	LD (BLIT_STRUCT+4), DE
284+  5D57              	; comma
285+  5D57 CD D4 60     	CALL CHKCHAR
286+  5D5A 2C           	DB ','
287+  5D5B              	; get tile columns
288+  5D5B DD 21 2F 54  	LD IX, FRMQNT
289+  5D5F CD 59 01     	CALL CALBAS
290+  5D62 ED 53 0D 5E  	LD (BLIT_STRUCT+2), DE
291+  5D66              	; comma
292+  5D66 CD D4 60     	CALL CHKCHAR
293+  5D69 2C           	DB ','
294+  5D6A              	; get destination begin column
295+  5D6A DD 21 2F 54  	LD IX, FRMQNT
296+  5D6E CD 59 01     	CALL CALBAS
297+  5D71 7B           	LD A, E
298+  5D72 32 09 5E     	LD (BLIT_TMP+2), A
299+  5D75              	; comma
300+  5D75 CD D4 60     	CALL CHKCHAR
301+  5D78 2C           	DB ','
302+  5D79              	; get destination begin row
303+  5D79 DD 21 2F 54  	LD IX, FRMQNT
304+  5D7D CD 59 01     	CALL CALBAS
305+  5D80 7B           	LD A, E
306+  5D81 32 0A 5E     	LD (BLIT_TMP+3), A
307+  5D84              	; comma
308+  5D84 CD D4 60     	CALL CHKCHAR
309+  5D87 2C           	DB ','
310+  5D88              	; get number of tiles horizontally
311+  5D88 DD 21 2F 54  	LD IX, FRMQNT
312+  5D8C CD 59 01     	CALL CALBAS
313+  5D8F ED 53 15 5E  	LD (BLIT_STRUCT+10), DE
314+  5D93              	; comma
315+  5D93 CD D4 60     	CALL CHKCHAR
316+  5D96 2C           	DB ','
317+  5D97              	; get number of tiles vertically
318+  5D97 DD 21 2F 54  	LD IX, FRMQNT
319+  5D9B CD 59 01     	CALL CALBAS
320+  5D9E ED 53 17 5E  	LD (BLIT_STRUCT+12), DE
321+  5DA2              	; ending )
322+  5DA2 CD D4 60     	CALL CHKCHAR
323+  5DA5 29           	DB ')'
324+  5DA6
325+  5DA6 E5           	PUSH HL ; save position in BASIC buffer
326+  5DA7
327+  5DA7              	; calculate destination add to value
328+  5DA7 21 00 01     	LD HL, 256
329+  5DAA 22 13 5E     	LD (BLIT_STRUCT+8), HL
330+  5DAD              	; calculate pointer to background location
331+  5DAD 3A 0A 5E     	LD A,(BLIT_TMP+3)
332+  5DB0 67           	LD H,A
333+  5DB1 2E 00        	LD L,0
334+  5DB3 EB           	EX DE,HL
335+  5DB4 26 00        	LD H,0
336+  5DB6 3A 09 5E     	LD A,(BLIT_TMP+2)
337+  5DB9 6F           	LD L,A
338+  5DBA CD C3 5F     	CALL HLx8
339+  5DBD 19           	ADD HL,DE
340+  5DBE ED 5B CB F3  	LD DE,(GRPCGP)
341+  5DC2 19           	ADD HL,DE
342+  5DC3 22 11 5E     	LD (BLIT_STRUCT+6),HL
343+  5DC6
344+  5DC6 FD 21 CD 5D  	LD IY, .RET
345+  5DCA C3 87 60     	JP ENABLE_PAGE0
346+  5DCD              .RET:
347+  5DCD FB           	EI
348+  5DCE              	; set RAM functions to call
349+  5DCE 21 E8 5D     	LD HL, .TILECOPY
350+  5DD1 22 17 5C     	LD (TILE.CALL2+1), HL
351+  5DD4 21 EE 5D     	LD HL, .SETDESTROW
352+  5DD7 22 09 5C     	LD (TILE.CALL1+1), HL
353+  5DDA DD 21 0B 5E  	LD IX,BLIT_STRUCT
354+  5DDE CD EE 5B     	CALL TILE
355+  5DE1
356+  5DE1 D1               POP DE
357+  5DE2 C1               POP BC
358+  5DE3 CD FE 5F         CALL RESTORE_PAGE_INFO
359+  5DE6
360+  5DE6 E1           	POP HL
361+  5DE7 C9           	RET
362+  5DE8              .TILECOPY:
363+  5DE8 01 98 08     	LD BC, #0898
364+  5DEB C3 BB 5F     	JP BBYTECOPY_NO_C
365+  5DEE              .SETDESTROW:
366+  5DEE 2A 07 5E     	LD HL, (TILETMP1)
367+  5DF1 F3           	DI
368+  5DF2 CD AE 5F     	CALL SETWRT_LOCAL
369+  5DF5 FB           	EI
370+  5DF6 C9           	RET
371+  5DF7              ; *******************************************************************************************************
372+  5DF7               ENDIF
373+  5DF7
374+  5DF7               IFNDEF CMDS_WITH_PARAMETERS
375+  5DF7 ~            ; *******************************************************************************************************
376+  5DF7 ~            ; function to handle CALL TILEVRM basic extension
377+  5DF7 ~            ; fills vram with tiles
378+  5DF7 ~            ; TILEVRM ( INT request_data_ptr )
379+  5DF7 ~            ; request_data_ptr described in TILE
380+  5DF7 ~            ; will put ram in page 0 also, page 1 is already there
381+  5DF7 ~            TILEVRM:
382+  5DF7 ~            	; opening (
383+  5DF7 ~            	CALL CHKCHAR
384+  5DF7 ~            	DB '('
385+  5DF7 ~            	; get pointer to request struct
386+  5DF7 ~            	LD IX, FRMQNT
387+  5DF7 ~            	CALL CALBAS
388+  5DF7 ~            	PUSH DE
389+  5DF7 ~            	; ending )
390+  5DF7 ~            	CALL CHKCHAR
391+  5DF7 ~            	DB ')'
392+  5DF7 ~
393+  5DF7 ~            	POP IX ; pointer to request struct
394+  5DF7 ~
395+  5DF7 ~            	PUSH HL ; save position in BASIC buffer
396+  5DF7 ~
397+  5DF7 ~            	LD IY, .RET
398+  5DF7 ~            	JP ENABLE_PAGE0
399+  5DF7 ~            .RET:
400+  5DF7 ~            	EI
401+  5DF7 ~            	; set RAM functions to call
402+  5DF7 ~            	LD HL, .TILECOPY
403+  5DF7 ~            	LD (TILE.CALL2+1), HL
404+  5DF7 ~            	LD HL, .SETDESTROW
405+  5DF7 ~            	LD (TILE.CALL1+1), HL
406+  5DF7 ~            	CALL TILE
407+  5DF7 ~
408+  5DF7 ~                POP DE
409+  5DF7 ~                POP BC
410+  5DF7 ~                CALL RESTORE_PAGE_INFO
411+  5DF7 ~
412+  5DF7 ~            	POP HL
413+  5DF7 ~            	RET
414+  5DF7 ~            .TILECOPY:
415+  5DF7 ~            	LD BC, #0898
416+  5DF7 ~            	JP BBYTECOPY_NO_C
417+  5DF7 ~            .SETDESTROW:
418+  5DF7 ~            	LD HL, (TILETMP1)
419+  5DF7 ~            	DI
420+  5DF7 ~            	CALL SETWRT_LOCAL
421+  5DF7 ~            	EI
422+  5DF7 ~            	RET
423+  5DF7 ~            ; *******************************************************************************************************
424+  5DF7               ENDIF
# file closed: asm\TILE.asm
153   5DF7               ENDIF
154   5DF7
155   5DF7               IF (BYTEOPS_CMDS == 1)
156   5DF7 ~             INCLUDE "BYTEOPS.asm"
157   5DF7               ENDIF
158   5DF7
159   5DF7               IF (COLL_CMD == 1)
160   5DF7               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
  1+  5DF7              ; ************************************************************************************************
  2+  5DF7              ; quick test if HL<=DE<=HL+BC
  3+  5DF7              ; input BC=width, DE=x, HL=min
  4+  5DF7              ; if not true flag C set
  5+  5DF7              GENERIC_INNER_CHECK:
  6+  5DF7 A7               AND A
  7+  5DF8 ED 52            SBC HL, DE
  8+  5DFA F2 05 5E         JP P, GENERIC_INNER_CHECK_NOT
  9+  5DFD A7               AND A
 10+  5DFE ED 4A            ADC HL, BC
 11+  5E00 FA 05 5E         JP M, GENERIC_INNER_CHECK_NOT
 12+  5E03 A7               AND A
 13+  5E04 C9               RET
 14+  5E05              GENERIC_INNER_CHECK_NOT:
 15+  5E05 37               SCF
 16+  5E06 C9               RET
 17+  5E07              ; ************************************************************************************************
 18+  5E07
# file closed: asm\COLLISION.asm
161   5E07               ENDIF
162   5E07
163   5E07              ; temp variables for BLIT, TILE functions
164   5E07               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
165   5E07              BLIT_TMP:
166   5E07              TILETMP1:
167   5E07              BLIT_TMP1:
168   5E07 00 00         DW 0
169   5E09              TILETMP2:
170   5E09              BLIT_TMP2:
171   5E09 00 00         DW 0
172   5E0B                IFDEF CMDS_WITH_PARAMETERS
173   5E0B              BLIT_STRUCT:
174   5E0B 00 00 00...   DS 17
175   5E0F                ENDIF
176   5E0F               ENDIF
177   5E1C
178   5E1C               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
179   5E1C              VRAM_UPDATE_IN_PROGRESS:
180   5E1C 00            DB 0
181   5E1D               ENDIF
182   5E1D
183   5E1D              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
184   5E1D              ; per starting letter, if no commands with this letter, NULL value
185   5E1D              CMDS:
186   5E1D               IF (ANIM_CMDS == 1)
187   5E1D 4D 5F        	DW CMDS_A ;
188   5E1F               ELSE
189   5E1F ~                DW 0 ; A
190   5E1F               ENDIF
191   5E1F               IF (BLIT_CMDS + BOX_CMDS > 0)
192   5E1F 18 5F            DW CMDS_B ; B
193   5E21               ELSE
194   5E21 ~            	DW 0
195   5E21               ENDIF
196   5E21 00 00            DW 0 ; C
197   5E23 00 00            DW 0 ; D
198   5E25 00 00            DW 0 ; E
199   5E27               IF (VRAM_CMDS + RAM_CMDS > 0)
200   5E27 8F 5E            DW CMDS_F; F
201   5E29               ELSE
202   5E29 ~            	DW 0
203   5E29               ENDIF
204   5E29               IF (GENCAL_CMD > 0)
205   5E29 A2 5E            DW CMDS_G; G
206   5E2B               ELSE
207   5E2B ~            	DW 0
208   5E2B               ENDIF
209   5E2B               IF (BYTEOPS_CMDS == 1)
210   5E2B ~                DW CMDS_H; H
211   5E2B               ELSE
212   5E2B 00 00            DW 0
213   5E2D               ENDIF
214   5E2D 00 00            DW 0 ; I
215   5E2F 00 00            DW 0 ; J
216   5E31 00 00            DW 0 ; K
217   5E33               IF (BYTEOPS_CMDS == 1)
218   5E33 ~                DW CMDS_L; L
219   5E33               ELSE
220   5E33 00 00            DW 0
221   5E35               ENDIF
222   5E35               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
223   5E35 51 5E            DW CMDS_M ; M
224   5E37               ELSE
225   5E37 ~            	DW 0
226   5E37               ENDIF
227   5E37 00 00            DW 0 ; N
228   5E39 00 00            DW 0 ; O
229   5E3B 00 00            DW 0 ; P
230   5E3D 00 00            DW 0 ; Q
231   5E3F               IF (BYTEOPS_CMDS == 1)
232   5E3F ~                DW CMDS_R; R
233   5E3F               ELSE
234   5E3F 00 00            DW 0
235   5E41               ENDIF
236   5E41               IF (SOUND_CMDS + SPRITE_CMDS > 0)
237   5E41 B6 5E            DW CMDS_S ; S
238   5E43               ELSE
239   5E43 ~            	DW 0
240   5E43               ENDIF
241   5E43               IF (TILE_CMDS > 0)
242   5E43 38 5F            DW CMDS_T ; T
243   5E45               ELSE
244   5E45 ~            	DW 0
245   5E45               ENDIF
246   5E45 00 00            DW 0 ; U
247   5E47               IF (VRAM_CMDS > 0)
248   5E47 AC 5E            DW CMDS_V ; V
249   5E49               ELSE
250   5E49 ~            	DW 0
251   5E49               ENDIF
252   5E49               IF (BYTEOPS_CMDS == 1)
253   5E49 ~                DW CMDS_W; W
254   5E49               ELSE
255   5E49 00 00            DW 0
256   5E4B               ENDIF
257   5E4B 00 00            DW 0 ; X
258   5E4D 00 00            DW 0 ; Y
259   5E4F 00 00            DW 0 ; Z
260   5E51
261   5E51              CMDS_M:
262   5E51               IF (VRAM_CMDS == 1)
263   5E51 4D 45 4D 56      DB "MEMVRM", 0
263   5E55 52 4D 00
264   5E58 3C 57            DW MEMVRM
265   5E5A               ENDIF
266   5E5A               IF (RAM_CMDS == 1)
267   5E5A 4D 45 4D 43  	DB "MEMCPY", 0
267   5E5E 50 59 00
268   5E61 72 55        	DW MEMCPY
269   5E63               ENDIF
270   5E63               IF (ANIM_CMDS == 1)
271   5E63 4D 41 58 41  	DB "MAXANIMITEMS",0
271   5E67 4E 49 4D 49
271   5E6B 54 45 4D 53
271   5E6F 00
272   5E70 EF 4F        	DW MAXANIMITEMS
273   5E72 4D 41 58 41  	DB "MAXANIMDEFS",0
273   5E76 4E 49 4D 44
273   5E7A 45 46 53 00
274   5E7E 64 51        	DW MAXANIMDEFS
275   5E80 4D 41 58 41  	DB "MAXANIMSPRS",0
275   5E84 4E 49 4D 53
275   5E88 50 52 53 00
276   5E8C F9 51        	DW MAXANIMSPRS
277   5E8E               ENDIF
278   5E8E               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
279   5E8E 00           	DB 0
280   5E8F               ENDIF
281   5E8F              CMDS_F:
282   5E8F               IF (VRAM_CMDS == 1)
283   5E8F 46 49 4C 56      DB "FILVRM", 0
283   5E93 52 4D 00
284   5E96 EC 56            DW FILVRM
285   5E98               ENDIF
286   5E98               IF (RAM_CMDS == 1)
287   5E98 46 49 4C 52      DB "FILRAM", 0
287   5E9C 41 4D 00
288   5E9F B5 55            DW FILRAM
289   5EA1               ENDIF
290   5EA1               IF (VRAM_CMDS + RAM_CMDS > 0)
291   5EA1 00               DB 0
292   5EA2               ENDIF
293   5EA2              CMDS_G:
294   5EA2               IF (GENCAL_CMD == 1)
295   5EA2 47 45 4E 43      DB "GENCAL", 0
295   5EA6 41 4C 00
296   5EA9 20 58            DW GENCAL
297   5EAB               ENDIF
298   5EAB               IF (GENCAL_CMD > 0)
299   5EAB 00           	DB	0
300   5EAC               ENDIF
301   5EAC              CMDS_V:
302   5EAC               IF (VRAM_CMDS == 1)
303   5EAC 56 52 4D 4D  	DB "VRMMEM", 0
303   5EB0 45 4D 00
304   5EB3 BB 57        	DW VRMMEM
305   5EB5               ENDIF
306   5EB5               IF (VRAM_CMDS > 0)
307   5EB5 00           	DB 0
308   5EB6               ENDIF
309   5EB6              CMDS_S:
310   5EB6               IF (SPRITE_CMDS + ANIM_CMDS > 0)
311   5EB6 53 47 41 4D      DB "SGAM",0
311   5EBA 00
312   5EBB BA 54            DW SGAM
313   5EBD               ENDIF
314   5EBD               IF (SPRITE_CMDS == 1)
315   5EBD 53 50 52 53   	DB "SPRSET", 0
315   5EC1 45 54 00
316   5EC4 81 4E        	DW SPRSET
317   5EC6 53 50 52 47  	DB "SPRGRPMOV", 0
317   5ECA 52 50 4D 4F
317   5ECE 56 00
318   5ED0 32 4F        	DW SPRGRPMOV
319   5ED2               ENDIF
320   5ED2               IF (SOUND_CMDS == 1)
321   5ED2 53 4E 44 53  	DB "SNDSFX", 0
321   5ED6 46 58 00
322   5ED9 92 56        	DW SNDSFX
323   5EDB 53 4E 44 50  	DB "SNDPLYON", 0
323   5EDF 4C 59 4F 4E
323   5EE3 00
324   5EE4 5C 56        	DW SNDPLYON
325   5EE6 53 4E 44 50  	DB "SNDPLYOFF", 0
325   5EEA 4C 59 4F 46
325   5EEE 46 00
326   5EF0 6F 56        	DW SNDPLYOFF
327   5EF2 53 4E 44 50  	DB "SNDPLYINI", 0
327   5EF6 4C 59 49 4E
327   5EFA 49 00
328   5EFC 12 56        	DW SNDPLYINIT
329   5EFE               ENDIF
330   5EFE               IF (SPRITE_CMDS == 1)
331   5EFE 53 50 52 45  	DB "SPRENABLE", 0
331   5F02 4E 41 42 4C
331   5F06 45 00
332   5F08 3C 4E        	DW SPRENABLE
333   5F0A 53 50 52 44  	DB "SPRDISABLE", 0
333   5F0E 49 53 41 42
333   5F12 4C 45 00
334   5F15 7C 4E        	DW SPRDISABLE
335   5F17               ENDIF
336   5F17               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
337   5F17 00           	DB 0
338   5F18               ENDIF
339   5F18              CMDS_B:
340   5F18               IF (BLIT_CMDS == 1)
341   5F18 42 4C 49 54  	DB "BLIT", 0
341   5F1C 00
342   5F1D F2 5A        	DW BLIT
343   5F1F               ENDIF
344   5F1F               IF (BOX_CMDS == 1)
345   5F1F 42 4F 58 4D  	DB "BOXMEMCPY", 0
345   5F23 45 4D 43 50
345   5F27 59 00
346   5F29 AF 58        	DW BOXMEMCPY
347   5F2B 42 4F 58 4D  	DB "BOXMEMVRM", 0
347   5F2F 45 4D 56 52
347   5F33 4D 00
348   5F35 44 59        	DW BOXMEMVRM
349   5F37               ENDIF
350   5F37               IF (BLIT_CMDS + BOX_CMDS > 0)
351   5F37 00           	DB 0
352   5F38               ENDIF
353   5F38              CMDS_T:
354   5F38               IF (TILE_CMDS == 1)
355   5F38 54 49 4C 45  	DB "TILERAM", 0
355   5F3C 52 41 4D 00
356   5F40 36 5C        	DW TILERAM
357   5F42 54 49 4C 45  	DB "TILEVRM", 0
357   5F46 56 52 4D 00
358   5F4A 39 5D        	DW TILEVRM
359   5F4C               ENDIF
360   5F4C               IF (TILE_CMDS > 0)
361   5F4C 00           	DB 0
362   5F4D               ENDIF
363   5F4D              CMDS_A:
364   5F4D               IF (ANIM_CMDS == 1)
365   5F4D 41 4E 49 4D      DB "ANIMSTEP",0
365   5F51 53 54 45 50
365   5F55 00
366   5F56 40 53            DW ANIMSTEP
367   5F58 41 4E 49 4D  	DB "ANIMSTART",0
367   5F5C 53 54 41 52
367   5F60 54 00
368   5F62 45 53        	DW ANIMSTART
369   5F64 41 4E 49 4D  	DB "ANIMSTOP",0
369   5F68 53 54 4F 50
369   5F6C 00
370   5F6D 4A 53        	DW ANIMSTOP
371   5F6F 41 4E 49 4D  	DB "ANIMITEMPAT",0
371   5F73 49 54 45 4D
371   5F77 50 41 54 00
372   5F7B AF 50        	DW ANIMITEMPAT
373   5F7D 41 4E 49 4D  	DB "ANIMITEMPTR",0
373   5F81 49 54 45 4D
373   5F85 50 54 52 00
374   5F89 10 51        	DW ANIMITEMPTR_CMD
375   5F8B 41 4E 49 4D  	DB "ANIMDEF",0
375   5F8F 44 45 46 00
376   5F93 A6 51        	DW ANIMDEF
377   5F95 41 4E 49 4D  	DB "ANIMSPRITE",0
377   5F99 53 50 52 49
377   5F9D 54 45 00
378   5FA0 4F 52        	DW ANIMSPRITE
379   5FA2 41 4E 49 4D      DB "ANIMCHAR",0
379   5FA6 43 48 41 52
379   5FAA 00
380   5FAB C7 52            DW ANIMCHAR
381   5FAD 00           	DB 0
382   5FAE               ENDIF
383   5FAE              CMDS_H:
384   5FAE               IF (BYTEOPS_CMDS == 1)
385   5FAE ~                DB "HI", 0
386   5FAE ~                DW HI
387   5FAE               ENDIF
388   5FAE               IF (BYTEOPS_CMDS > 0)
389   5FAE ~            	DB	0
390   5FAE               ENDIF
391   5FAE              CMDS_L:
392   5FAE               IF (BYTEOPS_CMDS == 1)
393   5FAE ~                DB "LO", 0
394   5FAE ~                DW LO
395   5FAE               ENDIF
396   5FAE               IF (BYTEOPS_CMDS > 0)
397   5FAE ~            	DB	0
398   5FAE               ENDIF
399   5FAE              CMDS_W:
400   5FAE               IF (BYTEOPS_CMDS == 1)
401   5FAE ~                DB "W", 0
402   5FAE ~                DW WORD
403   5FAE               ENDIF
404   5FAE               IF (BYTEOPS_CMDS > 0)
405   5FAE ~            	DB	0
406   5FAE               ENDIF
407   5FAE              CMDS_R:
408   5FAE               IF (BYTEOPS_CMDS == 1)
409   5FAE ~                DB "RANGE", 0
410   5FAE ~                DW RANGE
411   5FAE               ENDIF
412   5FAE               IF (BYTEOPS_CMDS > 0)
413   5FAE ~            	DB	0
414   5FAE               ENDIF
415   5FAE
416   5FAE               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
417   5FAE              ; ****************************************************************************************************
418   5FAE              ; function sets VRAM address
419   5FAE              ; input HL=address
420   5FAE              ; modifies AF
421   5FAE              SETWRT_LOCAL:
422   5FAE 7D           	LD	A, L
423   5FAF D3 99        	OUT	(099H), A
424   5FB1 7C           	LD	A, H
425   5FB2 E6 3F        	AND	03FH
426   5FB4 F6 40        	OR	040H
427   5FB6 D3 99        	OUT	(099H), A
428   5FB8 C9           	RET
429   5FB9              ; ****************************************************************************************************
430   5FB9               ENDIF
431   5FB9
432   5FB9               IF (VRAM_CMDS + TILE_CMDS > 0)
433   5FB9              ; ****************************************************************************************************
434   5FB9              ; function copies data from RAM to VRAM
435   5FB9              ; input HL=address in RAM
436   5FB9              ; input B=count
437   5FB9              ; modifies AF, BC, HL
438   5FB9              BBYTECOPY:
439   5FB9 0E 98        	LD C,#98
440   5FBB              BBYTECOPY_NO_C:
441   5FBB ED A3        	OUTI
442   5FBD C2 BB 5F     	JP	NZ, BBYTECOPY_NO_C
443   5FC0 C9           	RET
444   5FC1              ; ****************************************************************************************************
445   5FC1               ENDIF
446   5FC1
447   5FC1              ; ****************************************************************************************************
448   5FC1              ; function multiplies HL by 32
449   5FC1              HLx32:
450   5FC1 29           	ADD HL,HL
451   5FC2              ; ****************************************************************************************************
452   5FC2              ; function multiplies HL by 16
453   5FC2              HLx16:
454   5FC2 29           	ADD HL,HL
455   5FC3              ; ****************************************************************************************************
456   5FC3              ; function multiplies HL by 8
457   5FC3              HLx8:
458   5FC3 29          > ADD HL, HL
458   5FC4 29          > ADD HL, HL
458   5FC5 29          > ADD HL, HL
459   5FC6 C9           	RET
460   5FC7              ; ****************************************************************************************************
461   5FC7
462   5FC7              ; ****************************************************************************************************
463   5FC7              ; function gets slot and subslot data for specific page
464   5FC7              ; input A=page (0, 1 or 2)
465   5FC7              ; output B = 0A8H register value
466   5FC7              ; output D = 0 is no subslots, 1 if yes
467   5FC7              ; output C = 0A8H value when page 3 slot equals to requested page slot
468   5FC7              ; output E = subslot value if present
469   5FC7              ; modifies AF, BC, DE, HL
470   5FC7              GET_PAGE_INFO:
471   5FC7 6F               LD L, A
472   5FC8 C6 C1            ADD A, low (EXPTBL)
473   5FCA 32 D4 5F         LD (GET_PAGE_INFO_L1+1), A
474   5FCD DB A8            IN A, (0A8H)
475   5FCF 47               LD B, A
476   5FD0 E6 3F            AND 03FH
477   5FD2 4F               LD C, A
478   5FD3              GET_PAGE_INFO_L1:
479   5FD3 3A C1 FC         LD A, (EXPTBL) ; modified by code above
480   5FD6 E6 80            AND 080H
481   5FD8 28 1B            JR Z, GET_PAGE_INFO_L2
482   5FDA                  ; expanded
483   5FDA 2D               DEC L
484   5FDB FA FA 5F         JP M, GET_PAGE_INFO_L3
485   5FDE 2D               DEC L
486   5FDF FA F8 5F         JP M, GET_PAGE_INFO_L4
487   5FE2                  ; page 2
488   5FE2 07               RLCA
489   5FE3 07               RLCA
490   5FE4              GET_PAGE_INFO_L5:
491   5FE4 E6 C0            AND 0C0H
492   5FE6 B1               OR C
493   5FE7 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
494   5FE9 4F               LD C, A
495   5FEA 3A FF FF         LD A, (0FFFFH)
496   5FED 2F               CPL
497   5FEE 5F               LD E, A
498   5FEF 16 01            LD D, 1
499   5FF1 78               LD A, B ; return stack
500   5FF2 D3 A8            OUT (0A8H), A
501   5FF4 C9               RET
502   5FF5              GET_PAGE_INFO_L2:
503   5FF5                  ; not expanded
504   5FF5 16 00            LD D, 0
505   5FF7 C9               RET
506   5FF8              GET_PAGE_INFO_L4:
507   5FF8                  ; page 1
508   5FF8 0F               RRCA
509   5FF9 0F               RRCA
510   5FFA              GET_PAGE_INFO_L3:
511   5FFA                  ; page 0
512   5FFA 0F               RRCA
513   5FFB 0F               RRCA
514   5FFC 18 E6            JR GET_PAGE_INFO_L5
515   5FFE              ; ****************************************************************************************************
516   5FFE
517   5FFE              ; ****************************************************************************************************
518   5FFE              ; function returns original slot and subslot info
519   5FFE              ; input B = 0A8H register value
520   5FFE              ; input D = 0 is no subslots, 1 if yes
521   5FFE              ; input C = 0A8H value when page 3 slot equals to requested page slot
522   5FFE              ; input E = subslot value if present
523   5FFE              ; modifies AF, disables interrupts
524   5FFE              RESTORE_PAGE_INFO:
525   5FFE 7A               LD A, D
526   5FFF B7               OR A
527   6000 28 08            JR Z, RESTORE_PAGE_INFO_L1
528   6002 79               LD A, C
529   6003 F3           	DI
530   6004 D3 A8            OUT (0A8H), A
531   6006 7B               LD A, E
532   6007 32 FF FF         LD (0FFFFH), A
533   600A              RESTORE_PAGE_INFO_L1:
534   600A 78               LD A, B
535   600B D3 A8            OUT (0A8H), A
536   600D C9               RET
537   600E              ; ****************************************************************************************************
538   600E
539   600E              ; *******************************************************************************************************
540   600E              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
541   600E              ; INPUT:  A = SLOT ID: EXXXSSPP
542   600E              ; E = EXPANDED FLAG
543   600E              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
544   600E              ; PP = PRIMARY SLOT NUMBER
545   600E              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
546   600E              ; CHANGES: AF, BC, DE
547   600E
548   600E              LOCAL_ENASLT:
549   600E CD 2E 60         CALL L0353
550   6011 FA 1B 60         JP M, L0340
551   6014 DB A8            IN A, (0A8H)
552   6016 A1               AND C
553   6017 B0               OR B
554   6018 D3 A8            OUT (0A8H), A
555   601A C9               RET
556   601B              L0340:
557   601B E5               PUSH HL
558   601C CD 53 60         CALL L0378
559   601F 4F               LD C, A
560   6020 06 00            LD B, 0
561   6022 7D               LD A, L
562   6023 A4               AND H
563   6024 B2               OR D
564   6025 21 C5 FC         LD HL, 0FCC5H
565   6028 09               ADD HL, BC
566   6029 77               LD (HL), A
567   602A E1               POP HL
568   602B 79               LD A, C
569   602C 18 E0            JR LOCAL_ENASLT
570   602E              L0353:
571   602E F3               DI
572   602F F5               PUSH AF
573   6030 7C               LD A, H
574   6031 07               RLCA
575   6032 07               RLCA
576   6033 E6 03            AND 3
577   6035 5F               LD E, A
578   6036 3E C0            LD A, 0C0H
579   6038              L035D:
580   6038 07               RLCA
581   6039 07               RLCA
582   603A 1D               DEC E
583   603B F2 38 60         JP P, L035D
584   603E 5F               LD E, A
585   603F 2F               CPL
586   6040 4F               LD C, A
587   6041 F1               POP AF
588   6042 F5               PUSH AF
589   6043 E6 03            AND 3
590   6045 3C               INC A
591   6046 47               LD B, A
592   6047 3E AB            LD A, 0ABH
593   6049              L036E:
594   6049 C6 55            ADD A, 055H
595   604B 10 FC            DJNZ L036E
596   604D 57               LD D, A
597   604E A3               AND E
598   604F 47               LD B, A
599   6050 F1               POP AF
600   6051 A7               AND A
601   6052 C9               RET
602   6053              L0378:
603   6053 F5               PUSH AF
604   6054 7A               LD A, D
605   6055 E6 C0            AND 0C0H
606   6057 4F               LD C, A
607   6058 F1               POP AF
608   6059 F5               PUSH AF
609   605A 57               LD D, A
610   605B DB A8            IN A, (0A8H)
611   605D 47               LD B, A
612   605E E6 3F            AND 03FH
613   6060 B1               OR C
614   6061 D3 A8            OUT (0A8H), A
615   6063 7A               LD A, D
616   6064 0F               RRCA
617   6065 0F               RRCA
618   6066 E6 03            AND 3
619   6068 57               LD D, A
620   6069 3E AB            LD A, 0ABH
621   606B              L0390:
622   606B C6 55            ADD A, 055H
623   606D 15               DEC D
624   606E F2 6B 60         JP P, L0390
625   6071 A3               AND E
626   6072 57               LD D, A
627   6073 7B               LD A, E
628   6074 2F               CPL
629   6075 67               LD H, A
630   6076 3A FF FF         LD A, (0FFFFH)
631   6079 2F               CPL
632   607A 6F               LD L, A
633   607B A4               AND H
634   607C B2               OR D
635   607D 32 FF FF         LD (0FFFFH), A
636   6080 78               LD A, B
637   6081 D3 A8            OUT (0A8H), A
638   6083 F1               POP AF
639   6084 E6 03            AND 3
640   6086 C9               RET
641   6087              ; *******************************************************************************************************
642   6087
643   6087              ; *******************************************************************************************************
644   6087              ; some common code to activate page 0 and place values needed to restore original page on stack
645   6087              ; input IY=return address
646   6087              ENABLE_PAGE0:
647   6087 AF               XOR A
648   6088 CD C7 5F         CALL GET_PAGE_INFO
649   608B C5               PUSH BC
650   608C D5               PUSH DE
651   608D 3A 41 F3         LD A, (RAMAD0)
652   6090 26 00            LD H, 0
653   6092 CD 0E 60         CALL LOCAL_ENASLT
654   6095 FD E9        	JP (IY)
655   6097              ; *******************************************************************************************************
656   6097
657   6097              ; General BASIC CALL-instruction handler
658   6097              CALLHAND:
659   6097 E5           	PUSH HL
660   6098 21 1D 5E     	LD	HL, CMDS ; pointer table based on starting letter
661   609B 3A 89 FD         LD A, (PROCNM)
662   609E D6 41            SUB 'A'
663   60A0 87               ADD A, A
664   60A1 16 00            LD D, 0
665   60A3 5F               LD E, A
666   60A4 19               ADD HL, DE
667   60A5 5E               LD E, (HL)
668   60A6 23               INC HL
669   60A7 56               LD D, (HL)
670   60A8 7A               LD A, D
671   60A9 B3               OR E
672   60AA 28 23            JR Z, .CMDNOTRECOGNIZED
673   60AC EB               EX DE, HL
674   60AD              .CHKCMD:
675   60AD 11 89 FD     	LD	DE, PROCNM
676   60B0 1A           .LOOP:	LD	A,(DE)
677   60B1 BE           	CP	(HL)
678   60B2 20 11        	JR	NZ,.TONEXTCMD	; Not equal
679   60B4 13           	INC	DE
680   60B5 23           	INC	HL
681   60B6 A7           	AND	A
682   60B7 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
683   60B9 5E           	LD	E,(HL)
684   60BA 23           	INC	HL
685   60BB 56           	LD	D,(HL)
686   60BC E1           	POP	HL		; routine address
687   60BD CD DE 60     	CALL	GETPREVCHAR
688   60C0 CD D2 60     	CALL	.CALLDE		; Call routine
689   60C3 A7           	AND	A
690   60C4 C9           	RET
691   60C5
692   60C5              .TONEXTCMD:
693   60C5 0E FF        	LD	C,0FFH
694   60C7 AF           	XOR	A
695   60C8 ED B1        	CPIR			; Skip to end of instruction name
696   60CA 23           	INC	HL
697   60CB 23           	INC	HL		; Skip address
698   60CC BE           	CP	(HL)
699   60CD 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
700   60CF              .CMDNOTRECOGNIZED:
701   60CF E1           	POP	HL
702   60D0 37               SCF
703   60D1 C9           	RET
704   60D2
705   60D2              .CALLDE:
706   60D2 D5           	PUSH	DE
707   60D3 C9           	RET
708   60D4
709   60D4              ;---------------------------
710   60D4
711   60D4              ;GETSTRPNT:
712   60D4              ; OUT:
713   60D4              ; HL = String Address
714   60D4              ; B  = Lenght
715   60D4              ;        LD      HL,(USR)
716   60D4              ;        LD      B,(HL)
717   60D4              ;        INC     HL
718   60D4              ;        LD      E,(HL)
719   60D4              ;        INC     HL
720   60D4              ;        LD      D,(HL)
721   60D4              ;        EX      DE,HL
722   60D4              ;        RET
723   60D4
724   60D4              ;EVALTXTPARAM:
725   60D4              ;	CALL	CHKCHAR
726   60D4              ;	DEFB	"("             ; Check for (
727   60D4              ;	LD	IX,FRMEVL
728   60D4              ;	CALL	CALBAS		; Evaluate expression
729   60D4              ;       LD      A,(VALTYP)
730   60D4              ;        CP      3               ; Text type?
731   60D4              ;        JP      NZ,TYPE_MISMATCH
732   60D4              ;        PUSH	HL
733   60D4              ;        LD	IX,FRESTR         ; Free the temporary string
734   60D4              ;        CALL	CALBAS
735   60D4              ;        POP	HL
736   60D4              ;	CALL	CHKCHAR
737   60D4              ;	DEFB	")"             ; Check for )
738   60D4              ;        RET
739   60D4
740   60D4
741   60D4              CHKCHAR:
742   60D4 CD DE 60     	CALL	GETPREVCHAR	; Get previous basic char
743   60D7 E3           	EX	(SP),HL
744   60D8 BE           	CP	(HL) 	        ; Check if good char
745   60D9 20 1B        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
746   60DB 23           	INC	HL
747   60DC E3           	EX	(SP),HL
748   60DD 23           	INC	HL		; Get next basic char
749   60DE
750   60DE              GETPREVCHAR:
751   60DE 2B           	DEC	HL
752   60DF DD 21 66 46  	LD	IX,CHRGTR
753   60E3 C3 59 01     	JP      CALBAS
754   60E6
755   60E6
756   60E6              TYPE_MISMATCH:
757   60E6 1E 0D            LD E, 13 ; Type mismatch
758   60E8 18 0E            JR THROW_ERROR
759   60EA              SUBSCRIPT_OUT_OF_RANGE:
760   60EA 1E 09            LD E,9 ; subscript out of range
761   60EC 18 0A        	JR THROW_ERROR
762   60EE              OVERFLOW:
763   60EE 1E 06        	LD E,6
764   60F0 18 06        	JR THROW_ERROR
765   60F2              ILLEGAL_FUNCTION:
766   60F2 1E 05            LD E, 5 ; illegal function call
767   60F4 18 02            JR THROW_ERROR
768   60F6              SYNTAX_ERROR:
769   60F6 1E 02            LD E, 2 ; Syntax error
770   60F8              THROW_ERROR:
771   60F8 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
772   60FC C3 59 01     	JP	CALBAS
773   60FF
774   60FF              ;---------------------------
775   60FF
776   60FF              ; *******************************************************************************************************
777   60FF              ; helper function to get pointer to BASIC array data
778   60FF              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
779   60FF              ; input B=dimensions (1 or 2)
780   60FF              ; input D=minimal first dimension
781   60FF              ; input E=minimal second dimension, if applicable
782   60FF              ; returns BC=pointer to first data element
783   60FF              ; throws BASIC error if invalid type
784   60FF              GET_BASIC_ARRAY_DATA_POINTER:
785   60FF D5           	PUSH DE
786   6100 C5           	PUSH BC
787   6101 F5           	PUSH AF
788   6102 3E 01            LD A,1
789   6104 32 A5 F6         LD (SUBFLG),A ; search for arrays only
790   6107 DD 21 A4 5E  	LD IX, PTRGET
791   610B CD 59 01     	CALL CALBAS
792   610E AF               XOR A
793   610F 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
794   6112 3A 63 F6     	LD A,(VALTYP)
795   6115 D1           	POP DE ; required type
796   6116 BA           	CP D
797   6117 C2 E6 60     	JP NZ,TYPE_MISMATCH
798   611A 0A           	LD A,(BC)
799   611B 03           	INC BC
800   611C D1           	POP DE ; required number of dimensions
801   611D BA           	CP D
802   611E C2 E6 60     	JP NZ,TYPE_MISMATCH
803   6121 D1           	POP DE ; required minimal array dimensions
804   6122 3D           	DEC A
805   6123 28 07        	JR Z,.ONE_DIMENSION
806   6125              	; 2-dimension array
807   6125 0A           	LD A,(BC)
808   6126 03          > INC BC
808   6127 03          > INC BC
809   6128 BB           	CP E
810   6129 DA EA 60     	JP C,SUBSCRIPT_OUT_OF_RANGE
811   612C              .ONE_DIMENSION:
812   612C 0A           	LD A,(BC)
813   612D 03          > INC BC
813   612E 03          > INC BC
814   612F BA           	CP D
815   6130 DA EA 60     	JP C,SUBSCRIPT_OUT_OF_RANGE
816   6133 C9           	RET
817   6134              ; *******************************************************************************************************
818   6134
819   6134              EXT_END:
820   6134
# file closed: asm\main.asm
