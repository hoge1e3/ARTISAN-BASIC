# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              PTRGET		EQU 	#5EA4
  33  4000              SUBFLG		EQU		#F6A5
  34  4000              SYNCHR		EQU		#558C
  35  4000              VALTYP  	EQU     #F663
  36  4000              USR     	EQU     #F7F8
  37  4000              PROCNM		EQU		#FD89
  38  4000              BIOS_FILVRM EQU     #0056
  39  4000              CLIKSW		EQU		#F3DB
  40  4000              ATRBAS		EQU		#F928
  41  4000              GRPCGP		EQU		#F3CB
  42  4000
  43  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  44  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  45  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  46  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  47  4000              EXPTBL	EQU #FCC1
  48  4000              SCRMOD	EQU #FCAF ; current screen mode
  49  4000              REG1SAV EQU #F3E0 ; VDP(1)
  50  4000              JIFFY	EQU #FC9E
  51  4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
  52  4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
  53  4000              PATBAS  EQU #F926 ; current sprite generator table address
  54  4000
  55  4000              ; BASIC error codes
  56  4000              ;01 NEXT without FOR
  57  4000              ;02 Syntax error
  58  4000              ;03 RETURN without GOSUB
  59  4000              ;04 Out of DATA
  60  4000              ;05 Illegal function call
  61  4000              ;06 Overflow
  62  4000              ;07 Out of memory
  63  4000              ;08 Undefined line number
  64  4000              ;09 Subscript out of range
  65  4000              ;10 Redimensioned array
  66  4000              ;11 Division by zero
  67  4000              ;12 Illegal direct
  68  4000              ;13 Type mismatch
  69  4000              ;14 Out of string space
  70  4000              ;15 String too long
  71  4000              ;16 String formula too complex
  72  4000              ;17 Can't CONTINUE
  73  4000              ;18 Undefined user function
  74  4000              ;19 Device I/O error
  75  4000              ;20 Verify error
  76  4000              ;21 No RESUME
  77  4000              ;22 RESUME without error
  78  4000              ;23 Unprintable error
  79  4000              ;24 Missing operand
  80  4000              ;25 Line buffer overflow
  81  4000              ;50 FIELD overflow
  82  4000              ;51 Internal error
  83  4000              ;52 Bad file number
  84  4000              ;53 File not found
  85  4000              ;54 File already open
  86  4000              ;55 Input past end
  87  4000              ;56 Bad file name
  88  4000              ;57 Direct statement in file
  89  4000              ;58 Sequential I/O only
  90  4000              ;59 File not OPEN
  91  4000
  92  4000
  93  4000               ; simulate cartridge with BASIC extension
  94  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  94  4004 8E 59 00 00
  94  4008 00 00 00 00
  94  400C 00 00 00 00
  95  4010
  96  4010              ; this location #4010 stores last location used by basic extension
  97  4010              ; free memory after that point
  98  4010              FREEMEMPTR:
  99  4010 57 5F         DW EXT_END
 100  4012
 101  4012              ; this location #4012 stores extension version in DAA format
 102  4012              ; first byte is major version and second minor
 103  4012              VERSION:
 104  4012 00 70         DB #00, #70
 105  4014
 106  4014              ; binary included AKG player compiled at #4014
 107  4014               IF (SOUND_CMDS == 1)
 108  4014              	INCBIN "bin/AKG.bin"
 109  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 110  4CF0               ENDIF
 111  4CF0
 112  4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF0              ORIG.HTIMI:
   2+ 4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF4 00
   3+ 4CF5               EXPORT ORIG.HTIMI
   4+ 4CF5
   5+ 4CF5              ; *******************************************************************************************************
   6+ 4CF5              ; interrupt handler when page 0 enabled
   7+ 4CF5              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF5              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF5              VBLANK:
  10+ 4CF5              	EXPORT VBLANK
  11+ 4CF5
  12+ 4CF5 F5               PUSH AF
  13+ 4CF6              	; is VDP originator ?
  14+ 4CF6 DB 99        	IN	A, (099H)
  15+ 4CF8 A7           	AND	A
  16+ 4CF9 F2 27 4D     	JP P, .EXIT
  17+ 4CFC
  18+ 4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFC C5               PUSH BC
  20+ 4CFD D5               PUSH DE
  21+ 4CFE E5               PUSH HL
  22+ 4CFF 08               EX AF, AF'
  23+ 4D00 D9               EXX
  24+ 4D01 F5               PUSH AF
  25+ 4D02 C5               PUSH BC
  26+ 4D03 D5               PUSH DE
  27+ 4D04 E5               PUSH HL
  28+ 4D05 DD E5            PUSH IX
  29+ 4D07 FD E5            PUSH IY
  30+ 4D09
  31+ 4D09               IF (SPRITE_CMDS == 1)
  32+ 4D09 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0C               ENDIF
  34+ 4D0C
  35+ 4D0C               IF (SOUND_CMDS == 1)
  36+ 4D0C 3A B0 54     	LD A, (SOUND_ENABLED)
  37+ 4D0F B7           	OR A
  38+ 4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D13               ENDIF
  40+ 4D13
  41+ 4D13                  ; increase JIFFY
  42+ 4D13 2A 9E FC         LD HL,(JIFFY)
  43+ 4D16 23               INC HL
  44+ 4D17 22 9E FC         LD (JIFFY),HL
  45+ 4D1A
  46+ 4D1A FD E1            POP IY
  47+ 4D1C DD E1            POP IX
  48+ 4D1E E1               POP HL
  49+ 4D1F D1               POP DE
  50+ 4D20 C1               POP BC
  51+ 4D21 F1               POP AF
  52+ 4D22 08               EX AF, AF'
  53+ 4D23 D9               EXX
  54+ 4D24 E1               POP HL
  55+ 4D25 D1               POP DE
  56+ 4D26 C1               POP BC
  57+ 4D27               ENDIF
  58+ 4D27
  59+ 4D27              .EXIT:
  60+ 4D27 F1           	POP AF
  61+ 4D28 FB           	EI
  62+ 4D29 ED 4D        	RETI
  63+ 4D2B              ; *******************************************************************************************************
  64+ 4D2B
  65+ 4D2B              ; *******************************************************************************************************
  66+ 4D2B              ; H.TIMI function
  67+ 4D2B              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2B              MBGE_HTIMI:
  69+ 4D2B               EXPORT MBGE_HTIMI
  70+ 4D2B
  71+ 4D2B               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2B
  73+ 4D2B F5           	PUSH AF
  74+ 4D2C
  75+ 4D2C              	; enable page 2
  76+ 4D2C 3E 02            LD A, 2
  77+ 4D2E CD BE 58         CALL GET_PAGE_INFO
  78+ 4D31 C5               PUSH BC
  79+ 4D32 D5               PUSH DE
  80+ 4D33 3A 43 F3         LD A, (RAMAD2)
  81+ 4D36 26 80            LD H, 080H
  82+ 4D38 CD 05 59         CALL LOCAL_ENASLT
  83+ 4D3B              	; enable page 0
  84+ 4D3B AF               XOR A
  85+ 4D3C CD BE 58         CALL GET_PAGE_INFO
  86+ 4D3F C5               PUSH BC
  87+ 4D40 D5               PUSH DE
  88+ 4D41 3A 41 F3         LD A, (RAMAD0)
  89+ 4D44 26 00            LD H, 0
  90+ 4D46 CD 05 59         CALL LOCAL_ENASLT
  91+ 4D49
  92+ 4D49               IF (SPRITE_CMDS == 1)
  93+ 4D49 CD 61 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4C               ENDIF
  95+ 4D4C
  96+ 4D4C               IF (SOUND_CMDS == 1)
  97+ 4D4C 3A B0 54     	LD A, (SOUND_ENABLED)
  98+ 4D4F B7           	OR A
  99+ 4D50 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D53               ENDIF
 101+ 4D53
 102+ 4D53              	; restore page 0
 103+ 4D53 D1               POP DE
 104+ 4D54 C1               POP BC
 105+ 4D55 CD F5 58         CALL RESTORE_PAGE_INFO
 106+ 4D58              	; restore page 2
 107+ 4D58 D1               POP DE
 108+ 4D59 C1               POP BC
 109+ 4D5A CD F5 58         CALL RESTORE_PAGE_INFO
 110+ 4D5D
 111+ 4D5D F1           	POP AF
 112+ 4D5E               ENDIF
 113+ 4D5E C3 F0 4C     	JP ORIG.HTIMI
 114+ 4D61              ; *******************************************************************************************************
 115+ 4D61
 116+ 4D61              ; *******************************************************************************************************
 117+ 4D61              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D61              ; also checks if some VRAM modifying command is running
 119+ 4D61              ; when that checks out calls sprite updates and animation processing
 120+ 4D61              PROCESS_SPRITES_AND_ANIMATIONS:
 121+ 4D61              	; check if initialized
 122+ 4D61 3A 7A 4D     	LD A, (SPRATR_INIT_STATUS)
 123+ 4D64 B7           	OR A
 124+ 4D65 C8           	RET Z
 125+ 4D66              	; check screen mode
 126+ 4D66 3A AF FC     	LD A, (SCRMOD)
 127+ 4D69 3D           	DEC A
 128+ 4D6A 28 02        	JR Z, .L0 ; screen 1
 129+ 4D6C 3D           	DEC A
 130+ 4D6D C0           	RET NZ ; not screen 2
 131+ 4D6E              .L0:
 132+ 4D6E                  ; check if anyone else is working with VRAM
 133+ 4D6E 3A 30 57         LD A,(VRAM_UPDATE_IN_PROGRESS)
 134+ 4D71 B7               OR A
 135+ 4D72 C0               RET NZ
 136+ 4D73
 137+ 4D73 CD 8F 4D         CALL SPRATR_UPDATE
 138+ 4D76
 139+ 4D76               IF (ANIM_CMDS == 1)
 140+ 4D76 CD 3A 53         CALL PROCESS_ANIMATIONS
 141+ 4D79               ENDIF
 142+ 4D79 C9               RET
 143+ 4D7A              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 113  4D7A
 114  4D7A               IF (SPRITE_CMDS == 1)
 115  4D7A               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7A              ; commands and variables related to sprites
   2+ 4D7A
   3+ 4D7A              SPRATR_INIT_STATUS:
   4+ 4D7A 00            DB 0
   5+ 4D7B              SPRATR_UPDATE_FLAG:
   6+ 4D7B 00 00         DW 0
   7+ 4D7D              SPRATR_DATA:
   8+ 4D7D 00 00         DW 0
   9+ 4D7F              SPRFLICKER_ENABLED:
  10+ 4D7F 00            DB 0
  11+ 4D80              ; to support sprite flicker
  12+ 4D80              FLICKER:
  13+ 4D80 00            DB 0
  14+ 4D81
  15+ 4D81              ; to temporarily store stack pointer
  16+ 4D81              TMPSP:
  17+ 4D81 00 00         DW 0
  18+ 4D83
  19+ 4D83              ; *******************************************************************************************************
  20+ 4D83              ; helper function gets pointer to n-th entry in sprite attributes
  21+ 4D83              ; changes HL,DE;
  22+ 4D83              GETnthSPRATTR:
  23+ 4D83 26 00            LD H,0
  24+ 4D85 6F               LD L,A
  25+ 4D86 CD BA 58         CALL HLx8
  26+ 4D89 ED 5B 7D 4D      LD DE,(SPRATR_DATA)
  27+ 4D8D 19               ADD HL,DE
  28+ 4D8E C9               RET
  29+ 4D8F              ; *******************************************************************************************************
  30+ 4D8F
  31+ 4D8F              ; *******************************************************************************************************
  32+ 4D8F              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  33+ 4D8F              ; struct {
  34+ 4D8F              ; DW y
  35+ 4D8F              ; DW x
  36+ 4D8F              ; DW pattern (0-63)
  37+ 4D8F              ; DW color
  38+ 4D8F              ; } [32]
  39+ 4D8F              ; will hide sprites whose location is outside of visible area
  40+ 4D8F              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  41+ 4D8F              ; modifies AF, AF', BC, DE, HL
  42+ 4D8F              SPRATR_UPDATE:
  43+ 4D8F              	; check if update requested
  44+ 4D8F 2A 7B 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  45+ 4D92 7E           	LD A, (HL)
  46+ 4D93 B7           	OR A
  47+ 4D94 C8           	RET Z
  48+ 4D95              .L0:
  49+ 4D95 06 20        	LD B, 32 ; sprite number
  50+ 4D97 0E 98        	LD C, #98 ; register for vdp data output
  51+ 4D99              	; set VDP address
  52+ 4D99 2A 28 F9     	LD HL, (ATRBAS)
  53+ 4D9C 3A 7F 4D     	LD A, (SPRFLICKER_ENABLED)
  54+ 4D9F B7           	OR A
  55+ 4DA0 28 03        	JR Z, .L3
  56+ 4DA2 3A 80 4D     	LD A, (FLICKER)
  57+ 4DA5              .L3:
  58+ 4DA5 5F           	LD E, A
  59+ 4DA6 08           	EX AF, AF'
  60+ 4DA7 7B           	LD A, E
  61+ 4DA8 87           	ADD A, A
  62+ 4DA9 87           	ADD A, A
  63+ 4DAA 16 00        	LD D, 0
  64+ 4DAC 5F           	LD E, A
  65+ 4DAD 19           	ADD HL, DE
  66+ 4DAE CD A5 58     	CALL SETWRT_LOCAL
  67+ 4DB1 ED 73 81 4D  	LD (TMPSP), SP
  68+ 4DB5 ED 7B 7D 4D  	LD SP, (SPRATR_DATA)
  69+ 4DB9
  70+ 4DB9              .LOOP:
  71+ 4DB9 E1           	POP HL
  72+ 4DBA 24           	INC H
  73+ 4DBB 28 0D        	JR Z, .L1 ; negative number above -256
  74+ 4DBD 25           	DEC H
  75+ 4DBE 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  76+ 4DC0 7D           	LD A, L
  77+ 4DC1 FE C0        	CP 192
  78+ 4DC3 30 10        	JR NC, .OUT3
  79+ 4DC5 3D           	DEC A ; due to VDP rule that top of screen is -1
  80+ 4DC6 57           	LD D, A
  81+ 4DC7 C3 EE 4D     	JP .X
  82+ 4DCA              .L1:
  83+ 4DCA 7D           	LD A, L
  84+ 4DCB C6 10        	ADD 16
  85+ 4DCD FA D5 4D     	JP M, .OUT3 ; below -16
  86+ 4DD0 2D           	DEC L ; due to VDP rule that top of screen is -1
  87+ 4DD1 55           	LD D, L
  88+ 4DD2 C3 EE 4D     	JP .X
  89+ 4DD5              .OUT3:
  90+ 4DD5 E1           	POP HL ; skip x value
  91+ 4DD6              .OUT2:
  92+ 4DD6 E1           	POP HL ; skip pattern
  93+ 4DD7 E1           	POP HL ; skip color
  94+ 4DD8 3E D1        	LD A, #D1
  95+ 4DDA ED 79        	OUT (C), A ; sprite hidden
  96+ 4DDC 00          > NOP
  96+ 4DDD 00          > NOP
  96+ 4DDE 00          > NOP
  97+ 4DDF ED 79        	OUT (C), A ; value unimportant
  98+ 4DE1 00          > NOP
  98+ 4DE2 00          > NOP
  98+ 4DE3 00          > NOP
  99+ 4DE4 ED 79        	OUT (C), A ; value unimportant
 100+ 4DE6 00          > NOP
 100+ 4DE7 00          > NOP
 100+ 4DE8 00          > NOP
 101+ 4DE9 ED 79        	OUT (C), A ; value unimportant
 102+ 4DEB C3 19 4E     	JP .NEXT
 103+ 4DEE              .X:
 104+ 4DEE E1           	POP HL
 105+ 4DEF 24           	INC H
 106+ 4DF0 28 08        	JR Z, .L2
 107+ 4DF2 25           	DEC H
 108+ 4DF3 20 E1        	JR NZ, .OUT2
 109+ 4DF5 1E 00        	LD E, 0 ; EC bit
 110+ 4DF7 C3 03 4E     	JP .XY
 111+ 4DFA              .L2:
 112+ 4DFA 7D           	LD A, L
 113+ 4DFB C6 20        	ADD 32
 114+ 4DFD FA D6 4D     	JP M, .OUT2
 115+ 4E00 6F           	LD L, A
 116+ 4E01 1E 80        	LD E, #80
 117+ 4E03              .XY:
 118+ 4E03 ED 51        	OUT (C), D
 119+ 4E05 3A E0 F3     	LD A, (REG1SAV)
 120+ 4E08 E6 02        	AND 2
 121+ 4E0A ED 69        	OUT (C), L
 122+ 4E0C E1           	POP HL ; pattern
 123+ 4E0D 7D           	LD A, L
 124+ 4E0E 28 02        	JR Z, .SMALLSPRITES
 125+ 4E10 87           	ADD A, A
 126+ 4E11 87           	ADD A, A ; needs to go at 4x
 127+ 4E12              .SMALLSPRITES:
 128+ 4E12 D3 98        	OUT (#98), A
 129+ 4E14 E1           	POP HL ; color
 130+ 4E15 7D           	LD A, L
 131+ 4E16 B3           	OR E
 132+ 4E17 D3 98        	OUT (#98), A
 133+ 4E19              .NEXT:
 134+ 4E19 08           	EX AF, AF'
 135+ 4E1A 3C           	INC A
 136+ 4E1B E6 1F        	AND 31
 137+ 4E1D C2 31 4E     	JP NZ, .NEXT2
 138+ 4E20 08           	EX AF, AF'
 139+ 4E21 2A 28 F9     	LD HL, (ATRBAS)
 140+ 4E24              	; CALL SETWRT_LOCAL not allowed as SP modified
 141+ 4E24 7D           	LD	A, L
 142+ 4E25 D3 99        	OUT	(099H), A
 143+ 4E27 7C           	LD	A, H
 144+ 4E28 E6 3F        	AND	03FH
 145+ 4E2A F6 40        	OR	040H
 146+ 4E2C D3 99        	OUT	(099H), A
 147+ 4E2E C3 32 4E     	JP .NEXT3
 148+ 4E31              .NEXT2:
 149+ 4E31 08           	EX AF, AF'
 150+ 4E32              .NEXT3:
 151+ 4E32 10 85        	DJNZ .LOOP
 152+ 4E34 08           	EX AF, AF'
 153+ 4E35 3C           	INC A
 154+ 4E36 32 80 4D     	LD (FLICKER), A
 155+ 4E39
 156+ 4E39 ED 7B 81 4D  	LD SP, (TMPSP)
 157+ 4E3D 2A 7B 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 158+ 4E40 36 00        	LD (HL), 0 ; zero out update flag
 159+ 4E42 C9           	RET
 160+ 4E43              ; *******************************************************************************************************
 161+ 4E43
 162+ 4E43              ; *******************************************************************************************************
 163+ 4E43              ; function to handle CALL SPRENABLE basic extension
 164+ 4E43              ; initializes sprites handler
 165+ 4E43              ; _SPRENABLE ( INT sprites_attributes_data,
 166+ 4E43              ;			   INT update_variable_location,
 167+ 4E43              ;			   INT sprite_flicker_enabled )
 168+ 4E43              ; expects both locations to be in range #8000+ or throws an error
 169+ 4E43              ; since these should be BASIC variables
 170+ 4E43              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 171+ 4E43              SPRENABLE:
 172+ 4E43              	; opening (
 173+ 4E43 CD CB 59     	CALL CHKCHAR
 174+ 4E46 28           	DB '('
 175+ 4E47              	; get address of sprite attribute table DIM SA%(3,31)
 176+ 4E47 DD 21 2F 54  	LD IX, FRMQNT
 177+ 4E4B CD 59 01     	CALL CALBAS
 178+ 4E4E D5           	PUSH DE
 179+ 4E4F              	; comma
 180+ 4E4F CD CB 59     	CALL CHKCHAR
 181+ 4E52 2C           	DB ','
 182+ 4E53              	; get address of sprite update flag location
 183+ 4E53 DD 21 2F 54  	LD IX, FRMQNT
 184+ 4E57 CD 59 01     	CALL CALBAS
 185+ 4E5A D5           	PUSH DE
 186+ 4E5B              	; comma
 187+ 4E5B CD CB 59     	CALL CHKCHAR
 188+ 4E5E 2C           	DB ','
 189+ 4E5F              	; get flicker enabled flag
 190+ 4E5F DD 21 2F 54  	LD IX, FRMQNT
 191+ 4E63 CD 59 01     	CALL CALBAS
 192+ 4E66 D5           	PUSH DE
 193+ 4E67              	; ending )
 194+ 4E67 CD CB 59     	CALL CHKCHAR
 195+ 4E6A 29           	DB ')'
 196+ 4E6B
 197+ 4E6B D1           	POP DE ; get flicker flag
 198+ 4E6C 7A           	LD A, D
 199+ 4E6D B3           	OR E
 200+ 4E6E 32 7F 4D     	LD (SPRFLICKER_ENABLED), A
 201+ 4E71
 202+ 4E71 D1           	POP DE ; update variable location
 203+ 4E72 CB 7A        	BIT 7, D ; is address >= &h8000
 204+ 4E74 20 05        	JR NZ, .L1
 205+ 4E76 1E 05        	LD E, 5 ; illegal function call
 206+ 4E78 C3 EB 59     	JP THROW_ERROR
 207+ 4E7B              .L1:
 208+ 4E7B ED 53 7B 4D  	LD (SPRATR_UPDATE_FLAG), DE
 209+ 4E7F D1           	POP DE ; address of sprite attribute table
 210+ 4E80 CB 7A        	BIT 7, D ; is address >= &h8000
 211+ 4E82 20 05        	JR NZ, .L2
 212+ 4E84 1E 05        	LD E, 5 ; illegal function call
 213+ 4E86 C3 EB 59     	JP THROW_ERROR
 214+ 4E89              .L2:
 215+ 4E89 ED 53 7D 4D  	LD (SPRATR_DATA), DE
 216+ 4E8D 3E 01        	LD A, 1
 217+ 4E8F 32 7A 4D     	LD (SPRATR_INIT_STATUS), A
 218+ 4E92 C9           	RET
 219+ 4E93              ; *******************************************************************************************************
 220+ 4E93
 221+ 4E93              ; *******************************************************************************************************
 222+ 4E93              ; function to handle CALL SPRDISABLE basic extension
 223+ 4E93              ; disables sprites handling
 224+ 4E93              ; _SPRDISABLE
 225+ 4E93              ; resets variable SPRATR_INIT_STATUS
 226+ 4E93              SPRDISABLE:
 227+ 4E93 AF           	XOR A
 228+ 4E94 32 7A 4D     	LD (SPRATR_INIT_STATUS), A
 229+ 4E97 C9           	RET
 230+ 4E98              ; *******************************************************************************************************
 231+ 4E98
 232+ 4E98              ; *******************************************************************************************************
 233+ 4E98              ; function to handle CALL SPRSET basic extension
 234+ 4E98              ; sets position, and optionally pattern and color of sprite
 235+ 4E98              ; _SPRSET ( BYTE sprite_num , valid 0-31
 236+ 4E98              ;			INT x,
 237+ 4E98              ;			INT y,
 238+ 4E98              ;			INT pattern, valid 0-63, otherwise ignored
 239+ 4E98              ;			INT color, valid 0-15, otherwise ignored
 240+ 4E98              SPRSET:
 241+ 4E98 3A 7A 4D     	LD A, (SPRATR_INIT_STATUS)
 242+ 4E9B B7           	OR A
 243+ 4E9C 20 05        	JR NZ, .L1
 244+ 4E9E 1E 05        	LD E, 5 ; illegal function call
 245+ 4EA0 C3 EB 59     	JP THROW_ERROR
 246+ 4EA3              .L1:
 247+ 4EA3              	; opening (
 248+ 4EA3 CD CB 59     	CALL CHKCHAR
 249+ 4EA6 28           	DB '('
 250+ 4EA7              	; get sprite number
 251+ 4EA7 DD 21 1C 52  	LD IX, GETBYT
 252+ 4EAB CD 59 01     	CALL CALBAS
 253+ 4EAE F5           	PUSH AF
 254+ 4EAF              	; comma
 255+ 4EAF CD CB 59     	CALL CHKCHAR
 256+ 4EB2 2C           	DB ','
 257+ 4EB3              	; get x
 258+ 4EB3 DD 21 2F 54  	LD IX, FRMQNT
 259+ 4EB7 CD 59 01     	CALL CALBAS
 260+ 4EBA D5           	PUSH DE
 261+ 4EBB              	; comma
 262+ 4EBB CD CB 59     	CALL CHKCHAR
 263+ 4EBE 2C           	DB ','
 264+ 4EBF              	; get y
 265+ 4EBF DD 21 2F 54  	LD IX, FRMQNT
 266+ 4EC3 CD 59 01     	CALL CALBAS
 267+ 4EC6 D5           	PUSH DE
 268+ 4EC7              	; comma
 269+ 4EC7 CD CB 59     	CALL CHKCHAR
 270+ 4ECA 2C           	DB ','
 271+ 4ECB              	; get pattern
 272+ 4ECB DD 21 2F 54  	LD IX, FRMQNT
 273+ 4ECF CD 59 01     	CALL CALBAS
 274+ 4ED2 D5           	PUSH DE
 275+ 4ED3              	; comma
 276+ 4ED3 CD CB 59     	CALL CHKCHAR
 277+ 4ED6 2C           	DB ','
 278+ 4ED7              	; get color
 279+ 4ED7 DD 21 2F 54  	LD IX, FRMQNT
 280+ 4EDB CD 59 01     	CALL CALBAS
 281+ 4EDE D5           	PUSH DE
 282+ 4EDF              	; ending )
 283+ 4EDF CD CB 59     	CALL CHKCHAR
 284+ 4EE2 29           	DB ')'
 285+ 4EE3
 286+ 4EE3                  ; save position in BASIC text
 287+ 4EE3 E5           	PUSH HL
 288+ 4EE4 DD E1        	POP IX
 289+ 4EE6
 290+ 4EE6 C1           	POP BC ; color
 291+ 4EE7 D1           	POP DE ; pattern
 292+ 4EE8 D9           	EXX
 293+ 4EE9 C1           	POP BC ; y
 294+ 4EEA D1           	POP DE ; x
 295+ 4EEB F1           	POP AF ; sprite number
 296+ 4EEC FE 20        	CP 32
 297+ 4EEE 38 05        	JR C, .L2
 298+ 4EF0 1E 05        	LD E, 5 ; illegal function call
 299+ 4EF2 C3 EB 59     	JP THROW_ERROR
 300+ 4EF5              .L2:
 301+ 4EF5              	; find location in sprite attributes table
 302+ 4EF5 D5           	PUSH DE
 303+ 4EF6 CD 83 4D     	CALL GETnthSPRATTR
 304+ 4EF9 D1           	POP DE
 305+ 4EFA              	; set y
 306+ 4EFA 71           	LD (HL), C
 307+ 4EFB 23           	INC HL
 308+ 4EFC 70           	LD (HL), B
 309+ 4EFD 23           	INC HL
 310+ 4EFE              	; set x
 311+ 4EFE 73           	LD (HL), E
 312+ 4EFF 23           	INC HL
 313+ 4F00 72           	LD (HL), D
 314+ 4F01 23           	INC HL
 315+ 4F02 E5           	PUSH HL
 316+ 4F03 D9           	EXX
 317+ 4F04 E1           	POP HL
 318+ 4F05              	; check if 0<=pattern<64
 319+ 4F05 7A           	LD A, D
 320+ 4F06 B7           	OR A
 321+ 4F07 20 0B        	JR NZ, .L3
 322+ 4F09 7B           	LD A, E
 323+ 4F0A FE 40        	CP 64
 324+ 4F0C 30 06        	JR NC, .L3
 325+ 4F0E              	; set pattern
 326+ 4F0E              	;ADD A, A
 327+ 4F0E              	;ADD A, A
 328+ 4F0E              	;ADD A, A
 329+ 4F0E 77           	LD (HL), A
 330+ 4F0F 23           	INC HL
 331+ 4F10 72           	LD (HL), D
 332+ 4F11 23           	INC HL
 333+ 4F12 18 02        	JR .L4
 334+ 4F14              .L3:
 335+ 4F14              	; skip pattern
 336+ 4F14 23          > INC HL
 336+ 4F15 23          > INC HL
 337+ 4F16              .L4:
 338+ 4F16              	; check if 0<=color<16
 339+ 4F16 78           	LD A, B
 340+ 4F17 B7           	OR A
 341+ 4F18 20 08        	JR NZ, .L5
 342+ 4F1A 79           	LD A, C
 343+ 4F1B FE 10        	CP 16
 344+ 4F1D 30 03        	JR NC, .L5
 345+ 4F1F              	; set color
 346+ 4F1F 71           	LD (HL), C
 347+ 4F20 23           	INC HL
 348+ 4F21 70           	LD (HL), B
 349+ 4F22
 350+ 4F22              .L5:
 351+ 4F22 DD E5        	PUSH IX
 352+ 4F24 E1           	POP HL
 353+ 4F25 C9           	RET
 354+ 4F26              ; *******************************************************************************************************
 355+ 4F26
 356+ 4F26              ; *******************************************************************************************************
 357+ 4F26              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4F26              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4F26              ; input DE=initial x
 360+ 4F26              ; input BC=initial y
 361+ 4F26              ; input IY=location where delta y,x are located
 362+ 4F26              ; modifies AF, HL, IX
 363+ 4F26              SPRSET_DELTA_POS:
 364+ 4F26 D5           	PUSH DE
 365+ 4F27 CD 83 4D     	CALL GETnthSPRATTR
 366+ 4F2A E5           	PUSH HL
 367+ 4F2B DD E1        	POP IX
 368+ 4F2D D1           	POP DE
 369+ 4F2E              	; IX=sprite's y location
 370+ 4F2E FD 6E 00     	LD L, (IY)
 371+ 4F31 FD 66 01     	LD H, (IY+1)
 372+ 4F34 09           	ADD HL, BC
 373+ 4F35 DD 75 00     	LD (IX), L
 374+ 4F38 DD 74 01     	LD (IX+1), H
 375+ 4F3B FD 6E 02     	LD L, (IY+2)
 376+ 4F3E FD 66 03     	LD H, (IY+3)
 377+ 4F41 19           	ADD HL, DE
 378+ 4F42 DD 75 02     	LD (IX+2), L
 379+ 4F45 DD 74 03     	LD (IX+3), H
 380+ 4F48 C9           	RET
 381+ 4F49              ; *******************************************************************************************************
 382+ 4F49
 383+ 4F49              ; *******************************************************************************************************
 384+ 4F49              ; function to handle CALL SPRGRPMOV basic extension
 385+ 4F49              ; sets position of a group of sprites described with
 386+ 4F49              ; { int sprite_num, int delta_y, int delta_x } [count]
 387+ 4F49              ; _SPRGRPMOV ( INT x,
 388+ 4F49              ;			   INT y,
 389+ 4F49              ;			   INT data_ptr,
 390+ 4F49              ;			   BYTE count,
 391+ 4F49              ; will put ram in page 0 also, page 1 is already there
 392+ 4F49              SPRGRPMOV:
 393+ 4F49 3A 7A 4D     	LD A, (SPRATR_INIT_STATUS)
 394+ 4F4C B7           	OR A
 395+ 4F4D 20 05        	JR NZ, .L1
 396+ 4F4F 1E 05        	LD E, 5 ; illegal function call
 397+ 4F51 C3 EB 59     	JP THROW_ERROR
 398+ 4F54              .L1:
 399+ 4F54              	; opening (
 400+ 4F54 CD CB 59     	CALL CHKCHAR
 401+ 4F57 28           	DB '('
 402+ 4F58              	; get x
 403+ 4F58 DD 21 2F 54  	LD IX, FRMQNT
 404+ 4F5C CD 59 01     	CALL CALBAS
 405+ 4F5F D5           	PUSH DE
 406+ 4F60              	; comma
 407+ 4F60 CD CB 59     	CALL CHKCHAR
 408+ 4F63 2C           	DB ','
 409+ 4F64              	; get y
 410+ 4F64 DD 21 2F 54  	LD IX, FRMQNT
 411+ 4F68 CD 59 01     	CALL CALBAS
 412+ 4F6B D5           	PUSH DE
 413+ 4F6C              	; comma
 414+ 4F6C CD CB 59     	CALL CHKCHAR
 415+ 4F6F 2C           	DB ','
 416+ 4F70              	; get data pointer
 417+ 4F70 DD 21 2F 54  	LD IX, FRMQNT
 418+ 4F74 CD 59 01     	CALL CALBAS
 419+ 4F77 D5           	PUSH DE
 420+ 4F78              	; comma
 421+ 4F78 CD CB 59     	CALL CHKCHAR
 422+ 4F7B 2C           	DB ','
 423+ 4F7C              	; get count
 424+ 4F7C DD 21 1C 52  	LD IX, GETBYT
 425+ 4F80 CD 59 01     	CALL CALBAS
 426+ 4F83 F5           	PUSH AF
 427+ 4F84              	; ending )
 428+ 4F84 CD CB 59     	CALL CHKCHAR
 429+ 4F87 29           	DB ')'
 430+ 4F88
 431+ 4F88 E5           	PUSH HL
 432+ 4F89 DD E1        	POP IX
 433+ 4F8B
 434+ 4F8B C1           	POP BC ; count
 435+ 4F8C E1           	POP HL ; data pointer
 436+ 4F8D D9           	EXX
 437+ 4F8E C1           	POP BC ; y
 438+ 4F8F D1           	POP DE ; x
 439+ 4F90 D9           	EXX
 440+ 4F91
 441+ 4F91 DD E5        	PUSH IX ; save position in BASIC buffer
 442+ 4F93
 443+ 4F93 C5           	PUSH BC
 444+ 4F94 E5           	PUSH HL
 445+ 4F95 AF               XOR A
 446+ 4F96 CD BE 58         CALL GET_PAGE_INFO
 447+ 4F99 D9           	EXX
 448+ 4F9A E1           	POP HL
 449+ 4F9B F1           	POP AF
 450+ 4F9C D9           	EXX
 451+ 4F9D C5               PUSH BC
 452+ 4F9E D5               PUSH DE
 453+ 4F9F D9           	EXX
 454+ 4FA0 F5           	PUSH AF
 455+ 4FA1 E5           	PUSH HL
 456+ 4FA2 D9           	EXX
 457+ 4FA3 3A 41 F3         LD A, (RAMAD0)
 458+ 4FA6 26 00            LD H, 0
 459+ 4FA8 CD 05 59         CALL LOCAL_ENASLT
 460+ 4FAB FB           	EI
 461+ 4FAC E1           	POP HL
 462+ 4FAD C1           	POP BC
 463+ 4FAE CD B8 4F     	CALL .UPDATE_LOC
 464+ 4FB1 D1               POP DE
 465+ 4FB2 C1               POP BC
 466+ 4FB3 CD F5 58         CALL RESTORE_PAGE_INFO
 467+ 4FB6 E1           	POP HL
 468+ 4FB7 C9           	RET
 469+ 4FB8
 470+ 4FB8              .UPDATE_LOC:
 471+ 4FB8              .L4:
 472+ 4FB8 7E           	LD A, (HL)
 473+ 4FB9 23           	INC HL
 474+ 4FBA 23           	INC HL
 475+ 4FBB E5           	PUSH HL
 476+ 4FBC FD E1        	POP IY
 477+ 4FBE D9           	EXX
 478+ 4FBF CD 26 4F     	CALL SPRSET_DELTA_POS
 479+ 4FC2 D9           	EXX
 480+ 4FC3 23          > INC HL
 480+ 4FC4 23          > INC HL
 480+ 4FC5 23          > INC HL
 480+ 4FC6 23          > INC HL
 481+ 4FC7 10 EF        	DJNZ .L4
 482+ 4FC9 C9           	RET
 483+ 4FCA              ; *******************************************************************************************************
 484+ 4FCA
# file closed: asm\SPRITES.asm
 116  4FCA               ENDIF
 117  4FCA
 118  4FCA               IF (ANIM_CMDS == 1)
 119  4FCA               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4FCA              ; sprite animation routines
   2+ 4FCA
   3+ 4FCA              ; number of animation items and pointer
   4+ 4FCA              ANIMITEMNUM:
   5+ 4FCA 00            DB 0
   6+ 4FCB              ANIMITEMPTR:
   7+ 4FCB 57 5F         DW EXT_END
   8+ 4FCD              ; number of animation definitions and pointer
   9+ 4FCD              ANIMDEFNUM:
  10+ 4FCD 00            DB 0
  11+ 4FCE              ANIMDEFPTR:
  12+ 4FCE 57 5F         DW EXT_END
  13+ 4FD0              ; number of links between sprite and animation definitions
  14+ 4FD0              ANIMSPRNUM:
  15+ 4FD0 00            DB 0
  16+ 4FD1              ANIMSPRPTR:
  17+ 4FD1 57 5F         DW EXT_END
  18+ 4FD3
  19+ 4FD3              ; ANIMATION ITEM
  20+ 4FD3              ; byte type = [0 - pattern and color change
  21+ 4FD3              ;              1 - pattern definition change ]
  22+ 4FD3              ; word ticks - number of ticks to hold this state
  23+ 4FD3              ; for type = 0
  24+ 4FD3              ;   byte pattern;
  25+ 4FD3              ;   byte color;
  26+ 4FD3              ; for type = 1
  27+ 4FD3              ;   work data_pointer;
  28+ 4FD3              ; total size = 5b
  29+ 4FD3
  30+ 4FD3              ; ANIMATION DEFINITION
  31+ 4FD3              ; byte number of items 1-15
  32+ 4FD3              ; byte[15] anim_item;
  33+ 4FD3              ; total size = 16b
  34+ 4FD3
  35+ 4FD3              ; SPRITE ANIMATION
  36+ 4FD3              ; +00 byte sprite number;
  37+ 4FD3              ; +01 word time;
  38+ 4FD3              ; +03 byte current item;
  39+ 4FD3              ; +04 byte animation definition;
  40+ 4FD3              ; +05 byte cyclic;
  41+ 4FD3              ; +06 byte active;
  42+ 4FD3              ; +07 byte reserved
  43+ 4FD3              ; total size = 8b
  44+ 4FD3
  45+ 4FD3              ; *******************************************************************************************************
  46+ 4FD3              ; helper function HL=A*5
  47+ 4FD3              ; changes HL,DE;
  48+ 4FD3              Ax5:
  49+ 4FD3 26 00            LD H,0
  50+ 4FD5 6F               LD L,A
  51+ 4FD6 54               LD D,H
  52+ 4FD7 5D               LD E,L
  53+ 4FD8 29               ADD HL,HL
  54+ 4FD9 29               ADD HL,HL
  55+ 4FDA 19               ADD HL,DE
  56+ 4FDB C9               RET
  57+ 4FDC              ; *******************************************************************************************************
  58+ 4FDC
  59+ 4FDC              ; *******************************************************************************************************
  60+ 4FDC              ; helper function gets pointer to n-th animation item
  61+ 4FDC              ; changes HL,DE;
  62+ 4FDC              GETnthANIMITEM:
  63+ 4FDC CD D3 4F         CALL Ax5
  64+ 4FDF ED 5B CB 4F      LD DE,(ANIMITEMPTR)
  65+ 4FE3 19               ADD HL,DE
  66+ 4FE4 C9               RET
  67+ 4FE5              ; *******************************************************************************************************
  68+ 4FE5
  69+ 4FE5              ; *******************************************************************************************************
  70+ 4FE5              ; helper function gets pointer to n-th entry in animation definition
  71+ 4FE5              ; changes HL,DE;
  72+ 4FE5              GETnthANIMDEF:
  73+ 4FE5 26 00            LD H,0
  74+ 4FE7 6F               LD L,A
  75+ 4FE8 CD BA 58         CALL HLx8
  76+ 4FEB ED 5B CE 4F      LD DE,(ANIMDEFPTR)
  77+ 4FEF 19               ADD HL,DE
  78+ 4FF0 C9               RET
  79+ 4FF1              ; *******************************************************************************************************
  80+ 4FF1
  81+ 4FF1              ; *******************************************************************************************************
  82+ 4FF1              ; helper function gets pointer to n-th entry in sprite animation
  83+ 4FF1              ; changes HL,DE;
  84+ 4FF1              GETnthSPRANIM:
  85+ 4FF1 26 00            LD H,0
  86+ 4FF3 6F               LD L,A
  87+ 4FF4 CD B9 58         CALL HLx16
  88+ 4FF7 ED 5B D1 4F      LD DE,(ANIMSPRPTR)
  89+ 4FFB 19               ADD HL,DE
  90+ 4FFC C9               RET
  91+ 4FFD              ; *******************************************************************************************************
  92+ 4FFD
  93+ 4FFD              ; *******************************************************************************************************
  94+ 4FFD              ; function to handle CALL MAXANIMITEMS basic extension
  95+ 4FFD              ; MAXANIMITEMS (BYTE number)
  96+ 4FFD              ; sets new number and moves memory buffers as needed
  97+ 4FFD              MAXANIMITEMS:
  98+ 4FFD              	; opening (
  99+ 4FFD CD CB 59     	CALL CHKCHAR
 100+ 5000 28           	DB '('
 101+ 5001              	; get value
 102+ 5001 DD 21 1C 52  	LD IX, GETBYT
 103+ 5005 CD 59 01     	CALL CALBAS
 104+ 5008 F5               PUSH AF
 105+ 5009              	; ending )
 106+ 5009 CD CB 59     	CALL CHKCHAR
 107+ 500C 29           	DB ')'
 108+ 500D F1               POP AF
 109+ 500E
 110+ 500E              	; save position
 111+ 500E E5           	PUSH HL
 112+ 500F              .ENTRY:
 113+ 500F 47               LD B,A
 114+ 5010 3A CA 4F         LD A,(ANIMITEMNUM)
 115+ 5013 90               SUB B
 116+ 5014 28 1F            JR Z, .EXIT; same value as before
 117+ 5016 FD 21 CE 4F      LD IY,ANIMDEFPTR
 118+ 501A FA 38 50         JP M, .INCREASE
 119+ 501D                  ; new value is lower than previous one
 120+ 501D CD 50 50         CALL .SIZEDIFF
 121+ 5020 CD 6B 50         CALL .DECREASE_COMMON
 122+ 5023 2A D1 4F         LD HL,(ANIMSPRPTR)
 123+ 5026 AF               XOR A
 124+ 5027 ED 42            SBC HL,BC
 125+ 5029 22 D1 4F         LD (ANIMSPRPTR),HL
 126+ 502C              .E1:
 127+ 502C 2A 10 40         LD HL,(FREEMEMPTR)
 128+ 502F AF               XOR A
 129+ 5030 ED 42            SBC HL,BC
 130+ 5032 22 10 40         LD (FREEMEMPTR),HL
 131+ 5035              .EXIT:
 132+ 5035 FB               EI
 133+ 5036 E1           	POP HL
 134+ 5037 C9           	RET
 135+ 5038              .INCREASE:
 136+ 5038 ED 44            NEG
 137+ 503A CD 50 50         CALL .SIZEDIFF
 138+ 503D CD 97 50         CALL .INCREASE_COMMON
 139+ 5040 2A D1 4F         LD HL,(ANIMSPRPTR)
 140+ 5043 09               ADD HL,BC
 141+ 5044 22 D1 4F         LD (ANIMSPRPTR),HL
 142+ 5047              .E2:
 143+ 5047 2A 10 40         LD HL,(FREEMEMPTR)
 144+ 504A 09               ADD HL,BC
 145+ 504B 22 10 40         LD (FREEMEMPTR),HL
 146+ 504E 18 E5            JR .EXIT
 147+ 5050              .SIZEDIFF:
 148+ 5050 CD D3 4F         CALL Ax5
 149+ 5053 78               LD A,B
 150+ 5054 32 CA 4F         LD (ANIMITEMNUM),A
 151+ 5057 44               LD B,H
 152+ 5058 4D               LD C,L
 153+ 5059 C9               RET ; BC=size difference in bytes
 154+ 505A              .SIZETOMOVE:
 155+ 505A D5               PUSH DE
 156+ 505B 2A 10 40         LD HL,(FREEMEMPTR)
 157+ 505E FD 5E 00         LD E,(IY)
 158+ 5061 FD 56 01         LD D,(IY+1)
 159+ 5064 AF               XOR A
 160+ 5065 ED 52            SBC HL,DE
 161+ 5067 44               LD B,H
 162+ 5068 4D               LD C,L
 163+ 5069 D1               POP DE
 164+ 506A C9               RET
 165+ 506B              .DECREASE_COMMON:
 166+ 506B FD 6E 00         LD L,(IY)
 167+ 506E FD 66 01         LD H,(IY+1)
 168+ 5071 AF               XOR A
 169+ 5072 ED 42            SBC HL,BC
 170+ 5074 EB               EX DE,HL
 171+ 5075 C5               PUSH BC
 172+ 5076 CD 5A 50         CALL .SIZETOMOVE
 173+ 5079 F3               DI
 174+ 507A 78               LD A,B
 175+ 507B B1               OR C
 176+ 507C 28 08            JR Z,.L1
 177+ 507E FD 6E 00         LD L,(IY)
 178+ 5081 FD 66 01         LD H,(IY+1)
 179+ 5084 ED B0            LDIR
 180+ 5086              .L1:
 181+ 5086 C1               POP BC
 182+ 5087 FD 6E 00         LD L,(IY)
 183+ 508A FD 66 01         LD H,(IY+1)
 184+ 508D AF               XOR A
 185+ 508E ED 42            SBC HL,BC
 186+ 5090 FD 75 00         LD (IY),L
 187+ 5093 FD 74 01         LD (IY+1),H
 188+ 5096 C9               RET
 189+ 5097              .INCREASE_COMMON:
 190+ 5097 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 509A 2B               DEC HL
 192+ 509B AF               XOR A
 193+ 509C ED 42            SBC HL,BC
 194+ 509E EB               EX DE,HL
 195+ 509F C5               PUSH BC
 196+ 50A0 CD 5A 50         CALL .SIZETOMOVE
 197+ 50A3 F3               DI
 198+ 50A4 78               LD A,B
 199+ 50A5 B1               OR C
 200+ 50A6 28 06            JR Z,.L2
 201+ 50A8 2A 10 40         LD HL,(FREEMEMPTR)
 202+ 50AB 2B               DEC HL
 203+ 50AC ED B8            LDDR
 204+ 50AE              .L2:
 205+ 50AE C1               POP BC
 206+ 50AF FD 6E 00         LD L,(IY)
 207+ 50B2 FD 66 01         LD H,(IY+1)
 208+ 50B5 09               ADD HL,BC
 209+ 50B6 FD 75 00         LD (IY),L
 210+ 50B9 FD 74 01         LD (IY+1),H
 211+ 50BC C9               RET
 212+ 50BD              ; *******************************************************************************************************
 213+ 50BD
 214+ 50BD              ; *******************************************************************************************************
 215+ 50BD              ; function to handle CALL ANIMITEMPAT basic extension
 216+ 50BD              ; ANIMITEMPAT ( BYTE id,
 217+ 50BD              ;               INT ticks,
 218+ 50BD              ;               BYTE pattern,
 219+ 50BD              ;               BYTE color )
 220+ 50BD              ; fills animation item data, returns an error if out of bounds
 221+ 50BD              ANIMITEMPAT:
 222+ 50BD                  ; opening (
 223+ 50BD CD CB 59     	CALL CHKCHAR
 224+ 50C0 28           	DB '('
 225+ 50C1              	; get id
 226+ 50C1 DD 21 1C 52  	LD IX, GETBYT
 227+ 50C5 CD 59 01     	CALL CALBAS
 228+ 50C8 F5               PUSH AF
 229+ 50C9                  ; check if out of bounds
 230+ 50C9 3C               INC A
 231+ 50CA 4F               LD C,A
 232+ 50CB 3A CA 4F         LD A,(ANIMITEMNUM)
 233+ 50CE B9               CP C
 234+ 50CF DA E1 59         JP C,SUBSCRIPT_OUT_OF_RANGE
 235+ 50D2              	; comma
 236+ 50D2 CD CB 59     	CALL CHKCHAR
 237+ 50D5 2C           	DB ','
 238+ 50D6              	; get ticks
 239+ 50D6 DD 21 2F 54  	LD IX, FRMQNT
 240+ 50DA CD 59 01     	CALL CALBAS
 241+ 50DD D5           	PUSH DE
 242+ 50DE              	; comma
 243+ 50DE CD CB 59     	CALL CHKCHAR
 244+ 50E1 2C           	DB ','
 245+ 50E2              	; get pattern
 246+ 50E2 DD 21 1C 52  	LD IX, GETBYT
 247+ 50E6 CD 59 01     	CALL CALBAS
 248+ 50E9 F5               PUSH AF
 249+ 50EA              	; comma
 250+ 50EA CD CB 59     	CALL CHKCHAR
 251+ 50ED 2C           	DB ','
 252+ 50EE              	; get color
 253+ 50EE DD 21 1C 52  	LD IX, GETBYT
 254+ 50F2 CD 59 01     	CALL CALBAS
 255+ 50F5 F5               PUSH AF
 256+ 50F6              	; ending )
 257+ 50F6 CD CB 59     	CALL CHKCHAR
 258+ 50F9 29           	DB ')'
 259+ 50FA              .ENTRY:
 260+ 50FA E5               PUSH HL
 261+ 50FB DD E1            POP IX
 262+ 50FD D9               EXX
 263+ 50FE C1               POP BC ; color
 264+ 50FF D1               POP DE ; pattern
 265+ 5100 E1               POP HL ; ticks
 266+ 5101 D9               EXX
 267+ 5102 F1               POP AF
 268+ 5103 CD DC 4F         CALL GETnthANIMITEM
 269+ 5106 E5               PUSH HL
 270+ 5107 FD E1            POP IY
 271+ 5109 D9               EXX
 272+ 510A FD 36 00 00      LD (IY),0 ; type=0
 273+ 510E FD 75 01         LD (IY+1),L
 274+ 5111 FD 74 02         LD (IY+2),H
 275+ 5114 FD 72 03         LD (IY+3),D
 276+ 5117 FD 70 04         LD (IY+4),B
 277+ 511A
 278+ 511A DD E5            PUSH IX
 279+ 511C E1               POP HL
 280+ 511D C9               RET
 281+ 511E              ; *******************************************************************************************************
 282+ 511E
 283+ 511E              ; *******************************************************************************************************
 284+ 511E              ; function to handle CALL ANIMITEMPTR basic extension
 285+ 511E              ; ANIMITEMPTR ( BYTE id,
 286+ 511E              ;               INT ticks,
 287+ 511E              ;               INT pointer,
 288+ 511E              ; fills animation item data, returns an error if out of bounds
 289+ 511E              ANIMITEMPTR_CMD:
 290+ 511E                  ; opening (
 291+ 511E CD CB 59     	CALL CHKCHAR
 292+ 5121 28           	DB '('
 293+ 5122              	; get id
 294+ 5122 DD 21 1C 52  	LD IX, GETBYT
 295+ 5126 CD 59 01     	CALL CALBAS
 296+ 5129 F5               PUSH AF
 297+ 512A                  ; check if out of bounds
 298+ 512A 3C               INC A
 299+ 512B 4F               LD C,A
 300+ 512C 3A CA 4F         LD A,(ANIMITEMNUM)
 301+ 512F B9               CP C
 302+ 5130 DA E1 59         JP C,SUBSCRIPT_OUT_OF_RANGE
 303+ 5133              	; comma
 304+ 5133 CD CB 59     	CALL CHKCHAR
 305+ 5136 2C           	DB ','
 306+ 5137              	; get ticks
 307+ 5137 DD 21 2F 54  	LD IX, FRMQNT
 308+ 513B CD 59 01     	CALL CALBAS
 309+ 513E D5           	PUSH DE
 310+ 513F              	; comma
 311+ 513F CD CB 59     	CALL CHKCHAR
 312+ 5142 2C           	DB ','
 313+ 5143              	; get pointer
 314+ 5143 DD 21 2F 54  	LD IX, FRMQNT
 315+ 5147 CD 59 01     	CALL CALBAS
 316+ 514A D5           	PUSH DE
 317+ 514B              	; ending )
 318+ 514B CD CB 59     	CALL CHKCHAR
 319+ 514E 29           	DB ')'
 320+ 514F              .ENTRY:
 321+ 514F E5               PUSH HL
 322+ 5150 DD E1            POP IX
 323+ 5152 D9               EXX
 324+ 5153 D1               POP DE ; pointer
 325+ 5154 E1               POP HL ; ticks
 326+ 5155 D9               EXX
 327+ 5156 F1               POP AF
 328+ 5157 CD DC 4F         CALL GETnthANIMITEM
 329+ 515A E5               PUSH HL
 330+ 515B FD E1            POP IY
 331+ 515D D9               EXX
 332+ 515E FD 36 00 01      LD (IY),1 ; type=1
 333+ 5162 FD 75 01         LD (IY+1),L
 334+ 5165 FD 74 02         LD (IY+2),H
 335+ 5168 FD 73 03         LD (IY+3),E
 336+ 516B FD 72 04         LD (IY+4),D
 337+ 516E
 338+ 516E DD E5            PUSH IX
 339+ 5170 E1               POP HL
 340+ 5171 C9               RET
 341+ 5172              ; *******************************************************************************************************
 342+ 5172
 343+ 5172              ; *******************************************************************************************************
 344+ 5172              ; function to handle CALL MAXANIMDEFS basic extension
 345+ 5172              ; MAXANIMDEFS (BYTE number)
 346+ 5172              ; sets new number and moves memory buffers as needed
 347+ 5172              MAXANIMDEFS:
 348+ 5172              	; opening (
 349+ 5172 CD CB 59     	CALL CHKCHAR
 350+ 5175 28           	DB '('
 351+ 5176              	; get value
 352+ 5176 DD 21 1C 52  	LD IX, GETBYT
 353+ 517A CD 59 01     	CALL CALBAS
 354+ 517D F5               PUSH AF
 355+ 517E              	; ending )
 356+ 517E CD CB 59     	CALL CHKCHAR
 357+ 5181 29           	DB ')'
 358+ 5182 F1               POP AF
 359+ 5183
 360+ 5183              	; save position
 361+ 5183 E5           	PUSH HL
 362+ 5184              .ENTRY:
 363+ 5184 47               LD B,A
 364+ 5185 3A CD 4F         LD A,(ANIMDEFNUM)
 365+ 5188 90               SUB B
 366+ 5189 CA 35 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 367+ 518C FD 21 D1 4F      LD IY,ANIMSPRPTR
 368+ 5190 FA 9C 51         JP M, .INCREASE
 369+ 5193                  ; new value is lower than previous one
 370+ 5193 CD A7 51         CALL .SIZEDIFF
 371+ 5196 CD 6B 50         CALL MAXANIMITEMS.DECREASE_COMMON
 372+ 5199 C3 2C 50         JP MAXANIMITEMS.E1
 373+ 519C              .INCREASE:
 374+ 519C ED 44            NEG
 375+ 519E CD A7 51         CALL .SIZEDIFF
 376+ 51A1 CD 97 50         CALL MAXANIMITEMS.INCREASE_COMMON
 377+ 51A4 C3 47 50         JP MAXANIMITEMS.E2
 378+ 51A7              .SIZEDIFF:
 379+ 51A7 26 00            LD H,0
 380+ 51A9 6F               LD L,A
 381+ 51AA CD B9 58         CALL HLx16
 382+ 51AD 78               LD A,B
 383+ 51AE 32 CD 4F         LD (ANIMDEFNUM),A
 384+ 51B1 44               LD B,H
 385+ 51B2 4D               LD C,L
 386+ 51B3 C9               RET ; BC=size difference in bytes
 387+ 51B4              ; *******************************************************************************************************
 388+ 51B4
 389+ 51B4              ; *******************************************************************************************************
 390+ 51B4              ; function to handle CALL ANIMDEF basic extension
 391+ 51B4              ; ANIMITEMPAT ( BYTE id,
 392+ 51B4              ;               BYTE size,
 393+ 51B4              ;               INT[] list )
 394+ 51B4              ; fills animation definition data, returns an error if out of bounds, or invalid type
 395+ 51B4              ANIMDEF:
 396+ 51B4                  ; opening (
 397+ 51B4 CD CB 59     	CALL CHKCHAR
 398+ 51B7 28           	DB '('
 399+ 51B8              	; get id
 400+ 51B8 DD 21 1C 52  	LD IX, GETBYT
 401+ 51BC CD 59 01     	CALL CALBAS
 402+ 51BF F5               PUSH AF
 403+ 51C0                  ; check if out of bounds
 404+ 51C0 3C               INC A
 405+ 51C1 4F               LD C,A
 406+ 51C2 3A CD 4F         LD A,(ANIMDEFNUM)
 407+ 51C5 B9               CP C
 408+ 51C6 DA E1 59         JP C,SUBSCRIPT_OUT_OF_RANGE
 409+ 51C9              	; comma
 410+ 51C9 CD CB 59     	CALL CHKCHAR
 411+ 51CC 2C           	DB ','
 412+ 51CD              	; get size
 413+ 51CD DD 21 1C 52  	LD IX, GETBYT
 414+ 51D1 CD 59 01     	CALL CALBAS
 415+ 51D4 FE 10            CP 16
 416+ 51D6 D2 E5 59         JP NC, OVERFLOW
 417+ 51D9 B7               OR A
 418+ 51DA CA E5 59         JP Z, OVERFLOW
 419+ 51DD F5           	PUSH AF
 420+ 51DE              	; comma
 421+ 51DE CD CB 59     	CALL CHKCHAR
 422+ 51E1 2C           	DB ','
 423+ 51E2              	; get pointer to a list of animation items in integer array format
 424+ 51E2                  ; get array pointer
 425+ 51E2 D1               POP DE
 426+ 51E3 D5               PUSH DE
 427+ 51E4 15               DEC D
 428+ 51E5 1E 00            LD E,0
 429+ 51E7 3E 02            LD A,2
 430+ 51E9 06 01            LD B,1
 431+ 51EB CD F2 59         CALL GET_BASIC_ARRAY_DATA_POINTER
 432+ 51EE C5               PUSH BC
 433+ 51EF              	; ending )
 434+ 51EF CD CB 59     	CALL CHKCHAR
 435+ 51F2 29           	DB ')'
 436+ 51F3              .ENTRY:
 437+ 51F3 E5               PUSH HL
 438+ 51F4 DD E1            POP IX
 439+ 51F6 D1               POP DE ; pointer to INT array
 440+ 51F7 C1               POP BC ; B=item number
 441+ 51F8 F1               POP AF ; id
 442+ 51F9 D5               PUSH DE
 443+ 51FA CD E5 4F         CALL GETnthANIMDEF
 444+ 51FD D1               POP DE
 445+ 51FE 70               LD (HL),B
 446+ 51FF              .L1:
 447+ 51FF 23               INC HL
 448+ 5200 1A               LD A,(DE)
 449+ 5201 13          > INC DE
 449+ 5202 13          > INC DE
 450+ 5203 77               LD (HL),A
 451+ 5204 10 F9            DJNZ .L1
 452+ 5206 DD E5            PUSH IX
 453+ 5208 E1               POP HL
 454+ 5209 C9               RET
 455+ 520A              ; *******************************************************************************************************
 456+ 520A
 457+ 520A              ; *******************************************************************************************************
 458+ 520A              ; function to handle CALL MAXANIMSPRS basic extension
 459+ 520A              ; MAXANIMSPRS (BYTE number)
 460+ 520A              ; sets new number and moves memory buffers as needed
 461+ 520A              MAXANIMSPRS:
 462+ 520A              	; opening (
 463+ 520A CD CB 59     	CALL CHKCHAR
 464+ 520D 28           	DB '('
 465+ 520E              	; get value
 466+ 520E DD 21 1C 52  	LD IX, GETBYT
 467+ 5212 CD 59 01     	CALL CALBAS
 468+ 5215 F5               PUSH AF
 469+ 5216              	; ending )
 470+ 5216 CD CB 59     	CALL CHKCHAR
 471+ 5219 29           	DB ')'
 472+ 521A F1               POP AF
 473+ 521B
 474+ 521B              	; save position
 475+ 521B E5           	PUSH HL
 476+ 521C              .ENTRY:
 477+ 521C 47               LD B,A
 478+ 521D 3A D0 4F         LD A,(ANIMSPRNUM)
 479+ 5220 90               SUB B
 480+ 5221 CA 35 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 481+ 5224 FD 21 10 40      LD IY,FREEMEMPTR
 482+ 5228 FA 34 52         JP M, .INCREASE
 483+ 522B                  ; new value is lower than previous one
 484+ 522B CD 53 52         CALL .SIZEDIFF
 485+ 522E CD 6B 50         CALL MAXANIMITEMS.DECREASE_COMMON
 486+ 5231 C3 35 50         JP MAXANIMITEMS.EXIT
 487+ 5234              .INCREASE:
 488+ 5234 ED 44            NEG
 489+ 5236 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 490+ 5237 CD 53 52         CALL .SIZEDIFF
 491+ 523A CD 97 50         CALL MAXANIMITEMS.INCREASE_COMMON
 492+ 523D AF               XOR A
 493+ 523E ED 42            SBC HL,BC ; location of new stuff
 494+ 5240 F1               POP AF
 495+ 5241 47               LD B,A
 496+ 5242 11 08 00         LD DE,8
 497+ 5245 E5               PUSH HL
 498+ 5246 DD E1            POP IX
 499+ 5248              .L1:
 500+ 5248 DD 36 06 00      LD (IX+6),0
 501+ 524C DD 19            ADD IX,DE
 502+ 524E 10 F8            DJNZ .L1
 503+ 5250 C3 35 50         JP MAXANIMITEMS.EXIT
 504+ 5253              .SIZEDIFF:
 505+ 5253 26 00            LD H,0
 506+ 5255 6F               LD L,A
 507+ 5256 CD BA 58         CALL HLx8
 508+ 5259 78               LD A,B
 509+ 525A 32 D0 4F         LD (ANIMSPRNUM),A
 510+ 525D 44               LD B,H
 511+ 525E 4D               LD C,L
 512+ 525F C9               RET ; BC=size difference in bytes
 513+ 5260              ; *******************************************************************************************************
 514+ 5260
 515+ 5260              ; *******************************************************************************************************
 516+ 5260              ; function to handle CALL ANIMSPRITE basic extension
 517+ 5260              ; ANIMSPRITE ( BYTE id,
 518+ 5260              ;              BYTE sprite_number,
 519+ 5260              ;              BYTE animation_definition_id,
 520+ 5260              ;              BYTE cyclic_flag )
 521+ 5260              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 522+ 5260              ANIMSPRITE:
 523+ 5260                  ; opening (
 524+ 5260 CD CB 59     	CALL CHKCHAR
 525+ 5263 28           	DB '('
 526+ 5264              	; get sprite animation id
 527+ 5264 DD 21 1C 52  	LD IX, GETBYT
 528+ 5268 CD 59 01     	CALL CALBAS
 529+ 526B F5               PUSH AF
 530+ 526C 3C               INC A
 531+ 526D 4F               LD C,A
 532+ 526E 3A D0 4F         LD A,(ANIMSPRNUM)
 533+ 5271 B9               CP C
 534+ 5272 DA E1 59         JP C,SUBSCRIPT_OUT_OF_RANGE
 535+ 5275              	; comma
 536+ 5275 CD CB 59     	CALL CHKCHAR
 537+ 5278 2C           	DB ','
 538+ 5279              	; get sprite number
 539+ 5279 DD 21 1C 52  	LD IX, GETBYT
 540+ 527D CD 59 01     	CALL CALBAS
 541+ 5280 F5               PUSH AF
 542+ 5281                  ; check if out of bounds
 543+ 5281 FE 20            CP 32
 544+ 5283 D2 E1 59         JP NC, SUBSCRIPT_OUT_OF_RANGE
 545+ 5286              	; comma
 546+ 5286 CD CB 59     	CALL CHKCHAR
 547+ 5289 2C           	DB ','
 548+ 528A              	; get animation definition id
 549+ 528A DD 21 1C 52  	LD IX, GETBYT
 550+ 528E CD 59 01     	CALL CALBAS
 551+ 5291 F5               PUSH AF
 552+ 5292 3C               INC A
 553+ 5293 4F               LD C,A
 554+ 5294 3A CD 4F         LD A,(ANIMDEFNUM)
 555+ 5297 B9               CP C
 556+ 5298 DA E1 59         JP C,SUBSCRIPT_OUT_OF_RANGE
 557+ 529B              	; comma
 558+ 529B CD CB 59     	CALL CHKCHAR
 559+ 529E 2C           	DB ','
 560+ 529F              	; get cyclic flag
 561+ 529F DD 21 1C 52  	LD IX, GETBYT
 562+ 52A3 CD 59 01         CALL CALBAS
 563+ 52A6 F5           	PUSH AF
 564+ 52A7              	; ending )
 565+ 52A7 CD CB 59     	CALL CHKCHAR
 566+ 52AA 29           	DB ')'
 567+ 52AB              .ENTRY:
 568+ 52AB E5               PUSH HL
 569+ 52AC DD E1            POP IX
 570+ 52AE D9               EXX
 571+ 52AF D1               POP DE ; cyclic
 572+ 52B0 C1               POP BC ; animation definition id
 573+ 52B1 E1               POP HL ; sprite number
 574+ 52B2 D9               EXX
 575+ 52B3 F1               POP AF ; sprite animation id
 576+ 52B4 CD F1 4F         CALL GETnthSPRANIM
 577+ 52B7 E5               PUSH HL
 578+ 52B8 FD E1            POP IY
 579+ 52BA D9               EXX
 580+ 52BB FD 74 00         LD (IY),H
 581+ 52BE FD 70 04         LD (IY+4),B
 582+ 52C1 FD 72 05         LD (IY+5),D
 583+ 52C4                  ;LD (IY+6),0
 584+ 52C4 DD E5            PUSH IX
 585+ 52C6 E1               POP HL
 586+ 52C7 C9               RET
 587+ 52C8              ; *******************************************************************************************************
 588+ 52C8
 589+ 52C8              ; *******************************************************************************************************
 590+ 52C8              ; function to handle CALL ANIMSTART basic extension
 591+ 52C8              ; two forms
 592+ 52C8              ; ANIMSTART ( BYTE id )
 593+ 52C8              ; or
 594+ 52C8              ; ANIMSTART ( BYTE item_number,
 595+ 52C8              ;             INT[] sprite_animations )
 596+ 52C8              ; sets active flag to 1
 597+ 52C8              ANIMSTART:
 598+ 52C8 3E 01            LD A,1
 599+ 52CA 18 01            JR ANIMSTARTSTOP_COMMON
 600+ 52CC              ; *******************************************************************************************************
 601+ 52CC              ; *******************************************************************************************************
 602+ 52CC              ; function to handle CALL ANIMSTOP basic extension
 603+ 52CC              ; two forms
 604+ 52CC              ; ANIMSTOP ( BYTE id )
 605+ 52CC              ; or
 606+ 52CC              ; ANIMSTOP ( BYTE item_number,
 607+ 52CC              ;            INT[] sprite_animations )
 608+ 52CC              ; sets active flag to 1
 609+ 52CC              ANIMSTOP:
 610+ 52CC AF               XOR A
 611+ 52CD              ANIMSTARTSTOP_COMMON:
 612+ 52CD 32 2D 53         LD (ANIMSTARTSTOP_COMMON.VALUE+3),A
 613+ 52D0              ; *******************************************************************************************************
 614+ 52D0                  ; opening (
 615+ 52D0 CD CB 59     	CALL CHKCHAR
 616+ 52D3 28           	DB '('
 617+ 52D4              	; get sprite animation id or array size
 618+ 52D4 DD 21 1C 52  	LD IX,GETBYT
 619+ 52D8 CD 59 01     	CALL CALBAS
 620+ 52DB F5               PUSH AF
 621+ 52DC                  ; check if comma present
 622+ 52DC CD D5 59         CALL GETPREVCHAR
 623+ 52DF 23               INC HL
 624+ 52E0 FE 2C            CP ','
 625+ 52E2 28 0C            JR Z,.L1
 626+ 52E4 FE 29            CP ')'
 627+ 52E6 C2 E9 59         JP NZ,SYNTAX_ERROR
 628+ 52E9                  ; ok so single argument variant
 629+ 52E9 F1               POP AF
 630+ 52EA E5               PUSH HL
 631+ 52EB CD 19 53         CALL .SETVALUE
 632+ 52EE E1               POP HL
 633+ 52EF C9               RET
 634+ 52F0              .L1:
 635+ 52F0                  ; get array pointer
 636+ 52F0 D1               POP DE
 637+ 52F1 D5               PUSH DE
 638+ 52F2 15               DEC D
 639+ 52F3 1E 00            LD E,0
 640+ 52F5 3E 02            LD A,2
 641+ 52F7 06 01            LD B,1
 642+ 52F9 CD F2 59         CALL GET_BASIC_ARRAY_DATA_POINTER
 643+ 52FC C5               PUSH BC
 644+ 52FD              	; ending )
 645+ 52FD CD CB 59     	CALL CHKCHAR
 646+ 5300 29           	DB ')'
 647+ 5301 D1               POP DE ; array pointer
 648+ 5302 C1               POP BC ; number of items
 649+ 5303 78               LD A,B
 650+ 5304 B7               OR A
 651+ 5305 CA E1 59         JP Z,SUBSCRIPT_OUT_OF_RANGE
 652+ 5308 E5               PUSH HL
 653+ 5309 F3               DI
 654+ 530A              .L2:
 655+ 530A C5               PUSH BC
 656+ 530B 1A               LD A,(DE)
 657+ 530C 13          > INC DE
 657+ 530D 13          > INC DE
 658+ 530E D5               PUSH DE
 659+ 530F CD 19 53         CALL .SETVALUE
 660+ 5312 D1               POP DE
 661+ 5313 C1               POP BC
 662+ 5314 10 F4            DJNZ .L2
 663+ 5316 FB               EI
 664+ 5317 E1               POP HL
 665+ 5318 C9               RET
 666+ 5319
 667+ 5319              .SETVALUE:
 668+ 5319 47               LD B,A
 669+ 531A 3C               INC A
 670+ 531B 4F               LD C,A
 671+ 531C 3A D0 4F         LD A,(ANIMSPRNUM)
 672+ 531F B9               CP C
 673+ 5320 DA E1 59         JP C,SUBSCRIPT_OUT_OF_RANGE
 674+ 5323 78               LD A,B
 675+ 5324 CD F1 4F         CALL GETnthSPRANIM
 676+ 5327 E5               PUSH HL
 677+ 5328 DD E1            POP IX
 678+ 532A              .VALUE:
 679+ 532A DD 36 06 01      LD (IX+6),1 ; active flag
 680+ 532E 3A 2D 53         LD A,(.VALUE+3)
 681+ 5331 B7               OR A
 682+ 5332 C8               RET Z
 683+ 5333 DD 36 03 00      LD (IX+3),0 ; current item
 684+ 5337 C3 A8 53         JP SETUP_ANIM_STEP
 685+ 533A              ; *******************************************************************************************************
 686+ 533A
 687+ 533A              ; *******************************************************************************************************
 688+ 533A              ; function processes animations during vblank period
 689+ 533A              PROCESS_ANIMATIONS:
 690+ 533A 3A D0 4F         LD A,(ANIMSPRNUM)
 691+ 533D B7               OR A
 692+ 533E C8               RET Z; no animations defined
 693+ 533F 47               LD B,A
 694+ 5340 DD 2A D1 4F      LD IX,(ANIMSPRPTR)
 695+ 5344              .L1:
 696+ 5344 C5               PUSH BC
 697+ 5345 DD 7E 06         LD A,(IX+6); active
 698+ 5348 B7               OR A
 699+ 5349 28 16            JR Z,.SKIP ; inactive animation
 700+ 534B DD 6E 01         LD L,(IX+1)
 701+ 534E DD 66 02         LD H,(IX+2) ; HL=end time
 702+ 5351 ED 5B 9E FC      LD DE,(JIFFY)
 703+ 5355 AF               XOR A
 704+ 5356 ED 52            SBC HL,DE
 705+ 5358 F2 61 53         JP P,.SKIP ; time until next animation item not yet reached
 706+ 535B DD 34 03         INC (IX+3) ; current animation item
 707+ 535E CD A8 53         CALL SETUP_ANIM_STEP
 708+ 5361              .SKIP:
 709+ 5361 11 08 00         LD DE,8
 710+ 5364 DD 19            ADD IX,DE
 711+ 5366 C1               POP BC
 712+ 5367 10 DB            DJNZ .L1
 713+ 5369 C9               RET
 714+ 536A              ; *******************************************************************************************************
 715+ 536A
 716+ 536A              ; *******************************************************************************************************
 717+ 536A              ; function will setup sprite animation after current item change
 718+ 536A              ; input A=current animation definition
 719+ 536A              ; input IX=pointer to sprite animation
 720+ 536A              ; output IY=pointer to animation item
 721+ 536A              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
 722+ 536A              ; basically sets new end time for current animation
 723+ 536A              INIT_CURRENT_ANIMATION:
 724+ 536A CD E5 4F         CALL GETnthANIMDEF
 725+ 536D 7E               LD A,(HL); number of animation items in the animation definition
 726+ 536E DD BE 03         CP (IX+3) ; current animation item
 727+ 5371 20 0A            JR NZ,.L3 ; last item not reached
 728+ 5373                  ; last item reached
 729+ 5373 DD 7E 05         LD A,(IX+5) ; cyclic flag
 730+ 5376 B7               OR A
 731+ 5377 28 2D            JR Z,.ERROR ; non-cyclic animation
 732+ 5379                  ; cyclic animation, restart
 733+ 5379 DD 36 03 00      LD (IX+3),0; current item
 734+ 537D              .L3:
 735+ 537D                  ; HL = animation definition
 736+ 537D 23               INC HL ; skip animation definition size field
 737+ 537E 16 00            LD D,0
 738+ 5380 DD 5E 03         LD E,(IX+3); current item
 739+ 5383 19               ADD HL,DE
 740+ 5384 4E               LD C,(HL) ; current animation item
 741+ 5385 0C               INC C
 742+ 5386 3A CA 4F         LD A,(ANIMITEMNUM)
 743+ 5389 B9               CP C
 744+ 538A 38 1A            JR C,.ERROR ; invalid animation item, stop animation
 745+ 538C 0D               DEC C
 746+ 538D 79               LD A,C
 747+ 538E CD DC 4F         CALL GETnthANIMITEM
 748+ 5391 E5               PUSH HL
 749+ 5392 FD E1            POP IY ; IY=animation item
 750+ 5394 2A 9E FC         LD HL,(JIFFY)
 751+ 5397 FD 5E 01         LD E,(IY+1)
 752+ 539A FD 56 02         LD D,(IY+2) ; duration
 753+ 539D 19               ADD HL,DE
 754+ 539E DD 75 01         LD (IX+1),L
 755+ 53A1 DD 74 02         LD (IX+2),H ; end time for current item
 756+ 53A4              .EXIT:
 757+ 53A4 AF               XOR A
 758+ 53A5 C9               RET
 759+ 53A6              .ERROR:
 760+ 53A6 37               SCF
 761+ 53A7 C9               RET
 762+ 53A8              ; *******************************************************************************************************
 763+ 53A8
 764+ 53A8              ; *******************************************************************************************************
 765+ 53A8              ; function will display currect item and set up expiry time
 766+ 53A8              ; it will also stop the animation if expired
 767+ 53A8              ; sets sprite update flag if any changes in sprite data made
 768+ 53A8              ; input IX=current sprite animation
 769+ 53A8              SETUP_ANIM_STEP:
 770+ 53A8 DD 4E 04         LD C,(IX+4) ; animation definition ID
 771+ 53AB 0C               INC C
 772+ 53AC 3A CD 4F         LD A,(ANIMDEFNUM)
 773+ 53AF B9               CP C
 774+ 53B0 30 05            JR NC,.L2
 775+ 53B2                  ; given animation item is outside of bounds, deactivate animation
 776+ 53B2              .STOPANIM:
 777+ 53B2 DD 36 06 00      LD (IX+6),0
 778+ 53B6 C9               RET
 779+ 53B7              .L2:
 780+ 53B7 0D               DEC C
 781+ 53B8 79               LD A,C
 782+ 53B9 CD 6A 53         CALL INIT_CURRENT_ANIMATION
 783+ 53BC 38 F4            JR C, .STOPANIM
 784+ 53BE FD 7E 00         LD A,(IY) ; type of animation item
 785+ 53C1 B7               OR A
 786+ 53C2 CA F7 53         JP Z,.L4 ; change pattern and/or color
 787+ 53C5              .PAT:
 788+ 53C5                  ; change sprite pattern definition
 789+ 53C5 DD 7E 00         LD A,(IX) ; sprite number
 790+ 53C8 CD 83 4D         CALL GETnthSPRATTR
 791+ 53CB 23          > INC HL ; skip y and x
 791+ 53CC 23          > INC HL
 791+ 53CD 23          > INC HL
 791+ 53CE 23          > INC HL
 792+ 53CF 7E               LD A,(HL); current pattern
 793+ 53D0 26 00            LD H,0
 794+ 53D2 6F               LD L,A
 795+ 53D3 3A E0 F3         LD A,(REG1SAV)
 796+ 53D6 E6 02            AND 2
 797+ 53D8 20 07            JR NZ,.L6
 798+ 53DA                  ; 8x8 sprite
 799+ 53DA CD BA 58         CALL HLx8
 800+ 53DD 06 08            LD B,8
 801+ 53DF 18 05            JR .L5
 802+ 53E1              .L6:
 803+ 53E1 CD B8 58         CALL HLx32
 804+ 53E4 06 20            LD B,32
 805+ 53E6              .L5:
 806+ 53E6 ED 5B 26 F9      LD DE,(PATBAS)
 807+ 53EA 19               ADD HL,DE
 808+ 53EB CD A5 58         CALL SETWRT_LOCAL
 809+ 53EE FD 6E 03         LD L,(IY+3)
 810+ 53F1 FD 66 04         LD H,(IY+4) ; pointer to sprite patter data
 811+ 53F4 C3 B0 58         JP BBYTECOPY
 812+ 53F7              .L4:
 813+ 53F7                  ; change pattern and color in sprite attributes table
 814+ 53F7 DD 7E 00         LD A,(IX) ; sprite number
 815+ 53FA CD 83 4D         CALL GETnthSPRATTR
 816+ 53FD 23          > INC HL ; skip y and x
 816+ 53FE 23          > INC HL
 816+ 53FF 23          > INC HL
 816+ 5400 23          > INC HL
 817+ 5401 FD 7E 03         LD A,(IY+3) ; new pattern
 818+ 5404 77               LD (HL),A
 819+ 5405 23          > INC HL
 819+ 5406 23          > INC HL
 820+ 5407 FD 7E 04         LD A,(IY+4) ; new color
 821+ 540A 77               LD (HL),A
 822+ 540B 2A 7B 4D         LD HL,(SPRATR_UPDATE_FLAG)
 823+ 540E 36 01            LD (HL),1
 824+ 5410 C9               RET
 825+ 5411              ; *******************************************************************************************************
 826+ 5411
# file closed: asm\ANIMATION.asm
 120  5411               ENDIF
 121  5411
 122  5411               IF (RAM_CMDS == 1)
 123  5411               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5411              ; *******************************************************************************************************
   2+ 5411              ; function to handle CALL MEMCPY basic extension
   3+ 5411              ; _MEMCPY ( INT source,
   4+ 5411              ;			INT destination,
   5+ 5411              ;			INT count,
   6+ 5411              ; will put ram in page 0 also, page 1 is already there
   7+ 5411              MEMCPY:
   8+ 5411              	; opening (
   9+ 5411 CD CB 59     	CALL CHKCHAR
  10+ 5414 28           	DB '('
  11+ 5415              	; get source address
  12+ 5415 DD 21 2F 54  	LD IX, FRMQNT
  13+ 5419 CD 59 01     	CALL CALBAS
  14+ 541C D5           	PUSH DE
  15+ 541D              	; comma
  16+ 541D CD CB 59     	CALL CHKCHAR
  17+ 5420 2C           	DB ','
  18+ 5421              	; get destination address
  19+ 5421 DD 21 2F 54  	LD IX, FRMQNT
  20+ 5425 CD 59 01     	CALL CALBAS
  21+ 5428 D5           	PUSH DE
  22+ 5429              	; comma
  23+ 5429 CD CB 59     	CALL CHKCHAR
  24+ 542C 2C           	DB ','
  25+ 542D              	; get length
  26+ 542D DD 21 2F 54  	LD IX, FRMQNT
  27+ 5431 CD 59 01     	CALL CALBAS
  28+ 5434 D5           	PUSH DE
  29+ 5435              	; ending )
  30+ 5435 CD CB 59     	CALL CHKCHAR
  31+ 5438 29           	DB ')'
  32+ 5439
  33+ 5439              	; save position
  34+ 5439 E5           	PUSH HL
  35+ 543A DD E1        	POP IX
  36+ 543C
  37+ 543C C1           	POP BC ; count
  38+ 543D D1           	POP DE ; destination
  39+ 543E E1           	POP HL ; source
  40+ 543F D9           	EXX
  41+ 5440              	; enable page 0
  42+ 5440 FD 21 47 54  	LD IY, .RET
  43+ 5444 C3 7E 59     	JP ENABLE_PAGE0
  44+ 5447              .RET:
  45+ 5447 FB           	EI
  46+ 5448 D9           	EXX
  47+ 5449 ED B0        	LDIR
  48+ 544B D1               POP DE
  49+ 544C C1               POP BC
  50+ 544D CD F5 58         CALL RESTORE_PAGE_INFO
  51+ 5450 DD E5        	PUSH IX
  52+ 5452 E1           	POP HL
  53+ 5453 C9           	RET
  54+ 5454              ; *******************************************************************************************************
  55+ 5454
  56+ 5454              ; *******************************************************************************************************
  57+ 5454              ; function to handle CALL FILRAM basic extension
  58+ 5454              ; FILRAM ( INT start address,
  59+ 5454              ;		   INT count,
  60+ 5454              ;		   BYTE value,
  61+ 5454              ; will put ram in page 0 also, page 1 is already there
  62+ 5454              FILRAM:
  63+ 5454              	; opening (
  64+ 5454 CD CB 59     	CALL CHKCHAR
  65+ 5457 28           	DB '('
  66+ 5458              	; get start address
  67+ 5458 DD 21 2F 54  	LD IX, FRMQNT
  68+ 545C CD 59 01     	CALL CALBAS
  69+ 545F D5           	PUSH DE
  70+ 5460              	; comma
  71+ 5460 CD CB 59     	CALL CHKCHAR
  72+ 5463 2C           	DB ','
  73+ 5464              	; get count
  74+ 5464 DD 21 2F 54  	LD IX, FRMQNT
  75+ 5468 CD 59 01     	CALL CALBAS
  76+ 546B D5           	PUSH DE
  77+ 546C              	; comma
  78+ 546C CD CB 59     	CALL CHKCHAR
  79+ 546F 2C           	DB ','
  80+ 5470              	; get value
  81+ 5470 DD 21 1C 52  	LD IX, GETBYT
  82+ 5474 CD 59 01     	CALL CALBAS
  83+ 5477 F5           	PUSH AF
  84+ 5478              	; ending )
  85+ 5478 CD CB 59     	CALL CHKCHAR
  86+ 547B 29           	DB ')'
  87+ 547C
  88+ 547C              	; save position
  89+ 547C E5           	PUSH HL
  90+ 547D DD E1        	POP IX
  91+ 547F
  92+ 547F D1           	POP DE ; actually AF
  93+ 5480 C1           	POP BC ; count
  94+ 5481 E1           	POP HL ; start address
  95+ 5482 78           	LD A, B
  96+ 5483 B7           	OR A
  97+ 5484 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
  98+ 5486 B1           	OR C
  99+ 5487 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 100+ 5489 79           	LD A, C
 101+ 548A 3D           	DEC A
 102+ 548B 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 103+ 548D              	; one byte to fill
 104+ 548D 72           	LD (HL), D
 105+ 548E 18 12        	JR .EXIT
 106+ 5490              .L1:
 107+ 5490 D9           	EXX
 108+ 5491              	; enable page 0
 109+ 5491 FD 21 98 54  	LD IY, .RET
 110+ 5495 C3 7E 59     	JP ENABLE_PAGE0
 111+ 5498              .RET:
 112+ 5498 FB           	EI
 113+ 5499 D9           	EXX
 114+ 549A CD A6 54     	CALL .FILLVALUE
 115+ 549D D1               POP DE
 116+ 549E C1               POP BC
 117+ 549F CD F5 58         CALL RESTORE_PAGE_INFO
 118+ 54A2              .EXIT:
 119+ 54A2 DD E5        	PUSH IX
 120+ 54A4 E1           	POP HL
 121+ 54A5 C9           	RET
 122+ 54A6
 123+ 54A6              .FILLVALUE:
 124+ 54A6 72               LD (HL), D
 125+ 54A7 54               LD D, H
 126+ 54A8 5D               LD E, L
 127+ 54A9 13               INC DE
 128+ 54AA 0B               DEC BC
 129+ 54AB ED B0            LDIR
 130+ 54AD C9               RET
 131+ 54AE              ; *******************************************************************************************************
 132+ 54AE
# file closed: asm\MEMORY.asm
 124  54AE               ENDIF
 125  54AE
 126  54AE               IF (SOUND_CMDS == 1)
 127  54AE               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 54AE              MUSIC_INIT_STATUS:
   2+ 54AE 00            DB 0
   3+ 54AF              SFX_INIT_STATUS:
   4+ 54AF 00            DB 0
   5+ 54B0              SOUND_ENABLED:
   6+ 54B0 00            DB 0
   7+ 54B1
   8+ 54B1              ; *******************************************************************************************************
   9+ 54B1              ; function to handle CALL SNDPLYINIT basic extension
  10+ 54B1              ; initializes sound player
  11+ 54B1              ; _SNDPLYINIT ( INT music_offset,
  12+ 54B1              ;				INT sfx_offset, can be -1 if no SFX
  13+ 54B1              ; will put ram in page 0 also, page 1 is already there
  14+ 54B1              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 54B1              SNDPLYINIT:
  16+ 54B1              	; opening (
  17+ 54B1 CD CB 59     	CALL CHKCHAR
  18+ 54B4 28           	DB '('
  19+ 54B5              	; get music address
  20+ 54B5 DD 21 2F 54  	LD IX, FRMQNT
  21+ 54B9 CD 59 01     	CALL CALBAS
  22+ 54BC D5           	PUSH DE
  23+ 54BD              	; comma
  24+ 54BD CD CB 59     	CALL CHKCHAR
  25+ 54C0 2C           	DB ','
  26+ 54C1              	; get sfx address
  27+ 54C1 DD 21 2F 54  	LD IX, FRMQNT
  28+ 54C5 CD 59 01     	CALL CALBAS
  29+ 54C8 D5           	PUSH DE
  30+ 54C9              	; ending )
  31+ 54C9 CD CB 59     	CALL CHKCHAR
  32+ 54CC 29           	DB ')'
  33+ 54CD
  34+ 54CD                  ; save position in BASIC text
  35+ 54CD 44           	LD B, H
  36+ 54CE 4D           	LD C, L
  37+ 54CF
  38+ 54CF              	; pop LDIR parameters and store away for later
  39+ 54CF D1           	POP DE ; sfx address
  40+ 54D0 E1           	POP HL ; music address
  41+ 54D1 C5           	PUSH BC ; basic text location
  42+ 54D2 D9           	EXX
  43+ 54D3 FD 21 DA 54  	LD IY, .RET
  44+ 54D7 C3 7E 59     	JP ENABLE_PAGE0
  45+ 54DA              .RET:
  46+ 54DA D9           	EXX
  47+ 54DB
  48+ 54DB D5           	PUSH DE
  49+ 54DC AF           	XOR A
  50+ 54DD              	; HL = music location
  51+ 54DD CD 62 41     	CALL PLY_AKG_INIT
  52+ 54E0 3E 01        	LD A, 1
  53+ 54E2 32 AE 54     	LD (MUSIC_INIT_STATUS), A
  54+ 54E5
  55+ 54E5 E1           	POP HL ; SFX
  56+ 54E6              	; check if SFX address -1
  57+ 54E6 23           	INC HL
  58+ 54E7 7D           	LD A, L
  59+ 54E8 B4           	OR H
  60+ 54E9 28 09        	JR Z,.L1
  61+ 54EB 2B           	DEC HL
  62+ 54EC CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 54EF 3E 01        	LD A, 1
  64+ 54F1 32 AF 54     	LD (SFX_INIT_STATUS), A
  65+ 54F4              .L1:
  66+ 54F4 D1               POP DE
  67+ 54F5 C1               POP BC
  68+ 54F6 CD F5 58         CALL RESTORE_PAGE_INFO
  69+ 54F9
  70+ 54F9 E1           	POP HL
  71+ 54FA C9           	RET
  72+ 54FB              ; *******************************************************************************************************
  73+ 54FB
  74+ 54FB              ; *******************************************************************************************************
  75+ 54FB              ; function to handle CALL SNDPLYON basic extension
  76+ 54FB              ; enables sound player
  77+ 54FB              ; _SNDPLYON
  78+ 54FB              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 54FB              ; if not throws out of data error
  80+ 54FB              SNDPLYON:
  81+ 54FB 3A AE 54     	LD A, (MUSIC_INIT_STATUS)
  82+ 54FE B7           	OR A
  83+ 54FF 20 05        	JR NZ, .L1
  84+ 5501              	; player not initialized, throw error
  85+ 5501 1E 04        	LD E, 04 ; Out of DATA
  86+ 5503 C3 EB 59     	JP THROW_ERROR
  87+ 5506              .L1:
  88+ 5506 32 B0 54     	LD (SOUND_ENABLED), A
  89+ 5509              	; disable key click
  90+ 5509 AF           	XOR A
  91+ 550A 32 DB F3     	LD (CLIKSW), A
  92+ 550D C9           	RET
  93+ 550E              ; *******************************************************************************************************
  94+ 550E
  95+ 550E              ; *******************************************************************************************************
  96+ 550E              ; function to handle CALL SNDPLYOFF basic extension
  97+ 550E              ; disables sound player
  98+ 550E              ; _SNDPLYOFF
  99+ 550E              ; sets SOUND_ENABLED variable to 0
 100+ 550E              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 550E              SNDPLYOFF:
 102+ 550E 3A B0 54     	LD A, (SOUND_ENABLED)
 103+ 5511 B7           	OR A
 104+ 5512 C8           	RET Z ; already stopped
 105+ 5513 AF           	XOR A
 106+ 5514 32 B0 54     	LD (SOUND_ENABLED), A
 107+ 5517 E5           	PUSH HL
 108+ 5518 CD 21 42     	CALL PLY_AKG_STOP
 109+ 551B 3A AF 54     	LD A, (SFX_INIT_STATUS)
 110+ 551E B7           	OR A
 111+ 551F 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 5521 AF           	XOR A
 113+ 5522 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 5525 3E 01        	LD A, 1
 115+ 5527 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 552A 3E 02        	LD A, 2
 117+ 552C CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 552F              .EXIT:
 119+ 552F E1           	POP HL
 120+ 5530 C9           	RET
 121+ 5531              ; *******************************************************************************************************
 122+ 5531
 123+ 5531              ; *******************************************************************************************************
 124+ 5531              ; function to handle CALL SNDSFX basic extension
 125+ 5531              ; plays a sound effect
 126+ 5531              ; _SNDSFX ( BYTE sfx_number, >0
 127+ 5531              ;			BYTE channel, = 0,1 or 2
 128+ 5531              ;			BYTE inverted_volume = 0-16, 0 being full volume
 129+ 5531              ; will put ram in page 0 also, page 1 is already there
 130+ 5531              ; if sound off throws illegal function call
 131+ 5531              ; if sfx not initialized, throws out of data
 132+ 5531              SNDSFX:
 133+ 5531              	; opening (
 134+ 5531 CD CB 59     	CALL CHKCHAR
 135+ 5534 28           	DB '('
 136+ 5535              	; get sfx_number
 137+ 5535 DD 21 1C 52  	LD IX, GETBYT
 138+ 5539 CD 59 01     	CALL CALBAS
 139+ 553C D5           	PUSH DE
 140+ 553D              	; comma
 141+ 553D CD CB 59     	CALL CHKCHAR
 142+ 5540 2C           	DB ','
 143+ 5541              	; get sfx address
 144+ 5541 DD 21 1C 52  	LD IX, GETBYT
 145+ 5545 CD 59 01     	CALL CALBAS
 146+ 5548 D5           	PUSH DE
 147+ 5549              	; comma
 148+ 5549 CD CB 59     	CALL CHKCHAR
 149+ 554C 2C           	DB ','
 150+ 554D              	; get inverted volume
 151+ 554D DD 21 1C 52  	LD IX, GETBYT
 152+ 5551 CD 59 01     	CALL CALBAS
 153+ 5554 D5           	PUSH DE
 154+ 5555              	; ending )
 155+ 5555 CD CB 59     	CALL CHKCHAR
 156+ 5558 29           	DB ')'
 157+ 5559
 158+ 5559 3A B0 54     	LD A, (SOUND_ENABLED)
 159+ 555C B7           	OR A
 160+ 555D 20 05        	JR NZ, .L1
 161+ 555F              	; sound disabled, throw illegal function call
 162+ 555F 1E 05        	LD E, 5
 163+ 5561 C3 EB 59     	JP THROW_ERROR
 164+ 5564              .L1:
 165+ 5564 3A AF 54     	LD A, (SFX_INIT_STATUS)
 166+ 5567 B7           	OR A
 167+ 5568 20 05        	JR NZ, .L2
 168+ 556A              	; sfx data not initialized, throw out of data
 169+ 556A 1E 04        	LD E, 4
 170+ 556C C3 EB 59     	JP THROW_ERROR
 171+ 556F              .L2:
 172+ 556F              	; pop  parameters and store away for later
 173+ 556F D1           	POP DE ; inverted volume
 174+ 5570 43           	LD B, E
 175+ 5571 D1           	POP DE ; channel
 176+ 5572 4B           	LD C, E
 177+ 5573 D1           	POP DE
 178+ 5574 7B           	LD A, E
 179+ 5575 08           	EX AF, AF'
 180+ 5576 E5           	PUSH HL ; basic text location
 181+ 5577 D9           	EXX
 182+ 5578 FD 21 7F 55  	LD IY, .RET
 183+ 557C C3 7E 59     	JP ENABLE_PAGE0
 184+ 557F              .RET:
 185+ 557F D9           	EXX
 186+ 5580 08           	EX AF, AF'
 187+ 5581 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 188+ 5584
 189+ 5584 D1               POP DE
 190+ 5585 C1               POP BC
 191+ 5586 CD F5 58         CALL RESTORE_PAGE_INFO
 192+ 5589
 193+ 5589 E1           	POP HL
 194+ 558A C9           	RET
 195+ 558B              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
 128  558B               ENDIF
 129  558B
 130  558B               IF (VRAM_CMDS == 1)
 131  558B               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 558B              ; *******************************************************************************************************
   2+ 558B              ; function to handle CALL FILVRM basic extension
   3+ 558B              ; FILVRM ( INT offset,
   4+ 558B              ;		   INT count,
   5+ 558B              ;		   BYTE value,
   6+ 558B              ;		   BYTE wait_vsync) >0 = true
   7+ 558B              ; wait_vsync will issue HALT before copying
   8+ 558B              FILVRM:
   9+ 558B              	; opening (
  10+ 558B CD CB 59     	CALL CHKCHAR
  11+ 558E 28           	DB '('
  12+ 558F              	; get offset address
  13+ 558F DD 21 2F 54  	LD IX, FRMQNT
  14+ 5593 CD 59 01     	CALL CALBAS
  15+ 5596 D5           	PUSH DE
  16+ 5597              	; comma
  17+ 5597 CD CB 59     	CALL CHKCHAR
  18+ 559A 2C           	DB ','
  19+ 559B              	; get count
  20+ 559B DD 21 2F 54  	LD IX, FRMQNT
  21+ 559F CD 59 01     	CALL CALBAS
  22+ 55A2 D5           	PUSH DE
  23+ 55A3              	; comma
  24+ 55A3 CD CB 59     	CALL CHKCHAR
  25+ 55A6 2C           	DB ','
  26+ 55A7              	; get value
  27+ 55A7 DD 21 1C 52  	LD IX, GETBYT
  28+ 55AB CD 59 01     	CALL CALBAS
  29+ 55AE F5           	PUSH AF
  30+ 55AF              	; comma
  31+ 55AF CD CB 59     	CALL CHKCHAR
  32+ 55B2 2C           	DB ','
  33+ 55B3              	; get vsync wait
  34+ 55B3 DD 21 1C 52  	LD IX, GETBYT
  35+ 55B7 CD 59 01     	CALL CALBAS
  36+ 55BA F5           	PUSH AF
  37+ 55BB              	; ending )
  38+ 55BB CD CB 59     	CALL CHKCHAR
  39+ 55BE 29           	DB ')'
  40+ 55BF
  41+ 55BF FB               EI
  42+ 55C0              	; save position
  43+ 55C0 E5           	PUSH HL
  44+ 55C1 DD E1        	POP IX
  45+ 55C3
  46+ 55C3              	; syntax ok
  47+ 55C3              	; wait for vsync if needed
  48+ 55C3 F1           	POP AF
  49+ 55C4 B7           	OR A
  50+ 55C5 28 01        	JR Z, .L1
  51+ 55C7 76           	HALT
  52+ 55C8
  53+ 55C8              .L1:
  54+ 55C8 F1               POP AF ; value
  55+ 55C9 C1               POP BC ; count
  56+ 55CA E1               POP HL ; offset
  57+ 55CB 3E 01        	LD A,1
  58+ 55CD 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
  59+ 55D0 CD 56 00         CALL BIOS_FILVRM
  60+ 55D3 AF           	XOR A
  61+ 55D4 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 55D7
  63+ 55D7              .L3:
  64+ 55D7 DD E5        	PUSH IX
  65+ 55D9 E1           	POP HL
  66+ 55DA C9           	RET
  67+ 55DB              ; *******************************************************************************************************
  68+ 55DB
  69+ 55DB              ; *******************************************************************************************************
  70+ 55DB              ; function to handle CALL MEMVRM basic extension
  71+ 55DB              ; copies from RAM to VRAM
  72+ 55DB              ; _MEMVRM ( INT source,
  73+ 55DB              ;			INT destination,
  74+ 55DB              ;			INT count,
  75+ 55DB              ;			BYTE wait_vsync) >0 = true
  76+ 55DB              ; will put ram in page 0 also, page 1 is already there
  77+ 55DB              ; wait_vsync will issue HALT before copying
  78+ 55DB              MEMVRM:
  79+ 55DB              	; opening (
  80+ 55DB CD CB 59     	CALL CHKCHAR
  81+ 55DE 28           	DB '('
  82+ 55DF              	; get source address
  83+ 55DF DD 21 2F 54  	LD IX, FRMQNT
  84+ 55E3 CD 59 01     	CALL CALBAS
  85+ 55E6 D5           	PUSH DE
  86+ 55E7              	; comma
  87+ 55E7 CD CB 59     	CALL CHKCHAR
  88+ 55EA 2C           	DB ','
  89+ 55EB              	; get destination address
  90+ 55EB DD 21 2F 54  	LD IX, FRMQNT
  91+ 55EF CD 59 01     	CALL CALBAS
  92+ 55F2 D5           	PUSH DE
  93+ 55F3              	; comma
  94+ 55F3 CD CB 59     	CALL CHKCHAR
  95+ 55F6 2C           	DB ','
  96+ 55F7              	; get length
  97+ 55F7 DD 21 2F 54  	LD IX, FRMQNT
  98+ 55FB CD 59 01     	CALL CALBAS
  99+ 55FE D5           	PUSH DE
 100+ 55FF              	; comma
 101+ 55FF CD CB 59     	CALL CHKCHAR
 102+ 5602 2C           	DB ','
 103+ 5603              	; get vsync wait
 104+ 5603 DD 21 1C 52  	LD IX, GETBYT
 105+ 5607 CD 59 01     	CALL CALBAS
 106+ 560A F5           	PUSH AF
 107+ 560B              	; ending )
 108+ 560B CD CB 59     	CALL CHKCHAR
 109+ 560E 29           	DB ')'
 110+ 560F
 111+ 560F                  ; save position in BASIC text
 112+ 560F E5           	PUSH HL
 113+ 5610 DD E1        	POP IX
 114+ 5612
 115+ 5612 F1           	POP AF ; wait vsync
 116+ 5613 B7           	OR A
 117+ 5614 28 03        	JR Z, .L1
 118+ 5616 FB               EI
 119+ 5617 76           	HALT
 120+ 5618 F3           	DI
 121+ 5619              .L1:
 122+ 5619              	; pop LDIR parameters and store away for later
 123+ 5619 C1           	POP BC ; count
 124+ 561A D1           	POP DE ; vram destination
 125+ 561B E1           	POP HL ; ram source
 126+ 561C D9           	EXX
 127+ 561D FD 21 24 56   	LD IY, .RET
 128+ 5621 C3 7E 59     	JP ENABLE_PAGE0
 129+ 5624              .RET:
 130+ 5624 FB           	EI
 131+ 5625 D9           	EXX
 132+ 5626 3E 01        	LD A,1
 133+ 5628 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
 134+ 562B CD 3B 56     	CALL .LDIRVM
 135+ 562E AF           	XOR A
 136+ 562F 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
 137+ 5632 D1               POP DE
 138+ 5633 C1               POP BC
 139+ 5634 CD F5 58         CALL RESTORE_PAGE_INFO
 140+ 5637 DD E5        	PUSH IX
 141+ 5639 E1           	POP HL
 142+ 563A C9           	RET
 143+ 563B
 144+ 563B              .LDIRVM:
 145+ 563B EB           	EX DE, HL
 146+ 563C F3           	DI
 147+ 563D CD A5 58     	CALL SETWRT_LOCAL
 148+ 5640 FB           	EI
 149+ 5641 EB           	EX DE, HL
 150+ 5642 78           	LD A, B
 151+ 5643 B7           	OR A
 152+ 5644 28 0D        	JR Z, .L3
 153+ 5646 C5           	PUSH BC
 154+ 5647 0E 98        	LD C, #98
 155+ 5649              .L2:
 156+ 5649 50           	LD D, B
 157+ 564A 06 00        	LD B, 0
 158+ 564C CD B2 58     	CALL BBYTECOPY_NO_C
 159+ 564F 42           	LD B, D
 160+ 5650 10 F7        	DJNZ .L2
 161+ 5652 C1           	POP BC
 162+ 5653              .L3:
 163+ 5653 79           	LD A, C
 164+ 5654 B7           	OR A
 165+ 5655 C8           	RET Z
 166+ 5656 41           	LD B, C
 167+ 5657 C3 B0 58     	JP BBYTECOPY
 168+ 565A              ; *******************************************************************************************************
 169+ 565A
 170+ 565A              ; *******************************************************************************************************
 171+ 565A              ; function to handle CALL VRMMEM basic extension
 172+ 565A              ; copies from RAM to VRAM
 173+ 565A              ; _VRMMEM ( INT source,
 174+ 565A              ;			INT destination,
 175+ 565A              ;			INT count
 176+ 565A              ; will put ram in page 0 also, page 1 is already there
 177+ 565A              VRMMEM:
 178+ 565A              	; opening (
 179+ 565A CD CB 59     	CALL CHKCHAR
 180+ 565D 28           	DB '('
 181+ 565E              	; get source address
 182+ 565E DD 21 2F 54  	LD IX, FRMQNT
 183+ 5662 CD 59 01     	CALL CALBAS
 184+ 5665 D5           	PUSH DE
 185+ 5666              	; comma
 186+ 5666 CD CB 59     	CALL CHKCHAR
 187+ 5669 2C           	DB ','
 188+ 566A              	; get destination address
 189+ 566A DD 21 2F 54  	LD IX, FRMQNT
 190+ 566E CD 59 01     	CALL CALBAS
 191+ 5671 D5           	PUSH DE
 192+ 5672              	; comma
 193+ 5672 CD CB 59     	CALL CHKCHAR
 194+ 5675 2C           	DB ','
 195+ 5676              	; get length
 196+ 5676 DD 21 2F 54  	LD IX, FRMQNT
 197+ 567A CD 59 01     	CALL CALBAS
 198+ 567D D5           	PUSH DE
 199+ 567E              	; ending )
 200+ 567E CD CB 59     	CALL CHKCHAR
 201+ 5681 29           	DB ')'
 202+ 5682
 203+ 5682                  ; save position in BASIC text
 204+ 5682 E5           	PUSH HL
 205+ 5683 DD E1        	POP IX
 206+ 5685
 207+ 5685 C1           	POP BC ; count
 208+ 5686 D1           	POP DE ; destination
 209+ 5687 E1           	POP HL ; source
 210+ 5688 D9           	EXX
 211+ 5689 FD 21 90 56  	LD IY, .RET
 212+ 568D C3 7E 59     	JP ENABLE_PAGE0
 213+ 5690              .RET:
 214+ 5690 FB           	EI
 215+ 5691 D9           	EXX
 216+ 5692 3E 01        	LD A,1
 217+ 5694 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
 218+ 5697 CD A7 56     	CALL .LDIRMV
 219+ 569A AF           	XOR A
 220+ 569B 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
 221+ 569E D1               POP DE
 222+ 569F C1               POP BC
 223+ 56A0 CD F5 58         CALL RESTORE_PAGE_INFO
 224+ 56A3 DD E5        	PUSH IX
 225+ 56A5 E1           	POP HL
 226+ 56A6 C9           	RET
 227+ 56A7
 228+ 56A7              .LDIRMV:
 229+ 56A7              	; set VRAM address *exactly* as in ROM, otherwise corruption
 230+ 56A7 7D           	LD	A, L
 231+ 56A8 F3           	DI
 232+ 56A9 D3 99        	OUT	(099H), A
 233+ 56AB 7C           	LD	A, H
 234+ 56AC E6 3F        	AND	03FH
 235+ 56AE D3 99        	OUT	(099H), A
 236+ 56B0 FB           	EI
 237+ 56B1              	;EX (SP), HL
 238+ 56B1              	;EX (SP), HL
 239+ 56B1              	;NOP
 240+ 56B1              	;NOP
 241+ 56B1              .L4:
 242+ 56B1 DB 98            IN A, (#98)
 243+ 56B3 12           	LD (DE), A
 244+ 56B4 13               INC DE
 245+ 56B5 0B               DEC BC
 246+ 56B6 79               LD A, C
 247+ 56B7 B0               OR B
 248+ 56B8 20 F7            JR NZ, .L4
 249+ 56BA C9               RET
 250+ 56BB              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 132  56BB               ENDIF
 133  56BB
 134  56BB               IF (GENCAL_CMD == 1)
 135  56BB               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56BB              ; *******************************************************************************************************
   2+ 56BB              ; function to handle CALL GENCAL basic extension
   3+ 56BB              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 56BB              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 56BB              ; output values of registers will also be stored at reg_list_ptr
   6+ 56BB              GENCAL_VAR_SP:
   7+ 56BB 00 00            DW 0
   8+ 56BD              GENCAL_VAR_SP2:
   9+ 56BD 00 00            DW 0
  10+ 56BF              GENCAL:
  11+ 56BF              	; opening (
  12+ 56BF CD CB 59     	CALL CHKCHAR
  13+ 56C2 28           	DB '('
  14+ 56C3              	; get function address
  15+ 56C3 DD 21 2F 54  	LD IX, FRMQNT
  16+ 56C7 CD 59 01     	CALL CALBAS
  17+ 56CA D5           	PUSH DE
  18+ 56CB              	; comma
  19+ 56CB CD CB 59     	CALL CHKCHAR
  20+ 56CE 2C           	DB ','
  21+ 56CF              	; get pointer to register list
  22+ 56CF 3E 02            LD A,2
  23+ 56D1 06 01            LD B,1
  24+ 56D3 11 00 05         LD DE,#0500
  25+ 56D6 CD F2 59         CALL GET_BASIC_ARRAY_DATA_POINTER
  26+ 56D9 C5           	PUSH BC
  27+ 56DA              	; ending )
  28+ 56DA CD CB 59     	CALL CHKCHAR
  29+ 56DD 29           	DB ')'
  30+ 56DE
  31+ 56DE              	; save BASIC token position
  32+ 56DE E5           	PUSH HL
  33+ 56DF D9               EXX
  34+ 56E0 E1           	POP HL ; HL'=next basic token
  35+ 56E1 D9               EXX
  36+ 56E2
  37+ 56E2 E1               POP HL ; get pointer to register values
  38+ 56E3 F3           	DI
  39+ 56E4 ED 73 BB 56      LD (GENCAL_VAR_SP), SP
  40+ 56E8 F9               LD SP, HL
  41+ 56E9 F1               POP AF
  42+ 56EA C1               POP BC
  43+ 56EB D1               POP DE
  44+ 56EC E1               POP HL
  45+ 56ED DD E1            POP IX
  46+ 56EF FD E1            POP IY
  47+ 56F1 D9               EXX
  48+ 56F2 ED 73 BD 56      LD (GENCAL_VAR_SP2), SP
  49+ 56F6 ED 7B BB 56      LD SP, (GENCAL_VAR_SP)
  50+ 56FA FB               EI
  51+ 56FB D1               POP DE ; get function to call
  52+ 56FC E5               PUSH HL
  53+ 56FD CD 18 57         CALL .EXXDECALL
  54+ 5700 F3               DI
  55+ 5701 ED 73 BB 56      LD (GENCAL_VAR_SP), SP
  56+ 5705 ED 7B BD 56      LD SP, (GENCAL_VAR_SP2)
  57+ 5709 FD E5            PUSH IY
  58+ 570B DD E5            PUSH IX
  59+ 570D E5               PUSH HL
  60+ 570E D5               PUSH DE
  61+ 570F C5               PUSH BC
  62+ 5710 F5               PUSH AF
  63+ 5711 ED 7B BB 56      LD SP, (GENCAL_VAR_SP)
  64+ 5715 FB               EI
  65+ 5716 E1               POP HL
  66+ 5717 C9           	RET
  67+ 5718
  68+ 5718              .EXXDECALL:
  69+ 5718 D5               PUSH DE
  70+ 5719 D9               EXX
  71+ 571A C9               RET
  72+ 571B              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 136  571B               ENDIF
 137  571B
 138  571B              ; temp variables for BLIT, TILE functions
 139  571B               IF (BLIT_CMDS + TILE_CMDS > 0)
 140  571B              BLIT_TMP:
 141  571B              TILETMP1:
 142  571B              BLIT_TMP1:
 143  571B 00 00         DW 0
 144  571D              TILETMP2:
 145  571D              BLIT_TMP2:
 146  571D 00 00         DW 0
 147  571F                IFDEF CMDS_WITH_PARAMETERS
 148  571F              BLIT_STRUCT:
 149  571F 00 00 00...   DS 17
 150  5723                ENDIF
 151  5723               ENDIF
 152  5730
 153  5730               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS > 0)
 154  5730              VRAM_UPDATE_IN_PROGRESS:
 155  5730 00            DB 0
 156  5731               ENDIF
 157  5731
 158  5731              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 159  5731              ; per starting letter, if no commands with this letter, NULL value
 160  5731              CMDS:
 161  5731               IF (ANIM_CMDS == 1)
 162  5731 5A 58        	DW CMDS_A ;
 163  5733               ELSE
 164  5733 ~                DW 0 ; A
 165  5733               ENDIF
 166  5733               IF (BLIT_CMDS + BOX_CMDS > 0)
 167  5733 25 58            DW CMDS_B ; B
 168  5735               ELSE
 169  5735 ~            	DW 0
 170  5735               ENDIF
 171  5735 00 00            DW 0 ; C
 172  5737 00 00            DW 0 ; D
 173  5739 00 00            DW 0 ; E
 174  573B               IF (VRAM_CMDS + RAM_CMDS > 0)
 175  573B A3 57            DW CMDS_F; F
 176  573D               ELSE
 177  573D ~            	DW 0
 178  573D               ENDIF
 179  573D               IF (GENCAL_CMD > 0)
 180  573D B6 57            DW CMDS_G; G
 181  573F               ELSE
 182  573F ~            	DW 0
 183  573F               ENDIF
 184  573F 00 00            DW 0 ; H
 185  5741 00 00            DW 0 ; I
 186  5743 00 00            DW 0 ; J
 187  5745 00 00            DW 0 ; K
 188  5747 00 00            DW 0 ; L
 189  5749               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 190  5749 65 57            DW CMDS_M ; M
 191  574B               ELSE
 192  574B ~            	DW 0
 193  574B               ENDIF
 194  574B 00 00            DW 0 ; N
 195  574D 00 00            DW 0 ; O
 196  574F 00 00            DW 0 ; P
 197  5751 00 00            DW 0 ; Q
 198  5753 00 00            DW 0 ; R
 199  5755               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 200  5755 CA 57            DW CMDS_S ; S
 201  5757               ELSE
 202  5757 ~            	DW 0
 203  5757               ENDIF
 204  5757               IF (TILE_CMDS > 0)
 205  5757 45 58            DW CMDS_T ; T
 206  5759               ELSE
 207  5759 ~            	DW 0
 208  5759               ENDIF
 209  5759 00 00            DW 0 ; U
 210  575B               IF (VRAM_CMDS > 0)
 211  575B C0 57            DW CMDS_V ; V
 212  575D               ELSE
 213  575D ~            	DW 0
 214  575D               ENDIF
 215  575D 00 00            DW 0 ; W
 216  575F 00 00            DW 0 ; X
 217  5761 00 00            DW 0 ; Y
 218  5763 00 00            DW 0 ; Z
 219  5765
 220  5765              CMDS_M:
 221  5765               IF (VRAM_CMDS == 1)
 222  5765 4D 45 4D 56      DB "MEMVRM", 0
 222  5769 52 4D 00
 223  576C DB 55            DW MEMVRM
 224  576E               ENDIF
 225  576E               IF (RAM_CMDS == 1)
 226  576E 4D 45 4D 43  	DB "MEMCPY", 0
 226  5772 50 59 00
 227  5775 11 54        	DW MEMCPY
 228  5777               ENDIF
 229  5777               IF (ANIM_CMDS == 1)
 230  5777 4D 41 58 41  	DB "MAXANIMITEMS",0
 230  577B 4E 49 4D 49
 230  577F 54 45 4D 53
 230  5783 00
 231  5784 FD 4F        	DW MAXANIMITEMS
 232  5786 4D 41 58 41  	DB "MAXANIMDEFS",0
 232  578A 4E 49 4D 44
 232  578E 45 46 53 00
 233  5792 72 51        	DW MAXANIMDEFS
 234  5794 4D 41 58 41  	DB "MAXANIMSPRS",0
 234  5798 4E 49 4D 53
 234  579C 50 52 53 00
 235  57A0 0A 52        	DW MAXANIMSPRS
 236  57A2               ENDIF
 237  57A2               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 238  57A2 00           	DB 0
 239  57A3               ENDIF
 240  57A3              CMDS_F:
 241  57A3               IF (VRAM_CMDS == 1)
 242  57A3 46 49 4C 56      DB "FILVRM", 0
 242  57A7 52 4D 00
 243  57AA 8B 55            DW FILVRM
 244  57AC               ENDIF
 245  57AC               IF (RAM_CMDS == 1)
 246  57AC 46 49 4C 52      DB "FILRAM", 0
 246  57B0 41 4D 00
 247  57B3 54 54            DW FILRAM
 248  57B5               ENDIF
 249  57B5               IF (VRAM_CMDS + RAM_CMDS > 0)
 250  57B5 00               DB 0
 251  57B6               ENDIF
 252  57B6              CMDS_G:
 253  57B6               IF (GENCAL_CMD == 1)
 254  57B6 47 45 4E 43      DB "GENCAL", 0
 254  57BA 41 4C 00
 255  57BD BF 56            DW GENCAL
 256  57BF               ENDIF
 257  57BF               IF (GENCAL_CMD > 0)
 258  57BF 00           	DB	0
 259  57C0               ENDIF
 260  57C0              CMDS_V:
 261  57C0               IF (VRAM_CMDS == 1)
 262  57C0 56 52 4D 4D  	DB "VRMMEM", 0
 262  57C4 45 4D 00
 263  57C7 5A 56        	DW VRMMEM
 264  57C9               ENDIF
 265  57C9               IF (VRAM_CMDS > 0)
 266  57C9 00           	DB 0
 267  57CA               ENDIF
 268  57CA              CMDS_S:
 269  57CA               IF (SPRITE_CMDS == 1)
 270  57CA 53 50 52 53  	DB "SPRSET", 0
 270  57CE 45 54 00
 271  57D1 98 4E        	DW SPRSET
 272  57D3 53 50 52 47  	DB "SPRGRPMOV", 0
 272  57D7 52 50 4D 4F
 272  57DB 56 00
 273  57DD 49 4F        	DW SPRGRPMOV
 274  57DF               ENDIF
 275  57DF               IF (SOUND_CMDS == 1)
 276  57DF 53 4E 44 53  	DB "SNDSFX", 0
 276  57E3 46 58 00
 277  57E6 31 55        	DW SNDSFX
 278  57E8 53 4E 44 50  	DB "SNDPLYON", 0
 278  57EC 4C 59 4F 4E
 278  57F0 00
 279  57F1 FB 54        	DW SNDPLYON
 280  57F3 53 4E 44 50  	DB "SNDPLYOFF", 0
 280  57F7 4C 59 4F 46
 280  57FB 46 00
 281  57FD 0E 55        	DW SNDPLYOFF
 282  57FF 53 4E 44 50  	DB "SNDPLYINI", 0
 282  5803 4C 59 49 4E
 282  5807 49 00
 283  5809 B1 54        	DW SNDPLYINIT
 284  580B               ENDIF
 285  580B               IF (SPRITE_CMDS == 1)
 286  580B 53 50 52 45  	DB "SPRENABLE", 0
 286  580F 4E 41 42 4C
 286  5813 45 00
 287  5815 43 4E        	DW SPRENABLE
 288  5817 53 50 52 44  	DB "SPRDISABLE", 0
 288  581B 49 53 41 42
 288  581F 4C 45 00
 289  5822 93 4E        	DW SPRDISABLE
 290  5824               ENDIF
 291  5824               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 292  5824 00           	DB 0
 293  5825               ENDIF
 294  5825              CMDS_B:
 295  5825               IF (BLIT_CMDS == 1)
 296  5825 42 4C 49 54  	DB "BLIT", 0
 296  5829 00
 297  582A 9F 5B        	DW BLIT
 298  582C               ENDIF
 299  582C               IF (BOX_CMDS == 1)
 300  582C 42 4F 58 4D  	DB "BOXMEMCPY", 0
 300  5830 45 4D 43 50
 300  5834 59 00
 301  5836 D7 5E        	DW BOXMEMCPY
 302  5838 42 4F 58 4D  	DB "BOXMEMVRM", 0
 302  583C 45 4D 56 52
 302  5840 4D 00
 303  5842 0B 5F        	DW BOXMEMVRM
 304  5844               ENDIF
 305  5844               IF (BLIT_CMDS + BOX_CMDS > 0)
 306  5844 00           	DB 0
 307  5845               ENDIF
 308  5845              CMDS_T:
 309  5845               IF (TILE_CMDS == 1)
 310  5845 54 49 4C 45  	DB "TILERAM", 0
 310  5849 52 41 4D 00
 311  584D E3 5C        	DW TILERAM
 312  584F 54 49 4C 45  	DB "TILEVRM", 0
 312  5853 56 52 4D 00
 313  5857 E6 5D        	DW TILEVRM
 314  5859               ENDIF
 315  5859               IF (TILE_CMDS > 0)
 316  5859 00           	DB 0
 317  585A               ENDIF
 318  585A              CMDS_A:
 319  585A               IF (ANIM_CMDS == 1)
 320  585A 41 4E 49 4D  	DB "ANIMSTART",0
 320  585E 53 54 41 52
 320  5862 54 00
 321  5864 C8 52        	DW ANIMSTART
 322  5866 41 4E 49 4D  	DB "ANIMSTOP",0
 322  586A 53 54 4F 50
 322  586E 00
 323  586F CC 52        	DW ANIMSTOP
 324  5871 41 4E 49 4D  	DB "ANIMITEMPAT",0
 324  5875 49 54 45 4D
 324  5879 50 41 54 00
 325  587D BD 50        	DW ANIMITEMPAT
 326  587F 41 4E 49 4D  	DB "ANIMITEMPTR",0
 326  5883 49 54 45 4D
 326  5887 50 54 52 00
 327  588B 1E 51        	DW ANIMITEMPTR_CMD
 328  588D 41 4E 49 4D  	DB "ANIMDEF",0
 328  5891 44 45 46 00
 329  5895 B4 51        	DW ANIMDEF
 330  5897 41 4E 49 4D  	DB "ANIMSPRITE",0
 330  589B 53 50 52 49
 330  589F 54 45 00
 331  58A2 60 52        	DW ANIMSPRITE
 332  58A4 00           	DB 0
 333  58A5               ENDIF
 334  58A5
 335  58A5               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 336  58A5              ; ****************************************************************************************************
 337  58A5              ; function sets VRAM address
 338  58A5              ; input HL=address
 339  58A5              ; modifies AF
 340  58A5              SETWRT_LOCAL:
 341  58A5 7D           	LD	A, L
 342  58A6 D3 99        	OUT	(099H), A
 343  58A8 7C           	LD	A, H
 344  58A9 E6 3F        	AND	03FH
 345  58AB F6 40        	OR	040H
 346  58AD D3 99        	OUT	(099H), A
 347  58AF C9           	RET
 348  58B0              ; ****************************************************************************************************
 349  58B0               ENDIF
 350  58B0
 351  58B0               IF (VRAM_CMDS + TILE_CMDS > 0)
 352  58B0              ; ****************************************************************************************************
 353  58B0              ; function copies data from RAM to VRAM
 354  58B0              ; input HL=address in RAM
 355  58B0              ; input B=count
 356  58B0              ; modifies AF, BC, HL
 357  58B0              BBYTECOPY:
 358  58B0 0E 98        	LD C,#98
 359  58B2              BBYTECOPY_NO_C:
 360  58B2 ED A3        	OUTI
 361  58B4 C2 B2 58     	JP	NZ, BBYTECOPY_NO_C
 362  58B7 C9           	RET
 363  58B8              ; ****************************************************************************************************
 364  58B8               ENDIF
 365  58B8
 366  58B8              ; ****************************************************************************************************
 367  58B8              ; function multiplies HL by 32
 368  58B8              HLx32:
 369  58B8 29           	ADD HL,HL
 370  58B9              ; ****************************************************************************************************
 371  58B9              ; function multiplies HL by 16
 372  58B9              HLx16:
 373  58B9 29           	ADD HL,HL
 374  58BA              ; ****************************************************************************************************
 375  58BA              ; function multiplies HL by 8
 376  58BA              HLx8:
 377  58BA 29          > ADD HL, HL
 377  58BB 29          > ADD HL, HL
 377  58BC 29          > ADD HL, HL
 378  58BD C9           	RET
 379  58BE              ; ****************************************************************************************************
 380  58BE
 381  58BE              ; ****************************************************************************************************
 382  58BE              ; function gets slot and subslot data for specific page
 383  58BE              ; input A=page (0, 1 or 2)
 384  58BE              ; output B = 0A8H register value
 385  58BE              ; output D = 0 is no subslots, 1 if yes
 386  58BE              ; output C = 0A8H value when page 3 slot equals to requested page slot
 387  58BE              ; output E = subslot value if present
 388  58BE              ; modifies AF, BC, DE, HL
 389  58BE              GET_PAGE_INFO:
 390  58BE 6F               LD L, A
 391  58BF C6 C1            ADD A, low (EXPTBL)
 392  58C1 32 CB 58         LD (GET_PAGE_INFO_L1+1), A
 393  58C4 DB A8            IN A, (0A8H)
 394  58C6 47               LD B, A
 395  58C7 E6 3F            AND 03FH
 396  58C9 4F               LD C, A
 397  58CA              GET_PAGE_INFO_L1:
 398  58CA 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 399  58CD E6 80            AND 080H
 400  58CF 28 1B            JR Z, GET_PAGE_INFO_L2
 401  58D1                  ; expanded
 402  58D1 2D               DEC L
 403  58D2 FA F1 58         JP M, GET_PAGE_INFO_L3
 404  58D5 2D               DEC L
 405  58D6 FA EF 58         JP M, GET_PAGE_INFO_L4
 406  58D9                  ; page 2
 407  58D9 07               RLCA
 408  58DA 07               RLCA
 409  58DB              GET_PAGE_INFO_L5:
 410  58DB E6 C0            AND 0C0H
 411  58DD B1               OR C
 412  58DE D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 413  58E0 4F               LD C, A
 414  58E1 3A FF FF         LD A, (0FFFFH)
 415  58E4 2F               CPL
 416  58E5 5F               LD E, A
 417  58E6 16 01            LD D, 1
 418  58E8 78               LD A, B ; return stack
 419  58E9 D3 A8            OUT (0A8H), A
 420  58EB C9               RET
 421  58EC              GET_PAGE_INFO_L2:
 422  58EC                  ; not expanded
 423  58EC 16 00            LD D, 0
 424  58EE C9               RET
 425  58EF              GET_PAGE_INFO_L4:
 426  58EF                  ; page 1
 427  58EF 0F               RRCA
 428  58F0 0F               RRCA
 429  58F1              GET_PAGE_INFO_L3:
 430  58F1                  ; page 0
 431  58F1 0F               RRCA
 432  58F2 0F               RRCA
 433  58F3 18 E6            JR GET_PAGE_INFO_L5
 434  58F5              ; ****************************************************************************************************
 435  58F5
 436  58F5              ; ****************************************************************************************************
 437  58F5              ; function returns original slot and subslot info
 438  58F5              ; input B = 0A8H register value
 439  58F5              ; input D = 0 is no subslots, 1 if yes
 440  58F5              ; input C = 0A8H value when page 3 slot equals to requested page slot
 441  58F5              ; input E = subslot value if present
 442  58F5              ; modifies AF, disables interrupts
 443  58F5              RESTORE_PAGE_INFO:
 444  58F5 7A               LD A, D
 445  58F6 B7               OR A
 446  58F7 28 08            JR Z, RESTORE_PAGE_INFO_L1
 447  58F9 79               LD A, C
 448  58FA F3           	DI
 449  58FB D3 A8            OUT (0A8H), A
 450  58FD 7B               LD A, E
 451  58FE 32 FF FF         LD (0FFFFH), A
 452  5901              RESTORE_PAGE_INFO_L1:
 453  5901 78               LD A, B
 454  5902 D3 A8            OUT (0A8H), A
 455  5904 C9               RET
 456  5905              ; ****************************************************************************************************
 457  5905
 458  5905              ; *******************************************************************************************************
 459  5905              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 460  5905              ; INPUT:  A = SLOT ID: EXXXSSPP
 461  5905              ; E = EXPANDED FLAG
 462  5905              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 463  5905              ; PP = PRIMARY SLOT NUMBER
 464  5905              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 465  5905              ; CHANGES: AF, BC, DE
 466  5905
 467  5905              LOCAL_ENASLT:
 468  5905 CD 25 59         CALL L0353
 469  5908 FA 12 59         JP M, L0340
 470  590B DB A8            IN A, (0A8H)
 471  590D A1               AND C
 472  590E B0               OR B
 473  590F D3 A8            OUT (0A8H), A
 474  5911 C9               RET
 475  5912              L0340:
 476  5912 E5               PUSH HL
 477  5913 CD 4A 59         CALL L0378
 478  5916 4F               LD C, A
 479  5917 06 00            LD B, 0
 480  5919 7D               LD A, L
 481  591A A4               AND H
 482  591B B2               OR D
 483  591C 21 C5 FC         LD HL, 0FCC5H
 484  591F 09               ADD HL, BC
 485  5920 77               LD (HL), A
 486  5921 E1               POP HL
 487  5922 79               LD A, C
 488  5923 18 E0            JR LOCAL_ENASLT
 489  5925              L0353:
 490  5925 F3               DI
 491  5926 F5               PUSH AF
 492  5927 7C               LD A, H
 493  5928 07               RLCA
 494  5929 07               RLCA
 495  592A E6 03            AND 3
 496  592C 5F               LD E, A
 497  592D 3E C0            LD A, 0C0H
 498  592F              L035D:
 499  592F 07               RLCA
 500  5930 07               RLCA
 501  5931 1D               DEC E
 502  5932 F2 2F 59         JP P, L035D
 503  5935 5F               LD E, A
 504  5936 2F               CPL
 505  5937 4F               LD C, A
 506  5938 F1               POP AF
 507  5939 F5               PUSH AF
 508  593A E6 03            AND 3
 509  593C 3C               INC A
 510  593D 47               LD B, A
 511  593E 3E AB            LD A, 0ABH
 512  5940              L036E:
 513  5940 C6 55            ADD A, 055H
 514  5942 10 FC            DJNZ L036E
 515  5944 57               LD D, A
 516  5945 A3               AND E
 517  5946 47               LD B, A
 518  5947 F1               POP AF
 519  5948 A7               AND A
 520  5949 C9               RET
 521  594A              L0378:
 522  594A F5               PUSH AF
 523  594B 7A               LD A, D
 524  594C E6 C0            AND 0C0H
 525  594E 4F               LD C, A
 526  594F F1               POP AF
 527  5950 F5               PUSH AF
 528  5951 57               LD D, A
 529  5952 DB A8            IN A, (0A8H)
 530  5954 47               LD B, A
 531  5955 E6 3F            AND 03FH
 532  5957 B1               OR C
 533  5958 D3 A8            OUT (0A8H), A
 534  595A 7A               LD A, D
 535  595B 0F               RRCA
 536  595C 0F               RRCA
 537  595D E6 03            AND 3
 538  595F 57               LD D, A
 539  5960 3E AB            LD A, 0ABH
 540  5962              L0390:
 541  5962 C6 55            ADD A, 055H
 542  5964 15               DEC D
 543  5965 F2 62 59         JP P, L0390
 544  5968 A3               AND E
 545  5969 57               LD D, A
 546  596A 7B               LD A, E
 547  596B 2F               CPL
 548  596C 67               LD H, A
 549  596D 3A FF FF         LD A, (0FFFFH)
 550  5970 2F               CPL
 551  5971 6F               LD L, A
 552  5972 A4               AND H
 553  5973 B2               OR D
 554  5974 32 FF FF         LD (0FFFFH), A
 555  5977 78               LD A, B
 556  5978 D3 A8            OUT (0A8H), A
 557  597A F1               POP AF
 558  597B E6 03            AND 3
 559  597D C9               RET
 560  597E              ; *******************************************************************************************************
 561  597E
 562  597E              ; *******************************************************************************************************
 563  597E              ; some common code to activate page 0 and place values needed to restore original page on stack
 564  597E              ; input IY=return address
 565  597E              ENABLE_PAGE0:
 566  597E AF               XOR A
 567  597F CD BE 58         CALL GET_PAGE_INFO
 568  5982 C5               PUSH BC
 569  5983 D5               PUSH DE
 570  5984 3A 41 F3         LD A, (RAMAD0)
 571  5987 26 00            LD H, 0
 572  5989 CD 05 59         CALL LOCAL_ENASLT
 573  598C FD E9        	JP (IY)
 574  598E              ; *******************************************************************************************************
 575  598E
 576  598E              ; General BASIC CALL-instruction handler
 577  598E              CALLHAND:
 578  598E E5           	PUSH HL
 579  598F 21 31 57     	LD	HL, CMDS ; pointer table based on starting letter
 580  5992 3A 89 FD         LD A, (PROCNM)
 581  5995 D6 41            SUB 'A'
 582  5997 87               ADD A, A
 583  5998 16 00            LD D, 0
 584  599A 5F               LD E, A
 585  599B 19               ADD HL, DE
 586  599C 5E               LD E, (HL)
 587  599D 23               INC HL
 588  599E 56               LD D, (HL)
 589  599F 7A               LD A, D
 590  59A0 B3               OR E
 591  59A1 28 23            JR Z, .CMDNOTRECOGNIZED
 592  59A3 EB               EX DE, HL
 593  59A4              .CHKCMD:
 594  59A4 11 89 FD     	LD	DE, PROCNM
 595  59A7 1A           .LOOP:	LD	A,(DE)
 596  59A8 BE           	CP	(HL)
 597  59A9 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 598  59AB 13           	INC	DE
 599  59AC 23           	INC	HL
 600  59AD A7           	AND	A
 601  59AE 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 602  59B0 5E           	LD	E,(HL)
 603  59B1 23           	INC	HL
 604  59B2 56           	LD	D,(HL)
 605  59B3 E1           	POP	HL		; routine address
 606  59B4 CD D5 59     	CALL	GETPREVCHAR
 607  59B7 CD C9 59     	CALL	.CALLDE		; Call routine
 608  59BA A7           	AND	A
 609  59BB C9           	RET
 610  59BC
 611  59BC              .TONEXTCMD:
 612  59BC 0E FF        	LD	C,0FFH
 613  59BE AF           	XOR	A
 614  59BF ED B1        	CPIR			; Skip to end of instruction name
 615  59C1 23           	INC	HL
 616  59C2 23           	INC	HL		; Skip address
 617  59C3 BE           	CP	(HL)
 618  59C4 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 619  59C6              .CMDNOTRECOGNIZED:
 620  59C6 E1           	POP	HL
 621  59C7 37               SCF
 622  59C8 C9           	RET
 623  59C9
 624  59C9              .CALLDE:
 625  59C9 D5           	PUSH	DE
 626  59CA C9           	RET
 627  59CB
 628  59CB              ;---------------------------
 629  59CB
 630  59CB              ;GETSTRPNT:
 631  59CB              ; OUT:
 632  59CB              ; HL = String Address
 633  59CB              ; B  = Lenght
 634  59CB              ;        LD      HL,(USR)
 635  59CB              ;        LD      B,(HL)
 636  59CB              ;        INC     HL
 637  59CB              ;        LD      E,(HL)
 638  59CB              ;        INC     HL
 639  59CB              ;        LD      D,(HL)
 640  59CB              ;        EX      DE,HL
 641  59CB              ;        RET
 642  59CB
 643  59CB              ;EVALTXTPARAM:
 644  59CB              ;	CALL	CHKCHAR
 645  59CB              ;	DEFB	"("             ; Check for (
 646  59CB              ;	LD	IX,FRMEVL
 647  59CB              ;	CALL	CALBAS		; Evaluate expression
 648  59CB              ;       LD      A,(VALTYP)
 649  59CB              ;        CP      3               ; Text type?
 650  59CB              ;        JP      NZ,TYPE_MISMATCH
 651  59CB              ;        PUSH	HL
 652  59CB              ;        LD	IX,FRESTR         ; Free the temporary string
 653  59CB              ;        CALL	CALBAS
 654  59CB              ;        POP	HL
 655  59CB              ;	CALL	CHKCHAR
 656  59CB              ;	DEFB	")"             ; Check for )
 657  59CB              ;        RET
 658  59CB
 659  59CB
 660  59CB              CHKCHAR:
 661  59CB CD D5 59     	CALL	GETPREVCHAR	; Get previous basic char
 662  59CE E3           	EX	(SP),HL
 663  59CF BE           	CP	(HL) 	        ; Check if good char
 664  59D0 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 665  59D2 23           	INC	HL
 666  59D3 E3           	EX	(SP),HL
 667  59D4 23           	INC	HL		; Get next basic char
 668  59D5
 669  59D5              GETPREVCHAR:
 670  59D5 2B           	DEC	HL
 671  59D6 DD 21 66 46  	LD	IX,CHRGTR
 672  59DA C3 59 01     	JP      CALBAS
 673  59DD
 674  59DD
 675  59DD              TYPE_MISMATCH:
 676  59DD 1E 0D            LD E, 13 ; Type mismatch
 677  59DF 18 0A            JR THROW_ERROR
 678  59E1              SUBSCRIPT_OUT_OF_RANGE:
 679  59E1 1E 09            LD E,9 ; subscript out of range
 680  59E3 18 06        	JR THROW_ERROR
 681  59E5              OVERFLOW:
 682  59E5 1E 06        	LD E,6
 683  59E7 18 02        	JR THROW_ERROR
 684  59E9              SYNTAX_ERROR:
 685  59E9 1E 02            LD E, 2 ; Syntax error
 686  59EB              THROW_ERROR:
 687  59EB DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 688  59EF C3 59 01     	JP	CALBAS
 689  59F2
 690  59F2              ;---------------------------
 691  59F2
 692  59F2              ; *******************************************************************************************************
 693  59F2              ; helper function to get pointer to BASIC array data
 694  59F2              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 695  59F2              ; input B=dimensions (1 or 2)
 696  59F2              ; input D=minimal first dimension
 697  59F2              ; input E=minimal second dimension
 698  59F2              ; returns BC=pointer to first data element
 699  59F2              ; throws BASIC error if invalid type
 700  59F2              GET_BASIC_ARRAY_DATA_POINTER:
 701  59F2 D5           	PUSH DE
 702  59F3 C5           	PUSH BC
 703  59F4 F5           	PUSH AF
 704  59F5 3E 01            LD A,1
 705  59F7 32 A5 F6         LD (SUBFLG),A ; search for arrays only
 706  59FA DD 21 A4 5E  	LD IX, PTRGET
 707  59FE CD 59 01     	CALL CALBAS
 708  5A01 AF               XOR A
 709  5A02 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
 710  5A05 3A 63 F6     	LD A,(VALTYP)
 711  5A08 D1           	POP DE ; required type
 712  5A09 BA           	CP D
 713  5A0A C2 DD 59     	JP NZ,TYPE_MISMATCH
 714  5A0D 0A           	LD A,(BC)
 715  5A0E 03           	INC BC
 716  5A0F D1           	POP DE ; required number of dimensions
 717  5A10 BA           	CP D
 718  5A11 C2 DD 59     	JP NZ,TYPE_MISMATCH
 719  5A14 0A           	LD A,(BC)
 720  5A15 03           	INC BC
 721  5A16 D1           	POP DE ; required minimal array dimensions
 722  5A17 BA           	CP D
 723  5A18 DA E1 59     	JP C,SUBSCRIPT_OUT_OF_RANGE
 724  5A1B 0A           	LD A,(BC)
 725  5A1C 03           	INC BC
 726  5A1D BB           	CP E
 727  5A1E DA E1 59     	JP C,SUBSCRIPT_OUT_OF_RANGE
 728  5A21 C9           	RET
 729  5A22              ; *******************************************************************************************************
 730  5A22
 731  5A22               IF (BLIT_CMDS == 1)
 732  5A22              ; *******************************************************************************************************
 733  5A22              ; function rotates mask and data of several characters and applies to background data
 734  5A22              ; this handles x-shift from 0 to 4
 735  5A22              ; contains self-modifying code that is set-up from external function
 736  5A22              ; input HL=pointer to mask data
 737  5A22              ; input HL'=pointer to character data
 738  5A22              ; input DE=output buffer containing background data
 739  5A22              ; input BC=DE+8
 740  5A22              ; input A=number of characters to process
 741  5A22              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 742  5A22              SHIFT04:
 743  5A22 08           	EX AF, AF'
 744  5A23 7E           	LD A, (HL) ; get mask
 745  5A24 D9           	EXX
 746  5A25 57           	LD D, A
 747  5A26 1E FF        	LD E, #FF
 748  5A28 37           	SCF
 749  5A29              .M1:
 750  5A29 18 FE        	JR .M1 ; this is self-modifying part
 751  5A2B CB 1A        	RR D
 752  5A2D CB 1B        	RR E
 753  5A2F CB 1A        	RR D
 754  5A31 CB 1B        	RR E
 755  5A33 CB 1A        	RR D
 756  5A35 CB 1B        	RR E
 757  5A37 CB 1A        	RR D
 758  5A39 CB 1B        	RR E
 759  5A3B
 760  5A3B 46           	LD B, (HL) ; get data
 761  5A3C 0E 00        	LD C, 0
 762  5A3E              .M2:
 763  5A3E 18 FE        	JR .M2 ; also self-modifying part
 764  5A40 CB 38        	SRL B
 765  5A42 CB 19        	RR C
 766  5A44 CB 38        	SRL B
 767  5A46 CB 19        	RR C
 768  5A48 CB 38        	SRL B
 769  5A4A CB 19        	RR C
 770  5A4C CB 38        	SRL B
 771  5A4E CB 19        	RR C
 772  5A50
 773  5A50 D9           	EXX
 774  5A51 1A           	LD A, (DE) ; background
 775  5A52 D9           	EXX
 776  5A53 A2           	AND D
 777  5A54 B0           	OR B
 778  5A55 D9           	EXX
 779  5A56 12           	LD (DE), A
 780  5A57
 781  5A57 0A           	LD A, (BC)
 782  5A58 D9           	EXX
 783  5A59 A3           	AND E
 784  5A5A B1           	OR C
 785  5A5B 23           	INC HL
 786  5A5C D9           	EXX
 787  5A5D 02           	LD (BC), A
 788  5A5E
 789  5A5E 23           	INC HL
 790  5A5F 13           	INC DE
 791  5A60 03           	INC BC
 792  5A61
 793  5A61 08           	EX AF, AF'
 794  5A62 3D           	DEC A
 795  5A63 C2 22 5A     	JP NZ, SHIFT04
 796  5A66 C9           	RET
 797  5A67              ; *******************************************************************************************************
 798  5A67
 799  5A67              ; *******************************************************************************************************
 800  5A67              ; function rotates mask and data of several characters and applies to background data
 801  5A67              ; this handles x-shift from 5 to 8
 802  5A67              ; contains self-modifying code that is set-up from external function
 803  5A67              ; input HL=pointer to mask data
 804  5A67              ; input HL'=pointer to character data
 805  5A67              ; input DE=output buffer containing background data
 806  5A67              ; input BC=DE+8
 807  5A67              ; input A=number of characters to process
 808  5A67              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 809  5A67              SHIFT58:
 810  5A67 08           	EX AF, AF'
 811  5A68 7E           	LD A, (HL) ; get mask
 812  5A69 D9           	EXX
 813  5A6A 57           	LD D, A
 814  5A6B 1E FF        	LD E, #FF
 815  5A6D 37           	SCF
 816  5A6E              .M1:
 817  5A6E 18 FE        	JR .M1 ; this is self-modifying part
 818  5A70 CB 12        	RL D
 819  5A72 CB 13        	RL E
 820  5A74 CB 12        	RL D
 821  5A76 CB 13        	RL E
 822  5A78 CB 12        	RL D
 823  5A7A CB 13        	RL E
 824  5A7C
 825  5A7C 46           	LD B, (HL)
 826  5A7D 0E 00        	LD C, 0
 827  5A7F              .M2:
 828  5A7F 18 FE        	JR .M2 ; also self-modifying part
 829  5A81 CB 20        	SLA B
 830  5A83 CB 11        	RL C
 831  5A85 CB 20        	SLA B
 832  5A87 CB 11        	RL C
 833  5A89 CB 20        	SLA B
 834  5A8B CB 11        	RL C
 835  5A8D
 836  5A8D D9           	EXX
 837  5A8E 1A           	LD A, (DE) ; background
 838  5A8F D9           	EXX
 839  5A90 A3           	AND E
 840  5A91 B1           	OR C
 841  5A92 D9           	EXX
 842  5A93 12           	LD (DE), A
 843  5A94
 844  5A94 0A           	LD A, (BC)
 845  5A95 D9           	EXX
 846  5A96 A2           	AND D
 847  5A97 B0           	OR B
 848  5A98 23           	INC HL
 849  5A99 D9           	EXX
 850  5A9A 02           	LD (BC), A
 851  5A9B
 852  5A9B 23           	INC HL
 853  5A9C 13           	INC DE
 854  5A9D 03           	INC BC
 855  5A9E
 856  5A9E 08           	EX AF, AF'
 857  5A9F 3D           	DEC A
 858  5AA0 C2 67 5A     	JP NZ, SHIFT58
 859  5AA3 C9           	RET
 860  5AA4              ; *******************************************************************************************************
 861  5AA4
 862  5AA4              ; *******************************************************************************************************
 863  5AA4              ; routine that shifts one row of characters
 864  5AA4              ; contains self-modifying code that is set-up from external function
 865  5AA4              ; input HL=pointer to mask data
 866  5AA4              ; input HL'=pointer to character data
 867  5AA4              ; input DE=output buffer containing background data
 868  5AA4              ; input A=number of characters to process
 869  5AA4              ; input IX=pointer to structure describing input data
 870  5AA4              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 871  5AA4              SHIFT_ROW:
 872  5AA4 F5           	PUSH AF
 873  5AA5 ED 53 1B 57  		LD (BLIT_TMP1), DE
 874  5AA9 E5           		PUSH HL
 875  5AAA CD ED 5A     			CALL .ADDYSHIFT
 876  5AAD E1           		POP HL
 877  5AAE ED 53 1D 57  		LD (BLIT_TMP2), DE ; DE+vertical shift
 878  5AB2              .L1:
 879  5AB2 3E 08        		LD A, 8
 880  5AB4 DD 96 02     		SUB (IX+2) ; y shift
 881  5AB7              .CALL1:
 882  5AB7 CD 00 00     		CALL 0
 883  5ABA DD 7E 02     		LD A, (IX+2); y shift
 884  5ABD B7           		OR A
 885  5ABE 28 26        		JR Z, .DONE
 886  5AC0 ED 5B 1B 57  		LD DE, (BLIT_TMP1)
 887  5AC4 E5           		PUSH HL
 888  5AC5 CD FB 5A     			CALL .DETONEXTROW
 889  5AC8 E1           		POP HL
 890  5AC9              .CALL2:
 891  5AC9 CD 00 00     		CALL 0
 892  5ACC ED 5B 1B 57  		LD DE, (BLIT_TMP1)
 893  5AD0 E5           		PUSH HL
 894  5AD1 CD F5 5A     			CALL .ADD8
 895  5AD4 E1           		POP HL
 896  5AD5 ED 53 1B 57  		LD (BLIT_TMP1), DE
 897  5AD9 ED 5B 1D 57  		LD DE, (BLIT_TMP2)
 898  5ADD E5           		PUSH HL
 899  5ADE CD F5 5A     			CALL .ADD8
 900  5AE1 E1           		POP HL
 901  5AE2 ED 53 1D 57  		LD (BLIT_TMP2), DE ; DE+vertical shift
 902  5AE6              .DONE:
 903  5AE6 F1           	POP AF
 904  5AE7 3D           	DEC A
 905  5AE8 C8           	RET Z
 906  5AE9 F5           	PUSH AF
 907  5AEA C3 B2 5A     	JP .L1
 908  5AED              .ADDYSHIFT:
 909  5AED EB           	EX DE, HL
 910  5AEE 16 00        	LD D, 0
 911  5AF0 DD 5E 02     	LD E, (IX+2); y shift
 912  5AF3 18 0C        	JR .MOVDEBC
 913  5AF5              .ADD8:
 914  5AF5 21 08 00     	LD HL, 8
 915  5AF8 C3 01 5B     	JP .MOVDEBC
 916  5AFB              .DETONEXTROW:
 917  5AFB DD 6E 06     	LD L, (IX+6)
 918  5AFE DD 66 07     	LD H, (IX+7) ; bkg add to value
 919  5B01              .MOVDEBC:
 920  5B01 19           	ADD HL, DE
 921  5B02 54           	LD D, H
 922  5B03 5D           	LD E, L
 923  5B04 01 08 00     	LD BC, 8
 924  5B07 09           	ADD HL, BC
 925  5B08 44           	LD B, H
 926  5B09 4D           	LD C, L
 927  5B0A C9           	RET
 928  5B0B              ; *******************************************************************************************************
 929  5B0B
 930  5B0B              ; *******************************************************************************************************
 931  5B0B              ; function rotates mask and character data and applies it to background
 932  5B0B              ; input IX=pointer to structure describing input data
 933  5B0B              ; +0  DW horizontal shift count 0-7 (low byte used)
 934  5B0B              ; +2  DW vertical shift count 0-7 (low byte used)
 935  5B0B              ; +4  DW background data start;
 936  5B0B              ; +6  DW background add to value to next row of background data
 937  5B0B              ; +8  DW mask data start;
 938  5B0B              ; +10  DW character data start;
 939  5B0B              ; +12 DW character&mask add to value to next row of data
 940  5B0B              ; +14 DW columns (low byte used)
 941  5B0B              ; +16 DW rows (low byte used)
 942  5B0B              SHIFT_MERGE_CHARACTER:
 943  5B0B DD 7E 00     	LD A, (IX) ; shift
 944  5B0E FE 05        	CP 5
 945  5B10 38 25        	JR C, .RIGHT
 946  5B12              	; shifts 5-7, use rotate towards left 1-3
 947  5B12 21 67 5A     	LD HL, SHIFT58
 948  5B15 22 B8 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 949  5B18 22 CA 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 950  5B1B D6 05        	SUB 5
 951  5B1D 28 0D        	JR Z, .L1
 952  5B1F 87           	ADD A, A
 953  5B20 87           	ADD A, A
 954  5B21 67           	LD H, A
 955  5B22 2E 18        	LD L, #18 ; JR opcode
 956  5B24 22 6E 5A     	LD (SHIFT58.M1), HL
 957  5B27 22 7F 5A     	LD (SHIFT58.M2), HL
 958  5B2A 18 32        	JR .DO
 959  5B2C              .L1:
 960  5B2C 21 00 00     	LD HL, 0 ; 2xNOP opcode
 961  5B2F 22 6E 5A     	LD (SHIFT58.M1), HL
 962  5B32 22 7F 5A     	LD (SHIFT58.M2), HL
 963  5B35 18 27        	JR .DO
 964  5B37              .RIGHT:
 965  5B37              	; shifts 0-4, rotate towards right
 966  5B37 21 22 5A     	LD HL, SHIFT04
 967  5B3A 22 B8 5A     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 968  5B3D 22 CA 5A     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 969  5B40 FE 04        	CP 4
 970  5B42 28 11        	JR Z, .R1
 971  5B44 D6 04        	SUB 4
 972  5B46 ED 44        	NEG
 973  5B48 87           	ADD A, A
 974  5B49 87           	ADD A, A
 975  5B4A 67           	LD H, A
 976  5B4B 2E 18        	LD L, #18 ; JR opcode
 977  5B4D 22 29 5A     	LD (SHIFT04.M1), HL
 978  5B50 22 3E 5A     	LD (SHIFT04.M2), HL
 979  5B53 18 09        	JR .DO
 980  5B55              .R1:
 981  5B55 21 00 00     	LD HL, 0 ; 2xNOP opcode
 982  5B58 22 29 5A     	LD (SHIFT04.M1), HL
 983  5B5B 22 3E 5A     	LD (SHIFT04.M2), HL
 984  5B5E              .DO:
 985  5B5E DD 46 10     	LD B, (IX+16) ; rows
 986  5B61 DD 6E 08     	LD L, (IX+8)
 987  5B64 DD 66 09     	LD H, (IX+9) ; mask data
 988  5B67 DD 5E 04     	LD E, (IX+4)
 989  5B6A DD 56 05     	LD D, (IX+5) ; background data
 990  5B6D D9           	EXX
 991  5B6E DD 6E 0A     	LD L, (IX+10)
 992  5B71 DD 66 0B     	LD H, (IX+11) ; character data
 993  5B74 D9           	EXX
 994  5B75              .LOOP:
 995  5B75 C5           	PUSH BC
 996  5B76 E5           		PUSH HL
 997  5B77 D5           			PUSH DE
 998  5B78 D9           				EXX
 999  5B79 E5           				PUSH HL
1000  5B7A D9           					EXX
1001  5B7B DD 7E 0E     					LD A, (IX+14) ; columns
1002  5B7E              .CALL:
1003  5B7E CD A4 5A     					CALL SHIFT_ROW
1004  5B81 E1           				POP HL
1005  5B82 DD 5E 0C     				LD E, (IX+12)
1006  5B85 DD 56 0D     				LD D, (IX+13) ; char data to next row
1007  5B88 19           				ADD HL, DE
1008  5B89 D9           				EXX
1009  5B8A E1           			POP HL
1010  5B8B DD 5E 06     			LD E, (IX+6)
1011  5B8E DD 56 07     			LD D, (IX+7) ; background to next row
1012  5B91 19           			ADD HL, DE
1013  5B92 EB           			EX DE, HL
1014  5B93 E1           		POP HL
1015  5B94 DD 4E 0C     		LD C, (IX+12)
1016  5B97 DD 46 0D     		LD B, (IX+13) ; char data to next row
1017  5B9A 09           		ADD HL, BC
1018  5B9B C1           	POP BC
1019  5B9C 10 D7        	DJNZ .LOOP
1020  5B9E C9           	RET
1021  5B9F              ; *******************************************************************************************************
1022  5B9F
1023  5B9F               IFNDEF CMDS_WITH_PARAMETERS
1024  5B9F ~            ; *******************************************************************************************************
1025  5B9F ~            ; function to handle CALL BLIT basic extension
1026  5B9F ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1027  5B9F ~            ; fuses with background data and applies vertical shift too
1028  5B9F ~            ; BLIT ( INT request_data_ptr )
1029  5B9F ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1030  5B9F ~            ; will put ram in page 0 also, page 1 is already there
1031  5B9F ~            BLIT:
1032  5B9F ~            	; opening (
1033  5B9F ~            	CALL CHKCHAR
1034  5B9F ~            	DB '('
1035  5B9F ~            	; get pointer to request struct
1036  5B9F ~            	LD IX, FRMQNT
1037  5B9F ~            	CALL CALBAS
1038  5B9F ~            	PUSH DE
1039  5B9F ~            	; ending )
1040  5B9F ~            	CALL CHKCHAR
1041  5B9F ~            	DB ')'
1042  5B9F ~
1043  5B9F ~            	POP IX ; pointer to request struct
1044  5B9F ~
1045  5B9F ~            	PUSH HL ; save position in BASIC buffer
1046  5B9F ~
1047  5B9F ~            	LD IY, .RET
1048  5B9F ~            	JP ENABLE_PAGE0
1049  5B9F ~            .RET:
1050  5B9F ~            	EI
1051  5B9F ~            	CALL SHIFT_MERGE_CHARACTER
1052  5B9F ~
1053  5B9F ~                POP DE
1054  5B9F ~                POP BC
1055  5B9F ~                CALL RESTORE_PAGE_INFO
1056  5B9F ~
1057  5B9F ~            	POP HL
1058  5B9F ~            	RET
1059  5B9F ~            ; *******************************************************************************************************
1060  5B9F               ENDIF
1061  5B9F
1062  5B9F               IFDEF CMDS_WITH_PARAMETERS
1063  5B9F              ; *******************************************************************************************************
1064  5B9F              ; function to handle CALL BLIT basic extension
1065  5B9F              ; rotates 1-bit character drawing horizontally with mask and character data and
1066  5B9F              ; fuses with background data and applies vertical shift too
1067  5B9F              ; in form without pointers
1068  5B9F              ; BLIT ( INT x,
1069  5B9F              ;		 INT y,
1070  5B9F              ;		 INT char_data_pointer,
1071  5B9F              ;		 INT mask_data_pointer,
1072  5B9F              ;		 INT width (in characters),
1073  5B9F              ;		 INT height (in characters),
1074  5B9F              ;		 INT background_pointer (top left),
1075  5B9F              ;		 INT background_width (in characters),
1076  5B9F              ;		 INT background_height (in characters))
1077  5B9F              ; will put ram in page 0 also, page 1 is already there
1078  5B9F              BLIT:
1079  5B9F              	; opening (
1080  5B9F CD CB 59     	CALL CHKCHAR
1081  5BA2 28           	DB '('
1082  5BA3              	; get x coordinate
1083  5BA3 DD 21 2F 54  	LD IX, FRMQNT
1084  5BA7 CD 59 01     	CALL CALBAS
1085  5BAA 7B           	LD A, E
1086  5BAB E6 07        	AND 7
1087  5BAD 32 1F 57     	LD (BLIT_STRUCT+0), A
1088  5BB0 CD 8D 5C     	CALL .DAdiv8
1089  5BB3 32 1B 57     	LD (BLIT_TMP+0),A
1090  5BB6              	; comma
1091  5BB6 CD CB 59     	CALL CHKCHAR
1092  5BB9 2C           	DB ','
1093  5BBA              	; get y coordinate
1094  5BBA DD 21 2F 54  	LD IX, FRMQNT
1095  5BBE CD 59 01     	CALL CALBAS
1096  5BC1 7B           	LD A, E
1097  5BC2 E6 07        	AND 7
1098  5BC4 32 21 57     	LD (BLIT_STRUCT+2), A
1099  5BC7 CD 8D 5C     	CALL .DAdiv8
1100  5BCA 32 1C 57     	LD (BLIT_TMP+1),A
1101  5BCD              	; comma
1102  5BCD CD CB 59     	CALL CHKCHAR
1103  5BD0 2C           	DB ','
1104  5BD1              	; get char data pointer
1105  5BD1 DD 21 2F 54  	LD IX, FRMQNT
1106  5BD5 CD 59 01     	CALL CALBAS
1107  5BD8 ED 53 29 57  	LD (BLIT_STRUCT+10), DE
1108  5BDC              	; comma
1109  5BDC CD CB 59     	CALL CHKCHAR
1110  5BDF 2C           	DB ','
1111  5BE0              	; get mask data pointer
1112  5BE0 DD 21 2F 54  	LD IX, FRMQNT
1113  5BE4 CD 59 01     	CALL CALBAS
1114  5BE7 ED 53 27 57  	LD (BLIT_STRUCT+8), DE
1115  5BEB              	; comma
1116  5BEB CD CB 59     	CALL CHKCHAR
1117  5BEE 2C           	DB ','
1118  5BEF              	; get width
1119  5BEF DD 21 2F 54  	LD IX, FRMQNT
1120  5BF3 CD 59 01     	CALL CALBAS
1121  5BF6 7B           	LD A, E
1122  5BF7 32 2D 57     	LD (BLIT_STRUCT+14), A
1123  5BFA              	; comma
1124  5BFA CD CB 59     	CALL CHKCHAR
1125  5BFD 2C           	DB ','
1126  5BFE              	; get height
1127  5BFE DD 21 2F 54  	LD IX, FRMQNT
1128  5C02 CD 59 01     	CALL CALBAS
1129  5C05 7B           	LD A, E
1130  5C06 32 2F 57     	LD (BLIT_STRUCT+16), A
1131  5C09              	; comma
1132  5C09 CD CB 59     	CALL CHKCHAR
1133  5C0C 2C           	DB ','
1134  5C0D              	; get background pointer
1135  5C0D DD 21 2F 54  	LD IX, FRMQNT
1136  5C11 CD 59 01     	CALL CALBAS
1137  5C14 ED 53 23 57  	LD (BLIT_STRUCT+4), DE
1138  5C18              	; comma
1139  5C18 CD CB 59     	CALL CHKCHAR
1140  5C1B 2C           	DB ','
1141  5C1C              	; get background width
1142  5C1C DD 21 2F 54  	LD IX, FRMQNT
1143  5C20 CD 59 01     	CALL CALBAS
1144  5C23 7B           	LD A, E
1145  5C24 32 1D 57     	LD (BLIT_TMP+2), A
1146  5C27              	; comma
1147  5C27 CD CB 59     	CALL CHKCHAR
1148  5C2A 2C           	DB ','
1149  5C2B              	; get background height
1150  5C2B DD 21 2F 54  	LD IX, FRMQNT
1151  5C2F CD 59 01     	CALL CALBAS
1152  5C32 7B           	LD A, E
1153  5C33 32 1E 57     	LD (BLIT_TMP+3), A
1154  5C36              	; ending )
1155  5C36 CD CB 59     	CALL CHKCHAR
1156  5C39 29           	DB ')'
1157  5C3A
1158  5C3A E5           	PUSH HL ; save position in BASIC buffer
1159  5C3B
1160  5C3B              	; calculate char&mask add to value
1161  5C3B 26 00        	LD H, 0
1162  5C3D 3A 2D 57     	LD A, (BLIT_STRUCT+14)
1163  5C40 6F           	LD L, A
1164  5C41 CD BA 58     	CALL HLx8
1165  5C44 22 2B 57     	LD (BLIT_STRUCT+12), HL
1166  5C47              	; calculate background add to value
1167  5C47 26 00        	LD H, 0
1168  5C49 3A 1D 57     	LD A, (BLIT_TMP+2)
1169  5C4C 6F           	LD L, A
1170  5C4D CD BA 58     	CALL HLx8
1171  5C50 22 25 57     	LD (BLIT_STRUCT+6), HL
1172  5C53              	; calculate pointer to background location
1173  5C53 21 00 00     	LD HL, 0
1174  5C56 3A 1C 57     	LD A,(BLIT_TMP+1)
1175  5C59 B7           	OR A
1176  5C5A 28 08        	JR Z, .L1
1177  5C5C 47           	LD B,A
1178  5C5D ED 5B 25 57  	LD DE,(BLIT_STRUCT+6)
1179  5C61              .L0:
1180  5C61 19           	ADD HL, DE
1181  5C62 10 FD        	DJNZ .L0
1182  5C64              .L1:
1183  5C64 EB           	EX DE,HL
1184  5C65 26 00        	LD H,0
1185  5C67 3A 1B 57     	LD A,(BLIT_TMP+0)
1186  5C6A 6F           	LD L,A
1187  5C6B CD BA 58     	CALL HLx8
1188  5C6E 19           	ADD HL,DE
1189  5C6F ED 5B 23 57  	LD DE,(BLIT_STRUCT+4)
1190  5C73 19           	ADD HL,DE
1191  5C74 22 23 57     	LD (BLIT_STRUCT+4),HL
1192  5C77
1193  5C77 FD 21 7E 5C  	LD IY, .RET
1194  5C7B C3 7E 59     	JP ENABLE_PAGE0
1195  5C7E              .RET:
1196  5C7E FB           	EI
1197  5C7F DD 21 1F 57  	LD IX, BLIT_STRUCT
1198  5C83 CD 0B 5B     	CALL SHIFT_MERGE_CHARACTER
1199  5C86
1200  5C86 D1               POP DE
1201  5C87 C1               POP BC
1202  5C88 CD F5 58         CALL RESTORE_PAGE_INFO
1203  5C8B
1204  5C8B E1           	POP HL
1205  5C8C C9           	RET
1206  5C8D              .DAdiv8:
1207  5C8D 7B           	LD A,E
1208  5C8E CB 2A        	SRA D
1209  5C90 CB 1F            RR  A
1210  5C92 CB 2A            SRA D
1211  5C94 CB 1F            RR  A
1212  5C96 CB 2A            SRA D
1213  5C98 CB 1F            RR  A
1214  5C9A C9           	RET
1215  5C9B              ; *******************************************************************************************************
1216  5C9B               ENDIF
1217  5C9B               ENDIF
1218  5C9B
1219  5C9B               IF (TILE_CMDS == 1)
1220  5C9B              ; *******************************************************************************************************
1221  5C9B              ; generic function to implement tiling
1222  5C9B              ; should be modified to call appropriate function for memory or vram
1223  5C9B              ; input IX=pointer to following structure
1224  5C9B              ; +00 tile_data_ptr
1225  5C9B              ; +02 tile_rows
1226  5C9B              ; +04 tile_columns
1227  5C9B              ; +06 destination_address
1228  5C9B              ; +08 dest_to_next_row_add_to_value
1229  5C9B              ; +10 num_horizontal_tiles
1230  5C9B              ; +12 num_vertical_tiles
1231  5C9B              ; modifies AF, BC, DE, HL
1232  5C9B              TILE:
1233  5C9B DD 6E 06     	LD L, (IX+6)
1234  5C9E DD 66 07     	LD H, (IX+7) ; destination address
1235  5CA1 22 1B 57     	LD (TILETMP1), HL
1236  5CA4 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1237  5CA7              .L1:
1238  5CA7 C5           	PUSH BC
1239  5CA8 DD 6E 00     		LD L, (IX+0)
1240  5CAB DD 66 01     		LD H, (IX+1) ; tile address
1241  5CAE 22 1D 57     		LD (TILETMP2), HL
1242  5CB1 DD 46 02     		LD B, (IX+2) ; tile rows
1243  5CB4              .L2:
1244  5CB4 C5           		PUSH BC
1245  5CB5              .CALL1:
1246  5CB5 CD 00 00     			CALL 0
1247  5CB8 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1248  5CBB              .L3:
1249  5CBB C5           			PUSH BC
1250  5CBC 2A 1D 57     				LD HL, (TILETMP2)
1251  5CBF DD 46 04     				LD B, (IX+4) ; tile columns
1252  5CC2              .L4:
1253  5CC2 C5           				PUSH BC
1254  5CC3              .CALL2:
1255  5CC3 CD 00 00     					CALL 0
1256  5CC6 C1           				POP BC
1257  5CC7 10 F9        				DJNZ .L4
1258  5CC9 C1           			POP BC
1259  5CCA 10 EF        			DJNZ .L3
1260  5CCC 22 1D 57     			LD (TILETMP2), HL
1261  5CCF 2A 1B 57     			LD HL, (TILETMP1)
1262  5CD2 DD 5E 08     			LD E, (IX+8)
1263  5CD5 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1264  5CD8 19           			ADD HL, DE
1265  5CD9 22 1B 57     			LD (TILETMP1), HL
1266  5CDC C1           		POP BC
1267  5CDD 10 D5        		DJNZ .L2
1268  5CDF C1           	POP BC
1269  5CE0 10 C5        	DJNZ .L1
1270  5CE2 C9           	RET
1271  5CE3              ; *******************************************************************************************************
1272  5CE3
1273  5CE3               IFNDEF CMDS_WITH_PARAMETERS
1274  5CE3 ~            ; *******************************************************************************************************
1275  5CE3 ~            ; function to handle CALL TILERAM basic extension
1276  5CE3 ~            ; fills memory with tiles
1277  5CE3 ~            ; TILERAM ( INT request_data_ptr )
1278  5CE3 ~            ; request_data_ptr described in TILE
1279  5CE3 ~            ; will put ram in page 0 also, page 1 is already there
1280  5CE3 ~            TILERAM:
1281  5CE3 ~            	; opening (
1282  5CE3 ~            	CALL CHKCHAR
1283  5CE3 ~            	DB '('
1284  5CE3 ~            	; get pointer to request struct
1285  5CE3 ~            	LD IX, FRMQNT
1286  5CE3 ~            	CALL CALBAS
1287  5CE3 ~            	PUSH DE
1288  5CE3 ~            	; ending )
1289  5CE3 ~            	CALL CHKCHAR
1290  5CE3 ~            	DB ')'
1291  5CE3 ~
1292  5CE3 ~            	POP IX ; pointer to request struct
1293  5CE3 ~
1294  5CE3 ~            	PUSH HL ; save position in BASIC buffer
1295  5CE3 ~
1296  5CE3 ~            	LD IY, .RET
1297  5CE3 ~            	JP ENABLE_PAGE0
1298  5CE3 ~            .RET:
1299  5CE3 ~            	EI
1300  5CE3 ~            	; set RAM functions to call
1301  5CE3 ~            	LD HL, .TILECOPY
1302  5CE3 ~            	LD (TILE.CALL2+1), HL
1303  5CE3 ~            	LD HL, .SETDESTROW
1304  5CE3 ~            	LD (TILE.CALL1+1), HL
1305  5CE3 ~            	LD A,1
1306  5CE3 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1307  5CE3 ~            	CALL TILE
1308  5CE3 ~            	XOR A
1309  5CE3 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
1310  5CE3 ~
1311  5CE3 ~                POP DE
1312  5CE3 ~                POP BC
1313  5CE3 ~                CALL RESTORE_PAGE_INFO
1314  5CE3 ~
1315  5CE3 ~            	POP HL
1316  5CE3 ~            	RET
1317  5CE3 ~            .TILECOPY:
1318  5CE3 ~            	.8 LDI
1319  5CE3 ~            	RET
1320  5CE3 ~            .SETDESTROW:
1321  5CE3 ~            	LD DE, (TILETMP1)
1322  5CE3 ~            	RET
1323  5CE3 ~            ; *******************************************************************************************************
1324  5CE3               ENDIF
1325  5CE3
1326  5CE3               IFDEF CMDS_WITH_PARAMETERS
1327  5CE3              ; *******************************************************************************************************
1328  5CE3              ; function to handle CALL TILERAM basic extension
1329  5CE3              ; fills memory with tiles
1330  5CE3              ; TILERAM ( INT tile_data_pointer,
1331  5CE3              ;			INT tile_columns,
1332  5CE3              ;			INT tile_rows,
1333  5CE3              ;			INT destination_pointer,
1334  5CE3              ;			INT destination_columns,
1335  5CE3              ;			INT destination_rows,
1336  5CE3              ;			INT destination_begin_column,
1337  5CE3              ;			INT destination_begin_row,
1338  5CE3              ;			INT number_of_tiles_horizontally,
1339  5CE3              ;			INT	number_of_tiles_vertically )
1340  5CE3              ; will put ram in page 0 also, page 1 is already there
1341  5CE3              TILERAM:
1342  5CE3              	; opening (
1343  5CE3 CD CB 59     	CALL CHKCHAR
1344  5CE6 28           	DB '('
1345  5CE7              	; get tile data pointer coordinate
1346  5CE7 DD 21 2F 54  	LD IX, FRMQNT
1347  5CEB CD 59 01     	CALL CALBAS
1348  5CEE ED 53 1F 57  	LD (BLIT_STRUCT+0), DE
1349  5CF2              	; comma
1350  5CF2 CD CB 59     	CALL CHKCHAR
1351  5CF5 2C           	DB ','
1352  5CF6              	; get tile columns
1353  5CF6 DD 21 2F 54  	LD IX, FRMQNT
1354  5CFA CD 59 01     	CALL CALBAS
1355  5CFD ED 53 23 57  	LD (BLIT_STRUCT+4), DE
1356  5D01              	; comma
1357  5D01 CD CB 59     	CALL CHKCHAR
1358  5D04 2C           	DB ','
1359  5D05              	; get tile columns
1360  5D05 DD 21 2F 54  	LD IX, FRMQNT
1361  5D09 CD 59 01     	CALL CALBAS
1362  5D0C ED 53 21 57  	LD (BLIT_STRUCT+2), DE
1363  5D10              	; comma
1364  5D10 CD CB 59     	CALL CHKCHAR
1365  5D13 2C           	DB ','
1366  5D14              	; get destintion pointer
1367  5D14 DD 21 2F 54  	LD IX, FRMQNT
1368  5D18 CD 59 01     	CALL CALBAS
1369  5D1B ED 53 25 57  	LD (BLIT_STRUCT+6), DE
1370  5D1F              	; comma
1371  5D1F CD CB 59     	CALL CHKCHAR
1372  5D22 2C           	DB ','
1373  5D23              	; get destination columns
1374  5D23 DD 21 2F 54  	LD IX, FRMQNT
1375  5D27 CD 59 01     	CALL CALBAS
1376  5D2A 7B           	LD A, E
1377  5D2B 32 1B 57     	LD (BLIT_TMP+0), A
1378  5D2E              	; comma
1379  5D2E CD CB 59     	CALL CHKCHAR
1380  5D31 2C           	DB ','
1381  5D32              	; get destination rows
1382  5D32 DD 21 2F 54  	LD IX, FRMQNT
1383  5D36 CD 59 01     	CALL CALBAS
1384  5D39 7B           	LD A, E
1385  5D3A 32 1C 57     	LD (BLIT_TMP+1), A
1386  5D3D              	; comma
1387  5D3D CD CB 59     	CALL CHKCHAR
1388  5D40 2C           	DB ','
1389  5D41              	; get destination begin column
1390  5D41 DD 21 2F 54  	LD IX, FRMQNT
1391  5D45 CD 59 01     	CALL CALBAS
1392  5D48 7B           	LD A, E
1393  5D49 32 1D 57     	LD (BLIT_TMP+2), A
1394  5D4C              	; comma
1395  5D4C CD CB 59     	CALL CHKCHAR
1396  5D4F 2C           	DB ','
1397  5D50              	; get destination begin row
1398  5D50 DD 21 2F 54  	LD IX, FRMQNT
1399  5D54 CD 59 01     	CALL CALBAS
1400  5D57 7B           	LD A, E
1401  5D58 32 1E 57     	LD (BLIT_TMP+3), A
1402  5D5B              	; comma
1403  5D5B CD CB 59     	CALL CHKCHAR
1404  5D5E 2C           	DB ','
1405  5D5F              	; get number of tiles horizontally
1406  5D5F DD 21 2F 54  	LD IX, FRMQNT
1407  5D63 CD 59 01     	CALL CALBAS
1408  5D66 ED 53 29 57  	LD (BLIT_STRUCT+10), DE
1409  5D6A              	; comma
1410  5D6A CD CB 59     	CALL CHKCHAR
1411  5D6D 2C           	DB ','
1412  5D6E              	; get number of tiles vertically
1413  5D6E DD 21 2F 54  	LD IX, FRMQNT
1414  5D72 CD 59 01     	CALL CALBAS
1415  5D75 ED 53 2B 57  	LD (BLIT_STRUCT+12), DE
1416  5D79              	; ending )
1417  5D79 CD CB 59     	CALL CHKCHAR
1418  5D7C 29           	DB ')'
1419  5D7D
1420  5D7D E5           	PUSH HL ; save position in BASIC buffer
1421  5D7E
1422  5D7E              	; calculate destination add to value
1423  5D7E 26 00        	LD H, 0
1424  5D80 3A 1B 57     	LD A, (BLIT_TMP+0)
1425  5D83 6F           	LD L, A
1426  5D84 CD BA 58     	CALL HLx8
1427  5D87 22 27 57     	LD (BLIT_STRUCT+8), HL
1428  5D8A              	; calculate pointer to background location
1429  5D8A 21 00 00     	LD HL, 0
1430  5D8D 3A 1E 57     	LD A,(BLIT_TMP+3)
1431  5D90 B7           	OR A
1432  5D91 28 08        	JR Z, .L1
1433  5D93 47           	LD B,A
1434  5D94 ED 5B 27 57  	LD DE,(BLIT_STRUCT+8)
1435  5D98              .L0:
1436  5D98 19           	ADD HL, DE
1437  5D99 10 FD        	DJNZ .L0
1438  5D9B              .L1:
1439  5D9B EB           	EX DE,HL
1440  5D9C 26 00        	LD H,0
1441  5D9E 3A 1D 57     	LD A,(BLIT_TMP+2)
1442  5DA1 6F           	LD L,A
1443  5DA2 CD BA 58     	CALL HLx8
1444  5DA5 19           	ADD HL,DE
1445  5DA6 ED 5B 25 57  	LD DE,(BLIT_STRUCT+6)
1446  5DAA 19           	ADD HL,DE
1447  5DAB 22 25 57     	LD (BLIT_STRUCT+6),HL
1448  5DAE
1449  5DAE FD 21 B5 5D  	LD IY, .RET
1450  5DB2 C3 7E 59     	JP ENABLE_PAGE0
1451  5DB5              .RET:
1452  5DB5 FB           	EI
1453  5DB6              	; set RAM functions to call
1454  5DB6 21 D0 5D     	LD HL, .TILECOPY
1455  5DB9 22 C4 5C     	LD (TILE.CALL2+1), HL
1456  5DBC 21 E1 5D     	LD HL, .SETDESTROW
1457  5DBF 22 B6 5C     	LD (TILE.CALL1+1), HL
1458  5DC2 DD 21 1F 57  	LD IX,BLIT_STRUCT
1459  5DC6 CD 9B 5C     	CALL TILE
1460  5DC9
1461  5DC9 D1               POP DE
1462  5DCA C1               POP BC
1463  5DCB CD F5 58         CALL RESTORE_PAGE_INFO
1464  5DCE
1465  5DCE E1           	POP HL
1466  5DCF C9           	RET
1467  5DD0              .TILECOPY:
1468  5DD0 ED A0       > LDI
1468  5DD2 ED A0       > LDI
1468  5DD4 ED A0       > LDI
1468  5DD6 ED A0       > LDI
1468  5DD8 ED A0       > LDI
1468  5DDA ED A0       > LDI
1468  5DDC ED A0       > LDI
1468  5DDE ED A0       > LDI
1469  5DE0 C9           	RET
1470  5DE1              .SETDESTROW:
1471  5DE1 ED 5B 1B 57  	LD DE, (TILETMP1)
1472  5DE5 C9           	RET
1473  5DE6              ; *******************************************************************************************************
1474  5DE6               ENDIF
1475  5DE6
1476  5DE6               IFDEF CMDS_WITH_PARAMETERS
1477  5DE6              ; *******************************************************************************************************
1478  5DE6              ; function to handle CALL TILEVRM basic extension
1479  5DE6              ; fills vram with tiles
1480  5DE6              ; TILEVRM ( INT tile_data_pointer,
1481  5DE6              ;			INT tile_columns,
1482  5DE6              ;			INT tile_rows,
1483  5DE6              ;			INT destination_begin_column,
1484  5DE6              ;			INT destination_begin_row,
1485  5DE6              ;			INT number_of_tiles_horizontally,
1486  5DE6              ;			INT	number_of_tiles_vertically )
1487  5DE6              ; will put ram in page 0 also, page 1 is already there
1488  5DE6              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
1489  5DE6              TILEVRM:
1490  5DE6              	; opening (
1491  5DE6 CD CB 59     	CALL CHKCHAR
1492  5DE9 28           	DB '('
1493  5DEA              	; get tile data pointer coordinate
1494  5DEA DD 21 2F 54  	LD IX, FRMQNT
1495  5DEE CD 59 01     	CALL CALBAS
1496  5DF1 ED 53 1F 57  	LD (BLIT_STRUCT+0), DE
1497  5DF5              	; comma
1498  5DF5 CD CB 59     	CALL CHKCHAR
1499  5DF8 2C           	DB ','
1500  5DF9              	; get tile columns
1501  5DF9 DD 21 2F 54  	LD IX, FRMQNT
1502  5DFD CD 59 01     	CALL CALBAS
1503  5E00 ED 53 23 57  	LD (BLIT_STRUCT+4), DE
1504  5E04              	; comma
1505  5E04 CD CB 59     	CALL CHKCHAR
1506  5E07 2C           	DB ','
1507  5E08              	; get tile columns
1508  5E08 DD 21 2F 54  	LD IX, FRMQNT
1509  5E0C CD 59 01     	CALL CALBAS
1510  5E0F ED 53 21 57  	LD (BLIT_STRUCT+2), DE
1511  5E13              	; comma
1512  5E13 CD CB 59     	CALL CHKCHAR
1513  5E16 2C           	DB ','
1514  5E17              	; get destination begin column
1515  5E17 DD 21 2F 54  	LD IX, FRMQNT
1516  5E1B CD 59 01     	CALL CALBAS
1517  5E1E 7B           	LD A, E
1518  5E1F 32 1D 57     	LD (BLIT_TMP+2), A
1519  5E22              	; comma
1520  5E22 CD CB 59     	CALL CHKCHAR
1521  5E25 2C           	DB ','
1522  5E26              	; get destination begin row
1523  5E26 DD 21 2F 54  	LD IX, FRMQNT
1524  5E2A CD 59 01     	CALL CALBAS
1525  5E2D 7B           	LD A, E
1526  5E2E 32 1E 57     	LD (BLIT_TMP+3), A
1527  5E31              	; comma
1528  5E31 CD CB 59     	CALL CHKCHAR
1529  5E34 2C           	DB ','
1530  5E35              	; get number of tiles horizontally
1531  5E35 DD 21 2F 54  	LD IX, FRMQNT
1532  5E39 CD 59 01     	CALL CALBAS
1533  5E3C ED 53 29 57  	LD (BLIT_STRUCT+10), DE
1534  5E40              	; comma
1535  5E40 CD CB 59     	CALL CHKCHAR
1536  5E43 2C           	DB ','
1537  5E44              	; get number of tiles vertically
1538  5E44 DD 21 2F 54  	LD IX, FRMQNT
1539  5E48 CD 59 01     	CALL CALBAS
1540  5E4B ED 53 2B 57  	LD (BLIT_STRUCT+12), DE
1541  5E4F              	; ending )
1542  5E4F CD CB 59     	CALL CHKCHAR
1543  5E52 29           	DB ')'
1544  5E53
1545  5E53 E5           	PUSH HL ; save position in BASIC buffer
1546  5E54
1547  5E54              	; calculate destination add to value
1548  5E54 21 00 01     	LD HL, 256
1549  5E57 22 27 57     	LD (BLIT_STRUCT+8), HL
1550  5E5A              	; calculate pointer to background location
1551  5E5A 3A 1E 57     	LD A,(BLIT_TMP+3)
1552  5E5D 67           	LD H,A
1553  5E5E 2E 00        	LD L,0
1554  5E60 EB           	EX DE,HL
1555  5E61 26 00        	LD H,0
1556  5E63 3A 1D 57     	LD A,(BLIT_TMP+2)
1557  5E66 6F           	LD L,A
1558  5E67 CD BA 58     	CALL HLx8
1559  5E6A 19           	ADD HL,DE
1560  5E6B ED 5B CB F3  	LD DE,(GRPCGP)
1561  5E6F 19           	ADD HL,DE
1562  5E70 22 25 57     	LD (BLIT_STRUCT+6),HL
1563  5E73
1564  5E73 FD 21 7A 5E  	LD IY, .RET
1565  5E77 C3 7E 59     	JP ENABLE_PAGE0
1566  5E7A              .RET:
1567  5E7A FB           	EI
1568  5E7B              	; set RAM functions to call
1569  5E7B 21 95 5E     	LD HL, .TILECOPY
1570  5E7E 22 C4 5C     	LD (TILE.CALL2+1), HL
1571  5E81 21 9B 5E     	LD HL, .SETDESTROW
1572  5E84 22 B6 5C     	LD (TILE.CALL1+1), HL
1573  5E87 DD 21 1F 57  	LD IX,BLIT_STRUCT
1574  5E8B CD 9B 5C     	CALL TILE
1575  5E8E
1576  5E8E D1               POP DE
1577  5E8F C1               POP BC
1578  5E90 CD F5 58         CALL RESTORE_PAGE_INFO
1579  5E93
1580  5E93 E1           	POP HL
1581  5E94 C9           	RET
1582  5E95              .TILECOPY:
1583  5E95 01 98 08     	LD BC, #0898
1584  5E98 C3 B2 58     	JP BBYTECOPY_NO_C
1585  5E9B              .SETDESTROW:
1586  5E9B 2A 1B 57     	LD HL, (TILETMP1)
1587  5E9E F3           	DI
1588  5E9F CD A5 58     	CALL SETWRT_LOCAL
1589  5EA2 FB           	EI
1590  5EA3 C9           	RET
1591  5EA4              ; *******************************************************************************************************
1592  5EA4               ENDIF
1593  5EA4
1594  5EA4               IFNDEF CMDS_WITH_PARAMETERS
1595  5EA4 ~            ; *******************************************************************************************************
1596  5EA4 ~            ; function to handle CALL TILEVRM basic extension
1597  5EA4 ~            ; fills vram with tiles
1598  5EA4 ~            ; TILEVRM ( INT request_data_ptr )
1599  5EA4 ~            ; request_data_ptr described in TILE
1600  5EA4 ~            ; will put ram in page 0 also, page 1 is already there
1601  5EA4 ~            TILEVRM:
1602  5EA4 ~            	; opening (
1603  5EA4 ~            	CALL CHKCHAR
1604  5EA4 ~            	DB '('
1605  5EA4 ~            	; get pointer to request struct
1606  5EA4 ~            	LD IX, FRMQNT
1607  5EA4 ~            	CALL CALBAS
1608  5EA4 ~            	PUSH DE
1609  5EA4 ~            	; ending )
1610  5EA4 ~            	CALL CHKCHAR
1611  5EA4 ~            	DB ')'
1612  5EA4 ~
1613  5EA4 ~            	POP IX ; pointer to request struct
1614  5EA4 ~
1615  5EA4 ~            	PUSH HL ; save position in BASIC buffer
1616  5EA4 ~
1617  5EA4 ~            	LD IY, .RET
1618  5EA4 ~            	JP ENABLE_PAGE0
1619  5EA4 ~            .RET:
1620  5EA4 ~            	EI
1621  5EA4 ~            	; set RAM functions to call
1622  5EA4 ~            	LD HL, .TILECOPY
1623  5EA4 ~            	LD (TILE.CALL2+1), HL
1624  5EA4 ~            	LD HL, .SETDESTROW
1625  5EA4 ~            	LD (TILE.CALL1+1), HL
1626  5EA4 ~            	CALL TILE
1627  5EA4 ~
1628  5EA4 ~                POP DE
1629  5EA4 ~                POP BC
1630  5EA4 ~                CALL RESTORE_PAGE_INFO
1631  5EA4 ~
1632  5EA4 ~            	POP HL
1633  5EA4 ~            	RET
1634  5EA4 ~            .TILECOPY:
1635  5EA4 ~            	LD BC, #0898
1636  5EA4 ~            	JP BBYTECOPY_NO_C
1637  5EA4 ~            .SETDESTROW:
1638  5EA4 ~            	LD HL, (TILETMP1)
1639  5EA4 ~            	DI
1640  5EA4 ~            	CALL SETWRT_LOCAL
1641  5EA4 ~            	EI
1642  5EA4 ~            	RET
1643  5EA4 ~            ; *******************************************************************************************************
1644  5EA4               ENDIF
1645  5EA4               ENDIF
1646  5EA4
1647  5EA4               IF (BOX_CMDS == 1)
1648  5EA4              ; *******************************************************************************************************
1649  5EA4              ; generic function to implement rectangle data copy
1650  5EA4              ; should be modified to call appropriate function for memory or vram
1651  5EA4              ; input IX=pointer to following structure
1652  5EA4              ; +00 source data pointer
1653  5EA4              ; +02 num bytes in a row
1654  5EA4              ; +04 number of rows
1655  5EA4              ; +06 source add-to value till next row
1656  5EA4              ; +08 destination address
1657  5EA4              ; +10 destination add-to value till next row
1658  5EA4              ; modifies AF, BC, DE, HL
1659  5EA4              RECTANGLE_COPY:
1660  5EA4 DD 6E 00     	LD L, (IX+0)
1661  5EA7 DD 66 01     	LD H, (IX+1) ; source address
1662  5EAA DD 5E 08     	LD E, (IX+8)
1663  5EAD DD 56 09     	LD D, (IX+9) ; destination
1664  5EB0 DD 46 04     	LD B, (IX+4) ; row number
1665  5EB3              .L1:
1666  5EB3 C5           	PUSH BC
1667  5EB4 E5           		PUSH HL
1668  5EB5 D5           			PUSH DE
1669  5EB6 DD 4E 02     				LD C, (IX+2)
1670  5EB9 DD 46 03     				LD B, (IX+3) ; num bytes in a row
1671  5EBC              .CALL1:
1672  5EBC CD 00 00     				CALL 0 ; set destination address from DE
1673  5EBF              .CALL2:
1674  5EBF CD 00 00     				CALL 0 ; copy data fn
1675  5EC2 E1           			POP HL
1676  5EC3 DD 4E 0A     			LD C, (IX+10)
1677  5EC6 DD 46 0B     			LD B, (IX+11) ; destination add-to
1678  5EC9 09           			ADD HL, BC
1679  5ECA EB           			EX DE, HL
1680  5ECB E1           		POP HL
1681  5ECC DD 4E 06     		LD C, (IX+6)
1682  5ECF DD 46 07     		LD B, (IX+7) ; src add-to
1683  5ED2 09           		ADD HL, BC
1684  5ED3 C1           	POP BC
1685  5ED4 10 DD        	DJNZ .L1
1686  5ED6 C9           	RET
1687  5ED7              ; *******************************************************************************************************
1688  5ED7
1689  5ED7              ; *******************************************************************************************************
1690  5ED7              ; function to handle CALL BOXMEMCPY basic extension
1691  5ED7              ; copies data with window like boundaries to ram
1692  5ED7              ; BOXMEMCPY ( INT request_data_ptr )
1693  5ED7              ; request_data_ptr described in RECTANGLE_COPY
1694  5ED7              ; will put ram in page 0 also, page 1 is already there
1695  5ED7              BOXMEMCPY:
1696  5ED7              	; opening (
1697  5ED7 CD CB 59     	CALL CHKCHAR
1698  5EDA 28           	DB '('
1699  5EDB              	; get pointer to request struct
1700  5EDB DD 21 2F 54  	LD IX, FRMQNT
1701  5EDF CD 59 01     	CALL CALBAS
1702  5EE2 D5           	PUSH DE
1703  5EE3              	; ending )
1704  5EE3 CD CB 59     	CALL CHKCHAR
1705  5EE6 29           	DB ')'
1706  5EE7
1707  5EE7 DD E1        	POP IX ; pointer to request struct
1708  5EE9
1709  5EE9 E5           	PUSH HL ; save position in BASIC buffer
1710  5EEA
1711  5EEA FD 21 F1 5E  	LD IY, .RET
1712  5EEE C3 7E 59     	JP ENABLE_PAGE0
1713  5EF1              .RET:
1714  5EF1 FB           	EI
1715  5EF2              	; set RAM functions to call
1716  5EF2 21 00 00     	LD HL, 0
1717  5EF5 22 BC 5E     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
1718  5EF8 22 BE 5E     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
1719  5EFB 21 ED B0     	LD HL, #B0ED ; LDIR
1720  5EFE 22 C0 5E     	LD (RECTANGLE_COPY.CALL1+4), HL
1721  5F01 CD A4 5E     	CALL RECTANGLE_COPY
1722  5F04
1723  5F04 D1               POP DE
1724  5F05 C1               POP BC
1725  5F06 CD F5 58         CALL RESTORE_PAGE_INFO
1726  5F09
1727  5F09 E1           	POP HL
1728  5F0A C9           	RET
1729  5F0B              ; *******************************************************************************************************
1730  5F0B
1731  5F0B              ; *******************************************************************************************************
1732  5F0B              ; function to handle CALL BOXMEMVRM basic extension
1733  5F0B              ; copies data with window like boundaries to ram
1734  5F0B              ; BOXMEMVRM ( INT request_data_ptr )
1735  5F0B              ; request_data_ptr described in RECTANGLE_COPY
1736  5F0B              ; will put ram in page 0 also, page 1 is already there
1737  5F0B              BOXMEMVRM:
1738  5F0B              	; opening (
1739  5F0B CD CB 59     	CALL CHKCHAR
1740  5F0E 28           	DB '('
1741  5F0F              	; get pointer to request struct
1742  5F0F DD 21 2F 54  	LD IX, FRMQNT
1743  5F13 CD 59 01     	CALL CALBAS
1744  5F16 D5           	PUSH DE
1745  5F17              	; ending )
1746  5F17 CD CB 59     	CALL CHKCHAR
1747  5F1A 29           	DB ')'
1748  5F1B
1749  5F1B DD E1        	POP IX ; pointer to request struct
1750  5F1D
1751  5F1D E5           	PUSH HL ; save position in BASIC buffer
1752  5F1E
1753  5F1E FD 21 25 5F  	LD IY, .RET
1754  5F22 C3 7E 59     	JP ENABLE_PAGE0
1755  5F25              .RET:
1756  5F25 FB           	EI
1757  5F26              	; set RAM functions to call
1758  5F26 21 4B 5F     	LD HL, .SETDEST
1759  5F29 22 BD 5E     	LD (RECTANGLE_COPY.CALL1+1), HL
1760  5F2C 21 53 5F     	LD HL, .COPYDATA
1761  5F2F 22 C0 5E     	LD (RECTANGLE_COPY.CALL2+1), HL
1762  5F32 3E CD        	LD A, #CD ; CALL
1763  5F34 32 BC 5E     	LD (RECTANGLE_COPY.CALL1), A
1764  5F37 32 BF 5E     	LD (RECTANGLE_COPY.CALL2), A
1765  5F3A              	;LD A,1
1766  5F3A 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
1767  5F3D CD A4 5E     	CALL RECTANGLE_COPY
1768  5F40 AF           	XOR A
1769  5F41 32 30 57     	LD (VRAM_UPDATE_IN_PROGRESS),A
1770  5F44
1771  5F44 D1               POP DE
1772  5F45 C1               POP BC
1773  5F46 CD F5 58         CALL RESTORE_PAGE_INFO
1774  5F49
1775  5F49 E1           	POP HL
1776  5F4A C9           	RET
1777  5F4B              .SETDEST:
1778  5F4B EB           	EX DE, HL
1779  5F4C F3           	DI
1780  5F4D CD A5 58     	CALL SETWRT_LOCAL
1781  5F50 FB           	EI
1782  5F51 EB           	EX DE, HL
1783  5F52 C9           	RET
1784  5F53              .COPYDATA:
1785  5F53 41           	LD B, C
1786  5F54 C3 B0 58     	JP BBYTECOPY
1787  5F57              ; *******************************************************************************************************
1788  5F57               ENDIF
1789  5F57
1790  5F57              EXT_END:
1791  5F57
# file closed: asm\main.asm
