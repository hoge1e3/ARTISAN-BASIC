# file opened: asm\main.asm
  1   0000               ORG 04000h
  2   4000
  3   4000              ; control variables to include/exclude parts of code
  4   4000              SOUND_CMDS	 	EQU 1
  5   4000              RAM_CMDS 		EQU 1
  6   4000              VRAM_CMDS 		EQU 1
  7   4000              BLIT_CMDS		EQU 1
  8   4000              SPRITE_CMDS 	EQU 1
  9   4000              GENCAL_CMD		EQU 1
 10   4000              TILE_CMDS		EQU 1
 11   4000              BOX_CMDS		EQU 1
 12   4000              ANIM_CMDS		EQU 1
 13   4000
 14   4000               DEFINE CMDS_WITH_PARAMETERS
 15   4000
 16   4000              CHPUT   EQU     #A2
 17   4000              CALBAS	EQU		#159
 18   4000              ERRHAND EQU     #406F
 19   4000              FRMEVL  EQU     #4C64
 20   4000              FRESTR	EQU		#67D0
 21   4000              ; FRMQNT = formula quantificator
 22   4000              ; input HL=pointer to current program expression
 23   4000              ; output HL=next address
 24   4000              ; output DE=integer datum
 25   4000              FRMQNT	EQU		#542F
 26   4000              ; GETBYT = get byte parameter
 27   4000              ; input HL=pointer to current program expression
 28   4000              ; output HL=next address
 29   4000              ; output A=E=byte read
 30   4000              GETBYT		EQU		#521C
 31   4000              CHRGTR  	EQU     #4666
 32   4000              PTRGET		EQU 	#5EA4
 33   4000              SUBFLG		EQU		#F6A5
 34   4000              SYNCHR		EQU		#558C
 35   4000              VALTYP  	EQU     #F663
 36   4000              USR     	EQU     #F7F8
 37   4000              PROCNM		EQU		#FD89
 38   4000              BIOS_FILVRM EQU     #0056
 39   4000              CLIKSW		EQU		#F3DB
 40   4000              ATRBAS		EQU		#F928
 41   4000              GRPCGP		EQU		#F3CB
 42   4000
 43   4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
 44   4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
 45   4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
 46   4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
 47   4000              EXPTBL	EQU #FCC1
 48   4000              SCRMOD	EQU #FCAF ; current screen mode
 49   4000              REG1SAV EQU #F3E0 ; VDP(1)
 50   4000              JIFFY	EQU #FC9E
 51   4000              GRPPAT	EQU #F3CF ; SCREEN 2 sprite generator table address
 52   4000              T32PAT	EQU #F3C5 ; SCREEN 1 sprite generator table address
 53   4000              PATBAS  EQU #F926 ; current sprite generator table address
 54   4000
 55   4000              ; BASIC error codes
 56   4000              ;01 NEXT without FOR
 57   4000              ;02 Syntax error
 58   4000              ;03 RETURN without GOSUB
 59   4000              ;04 Out of DATA
 60   4000              ;05 Illegal function call
 61   4000              ;06 Overflow
 62   4000              ;07 Out of memory
 63   4000              ;08 Undefined line number
 64   4000              ;09 Subscript out of range
 65   4000              ;10 Redimensioned array
 66   4000              ;11 Division by zero
 67   4000              ;12 Illegal direct
 68   4000              ;13 Type mismatch
 69   4000              ;14 Out of string space
 70   4000              ;15 String too long
 71   4000              ;16 String formula too complex
 72   4000              ;17 Can't CONTINUE
 73   4000              ;18 Undefined user function
 74   4000              ;19 Device I/O error
 75   4000              ;20 Verify error
 76   4000              ;21 No RESUME
 77   4000              ;22 RESUME without error
 78   4000              ;23 Unprintable error
 79   4000              ;24 Missing operand
 80   4000              ;25 Line buffer overflow
 81   4000              ;50 FIELD overflow
 82   4000              ;51 Internal error
 83   4000              ;52 Bad file number
 84   4000              ;53 File not found
 85   4000              ;54 File already open
 86   4000              ;55 Input past end
 87   4000              ;56 Bad file name
 88   4000              ;57 Direct statement in file
 89   4000              ;58 Sequential I/O only
 90   4000              ;59 File not OPEN
 91   4000
 92   4000
 93   4000               ; simulate cartridge with BASIC extension
 94   4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 94   4004 15 5F 00 00
 94   4008 00 00 00 00
 94   400C 00 00 00 00
 95   4010
 96   4010              ; this location #4010 stores last location used by basic extension
 97   4010              ; free memory after that point
 98   4010              FREEMEMPTR:
 99   4010 AE 5F         DW EXT_END
100   4012
101   4012              ; this location #4012 stores extension version in DAA format
102   4012              ; first byte is major version and second minor
103   4012              VERSION:
104   4012 00 70         DB #00, #70
105   4014
106   4014              ; binary included AKG player compiled at #4014
107   4014               IF (SOUND_CMDS == 1)
108   4014              	INCBIN "bin/AKG.bin"
109   4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
  1+  4CF0              MAIN_PLAYER_START EQU 04014H
  2+  4CF0              PLY_AKG_START EQU 04014H
  3+  4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
  4+  4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
  5+  4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
  6+  4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
  7+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
  8+  4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
  9+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
 10+  4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
 11+  4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
 12+  4CF0              PLY_AKG_PSES_PLAY EQU 04090H
 13+  4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
 14+  4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
 15+  4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
 16+  4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
 17+  4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
 18+  4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
 19+  4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
 20+  4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
 21+  4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
 22+  4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
 23+  4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
 24+  4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
 25+  4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
 26+  4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
 27+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
 28+  4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
 29+  4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
 30+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
 31+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
 32+  4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
 33+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
 34+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
 35+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
 36+  4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
 37+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
 38+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
 39+  4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
 40+  4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
 41+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
 42+  4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
 43+  4CF0              PLY_AKG_INIT EQU 04162H
 44+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
 45+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
 46+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
 47+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
 48+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
 49+  4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
 50+  4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
 51+  4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
 52+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
 53+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
 54+  4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
 55+  4CF0              PLY_AKG_INITTABLE1 EQU 04205H
 56+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
 57+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
 58+  4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
 59+  4CF0              PLY_AKG_INITTABLEORA EQU 04209H
 60+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
 61+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
 62+  4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
 63+  4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
 64+  4CF0              PLY_AKG_STOP EQU 04221H
 65+  4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
 66+  4CF0              PLY_AKG_PLAY EQU 04233H
 67+  4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
 68+  4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
 69+  4CF0              PLY_AKG_READLINKER EQU 04246H
 70+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
 71+  4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
 72+  4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
 73+  4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
 74+  4CF0              PLY_AKG_READLINE EQU 0428DH
 75+  4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
 76+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
 77+  4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
 78+  4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
 79+  4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
 80+  4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
 81+  4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
 82+  4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
 83+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
 84+  4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
 85+  4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
 86+  4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
 87+  4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
 88+  4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
 89+  4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
 90+  4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
 91+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
 92+  4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
 93+  4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
 94+  4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
 95+  4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
 96+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
 97+  4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
 98+  4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
 99+  4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
100+  4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
101+  4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
102+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
103+  4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
104+  4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
105+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
106+  4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
107+  4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
108+  4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
109+  4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
110+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
111+  4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
112+  4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
113+  4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
114+  4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
115+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
116+  4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
117+  4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
118+  4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
119+  4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
120+  4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
121+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
122+  4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
123+  4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
124+  4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
125+  4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
126+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
127+  4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
128+  4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
129+  4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
130+  4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
131+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
132+  4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
133+  4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
134+  4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
135+  4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
136+  4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
137+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
138+  4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
139+  4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
140+  4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
141+  4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
142+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
143+  4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
144+  4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
145+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
146+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
147+  4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
148+  4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
149+  4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
150+  4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
151+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
152+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
153+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
154+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
155+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
156+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
157+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
158+  4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
159+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
160+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
161+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
162+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
163+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
164+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
165+  4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
166+  4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
167+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
168+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
169+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
170+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
171+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
172+  4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
173+  4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
174+  4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
175+  4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
176+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
177+  4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
178+  4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
179+  4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
180+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
181+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
182+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
183+  4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
184+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
185+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
186+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
187+  4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
188+  4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
189+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
190+  4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
191+  4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
192+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
193+  4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
194+  4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
195+  4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
196+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
197+  4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
198+  4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
199+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
200+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
201+  4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
202+  4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
203+  4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
204+  4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
205+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
206+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
207+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
208+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
209+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
210+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
211+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
212+  4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
213+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
214+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
215+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
216+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
217+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
218+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
219+  4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
220+  4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
221+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
222+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
223+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
224+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
225+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
226+  4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
227+  4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
228+  4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
229+  4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
230+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
231+  4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
232+  4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
233+  4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
234+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
235+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
236+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
237+  4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
238+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
239+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
240+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
241+  4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
242+  4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
243+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
244+  4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
245+  4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
246+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
247+  4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
248+  4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
249+  4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
250+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
251+  4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
252+  4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
253+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
254+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
255+  4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
256+  4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
257+  4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
258+  4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
259+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
260+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
261+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
262+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
263+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
264+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
265+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
266+  4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
267+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
268+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
269+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
270+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
271+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
272+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
273+  4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
274+  4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
275+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
276+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
277+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
278+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
279+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
280+  4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
281+  4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
282+  4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
283+  4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
284+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
285+  4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
286+  4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
287+  4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
288+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
289+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
290+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
291+  4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
292+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
293+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
294+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
295+  4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
296+  4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
297+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
298+  4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
299+  4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
300+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
301+  4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
302+  4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
303+  4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
304+  4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
305+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
306+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
307+  4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
308+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
309+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
310+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
311+  4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
312+  4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
313+  4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
314+  4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
315+  4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
316+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
317+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
318+  4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
319+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
320+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
321+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
322+  4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
323+  4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
324+  4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
325+  4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
326+  4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
327+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
328+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
329+  4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
330+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
331+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
332+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
333+  4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
334+  4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
335+  4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
336+  4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
337+  4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
338+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
339+  4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
340+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
341+  4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
342+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
343+  4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
344+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
345+  4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
346+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
347+  4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
348+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
349+  4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
350+  4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
351+  4CF0              PLY_AKG_RETRIG EQU 04829H
352+  4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
353+  4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
354+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
355+  4CF0              PLY_AKG_SAVESP EQU 0483AH
356+  4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
357+  4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
358+  4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
359+  4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
360+  4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
361+  4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
362+  4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
363+  4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
364+  4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
365+  4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
366+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
367+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
368+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
369+  4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
370+  4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
371+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
372+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
373+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
374+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
375+  4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
376+  4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
377+  4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
378+  4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
379+  4CF0              PLY_AKG_SOFT EQU 048DFH
380+  4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
381+  4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
382+  4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
383+  4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
384+  4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
385+  4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
386+  4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
387+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
388+  4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
389+  4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
390+  4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
391+  4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
392+  4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
393+  4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
394+  4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
395+  4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
396+  4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
397+  4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
398+  4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
399+  4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
400+  4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
401+  4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
402+  4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
403+  4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
404+  4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
405+  4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
406+  4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
407+  4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
408+  4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
409+  4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
410+  4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
411+  4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
412+  4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
413+  4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
414+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
415+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
416+  4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
417+  4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
418+  4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
419+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
420+  4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
421+  4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
422+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
423+  4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
424+  4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
425+  4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
426+  4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
427+  4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
428+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
429+  4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
430+  4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
431+  4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
432+  4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
433+  4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
434+  4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
435+  4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
436+  4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
437+  4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
438+  4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
439+  4CF0              PLY_AKG_EVENT EQU 04BEFH
440+  4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
441+  4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
442+  4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
443+  4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
444+  4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
445+  4CF0              PLY_AKG_END EQU 04CF0H
446+  4CF0              MAIN_PLAYER_END EQU 04CF0H
447+  4CF0              TESTEREND EQU 04CF0H
448+  4CF0
# file closed: ./symbol/AKG.sym
110   4CF0               ENDIF
111   4CF0
112   4CF0               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
  1+  4CF0              ORIG.HTIMI:
  2+  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
  2+  4CF4 00
  3+  4CF5               EXPORT ORIG.HTIMI
  4+  4CF5
  5+  4CF5              ; *******************************************************************************************************
  6+  4CF5              ; interrupt handler when page 0 enabled
  7+  4CF5              ; we are here only if one of the extended basic commands have paged in page 0
  8+  4CF5              ; which means we arrived from BASIC so page 2 is already good
  9+  4CF5              VBLANK:
 10+  4CF5              	EXPORT VBLANK
 11+  4CF5
 12+  4CF5 F5               PUSH AF
 13+  4CF6              	; is VDP originator ?
 14+  4CF6 DB 99        	IN	A, (099H)
 15+  4CF8 A7           	AND	A
 16+  4CF9 F2 20 4D     	JP P, .EXIT
 17+  4CFC
 18+  4CFC               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 19+  4CFC C5               PUSH BC
 20+  4CFD D5               PUSH DE
 21+  4CFE E5               PUSH HL
 22+  4CFF 08               EX AF, AF'
 23+  4D00 D9               EXX
 24+  4D01 F5               PUSH AF
 25+  4D02 C5               PUSH BC
 26+  4D03 D5               PUSH DE
 27+  4D04 E5               PUSH HL
 28+  4D05 DD E5            PUSH IX
 29+  4D07 FD E5            PUSH IY
 30+  4D09
 31+  4D09               IF (SPRITE_CMDS == 1)
 32+  4D09 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 33+  4D0C               ENDIF
 34+  4D0C
 35+  4D0C               IF (SOUND_CMDS == 1)
 36+  4D0C 3A B1 54     	LD A, (SOUND_ENABLED)
 37+  4D0F B7           	OR A
 38+  4D10 C4 33 42     	CALL NZ,PLY_AKG_PLAY
 39+  4D13               ENDIF
 40+  4D13
 41+  4D13                  ; increase JIFFY
 42+  4D13                  ;LD HL,(JIFFY)
 43+  4D13                  ;INC HL
 44+  4D13                  ;LD (JIFFY),HL
 45+  4D13
 46+  4D13 FD E1            POP IY
 47+  4D15 DD E1            POP IX
 48+  4D17 E1               POP HL
 49+  4D18 D1               POP DE
 50+  4D19 C1               POP BC
 51+  4D1A F1               POP AF
 52+  4D1B 08               EX AF, AF'
 53+  4D1C D9               EXX
 54+  4D1D E1               POP HL
 55+  4D1E D1               POP DE
 56+  4D1F C1               POP BC
 57+  4D20               ENDIF
 58+  4D20
 59+  4D20              .EXIT:
 60+  4D20 F1           	POP AF
 61+  4D21 FB           	EI
 62+  4D22 ED 4D        	RETI
 63+  4D24              ; *******************************************************************************************************
 64+  4D24
 65+  4D24              ; *******************************************************************************************************
 66+  4D24              ; H.TIMI function
 67+  4D24              ; we can end up here from anywhere so page in both page 0 and 2
 68+  4D24              MBGE_HTIMI:
 69+  4D24               EXPORT MBGE_HTIMI
 70+  4D24
 71+  4D24               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 72+  4D24
 73+  4D24 F5           	PUSH AF
 74+  4D25
 75+  4D25              	; enable page 2
 76+  4D25 3E 02            LD A, 2
 77+  4D27 CD 45 5E         CALL GET_PAGE_INFO
 78+  4D2A C5               PUSH BC
 79+  4D2B D5               PUSH DE
 80+  4D2C 3A 43 F3         LD A, (RAMAD2)
 81+  4D2F 26 80            LD H, 080H
 82+  4D31 CD 8C 5E         CALL LOCAL_ENASLT
 83+  4D34              	; enable page 0
 84+  4D34 AF               XOR A
 85+  4D35 CD 45 5E         CALL GET_PAGE_INFO
 86+  4D38 C5               PUSH BC
 87+  4D39 D5               PUSH DE
 88+  4D3A 3A 41 F3         LD A, (RAMAD0)
 89+  4D3D 26 00            LD H, 0
 90+  4D3F CD 8C 5E         CALL LOCAL_ENASLT
 91+  4D42
 92+  4D42               IF (SPRITE_CMDS == 1)
 93+  4D42 CD 5A 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
 94+  4D45               ENDIF
 95+  4D45
 96+  4D45               IF (SOUND_CMDS == 1)
 97+  4D45 3A B1 54     	LD A, (SOUND_ENABLED)
 98+  4D48 B7           	OR A
 99+  4D49 C4 33 42     	CALL NZ,PLY_AKG_PLAY
100+  4D4C               ENDIF
101+  4D4C
102+  4D4C              	; restore page 0
103+  4D4C D1               POP DE
104+  4D4D C1               POP BC
105+  4D4E CD 7C 5E         CALL RESTORE_PAGE_INFO
106+  4D51              	; restore page 2
107+  4D51 D1               POP DE
108+  4D52 C1               POP BC
109+  4D53 CD 7C 5E         CALL RESTORE_PAGE_INFO
110+  4D56
111+  4D56 F1           	POP AF
112+  4D57               ENDIF
113+  4D57 C3 F0 4C     	JP ORIG.HTIMI
114+  4D5A              ; *******************************************************************************************************
115+  4D5A
116+  4D5A              ; *******************************************************************************************************
117+  4D5A              ; function checks if the sprite system is initialized and what screen mode we are running
118+  4D5A              ; also checks if some VRAM modifying command is running
119+  4D5A              ; when that checks out calls sprite updates and animation processing
120+  4D5A              PROCESS_SPRITES_AND_ANIMATIONS:
121+  4D5A              	; check if initialized
122+  4D5A 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
123+  4D5D B7           	OR A
124+  4D5E C8           	RET Z
125+  4D5F              	; check screen mode
126+  4D5F 3A AF FC     	LD A, (SCRMOD)
127+  4D62 3D           	DEC A
128+  4D63 28 02        	JR Z, .L0 ; screen 1
129+  4D65 3D           	DEC A
130+  4D66 C0           	RET NZ ; not screen 2
131+  4D67              .L0:
132+  4D67                  ; check if anyone else is working with VRAM
133+  4D67 3A AC 5C         LD A,(VRAM_UPDATE_IN_PROGRESS)
134+  4D6A B7               OR A
135+  4D6B C0               RET NZ
136+  4D6C
137+  4D6C CD 88 4D         CALL SPRATR_UPDATE
138+  4D6F
139+  4D6F               IF (ANIM_CMDS == 1)
140+  4D6F CD 2F 53         CALL PROCESS_ANIMATIONS
141+  4D72               ENDIF
142+  4D72 C9               RET
143+  4D73              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
113   4D73
114   4D73               IF (SPRITE_CMDS == 1)
115   4D73               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
  1+  4D73              ; commands and variables related to sprites
  2+  4D73
  3+  4D73              SPRATR_INIT_STATUS:
  4+  4D73 00            DB 0
  5+  4D74              SPRATR_UPDATE_FLAG:
  6+  4D74 00 00         DW 0
  7+  4D76              SPRATR_DATA:
  8+  4D76 00 00         DW 0
  9+  4D78              SPRFLICKER_ENABLED:
 10+  4D78 00            DB 0
 11+  4D79              ; to support sprite flicker
 12+  4D79              FLICKER:
 13+  4D79 00            DB 0
 14+  4D7A
 15+  4D7A              ; to temporarily store stack pointer
 16+  4D7A              TMPSP:
 17+  4D7A 00 00         DW 0
 18+  4D7C
 19+  4D7C              ; *******************************************************************************************************
 20+  4D7C              ; helper function gets pointer to n-th entry in sprite attributes
 21+  4D7C              ; changes HL,DE;
 22+  4D7C              GETnthSPRATTR:
 23+  4D7C 26 00            LD H,0
 24+  4D7E 6F               LD L,A
 25+  4D7F CD 41 5E         CALL HLx8
 26+  4D82 ED 5B 76 4D      LD DE,(SPRATR_DATA)
 27+  4D86 19               ADD HL,DE
 28+  4D87 C9               RET
 29+  4D88              ; *******************************************************************************************************
 30+  4D88
 31+  4D88              ; *******************************************************************************************************
 32+  4D88              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
 33+  4D88              ; struct {
 34+  4D88              ; DW y
 35+  4D88              ; DW x
 36+  4D88              ; DW pattern (0-63)
 37+  4D88              ; DW color
 38+  4D88              ; } [32]
 39+  4D88              ; will hide sprites whose location is outside of visible area
 40+  4D88              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
 41+  4D88              ; modifies AF, AF', BC, DE, HL
 42+  4D88              SPRATR_UPDATE:
 43+  4D88              	; check if update requested
 44+  4D88 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 45+  4D8B 7E           	LD A, (HL)
 46+  4D8C B7           	OR A
 47+  4D8D C8           	RET Z
 48+  4D8E              .L0:
 49+  4D8E 06 20        	LD B, 32 ; sprite number
 50+  4D90 0E 98        	LD C, #98 ; register for vdp data output
 51+  4D92              	; set VDP address
 52+  4D92 2A 28 F9     	LD HL, (ATRBAS)
 53+  4D95 3A 78 4D     	LD A, (SPRFLICKER_ENABLED)
 54+  4D98 B7           	OR A
 55+  4D99 28 03        	JR Z, .L3
 56+  4D9B 3A 79 4D     	LD A, (FLICKER)
 57+  4D9E              .L3:
 58+  4D9E 5F           	LD E, A
 59+  4D9F 08           	EX AF, AF'
 60+  4DA0 7B           	LD A, E
 61+  4DA1 87           	ADD A, A
 62+  4DA2 87           	ADD A, A
 63+  4DA3 16 00        	LD D, 0
 64+  4DA5 5F           	LD E, A
 65+  4DA6 19           	ADD HL, DE
 66+  4DA7 CD 2C 5E     	CALL SETWRT_LOCAL
 67+  4DAA ED 73 7A 4D  	LD (TMPSP), SP
 68+  4DAE ED 7B 76 4D  	LD SP, (SPRATR_DATA)
 69+  4DB2
 70+  4DB2              .LOOP:
 71+  4DB2 E1           	POP HL
 72+  4DB3 24           	INC H
 73+  4DB4 28 0D        	JR Z, .L1 ; negative number above -256
 74+  4DB6 25           	DEC H
 75+  4DB7 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
 76+  4DB9 7D           	LD A, L
 77+  4DBA FE C0        	CP 192
 78+  4DBC 30 10        	JR NC, .OUT3
 79+  4DBE 3D           	DEC A ; due to VDP rule that top of screen is -1
 80+  4DBF 57           	LD D, A
 81+  4DC0 C3 E7 4D     	JP .X
 82+  4DC3              .L1:
 83+  4DC3 7D           	LD A, L
 84+  4DC4 C6 10        	ADD 16
 85+  4DC6 FA CE 4D     	JP M, .OUT3 ; below -16
 86+  4DC9 2D           	DEC L ; due to VDP rule that top of screen is -1
 87+  4DCA 55           	LD D, L
 88+  4DCB C3 E7 4D     	JP .X
 89+  4DCE              .OUT3:
 90+  4DCE E1           	POP HL ; skip x value
 91+  4DCF              .OUT2:
 92+  4DCF E1           	POP HL ; skip pattern
 93+  4DD0 E1           	POP HL ; skip color
 94+  4DD1 3E D1        	LD A, #D1
 95+  4DD3 ED 79        	OUT (C), A ; sprite hidden
 96+  4DD5 00          > NOP
 96+  4DD6 00          > NOP
 96+  4DD7 00          > NOP
 97+  4DD8 ED 79        	OUT (C), A ; value unimportant
 98+  4DDA 00          > NOP
 98+  4DDB 00          > NOP
 98+  4DDC 00          > NOP
 99+  4DDD ED 79        	OUT (C), A ; value unimportant
100+  4DDF 00          > NOP
100+  4DE0 00          > NOP
100+  4DE1 00          > NOP
101+  4DE2 ED 79        	OUT (C), A ; value unimportant
102+  4DE4 C3 12 4E     	JP .NEXT
103+  4DE7              .X:
104+  4DE7 E1           	POP HL
105+  4DE8 24           	INC H
106+  4DE9 28 08        	JR Z, .L2
107+  4DEB 25           	DEC H
108+  4DEC 20 E1        	JR NZ, .OUT2
109+  4DEE 1E 00        	LD E, 0 ; EC bit
110+  4DF0 C3 FC 4D     	JP .XY
111+  4DF3              .L2:
112+  4DF3 7D           	LD A, L
113+  4DF4 C6 20        	ADD 32
114+  4DF6 FA CF 4D     	JP M, .OUT2
115+  4DF9 6F           	LD L, A
116+  4DFA 1E 80        	LD E, #80
117+  4DFC              .XY:
118+  4DFC ED 51        	OUT (C), D
119+  4DFE 3A E0 F3     	LD A, (REG1SAV)
120+  4E01 E6 02        	AND 2
121+  4E03 ED 69        	OUT (C), L
122+  4E05 E1           	POP HL ; pattern
123+  4E06 7D           	LD A, L
124+  4E07 28 02        	JR Z, .SMALLSPRITES
125+  4E09 87           	ADD A, A
126+  4E0A 87           	ADD A, A ; needs to go at 4x
127+  4E0B              .SMALLSPRITES:
128+  4E0B D3 98        	OUT (#98), A
129+  4E0D E1           	POP HL ; color
130+  4E0E 7D           	LD A, L
131+  4E0F B3           	OR E
132+  4E10 D3 98        	OUT (#98), A
133+  4E12              .NEXT:
134+  4E12 08           	EX AF, AF'
135+  4E13 3C           	INC A
136+  4E14 E6 1F        	AND 31
137+  4E16 C2 2A 4E     	JP NZ, .NEXT2
138+  4E19 08           	EX AF, AF'
139+  4E1A 2A 28 F9     	LD HL, (ATRBAS)
140+  4E1D              	; CALL SETWRT_LOCAL not allowed as SP modified
141+  4E1D 7D           	LD	A, L
142+  4E1E D3 99        	OUT	(099H), A
143+  4E20 7C           	LD	A, H
144+  4E21 E6 3F        	AND	03FH
145+  4E23 F6 40        	OR	040H
146+  4E25 D3 99        	OUT	(099H), A
147+  4E27 C3 2B 4E     	JP .NEXT3
148+  4E2A              .NEXT2:
149+  4E2A 08           	EX AF, AF'
150+  4E2B              .NEXT3:
151+  4E2B 10 85        	DJNZ .LOOP
152+  4E2D 08           	EX AF, AF'
153+  4E2E 3C           	INC A
154+  4E2F 32 79 4D     	LD (FLICKER), A
155+  4E32
156+  4E32 ED 7B 7A 4D  	LD SP, (TMPSP)
157+  4E36 2A 74 4D     	LD HL, (SPRATR_UPDATE_FLAG)
158+  4E39 36 00        	LD (HL), 0 ; zero out update flag
159+  4E3B C9           	RET
160+  4E3C              ; *******************************************************************************************************
161+  4E3C
162+  4E3C              ; *******************************************************************************************************
163+  4E3C              ; function to handle CALL SPRENABLE basic extension
164+  4E3C              ; initializes sprites handler
165+  4E3C              ; _SPRENABLE ( INT[][] sprites_attributes,
166+  4E3C              ;			   INT update_variable,
167+  4E3C              ;			   BYTE sprite_flicker_enabled )
168+  4E3C              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
169+  4E3C              SPRENABLE:
170+  4E3C              	; opening (
171+  4E3C CD 52 5F     	CALL CHKCHAR
172+  4E3F 28           	DB '('
173+  4E40              	; get address of sprite attribute table DIM SA%(3,31)
174+  4E40 3E 02        	LD A,2
175+  4E42 06 02        	LD B,2
176+  4E44 11 20 04     	LD DE,#0420
177+  4E47 CD 79 5F     	CALL GET_BASIC_ARRAY_DATA_POINTER
178+  4E4A C5           	PUSH BC
179+  4E4B              	; comma
180+  4E4B CD 52 5F     	CALL CHKCHAR
181+  4E4E 2C           	DB ','
182+  4E4F              	; get address of sprite update flag
183+  4E4F DD 21 A4 5E  	LD IX, PTRGET
184+  4E53 CD 59 01     	CALL CALBAS
185+  4E56 D5           	PUSH DE
186+  4E57              	; comma
187+  4E57 CD 52 5F     	CALL CHKCHAR
188+  4E5A 2C           	DB ','
189+  4E5B              	; get flicker enabled flag
190+  4E5B DD 21 1C 52  	LD IX, GETBYT
191+  4E5F CD 59 01     	CALL CALBAS
192+  4E62 F5           	PUSH AF
193+  4E63              	; ending )
194+  4E63 CD 52 5F     	CALL CHKCHAR
195+  4E66 29           	DB ')'
196+  4E67
197+  4E67 F1           	POP AF ; get flicker flag
198+  4E68 B7           	OR A
199+  4E69 32 78 4D     	LD (SPRFLICKER_ENABLED), A
200+  4E6C
201+  4E6C D1           	POP DE ; update variable location
202+  4E6D ED 53 74 4D  	LD (SPRATR_UPDATE_FLAG), DE
203+  4E71 D1           	POP DE ; address of sprite attribute table
204+  4E72 ED 53 76 4D  	LD (SPRATR_DATA), DE
205+  4E76 3E 01        	LD A, 1
206+  4E78 32 73 4D     	LD (SPRATR_INIT_STATUS), A
207+  4E7B C9           	RET
208+  4E7C              ; *******************************************************************************************************
209+  4E7C
210+  4E7C              ; *******************************************************************************************************
211+  4E7C              ; function to handle CALL SPRDISABLE basic extension
212+  4E7C              ; disables sprites handling
213+  4E7C              ; _SPRDISABLE
214+  4E7C              ; resets variable SPRATR_INIT_STATUS
215+  4E7C              SPRDISABLE:
216+  4E7C AF           	XOR A
217+  4E7D 32 73 4D     	LD (SPRATR_INIT_STATUS), A
218+  4E80 C9           	RET
219+  4E81              ; *******************************************************************************************************
220+  4E81
221+  4E81              ; *******************************************************************************************************
222+  4E81              ; function to handle CALL SPRSET basic extension
223+  4E81              ; sets position, and optionally pattern and color of sprite
224+  4E81              ; _SPRSET ( BYTE sprite_num , valid 0-31
225+  4E81              ;			INT x,
226+  4E81              ;			INT y,
227+  4E81              ;			INT pattern, valid 0-63, otherwise ignored
228+  4E81              ;			INT color, valid 0-15, otherwise ignored
229+  4E81              SPRSET:
230+  4E81 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
231+  4E84 B7           	OR A
232+  4E85 20 05        	JR NZ, .L1
233+  4E87 1E 05        	LD E, 5 ; illegal function call
234+  4E89 C3 72 5F     	JP THROW_ERROR
235+  4E8C              .L1:
236+  4E8C              	; opening (
237+  4E8C CD 52 5F     	CALL CHKCHAR
238+  4E8F 28           	DB '('
239+  4E90              	; get sprite number
240+  4E90 DD 21 1C 52  	LD IX, GETBYT
241+  4E94 CD 59 01     	CALL CALBAS
242+  4E97 F5           	PUSH AF
243+  4E98              	; comma
244+  4E98 CD 52 5F     	CALL CHKCHAR
245+  4E9B 2C           	DB ','
246+  4E9C              	; get x
247+  4E9C DD 21 2F 54  	LD IX, FRMQNT
248+  4EA0 CD 59 01     	CALL CALBAS
249+  4EA3 D5           	PUSH DE
250+  4EA4              	; comma
251+  4EA4 CD 52 5F     	CALL CHKCHAR
252+  4EA7 2C           	DB ','
253+  4EA8              	; get y
254+  4EA8 DD 21 2F 54  	LD IX, FRMQNT
255+  4EAC CD 59 01     	CALL CALBAS
256+  4EAF D5           	PUSH DE
257+  4EB0              	; comma
258+  4EB0 CD 52 5F     	CALL CHKCHAR
259+  4EB3 2C           	DB ','
260+  4EB4              	; get pattern
261+  4EB4 DD 21 2F 54  	LD IX, FRMQNT
262+  4EB8 CD 59 01     	CALL CALBAS
263+  4EBB D5           	PUSH DE
264+  4EBC              	; comma
265+  4EBC CD 52 5F     	CALL CHKCHAR
266+  4EBF 2C           	DB ','
267+  4EC0              	; get color
268+  4EC0 DD 21 2F 54  	LD IX, FRMQNT
269+  4EC4 CD 59 01     	CALL CALBAS
270+  4EC7 D5           	PUSH DE
271+  4EC8              	; ending )
272+  4EC8 CD 52 5F     	CALL CHKCHAR
273+  4ECB 29           	DB ')'
274+  4ECC
275+  4ECC                  ; save position in BASIC text
276+  4ECC E5           	PUSH HL
277+  4ECD DD E1        	POP IX
278+  4ECF
279+  4ECF C1           	POP BC ; color
280+  4ED0 D1           	POP DE ; pattern
281+  4ED1 D9           	EXX
282+  4ED2 C1           	POP BC ; y
283+  4ED3 D1           	POP DE ; x
284+  4ED4 F1           	POP AF ; sprite number
285+  4ED5 FE 20        	CP 32
286+  4ED7 38 05        	JR C, .L2
287+  4ED9 1E 05        	LD E, 5 ; illegal function call
288+  4EDB C3 72 5F     	JP THROW_ERROR
289+  4EDE              .L2:
290+  4EDE              	; find location in sprite attributes table
291+  4EDE D5           	PUSH DE
292+  4EDF CD 7C 4D     	CALL GETnthSPRATTR
293+  4EE2 D1           	POP DE
294+  4EE3              	; set y
295+  4EE3 71           	LD (HL), C
296+  4EE4 23           	INC HL
297+  4EE5 70           	LD (HL), B
298+  4EE6 23           	INC HL
299+  4EE7              	; set x
300+  4EE7 73           	LD (HL), E
301+  4EE8 23           	INC HL
302+  4EE9 72           	LD (HL), D
303+  4EEA 23           	INC HL
304+  4EEB E5           	PUSH HL
305+  4EEC D9           	EXX
306+  4EED E1           	POP HL
307+  4EEE              	; check if 0<=pattern<64
308+  4EEE 7A           	LD A, D
309+  4EEF B7           	OR A
310+  4EF0 20 0B        	JR NZ, .L3
311+  4EF2 7B           	LD A, E
312+  4EF3 FE 40        	CP 64
313+  4EF5 30 06        	JR NC, .L3
314+  4EF7              	; set pattern
315+  4EF7              	;ADD A, A
316+  4EF7              	;ADD A, A
317+  4EF7              	;ADD A, A
318+  4EF7 77           	LD (HL), A
319+  4EF8 23           	INC HL
320+  4EF9 72           	LD (HL), D
321+  4EFA 23           	INC HL
322+  4EFB 18 02        	JR .L4
323+  4EFD              .L3:
324+  4EFD              	; skip pattern
325+  4EFD 23          > INC HL
325+  4EFE 23          > INC HL
326+  4EFF              .L4:
327+  4EFF              	; check if 0<=color<16
328+  4EFF 78           	LD A, B
329+  4F00 B7           	OR A
330+  4F01 20 08        	JR NZ, .L5
331+  4F03 79           	LD A, C
332+  4F04 FE 10        	CP 16
333+  4F06 30 03        	JR NC, .L5
334+  4F08              	; set color
335+  4F08 71           	LD (HL), C
336+  4F09 23           	INC HL
337+  4F0A 70           	LD (HL), B
338+  4F0B
339+  4F0B              .L5:
340+  4F0B DD E5        	PUSH IX
341+  4F0D E1           	POP HL
342+  4F0E C9           	RET
343+  4F0F              ; *******************************************************************************************************
344+  4F0F
345+  4F0F              ; *******************************************************************************************************
346+  4F0F              ; function sets sprite location based on initial coordinates and offset provided
347+  4F0F              ; input A=sprite number in SPRATR_DATA , 0-31
348+  4F0F              ; input DE=initial x
349+  4F0F              ; input BC=initial y
350+  4F0F              ; input IY=location where delta y,x are located
351+  4F0F              ; modifies AF, HL, IX
352+  4F0F              SPRSET_DELTA_POS:
353+  4F0F D5           	PUSH DE
354+  4F10 CD 7C 4D     	CALL GETnthSPRATTR
355+  4F13 E5           	PUSH HL
356+  4F14 DD E1        	POP IX
357+  4F16 D1           	POP DE
358+  4F17              	; IX=sprite's y location
359+  4F17 FD 6E 00     	LD L, (IY)
360+  4F1A FD 66 01     	LD H, (IY+1)
361+  4F1D 09           	ADD HL, BC
362+  4F1E DD 75 00     	LD (IX), L
363+  4F21 DD 74 01     	LD (IX+1), H
364+  4F24 FD 6E 02     	LD L, (IY+2)
365+  4F27 FD 66 03     	LD H, (IY+3)
366+  4F2A 19           	ADD HL, DE
367+  4F2B DD 75 02     	LD (IX+2), L
368+  4F2E DD 74 03     	LD (IX+3), H
369+  4F31 C9           	RET
370+  4F32              ; *******************************************************************************************************
371+  4F32
372+  4F32              ; *******************************************************************************************************
373+  4F32              ; function to handle CALL SPRGRPMOV basic extension
374+  4F32              ; sets position of a group of sprites described with
375+  4F32              ; { int sprite_num, int delta_y, int delta_x } [count]
376+  4F32              ; _SPRGRPMOV ( INT x,
377+  4F32              ;			   INT y,
378+  4F32              ;			   BYTE count,
379+  4F32              ;			   INT[2][count] data_ptr
380+  4F32              ; will put ram in page 0 also, page 1 is already there
381+  4F32              SPRGRPMOV:
382+  4F32 3A 73 4D     	LD A, (SPRATR_INIT_STATUS)
383+  4F35 B7           	OR A
384+  4F36 20 05        	JR NZ, .L1
385+  4F38 1E 05        	LD E, 5 ; illegal function call
386+  4F3A C3 72 5F     	JP THROW_ERROR
387+  4F3D              .L1:
388+  4F3D              	; opening (
389+  4F3D CD 52 5F     	CALL CHKCHAR
390+  4F40 28           	DB '('
391+  4F41              	; get x
392+  4F41 DD 21 2F 54  	LD IX, FRMQNT
393+  4F45 CD 59 01     	CALL CALBAS
394+  4F48 D5           	PUSH DE
395+  4F49              	; comma
396+  4F49 CD 52 5F     	CALL CHKCHAR
397+  4F4C 2C           	DB ','
398+  4F4D              	; get y
399+  4F4D DD 21 2F 54  	LD IX, FRMQNT
400+  4F51 CD 59 01     	CALL CALBAS
401+  4F54 D5           	PUSH DE
402+  4F55              	; comma
403+  4F55 CD 52 5F     	CALL CHKCHAR
404+  4F58 2C           	DB ','
405+  4F59              	; get count
406+  4F59 DD 21 1C 52  	LD IX, GETBYT
407+  4F5D CD 59 01     	CALL CALBAS
408+  4F60 F5           	PUSH AF
409+  4F61              	; comma
410+  4F61 CD 52 5F     	CALL CHKCHAR
411+  4F64 2C           	DB ','
412+  4F65              	; get sprite group definition array data pointer
413+  4F65 D1           	POP DE
414+  4F66 D5           	PUSH DE
415+  4F67 5A           	LD E,D
416+  4F68 16 03        	LD D,3
417+  4F6A 3E 02        	LD A,2
418+  4F6C 47           	LD B,A
419+  4F6D CD 79 5F     	CALL GET_BASIC_ARRAY_DATA_POINTER
420+  4F70 C5           	PUSH BC
421+  4F71              	; ending )
422+  4F71 CD 52 5F     	CALL CHKCHAR
423+  4F74 29           	DB ')'
424+  4F75
425+  4F75 E5           	PUSH HL
426+  4F76 DD E1        	POP IX
427+  4F78
428+  4F78 E1           	POP HL ; data pointer
429+  4F79 C1           	POP BC ; count
430+  4F7A D9           	EXX
431+  4F7B C1           	POP BC ; y
432+  4F7C D1           	POP DE ; x
433+  4F7D D9           	EXX
434+  4F7E
435+  4F7E DD E5        	PUSH IX ; save position in BASIC buffer
436+  4F80
437+  4F80 C5           	PUSH BC
438+  4F81 E5           	PUSH HL
439+  4F82 AF               XOR A
440+  4F83 CD 45 5E         CALL GET_PAGE_INFO
441+  4F86 D9           	EXX
442+  4F87 E1           	POP HL
443+  4F88 F1           	POP AF
444+  4F89 D9           	EXX
445+  4F8A C5               PUSH BC
446+  4F8B D5               PUSH DE
447+  4F8C D9           	EXX
448+  4F8D F5           	PUSH AF
449+  4F8E E5           	PUSH HL
450+  4F8F D9           	EXX
451+  4F90 3A 41 F3         LD A, (RAMAD0)
452+  4F93 26 00            LD H, 0
453+  4F95 CD 8C 5E         CALL LOCAL_ENASLT
454+  4F98 FB           	EI
455+  4F99 E1           	POP HL
456+  4F9A C1           	POP BC
457+  4F9B CD A5 4F     	CALL .UPDATE_LOC
458+  4F9E D1               POP DE
459+  4F9F C1               POP BC
460+  4FA0 CD 7C 5E         CALL RESTORE_PAGE_INFO
461+  4FA3 E1           	POP HL
462+  4FA4 C9           	RET
463+  4FA5
464+  4FA5              .UPDATE_LOC:
465+  4FA5              .L4:
466+  4FA5 7E           	LD A, (HL)
467+  4FA6 23           	INC HL
468+  4FA7 23           	INC HL
469+  4FA8 E5           	PUSH HL
470+  4FA9 FD E1        	POP IY
471+  4FAB D9           	EXX
472+  4FAC CD 0F 4F     	CALL SPRSET_DELTA_POS
473+  4FAF D9           	EXX
474+  4FB0 23          > INC HL
474+  4FB1 23          > INC HL
474+  4FB2 23          > INC HL
474+  4FB3 23          > INC HL
475+  4FB4 10 EF        	DJNZ .L4
476+  4FB6 C9           	RET
477+  4FB7              ; *******************************************************************************************************
478+  4FB7
# file closed: asm\SPRITES.asm
116   4FB7               ENDIF
117   4FB7
118   4FB7               IF (ANIM_CMDS == 1)
119   4FB7               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
  1+  4FB7              ; sprite animation routines
  2+  4FB7
  3+  4FB7              ; number of animation items and pointer
  4+  4FB7              ANIMITEMNUM:
  5+  4FB7 00            DB 0
  6+  4FB8              ANIMITEMPTR:
  7+  4FB8 AE 5F         DW EXT_END
  8+  4FBA              ; number of animation definitions and pointer
  9+  4FBA              ANIMDEFNUM:
 10+  4FBA 00            DB 0
 11+  4FBB              ANIMDEFPTR:
 12+  4FBB AE 5F         DW EXT_END
 13+  4FBD              ; number of links between sprite and animation definitions
 14+  4FBD              ANIMSPRNUM:
 15+  4FBD 00            DB 0
 16+  4FBE              ANIMSPRPTR:
 17+  4FBE AE 5F         DW EXT_END
 18+  4FC0
 19+  4FC0              ; ANIMATION ITEM
 20+  4FC0              ; byte type = [0 - pattern and color change
 21+  4FC0              ;              1 - pattern definition change ]
 22+  4FC0              ; word ticks - number of ticks to hold this state
 23+  4FC0              ; for type = 0
 24+  4FC0              ;   byte pattern;
 25+  4FC0              ;   byte color;
 26+  4FC0              ; for type = 1
 27+  4FC0              ;   work data_pointer;
 28+  4FC0              ; total size = 5b
 29+  4FC0
 30+  4FC0              ; ANIMATION DEFINITION
 31+  4FC0              ; byte number of items 1-15
 32+  4FC0              ; byte[15] anim_item;
 33+  4FC0              ; total size = 16b
 34+  4FC0
 35+  4FC0              ; SPRITE ANIMATION
 36+  4FC0              ; +00 byte sprite number;
 37+  4FC0              ; +01 word time;
 38+  4FC0              ; +03 byte current item;
 39+  4FC0              ; +04 byte animation definition;
 40+  4FC0              ; +05 byte cyclic;
 41+  4FC0              ; +06 byte active;
 42+  4FC0              ; +07 byte reserved
 43+  4FC0              ; total size = 8b
 44+  4FC0
 45+  4FC0              ; *******************************************************************************************************
 46+  4FC0              ; helper function HL=A*5
 47+  4FC0              ; changes HL,DE;
 48+  4FC0              Ax5:
 49+  4FC0 26 00            LD H,0
 50+  4FC2 6F               LD L,A
 51+  4FC3 54               LD D,H
 52+  4FC4 5D               LD E,L
 53+  4FC5 29               ADD HL,HL
 54+  4FC6 29               ADD HL,HL
 55+  4FC7 19               ADD HL,DE
 56+  4FC8 C9               RET
 57+  4FC9              ; *******************************************************************************************************
 58+  4FC9
 59+  4FC9              ; *******************************************************************************************************
 60+  4FC9              ; helper function gets pointer to n-th animation item
 61+  4FC9              ; changes HL,DE;
 62+  4FC9              GETnthANIMITEM:
 63+  4FC9 CD C0 4F         CALL Ax5
 64+  4FCC ED 5B B8 4F      LD DE,(ANIMITEMPTR)
 65+  4FD0 19               ADD HL,DE
 66+  4FD1 C9               RET
 67+  4FD2              ; *******************************************************************************************************
 68+  4FD2
 69+  4FD2              ; *******************************************************************************************************
 70+  4FD2              ; helper function gets pointer to n-th entry in animation definition
 71+  4FD2              ; changes HL,DE;
 72+  4FD2              GETnthANIMDEF:
 73+  4FD2 26 00            LD H,0
 74+  4FD4 6F               LD L,A
 75+  4FD5 CD 41 5E         CALL HLx8
 76+  4FD8 ED 5B BB 4F      LD DE,(ANIMDEFPTR)
 77+  4FDC 19               ADD HL,DE
 78+  4FDD C9               RET
 79+  4FDE              ; *******************************************************************************************************
 80+  4FDE
 81+  4FDE              ; *******************************************************************************************************
 82+  4FDE              ; helper function gets pointer to n-th entry in sprite animation
 83+  4FDE              ; changes HL,DE;
 84+  4FDE              GETnthSPRANIM:
 85+  4FDE 26 00            LD H,0
 86+  4FE0 6F               LD L,A
 87+  4FE1 CD 40 5E         CALL HLx16
 88+  4FE4 ED 5B BE 4F      LD DE,(ANIMSPRPTR)
 89+  4FE8 19               ADD HL,DE
 90+  4FE9 C9               RET
 91+  4FEA              ; *******************************************************************************************************
 92+  4FEA
 93+  4FEA              ; *******************************************************************************************************
 94+  4FEA              ; function to handle CALL MAXANIMITEMS basic extension
 95+  4FEA              ; MAXANIMITEMS (BYTE number)
 96+  4FEA              ; sets new number and moves memory buffers as needed
 97+  4FEA              MAXANIMITEMS:
 98+  4FEA              	; opening (
 99+  4FEA CD 52 5F     	CALL CHKCHAR
100+  4FED 28           	DB '('
101+  4FEE              	; get value
102+  4FEE DD 21 1C 52  	LD IX, GETBYT
103+  4FF2 CD 59 01     	CALL CALBAS
104+  4FF5 F5               PUSH AF
105+  4FF6              	; ending )
106+  4FF6 CD 52 5F     	CALL CHKCHAR
107+  4FF9 29           	DB ')'
108+  4FFA F1               POP AF
109+  4FFB
110+  4FFB              	; save position
111+  4FFB E5           	PUSH HL
112+  4FFC              .ENTRY:
113+  4FFC 47               LD B,A
114+  4FFD 3A B7 4F         LD A,(ANIMITEMNUM)
115+  5000 90               SUB B
116+  5001 28 1F            JR Z, .EXIT; same value as before
117+  5003 FD 21 BB 4F      LD IY,ANIMDEFPTR
118+  5007 FA 25 50         JP M, .INCREASE
119+  500A                  ; new value is lower than previous one
120+  500A CD 3D 50         CALL .SIZEDIFF
121+  500D CD 58 50         CALL .DECREASE_COMMON
122+  5010 2A BE 4F         LD HL,(ANIMSPRPTR)
123+  5013 AF               XOR A
124+  5014 ED 42            SBC HL,BC
125+  5016 22 BE 4F         LD (ANIMSPRPTR),HL
126+  5019              .E1:
127+  5019 2A 10 40         LD HL,(FREEMEMPTR)
128+  501C AF               XOR A
129+  501D ED 42            SBC HL,BC
130+  501F 22 10 40         LD (FREEMEMPTR),HL
131+  5022              .EXIT:
132+  5022 FB               EI
133+  5023 E1           	POP HL
134+  5024 C9           	RET
135+  5025              .INCREASE:
136+  5025 ED 44            NEG
137+  5027 CD 3D 50         CALL .SIZEDIFF
138+  502A CD 84 50         CALL .INCREASE_COMMON
139+  502D 2A BE 4F         LD HL,(ANIMSPRPTR)
140+  5030 09               ADD HL,BC
141+  5031 22 BE 4F         LD (ANIMSPRPTR),HL
142+  5034              .E2:
143+  5034 2A 10 40         LD HL,(FREEMEMPTR)
144+  5037 09               ADD HL,BC
145+  5038 22 10 40         LD (FREEMEMPTR),HL
146+  503B 18 E5            JR .EXIT
147+  503D              .SIZEDIFF:
148+  503D CD C0 4F         CALL Ax5
149+  5040 78               LD A,B
150+  5041 32 B7 4F         LD (ANIMITEMNUM),A
151+  5044 44               LD B,H
152+  5045 4D               LD C,L
153+  5046 C9               RET ; BC=size difference in bytes
154+  5047              .SIZETOMOVE:
155+  5047 D5               PUSH DE
156+  5048 2A 10 40         LD HL,(FREEMEMPTR)
157+  504B FD 5E 00         LD E,(IY)
158+  504E FD 56 01         LD D,(IY+1)
159+  5051 AF               XOR A
160+  5052 ED 52            SBC HL,DE
161+  5054 44               LD B,H
162+  5055 4D               LD C,L
163+  5056 D1               POP DE
164+  5057 C9               RET
165+  5058              .DECREASE_COMMON:
166+  5058 FD 6E 00         LD L,(IY)
167+  505B FD 66 01         LD H,(IY+1)
168+  505E AF               XOR A
169+  505F ED 42            SBC HL,BC
170+  5061 EB               EX DE,HL
171+  5062 C5               PUSH BC
172+  5063 CD 47 50         CALL .SIZETOMOVE
173+  5066 F3               DI
174+  5067 78               LD A,B
175+  5068 B1               OR C
176+  5069 28 08            JR Z,.L1
177+  506B FD 6E 00         LD L,(IY)
178+  506E FD 66 01         LD H,(IY+1)
179+  5071 ED B0            LDIR
180+  5073              .L1:
181+  5073 C1               POP BC
182+  5074 FD 6E 00         LD L,(IY)
183+  5077 FD 66 01         LD H,(IY+1)
184+  507A AF               XOR A
185+  507B ED 42            SBC HL,BC
186+  507D FD 75 00         LD (IY),L
187+  5080 FD 74 01         LD (IY+1),H
188+  5083 C9               RET
189+  5084              .INCREASE_COMMON:
190+  5084 2A 10 40         LD HL,(FREEMEMPTR)
191+  5087 2B               DEC HL
192+  5088 AF               XOR A
193+  5089 ED 42            SBC HL,BC
194+  508B EB               EX DE,HL
195+  508C C5               PUSH BC
196+  508D CD 47 50         CALL .SIZETOMOVE
197+  5090 F3               DI
198+  5091 78               LD A,B
199+  5092 B1               OR C
200+  5093 28 06            JR Z,.L2
201+  5095 2A 10 40         LD HL,(FREEMEMPTR)
202+  5098 2B               DEC HL
203+  5099 ED B8            LDDR
204+  509B              .L2:
205+  509B C1               POP BC
206+  509C FD 6E 00         LD L,(IY)
207+  509F FD 66 01         LD H,(IY+1)
208+  50A2 09               ADD HL,BC
209+  50A3 FD 75 00         LD (IY),L
210+  50A6 FD 74 01         LD (IY+1),H
211+  50A9 C9               RET
212+  50AA              ; *******************************************************************************************************
213+  50AA
214+  50AA              ; *******************************************************************************************************
215+  50AA              ; function to handle CALL ANIMITEMPAT basic extension
216+  50AA              ; ANIMITEMPAT ( BYTE id,
217+  50AA              ;               INT ticks,
218+  50AA              ;               BYTE pattern,
219+  50AA              ;               BYTE color )
220+  50AA              ; fills animation item data, returns an error if out of bounds
221+  50AA              ANIMITEMPAT:
222+  50AA                  ; opening (
223+  50AA CD 52 5F     	CALL CHKCHAR
224+  50AD 28           	DB '('
225+  50AE              	; get id
226+  50AE DD 21 1C 52  	LD IX, GETBYT
227+  50B2 CD 59 01     	CALL CALBAS
228+  50B5 F5               PUSH AF
229+  50B6                  ; check if out of bounds
230+  50B6 3C               INC A
231+  50B7 4F               LD C,A
232+  50B8 3A B7 4F         LD A,(ANIMITEMNUM)
233+  50BB B9               CP C
234+  50BC DA 68 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
235+  50BF              	; comma
236+  50BF CD 52 5F     	CALL CHKCHAR
237+  50C2 2C           	DB ','
238+  50C3              	; get ticks
239+  50C3 DD 21 2F 54  	LD IX, FRMQNT
240+  50C7 CD 59 01     	CALL CALBAS
241+  50CA D5           	PUSH DE
242+  50CB              	; comma
243+  50CB CD 52 5F     	CALL CHKCHAR
244+  50CE 2C           	DB ','
245+  50CF              	; get pattern
246+  50CF DD 21 1C 52  	LD IX, GETBYT
247+  50D3 CD 59 01     	CALL CALBAS
248+  50D6 F5               PUSH AF
249+  50D7              	; comma
250+  50D7 CD 52 5F     	CALL CHKCHAR
251+  50DA 2C           	DB ','
252+  50DB              	; get color
253+  50DB DD 21 1C 52  	LD IX, GETBYT
254+  50DF CD 59 01     	CALL CALBAS
255+  50E2 F5               PUSH AF
256+  50E3              	; ending )
257+  50E3 CD 52 5F     	CALL CHKCHAR
258+  50E6 29           	DB ')'
259+  50E7              .ENTRY:
260+  50E7 E5               PUSH HL
261+  50E8 DD E1            POP IX
262+  50EA D9               EXX
263+  50EB C1               POP BC ; color
264+  50EC D1               POP DE ; pattern
265+  50ED E1               POP HL ; ticks
266+  50EE D9               EXX
267+  50EF F1               POP AF
268+  50F0 CD C9 4F         CALL GETnthANIMITEM
269+  50F3 E5               PUSH HL
270+  50F4 FD E1            POP IY
271+  50F6 D9               EXX
272+  50F7 FD 36 00 00      LD (IY),0 ; type=0
273+  50FB FD 75 01         LD (IY+1),L
274+  50FE FD 74 02         LD (IY+2),H
275+  5101 FD 72 03         LD (IY+3),D
276+  5104 FD 70 04         LD (IY+4),B
277+  5107
278+  5107 DD E5            PUSH IX
279+  5109 E1               POP HL
280+  510A C9               RET
281+  510B              ; *******************************************************************************************************
282+  510B
283+  510B              ; *******************************************************************************************************
284+  510B              ; function to handle CALL ANIMITEMPTR basic extension
285+  510B              ; ANIMITEMPTR ( BYTE id,
286+  510B              ;               INT ticks,
287+  510B              ;               INT pointer,
288+  510B              ; fills animation item data, returns an error if out of bounds
289+  510B              ANIMITEMPTR_CMD:
290+  510B                  ; opening (
291+  510B CD 52 5F     	CALL CHKCHAR
292+  510E 28           	DB '('
293+  510F              	; get id
294+  510F DD 21 1C 52  	LD IX, GETBYT
295+  5113 CD 59 01     	CALL CALBAS
296+  5116 F5               PUSH AF
297+  5117                  ; check if out of bounds
298+  5117 3C               INC A
299+  5118 4F               LD C,A
300+  5119 3A B7 4F         LD A,(ANIMITEMNUM)
301+  511C B9               CP C
302+  511D DA 68 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
303+  5120              	; comma
304+  5120 CD 52 5F     	CALL CHKCHAR
305+  5123 2C           	DB ','
306+  5124              	; get ticks
307+  5124 DD 21 2F 54  	LD IX, FRMQNT
308+  5128 CD 59 01     	CALL CALBAS
309+  512B D5           	PUSH DE
310+  512C              	; comma
311+  512C CD 52 5F     	CALL CHKCHAR
312+  512F 2C           	DB ','
313+  5130              	; get pointer
314+  5130 DD 21 2F 54  	LD IX, FRMQNT
315+  5134 CD 59 01     	CALL CALBAS
316+  5137 D5           	PUSH DE
317+  5138              	; ending )
318+  5138 CD 52 5F     	CALL CHKCHAR
319+  513B 29           	DB ')'
320+  513C              .ENTRY:
321+  513C E5               PUSH HL
322+  513D DD E1            POP IX
323+  513F D9               EXX
324+  5140 D1               POP DE ; pointer
325+  5141 E1               POP HL ; ticks
326+  5142 D9               EXX
327+  5143 F1               POP AF
328+  5144 CD C9 4F         CALL GETnthANIMITEM
329+  5147 E5               PUSH HL
330+  5148 FD E1            POP IY
331+  514A D9               EXX
332+  514B FD 36 00 01      LD (IY),1 ; type=1
333+  514F FD 75 01         LD (IY+1),L
334+  5152 FD 74 02         LD (IY+2),H
335+  5155 FD 73 03         LD (IY+3),E
336+  5158 FD 72 04         LD (IY+4),D
337+  515B
338+  515B DD E5            PUSH IX
339+  515D E1               POP HL
340+  515E C9               RET
341+  515F              ; *******************************************************************************************************
342+  515F
343+  515F              ; *******************************************************************************************************
344+  515F              ; function to handle CALL MAXANIMDEFS basic extension
345+  515F              ; MAXANIMDEFS (BYTE number)
346+  515F              ; sets new number and moves memory buffers as needed
347+  515F              MAXANIMDEFS:
348+  515F              	; opening (
349+  515F CD 52 5F     	CALL CHKCHAR
350+  5162 28           	DB '('
351+  5163              	; get value
352+  5163 DD 21 1C 52  	LD IX, GETBYT
353+  5167 CD 59 01     	CALL CALBAS
354+  516A F5               PUSH AF
355+  516B              	; ending )
356+  516B CD 52 5F     	CALL CHKCHAR
357+  516E 29           	DB ')'
358+  516F F1               POP AF
359+  5170
360+  5170              	; save position
361+  5170 E5           	PUSH HL
362+  5171              .ENTRY:
363+  5171 47               LD B,A
364+  5172 3A BA 4F         LD A,(ANIMDEFNUM)
365+  5175 90               SUB B
366+  5176 CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
367+  5179 FD 21 BE 4F      LD IY,ANIMSPRPTR
368+  517D FA 89 51         JP M, .INCREASE
369+  5180                  ; new value is lower than previous one
370+  5180 CD 94 51         CALL .SIZEDIFF
371+  5183 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
372+  5186 C3 19 50         JP MAXANIMITEMS.E1
373+  5189              .INCREASE:
374+  5189 ED 44            NEG
375+  518B CD 94 51         CALL .SIZEDIFF
376+  518E CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
377+  5191 C3 34 50         JP MAXANIMITEMS.E2
378+  5194              .SIZEDIFF:
379+  5194 26 00            LD H,0
380+  5196 6F               LD L,A
381+  5197 CD 40 5E         CALL HLx16
382+  519A 78               LD A,B
383+  519B 32 BA 4F         LD (ANIMDEFNUM),A
384+  519E 44               LD B,H
385+  519F 4D               LD C,L
386+  51A0 C9               RET ; BC=size difference in bytes
387+  51A1              ; *******************************************************************************************************
388+  51A1
389+  51A1              ; *******************************************************************************************************
390+  51A1              ; function to handle CALL ANIMDEF basic extension
391+  51A1              ; ANIMITEMPAT ( BYTE id,
392+  51A1              ;               BYTE size,
393+  51A1              ;               INT[] list )
394+  51A1              ; fills animation definition data, returns an error if out of bounds, or invalid type
395+  51A1              ANIMDEF:
396+  51A1                  ; opening (
397+  51A1 CD 52 5F     	CALL CHKCHAR
398+  51A4 28           	DB '('
399+  51A5              	; get id
400+  51A5 DD 21 1C 52  	LD IX, GETBYT
401+  51A9 CD 59 01     	CALL CALBAS
402+  51AC F5               PUSH AF
403+  51AD                  ; check if out of bounds
404+  51AD 3C               INC A
405+  51AE 4F               LD C,A
406+  51AF 3A BA 4F         LD A,(ANIMDEFNUM)
407+  51B2 B9               CP C
408+  51B3 DA 68 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
409+  51B6              	; comma
410+  51B6 CD 52 5F     	CALL CHKCHAR
411+  51B9 2C           	DB ','
412+  51BA              	; get size
413+  51BA DD 21 1C 52  	LD IX, GETBYT
414+  51BE CD 59 01     	CALL CALBAS
415+  51C1 FE 10            CP 16
416+  51C3 D2 6C 5F         JP NC, OVERFLOW
417+  51C6 B7               OR A
418+  51C7 CA 6C 5F         JP Z, OVERFLOW
419+  51CA F5           	PUSH AF
420+  51CB              	; comma
421+  51CB CD 52 5F     	CALL CHKCHAR
422+  51CE 2C           	DB ','
423+  51CF              	; get pointer to a list of animation items in integer array format
424+  51CF                  ; get array pointer
425+  51CF D1               POP DE
426+  51D0 D5               PUSH DE
427+  51D1 3E 02            LD A,2
428+  51D3 06 01            LD B,1
429+  51D5 CD 79 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
430+  51D8 C5               PUSH BC
431+  51D9              	; ending )
432+  51D9 CD 52 5F     	CALL CHKCHAR
433+  51DC 29           	DB ')'
434+  51DD              .ENTRY:
435+  51DD E5               PUSH HL
436+  51DE DD E1            POP IX
437+  51E0 D1               POP DE ; pointer to INT array
438+  51E1 C1               POP BC ; B=item number
439+  51E2 F1               POP AF ; id
440+  51E3 D5               PUSH DE
441+  51E4 CD D2 4F         CALL GETnthANIMDEF
442+  51E7 D1               POP DE
443+  51E8 70               LD (HL),B
444+  51E9              .L1:
445+  51E9 23               INC HL
446+  51EA 1A               LD A,(DE)
447+  51EB 13          > INC DE
447+  51EC 13          > INC DE
448+  51ED 77               LD (HL),A
449+  51EE 10 F9            DJNZ .L1
450+  51F0 DD E5            PUSH IX
451+  51F2 E1               POP HL
452+  51F3 C9               RET
453+  51F4              ; *******************************************************************************************************
454+  51F4
455+  51F4              ; *******************************************************************************************************
456+  51F4              ; function to handle CALL MAXANIMSPRS basic extension
457+  51F4              ; MAXANIMSPRS (BYTE number)
458+  51F4              ; sets new number and moves memory buffers as needed
459+  51F4              MAXANIMSPRS:
460+  51F4              	; opening (
461+  51F4 CD 52 5F     	CALL CHKCHAR
462+  51F7 28           	DB '('
463+  51F8              	; get value
464+  51F8 DD 21 1C 52  	LD IX, GETBYT
465+  51FC CD 59 01     	CALL CALBAS
466+  51FF F5               PUSH AF
467+  5200              	; ending )
468+  5200 CD 52 5F     	CALL CHKCHAR
469+  5203 29           	DB ')'
470+  5204 F1               POP AF
471+  5205
472+  5205              	; save position
473+  5205 E5           	PUSH HL
474+  5206              .ENTRY:
475+  5206 47               LD B,A
476+  5207 3A BD 4F         LD A,(ANIMSPRNUM)
477+  520A 90               SUB B
478+  520B CA 22 50         JP Z, MAXANIMITEMS.EXIT; same value as before
479+  520E FD 21 10 40      LD IY,FREEMEMPTR
480+  5212 FA 1E 52         JP M, .INCREASE
481+  5215                  ; new value is lower than previous one
482+  5215 CD 3D 52         CALL .SIZEDIFF
483+  5218 CD 58 50         CALL MAXANIMITEMS.DECREASE_COMMON
484+  521B C3 22 50         JP MAXANIMITEMS.EXIT
485+  521E              .INCREASE:
486+  521E ED 44            NEG
487+  5220 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
488+  5221 CD 3D 52         CALL .SIZEDIFF
489+  5224 CD 84 50         CALL MAXANIMITEMS.INCREASE_COMMON
490+  5227 AF               XOR A
491+  5228 ED 42            SBC HL,BC ; location of new stuff
492+  522A F1               POP AF
493+  522B 47               LD B,A
494+  522C 11 08 00         LD DE,8
495+  522F E5               PUSH HL
496+  5230 DD E1            POP IX
497+  5232              .L1:
498+  5232 DD 36 06 00      LD (IX+6),0
499+  5236 DD 19            ADD IX,DE
500+  5238 10 F8            DJNZ .L1
501+  523A C3 22 50         JP MAXANIMITEMS.EXIT
502+  523D              .SIZEDIFF:
503+  523D 26 00            LD H,0
504+  523F 6F               LD L,A
505+  5240 CD 41 5E         CALL HLx8
506+  5243 78               LD A,B
507+  5244 32 BD 4F         LD (ANIMSPRNUM),A
508+  5247 44               LD B,H
509+  5248 4D               LD C,L
510+  5249 C9               RET ; BC=size difference in bytes
511+  524A              ; *******************************************************************************************************
512+  524A
513+  524A              ; *******************************************************************************************************
514+  524A              ; function to handle CALL ANIMSPRITE basic extension
515+  524A              ; ANIMSPRITE ( BYTE id,
516+  524A              ;              BYTE sprite_number,
517+  524A              ;              BYTE animation_definition_id,
518+  524A              ;              BYTE cyclic_flag )
519+  524A              ; fills sprite animation data, returns an error if out of bounds, or invalid type
520+  524A              ANIMSPRITE:
521+  524A                  ; opening (
522+  524A CD 52 5F     	CALL CHKCHAR
523+  524D 28           	DB '('
524+  524E              	; get sprite animation id
525+  524E DD 21 1C 52  	LD IX, GETBYT
526+  5252 CD 59 01     	CALL CALBAS
527+  5255 F5               PUSH AF
528+  5256 3C               INC A
529+  5257 4F               LD C,A
530+  5258 3A BD 4F         LD A,(ANIMSPRNUM)
531+  525B B9               CP C
532+  525C DA 68 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
533+  525F              	; comma
534+  525F CD 52 5F     	CALL CHKCHAR
535+  5262 2C           	DB ','
536+  5263              	; get sprite number
537+  5263 DD 21 1C 52  	LD IX, GETBYT
538+  5267 CD 59 01     	CALL CALBAS
539+  526A F5               PUSH AF
540+  526B                  ; check if out of bounds
541+  526B FE 20            CP 32
542+  526D D2 68 5F         JP NC, SUBSCRIPT_OUT_OF_RANGE
543+  5270              	; comma
544+  5270 CD 52 5F     	CALL CHKCHAR
545+  5273 2C           	DB ','
546+  5274              	; get animation definition id
547+  5274 DD 21 1C 52  	LD IX, GETBYT
548+  5278 CD 59 01     	CALL CALBAS
549+  527B F5               PUSH AF
550+  527C 3C               INC A
551+  527D 4F               LD C,A
552+  527E 3A BA 4F         LD A,(ANIMDEFNUM)
553+  5281 B9               CP C
554+  5282 DA 68 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
555+  5285              	; comma
556+  5285 CD 52 5F     	CALL CHKCHAR
557+  5288 2C           	DB ','
558+  5289              	; get cyclic flag
559+  5289 DD 21 1C 52  	LD IX, GETBYT
560+  528D CD 59 01         CALL CALBAS
561+  5290 F5           	PUSH AF
562+  5291              	; ending )
563+  5291 CD 52 5F     	CALL CHKCHAR
564+  5294 29           	DB ')'
565+  5295              .ENTRY:
566+  5295 E5               PUSH HL
567+  5296 DD E1            POP IX
568+  5298 D9               EXX
569+  5299 D1               POP DE ; cyclic
570+  529A C1               POP BC ; animation definition id
571+  529B E1               POP HL ; sprite number
572+  529C D9               EXX
573+  529D F1               POP AF ; sprite animation id
574+  529E CD DE 4F         CALL GETnthSPRANIM
575+  52A1 E5               PUSH HL
576+  52A2 FD E1            POP IY
577+  52A4 D9               EXX
578+  52A5 FD 74 00         LD (IY),H
579+  52A8 FD 70 04         LD (IY+4),B
580+  52AB FD 72 05         LD (IY+5),D
581+  52AE                  ;LD (IY+6),0
582+  52AE DD E5            PUSH IX
583+  52B0 E1               POP HL
584+  52B1 C9               RET
585+  52B2              ; *******************************************************************************************************
586+  52B2
587+  52B2              ; *******************************************************************************************************
588+  52B2              ; function to handle CALL ANIMSTEP basic extension
589+  52B2              ; two forms
590+  52B2              ; ANIMSTEP ( BYTE id )
591+  52B2              ; or
592+  52B2              ; ANIMSTEP ( BYTE item_number,
593+  52B2              ;            INT[] sprite_animations )
594+  52B2              ; sets active flag to 1
595+  52B2              ANIMSTEP:
596+  52B2 11 25 53         LD DE,ANIMSTARTSTOP_COMMON.STEP
597+  52B5 18 08            JR ANIMSTARTSTOP_COMMON
598+  52B7              ; *******************************************************************************************************
599+  52B7              ; *******************************************************************************************************
600+  52B7              ; function to handle CALL ANIMSTART basic extension
601+  52B7              ; two forms
602+  52B7              ; ANIMSTART ( BYTE id )
603+  52B7              ; or
604+  52B7              ; ANIMSTART ( BYTE item_number,
605+  52B7              ;             INT[] sprite_animations )
606+  52B7              ; sets active flag to 1
607+  52B7              ANIMSTART:
608+  52B7 11 1D 53         LD DE,ANIMSTARTSTOP_COMMON.START
609+  52BA 18 03            JR ANIMSTARTSTOP_COMMON
610+  52BC              ; *******************************************************************************************************
611+  52BC              ; *******************************************************************************************************
612+  52BC              ; function to handle CALL ANIMSTOP basic extension
613+  52BC              ; two forms
614+  52BC              ; ANIMSTOP ( BYTE id )
615+  52BC              ; or
616+  52BC              ; ANIMSTOP ( BYTE item_number,
617+  52BC              ;            INT[] sprite_animations )
618+  52BC              ; sets active flag to 1
619+  52BC              ANIMSTOP:
620+  52BC 11 2A 53         LD DE,ANIMSTARTSTOP_COMMON.STOP
621+  52BF              ; *******************************************************************************************************
622+  52BF              ANIMSTARTSTOP_COMMON:
623+  52BF ED 53 1B 53      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
624+  52C3                  ; opening (
625+  52C3 CD 52 5F     	CALL CHKCHAR
626+  52C6 28           	DB '('
627+  52C7              	; get sprite animation id or array size
628+  52C7 DD 21 1C 52  	LD IX,GETBYT
629+  52CB CD 59 01     	CALL CALBAS
630+  52CE F5               PUSH AF
631+  52CF                  ; check if comma present
632+  52CF CD 5C 5F         CALL GETPREVCHAR
633+  52D2 23               INC HL
634+  52D3 FE 2C            CP ','
635+  52D5 28 0C            JR Z,.L1
636+  52D7 FE 29            CP ')'
637+  52D9 C2 70 5F         JP NZ,SYNTAX_ERROR
638+  52DC                  ; ok so single argument variant
639+  52DC F1               POP AF
640+  52DD E5               PUSH HL
641+  52DE CD 09 53         CALL .SETVALUE
642+  52E1 E1               POP HL
643+  52E2 C9               RET
644+  52E3              .L1:
645+  52E3                  ; get array pointer
646+  52E3 D1               POP DE
647+  52E4 D5               PUSH DE
648+  52E5 3E 02            LD A,2
649+  52E7 06 01            LD B,1
650+  52E9 CD 79 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
651+  52EC C5               PUSH BC
652+  52ED              	; ending )
653+  52ED CD 52 5F     	CALL CHKCHAR
654+  52F0 29           	DB ')'
655+  52F1 D1               POP DE ; array pointer
656+  52F2 C1               POP BC ; number of items
657+  52F3 78               LD A,B
658+  52F4 B7               OR A
659+  52F5 CA 68 5F         JP Z,SUBSCRIPT_OUT_OF_RANGE
660+  52F8 E5               PUSH HL
661+  52F9 F3               DI
662+  52FA              .L2:
663+  52FA C5               PUSH BC
664+  52FB 1A               LD A,(DE)
665+  52FC 13          > INC DE
665+  52FD 13          > INC DE
666+  52FE D5               PUSH DE
667+  52FF CD 09 53         CALL .SETVALUE
668+  5302 D1               POP DE
669+  5303 C1               POP BC
670+  5304 10 F4            DJNZ .L2
671+  5306 FB               EI
672+  5307 E1               POP HL
673+  5308 C9               RET
674+  5309
675+  5309              .SETVALUE:
676+  5309 47               LD B,A
677+  530A 3C               INC A
678+  530B 4F               LD C,A
679+  530C 3A BD 4F         LD A,(ANIMSPRNUM)
680+  530F B9               CP C
681+  5310 DA 68 5F         JP C,SUBSCRIPT_OUT_OF_RANGE
682+  5313 78               LD A,B
683+  5314 CD DE 4F         CALL GETnthSPRANIM
684+  5317 E5               PUSH HL
685+  5318 DD E1            POP IX
686+  531A              .FN:
687+  531A C3 00 00         JP 0
688+  531D              .START:
689+  531D DD 36 06 01      LD (IX+6),1 ; active flag
690+  5321 DD 36 03 00      LD (IX+3),0 ; current item
691+  5325              .STEP:
692+  5325 06 00            LD B,0 ; setup timer
693+  5327 C3 A9 53         JP SETUP_ANIM_STEP
694+  532A              .STOP:
695+  532A DD 36 06 00      LD (IX+6),0 ; active flag
696+  532E C9               RET
697+  532F              ; *******************************************************************************************************
698+  532F
699+  532F              ; *******************************************************************************************************
700+  532F              ; function processes animations during vblank period
701+  532F              PROCESS_ANIMATIONS:
702+  532F 3A BD 4F         LD A,(ANIMSPRNUM)
703+  5332 B7               OR A
704+  5333 C8               RET Z; no animations defined
705+  5334 47               LD B,A
706+  5335 DD 2A BE 4F      LD IX,(ANIMSPRPTR)
707+  5339              .L1:
708+  5339 C5               PUSH BC
709+  533A 06 00            LD B,0 ; normal mode, change on timer expiry only
710+  533C CD 48 53         CALL PROCESS_SINGLE_ANIMATION
711+  533F 11 08 00         LD DE,8
712+  5342 DD 19            ADD IX,DE
713+  5344 C1               POP BC
714+  5345 10 F2            DJNZ .L1
715+  5347 C9               RET
716+  5348              ; *******************************************************************************************************
717+  5348
718+  5348              ; *******************************************************************************************************
719+  5348              ; processes single sprite animation
720+  5348              ; skips inactive ones
721+  5348              ; on timer expiry goes to next animation item
722+  5348              ; input IX=sprite animation pointer
723+  5348              ; input B=1 force mode, activate animation action regardless of expired timer
724+  5348              PROCESS_SINGLE_ANIMATION:
725+  5348 DD 7E 06         LD A,(IX+6); active
726+  534B B7               OR A
727+  534C C8               RET Z ; inactive animation
728+  534D DD 6E 01         LD L,(IX+1)
729+  5350 DD 66 02         LD H,(IX+2) ; HL=end time
730+  5353 2B               DEC HL
731+  5354 DD 75 01         LD (IX+1),L
732+  5357 DD 74 02         LD (IX+2),H
733+  535A 7D               LD A,L
734+  535B B4               OR H
735+  535C 28 06            JR Z,.STEP
736+  535E 05               DEC B
737+  535F 04               INC B
738+  5360 C8               RET Z ; not forced mode, return
739+  5361 C3 A9 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
740+  5364              .STEP:
741+  5364 06 00            LD B,0; setup timer
742+  5366 DD 34 03         INC (IX+3) ; current animation item
743+  5369 C3 A9 53         JP SETUP_ANIM_STEP
744+  536C              ; *******************************************************************************************************
745+  536C
746+  536C              ; *******************************************************************************************************
747+  536C              ; function will setup sprite animation after current item change
748+  536C              ; input A=current animation definition
749+  536C              ; input IX=pointer to sprite animation
750+  536C              ; input B=1 skip timer setup
751+  536C              ; output IY=pointer to animation item
752+  536C              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
753+  536C              ; basically sets new end time for current animation
754+  536C              INIT_CURRENT_ANIMATION:
755+  536C CD D2 4F         CALL GETnthANIMDEF
756+  536F 7E               LD A,(HL); number of animation items in the animation definition
757+  5370 DD BE 03         CP (IX+3) ; current animation item
758+  5373 20 0A            JR NZ,.L3 ; last item not reached
759+  5375                  ; last item reached
760+  5375 DD 7E 05         LD A,(IX+5) ; cyclic flag
761+  5378 B7               OR A
762+  5379 28 2C            JR Z,.ERROR ; non-cyclic animation
763+  537B                  ; cyclic animation, restart
764+  537B DD 36 03 00      LD (IX+3),0; current item
765+  537F              .L3:
766+  537F                  ; HL = animation definition
767+  537F 23               INC HL ; skip animation definition size field
768+  5380 16 00            LD D,0
769+  5382 DD 5E 03         LD E,(IX+3); current item
770+  5385 19               ADD HL,DE
771+  5386 4E               LD C,(HL) ; current animation item
772+  5387 0C               INC C
773+  5388 3A B7 4F         LD A,(ANIMITEMNUM)
774+  538B B9               CP C
775+  538C 38 19            JR C,.ERROR ; invalid animation item, stop animation
776+  538E 0D               DEC C
777+  538F 79               LD A,C
778+  5390 CD C9 4F         CALL GETnthANIMITEM
779+  5393 E5               PUSH HL
780+  5394 FD E1            POP IY ; IY=animation item
781+  5396 05               DEC B
782+  5397 28 0C            JR Z,.EXIT
783+  5399 FD 5E 01         LD E,(IY+1)
784+  539C FD 56 02         LD D,(IY+2) ; duration
785+  539F DD 73 01         LD (IX+1),E
786+  53A2 DD 72 02         LD (IX+2),D
787+  53A5              .EXIT:
788+  53A5 AF               XOR A
789+  53A6 C9               RET
790+  53A7              .ERROR:
791+  53A7 37               SCF
792+  53A8 C9               RET
793+  53A9              ; *******************************************************************************************************
794+  53A9
795+  53A9              ; *******************************************************************************************************
796+  53A9              ; function will display currect item and set up expiry time
797+  53A9              ; it will also stop the animation if expired
798+  53A9              ; sets sprite update flag if any changes in sprite data made
799+  53A9              ; input IX=current sprite animation
800+  53A9              ; input B=1 skip timer setup
801+  53A9              SETUP_ANIM_STEP:
802+  53A9 DD 4E 04         LD C,(IX+4) ; animation definition ID
803+  53AC 0C               INC C
804+  53AD 3A BA 4F         LD A,(ANIMDEFNUM)
805+  53B0 B9               CP C
806+  53B1 30 05            JR NC,.L2
807+  53B3                  ; given animation item is outside of bounds, deactivate animation
808+  53B3              .STOPANIM:
809+  53B3 DD 36 06 00      LD (IX+6),0
810+  53B7 C9               RET
811+  53B8              .L2:
812+  53B8 0D               DEC C
813+  53B9 79               LD A,C
814+  53BA CD 6C 53         CALL INIT_CURRENT_ANIMATION
815+  53BD 38 F4            JR C, .STOPANIM
816+  53BF FD 7E 00         LD A,(IY) ; type of animation item
817+  53C2 B7               OR A
818+  53C3 CA F8 53         JP Z,.L4 ; change pattern and/or color
819+  53C6              .PAT:
820+  53C6                  ; change sprite pattern definition
821+  53C6 DD 7E 00         LD A,(IX) ; sprite number
822+  53C9 CD 7C 4D         CALL GETnthSPRATTR
823+  53CC 23          > INC HL ; skip y and x
823+  53CD 23          > INC HL
823+  53CE 23          > INC HL
823+  53CF 23          > INC HL
824+  53D0 7E               LD A,(HL); current pattern
825+  53D1 26 00            LD H,0
826+  53D3 6F               LD L,A
827+  53D4 3A E0 F3         LD A,(REG1SAV)
828+  53D7 E6 02            AND 2
829+  53D9 20 07            JR NZ,.L6
830+  53DB                  ; 8x8 sprite
831+  53DB CD 41 5E         CALL HLx8
832+  53DE 06 08            LD B,8
833+  53E0 18 05            JR .L5
834+  53E2              .L6:
835+  53E2 CD 3F 5E         CALL HLx32
836+  53E5 06 20            LD B,32
837+  53E7              .L5:
838+  53E7 ED 5B 26 F9      LD DE,(PATBAS)
839+  53EB 19               ADD HL,DE
840+  53EC CD 2C 5E         CALL SETWRT_LOCAL
841+  53EF FD 6E 03         LD L,(IY+3)
842+  53F2 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
843+  53F5 C3 37 5E         JP BBYTECOPY
844+  53F8              .L4:
845+  53F8                  ; change pattern and color in sprite attributes table
846+  53F8 DD 7E 00         LD A,(IX) ; sprite number
847+  53FB CD 7C 4D         CALL GETnthSPRATTR
848+  53FE 23          > INC HL ; skip y and x
848+  53FF 23          > INC HL
848+  5400 23          > INC HL
848+  5401 23          > INC HL
849+  5402 FD 7E 03         LD A,(IY+3) ; new pattern
850+  5405 77               LD (HL),A
851+  5406 23          > INC HL
851+  5407 23          > INC HL
852+  5408 FD 7E 04         LD A,(IY+4) ; new color
853+  540B 77               LD (HL),A
854+  540C 2A 74 4D         LD HL,(SPRATR_UPDATE_FLAG)
855+  540F 36 01            LD (HL),1
856+  5411 C9               RET
857+  5412              ; *******************************************************************************************************
858+  5412
# file closed: asm\ANIMATION.asm
120   5412               ENDIF
121   5412
122   5412               IF (RAM_CMDS == 1)
123   5412               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
  1+  5412              ; *******************************************************************************************************
  2+  5412              ; function to handle CALL MEMCPY basic extension
  3+  5412              ; _MEMCPY ( INT source,
  4+  5412              ;			INT destination,
  5+  5412              ;			INT count,
  6+  5412              ; will put ram in page 0 also, page 1 is already there
  7+  5412              MEMCPY:
  8+  5412              	; opening (
  9+  5412 CD 52 5F     	CALL CHKCHAR
 10+  5415 28           	DB '('
 11+  5416              	; get source address
 12+  5416 DD 21 2F 54  	LD IX, FRMQNT
 13+  541A CD 59 01     	CALL CALBAS
 14+  541D D5           	PUSH DE
 15+  541E              	; comma
 16+  541E CD 52 5F     	CALL CHKCHAR
 17+  5421 2C           	DB ','
 18+  5422              	; get destination address
 19+  5422 DD 21 2F 54  	LD IX, FRMQNT
 20+  5426 CD 59 01     	CALL CALBAS
 21+  5429 D5           	PUSH DE
 22+  542A              	; comma
 23+  542A CD 52 5F     	CALL CHKCHAR
 24+  542D 2C           	DB ','
 25+  542E              	; get length
 26+  542E DD 21 2F 54  	LD IX, FRMQNT
 27+  5432 CD 59 01     	CALL CALBAS
 28+  5435 D5           	PUSH DE
 29+  5436              	; ending )
 30+  5436 CD 52 5F     	CALL CHKCHAR
 31+  5439 29           	DB ')'
 32+  543A
 33+  543A              	; save position
 34+  543A E5           	PUSH HL
 35+  543B DD E1        	POP IX
 36+  543D
 37+  543D C1           	POP BC ; count
 38+  543E D1           	POP DE ; destination
 39+  543F E1           	POP HL ; source
 40+  5440 D9           	EXX
 41+  5441              	; enable page 0
 42+  5441 FD 21 48 54  	LD IY, .RET
 43+  5445 C3 05 5F     	JP ENABLE_PAGE0
 44+  5448              .RET:
 45+  5448 FB           	EI
 46+  5449 D9           	EXX
 47+  544A ED B0        	LDIR
 48+  544C D1               POP DE
 49+  544D C1               POP BC
 50+  544E CD 7C 5E         CALL RESTORE_PAGE_INFO
 51+  5451 DD E5        	PUSH IX
 52+  5453 E1           	POP HL
 53+  5454 C9           	RET
 54+  5455              ; *******************************************************************************************************
 55+  5455
 56+  5455              ; *******************************************************************************************************
 57+  5455              ; function to handle CALL FILRAM basic extension
 58+  5455              ; FILRAM ( INT start address,
 59+  5455              ;		   INT count,
 60+  5455              ;		   BYTE value,
 61+  5455              ; will put ram in page 0 also, page 1 is already there
 62+  5455              FILRAM:
 63+  5455              	; opening (
 64+  5455 CD 52 5F     	CALL CHKCHAR
 65+  5458 28           	DB '('
 66+  5459              	; get start address
 67+  5459 DD 21 2F 54  	LD IX, FRMQNT
 68+  545D CD 59 01     	CALL CALBAS
 69+  5460 D5           	PUSH DE
 70+  5461              	; comma
 71+  5461 CD 52 5F     	CALL CHKCHAR
 72+  5464 2C           	DB ','
 73+  5465              	; get count
 74+  5465 DD 21 2F 54  	LD IX, FRMQNT
 75+  5469 CD 59 01     	CALL CALBAS
 76+  546C D5           	PUSH DE
 77+  546D              	; comma
 78+  546D CD 52 5F     	CALL CHKCHAR
 79+  5470 2C           	DB ','
 80+  5471              	; get value
 81+  5471 DD 21 1C 52  	LD IX, GETBYT
 82+  5475 CD 59 01     	CALL CALBAS
 83+  5478 F5           	PUSH AF
 84+  5479              	; ending )
 85+  5479 CD 52 5F     	CALL CHKCHAR
 86+  547C 29           	DB ')'
 87+  547D
 88+  547D              	; save position
 89+  547D E5           	PUSH HL
 90+  547E DD E1        	POP IX
 91+  5480
 92+  5480 D1           	POP DE ; actually AF
 93+  5481 C1           	POP BC ; count
 94+  5482 E1           	POP HL ; start address
 95+  5483 78           	LD A, B
 96+  5484 B7           	OR A
 97+  5485 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 98+  5487 B1           	OR C
 99+  5488 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
100+  548A 79           	LD A, C
101+  548B 3D           	DEC A
102+  548C 20 03        	JR NZ, .L1 ; ; >1 byte to fill
103+  548E              	; one byte to fill
104+  548E 72           	LD (HL), D
105+  548F 18 12        	JR .EXIT
106+  5491              .L1:
107+  5491 D9           	EXX
108+  5492              	; enable page 0
109+  5492 FD 21 99 54  	LD IY, .RET
110+  5496 C3 05 5F     	JP ENABLE_PAGE0
111+  5499              .RET:
112+  5499 FB           	EI
113+  549A D9           	EXX
114+  549B CD A7 54     	CALL .FILLVALUE
115+  549E D1               POP DE
116+  549F C1               POP BC
117+  54A0 CD 7C 5E         CALL RESTORE_PAGE_INFO
118+  54A3              .EXIT:
119+  54A3 DD E5        	PUSH IX
120+  54A5 E1           	POP HL
121+  54A6 C9           	RET
122+  54A7
123+  54A7              .FILLVALUE:
124+  54A7 72               LD (HL), D
125+  54A8 54               LD D, H
126+  54A9 5D               LD E, L
127+  54AA 13               INC DE
128+  54AB 0B               DEC BC
129+  54AC ED B0            LDIR
130+  54AE C9               RET
131+  54AF              ; *******************************************************************************************************
132+  54AF
# file closed: asm\MEMORY.asm
124   54AF               ENDIF
125   54AF
126   54AF               IF (SOUND_CMDS == 1)
127   54AF               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
  1+  54AF              MUSIC_INIT_STATUS:
  2+  54AF 00            DB 0
  3+  54B0              SFX_INIT_STATUS:
  4+  54B0 00            DB 0
  5+  54B1              SOUND_ENABLED:
  6+  54B1 00            DB 0
  7+  54B2
  8+  54B2              ; *******************************************************************************************************
  9+  54B2              ; function to handle CALL SNDPLYINIT basic extension
 10+  54B2              ; initializes sound player
 11+  54B2              ; _SNDPLYINIT ( INT music_offset,
 12+  54B2              ;				INT sfx_offset, can be -1 if no SFX
 13+  54B2              ; will put ram in page 0 also, page 1 is already there
 14+  54B2              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
 15+  54B2              SNDPLYINIT:
 16+  54B2              	; opening (
 17+  54B2 CD 52 5F     	CALL CHKCHAR
 18+  54B5 28           	DB '('
 19+  54B6              	; get music address
 20+  54B6 DD 21 2F 54  	LD IX, FRMQNT
 21+  54BA CD 59 01     	CALL CALBAS
 22+  54BD D5           	PUSH DE
 23+  54BE              	; comma
 24+  54BE CD 52 5F     	CALL CHKCHAR
 25+  54C1 2C           	DB ','
 26+  54C2              	; get sfx address
 27+  54C2 DD 21 2F 54  	LD IX, FRMQNT
 28+  54C6 CD 59 01     	CALL CALBAS
 29+  54C9 D5           	PUSH DE
 30+  54CA              	; ending )
 31+  54CA CD 52 5F     	CALL CHKCHAR
 32+  54CD 29           	DB ')'
 33+  54CE
 34+  54CE                  ; save position in BASIC text
 35+  54CE 44           	LD B, H
 36+  54CF 4D           	LD C, L
 37+  54D0
 38+  54D0              	; pop LDIR parameters and store away for later
 39+  54D0 D1           	POP DE ; sfx address
 40+  54D1 E1           	POP HL ; music address
 41+  54D2 C5           	PUSH BC ; basic text location
 42+  54D3 D9           	EXX
 43+  54D4 FD 21 DB 54  	LD IY, .RET
 44+  54D8 C3 05 5F     	JP ENABLE_PAGE0
 45+  54DB              .RET:
 46+  54DB D9           	EXX
 47+  54DC
 48+  54DC D5           	PUSH DE
 49+  54DD AF           	XOR A
 50+  54DE              	; HL = music location
 51+  54DE CD 62 41     	CALL PLY_AKG_INIT
 52+  54E1 3E 01        	LD A, 1
 53+  54E3 32 AF 54     	LD (MUSIC_INIT_STATUS), A
 54+  54E6
 55+  54E6 E1           	POP HL ; SFX
 56+  54E7              	; check if SFX address -1
 57+  54E7 23           	INC HL
 58+  54E8 7D           	LD A, L
 59+  54E9 B4           	OR H
 60+  54EA 28 09        	JR Z,.L1
 61+  54EC 2B           	DEC HL
 62+  54ED CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 63+  54F0 3E 01        	LD A, 1
 64+  54F2 32 B0 54     	LD (SFX_INIT_STATUS), A
 65+  54F5              .L1:
 66+  54F5 D1               POP DE
 67+  54F6 C1               POP BC
 68+  54F7 CD 7C 5E         CALL RESTORE_PAGE_INFO
 69+  54FA
 70+  54FA E1           	POP HL
 71+  54FB C9           	RET
 72+  54FC              ; *******************************************************************************************************
 73+  54FC
 74+  54FC              ; *******************************************************************************************************
 75+  54FC              ; function to handle CALL SNDPLYON basic extension
 76+  54FC              ; enables sound player
 77+  54FC              ; _SNDPLYON
 78+  54FC              ; sets SOUND_ENABLED variable to 1 if init call was done
 79+  54FC              ; if not throws out of data error
 80+  54FC              SNDPLYON:
 81+  54FC 3A AF 54     	LD A, (MUSIC_INIT_STATUS)
 82+  54FF B7           	OR A
 83+  5500 20 05        	JR NZ, .L1
 84+  5502              	; player not initialized, throw error
 85+  5502 1E 04        	LD E, 04 ; Out of DATA
 86+  5504 C3 72 5F     	JP THROW_ERROR
 87+  5507              .L1:
 88+  5507 32 B1 54     	LD (SOUND_ENABLED), A
 89+  550A              	; disable key click
 90+  550A AF           	XOR A
 91+  550B 32 DB F3     	LD (CLIKSW), A
 92+  550E C9           	RET
 93+  550F              ; *******************************************************************************************************
 94+  550F
 95+  550F              ; *******************************************************************************************************
 96+  550F              ; function to handle CALL SNDPLYOFF basic extension
 97+  550F              ; disables sound player
 98+  550F              ; _SNDPLYOFF
 99+  550F              ; sets SOUND_ENABLED variable to 0
100+  550F              ; calls AKG to stop music and SFX on all channels if initialized
101+  550F              SNDPLYOFF:
102+  550F 3A B1 54     	LD A, (SOUND_ENABLED)
103+  5512 B7           	OR A
104+  5513 C8           	RET Z ; already stopped
105+  5514 AF           	XOR A
106+  5515 32 B1 54     	LD (SOUND_ENABLED), A
107+  5518 E5           	PUSH HL
108+  5519 CD 21 42     	CALL PLY_AKG_STOP
109+  551C 3A B0 54     	LD A, (SFX_INIT_STATUS)
110+  551F B7           	OR A
111+  5520 28 0E        	JR Z, .EXIT ; SFX not in use
112+  5522 AF           	XOR A
113+  5523 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
114+  5526 3E 01        	LD A, 1
115+  5528 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
116+  552B 3E 02        	LD A, 2
117+  552D CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
118+  5530              .EXIT:
119+  5530 E1           	POP HL
120+  5531 C9           	RET
121+  5532              ; *******************************************************************************************************
122+  5532
123+  5532              ; *******************************************************************************************************
124+  5532              ; function to handle CALL SNDSFX basic extension
125+  5532              ; plays a sound effect
126+  5532              ; _SNDSFX ( BYTE sfx_number, >0
127+  5532              ;			BYTE channel, = 0,1 or 2
128+  5532              ;			BYTE inverted_volume = 0-16, 0 being full volume
129+  5532              ; will put ram in page 0 also, page 1 is already there
130+  5532              ; if sound off throws illegal function call
131+  5532              ; if sfx not initialized, throws out of data
132+  5532              SNDSFX:
133+  5532              	; opening (
134+  5532 CD 52 5F     	CALL CHKCHAR
135+  5535 28           	DB '('
136+  5536              	; get sfx_number
137+  5536 DD 21 1C 52  	LD IX, GETBYT
138+  553A CD 59 01     	CALL CALBAS
139+  553D D5           	PUSH DE
140+  553E              	; comma
141+  553E CD 52 5F     	CALL CHKCHAR
142+  5541 2C           	DB ','
143+  5542              	; get sfx address
144+  5542 DD 21 1C 52  	LD IX, GETBYT
145+  5546 CD 59 01     	CALL CALBAS
146+  5549 D5           	PUSH DE
147+  554A              	; comma
148+  554A CD 52 5F     	CALL CHKCHAR
149+  554D 2C           	DB ','
150+  554E              	; get inverted volume
151+  554E DD 21 1C 52  	LD IX, GETBYT
152+  5552 CD 59 01     	CALL CALBAS
153+  5555 D5           	PUSH DE
154+  5556              	; ending )
155+  5556 CD 52 5F     	CALL CHKCHAR
156+  5559 29           	DB ')'
157+  555A
158+  555A 3A B1 54     	LD A, (SOUND_ENABLED)
159+  555D B7           	OR A
160+  555E 20 05        	JR NZ, .L1
161+  5560              	; sound disabled, throw illegal function call
162+  5560 1E 05        	LD E, 5
163+  5562 C3 72 5F     	JP THROW_ERROR
164+  5565              .L1:
165+  5565 3A B0 54     	LD A, (SFX_INIT_STATUS)
166+  5568 B7           	OR A
167+  5569 20 05        	JR NZ, .L2
168+  556B              	; sfx data not initialized, throw out of data
169+  556B 1E 04        	LD E, 4
170+  556D C3 72 5F     	JP THROW_ERROR
171+  5570              .L2:
172+  5570              	; pop  parameters and store away for later
173+  5570 D1           	POP DE ; inverted volume
174+  5571 43           	LD B, E
175+  5572 D1           	POP DE ; channel
176+  5573 4B           	LD C, E
177+  5574 D1           	POP DE
178+  5575 7B           	LD A, E
179+  5576 08           	EX AF, AF'
180+  5577 E5           	PUSH HL ; basic text location
181+  5578 D9           	EXX
182+  5579 FD 21 80 55  	LD IY, .RET
183+  557D C3 05 5F     	JP ENABLE_PAGE0
184+  5580              .RET:
185+  5580 D9           	EXX
186+  5581 08           	EX AF, AF'
187+  5582 CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
188+  5585
189+  5585 D1               POP DE
190+  5586 C1               POP BC
191+  5587 CD 7C 5E         CALL RESTORE_PAGE_INFO
192+  558A
193+  558A E1           	POP HL
194+  558B C9           	RET
195+  558C              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
128   558C               ENDIF
129   558C
130   558C               IF (VRAM_CMDS == 1)
131   558C               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
  1+  558C              ; *******************************************************************************************************
  2+  558C              ; function to handle CALL FILVRM basic extension
  3+  558C              ; FILVRM ( INT offset,
  4+  558C              ;		   INT count,
  5+  558C              ;		   BYTE value,
  6+  558C              ;		   BYTE wait_vsync) >0 = true
  7+  558C              ; wait_vsync will issue HALT before copying
  8+  558C              FILVRM:
  9+  558C              	; opening (
 10+  558C CD 52 5F     	CALL CHKCHAR
 11+  558F 28           	DB '('
 12+  5590              	; get offset address
 13+  5590 DD 21 2F 54  	LD IX, FRMQNT
 14+  5594 CD 59 01     	CALL CALBAS
 15+  5597 D5           	PUSH DE
 16+  5598              	; comma
 17+  5598 CD 52 5F     	CALL CHKCHAR
 18+  559B 2C           	DB ','
 19+  559C              	; get count
 20+  559C DD 21 2F 54  	LD IX, FRMQNT
 21+  55A0 CD 59 01     	CALL CALBAS
 22+  55A3 D5           	PUSH DE
 23+  55A4              	; comma
 24+  55A4 CD 52 5F     	CALL CHKCHAR
 25+  55A7 2C           	DB ','
 26+  55A8              	; get value
 27+  55A8 DD 21 1C 52  	LD IX, GETBYT
 28+  55AC CD 59 01     	CALL CALBAS
 29+  55AF F5           	PUSH AF
 30+  55B0              	; comma
 31+  55B0 CD 52 5F     	CALL CHKCHAR
 32+  55B3 2C           	DB ','
 33+  55B4              	; get vsync wait
 34+  55B4 DD 21 1C 52  	LD IX, GETBYT
 35+  55B8 CD 59 01     	CALL CALBAS
 36+  55BB F5           	PUSH AF
 37+  55BC              	; ending )
 38+  55BC CD 52 5F     	CALL CHKCHAR
 39+  55BF 29           	DB ')'
 40+  55C0
 41+  55C0 FB               EI
 42+  55C1              	; save position
 43+  55C1 E5           	PUSH HL
 44+  55C2 DD E1        	POP IX
 45+  55C4
 46+  55C4              	; syntax ok
 47+  55C4              	; wait for vsync if needed
 48+  55C4 F1           	POP AF
 49+  55C5 B7           	OR A
 50+  55C6 28 01        	JR Z, .L1
 51+  55C8 76           	HALT
 52+  55C9
 53+  55C9              .L1:
 54+  55C9 3E 01        	LD A,1
 55+  55CB 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 56+  55CE F1               POP AF ; value
 57+  55CF C1               POP BC ; count
 58+  55D0 E1               POP HL ; offset
 59+  55D1 CD 56 00         CALL BIOS_FILVRM
 60+  55D4 AF           	XOR A
 61+  55D5 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
 62+  55D8
 63+  55D8              .L3:
 64+  55D8 DD E5        	PUSH IX
 65+  55DA E1           	POP HL
 66+  55DB C9           	RET
 67+  55DC              ; *******************************************************************************************************
 68+  55DC
 69+  55DC              ; *******************************************************************************************************
 70+  55DC              ; function to handle CALL MEMVRM basic extension
 71+  55DC              ; copies from RAM to VRAM
 72+  55DC              ; _MEMVRM ( INT source,
 73+  55DC              ;			INT destination,
 74+  55DC              ;			INT count,
 75+  55DC              ;			BYTE wait_vsync) >0 = true
 76+  55DC              ; will put ram in page 0 also, page 1 is already there
 77+  55DC              ; wait_vsync will issue HALT before copying
 78+  55DC              MEMVRM:
 79+  55DC              	; opening (
 80+  55DC CD 52 5F     	CALL CHKCHAR
 81+  55DF 28           	DB '('
 82+  55E0              	; get source address
 83+  55E0 DD 21 2F 54  	LD IX, FRMQNT
 84+  55E4 CD 59 01     	CALL CALBAS
 85+  55E7 D5           	PUSH DE
 86+  55E8              	; comma
 87+  55E8 CD 52 5F     	CALL CHKCHAR
 88+  55EB 2C           	DB ','
 89+  55EC              	; get destination address
 90+  55EC DD 21 2F 54  	LD IX, FRMQNT
 91+  55F0 CD 59 01     	CALL CALBAS
 92+  55F3 D5           	PUSH DE
 93+  55F4              	; comma
 94+  55F4 CD 52 5F     	CALL CHKCHAR
 95+  55F7 2C           	DB ','
 96+  55F8              	; get length
 97+  55F8 DD 21 2F 54  	LD IX, FRMQNT
 98+  55FC CD 59 01     	CALL CALBAS
 99+  55FF D5           	PUSH DE
100+  5600              	; comma
101+  5600 CD 52 5F     	CALL CHKCHAR
102+  5603 2C           	DB ','
103+  5604              	; get vsync wait
104+  5604 DD 21 1C 52  	LD IX, GETBYT
105+  5608 CD 59 01     	CALL CALBAS
106+  560B F5           	PUSH AF
107+  560C              	; ending )
108+  560C CD 52 5F     	CALL CHKCHAR
109+  560F 29           	DB ')'
110+  5610
111+  5610                  ; save position in BASIC text
112+  5610 E5           	PUSH HL
113+  5611 DD E1        	POP IX
114+  5613
115+  5613 F1           	POP AF ; wait vsync
116+  5614 B7           	OR A
117+  5615 28 03        	JR Z, .L1
118+  5617 FB               EI
119+  5618 76           	HALT
120+  5619 F3           	DI
121+  561A              .L1:
122+  561A              	; pop LDIR parameters and store away for later
123+  561A C1           	POP BC ; count
124+  561B D1           	POP DE ; vram destination
125+  561C E1           	POP HL ; ram source
126+  561D D9           	EXX
127+  561E FD 21 25 56   	LD IY, .RET
128+  5622 C3 05 5F     	JP ENABLE_PAGE0
129+  5625              .RET:
130+  5625 FB           	EI
131+  5626 D9           	EXX
132+  5627 3E 01        	LD A,1
133+  5629 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
134+  562C CD 3C 56     	CALL .LDIRVM
135+  562F AF           	XOR A
136+  5630 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
137+  5633 D1               POP DE
138+  5634 C1               POP BC
139+  5635 CD 7C 5E         CALL RESTORE_PAGE_INFO
140+  5638 DD E5        	PUSH IX
141+  563A E1           	POP HL
142+  563B C9           	RET
143+  563C
144+  563C              .LDIRVM:
145+  563C EB           	EX DE, HL
146+  563D F3           	DI
147+  563E CD 2C 5E     	CALL SETWRT_LOCAL
148+  5641 FB           	EI
149+  5642 EB           	EX DE, HL
150+  5643 78           	LD A, B
151+  5644 B7           	OR A
152+  5645 28 0D        	JR Z, .L3
153+  5647 C5           	PUSH BC
154+  5648 0E 98        	LD C, #98
155+  564A              .L2:
156+  564A 50           	LD D, B
157+  564B 06 00        	LD B, 0
158+  564D CD 39 5E     	CALL BBYTECOPY_NO_C
159+  5650 42           	LD B, D
160+  5651 10 F7        	DJNZ .L2
161+  5653 C1           	POP BC
162+  5654              .L3:
163+  5654 79           	LD A, C
164+  5655 B7           	OR A
165+  5656 C8           	RET Z
166+  5657 41           	LD B, C
167+  5658 C3 37 5E     	JP BBYTECOPY
168+  565B              ; *******************************************************************************************************
169+  565B
170+  565B              ; *******************************************************************************************************
171+  565B              ; function to handle CALL VRMMEM basic extension
172+  565B              ; copies from RAM to VRAM
173+  565B              ; _VRMMEM ( INT source,
174+  565B              ;			INT destination,
175+  565B              ;			INT count
176+  565B              ; will put ram in page 0 also, page 1 is already there
177+  565B              VRMMEM:
178+  565B              	; opening (
179+  565B CD 52 5F     	CALL CHKCHAR
180+  565E 28           	DB '('
181+  565F              	; get source address
182+  565F DD 21 2F 54  	LD IX, FRMQNT
183+  5663 CD 59 01     	CALL CALBAS
184+  5666 D5           	PUSH DE
185+  5667              	; comma
186+  5667 CD 52 5F     	CALL CHKCHAR
187+  566A 2C           	DB ','
188+  566B              	; get destination address
189+  566B DD 21 2F 54  	LD IX, FRMQNT
190+  566F CD 59 01     	CALL CALBAS
191+  5672 D5           	PUSH DE
192+  5673              	; comma
193+  5673 CD 52 5F     	CALL CHKCHAR
194+  5676 2C           	DB ','
195+  5677              	; get length
196+  5677 DD 21 2F 54  	LD IX, FRMQNT
197+  567B CD 59 01     	CALL CALBAS
198+  567E D5           	PUSH DE
199+  567F              	; ending )
200+  567F CD 52 5F     	CALL CHKCHAR
201+  5682 29           	DB ')'
202+  5683
203+  5683                  ; save position in BASIC text
204+  5683 E5           	PUSH HL
205+  5684 DD E1        	POP IX
206+  5686
207+  5686 C1           	POP BC ; count
208+  5687 D1           	POP DE ; destination
209+  5688 E1           	POP HL ; source
210+  5689 D9           	EXX
211+  568A FD 21 91 56  	LD IY, .RET
212+  568E C3 05 5F     	JP ENABLE_PAGE0
213+  5691              .RET:
214+  5691 FB           	EI
215+  5692 D9           	EXX
216+  5693 3E 01        	LD A,1
217+  5695 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
218+  5698 CD A8 56     	CALL .LDIRMV
219+  569B AF           	XOR A
220+  569C 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
221+  569F D1               POP DE
222+  56A0 C1               POP BC
223+  56A1 CD 7C 5E         CALL RESTORE_PAGE_INFO
224+  56A4 DD E5        	PUSH IX
225+  56A6 E1           	POP HL
226+  56A7 C9           	RET
227+  56A8
228+  56A8              .LDIRMV:
229+  56A8              	; set VRAM address *exactly* as in ROM, otherwise corruption
230+  56A8 7D           	LD	A, L
231+  56A9 F3           	DI
232+  56AA D3 99        	OUT	(099H), A
233+  56AC 7C           	LD	A, H
234+  56AD E6 3F        	AND	03FH
235+  56AF D3 99        	OUT	(099H), A
236+  56B1 FB           	EI
237+  56B2              	;EX (SP), HL
238+  56B2              	;EX (SP), HL
239+  56B2              	;NOP
240+  56B2              	;NOP
241+  56B2              .L4:
242+  56B2 DB 98            IN A, (#98)
243+  56B4 12           	LD (DE), A
244+  56B5 13               INC DE
245+  56B6 0B               DEC BC
246+  56B7 79               LD A, C
247+  56B8 B0               OR B
248+  56B9 20 F7            JR NZ, .L4
249+  56BB C9               RET
250+  56BC              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
132   56BC               ENDIF
133   56BC
134   56BC               IF (GENCAL_CMD == 1)
135   56BC               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
  1+  56BC              ; *******************************************************************************************************
  2+  56BC              ; function to handle CALL GENCAL basic extension
  3+  56BC              ; GENCAL ( INT fn_addr, = address of the function to call
  4+  56BC              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  5+  56BC              ; output values of registers will also be stored at reg_list_ptr
  6+  56BC              GENCAL_VAR_SP:
  7+  56BC 00 00            DW 0
  8+  56BE              GENCAL_VAR_SP2:
  9+  56BE 00 00            DW 0
 10+  56C0              GENCAL:
 11+  56C0              	; opening (
 12+  56C0 CD 52 5F     	CALL CHKCHAR
 13+  56C3 28           	DB '('
 14+  56C4              	; get function address
 15+  56C4 DD 21 2F 54  	LD IX, FRMQNT
 16+  56C8 CD 59 01     	CALL CALBAS
 17+  56CB D5           	PUSH DE
 18+  56CC              	; comma
 19+  56CC CD 52 5F     	CALL CHKCHAR
 20+  56CF 2C           	DB ','
 21+  56D0              	; get pointer to register list
 22+  56D0 3E 02            LD A,2
 23+  56D2 06 01            LD B,1
 24+  56D4 11 00 05         LD DE,#0500
 25+  56D7 CD 79 5F         CALL GET_BASIC_ARRAY_DATA_POINTER
 26+  56DA C5           	PUSH BC
 27+  56DB              	; ending )
 28+  56DB CD 52 5F     	CALL CHKCHAR
 29+  56DE 29           	DB ')'
 30+  56DF
 31+  56DF              	; save BASIC token position
 32+  56DF E5           	PUSH HL
 33+  56E0 D9               EXX
 34+  56E1 E1           	POP HL ; HL'=next basic token
 35+  56E2 D9               EXX
 36+  56E3
 37+  56E3 E1               POP HL ; get pointer to register values
 38+  56E4 F3           	DI
 39+  56E5 ED 73 BC 56      LD (GENCAL_VAR_SP), SP
 40+  56E9 F9               LD SP, HL
 41+  56EA F1               POP AF
 42+  56EB C1               POP BC
 43+  56EC D1               POP DE
 44+  56ED E1               POP HL
 45+  56EE DD E1            POP IX
 46+  56F0 FD E1            POP IY
 47+  56F2 D9               EXX
 48+  56F3 ED 73 BE 56      LD (GENCAL_VAR_SP2), SP
 49+  56F7 ED 7B BC 56      LD SP, (GENCAL_VAR_SP)
 50+  56FB FB               EI
 51+  56FC D1               POP DE ; get function to call
 52+  56FD E5               PUSH HL
 53+  56FE CD 19 57         CALL .EXXDECALL
 54+  5701 F3               DI
 55+  5702 ED 73 BC 56      LD (GENCAL_VAR_SP), SP
 56+  5706 ED 7B BE 56      LD SP, (GENCAL_VAR_SP2)
 57+  570A FD E5            PUSH IY
 58+  570C DD E5            PUSH IX
 59+  570E E5               PUSH HL
 60+  570F D5               PUSH DE
 61+  5710 C5               PUSH BC
 62+  5711 F5               PUSH AF
 63+  5712 ED 7B BC 56      LD SP, (GENCAL_VAR_SP)
 64+  5716 FB               EI
 65+  5717 E1               POP HL
 66+  5718 C9           	RET
 67+  5719
 68+  5719              .EXXDECALL:
 69+  5719 D5               PUSH DE
 70+  571A D9               EXX
 71+  571B C9               RET
 72+  571C              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
136   571C               ENDIF
137   571C
138   571C               IF (BOX_CMDS == 1)
139   571C               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
  1+  571C              ; *******************************************************************************************************
  2+  571C              ; generic function to implement rectangle data copy
  3+  571C              ; should be modified to call appropriate function for memory or vram
  4+  571C              ; input IX=pointer to following structure
  5+  571C              ; +00 source data pointer
  6+  571C              ; +02 num bytes in a row
  7+  571C              ; +04 number of rows
  8+  571C              ; +06 source add-to value till next row
  9+  571C              ; +08 destination address
 10+  571C              ; +10 destination add-to value till next row
 11+  571C              ; modifies AF, BC, DE, HL
 12+  571C              RECTANGLE_COPY:
 13+  571C DD 6E 00     	LD L, (IX+0)
 14+  571F DD 66 01     	LD H, (IX+1) ; source address
 15+  5722 DD 5E 08     	LD E, (IX+8)
 16+  5725 DD 56 09     	LD D, (IX+9) ; destination
 17+  5728 DD 46 04     	LD B, (IX+4) ; row number
 18+  572B              .L1:
 19+  572B C5           	PUSH BC
 20+  572C E5           		PUSH HL
 21+  572D D5           			PUSH DE
 22+  572E DD 4E 02     				LD C, (IX+2)
 23+  5731 DD 46 03     				LD B, (IX+3) ; num bytes in a row
 24+  5734              .CALL1:
 25+  5734 CD 00 00     				CALL 0 ; set destination address from DE
 26+  5737              .CALL2:
 27+  5737 CD 00 00     				CALL 0 ; copy data fn
 28+  573A E1           			POP HL
 29+  573B DD 4E 0A     			LD C, (IX+10)
 30+  573E DD 46 0B     			LD B, (IX+11) ; destination add-to
 31+  5741 09           			ADD HL, BC
 32+  5742 EB           			EX DE, HL
 33+  5743 E1           		POP HL
 34+  5744 DD 4E 06     		LD C, (IX+6)
 35+  5747 DD 46 07     		LD B, (IX+7) ; src add-to
 36+  574A 09           		ADD HL, BC
 37+  574B C1           	POP BC
 38+  574C 10 DD        	DJNZ .L1
 39+  574E C9           	RET
 40+  574F              ; *******************************************************************************************************
 41+  574F
 42+  574F              ; *******************************************************************************************************
 43+  574F              ; function to handle CALL BOXMEMCPY basic extension
 44+  574F              ; copies data with window like boundaries within ram
 45+  574F              ; BOXMEMCPY ( INT source data pointer,
 46+  574F              ;			  INT source number of bytes in a row,
 47+  574F              ;			  INT number of rows,
 48+  574F              ;			  INT source add-to value till next row,
 49+  574F              ; 			  INT destination pointer,
 50+  574F              ;			  INT destination add-to value till next row )
 51+  574F              ; request_data_ptr described in RECTANGLE_COPY
 52+  574F              ; will put ram in page 0 also, page 1 is already there
 53+  574F              BOXMEMCPY:
 54+  574F 11 59 57     	LD DE,BOXMEMCPY.RET
 55+  5752 ED 53 CD 57  	LD (BOXCOMMON.ADDR+2), DE
 56+  5756 C3 6C 57     	JP BOXCOMMON
 57+  5759              .RET:
 58+  5759 FB           	EI
 59+  575A              	; set RAM functions to call
 60+  575A 21 00 00     	LD HL, 0
 61+  575D 22 34 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
 62+  5760 22 36 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
 63+  5763 21 ED B0     	LD HL, #B0ED ; LDIR
 64+  5766 22 38 57     	LD (RECTANGLE_COPY.CALL1+4), HL
 65+  5769 C3 D2 57     	JP BOXCOMMON.CALL
 66+  576C              ; *******************************************************************************************************
 67+  576C
 68+  576C              ; *******************************************************************************************************
 69+  576C              ; common parts of BOX commands
 70+  576C              BOXCOMMON:
 71+  576C              	; opening (
 72+  576C CD 52 5F     	CALL CHKCHAR
 73+  576F 28           	DB '('
 74+  5770              	; get source data pointer
 75+  5770 DD 21 2F 54  	LD IX, FRMQNT
 76+  5774 CD 59 01     	CALL CALBAS
 77+  5777 ED 53 9B 5C  	LD (BLIT_STRUCT+0), DE
 78+  577B              	; comma
 79+  577B CD 52 5F     	CALL CHKCHAR
 80+  577E 2C           	DB ','
 81+  577F              	; source number of bytes in a row
 82+  577F DD 21 2F 54  	LD IX, FRMQNT
 83+  5783 CD 59 01     	CALL CALBAS
 84+  5786 ED 53 9D 5C  	LD (BLIT_STRUCT+2), DE
 85+  578A              	; comma
 86+  578A CD 52 5F     	CALL CHKCHAR
 87+  578D 2C           	DB ','
 88+  578E              	; number of rows
 89+  578E DD 21 2F 54  	LD IX, FRMQNT
 90+  5792 CD 59 01     	CALL CALBAS
 91+  5795 ED 53 9F 5C  	LD (BLIT_STRUCT+4), DE
 92+  5799              	; comma
 93+  5799 CD 52 5F     	CALL CHKCHAR
 94+  579C 2C           	DB ','
 95+  579D              	; source add-to value till next row
 96+  579D DD 21 2F 54  	LD IX, FRMQNT
 97+  57A1 CD 59 01     	CALL CALBAS
 98+  57A4 ED 53 A1 5C  	LD (BLIT_STRUCT+6), DE
 99+  57A8              	; comma
100+  57A8 CD 52 5F     	CALL CHKCHAR
101+  57AB 2C           	DB ','
102+  57AC              	; destination pointer
103+  57AC DD 21 2F 54  	LD IX, FRMQNT
104+  57B0 CD 59 01     	CALL CALBAS
105+  57B3 ED 53 A3 5C  	LD (BLIT_STRUCT+8), DE
106+  57B7              	; comma
107+  57B7 CD 52 5F     	CALL CHKCHAR
108+  57BA 2C           	DB ','
109+  57BB              	; destination add-to value till next row
110+  57BB DD 21 2F 54  	LD IX, FRMQNT
111+  57BF CD 59 01     	CALL CALBAS
112+  57C2 ED 53 A5 5C  	LD (BLIT_STRUCT+10), DE
113+  57C6              	; ending )
114+  57C6 CD 52 5F     	CALL CHKCHAR
115+  57C9 29           	DB ')'
116+  57CA
117+  57CA E5           	PUSH HL ; save position in BASIC buffer
118+  57CB              .ADDR:
119+  57CB FD 21 00 00  	LD IY, 0
120+  57CF C3 05 5F     	JP ENABLE_PAGE0
121+  57D2              .CALL:
122+  57D2 DD 21 9B 5C  	LD IX,BLIT_STRUCT
123+  57D6 CD 1C 57     	CALL RECTANGLE_COPY
124+  57D9 AF           	XOR A
125+  57DA 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
126+  57DD
127+  57DD D1               POP DE
128+  57DE C1               POP BC
129+  57DF CD 7C 5E         CALL RESTORE_PAGE_INFO
130+  57E2
131+  57E2 E1           	POP HL
132+  57E3 C9           	RET
133+  57E4              ; *******************************************************************************************************
134+  57E4
135+  57E4              ; *******************************************************************************************************
136+  57E4              ; function to handle CALL BOXMEMVRM basic extension
137+  57E4              ; copies data with window like boundaries from ram to Vram
138+  57E4              ; BOXMEMVRM ( INT source data pointer,
139+  57E4              ;			  INT source number of bytes in a row,
140+  57E4              ;			  INT number of rows,
141+  57E4              ;			  INT source add-to value till next row,
142+  57E4              ; 			  INT destination pointer,
143+  57E4              ;			  INT destination add-to value till next row )
144+  57E4              ; request_data_ptr described in RECTANGLE_COPY
145+  57E4              ; will put ram in page 0 also, page 1 is already there
146+  57E4              BOXMEMVRM:
147+  57E4 11 EE 57     	LD DE,BOXMEMVRM.RET
148+  57E7 ED 53 CD 57  	LD (BOXCOMMON.ADDR+2), DE
149+  57EB C3 6C 57     	JP BOXCOMMON
150+  57EE              .RET:
151+  57EE FB           	EI
152+  57EF              	; set RAM functions to call
153+  57EF 21 09 58     	LD HL, .SETDEST
154+  57F2 22 35 57     	LD (RECTANGLE_COPY.CALL1+1), HL
155+  57F5 21 11 58     	LD HL, .COPYDATA
156+  57F8 22 38 57     	LD (RECTANGLE_COPY.CALL2+1), HL
157+  57FB 3E CD        	LD A, #CD ; CALL
158+  57FD 32 34 57     	LD (RECTANGLE_COPY.CALL1), A
159+  5800 32 37 57     	LD (RECTANGLE_COPY.CALL2), A
160+  5803              	;LD A,1
161+  5803 32 AC 5C     	LD (VRAM_UPDATE_IN_PROGRESS),A
162+  5806 C3 D2 57     	JP BOXCOMMON.CALL
163+  5809              .SETDEST:
164+  5809 EB           	EX DE, HL
165+  580A F3           	DI
166+  580B CD 2C 5E     	CALL SETWRT_LOCAL
167+  580E FB           	EI
168+  580F EB           	EX DE, HL
169+  5810 C9           	RET
170+  5811              .COPYDATA:
171+  5811 41           	LD B, C
172+  5812 C3 37 5E     	JP BBYTECOPY
173+  5815              ; *******************************************************************************************************
# file closed: asm\BOX.asm
140   5815               ENDIF
141   5815
142   5815               IF (BLIT_CMDS == 1)
143   5815               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
  1+  5815              ; *******************************************************************************************************
  2+  5815              ; function rotates mask and data of several characters and applies to background data
  3+  5815              ; this handles x-shift from 0 to 4
  4+  5815              ; contains self-modifying code that is set-up from external function
  5+  5815              ; input HL=pointer to mask data
  6+  5815              ; input HL'=pointer to character data
  7+  5815              ; input DE=output buffer containing background data
  8+  5815              ; input BC=DE+8
  9+  5815              ; input A=number of characters to process
 10+  5815              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 11+  5815              SHIFT04:
 12+  5815 08           	EX AF, AF'
 13+  5816 7E           	LD A, (HL) ; get mask
 14+  5817 D9           	EXX
 15+  5818 57           	LD D, A
 16+  5819 1E FF        	LD E, #FF
 17+  581B 37           	SCF
 18+  581C              .M1:
 19+  581C 18 FE        	JR .M1 ; this is self-modifying part
 20+  581E CB 1A        	RR D
 21+  5820 CB 1B        	RR E
 22+  5822 CB 1A        	RR D
 23+  5824 CB 1B        	RR E
 24+  5826 CB 1A        	RR D
 25+  5828 CB 1B        	RR E
 26+  582A CB 1A        	RR D
 27+  582C CB 1B        	RR E
 28+  582E
 29+  582E 46           	LD B, (HL) ; get data
 30+  582F 0E 00        	LD C, 0
 31+  5831              .M2:
 32+  5831 18 FE        	JR .M2 ; also self-modifying part
 33+  5833 CB 38        	SRL B
 34+  5835 CB 19        	RR C
 35+  5837 CB 38        	SRL B
 36+  5839 CB 19        	RR C
 37+  583B CB 38        	SRL B
 38+  583D CB 19        	RR C
 39+  583F CB 38        	SRL B
 40+  5841 CB 19        	RR C
 41+  5843
 42+  5843 D9           	EXX
 43+  5844 1A           	LD A, (DE) ; background
 44+  5845 D9           	EXX
 45+  5846 A2           	AND D
 46+  5847 B0           	OR B
 47+  5848 D9           	EXX
 48+  5849 12           	LD (DE), A
 49+  584A
 50+  584A 0A           	LD A, (BC)
 51+  584B D9           	EXX
 52+  584C A3           	AND E
 53+  584D B1           	OR C
 54+  584E 23           	INC HL
 55+  584F D9           	EXX
 56+  5850 02           	LD (BC), A
 57+  5851
 58+  5851 23           	INC HL
 59+  5852 13           	INC DE
 60+  5853 03           	INC BC
 61+  5854
 62+  5854 08           	EX AF, AF'
 63+  5855 3D           	DEC A
 64+  5856 C2 15 58     	JP NZ, SHIFT04
 65+  5859 C9           	RET
 66+  585A              ; *******************************************************************************************************
 67+  585A
 68+  585A              ; *******************************************************************************************************
 69+  585A              ; function rotates mask and data of several characters and applies to background data
 70+  585A              ; this handles x-shift from 5 to 8
 71+  585A              ; contains self-modifying code that is set-up from external function
 72+  585A              ; input HL=pointer to mask data
 73+  585A              ; input HL'=pointer to character data
 74+  585A              ; input DE=output buffer containing background data
 75+  585A              ; input BC=DE+8
 76+  585A              ; input A=number of characters to process
 77+  585A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 78+  585A              SHIFT58:
 79+  585A 08           	EX AF, AF'
 80+  585B 7E           	LD A, (HL) ; get mask
 81+  585C D9           	EXX
 82+  585D 57           	LD D, A
 83+  585E 1E FF        	LD E, #FF
 84+  5860 37           	SCF
 85+  5861              .M1:
 86+  5861 18 FE        	JR .M1 ; this is self-modifying part
 87+  5863 CB 12        	RL D
 88+  5865 CB 13        	RL E
 89+  5867 CB 12        	RL D
 90+  5869 CB 13        	RL E
 91+  586B CB 12        	RL D
 92+  586D CB 13        	RL E
 93+  586F
 94+  586F 46           	LD B, (HL)
 95+  5870 0E 00        	LD C, 0
 96+  5872              .M2:
 97+  5872 18 FE        	JR .M2 ; also self-modifying part
 98+  5874 CB 20        	SLA B
 99+  5876 CB 11        	RL C
100+  5878 CB 20        	SLA B
101+  587A CB 11        	RL C
102+  587C CB 20        	SLA B
103+  587E CB 11        	RL C
104+  5880
105+  5880 D9           	EXX
106+  5881 1A           	LD A, (DE) ; background
107+  5882 D9           	EXX
108+  5883 A3           	AND E
109+  5884 B1           	OR C
110+  5885 D9           	EXX
111+  5886 12           	LD (DE), A
112+  5887
113+  5887 0A           	LD A, (BC)
114+  5888 D9           	EXX
115+  5889 A2           	AND D
116+  588A B0           	OR B
117+  588B 23           	INC HL
118+  588C D9           	EXX
119+  588D 02           	LD (BC), A
120+  588E
121+  588E 23           	INC HL
122+  588F 13           	INC DE
123+  5890 03           	INC BC
124+  5891
125+  5891 08           	EX AF, AF'
126+  5892 3D           	DEC A
127+  5893 C2 5A 58     	JP NZ, SHIFT58
128+  5896 C9           	RET
129+  5897              ; *******************************************************************************************************
130+  5897
131+  5897              ; *******************************************************************************************************
132+  5897              ; routine that shifts one row of characters
133+  5897              ; contains self-modifying code that is set-up from external function
134+  5897              ; input HL=pointer to mask data
135+  5897              ; input HL'=pointer to character data
136+  5897              ; input DE=output buffer containing background data
137+  5897              ; input A=number of characters to process
138+  5897              ; input IX=pointer to structure describing input data
139+  5897              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
140+  5897              SHIFT_ROW:
141+  5897 F5           	PUSH AF
142+  5898 ED 53 97 5C  		LD (BLIT_TMP1), DE
143+  589C E5           		PUSH HL
144+  589D CD E0 58     			CALL .ADDYSHIFT
145+  58A0 E1           		POP HL
146+  58A1 ED 53 99 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
147+  58A5              .L1:
148+  58A5 3E 08        		LD A, 8
149+  58A7 DD 96 02     		SUB (IX+2) ; y shift
150+  58AA              .CALL1:
151+  58AA CD 00 00     		CALL 0
152+  58AD DD 7E 02     		LD A, (IX+2); y shift
153+  58B0 B7           		OR A
154+  58B1 28 26        		JR Z, .DONE
155+  58B3 ED 5B 97 5C  		LD DE, (BLIT_TMP1)
156+  58B7 E5           		PUSH HL
157+  58B8 CD EE 58     			CALL .DETONEXTROW
158+  58BB E1           		POP HL
159+  58BC              .CALL2:
160+  58BC CD 00 00     		CALL 0
161+  58BF ED 5B 97 5C  		LD DE, (BLIT_TMP1)
162+  58C3 E5           		PUSH HL
163+  58C4 CD E8 58     			CALL .ADD8
164+  58C7 E1           		POP HL
165+  58C8 ED 53 97 5C  		LD (BLIT_TMP1), DE
166+  58CC ED 5B 99 5C  		LD DE, (BLIT_TMP2)
167+  58D0 E5           		PUSH HL
168+  58D1 CD E8 58     			CALL .ADD8
169+  58D4 E1           		POP HL
170+  58D5 ED 53 99 5C  		LD (BLIT_TMP2), DE ; DE+vertical shift
171+  58D9              .DONE:
172+  58D9 F1           	POP AF
173+  58DA 3D           	DEC A
174+  58DB C8           	RET Z
175+  58DC F5           	PUSH AF
176+  58DD C3 A5 58     	JP .L1
177+  58E0              .ADDYSHIFT:
178+  58E0 EB           	EX DE, HL
179+  58E1 16 00        	LD D, 0
180+  58E3 DD 5E 02     	LD E, (IX+2); y shift
181+  58E6 18 0C        	JR .MOVDEBC
182+  58E8              .ADD8:
183+  58E8 21 08 00     	LD HL, 8
184+  58EB C3 F4 58     	JP .MOVDEBC
185+  58EE              .DETONEXTROW:
186+  58EE DD 6E 06     	LD L, (IX+6)
187+  58F1 DD 66 07     	LD H, (IX+7) ; bkg add to value
188+  58F4              .MOVDEBC:
189+  58F4 19           	ADD HL, DE
190+  58F5 54           	LD D, H
191+  58F6 5D           	LD E, L
192+  58F7 01 08 00     	LD BC, 8
193+  58FA 09           	ADD HL, BC
194+  58FB 44           	LD B, H
195+  58FC 4D           	LD C, L
196+  58FD C9           	RET
197+  58FE              ; *******************************************************************************************************
198+  58FE
199+  58FE              ; *******************************************************************************************************
200+  58FE              ; function rotates mask and character data and applies it to background
201+  58FE              ; input IX=pointer to structure describing input data
202+  58FE              ; +0  DW horizontal shift count 0-7 (low byte used)
203+  58FE              ; +2  DW vertical shift count 0-7 (low byte used)
204+  58FE              ; +4  DW background data start;
205+  58FE              ; +6  DW background add to value to next row of background data
206+  58FE              ; +8  DW mask data start;
207+  58FE              ; +10  DW character data start;
208+  58FE              ; +12 DW character&mask add to value to next row of data
209+  58FE              ; +14 DW columns (low byte used)
210+  58FE              ; +16 DW rows (low byte used)
211+  58FE              SHIFT_MERGE_CHARACTER:
212+  58FE DD 7E 00     	LD A, (IX) ; shift
213+  5901 FE 05        	CP 5
214+  5903 38 25        	JR C, .RIGHT
215+  5905              	; shifts 5-7, use rotate towards left 1-3
216+  5905 21 5A 58     	LD HL, SHIFT58
217+  5908 22 AB 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
218+  590B 22 BD 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
219+  590E D6 05        	SUB 5
220+  5910 28 0D        	JR Z, .L1
221+  5912 87           	ADD A, A
222+  5913 87           	ADD A, A
223+  5914 67           	LD H, A
224+  5915 2E 18        	LD L, #18 ; JR opcode
225+  5917 22 61 58     	LD (SHIFT58.M1), HL
226+  591A 22 72 58     	LD (SHIFT58.M2), HL
227+  591D 18 32        	JR .DO
228+  591F              .L1:
229+  591F 21 00 00     	LD HL, 0 ; 2xNOP opcode
230+  5922 22 61 58     	LD (SHIFT58.M1), HL
231+  5925 22 72 58     	LD (SHIFT58.M2), HL
232+  5928 18 27        	JR .DO
233+  592A              .RIGHT:
234+  592A              	; shifts 0-4, rotate towards right
235+  592A 21 15 58     	LD HL, SHIFT04
236+  592D 22 AB 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
237+  5930 22 BD 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
238+  5933 FE 04        	CP 4
239+  5935 28 11        	JR Z, .R1
240+  5937 D6 04        	SUB 4
241+  5939 ED 44        	NEG
242+  593B 87           	ADD A, A
243+  593C 87           	ADD A, A
244+  593D 67           	LD H, A
245+  593E 2E 18        	LD L, #18 ; JR opcode
246+  5940 22 1C 58     	LD (SHIFT04.M1), HL
247+  5943 22 31 58     	LD (SHIFT04.M2), HL
248+  5946 18 09        	JR .DO
249+  5948              .R1:
250+  5948 21 00 00     	LD HL, 0 ; 2xNOP opcode
251+  594B 22 1C 58     	LD (SHIFT04.M1), HL
252+  594E 22 31 58     	LD (SHIFT04.M2), HL
253+  5951              .DO:
254+  5951 DD 46 10     	LD B, (IX+16) ; rows
255+  5954 DD 6E 08     	LD L, (IX+8)
256+  5957 DD 66 09     	LD H, (IX+9) ; mask data
257+  595A DD 5E 04     	LD E, (IX+4)
258+  595D DD 56 05     	LD D, (IX+5) ; background data
259+  5960 D9           	EXX
260+  5961 DD 6E 0A     	LD L, (IX+10)
261+  5964 DD 66 0B     	LD H, (IX+11) ; character data
262+  5967 D9           	EXX
263+  5968              .LOOP:
264+  5968 C5           	PUSH BC
265+  5969 E5           		PUSH HL
266+  596A D5           			PUSH DE
267+  596B D9           				EXX
268+  596C E5           				PUSH HL
269+  596D D9           					EXX
270+  596E DD 7E 0E     					LD A, (IX+14) ; columns
271+  5971              .CALL:
272+  5971 CD 97 58     					CALL SHIFT_ROW
273+  5974 E1           				POP HL
274+  5975 DD 5E 0C     				LD E, (IX+12)
275+  5978 DD 56 0D     				LD D, (IX+13) ; char data to next row
276+  597B 19           				ADD HL, DE
277+  597C D9           				EXX
278+  597D E1           			POP HL
279+  597E DD 5E 06     			LD E, (IX+6)
280+  5981 DD 56 07     			LD D, (IX+7) ; background to next row
281+  5984 19           			ADD HL, DE
282+  5985 EB           			EX DE, HL
283+  5986 E1           		POP HL
284+  5987 DD 4E 0C     		LD C, (IX+12)
285+  598A DD 46 0D     		LD B, (IX+13) ; char data to next row
286+  598D 09           		ADD HL, BC
287+  598E C1           	POP BC
288+  598F 10 D7        	DJNZ .LOOP
289+  5991 C9           	RET
290+  5992              ; *******************************************************************************************************
291+  5992
292+  5992               IFNDEF CMDS_WITH_PARAMETERS
293+  5992 ~            ; *******************************************************************************************************
294+  5992 ~            ; function to handle CALL BLIT basic extension
295+  5992 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
296+  5992 ~            ; fuses with background data and applies vertical shift too
297+  5992 ~            ; BLIT ( INT request_data_ptr )
298+  5992 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
299+  5992 ~            ; will put ram in page 0 also, page 1 is already there
300+  5992 ~            BLIT:
301+  5992 ~            	; opening (
302+  5992 ~            	CALL CHKCHAR
303+  5992 ~            	DB '('
304+  5992 ~            	; get pointer to request struct
305+  5992 ~            	LD IX, FRMQNT
306+  5992 ~            	CALL CALBAS
307+  5992 ~            	PUSH DE
308+  5992 ~            	; ending )
309+  5992 ~            	CALL CHKCHAR
310+  5992 ~            	DB ')'
311+  5992 ~
312+  5992 ~            	POP IX ; pointer to request struct
313+  5992 ~
314+  5992 ~            	PUSH HL ; save position in BASIC buffer
315+  5992 ~
316+  5992 ~            	LD IY, .RET
317+  5992 ~            	JP ENABLE_PAGE0
318+  5992 ~            .RET:
319+  5992 ~            	EI
320+  5992 ~            	CALL SHIFT_MERGE_CHARACTER
321+  5992 ~
322+  5992 ~                POP DE
323+  5992 ~                POP BC
324+  5992 ~                CALL RESTORE_PAGE_INFO
325+  5992 ~
326+  5992 ~            	POP HL
327+  5992 ~            	RET
328+  5992 ~            ; *******************************************************************************************************
329+  5992               ENDIF
330+  5992
331+  5992               IFDEF CMDS_WITH_PARAMETERS
332+  5992              ; *******************************************************************************************************
333+  5992              ; function to handle CALL BLIT basic extension
334+  5992              ; rotates 1-bit character drawing horizontally with mask and character data and
335+  5992              ; fuses with background data and applies vertical shift too
336+  5992              ; in form without pointers
337+  5992              ; BLIT ( INT x,
338+  5992              ;		 INT y,
339+  5992              ;		 INT char_data_pointer,
340+  5992              ;		 INT mask_data_pointer,
341+  5992              ;		 INT width (in characters),
342+  5992              ;		 INT height (in characters),
343+  5992              ;		 INT background_pointer (top left),
344+  5992              ;		 INT background_width (in characters),
345+  5992              ;		 INT background_height (in characters))
346+  5992              ; will put ram in page 0 also, page 1 is already there
347+  5992              BLIT:
348+  5992              	; opening (
349+  5992 CD 52 5F     	CALL CHKCHAR
350+  5995 28           	DB '('
351+  5996              	; get x coordinate
352+  5996 DD 21 2F 54  	LD IX, FRMQNT
353+  599A CD 59 01     	CALL CALBAS
354+  599D 7B           	LD A, E
355+  599E E6 07        	AND 7
356+  59A0 32 9B 5C     	LD (BLIT_STRUCT+0), A
357+  59A3 CD 80 5A     	CALL .DAdiv8
358+  59A6 32 97 5C     	LD (BLIT_TMP+0),A
359+  59A9              	; comma
360+  59A9 CD 52 5F     	CALL CHKCHAR
361+  59AC 2C           	DB ','
362+  59AD              	; get y coordinate
363+  59AD DD 21 2F 54  	LD IX, FRMQNT
364+  59B1 CD 59 01     	CALL CALBAS
365+  59B4 7B           	LD A, E
366+  59B5 E6 07        	AND 7
367+  59B7 32 9D 5C     	LD (BLIT_STRUCT+2), A
368+  59BA CD 80 5A     	CALL .DAdiv8
369+  59BD 32 98 5C     	LD (BLIT_TMP+1),A
370+  59C0              	; comma
371+  59C0 CD 52 5F     	CALL CHKCHAR
372+  59C3 2C           	DB ','
373+  59C4              	; get char data pointer
374+  59C4 DD 21 2F 54  	LD IX, FRMQNT
375+  59C8 CD 59 01     	CALL CALBAS
376+  59CB ED 53 A5 5C  	LD (BLIT_STRUCT+10), DE
377+  59CF              	; comma
378+  59CF CD 52 5F     	CALL CHKCHAR
379+  59D2 2C           	DB ','
380+  59D3              	; get mask data pointer
381+  59D3 DD 21 2F 54  	LD IX, FRMQNT
382+  59D7 CD 59 01     	CALL CALBAS
383+  59DA ED 53 A3 5C  	LD (BLIT_STRUCT+8), DE
384+  59DE              	; comma
385+  59DE CD 52 5F     	CALL CHKCHAR
386+  59E1 2C           	DB ','
387+  59E2              	; get width
388+  59E2 DD 21 2F 54  	LD IX, FRMQNT
389+  59E6 CD 59 01     	CALL CALBAS
390+  59E9 7B           	LD A, E
391+  59EA 32 A9 5C     	LD (BLIT_STRUCT+14), A
392+  59ED              	; comma
393+  59ED CD 52 5F     	CALL CHKCHAR
394+  59F0 2C           	DB ','
395+  59F1              	; get height
396+  59F1 DD 21 2F 54  	LD IX, FRMQNT
397+  59F5 CD 59 01     	CALL CALBAS
398+  59F8 7B           	LD A, E
399+  59F9 32 AB 5C     	LD (BLIT_STRUCT+16), A
400+  59FC              	; comma
401+  59FC CD 52 5F     	CALL CHKCHAR
402+  59FF 2C           	DB ','
403+  5A00              	; get background pointer
404+  5A00 DD 21 2F 54  	LD IX, FRMQNT
405+  5A04 CD 59 01     	CALL CALBAS
406+  5A07 ED 53 9F 5C  	LD (BLIT_STRUCT+4), DE
407+  5A0B              	; comma
408+  5A0B CD 52 5F     	CALL CHKCHAR
409+  5A0E 2C           	DB ','
410+  5A0F              	; get background width
411+  5A0F DD 21 2F 54  	LD IX, FRMQNT
412+  5A13 CD 59 01     	CALL CALBAS
413+  5A16 7B           	LD A, E
414+  5A17 32 99 5C     	LD (BLIT_TMP+2), A
415+  5A1A              	; comma
416+  5A1A CD 52 5F     	CALL CHKCHAR
417+  5A1D 2C           	DB ','
418+  5A1E              	; get background height
419+  5A1E DD 21 2F 54  	LD IX, FRMQNT
420+  5A22 CD 59 01     	CALL CALBAS
421+  5A25 7B           	LD A, E
422+  5A26 32 9A 5C     	LD (BLIT_TMP+3), A
423+  5A29              	; ending )
424+  5A29 CD 52 5F     	CALL CHKCHAR
425+  5A2C 29           	DB ')'
426+  5A2D
427+  5A2D E5           	PUSH HL ; save position in BASIC buffer
428+  5A2E
429+  5A2E              	; calculate char&mask add to value
430+  5A2E 26 00        	LD H, 0
431+  5A30 3A A9 5C     	LD A, (BLIT_STRUCT+14)
432+  5A33 6F           	LD L, A
433+  5A34 CD 41 5E     	CALL HLx8
434+  5A37 22 A7 5C     	LD (BLIT_STRUCT+12), HL
435+  5A3A              	; calculate background add to value
436+  5A3A 26 00        	LD H, 0
437+  5A3C 3A 99 5C     	LD A, (BLIT_TMP+2)
438+  5A3F 6F           	LD L, A
439+  5A40 CD 41 5E     	CALL HLx8
440+  5A43 22 A1 5C     	LD (BLIT_STRUCT+6), HL
441+  5A46              	; calculate pointer to background location
442+  5A46 21 00 00     	LD HL, 0
443+  5A49 3A 98 5C     	LD A,(BLIT_TMP+1)
444+  5A4C B7           	OR A
445+  5A4D 28 08        	JR Z, .L1
446+  5A4F 47           	LD B,A
447+  5A50 ED 5B A1 5C  	LD DE,(BLIT_STRUCT+6)
448+  5A54              .L0:
449+  5A54 19           	ADD HL, DE
450+  5A55 10 FD        	DJNZ .L0
451+  5A57              .L1:
452+  5A57 EB           	EX DE,HL
453+  5A58 26 00        	LD H,0
454+  5A5A 3A 97 5C     	LD A,(BLIT_TMP+0)
455+  5A5D 6F           	LD L,A
456+  5A5E CD 41 5E     	CALL HLx8
457+  5A61 19           	ADD HL,DE
458+  5A62 ED 5B 9F 5C  	LD DE,(BLIT_STRUCT+4)
459+  5A66 19           	ADD HL,DE
460+  5A67 22 9F 5C     	LD (BLIT_STRUCT+4),HL
461+  5A6A
462+  5A6A FD 21 71 5A  	LD IY, .RET
463+  5A6E C3 05 5F     	JP ENABLE_PAGE0
464+  5A71              .RET:
465+  5A71 FB           	EI
466+  5A72 DD 21 9B 5C  	LD IX, BLIT_STRUCT
467+  5A76 CD FE 58     	CALL SHIFT_MERGE_CHARACTER
468+  5A79
469+  5A79 D1               POP DE
470+  5A7A C1               POP BC
471+  5A7B CD 7C 5E         CALL RESTORE_PAGE_INFO
472+  5A7E
473+  5A7E E1           	POP HL
474+  5A7F C9           	RET
475+  5A80              .DAdiv8:
476+  5A80 7B           	LD A,E
477+  5A81 CB 2A        	SRA D
478+  5A83 CB 1F            RR  A
479+  5A85 CB 2A            SRA D
480+  5A87 CB 1F            RR  A
481+  5A89 CB 2A            SRA D
482+  5A8B CB 1F            RR  A
483+  5A8D C9           	RET
484+  5A8E              ; *******************************************************************************************************
485+  5A8E               ENDIF
# file closed: asm\BLIT.asm
144   5A8E               ENDIF
145   5A8E
146   5A8E               IF (TILE_CMDS == 1)
147   5A8E               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
  1+  5A8E              ; *******************************************************************************************************
  2+  5A8E              ; generic function to implement tiling
  3+  5A8E              ; should be modified to call appropriate function for memory or vram
  4+  5A8E              ; input IX=pointer to following structure
  5+  5A8E              ; +00 tile_data_ptr
  6+  5A8E              ; +02 tile_rows
  7+  5A8E              ; +04 tile_columns
  8+  5A8E              ; +06 destination_address
  9+  5A8E              ; +08 dest_to_next_row_add_to_value
 10+  5A8E              ; +10 num_horizontal_tiles
 11+  5A8E              ; +12 num_vertical_tiles
 12+  5A8E              ; modifies AF, BC, DE, HL
 13+  5A8E              TILE:
 14+  5A8E DD 6E 06     	LD L, (IX+6)
 15+  5A91 DD 66 07     	LD H, (IX+7) ; destination address
 16+  5A94 22 97 5C     	LD (TILETMP1), HL
 17+  5A97 DD 46 0C     	LD B, (IX+12) ; vertical tile number
 18+  5A9A              .L1:
 19+  5A9A C5           	PUSH BC
 20+  5A9B DD 6E 00     		LD L, (IX+0)
 21+  5A9E DD 66 01     		LD H, (IX+1) ; tile address
 22+  5AA1 22 99 5C     		LD (TILETMP2), HL
 23+  5AA4 DD 46 02     		LD B, (IX+2) ; tile rows
 24+  5AA7              .L2:
 25+  5AA7 C5           		PUSH BC
 26+  5AA8 CD 00 00     .CALL1:		CALL 0
 27+  5AAB DD 46 0A     			LD B, (IX+10) ; horizontal tile num
 28+  5AAE              .L3:
 29+  5AAE C5           			PUSH BC
 30+  5AAF 2A 99 5C     				LD HL, (TILETMP2)
 31+  5AB2 DD 46 04     				LD B, (IX+4) ; tile columns
 32+  5AB5              .L4:
 33+  5AB5 C5           				PUSH BC
 34+  5AB6              .CALL2:
 35+  5AB6 CD 00 00     					CALL 0
 36+  5AB9 C1           				POP BC
 37+  5ABA 10 F9        				DJNZ .L4
 38+  5ABC C1           			POP BC
 39+  5ABD 10 EF        			DJNZ .L3
 40+  5ABF 22 99 5C     			LD (TILETMP2), HL
 41+  5AC2 2A 97 5C     			LD HL, (TILETMP1)
 42+  5AC5 DD 5E 08     			LD E, (IX+8)
 43+  5AC8 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
 44+  5ACB 19           			ADD HL, DE
 45+  5ACC 22 97 5C     			LD (TILETMP1), HL
 46+  5ACF C1           		POP BC
 47+  5AD0 10 D5        		DJNZ .L2
 48+  5AD2 C1           	POP BC
 49+  5AD3 10 C5        	DJNZ .L1
 50+  5AD5 C9           	RET
 51+  5AD6              ; *******************************************************************************************************
 52+  5AD6
 53+  5AD6               IFNDEF CMDS_WITH_PARAMETERS
 54+  5AD6 ~            ; *******************************************************************************************************
 55+  5AD6 ~            ; function to handle CALL TILERAM basic extension
 56+  5AD6 ~            ; fills memory with tiles
 57+  5AD6 ~            ; TILERAM ( INT request_data_ptr )
 58+  5AD6 ~            ; request_data_ptr described in TILE
 59+  5AD6 ~            ; will put ram in page 0 also, page 1 is already there
 60+  5AD6 ~            TILERAM:
 61+  5AD6 ~            	; opening (
 62+  5AD6 ~            	CALL CHKCHAR
 63+  5AD6 ~            	DB '('
 64+  5AD6 ~            	; get pointer to request struct
 65+  5AD6 ~            	LD IX, FRMQNT
 66+  5AD6 ~            	CALL CALBAS
 67+  5AD6 ~            	PUSH DE
 68+  5AD6 ~            	; ending )
 69+  5AD6 ~            	CALL CHKCHAR
 70+  5AD6 ~            	DB ')'
 71+  5AD6 ~
 72+  5AD6 ~            	POP IX ; pointer to request struct
 73+  5AD6 ~
 74+  5AD6 ~            	PUSH HL ; save position in BASIC buffer
 75+  5AD6 ~
 76+  5AD6 ~            	LD IY, .RET
 77+  5AD6 ~            	JP ENABLE_PAGE0
 78+  5AD6 ~            .RET:
 79+  5AD6 ~            	EI
 80+  5AD6 ~            	; set RAM functions to call
 81+  5AD6 ~            	LD HL, .TILECOPY
 82+  5AD6 ~            	LD (TILE.CALL2+1), HL
 83+  5AD6 ~            	LD HL, .SETDESTROW
 84+  5AD6 ~            	LD (TILE.CALL1+1), HL
 85+  5AD6 ~            	LD A,1
 86+  5AD6 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 87+  5AD6 ~            	CALL TILE
 88+  5AD6 ~            	XOR A
 89+  5AD6 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
 90+  5AD6 ~
 91+  5AD6 ~                POP DE
 92+  5AD6 ~                POP BC
 93+  5AD6 ~                CALL RESTORE_PAGE_INFO
 94+  5AD6 ~
 95+  5AD6 ~            	POP HL
 96+  5AD6 ~            	RET
 97+  5AD6 ~            .TILECOPY:
 98+  5AD6 ~            	.8 LDI
 99+  5AD6 ~            	RET
100+  5AD6 ~            .SETDESTROW:
101+  5AD6 ~            	LD DE, (TILETMP1)
102+  5AD6 ~            	RET
103+  5AD6 ~            ; *******************************************************************************************************
104+  5AD6               ENDIF
105+  5AD6
106+  5AD6               IFDEF CMDS_WITH_PARAMETERS
107+  5AD6              ; *******************************************************************************************************
108+  5AD6              ; function to handle CALL TILERAM basic extension
109+  5AD6              ; fills memory with tiles
110+  5AD6              ; TILERAM ( INT tile_data_pointer,
111+  5AD6              ;			INT tile_columns,
112+  5AD6              ;			INT tile_rows,
113+  5AD6              ;			INT destination_pointer,
114+  5AD6              ;			INT destination_columns,
115+  5AD6              ;			INT destination_rows,
116+  5AD6              ;			INT destination_begin_column,
117+  5AD6              ;			INT destination_begin_row,
118+  5AD6              ;			INT number_of_tiles_horizontally,
119+  5AD6              ;			INT	number_of_tiles_vertically )
120+  5AD6              ; will put ram in page 0 also, page 1 is already there
121+  5AD6              TILERAM:
122+  5AD6              	; opening (
123+  5AD6 CD 52 5F     	CALL CHKCHAR
124+  5AD9 28           	DB '('
125+  5ADA              	; get tile data pointer coordinate
126+  5ADA DD 21 2F 54  	LD IX, FRMQNT
127+  5ADE CD 59 01     	CALL CALBAS
128+  5AE1 ED 53 9B 5C  	LD (BLIT_STRUCT+0), DE
129+  5AE5              	; comma
130+  5AE5 CD 52 5F     	CALL CHKCHAR
131+  5AE8 2C           	DB ','
132+  5AE9              	; get tile columns
133+  5AE9 DD 21 2F 54  	LD IX, FRMQNT
134+  5AED CD 59 01     	CALL CALBAS
135+  5AF0 ED 53 9F 5C  	LD (BLIT_STRUCT+4), DE
136+  5AF4              	; comma
137+  5AF4 CD 52 5F     	CALL CHKCHAR
138+  5AF7 2C           	DB ','
139+  5AF8              	; get tile columns
140+  5AF8 DD 21 2F 54  	LD IX, FRMQNT
141+  5AFC CD 59 01     	CALL CALBAS
142+  5AFF ED 53 9D 5C  	LD (BLIT_STRUCT+2), DE
143+  5B03              	; comma
144+  5B03 CD 52 5F     	CALL CHKCHAR
145+  5B06 2C           	DB ','
146+  5B07              	; get destintion pointer
147+  5B07 DD 21 2F 54  	LD IX, FRMQNT
148+  5B0B CD 59 01     	CALL CALBAS
149+  5B0E ED 53 A1 5C  	LD (BLIT_STRUCT+6), DE
150+  5B12              	; comma
151+  5B12 CD 52 5F     	CALL CHKCHAR
152+  5B15 2C           	DB ','
153+  5B16              	; get destination columns
154+  5B16 DD 21 2F 54  	LD IX, FRMQNT
155+  5B1A CD 59 01     	CALL CALBAS
156+  5B1D 7B           	LD A, E
157+  5B1E 32 97 5C     	LD (BLIT_TMP+0), A
158+  5B21              	; comma
159+  5B21 CD 52 5F     	CALL CHKCHAR
160+  5B24 2C           	DB ','
161+  5B25              	; get destination rows
162+  5B25 DD 21 2F 54  	LD IX, FRMQNT
163+  5B29 CD 59 01     	CALL CALBAS
164+  5B2C 7B           	LD A, E
165+  5B2D 32 98 5C     	LD (BLIT_TMP+1), A
166+  5B30              	; comma
167+  5B30 CD 52 5F     	CALL CHKCHAR
168+  5B33 2C           	DB ','
169+  5B34              	; get destination begin column
170+  5B34 DD 21 2F 54  	LD IX, FRMQNT
171+  5B38 CD 59 01     	CALL CALBAS
172+  5B3B 7B           	LD A, E
173+  5B3C 32 99 5C     	LD (BLIT_TMP+2), A
174+  5B3F              	; comma
175+  5B3F CD 52 5F     	CALL CHKCHAR
176+  5B42 2C           	DB ','
177+  5B43              	; get destination begin row
178+  5B43 DD 21 2F 54  	LD IX, FRMQNT
179+  5B47 CD 59 01     	CALL CALBAS
180+  5B4A 7B           	LD A, E
181+  5B4B 32 9A 5C     	LD (BLIT_TMP+3), A
182+  5B4E              	; comma
183+  5B4E CD 52 5F     	CALL CHKCHAR
184+  5B51 2C           	DB ','
185+  5B52              	; get number of tiles horizontally
186+  5B52 DD 21 2F 54  	LD IX, FRMQNT
187+  5B56 CD 59 01     	CALL CALBAS
188+  5B59 ED 53 A5 5C  	LD (BLIT_STRUCT+10), DE
189+  5B5D              	; comma
190+  5B5D CD 52 5F     	CALL CHKCHAR
191+  5B60 2C           	DB ','
192+  5B61              	; get number of tiles vertically
193+  5B61 DD 21 2F 54  	LD IX, FRMQNT
194+  5B65 CD 59 01     	CALL CALBAS
195+  5B68 ED 53 A7 5C  	LD (BLIT_STRUCT+12), DE
196+  5B6C              	; ending )
197+  5B6C CD 52 5F     	CALL CHKCHAR
198+  5B6F 29           	DB ')'
199+  5B70
200+  5B70 E5           	PUSH HL ; save position in BASIC buffer
201+  5B71
202+  5B71              	; calculate destination add to value
203+  5B71 26 00        	LD H, 0
204+  5B73 3A 97 5C     	LD A, (BLIT_TMP+0)
205+  5B76 6F           	LD L, A
206+  5B77 CD 41 5E     	CALL HLx8
207+  5B7A 22 A3 5C     	LD (BLIT_STRUCT+8), HL
208+  5B7D              	; calculate pointer to background location
209+  5B7D 21 00 00     	LD HL, 0
210+  5B80 3A 9A 5C     	LD A,(BLIT_TMP+3)
211+  5B83 B7           	OR A
212+  5B84 28 08        	JR Z, .L1
213+  5B86 47           	LD B,A
214+  5B87 ED 5B A3 5C  	LD DE,(BLIT_STRUCT+8)
215+  5B8B              .L0:
216+  5B8B 19           	ADD HL, DE
217+  5B8C 10 FD        	DJNZ .L0
218+  5B8E              .L1:
219+  5B8E EB           	EX DE,HL
220+  5B8F 26 00        	LD H,0
221+  5B91 3A 99 5C     	LD A,(BLIT_TMP+2)
222+  5B94 6F           	LD L,A
223+  5B95 CD 41 5E     	CALL HLx8
224+  5B98 19           	ADD HL,DE
225+  5B99 ED 5B A1 5C  	LD DE,(BLIT_STRUCT+6)
226+  5B9D 19           	ADD HL,DE
227+  5B9E 22 A1 5C     	LD (BLIT_STRUCT+6),HL
228+  5BA1
229+  5BA1 FD 21 A8 5B  	LD IY, .RET
230+  5BA5 C3 05 5F     	JP ENABLE_PAGE0
231+  5BA8              .RET:
232+  5BA8 FB           	EI
233+  5BA9              	; set RAM functions to call
234+  5BA9 21 C3 5B     	LD HL, .TILECOPY
235+  5BAC 22 B7 5A     	LD (TILE.CALL2+1), HL
236+  5BAF 21 D4 5B     	LD HL, .SETDESTROW
237+  5BB2 22 A9 5A     	LD (TILE.CALL1+1), HL
238+  5BB5 DD 21 9B 5C  	LD IX,BLIT_STRUCT
239+  5BB9 CD 8E 5A     	CALL TILE
240+  5BBC
241+  5BBC D1               POP DE
242+  5BBD C1               POP BC
243+  5BBE CD 7C 5E         CALL RESTORE_PAGE_INFO
244+  5BC1
245+  5BC1 E1           	POP HL
246+  5BC2 C9           	RET
247+  5BC3              .TILECOPY:
248+  5BC3 ED A0       > LDI
248+  5BC5 ED A0       > LDI
248+  5BC7 ED A0       > LDI
248+  5BC9 ED A0       > LDI
248+  5BCB ED A0       > LDI
248+  5BCD ED A0       > LDI
248+  5BCF ED A0       > LDI
248+  5BD1 ED A0       > LDI
249+  5BD3 C9           	RET
250+  5BD4              .SETDESTROW:
251+  5BD4 ED 5B 97 5C  	LD DE, (TILETMP1)
252+  5BD8 C9           	RET
253+  5BD9              ; *******************************************************************************************************
254+  5BD9               ENDIF
255+  5BD9
256+  5BD9               IFDEF CMDS_WITH_PARAMETERS
257+  5BD9              ; *******************************************************************************************************
258+  5BD9              ; function to handle CALL TILEVRM basic extension
259+  5BD9              ; fills vram with tiles
260+  5BD9              ; TILEVRM ( INT tile_data_pointer,
261+  5BD9              ;			INT tile_columns,
262+  5BD9              ;			INT tile_rows,
263+  5BD9              ;			INT destination_begin_column,
264+  5BD9              ;			INT destination_begin_row,
265+  5BD9              ;			INT number_of_tiles_horizontally,
266+  5BD9              ;			INT	number_of_tiles_vertically )
267+  5BD9              ; will put ram in page 0 also, page 1 is already there
268+  5BD9              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
269+  5BD9              TILEVRM:
270+  5BD9              	; opening (
271+  5BD9 CD 52 5F     	CALL CHKCHAR
272+  5BDC 28           	DB '('
273+  5BDD              	; get tile data pointer coordinate
274+  5BDD DD 21 2F 54  	LD IX, FRMQNT
275+  5BE1 CD 59 01     	CALL CALBAS
276+  5BE4 ED 53 9B 5C  	LD (BLIT_STRUCT+0), DE
277+  5BE8              	; comma
278+  5BE8 CD 52 5F     	CALL CHKCHAR
279+  5BEB 2C           	DB ','
280+  5BEC              	; get tile columns
281+  5BEC DD 21 2F 54  	LD IX, FRMQNT
282+  5BF0 CD 59 01     	CALL CALBAS
283+  5BF3 ED 53 9F 5C  	LD (BLIT_STRUCT+4), DE
284+  5BF7              	; comma
285+  5BF7 CD 52 5F     	CALL CHKCHAR
286+  5BFA 2C           	DB ','
287+  5BFB              	; get tile columns
288+  5BFB DD 21 2F 54  	LD IX, FRMQNT
289+  5BFF CD 59 01     	CALL CALBAS
290+  5C02 ED 53 9D 5C  	LD (BLIT_STRUCT+2), DE
291+  5C06              	; comma
292+  5C06 CD 52 5F     	CALL CHKCHAR
293+  5C09 2C           	DB ','
294+  5C0A              	; get destination begin column
295+  5C0A DD 21 2F 54  	LD IX, FRMQNT
296+  5C0E CD 59 01     	CALL CALBAS
297+  5C11 7B           	LD A, E
298+  5C12 32 99 5C     	LD (BLIT_TMP+2), A
299+  5C15              	; comma
300+  5C15 CD 52 5F     	CALL CHKCHAR
301+  5C18 2C           	DB ','
302+  5C19              	; get destination begin row
303+  5C19 DD 21 2F 54  	LD IX, FRMQNT
304+  5C1D CD 59 01     	CALL CALBAS
305+  5C20 7B           	LD A, E
306+  5C21 32 9A 5C     	LD (BLIT_TMP+3), A
307+  5C24              	; comma
308+  5C24 CD 52 5F     	CALL CHKCHAR
309+  5C27 2C           	DB ','
310+  5C28              	; get number of tiles horizontally
311+  5C28 DD 21 2F 54  	LD IX, FRMQNT
312+  5C2C CD 59 01     	CALL CALBAS
313+  5C2F ED 53 A5 5C  	LD (BLIT_STRUCT+10), DE
314+  5C33              	; comma
315+  5C33 CD 52 5F     	CALL CHKCHAR
316+  5C36 2C           	DB ','
317+  5C37              	; get number of tiles vertically
318+  5C37 DD 21 2F 54  	LD IX, FRMQNT
319+  5C3B CD 59 01     	CALL CALBAS
320+  5C3E ED 53 A7 5C  	LD (BLIT_STRUCT+12), DE
321+  5C42              	; ending )
322+  5C42 CD 52 5F     	CALL CHKCHAR
323+  5C45 29           	DB ')'
324+  5C46
325+  5C46 E5           	PUSH HL ; save position in BASIC buffer
326+  5C47
327+  5C47              	; calculate destination add to value
328+  5C47 21 00 01     	LD HL, 256
329+  5C4A 22 A3 5C     	LD (BLIT_STRUCT+8), HL
330+  5C4D              	; calculate pointer to background location
331+  5C4D 3A 9A 5C     	LD A,(BLIT_TMP+3)
332+  5C50 67           	LD H,A
333+  5C51 2E 00        	LD L,0
334+  5C53 EB           	EX DE,HL
335+  5C54 26 00        	LD H,0
336+  5C56 3A 99 5C     	LD A,(BLIT_TMP+2)
337+  5C59 6F           	LD L,A
338+  5C5A CD 41 5E     	CALL HLx8
339+  5C5D 19           	ADD HL,DE
340+  5C5E ED 5B CB F3  	LD DE,(GRPCGP)
341+  5C62 19           	ADD HL,DE
342+  5C63 22 A1 5C     	LD (BLIT_STRUCT+6),HL
343+  5C66
344+  5C66 FD 21 6D 5C  	LD IY, .RET
345+  5C6A C3 05 5F     	JP ENABLE_PAGE0
346+  5C6D              .RET:
347+  5C6D FB           	EI
348+  5C6E              	; set RAM functions to call
349+  5C6E 21 88 5C     	LD HL, .TILECOPY
350+  5C71 22 B7 5A     	LD (TILE.CALL2+1), HL
351+  5C74 21 8E 5C     	LD HL, .SETDESTROW
352+  5C77 22 A9 5A     	LD (TILE.CALL1+1), HL
353+  5C7A DD 21 9B 5C  	LD IX,BLIT_STRUCT
354+  5C7E CD 8E 5A     	CALL TILE
355+  5C81
356+  5C81 D1               POP DE
357+  5C82 C1               POP BC
358+  5C83 CD 7C 5E         CALL RESTORE_PAGE_INFO
359+  5C86
360+  5C86 E1           	POP HL
361+  5C87 C9           	RET
362+  5C88              .TILECOPY:
363+  5C88 01 98 08     	LD BC, #0898
364+  5C8B C3 39 5E     	JP BBYTECOPY_NO_C
365+  5C8E              .SETDESTROW:
366+  5C8E 2A 97 5C     	LD HL, (TILETMP1)
367+  5C91 F3           	DI
368+  5C92 CD 2C 5E     	CALL SETWRT_LOCAL
369+  5C95 FB           	EI
370+  5C96 C9           	RET
371+  5C97              ; *******************************************************************************************************
372+  5C97               ENDIF
373+  5C97
374+  5C97               IFNDEF CMDS_WITH_PARAMETERS
375+  5C97 ~            ; *******************************************************************************************************
376+  5C97 ~            ; function to handle CALL TILEVRM basic extension
377+  5C97 ~            ; fills vram with tiles
378+  5C97 ~            ; TILEVRM ( INT request_data_ptr )
379+  5C97 ~            ; request_data_ptr described in TILE
380+  5C97 ~            ; will put ram in page 0 also, page 1 is already there
381+  5C97 ~            TILEVRM:
382+  5C97 ~            	; opening (
383+  5C97 ~            	CALL CHKCHAR
384+  5C97 ~            	DB '('
385+  5C97 ~            	; get pointer to request struct
386+  5C97 ~            	LD IX, FRMQNT
387+  5C97 ~            	CALL CALBAS
388+  5C97 ~            	PUSH DE
389+  5C97 ~            	; ending )
390+  5C97 ~            	CALL CHKCHAR
391+  5C97 ~            	DB ')'
392+  5C97 ~
393+  5C97 ~            	POP IX ; pointer to request struct
394+  5C97 ~
395+  5C97 ~            	PUSH HL ; save position in BASIC buffer
396+  5C97 ~
397+  5C97 ~            	LD IY, .RET
398+  5C97 ~            	JP ENABLE_PAGE0
399+  5C97 ~            .RET:
400+  5C97 ~            	EI
401+  5C97 ~            	; set RAM functions to call
402+  5C97 ~            	LD HL, .TILECOPY
403+  5C97 ~            	LD (TILE.CALL2+1), HL
404+  5C97 ~            	LD HL, .SETDESTROW
405+  5C97 ~            	LD (TILE.CALL1+1), HL
406+  5C97 ~            	CALL TILE
407+  5C97 ~
408+  5C97 ~                POP DE
409+  5C97 ~                POP BC
410+  5C97 ~                CALL RESTORE_PAGE_INFO
411+  5C97 ~
412+  5C97 ~            	POP HL
413+  5C97 ~            	RET
414+  5C97 ~            .TILECOPY:
415+  5C97 ~            	LD BC, #0898
416+  5C97 ~            	JP BBYTECOPY_NO_C
417+  5C97 ~            .SETDESTROW:
418+  5C97 ~            	LD HL, (TILETMP1)
419+  5C97 ~            	DI
420+  5C97 ~            	CALL SETWRT_LOCAL
421+  5C97 ~            	EI
422+  5C97 ~            	RET
423+  5C97 ~            ; *******************************************************************************************************
424+  5C97               ENDIF
# file closed: asm\TILE.asm
148   5C97               ENDIF
149   5C97
150   5C97              ; temp variables for BLIT, TILE functions
151   5C97               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS > 0)
152   5C97              BLIT_TMP:
153   5C97              TILETMP1:
154   5C97              BLIT_TMP1:
155   5C97 00 00         DW 0
156   5C99              TILETMP2:
157   5C99              BLIT_TMP2:
158   5C99 00 00         DW 0
159   5C9B                IFDEF CMDS_WITH_PARAMETERS
160   5C9B              BLIT_STRUCT:
161   5C9B 00 00 00...   DS 17
162   5C9F                ENDIF
163   5C9F               ENDIF
164   5CAC
165   5CAC               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS > 0)
166   5CAC              VRAM_UPDATE_IN_PROGRESS:
167   5CAC 00            DB 0
168   5CAD               ENDIF
169   5CAD
170   5CAD              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
171   5CAD              ; per starting letter, if no commands with this letter, NULL value
172   5CAD              CMDS:
173   5CAD               IF (ANIM_CMDS == 1)
174   5CAD D6 5D        	DW CMDS_A ;
175   5CAF               ELSE
176   5CAF ~                DW 0 ; A
177   5CAF               ENDIF
178   5CAF               IF (BLIT_CMDS + BOX_CMDS > 0)
179   5CAF A1 5D            DW CMDS_B ; B
180   5CB1               ELSE
181   5CB1 ~            	DW 0
182   5CB1               ENDIF
183   5CB1 00 00            DW 0 ; C
184   5CB3 00 00            DW 0 ; D
185   5CB5 00 00            DW 0 ; E
186   5CB7               IF (VRAM_CMDS + RAM_CMDS > 0)
187   5CB7 1F 5D            DW CMDS_F; F
188   5CB9               ELSE
189   5CB9 ~            	DW 0
190   5CB9               ENDIF
191   5CB9               IF (GENCAL_CMD > 0)
192   5CB9 32 5D            DW CMDS_G; G
193   5CBB               ELSE
194   5CBB ~            	DW 0
195   5CBB               ENDIF
196   5CBB 00 00            DW 0 ; H
197   5CBD 00 00            DW 0 ; I
198   5CBF 00 00            DW 0 ; J
199   5CC1 00 00            DW 0 ; K
200   5CC3 00 00            DW 0 ; L
201   5CC5               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
202   5CC5 E1 5C            DW CMDS_M ; M
203   5CC7               ELSE
204   5CC7 ~            	DW 0
205   5CC7               ENDIF
206   5CC7 00 00            DW 0 ; N
207   5CC9 00 00            DW 0 ; O
208   5CCB 00 00            DW 0 ; P
209   5CCD 00 00            DW 0 ; Q
210   5CCF 00 00            DW 0 ; R
211   5CD1               IF (SOUND_CMDS + SPRITE_CMDS > 0)
212   5CD1 46 5D            DW CMDS_S ; S
213   5CD3               ELSE
214   5CD3 ~            	DW 0
215   5CD3               ENDIF
216   5CD3               IF (TILE_CMDS > 0)
217   5CD3 C1 5D            DW CMDS_T ; T
218   5CD5               ELSE
219   5CD5 ~            	DW 0
220   5CD5               ENDIF
221   5CD5 00 00            DW 0 ; U
222   5CD7               IF (VRAM_CMDS > 0)
223   5CD7 3C 5D            DW CMDS_V ; V
224   5CD9               ELSE
225   5CD9 ~            	DW 0
226   5CD9               ENDIF
227   5CD9 00 00            DW 0 ; W
228   5CDB 00 00            DW 0 ; X
229   5CDD 00 00            DW 0 ; Y
230   5CDF 00 00            DW 0 ; Z
231   5CE1
232   5CE1              CMDS_M:
233   5CE1               IF (VRAM_CMDS == 1)
234   5CE1 4D 45 4D 56      DB "MEMVRM", 0
234   5CE5 52 4D 00
235   5CE8 DC 55            DW MEMVRM
236   5CEA               ENDIF
237   5CEA               IF (RAM_CMDS == 1)
238   5CEA 4D 45 4D 43  	DB "MEMCPY", 0
238   5CEE 50 59 00
239   5CF1 12 54        	DW MEMCPY
240   5CF3               ENDIF
241   5CF3               IF (ANIM_CMDS == 1)
242   5CF3 4D 41 58 41  	DB "MAXANIMITEMS",0
242   5CF7 4E 49 4D 49
242   5CFB 54 45 4D 53
242   5CFF 00
243   5D00 EA 4F        	DW MAXANIMITEMS
244   5D02 4D 41 58 41  	DB "MAXANIMDEFS",0
244   5D06 4E 49 4D 44
244   5D0A 45 46 53 00
245   5D0E 5F 51        	DW MAXANIMDEFS
246   5D10 4D 41 58 41  	DB "MAXANIMSPRS",0
246   5D14 4E 49 4D 53
246   5D18 50 52 53 00
247   5D1C F4 51        	DW MAXANIMSPRS
248   5D1E               ENDIF
249   5D1E               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
250   5D1E 00           	DB 0
251   5D1F               ENDIF
252   5D1F              CMDS_F:
253   5D1F               IF (VRAM_CMDS == 1)
254   5D1F 46 49 4C 56      DB "FILVRM", 0
254   5D23 52 4D 00
255   5D26 8C 55            DW FILVRM
256   5D28               ENDIF
257   5D28               IF (RAM_CMDS == 1)
258   5D28 46 49 4C 52      DB "FILRAM", 0
258   5D2C 41 4D 00
259   5D2F 55 54            DW FILRAM
260   5D31               ENDIF
261   5D31               IF (VRAM_CMDS + RAM_CMDS > 0)
262   5D31 00               DB 0
263   5D32               ENDIF
264   5D32              CMDS_G:
265   5D32               IF (GENCAL_CMD == 1)
266   5D32 47 45 4E 43      DB "GENCAL", 0
266   5D36 41 4C 00
267   5D39 C0 56            DW GENCAL
268   5D3B               ENDIF
269   5D3B               IF (GENCAL_CMD > 0)
270   5D3B 00           	DB	0
271   5D3C               ENDIF
272   5D3C              CMDS_V:
273   5D3C               IF (VRAM_CMDS == 1)
274   5D3C 56 52 4D 4D  	DB "VRMMEM", 0
274   5D40 45 4D 00
275   5D43 5B 56        	DW VRMMEM
276   5D45               ENDIF
277   5D45               IF (VRAM_CMDS > 0)
278   5D45 00           	DB 0
279   5D46               ENDIF
280   5D46              CMDS_S:
281   5D46               IF (SPRITE_CMDS == 1)
282   5D46 53 50 52 53  	DB "SPRSET", 0
282   5D4A 45 54 00
283   5D4D 81 4E        	DW SPRSET
284   5D4F 53 50 52 47  	DB "SPRGRPMOV", 0
284   5D53 52 50 4D 4F
284   5D57 56 00
285   5D59 32 4F        	DW SPRGRPMOV
286   5D5B               ENDIF
287   5D5B               IF (SOUND_CMDS == 1)
288   5D5B 53 4E 44 53  	DB "SNDSFX", 0
288   5D5F 46 58 00
289   5D62 32 55        	DW SNDSFX
290   5D64 53 4E 44 50  	DB "SNDPLYON", 0
290   5D68 4C 59 4F 4E
290   5D6C 00
291   5D6D FC 54        	DW SNDPLYON
292   5D6F 53 4E 44 50  	DB "SNDPLYOFF", 0
292   5D73 4C 59 4F 46
292   5D77 46 00
293   5D79 0F 55        	DW SNDPLYOFF
294   5D7B 53 4E 44 50  	DB "SNDPLYINI", 0
294   5D7F 4C 59 49 4E
294   5D83 49 00
295   5D85 B2 54        	DW SNDPLYINIT
296   5D87               ENDIF
297   5D87               IF (SPRITE_CMDS == 1)
298   5D87 53 50 52 45  	DB "SPRENABLE", 0
298   5D8B 4E 41 42 4C
298   5D8F 45 00
299   5D91 3C 4E        	DW SPRENABLE
300   5D93 53 50 52 44  	DB "SPRDISABLE", 0
300   5D97 49 53 41 42
300   5D9B 4C 45 00
301   5D9E 7C 4E        	DW SPRDISABLE
302   5DA0               ENDIF
303   5DA0               IF (SOUND_CMDS + SPRITE_CMDS > 0)
304   5DA0 00           	DB 0
305   5DA1               ENDIF
306   5DA1              CMDS_B:
307   5DA1               IF (BLIT_CMDS == 1)
308   5DA1 42 4C 49 54  	DB "BLIT", 0
308   5DA5 00
309   5DA6 92 59        	DW BLIT
310   5DA8               ENDIF
311   5DA8               IF (BOX_CMDS == 1)
312   5DA8 42 4F 58 4D  	DB "BOXMEMCPY", 0
312   5DAC 45 4D 43 50
312   5DB0 59 00
313   5DB2 4F 57        	DW BOXMEMCPY
314   5DB4 42 4F 58 4D  	DB "BOXMEMVRM", 0
314   5DB8 45 4D 56 52
314   5DBC 4D 00
315   5DBE E4 57        	DW BOXMEMVRM
316   5DC0               ENDIF
317   5DC0               IF (BLIT_CMDS + BOX_CMDS > 0)
318   5DC0 00           	DB 0
319   5DC1               ENDIF
320   5DC1              CMDS_T:
321   5DC1               IF (TILE_CMDS == 1)
322   5DC1 54 49 4C 45  	DB "TILERAM", 0
322   5DC5 52 41 4D 00
323   5DC9 D6 5A        	DW TILERAM
324   5DCB 54 49 4C 45  	DB "TILEVRM", 0
324   5DCF 56 52 4D 00
325   5DD3 D9 5B        	DW TILEVRM
326   5DD5               ENDIF
327   5DD5               IF (TILE_CMDS > 0)
328   5DD5 00           	DB 0
329   5DD6               ENDIF
330   5DD6              CMDS_A:
331   5DD6               IF (ANIM_CMDS == 1)
332   5DD6 41 4E 49 4D      DB "ANIMSTEP",0
332   5DDA 53 54 45 50
332   5DDE 00
333   5DDF B2 52            DW ANIMSTEP
334   5DE1 41 4E 49 4D  	DB "ANIMSTART",0
334   5DE5 53 54 41 52
334   5DE9 54 00
335   5DEB B7 52        	DW ANIMSTART
336   5DED 41 4E 49 4D  	DB "ANIMSTOP",0
336   5DF1 53 54 4F 50
336   5DF5 00
337   5DF6 BC 52        	DW ANIMSTOP
338   5DF8 41 4E 49 4D  	DB "ANIMITEMPAT",0
338   5DFC 49 54 45 4D
338   5E00 50 41 54 00
339   5E04 AA 50        	DW ANIMITEMPAT
340   5E06 41 4E 49 4D  	DB "ANIMITEMPTR",0
340   5E0A 49 54 45 4D
340   5E0E 50 54 52 00
341   5E12 0B 51        	DW ANIMITEMPTR_CMD
342   5E14 41 4E 49 4D  	DB "ANIMDEF",0
342   5E18 44 45 46 00
343   5E1C A1 51        	DW ANIMDEF
344   5E1E 41 4E 49 4D  	DB "ANIMSPRITE",0
344   5E22 53 50 52 49
344   5E26 54 45 00
345   5E29 4A 52        	DW ANIMSPRITE
346   5E2B 00           	DB 0
347   5E2C               ENDIF
348   5E2C
349   5E2C               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
350   5E2C              ; ****************************************************************************************************
351   5E2C              ; function sets VRAM address
352   5E2C              ; input HL=address
353   5E2C              ; modifies AF
354   5E2C              SETWRT_LOCAL:
355   5E2C 7D           	LD	A, L
356   5E2D D3 99        	OUT	(099H), A
357   5E2F 7C           	LD	A, H
358   5E30 E6 3F        	AND	03FH
359   5E32 F6 40        	OR	040H
360   5E34 D3 99        	OUT	(099H), A
361   5E36 C9           	RET
362   5E37              ; ****************************************************************************************************
363   5E37               ENDIF
364   5E37
365   5E37               IF (VRAM_CMDS + TILE_CMDS > 0)
366   5E37              ; ****************************************************************************************************
367   5E37              ; function copies data from RAM to VRAM
368   5E37              ; input HL=address in RAM
369   5E37              ; input B=count
370   5E37              ; modifies AF, BC, HL
371   5E37              BBYTECOPY:
372   5E37 0E 98        	LD C,#98
373   5E39              BBYTECOPY_NO_C:
374   5E39 ED A3        	OUTI
375   5E3B C2 39 5E     	JP	NZ, BBYTECOPY_NO_C
376   5E3E C9           	RET
377   5E3F              ; ****************************************************************************************************
378   5E3F               ENDIF
379   5E3F
380   5E3F              ; ****************************************************************************************************
381   5E3F              ; function multiplies HL by 32
382   5E3F              HLx32:
383   5E3F 29           	ADD HL,HL
384   5E40              ; ****************************************************************************************************
385   5E40              ; function multiplies HL by 16
386   5E40              HLx16:
387   5E40 29           	ADD HL,HL
388   5E41              ; ****************************************************************************************************
389   5E41              ; function multiplies HL by 8
390   5E41              HLx8:
391   5E41 29          > ADD HL, HL
391   5E42 29          > ADD HL, HL
391   5E43 29          > ADD HL, HL
392   5E44 C9           	RET
393   5E45              ; ****************************************************************************************************
394   5E45
395   5E45              ; ****************************************************************************************************
396   5E45              ; function gets slot and subslot data for specific page
397   5E45              ; input A=page (0, 1 or 2)
398   5E45              ; output B = 0A8H register value
399   5E45              ; output D = 0 is no subslots, 1 if yes
400   5E45              ; output C = 0A8H value when page 3 slot equals to requested page slot
401   5E45              ; output E = subslot value if present
402   5E45              ; modifies AF, BC, DE, HL
403   5E45              GET_PAGE_INFO:
404   5E45 6F               LD L, A
405   5E46 C6 C1            ADD A, low (EXPTBL)
406   5E48 32 52 5E         LD (GET_PAGE_INFO_L1+1), A
407   5E4B DB A8            IN A, (0A8H)
408   5E4D 47               LD B, A
409   5E4E E6 3F            AND 03FH
410   5E50 4F               LD C, A
411   5E51              GET_PAGE_INFO_L1:
412   5E51 3A C1 FC         LD A, (EXPTBL) ; modified by code above
413   5E54 E6 80            AND 080H
414   5E56 28 1B            JR Z, GET_PAGE_INFO_L2
415   5E58                  ; expanded
416   5E58 2D               DEC L
417   5E59 FA 78 5E         JP M, GET_PAGE_INFO_L3
418   5E5C 2D               DEC L
419   5E5D FA 76 5E         JP M, GET_PAGE_INFO_L4
420   5E60                  ; page 2
421   5E60 07               RLCA
422   5E61 07               RLCA
423   5E62              GET_PAGE_INFO_L5:
424   5E62 E6 C0            AND 0C0H
425   5E64 B1               OR C
426   5E65 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
427   5E67 4F               LD C, A
428   5E68 3A FF FF         LD A, (0FFFFH)
429   5E6B 2F               CPL
430   5E6C 5F               LD E, A
431   5E6D 16 01            LD D, 1
432   5E6F 78               LD A, B ; return stack
433   5E70 D3 A8            OUT (0A8H), A
434   5E72 C9               RET
435   5E73              GET_PAGE_INFO_L2:
436   5E73                  ; not expanded
437   5E73 16 00            LD D, 0
438   5E75 C9               RET
439   5E76              GET_PAGE_INFO_L4:
440   5E76                  ; page 1
441   5E76 0F               RRCA
442   5E77 0F               RRCA
443   5E78              GET_PAGE_INFO_L3:
444   5E78                  ; page 0
445   5E78 0F               RRCA
446   5E79 0F               RRCA
447   5E7A 18 E6            JR GET_PAGE_INFO_L5
448   5E7C              ; ****************************************************************************************************
449   5E7C
450   5E7C              ; ****************************************************************************************************
451   5E7C              ; function returns original slot and subslot info
452   5E7C              ; input B = 0A8H register value
453   5E7C              ; input D = 0 is no subslots, 1 if yes
454   5E7C              ; input C = 0A8H value when page 3 slot equals to requested page slot
455   5E7C              ; input E = subslot value if present
456   5E7C              ; modifies AF, disables interrupts
457   5E7C              RESTORE_PAGE_INFO:
458   5E7C 7A               LD A, D
459   5E7D B7               OR A
460   5E7E 28 08            JR Z, RESTORE_PAGE_INFO_L1
461   5E80 79               LD A, C
462   5E81 F3           	DI
463   5E82 D3 A8            OUT (0A8H), A
464   5E84 7B               LD A, E
465   5E85 32 FF FF         LD (0FFFFH), A
466   5E88              RESTORE_PAGE_INFO_L1:
467   5E88 78               LD A, B
468   5E89 D3 A8            OUT (0A8H), A
469   5E8B C9               RET
470   5E8C              ; ****************************************************************************************************
471   5E8C
472   5E8C              ; *******************************************************************************************************
473   5E8C              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
474   5E8C              ; INPUT:  A = SLOT ID: EXXXSSPP
475   5E8C              ; E = EXPANDED FLAG
476   5E8C              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
477   5E8C              ; PP = PRIMARY SLOT NUMBER
478   5E8C              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
479   5E8C              ; CHANGES: AF, BC, DE
480   5E8C
481   5E8C              LOCAL_ENASLT:
482   5E8C CD AC 5E         CALL L0353
483   5E8F FA 99 5E         JP M, L0340
484   5E92 DB A8            IN A, (0A8H)
485   5E94 A1               AND C
486   5E95 B0               OR B
487   5E96 D3 A8            OUT (0A8H), A
488   5E98 C9               RET
489   5E99              L0340:
490   5E99 E5               PUSH HL
491   5E9A CD D1 5E         CALL L0378
492   5E9D 4F               LD C, A
493   5E9E 06 00            LD B, 0
494   5EA0 7D               LD A, L
495   5EA1 A4               AND H
496   5EA2 B2               OR D
497   5EA3 21 C5 FC         LD HL, 0FCC5H
498   5EA6 09               ADD HL, BC
499   5EA7 77               LD (HL), A
500   5EA8 E1               POP HL
501   5EA9 79               LD A, C
502   5EAA 18 E0            JR LOCAL_ENASLT
503   5EAC              L0353:
504   5EAC F3               DI
505   5EAD F5               PUSH AF
506   5EAE 7C               LD A, H
507   5EAF 07               RLCA
508   5EB0 07               RLCA
509   5EB1 E6 03            AND 3
510   5EB3 5F               LD E, A
511   5EB4 3E C0            LD A, 0C0H
512   5EB6              L035D:
513   5EB6 07               RLCA
514   5EB7 07               RLCA
515   5EB8 1D               DEC E
516   5EB9 F2 B6 5E         JP P, L035D
517   5EBC 5F               LD E, A
518   5EBD 2F               CPL
519   5EBE 4F               LD C, A
520   5EBF F1               POP AF
521   5EC0 F5               PUSH AF
522   5EC1 E6 03            AND 3
523   5EC3 3C               INC A
524   5EC4 47               LD B, A
525   5EC5 3E AB            LD A, 0ABH
526   5EC7              L036E:
527   5EC7 C6 55            ADD A, 055H
528   5EC9 10 FC            DJNZ L036E
529   5ECB 57               LD D, A
530   5ECC A3               AND E
531   5ECD 47               LD B, A
532   5ECE F1               POP AF
533   5ECF A7               AND A
534   5ED0 C9               RET
535   5ED1              L0378:
536   5ED1 F5               PUSH AF
537   5ED2 7A               LD A, D
538   5ED3 E6 C0            AND 0C0H
539   5ED5 4F               LD C, A
540   5ED6 F1               POP AF
541   5ED7 F5               PUSH AF
542   5ED8 57               LD D, A
543   5ED9 DB A8            IN A, (0A8H)
544   5EDB 47               LD B, A
545   5EDC E6 3F            AND 03FH
546   5EDE B1               OR C
547   5EDF D3 A8            OUT (0A8H), A
548   5EE1 7A               LD A, D
549   5EE2 0F               RRCA
550   5EE3 0F               RRCA
551   5EE4 E6 03            AND 3
552   5EE6 57               LD D, A
553   5EE7 3E AB            LD A, 0ABH
554   5EE9              L0390:
555   5EE9 C6 55            ADD A, 055H
556   5EEB 15               DEC D
557   5EEC F2 E9 5E         JP P, L0390
558   5EEF A3               AND E
559   5EF0 57               LD D, A
560   5EF1 7B               LD A, E
561   5EF2 2F               CPL
562   5EF3 67               LD H, A
563   5EF4 3A FF FF         LD A, (0FFFFH)
564   5EF7 2F               CPL
565   5EF8 6F               LD L, A
566   5EF9 A4               AND H
567   5EFA B2               OR D
568   5EFB 32 FF FF         LD (0FFFFH), A
569   5EFE 78               LD A, B
570   5EFF D3 A8            OUT (0A8H), A
571   5F01 F1               POP AF
572   5F02 E6 03            AND 3
573   5F04 C9               RET
574   5F05              ; *******************************************************************************************************
575   5F05
576   5F05              ; *******************************************************************************************************
577   5F05              ; some common code to activate page 0 and place values needed to restore original page on stack
578   5F05              ; input IY=return address
579   5F05              ENABLE_PAGE0:
580   5F05 AF               XOR A
581   5F06 CD 45 5E         CALL GET_PAGE_INFO
582   5F09 C5               PUSH BC
583   5F0A D5               PUSH DE
584   5F0B 3A 41 F3         LD A, (RAMAD0)
585   5F0E 26 00            LD H, 0
586   5F10 CD 8C 5E         CALL LOCAL_ENASLT
587   5F13 FD E9        	JP (IY)
588   5F15              ; *******************************************************************************************************
589   5F15
590   5F15              ; General BASIC CALL-instruction handler
591   5F15              CALLHAND:
592   5F15 E5           	PUSH HL
593   5F16 21 AD 5C     	LD	HL, CMDS ; pointer table based on starting letter
594   5F19 3A 89 FD         LD A, (PROCNM)
595   5F1C D6 41            SUB 'A'
596   5F1E 87               ADD A, A
597   5F1F 16 00            LD D, 0
598   5F21 5F               LD E, A
599   5F22 19               ADD HL, DE
600   5F23 5E               LD E, (HL)
601   5F24 23               INC HL
602   5F25 56               LD D, (HL)
603   5F26 7A               LD A, D
604   5F27 B3               OR E
605   5F28 28 23            JR Z, .CMDNOTRECOGNIZED
606   5F2A EB               EX DE, HL
607   5F2B              .CHKCMD:
608   5F2B 11 89 FD     	LD	DE, PROCNM
609   5F2E 1A           .LOOP:	LD	A,(DE)
610   5F2F BE           	CP	(HL)
611   5F30 20 11        	JR	NZ,.TONEXTCMD	; Not equal
612   5F32 13           	INC	DE
613   5F33 23           	INC	HL
614   5F34 A7           	AND	A
615   5F35 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
616   5F37 5E           	LD	E,(HL)
617   5F38 23           	INC	HL
618   5F39 56           	LD	D,(HL)
619   5F3A E1           	POP	HL		; routine address
620   5F3B CD 5C 5F     	CALL	GETPREVCHAR
621   5F3E CD 50 5F     	CALL	.CALLDE		; Call routine
622   5F41 A7           	AND	A
623   5F42 C9           	RET
624   5F43
625   5F43              .TONEXTCMD:
626   5F43 0E FF        	LD	C,0FFH
627   5F45 AF           	XOR	A
628   5F46 ED B1        	CPIR			; Skip to end of instruction name
629   5F48 23           	INC	HL
630   5F49 23           	INC	HL		; Skip address
631   5F4A BE           	CP	(HL)
632   5F4B 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
633   5F4D              .CMDNOTRECOGNIZED:
634   5F4D E1           	POP	HL
635   5F4E 37               SCF
636   5F4F C9           	RET
637   5F50
638   5F50              .CALLDE:
639   5F50 D5           	PUSH	DE
640   5F51 C9           	RET
641   5F52
642   5F52              ;---------------------------
643   5F52
644   5F52              ;GETSTRPNT:
645   5F52              ; OUT:
646   5F52              ; HL = String Address
647   5F52              ; B  = Lenght
648   5F52              ;        LD      HL,(USR)
649   5F52              ;        LD      B,(HL)
650   5F52              ;        INC     HL
651   5F52              ;        LD      E,(HL)
652   5F52              ;        INC     HL
653   5F52              ;        LD      D,(HL)
654   5F52              ;        EX      DE,HL
655   5F52              ;        RET
656   5F52
657   5F52              ;EVALTXTPARAM:
658   5F52              ;	CALL	CHKCHAR
659   5F52              ;	DEFB	"("             ; Check for (
660   5F52              ;	LD	IX,FRMEVL
661   5F52              ;	CALL	CALBAS		; Evaluate expression
662   5F52              ;       LD      A,(VALTYP)
663   5F52              ;        CP      3               ; Text type?
664   5F52              ;        JP      NZ,TYPE_MISMATCH
665   5F52              ;        PUSH	HL
666   5F52              ;        LD	IX,FRESTR         ; Free the temporary string
667   5F52              ;        CALL	CALBAS
668   5F52              ;        POP	HL
669   5F52              ;	CALL	CHKCHAR
670   5F52              ;	DEFB	")"             ; Check for )
671   5F52              ;        RET
672   5F52
673   5F52
674   5F52              CHKCHAR:
675   5F52 CD 5C 5F     	CALL	GETPREVCHAR	; Get previous basic char
676   5F55 E3           	EX	(SP),HL
677   5F56 BE           	CP	(HL) 	        ; Check if good char
678   5F57 20 17        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
679   5F59 23           	INC	HL
680   5F5A E3           	EX	(SP),HL
681   5F5B 23           	INC	HL		; Get next basic char
682   5F5C
683   5F5C              GETPREVCHAR:
684   5F5C 2B           	DEC	HL
685   5F5D DD 21 66 46  	LD	IX,CHRGTR
686   5F61 C3 59 01     	JP      CALBAS
687   5F64
688   5F64
689   5F64              TYPE_MISMATCH:
690   5F64 1E 0D            LD E, 13 ; Type mismatch
691   5F66 18 0A            JR THROW_ERROR
692   5F68              SUBSCRIPT_OUT_OF_RANGE:
693   5F68 1E 09            LD E,9 ; subscript out of range
694   5F6A 18 06        	JR THROW_ERROR
695   5F6C              OVERFLOW:
696   5F6C 1E 06        	LD E,6
697   5F6E 18 02        	JR THROW_ERROR
698   5F70              SYNTAX_ERROR:
699   5F70 1E 02            LD E, 2 ; Syntax error
700   5F72              THROW_ERROR:
701   5F72 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
702   5F76 C3 59 01     	JP	CALBAS
703   5F79
704   5F79              ;---------------------------
705   5F79
706   5F79              ; *******************************************************************************************************
707   5F79              ; helper function to get pointer to BASIC array data
708   5F79              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
709   5F79              ; input B=dimensions (1 or 2)
710   5F79              ; input D=minimal first dimension
711   5F79              ; input E=minimal second dimension, if applicable
712   5F79              ; returns BC=pointer to first data element
713   5F79              ; throws BASIC error if invalid type
714   5F79              GET_BASIC_ARRAY_DATA_POINTER:
715   5F79 D5           	PUSH DE
716   5F7A C5           	PUSH BC
717   5F7B F5           	PUSH AF
718   5F7C 3E 01            LD A,1
719   5F7E 32 A5 F6         LD (SUBFLG),A ; search for arrays only
720   5F81 DD 21 A4 5E  	LD IX, PTRGET
721   5F85 CD 59 01     	CALL CALBAS
722   5F88 AF               XOR A
723   5F89 32 A5 F6         LD (SUBFLG),A ; if not reset will cause syntax errors
724   5F8C 3A 63 F6     	LD A,(VALTYP)
725   5F8F D1           	POP DE ; required type
726   5F90 BA           	CP D
727   5F91 C2 64 5F     	JP NZ,TYPE_MISMATCH
728   5F94 0A           	LD A,(BC)
729   5F95 03           	INC BC
730   5F96 D1           	POP DE ; required number of dimensions
731   5F97 BA           	CP D
732   5F98 C2 64 5F     	JP NZ,TYPE_MISMATCH
733   5F9B D1           	POP DE ; required minimal array dimensions
734   5F9C 3D           	DEC A
735   5F9D 28 07        	JR Z,.ONE_DIMENSION
736   5F9F              	; 2-dimension array
737   5F9F 0A           	LD A,(BC)
738   5FA0 03          > INC BC
738   5FA1 03          > INC BC
739   5FA2 BB           	CP E
740   5FA3 DA 68 5F     	JP C,SUBSCRIPT_OUT_OF_RANGE
741   5FA6              .ONE_DIMENSION:
742   5FA6 0A           	LD A,(BC)
743   5FA7 03          > INC BC
743   5FA8 03          > INC BC
744   5FA9 BA           	CP D
745   5FAA DA 68 5F     	JP C,SUBSCRIPT_OUT_OF_RANGE
746   5FAD C9           	RET
747   5FAE              ; *******************************************************************************************************
748   5FAE
749   5FAE              EXT_END:
750   5FAE
# file closed: asm\main.asm
