# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000
  14  4000               DEFINE CMDS_WITH_PARAMETERS
  15  4000
  16  4000              CHPUT   EQU     #A2
  17  4000              CALBAS	EQU		#159
  18  4000              ERRHAND EQU     #406F
  19  4000              FRMEVL  EQU     #4C64
  20  4000              FRESTR	EQU		#67D0
  21  4000              ; FRMQNT = formula quantificator
  22  4000              ; input HL=pointer to current program expression
  23  4000              ; output HL=next address
  24  4000              ; output DE=integer datum
  25  4000              FRMQNT	EQU		#542F
  26  4000              ; GETBYT = get byte parameter
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output A=E=byte read
  30  4000              GETBYT		EQU		#521C
  31  4000              CHRGTR  	EQU     #4666
  32  4000              SYNCHR		EQU		#558C
  33  4000              VALTYP  	EQU     #F663
  34  4000              USR     	EQU     #F7F8
  35  4000              PROCNM		EQU		#FD89
  36  4000              BIOS_FILVRM EQU     #0056
  37  4000              CLIKSW		EQU		#F3DB
  38  4000              ATRBAS		EQU		#F928
  39  4000              GRPCGP		EQU		#F3CB
  40  4000
  41  4000              RAMAD0	EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  42  4000              RAMAD1	EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  43  4000              RAMAD2	EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  44  4000              RAMAD3	EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  45  4000              EXPTBL	EQU #FCC1
  46  4000              SCRMOD	EQU #FCAF ; current screen mode
  47  4000              REG1SAV EQU #F3E0 ; VDP(1)
  48  4000
  49  4000              ; BASIC error codes
  50  4000              ;01 NEXT without FOR
  51  4000              ;02 Syntax error
  52  4000              ;03 RETURN without GOSUB
  53  4000              ;04 Out of DATA
  54  4000              ;05 Illegal function call
  55  4000              ;06 Overflow
  56  4000              ;07 Out of memory
  57  4000              ;08 Undefined line number
  58  4000              ;09 Subscript out of range
  59  4000              ;10 Redimensioned array
  60  4000              ;11 Division by zero
  61  4000              ;12 Illegal direct
  62  4000              ;13 Type mismatch
  63  4000              ;14 Out of string space
  64  4000              ;15 String too long
  65  4000              ;16 String formula too complex
  66  4000              ;17 Can't CONTINUE
  67  4000              ;18 Undefined user function
  68  4000              ;19 Device I/O error
  69  4000              ;20 Verify error
  70  4000              ;21 No RESUME
  71  4000              ;22 RESUME without error
  72  4000              ;23 Unprintable error
  73  4000              ;24 Missing operand
  74  4000              ;25 Line buffer overflow
  75  4000              ;50 FIELD overflow
  76  4000              ;51 Internal error
  77  4000              ;52 Bad file number
  78  4000              ;53 File not found
  79  4000              ;54 File already open
  80  4000              ;55 Input past end
  81  4000              ;56 Bad file name
  82  4000              ;57 Direct statement in file
  83  4000              ;58 Sequential I/O only
  84  4000              ;59 File not OPEN
  85  4000
  86  4000
  87  4000               ; simulate cartridge with BASIC extension
  88  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  88  4004 29 52 00 00
  88  4008 00 00 00 00
  88  400C 00 00 00 00
  89  4010
  90  4010              ; this location #4010 stores last location used by basic extension
  91  4010              ; free memory after that point
  92  4010              FREEMEMPTR:
  93  4010 06 5B         DW EXT_END
  94  4012
  95  4012              ; this location #4012 stores extension version in DAA format
  96  4012              ; first byte is major version and second minor
  97  4012              VERSION:
  98  4012 00 70         DB #00, #70
  99  4014
 100  4014              ; binary included AKG player compiled at #4014
 101  4014               IF (SOUND_CMDS == 1)
 102  4014              	INCBIN "bin/AKG.bin"
 103  4CF0              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF0              MAIN_PLAYER_START EQU 04014H
   2+ 4CF0              PLY_AKG_START EQU 04014H
   3+ 4CF0              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 0401DH
   4+ 4CF0              PLY_AKG_INITSOUNDEFFECTS EQU 0401DH
   5+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04021H
   6+ 4CF0              PLY_AKG_PLAYSOUNDEFFECT EQU 04021H
   7+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04022H
   8+ 4CF0              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04022H
   9+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 04049H
  10+ 4CF0              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 04049H
  11+ 4CF0              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 04057H
  12+ 4CF0              PLY_AKG_PSES_PLAY EQU 04090H
  13+ 4CF0              PLY_AKG_PSES_READFIRSTBYTE EQU 04099H
  14+ 4CF0              PLY_AKG_PSES_S_ENDORLOOP EQU 040B1H
  15+ 4CF0              PLY_AKG_PSES_S_LOOP EQU 040BCH
  16+ 4CF0              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C2H
  17+ 4CF0              PLY_AKG_PSES_NOTREACHED EQU 040D5H
  18+ 4CF0              PLY_AKG_PSES_HARDWAREONLY EQU 040D9H
  19+ 4CF0              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E0H
  20+ 4CF0              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F2H
  21+ 4CF0              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FCH
  22+ 4CF0              PLY_AKG_PSES_H_AFTERRETRIG EQU 04106H
  23+ 4CF0              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411AH
  24+ 4CF0              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 0411FH
  25+ 4CF0              PLY_AKG_PSES_READHARDWAREPERIOD EQU 04127H
  26+ 4CF0              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04132H
  27+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 0413EH
  28+ 4CF0              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04140H
  29+ 4CF0              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04146H
  30+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414AH
  31+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414AH
  32+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414CH
  33+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414CH
  34+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414CH
  35+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 0414DH
  36+ 4CF0              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 0414EH
  37+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04152H
  38+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04152H
  39+ 4CF0              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04152H
  40+ 4CF0              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415AH
  41+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04162H
  42+ 4CF0              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04162H
  43+ 4CF0              PLY_AKG_INIT EQU 04162H
  44+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04162H
  45+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04190H
  46+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A4H
  47+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B6H
  48+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D5H
  49+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E2H
  50+ 4CF0              PLY_AKG_INIT_READWORDSANDFILL EQU 041E8H
  51+ 4CF0              PLY_AKG_INITTABLE0 EQU 041EBH
  52+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EBH
  53+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04205H
  54+ 4CF0              PLY_AKG_INITTABLE0_END EQU 04205H
  55+ 4CF0              PLY_AKG_INITTABLE1 EQU 04205H
  56+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04205H
  57+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 04209H
  58+ 4CF0              PLY_AKG_INITTABLE1_END EQU 04209H
  59+ 4CF0              PLY_AKG_INITTABLEORA EQU 04209H
  60+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 04209H
  61+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04221H
  62+ 4CF0              PLY_AKG_INITTABLEORA_END EQU 04221H
  63+ 4CF0              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04221H
  64+ 4CF0              PLY_AKG_STOP EQU 04221H
  65+ 4CF0              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04233H
  66+ 4CF0              PLY_AKG_PLAY EQU 04233H
  67+ 4CF0              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423BH
  68+ 4CF0              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04241H
  69+ 4CF0              PLY_AKG_READLINKER EQU 04246H
  70+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04246H
  71+ 4CF0              PLY_AKG_READLINKER_PTLINKER EQU 04246H
  72+ 4CF0              PLY_AKG_READLINKER_NOLOOP EQU 04251H
  73+ 4CF0              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428AH
  74+ 4CF0              PLY_AKG_READLINE EQU 0428DH
  75+ 4CF0              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 0428DH
  76+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04293H
  77+ 4CF0              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04293H
  78+ 4CF0              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A0H
  79+ 4CF0              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A4H
  80+ 4CF0              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042A7H
  81+ 4CF0              PLY_AKG_SPEEDTRACK_END EQU 042AAH
  82+ 4CF0              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042AAH
  83+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B0H
  84+ 4CF0              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B0H
  85+ 4CF0              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042BDH
  86+ 4CF0              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C1H
  87+ 4CF0              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C4H
  88+ 4CF0              PLY_AKG_EVENTTRACK_END EQU 042C7H
  89+ 4CF0              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042C7H
  90+ 4CF0              PLY_AKG_CHANNEL1_READTRACK EQU 042D3H
  91+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D3H
  92+ 4CF0              PLY_AKG_CHANNEL1_PTTRACK EQU 042D3H
  93+ 4CF0              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042EEH
  94+ 4CF0              PLY_AKG_CHANNEL1_WAIT EQU 042F9H
  95+ 4CF0              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04300H
  96+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04300H
  97+ 4CF0              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04300H
  98+ 4CF0              PLY_AKG_CHANNEL1_NOTE EQU 04309H
  99+ 4CF0              PLY_AKG_BASENOTEINDEX EQU 04309H
 100+ 4CF0              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430BH
 101+ 4CF0              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430BH
 102+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431BH
 103+ 4CF0              PLY_AKG_INSTRUMENTSTABLE EQU 0431BH
 104+ 4CF0              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 0432DH
 105+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 0433DH
 106+ 4CF0              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04365H
 107+ 4CF0              PLY_AKG_CHANNEL1_READCELLEND EQU 04368H
 108+ 4CF0              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 04368H
 109+ 4CF0              PLY_AKG_CHANNEL2_READTRACK EQU 04374H
 110+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04374H
 111+ 4CF0              PLY_AKG_CHANNEL2_PTTRACK EQU 04374H
 112+ 4CF0              PLY_AKG_CHANNEL2_SMALLWAIT EQU 0438FH
 113+ 4CF0              PLY_AKG_CHANNEL2_WAIT EQU 0439AH
 114+ 4CF0              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A1H
 115+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A1H
 116+ 4CF0              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A1H
 117+ 4CF0              PLY_AKG_CHANNEL2_NOTE EQU 043AAH
 118+ 4CF0              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043AFH
 119+ 4CF0              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043AFH
 120+ 4CF0              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D1H
 121+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E1H
 122+ 4CF0              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 04409H
 123+ 4CF0              PLY_AKG_CHANNEL2_READCELLEND EQU 0440CH
 124+ 4CF0              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440CH
 125+ 4CF0              PLY_AKG_CHANNEL3_READTRACK EQU 04418H
 126+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 04418H
 127+ 4CF0              PLY_AKG_CHANNEL3_PTTRACK EQU 04418H
 128+ 4CF0              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04433H
 129+ 4CF0              PLY_AKG_CHANNEL3_WAIT EQU 0443EH
 130+ 4CF0              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04445H
 131+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04445H
 132+ 4CF0              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04445H
 133+ 4CF0              PLY_AKG_CHANNEL3_NOTE EQU 0444EH
 134+ 4CF0              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04453H
 135+ 4CF0              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04453H
 136+ 4CF0              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04475H
 137+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04485H
 138+ 4CF0              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044ADH
 139+ 4CF0              PLY_AKG_CHANNEL3_READCELLEND EQU 044B0H
 140+ 4CF0              PLY_AKG_CURRENTSPEED EQU 044B0H
 141+ 4CF0              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B2H
 142+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B5H
 143+ 4CF0              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B5H
 144+ 4CF0              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044B8H
 145+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BBH
 146+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BBH
 147+ 4CF0              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044C7H
 148+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044CEH
 149+ 4CF0              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D1H
 150+ 4CF0              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044D7H
 151+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DAH
 152+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DAH
 153+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044E8H
 154+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044EDH
 155+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044F8H
 156+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FBH
 157+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FBH
 158+ 4CF0              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 044FEH
 159+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04501H
 160+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04501H
 161+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450AH
 162+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04514H
 163+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 04517H
 164+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 04517H
 165+ 4CF0              PLY_AKG_CHANNEL1_PITCH EQU 04517H
 166+ 4CF0              PLY_AKG_CHANNEL1_ISPITCH EQU 0451AH
 167+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 0451FH
 168+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACK EQU 0451FH
 169+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04523H
 170+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04525H
 171+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 04527H
 172+ 4CF0              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 0452EH
 173+ 4CF0              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 0452FH
 174+ 4CF0              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04532H
 175+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04532H
 176+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 0454EH
 177+ 4CF0              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 0454EH
 178+ 4CF0              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455BH
 179+ 4CF0              PLY_AKG_CHANNEL1_GLIDEOVER EQU 0455FH
 180+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 0456FH
 181+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 0456FH
 182+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04570H
 183+ 4CF0              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04571H
 184+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04573H
 185+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04573H
 186+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04573H
 187+ 4CF0              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04574H
 188+ 4CF0              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04575H
 189+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 04577H
 190+ 4CF0              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 04577H
 191+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 04577H
 192+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 04577H
 193+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 04577H
 194+ 4CF0              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457AH
 195+ 4CF0              PLY_AKG_CHANNEL1_PITCH_END EQU 0457CH
 196+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04584H
 197+ 4CF0              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04584H
 198+ 4CF0              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 04587H
 199+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458AH
 200+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458AH
 201+ 4CF0              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04596H
 202+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 0459DH
 203+ 4CF0              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A0H
 204+ 4CF0              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A6H
 205+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045A9H
 206+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045A9H
 207+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045B7H
 208+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BCH
 209+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045C7H
 210+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CAH
 211+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CAH
 212+ 4CF0              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045CDH
 213+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D0H
 214+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D0H
 215+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045D9H
 216+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E3H
 217+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E6H
 218+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E6H
 219+ 4CF0              PLY_AKG_CHANNEL2_PITCH EQU 045E6H
 220+ 4CF0              PLY_AKG_CHANNEL2_ISPITCH EQU 045E9H
 221+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045EEH
 222+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045EEH
 223+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F2H
 224+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F4H
 225+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F6H
 226+ 4CF0              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 045FDH
 227+ 4CF0              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 045FEH
 228+ 4CF0              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04601H
 229+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04601H
 230+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 0461DH
 231+ 4CF0              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 0461DH
 232+ 4CF0              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462AH
 233+ 4CF0              PLY_AKG_CHANNEL2_GLIDEOVER EQU 0462EH
 234+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 0463EH
 235+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 0463EH
 236+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 0463FH
 237+ 4CF0              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04640H
 238+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04642H
 239+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04642H
 240+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04642H
 241+ 4CF0              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04643H
 242+ 4CF0              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04644H
 243+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04646H
 244+ 4CF0              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04646H
 245+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04646H
 246+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04646H
 247+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04646H
 248+ 4CF0              PLY_AKG_CHANNEL2_GLIDE_END EQU 04649H
 249+ 4CF0              PLY_AKG_CHANNEL2_PITCH_END EQU 0464BH
 250+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04653H
 251+ 4CF0              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04653H
 252+ 4CF0              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04656H
 253+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 04659H
 254+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 04659H
 255+ 4CF0              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04665H
 256+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466CH
 257+ 4CF0              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 0466FH
 258+ 4CF0              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04675H
 259+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 04678H
 260+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 04678H
 261+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04686H
 262+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468BH
 263+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04696H
 264+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 04699H
 265+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 04699H
 266+ 4CF0              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469CH
 267+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 0469FH
 268+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE EQU 0469FH
 269+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046A8H
 270+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B2H
 271+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B5H
 272+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B5H
 273+ 4CF0              PLY_AKG_CHANNEL3_PITCH EQU 046B5H
 274+ 4CF0              PLY_AKG_CHANNEL3_ISPITCH EQU 046B8H
 275+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046BDH
 276+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046BDH
 277+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C1H
 278+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C3H
 279+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C5H
 280+ 4CF0              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CCH
 281+ 4CF0              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046CDH
 282+ 4CF0              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D0H
 283+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D0H
 284+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046ECH
 285+ 4CF0              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046ECH
 286+ 4CF0              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046F9H
 287+ 4CF0              PLY_AKG_CHANNEL3_GLIDEOVER EQU 046FDH
 288+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 0470DH
 289+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 0470DH
 290+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 0470EH
 291+ 4CF0              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 0470FH
 292+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04711H
 293+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04711H
 294+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04711H
 295+ 4CF0              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04712H
 296+ 4CF0              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04713H
 297+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04715H
 298+ 4CF0              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04715H
 299+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04715H
 300+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04715H
 301+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04715H
 302+ 4CF0              PLY_AKG_CHANNEL3_GLIDE_END EQU 04718H
 303+ 4CF0              PLY_AKG_CHANNEL3_PITCH_END EQU 0471AH
 304+ 4CF0              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04726H
 305+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04726H
 306+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04726H
 307+ 4CF0              PLY_AKG_CHANNEL1_TRACKNOTE EQU 04729H
 308+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472BH
 309+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04731H
 310+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04734H
 311+ 4CF0              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04734H
 312+ 4CF0              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 04737H
 313+ 4CF0              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04740H
 314+ 4CF0              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 04748H
 315+ 4CF0              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04755H
 316+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04755H
 317+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04755H
 318+ 4CF0              PLY_AKG_CHANNEL2_TRACKNOTE EQU 04758H
 319+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475AH
 320+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04760H
 321+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04763H
 322+ 4CF0              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04763H
 323+ 4CF0              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04766H
 324+ 4CF0              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 0476FH
 325+ 4CF0              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 04777H
 326+ 4CF0              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04785H
 327+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04785H
 328+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04785H
 329+ 4CF0              PLY_AKG_CHANNEL3_TRACKNOTE EQU 04788H
 330+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478AH
 331+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04790H
 332+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04793H
 333+ 4CF0              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04793H
 334+ 4CF0              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04796H
 335+ 4CF0              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 0479FH
 336+ 4CF0              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047A7H
 337+ 4CF0              PLY_AKG_SENDPSGREGISTERS EQU 047B6H
 338+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047BEH
 339+ 4CF0              PLY_AKG_PSGREG01_INSTR EQU 047BEH
 340+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047CEH
 341+ 4CF0              PLY_AKG_PSGREG23_INSTR EQU 047CEH
 342+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047DFH
 343+ 4CF0              PLY_AKG_PSGREG45_INSTR EQU 047DFH
 344+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F0H
 345+ 4CF0              PLY_AKG_PSGREG6_8_INSTR EQU 047F0H
 346+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04801H
 347+ 4CF0              PLY_AKG_PSGREG9_10_INSTR EQU 04801H
 348+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04812H
 349+ 4CF0              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04812H
 350+ 4CF0              PLY_AKG_PSGREG13_OLDVALUE EQU 04827H
 351+ 4CF0              PLY_AKG_RETRIG EQU 04829H
 352+ 4CF0              PLY_AKG_PSGREG13_INSTR EQU 0482BH
 353+ 4CF0              PLY_AKG_PSGREG13_END EQU 0483AH
 354+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483AH
 355+ 4CF0              PLY_AKG_SAVESP EQU 0483AH
 356+ 4CF0              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 0483EH
 357+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTS EQU 04846H
 358+ 4CF0              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04853H
 359+ 4CF0              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04853H
 360+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485BH
 361+ 4CF0              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 04868H
 362+ 4CF0              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 04868H
 363+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTS EQU 04870H
 364+ 4CF0              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487BH
 365+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS EQU 0487BH
 366+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488AH
 367+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488AH
 368+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04891H
 369+ 4CF0              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A1H
 370+ 4CF0              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A1H
 371+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048A8H
 372+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048A8H
 373+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048ABH
 374+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B4H
 375+ 4CF0              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B4H
 376+ 4CF0              PLY_AKG_READINSTRUMENTCELL EQU 048BAH
 377+ 4CF0              PLY_AKG_NOSOFTNOHARD EQU 048C7H
 378+ 4CF0              PLY_AKG_NSNH_NONOISE EQU 048DCH
 379+ 4CF0              PLY_AKG_SOFT EQU 048DFH
 380+ 4CF0              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E6H
 381+ 4CF0              PLY_AKG_S_NOTSIMPLE EQU 048EEH
 382+ 4CF0              PLY_AKG_S_AFTERSIMPLETEST EQU 048F1H
 383+ 4CF0              PLY_AKG_HARDTOSOFT EQU 048FEH
 384+ 4CF0              PLY_AKG_HS_JUMPRATIO EQU 04909H
 385+ 4CF0              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04936H
 386+ 4CF0              PLY_AKG_ENDWITHOUTLOOP EQU 04938H
 387+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 04938H
 388+ 4CF0              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 04938H
 389+ 4CF0              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04940H
 390+ 4CF0              PLY_AKG_SH_JUMPRATIO EQU 0494DH
 391+ 4CF0              PLY_AKG_SH_JUMPRATIOEND EQU 0496EH
 392+ 4CF0              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 0497DH
 393+ 4CF0              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04983H
 394+ 4CF0              PLY_AKG_H_OR_ENDWITHLOOP EQU 0499DH
 395+ 4CF0              PLY_AKG_H_RETRIGEND EQU 049AFH
 396+ 4CF0              PLY_AKG_H_AFTERRETRIG EQU 049B0H
 397+ 4CF0              PLY_AKG_ENDWITHLOOP EQU 049C2H
 398+ 4CF0              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049C9H
 399+ 4CF0              PLY_AKG_S_OR_H_NEXTBYTE EQU 049DFH
 400+ 4CF0              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049EDH
 401+ 4CF0              PLY_AKG_S_OR_H_AFTERPITCH EQU 049FDH
 402+ 4CF0              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0BH
 403+ 4CF0              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1AH
 404+ 4CF0              PLY_AKG_SHOHS_RETRIGEND EQU 04A29H
 405+ 4CF0              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2AH
 406+ 4CF0              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3CH
 407+ 4CF0              PLY_AKG_EFFECTTABLE EQU 04A4AH
 408+ 4CF0              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4AH
 409+ 4CF0              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A6EH
 410+ 4CF0              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A6EH
 411+ 4CF0              PLY_AKG_EFFECT_RESET EQU 04A71H
 412+ 4CF0              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A73H
 413+ 4CF0              PLY_AKG_EFFECT_VOLUME EQU 04A8EH
 414+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9AH
 415+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA0H
 416+ 4CF0              PLY_AKG_ARPEGGIOSTABLE EQU 04AA0H
 417+ 4CF0              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04AC7H
 418+ 4CF0              PLY_AKG_EFFECT_PITCHTABLE EQU 04ACEH
 419+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD4H
 420+ 4CF0              PLY_AKG_PITCHESTABLE EQU 04AD4H
 421+ 4CF0              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFBH
 422+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B02H
 423+ 4CF0              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B13H
 424+ 4CF0              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1AH
 425+ 4CF0              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2AH
 426+ 4CF0              PLY_AKG_EFFECT_PITCHUP EQU 04B3FH
 427+ 4CF0              PLY_AKG_EFFECT_PITCHSTOP EQU 04B51H
 428+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B58H
 429+ 4CF0              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B82H
 430+ 4CF0              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B82H
 431+ 4CF0              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9BH
 432+ 4CF0              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9BH
 433+ 4CF0              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BADH
 434+ 4CF0              PLY_AKG_EFFECT_LEGATO EQU 04BC3H
 435+ 4CF0              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BD7H
 436+ 4CF0              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BDFH
 437+ 4CF0              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BE7H
 438+ 4CF0              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BEFH
 439+ 4CF0              PLY_AKG_EVENT EQU 04BEFH
 440+ 4CF0              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF0H
 441+ 4CF0              PLY_AKG_PERIODTABLE EQU 04BF0H
 442+ 4CF0              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF0H
 443+ 4CF0              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF0H
 444+ 4CF0              PLY_AKG_PERIODTABLE_END EQU 04CF0H
 445+ 4CF0              PLY_AKG_END EQU 04CF0H
 446+ 4CF0              MAIN_PLAYER_END EQU 04CF0H
 447+ 4CF0              TESTEREND EQU 04CF0H
 448+ 4CF0
# file closed: ./symbol/AKG.sym
 104  4CF0               ENDIF
 105  4CF0
 106  4CF0              ORIG.HTIMI:
 107  4CF0 00 00 00 00  	DB 0, 0, 0, 0, 0
 107  4CF4 00
 108  4CF5               EXPORT ORIG.HTIMI
 109  4CF5
 110  4CF5               IF (SOUND_CMDS == 1)
 111  4CF5              MUSIC_INIT_STATUS:
 112  4CF5 00            DB 0
 113  4CF6              SFX_INIT_STATUS:
 114  4CF6 00            DB 0
 115  4CF7              SOUND_ENABLED:
 116  4CF7 00            DB 0
 117  4CF8               ENDIF
 118  4CF8
 119  4CF8               IF (SPRITE_CMDS == 1)
 120  4CF8               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4CF8              ; commands and variables related to sprites
   2+ 4CF8
   3+ 4CF8              SPRATR_INIT_STATUS:
   4+ 4CF8 00            DB 0
   5+ 4CF9              SPRATR_UPDATE_FLAG:
   6+ 4CF9 00 00         DW 0
   7+ 4CFB              SPRATR_DATA:
   8+ 4CFB 00 00         DW 0
   9+ 4CFD              SPRFLICKER_ENABLED:
  10+ 4CFD 00            DB 0
  11+ 4CFE              ; to support sprite flicker
  12+ 4CFE              FLICKER:
  13+ 4CFE 00            DB 0
  14+ 4CFF
  15+ 4CFF              ; to temporarily store stack pointer
  16+ 4CFF              TMPSP:
  17+ 4CFF 00 00         DW 0
  18+ 4D01
  19+ 4D01              ; *******************************************************************************************************
  20+ 4D01              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  21+ 4D01              ; struct {
  22+ 4D01              ; DW y
  23+ 4D01              ; DW x
  24+ 4D01              ; DW pattern (0-63)
  25+ 4D01              ; DW color
  26+ 4D01              ; } [32]
  27+ 4D01              ; will hide sprites whose location is outside of visible area
  28+ 4D01              ; works in screen 1 and 2
  29+ 4D01              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  30+ 4D01              ; modifies AF, AF', BC, DE, HL
  31+ 4D01              SPRATR_UPDATE:
  32+ 4D01              	; check if initialized
  33+ 4D01 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
  34+ 4D04 B7           	OR A
  35+ 4D05 C8           	RET Z
  36+ 4D06              	; check if update requested
  37+ 4D06 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
  38+ 4D09 7E           	LD A, (HL)
  39+ 4D0A B7           	OR A
  40+ 4D0B C8           	RET Z
  41+ 4D0C              	; check screen mode
  42+ 4D0C 3A AF FC     	LD A, (SCRMOD)
  43+ 4D0F 3D           	DEC A
  44+ 4D10 28 02        	JR Z, .L0 ; screen 1
  45+ 4D12 3D           	DEC A
  46+ 4D13 C0           	RET NZ ; not screen 2
  47+ 4D14              .L0:
  48+ 4D14 06 20        	LD B, 32 ; sprite number
  49+ 4D16 0E 98        	LD C, #98 ; register for vdp data output
  50+ 4D18              	; set VDP address
  51+ 4D18 2A 28 F9     	LD HL, (ATRBAS)
  52+ 4D1B 3A FD 4C     	LD A, (SPRFLICKER_ENABLED)
  53+ 4D1E B7           	OR A
  54+ 4D1F 28 03        	JR Z, .L3
  55+ 4D21 3A FE 4C     	LD A, (FLICKER)
  56+ 4D24              .L3:
  57+ 4D24 5F           	LD E, A
  58+ 4D25 08           	EX AF, AF'
  59+ 4D26 7B           	LD A, E
  60+ 4D27 87           	ADD A, A
  61+ 4D28 87           	ADD A, A
  62+ 4D29 16 00        	LD D, 0
  63+ 4D2B 5F           	LD E, A
  64+ 4D2C 19           	ADD HL, DE
  65+ 4D2D CD 44 51     	CALL SETWRT_LOCAL
  66+ 4D30 ED 73 FF 4C  	LD (TMPSP), SP
  67+ 4D34 ED 7B FB 4C  	LD SP, (SPRATR_DATA)
  68+ 4D38
  69+ 4D38              .LOOP:
  70+ 4D38 E1           	POP HL
  71+ 4D39 24           	INC H
  72+ 4D3A 28 0D        	JR Z, .L1 ; negative number above -256
  73+ 4D3C 25           	DEC H
  74+ 4D3D 20 15        	JR NZ, .OUT3 ; sprite verticall can't be visible
  75+ 4D3F 7D           	LD A, L
  76+ 4D40 FE C0        	CP 192
  77+ 4D42 30 10        	JR NC, .OUT3
  78+ 4D44 3D           	DEC A ; due to VDP rule that top of screen is -1
  79+ 4D45 57           	LD D, A
  80+ 4D46 C3 64 4D     	JP .X
  81+ 4D49              .L1:
  82+ 4D49 7D           	LD A, L
  83+ 4D4A C6 10        	ADD 16
  84+ 4D4C FA 54 4D     	JP M, .OUT3 ; below -16
  85+ 4D4F 2D           	DEC L ; due to VDP rule that top of screen is -1
  86+ 4D50 55           	LD D, L
  87+ 4D51 C3 64 4D     	JP .X
  88+ 4D54              .OUT3:
  89+ 4D54 E1           	POP HL ; skip x value
  90+ 4D55              .OUT2:
  91+ 4D55 E1           	POP HL ; skip pattern
  92+ 4D56 E1           	POP HL ; skip color
  93+ 4D57 3E D1        	LD A, #D1
  94+ 4D59 D3 98        	OUT (#98), A ; sprite hidden
  95+ 4D5B D3 98        	OUT (#98), A ; value unimportant
  96+ 4D5D D3 98        	OUT (#98), A ; value unimportant
  97+ 4D5F D3 98        	OUT (#98), A ; value unimportant
  98+ 4D61 C3 8F 4D     	JP .NEXT
  99+ 4D64              .X:
 100+ 4D64 E1           	POP HL
 101+ 4D65 24           	INC H
 102+ 4D66 28 08        	JR Z, .L2
 103+ 4D68 25           	DEC H
 104+ 4D69 20 EA        	JR NZ, .OUT2
 105+ 4D6B 1E 00        	LD E, 0 ; EC bit
 106+ 4D6D C3 79 4D     	JP .XY
 107+ 4D70              .L2:
 108+ 4D70 7D           	LD A, L
 109+ 4D71 C6 20        	ADD 32
 110+ 4D73 FA 55 4D     	JP M, .OUT2
 111+ 4D76 6F           	LD L, A
 112+ 4D77 1E 80        	LD E, #80
 113+ 4D79              .XY:
 114+ 4D79 ED 51        	OUT (C), D
 115+ 4D7B ED 69        	OUT (C), L
 116+ 4D7D E1           	POP HL ; pattern
 117+ 4D7E 3A E0 F3     	LD A, (REG1SAV)
 118+ 4D81 E6 02        	AND 2
 119+ 4D83 7D           	LD A, L
 120+ 4D84 28 02        	JR Z, .SMALLSPRITES
 121+ 4D86 87           	ADD A, A
 122+ 4D87 87           	ADD A, A ; needs to go at 4x
 123+ 4D88              .SMALLSPRITES:
 124+ 4D88 D3 98        	OUT (#98), A
 125+ 4D8A E1           	POP HL ; color
 126+ 4D8B 7D           	LD A, L
 127+ 4D8C B3           	OR E
 128+ 4D8D D3 98        	OUT (#98), A
 129+ 4D8F              .NEXT:
 130+ 4D8F 08           	EX AF, AF'
 131+ 4D90 3C           	INC A
 132+ 4D91 E6 1F        	AND 31
 133+ 4D93 C2 A7 4D     	JP NZ, .NEXT2
 134+ 4D96 08           	EX AF, AF'
 135+ 4D97 2A 28 F9     	LD HL, (ATRBAS)
 136+ 4D9A              	; CALL SETWRT_LOCAL not allowed as SP modified
 137+ 4D9A 7D           	LD	A, L
 138+ 4D9B D3 99        	OUT	(099H), A
 139+ 4D9D 7C           	LD	A, H
 140+ 4D9E E6 3F        	AND	03FH
 141+ 4DA0 F6 40        	OR	040H
 142+ 4DA2 D3 99        	OUT	(099H), A
 143+ 4DA4 C3 A8 4D     	JP .NEXT3
 144+ 4DA7              .NEXT2:
 145+ 4DA7 08           	EX AF, AF'
 146+ 4DA8              .NEXT3:
 147+ 4DA8 10 8E        	DJNZ .LOOP
 148+ 4DAA 08           	EX AF, AF'
 149+ 4DAB 3C           	INC A
 150+ 4DAC 32 FE 4C     	LD (FLICKER), A
 151+ 4DAF
 152+ 4DAF ED 7B FF 4C  	LD SP, (TMPSP)
 153+ 4DB3 2A F9 4C     	LD HL, (SPRATR_UPDATE_FLAG)
 154+ 4DB6 36 00        	LD (HL), 0 ; zero out update flag
 155+ 4DB8 C9           	RET
 156+ 4DB9              ; *******************************************************************************************************
 157+ 4DB9
 158+ 4DB9              ; *******************************************************************************************************
 159+ 4DB9              ; function to handle CALL SPRENABLE basic extension
 160+ 4DB9              ; initializes sprites handler
 161+ 4DB9              ; _SPRENABLE ( INT sprites_attributes_data,
 162+ 4DB9              ;			   INT update_variable_location,
 163+ 4DB9              ;			   INT sprite_flicker_enabled )
 164+ 4DB9              ; expects both locations to be in range #8000+ or throws an error
 165+ 4DB9              ; since these should be BASIC variables
 166+ 4DB9              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA and SPRFLICKER_ENABLED
 167+ 4DB9              SPRENABLE:
 168+ 4DB9              	; opening (
 169+ 4DB9 CD 66 52     	CALL CHKCHAR
 170+ 4DBC 28           	DB '('
 171+ 4DBD              	; get address of sprite attribute table DIM SA%(3,31)
 172+ 4DBD DD 21 2F 54  	LD IX, FRMQNT
 173+ 4DC1 CD 59 01     	CALL CALBAS
 174+ 4DC4 D5           	PUSH DE
 175+ 4DC5              	; comma
 176+ 4DC5 CD 66 52     	CALL CHKCHAR
 177+ 4DC8 2C           	DB ','
 178+ 4DC9              	; get address of sprite update flag location
 179+ 4DC9 DD 21 2F 54  	LD IX, FRMQNT
 180+ 4DCD CD 59 01     	CALL CALBAS
 181+ 4DD0 D5           	PUSH DE
 182+ 4DD1              	; comma
 183+ 4DD1 CD 66 52     	CALL CHKCHAR
 184+ 4DD4 2C           	DB ','
 185+ 4DD5              	; get flicker enabled flag
 186+ 4DD5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 4DD9 CD 59 01     	CALL CALBAS
 188+ 4DDC D5           	PUSH DE
 189+ 4DDD              	; ending )
 190+ 4DDD CD 66 52     	CALL CHKCHAR
 191+ 4DE0 29           	DB ')'
 192+ 4DE1
 193+ 4DE1 D1           	POP DE ; get flicker flag
 194+ 4DE2 7A           	LD A, D
 195+ 4DE3 B3           	OR E
 196+ 4DE4 32 FD 4C     	LD (SPRFLICKER_ENABLED), A
 197+ 4DE7
 198+ 4DE7 D1           	POP DE ; update variable location
 199+ 4DE8 CB 7A        	BIT 7, D ; is address >= &h8000
 200+ 4DEA 20 05        	JR NZ, .L1
 201+ 4DEC 1E 05        	LD E, 5 ; illegal function call
 202+ 4DEE C3 7E 52     	JP THROW_ERROR
 203+ 4DF1              .L1:
 204+ 4DF1 ED 53 F9 4C  	LD (SPRATR_UPDATE_FLAG), DE
 205+ 4DF5 D1           	POP DE ; address of sprite attribute table
 206+ 4DF6 CB 7A        	BIT 7, D ; is address >= &h8000
 207+ 4DF8 20 05        	JR NZ, .L2
 208+ 4DFA 1E 05        	LD E, 5 ; illegal function call
 209+ 4DFC C3 7E 52     	JP THROW_ERROR
 210+ 4DFF              .L2:
 211+ 4DFF ED 53 FB 4C  	LD (SPRATR_DATA), DE
 212+ 4E03 3E 01        	LD A, 1
 213+ 4E05 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 214+ 4E08 C9           	RET
 215+ 4E09              ; *******************************************************************************************************
 216+ 4E09
 217+ 4E09              ; *******************************************************************************************************
 218+ 4E09              ; function to handle CALL SPRDISABLE basic extension
 219+ 4E09              ; disables sprites handling
 220+ 4E09              ; _SPRDISABLE
 221+ 4E09              ; resets variable SPRATR_INIT_STATUS
 222+ 4E09              SPRDISABLE:
 223+ 4E09 AF           	XOR A
 224+ 4E0A 32 F8 4C     	LD (SPRATR_INIT_STATUS), A
 225+ 4E0D C9           	RET
 226+ 4E0E              ; *******************************************************************************************************
 227+ 4E0E
 228+ 4E0E              ; *******************************************************************************************************
 229+ 4E0E              ; function to handle CALL SPRSET basic extension
 230+ 4E0E              ; sets position, and optionally pattern and color of sprite
 231+ 4E0E              ; _SPRSET ( BYTE sprite_num , valid 0-31
 232+ 4E0E              ;			INT x,
 233+ 4E0E              ;			INT y,
 234+ 4E0E              ;			INT pattern, valid 0-63, otherwise ignored
 235+ 4E0E              ;			INT color, valid 0-15, otherwise ignored
 236+ 4E0E              SPRSET:
 237+ 4E0E 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 238+ 4E11 B7           	OR A
 239+ 4E12 20 05        	JR NZ, .L1
 240+ 4E14 1E 05        	LD E, 5 ; illegal function call
 241+ 4E16 C3 7E 52     	JP THROW_ERROR
 242+ 4E19              .L1:
 243+ 4E19              	; opening (
 244+ 4E19 CD 66 52     	CALL CHKCHAR
 245+ 4E1C 28           	DB '('
 246+ 4E1D              	; get sprite number
 247+ 4E1D DD 21 1C 52  	LD IX, GETBYT
 248+ 4E21 CD 59 01     	CALL CALBAS
 249+ 4E24 F5           	PUSH AF
 250+ 4E25              	; comma
 251+ 4E25 CD 66 52     	CALL CHKCHAR
 252+ 4E28 2C           	DB ','
 253+ 4E29              	; get x
 254+ 4E29 DD 21 2F 54  	LD IX, FRMQNT
 255+ 4E2D CD 59 01     	CALL CALBAS
 256+ 4E30 D5           	PUSH DE
 257+ 4E31              	; comma
 258+ 4E31 CD 66 52     	CALL CHKCHAR
 259+ 4E34 2C           	DB ','
 260+ 4E35              	; get y
 261+ 4E35 DD 21 2F 54  	LD IX, FRMQNT
 262+ 4E39 CD 59 01     	CALL CALBAS
 263+ 4E3C D5           	PUSH DE
 264+ 4E3D              	; comma
 265+ 4E3D CD 66 52     	CALL CHKCHAR
 266+ 4E40 2C           	DB ','
 267+ 4E41              	; get pattern
 268+ 4E41 DD 21 2F 54  	LD IX, FRMQNT
 269+ 4E45 CD 59 01     	CALL CALBAS
 270+ 4E48 D5           	PUSH DE
 271+ 4E49              	; comma
 272+ 4E49 CD 66 52     	CALL CHKCHAR
 273+ 4E4C 2C           	DB ','
 274+ 4E4D              	; get color
 275+ 4E4D DD 21 2F 54  	LD IX, FRMQNT
 276+ 4E51 CD 59 01     	CALL CALBAS
 277+ 4E54 D5           	PUSH DE
 278+ 4E55              	; ending )
 279+ 4E55 CD 66 52     	CALL CHKCHAR
 280+ 4E58 29           	DB ')'
 281+ 4E59
 282+ 4E59                  ; save position in BASIC text
 283+ 4E59 E5           	PUSH HL
 284+ 4E5A DD E1        	POP IX
 285+ 4E5C
 286+ 4E5C C1           	POP BC ; color
 287+ 4E5D D1           	POP DE ; pattern
 288+ 4E5E D9           	EXX
 289+ 4E5F C1           	POP BC ; y
 290+ 4E60 D1           	POP DE ; x
 291+ 4E61 F1           	POP AF ; sprite number
 292+ 4E62 FE 20        	CP 32
 293+ 4E64 38 05        	JR C, .L2
 294+ 4E66 1E 05        	LD E, 5 ; illegal function call
 295+ 4E68 C3 7E 52     	JP THROW_ERROR
 296+ 4E6B              .L2:
 297+ 4E6B              	; find location in sprite attributes table
 298+ 4E6B 87          > ADD A, A
 298+ 4E6C 87          > ADD A, A
 298+ 4E6D 87          > ADD A, A
 299+ 4E6E D5           	PUSH DE
 300+ 4E6F 16 00        	LD D, 0
 301+ 4E71 5F           	LD E, A
 302+ 4E72 2A FB 4C     	LD HL, (SPRATR_DATA)
 303+ 4E75 19           	ADD HL, DE
 304+ 4E76 D1           	POP DE
 305+ 4E77              	; set y
 306+ 4E77 71           	LD (HL), C
 307+ 4E78 23           	INC HL
 308+ 4E79 70           	LD (HL), B
 309+ 4E7A 23           	INC HL
 310+ 4E7B              	; set x
 311+ 4E7B 73           	LD (HL), E
 312+ 4E7C 23           	INC HL
 313+ 4E7D 72           	LD (HL), D
 314+ 4E7E 23           	INC HL
 315+ 4E7F E5           	PUSH HL
 316+ 4E80 D9           	EXX
 317+ 4E81 E1           	POP HL
 318+ 4E82              	; check if 0<=pattern<64
 319+ 4E82 7A           	LD A, D
 320+ 4E83 B7           	OR A
 321+ 4E84 20 0B        	JR NZ, .L3
 322+ 4E86 7B           	LD A, E
 323+ 4E87 FE 40        	CP 64
 324+ 4E89 30 06        	JR NC, .L3
 325+ 4E8B              	; set pattern
 326+ 4E8B              	;ADD A, A
 327+ 4E8B              	;ADD A, A
 328+ 4E8B              	;ADD A, A
 329+ 4E8B 77           	LD (HL), A
 330+ 4E8C 23           	INC HL
 331+ 4E8D 72           	LD (HL), D
 332+ 4E8E 23           	INC HL
 333+ 4E8F 18 02        	JR .L4
 334+ 4E91              .L3:
 335+ 4E91              	; skip pattern
 336+ 4E91 23          > INC HL
 336+ 4E92 23          > INC HL
 337+ 4E93              .L4:
 338+ 4E93              	; check if 0<=color<16
 339+ 4E93 78           	LD A, B
 340+ 4E94 B7           	OR A
 341+ 4E95 20 08        	JR NZ, .L5
 342+ 4E97 79           	LD A, C
 343+ 4E98 FE 10        	CP 16
 344+ 4E9A 30 03        	JR NC, .L5
 345+ 4E9C              	; set color
 346+ 4E9C 71           	LD (HL), C
 347+ 4E9D 23           	INC HL
 348+ 4E9E 70           	LD (HL), B
 349+ 4E9F
 350+ 4E9F              .L5:
 351+ 4E9F DD E5        	PUSH IX
 352+ 4EA1 E1           	POP HL
 353+ 4EA2 C9           	RET
 354+ 4EA3              ; *******************************************************************************************************
 355+ 4EA3
 356+ 4EA3              ; *******************************************************************************************************
 357+ 4EA3              ; function sets sprite location based on initial coordinates and offset provided
 358+ 4EA3              ; input A=sprite number in SPRATR_DATA , 0-31
 359+ 4EA3              ; input DE=initial x
 360+ 4EA3              ; input BC=initial y
 361+ 4EA3              ; input IY=location where delta y,x are located
 362+ 4EA3              ; modifies AF, HL, IX
 363+ 4EA3              SPRSET_DELTA_POS:
 364+ 4EA3 87          > ADD A, A
 364+ 4EA4 87          > ADD A, A
 364+ 4EA5 87          > ADD A, A
 365+ 4EA6 D5           	PUSH DE
 366+ 4EA7 16 00        	LD D, 0
 367+ 4EA9 5F           	LD E, A
 368+ 4EAA DD 2A FB 4C  	LD IX, (SPRATR_DATA)
 369+ 4EAE DD 19        	ADD IX, DE
 370+ 4EB0 D1           	POP DE
 371+ 4EB1              	; IX=sprite's y location
 372+ 4EB1 FD 6E 00     	LD L, (IY)
 373+ 4EB4 FD 66 01     	LD H, (IY+1)
 374+ 4EB7 09           	ADD HL, BC
 375+ 4EB8 DD 75 00     	LD (IX), L
 376+ 4EBB DD 74 01     	LD (IX+1), H
 377+ 4EBE FD 6E 02     	LD L, (IY+2)
 378+ 4EC1 FD 66 03     	LD H, (IY+3)
 379+ 4EC4 19           	ADD HL, DE
 380+ 4EC5 DD 75 02     	LD (IX+2), L
 381+ 4EC8 DD 74 03     	LD (IX+3), H
 382+ 4ECB C9           	RET
 383+ 4ECC              ; *******************************************************************************************************
 384+ 4ECC
 385+ 4ECC              ; *******************************************************************************************************
 386+ 4ECC              ; function to handle CALL SPRGRPMOV basic extension
 387+ 4ECC              ; sets position of a group of sprites described with
 388+ 4ECC              ; { int sprite_num, int delta_y, int delta_x } [count]
 389+ 4ECC              ; _SPRGRPMOV ( INT x,
 390+ 4ECC              ;			   INT y,
 391+ 4ECC              ;			   INT data_ptr,
 392+ 4ECC              ;			   BYTE count,
 393+ 4ECC              ; will put ram in page 0 also, page 1 is already there
 394+ 4ECC              SPRGRPMOV:
 395+ 4ECC 3A F8 4C     	LD A, (SPRATR_INIT_STATUS)
 396+ 4ECF B7           	OR A
 397+ 4ED0 20 05        	JR NZ, .L1
 398+ 4ED2 1E 05        	LD E, 5 ; illegal function call
 399+ 4ED4 C3 7E 52     	JP THROW_ERROR
 400+ 4ED7              .L1:
 401+ 4ED7              	; opening (
 402+ 4ED7 CD 66 52     	CALL CHKCHAR
 403+ 4EDA 28           	DB '('
 404+ 4EDB              	; get x
 405+ 4EDB DD 21 2F 54  	LD IX, FRMQNT
 406+ 4EDF CD 59 01     	CALL CALBAS
 407+ 4EE2 D5           	PUSH DE
 408+ 4EE3              	; comma
 409+ 4EE3 CD 66 52     	CALL CHKCHAR
 410+ 4EE6 2C           	DB ','
 411+ 4EE7              	; get y
 412+ 4EE7 DD 21 2F 54  	LD IX, FRMQNT
 413+ 4EEB CD 59 01     	CALL CALBAS
 414+ 4EEE D5           	PUSH DE
 415+ 4EEF              	; comma
 416+ 4EEF CD 66 52     	CALL CHKCHAR
 417+ 4EF2 2C           	DB ','
 418+ 4EF3              	; get data pointer
 419+ 4EF3 DD 21 2F 54  	LD IX, FRMQNT
 420+ 4EF7 CD 59 01     	CALL CALBAS
 421+ 4EFA D5           	PUSH DE
 422+ 4EFB              	; comma
 423+ 4EFB CD 66 52     	CALL CHKCHAR
 424+ 4EFE 2C           	DB ','
 425+ 4EFF              	; get count
 426+ 4EFF DD 21 1C 52  	LD IX, GETBYT
 427+ 4F03 CD 59 01     	CALL CALBAS
 428+ 4F06 F5           	PUSH AF
 429+ 4F07              	; ending )
 430+ 4F07 CD 66 52     	CALL CHKCHAR
 431+ 4F0A 29           	DB ')'
 432+ 4F0B
 433+ 4F0B E5           	PUSH HL
 434+ 4F0C DD E1        	POP IX
 435+ 4F0E
 436+ 4F0E C1           	POP BC ; count
 437+ 4F0F E1           	POP HL ; data pointer
 438+ 4F10 D9           	EXX
 439+ 4F11 C1           	POP BC ; y
 440+ 4F12 D1           	POP DE ; x
 441+ 4F13 D9           	EXX
 442+ 4F14
 443+ 4F14 DD E5        	PUSH IX ; save position in BASIC buffer
 444+ 4F16
 445+ 4F16 C5           	PUSH BC
 446+ 4F17 E5           	PUSH HL
 447+ 4F18 AF               XOR A
 448+ 4F19 CD 59 51         CALL GET_PAGE_INFO
 449+ 4F1C D9           	EXX
 450+ 4F1D E1           	POP HL
 451+ 4F1E F1           	POP AF
 452+ 4F1F D9           	EXX
 453+ 4F20 C5               PUSH BC
 454+ 4F21 D5               PUSH DE
 455+ 4F22 D9           	EXX
 456+ 4F23 F5           	PUSH AF
 457+ 4F24 E5           	PUSH HL
 458+ 4F25 D9           	EXX
 459+ 4F26 3A 41 F3         LD A, (RAMAD0)
 460+ 4F29 26 00            LD H, 0
 461+ 4F2B CD A0 51         CALL LOCAL_ENASLT
 462+ 4F2E FB           	EI
 463+ 4F2F E1           	POP HL
 464+ 4F30 C1           	POP BC
 465+ 4F31 CD 3B 4F     	CALL .UPDATE_LOC
 466+ 4F34 D1               POP DE
 467+ 4F35 C1               POP BC
 468+ 4F36 CD 90 51         CALL RESTORE_PAGE_INFO
 469+ 4F39 E1           	POP HL
 470+ 4F3A C9           	RET
 471+ 4F3B
 472+ 4F3B              .UPDATE_LOC:
 473+ 4F3B              .L4:
 474+ 4F3B 7E           	LD A, (HL)
 475+ 4F3C 23           	INC HL
 476+ 4F3D 23           	INC HL
 477+ 4F3E E5           	PUSH HL
 478+ 4F3F FD E1        	POP IY
 479+ 4F41 D9           	EXX
 480+ 4F42 CD A3 4E     	CALL SPRSET_DELTA_POS
 481+ 4F45 D9           	EXX
 482+ 4F46 23          > INC HL
 482+ 4F47 23          > INC HL
 482+ 4F48 23          > INC HL
 482+ 4F49 23          > INC HL
 483+ 4F4A 10 EF        	DJNZ .L4
 484+ 4F4C C9           	RET
 485+ 4F4D              ; *******************************************************************************************************
 486+ 4F4D
# file closed: asm\SPRITES.asm
 121  4F4D               ENDIF
 122  4F4D
 123  4F4D               IF (ANIM_CMDS == 1)
 124  4F4D               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F4D              ; sprite animation routines
   2+ 4F4D
   3+ 4F4D              ; number of animation items and pointer
   4+ 4F4D              ANIMITEMNUM:
   5+ 4F4D 00            DB 0
   6+ 4F4E              ANIMITEMPTR:
   7+ 4F4E 06 5B         DW EXT_END
   8+ 4F50              ; number of animation definitions and pointer
   9+ 4F50              ANIMDEFNUM:
  10+ 4F50 00            DB 0
  11+ 4F51              ANIMDEFPTR:
  12+ 4F51 06 5B         DW EXT_END
  13+ 4F53              ; number of links between sprite and animation definitions
  14+ 4F53              ANIMSPRNUM:
  15+ 4F53 00            DB 0
  16+ 4F54              ANIMSPRPTR:
  17+ 4F54 06 5B         DW EXT_END
  18+ 4F56
  19+ 4F56              ; *******************************************************************************************************
  20+ 4F56              ; function to handle CALL MAXANIMITEMS basic extension
  21+ 4F56              ; MAXANIMITEMS BYTE number
  22+ 4F56              ; sets new number and moves memory buffers as needed
  23+ 4F56              MAXANIMITEMS:
  24+ 4F56              	; opening (
  25+ 4F56 CD 66 52     	CALL CHKCHAR
  26+ 4F59 28           	DB '('
  27+ 4F5A              	; get value
  28+ 4F5A DD 21 1C 52  	LD IX, GETBYT
  29+ 4F5E CD 59 01     	CALL CALBAS
  30+ 4F61 F5               PUSH AF
  31+ 4F62              	; ending )
  32+ 4F62 CD 66 52     	CALL CHKCHAR
  33+ 4F65 29           	DB ')'
  34+ 4F66 F1               POP AF
  35+ 4F67
  36+ 4F67              	; save position
  37+ 4F67 E5           	PUSH HL
  38+ 4F68              MAXANIMITEMS.ENTRY:
  39+ 4F68 47               LD B,A
  40+ 4F69 3A 4D 4F         LD A,(ANIMITEMNUM)
  41+ 4F6C 90               SUB B
  42+ 4F6D 28 23            JR Z, .EXIT; same value as before
  43+ 4F6F DD 21 4E 4F      LD IX,ANIMITEMPTR
  44+ 4F73 FD 21 51 4F      LD IY,ANIMDEFPTR
  45+ 4F77 FA 95 4F         JP M, .INCREASE
  46+ 4F7A                  ; new value is lower than previous one
  47+ 4F7A CD AD 4F         CALL .SIZEDIFF
  48+ 4F7D CD CA 4F         CALL .DECREASE_COMMON
  49+ 4F80 2A 54 4F         LD HL,(ANIMSPRPTR)
  50+ 4F83 AF               XOR A
  51+ 4F84 ED 42            SBC HL,BC
  52+ 4F86 22 54 4F         LD (ANIMSPRPTR),HL
  53+ 4F89 2A 10 40         LD HL,(FREEMEMPTR)
  54+ 4F8C AF               XOR A
  55+ 4F8D ED 42            SBC HL,BC
  56+ 4F8F 22 10 40         LD (FREEMEMPTR),HL
  57+ 4F92              .EXIT:
  58+ 4F92 FB               EI
  59+ 4F93 E1           	POP HL
  60+ 4F94 C9           	RET
  61+ 4F95              .INCREASE:
  62+ 4F95 ED 44            NEG
  63+ 4F97 CD AD 4F         CALL .SIZEDIFF
  64+ 4F9A CD FC 4F         CALL .INCREASE_COMMON
  65+ 4F9D 2A 54 4F         LD HL,(ANIMSPRPTR)
  66+ 4FA0 09               ADD HL,BC
  67+ 4FA1 22 54 4F         LD (ANIMSPRPTR),HL
  68+ 4FA4 2A 10 40         LD HL,(FREEMEMPTR)
  69+ 4FA7 09               ADD HL,BC
  70+ 4FA8 22 10 40         LD (FREEMEMPTR),HL
  71+ 4FAB 18 E5            JR .EXIT
  72+ 4FAD              .SIZEDIFF:
  73+ 4FAD 26 00            LD H,0
  74+ 4FAF 6F               LD L,A
  75+ 4FB0 29               ADD HL,HL
  76+ 4FB1 29               ADD HL,HL
  77+ 4FB2 78               LD A,B
  78+ 4FB3 32 4D 4F         LD (ANIMITEMNUM),A
  79+ 4FB6 44               LD B,H
  80+ 4FB7 4D               LD C,L
  81+ 4FB8 C9               RET ; BC=size difference in bytes
  82+ 4FB9              .SIZETOMOVE:
  83+ 4FB9 D5               PUSH DE
  84+ 4FBA 2A 10 40         LD HL,(FREEMEMPTR)
  85+ 4FBD FD 5E 00         LD E,(IY)
  86+ 4FC0 FD 56 01         LD D,(IY+1)
  87+ 4FC3 AF               XOR A
  88+ 4FC4 ED 52            SBC HL,DE
  89+ 4FC6 44               LD B,H
  90+ 4FC7 4D               LD C,L
  91+ 4FC8 D1               POP DE
  92+ 4FC9 C9               RET
  93+ 4FCA              .DECREASE_COMMON:
  94+ 4FCA FD 6E 00         LD L,(IY)
  95+ 4FCD FD 66 01         LD H,(IY+1)
  96+ 4FD0 AF               XOR A
  97+ 4FD1 ED 42            SBC HL,BC
  98+ 4FD3 EB               EX DE,HL
  99+ 4FD4 C5               PUSH BC
 100+ 4FD5 CD B9 4F         CALL .SIZETOMOVE
 101+ 4FD8 F3               DI
 102+ 4FD9 78               LD A,B
 103+ 4FDA B1               OR C
 104+ 4FDB 28 0E            JR Z,.L1
 105+ 4FDD FD 6E 00         LD L,(IY)
 106+ 4FE0 FD 66 01         LD H,(IY+1)
 107+ 4FE3 DD 73 00         LD (IX),E
 108+ 4FE6 DD 72 01         LD (IX+1),D
 109+ 4FE9 ED B0            LDIR
 110+ 4FEB              .L1:
 111+ 4FEB C1               POP BC
 112+ 4FEC FD 6E 00         LD L,(IY)
 113+ 4FEF FD 66 01         LD H,(IY+1)
 114+ 4FF2 AF               XOR A
 115+ 4FF3 ED 42            SBC HL,BC
 116+ 4FF5 FD 75 00         LD (IY),L
 117+ 4FF8 FD 74 01         LD (IY+1),H
 118+ 4FFB C9               RET
 119+ 4FFC              .INCREASE_COMMON:
 120+ 4FFC 2A 10 40         LD HL,(FREEMEMPTR)
 121+ 4FFF 2B               DEC HL
 122+ 5000 AF               XOR A
 123+ 5001 ED 42            SBC HL,BC
 124+ 5003 EB               EX DE,HL
 125+ 5004 C5               PUSH BC
 126+ 5005 CD B9 4F         CALL .SIZETOMOVE
 127+ 5008 F3               DI
 128+ 5009 78               LD A,B
 129+ 500A B1               OR C
 130+ 500B 28 06            JR Z,.L2
 131+ 500D 2A 10 40         LD HL,(FREEMEMPTR)
 132+ 5010 2B               DEC HL
 133+ 5011 ED B8            LDDR
 134+ 5013              .L2:
 135+ 5013 C1               POP BC
 136+ 5014 FD 6E 00         LD L,(IY)
 137+ 5017 FD 66 01         LD H,(IY+1)
 138+ 501A 09               ADD HL,BC
 139+ 501B FD 75 00         LD (IY),L
 140+ 501E FD 74 01         LD (IY+1),H
 141+ 5021 C9               RET
 142+ 5022              ; *******************************************************************************************************
# file closed: asm\ANIMATION.asm
 125  5022               ENDIF
 126  5022
 127  5022              ; temp variables for BLIT, TILE functions
 128  5022               IF (BLIT_CMDS + TILE_CMDS > 0)
 129  5022              BLIT_TMP:
 130  5022              TILETMP1:
 131  5022              BLIT_TMP1:
 132  5022 00 00         DW 0
 133  5024              TILETMP2:
 134  5024              BLIT_TMP2:
 135  5024 00 00         DW 0
 136  5026                IFDEF CMDS_WITH_PARAMETERS
 137  5026              BLIT_STRUCT:
 138  5026 00 00 00...   DS 17
 139  502A                ENDIF
 140  502A               ENDIF
 141  5037
 142  5037              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 143  5037              ; per starting letter, if no commands with this letter, NULL value
 144  5037              CMDS:
 145  5037 00 00            DW 0 ; A
 146  5039               IF (BLIT_CMDS + BOX_CMDS > 0)
 147  5039 0F 51            DW CMDS_B ; B
 148  503B               ELSE
 149  503B ~            	DW 0
 150  503B               ENDIF
 151  503B 00 00            DW 0 ; C
 152  503D 00 00            DW 0 ; D
 153  503F 00 00            DW 0 ; E
 154  5041               IF (VRAM_CMDS + RAM_CMDS > 0)
 155  5041 8D 50            DW CMDS_F; F
 156  5043               ELSE
 157  5043 ~            	DW 0
 158  5043               ENDIF
 159  5043               IF (GENCAL_CMD > 0)
 160  5043 A0 50            DW CMDS_G; G
 161  5045               ELSE
 162  5045 ~            	DW 0
 163  5045               ENDIF
 164  5045 00 00            DW 0 ; H
 165  5047 00 00            DW 0 ; I
 166  5049 00 00            DW 0 ; J
 167  504B 00 00            DW 0 ; K
 168  504D 00 00            DW 0 ; L
 169  504F               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 170  504F 6B 50            DW CMDS_M ; M
 171  5051               ELSE
 172  5051 ~            	DW 0
 173  5051               ENDIF
 174  5051 00 00            DW 0 ; N
 175  5053 00 00            DW 0 ; O
 176  5055 00 00            DW 0 ; P
 177  5057 00 00            DW 0 ; Q
 178  5059 00 00            DW 0 ; R
 179  505B               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 180  505B B4 50            DW CMDS_S ; S
 181  505D               ELSE
 182  505D ~            	DW 0
 183  505D               ENDIF
 184  505D               IF (TILE_CMDS > 0)
 185  505D 2F 51            DW CMDS_T ; T
 186  505F               ELSE
 187  505F ~            	DW 0
 188  505F               ENDIF
 189  505F 00 00            DW 0 ; U
 190  5061               IF (VRAM_CMDS > 0)
 191  5061 AA 50            DW CMDS_V ; V
 192  5063               ELSE
 193  5063 ~            	DW 0
 194  5063               ENDIF
 195  5063 00 00            DW 0 ; W
 196  5065 00 00            DW 0 ; X
 197  5067 00 00            DW 0 ; Y
 198  5069 00 00            DW 0 ; Z
 199  506B
 200  506B              CMDS_M:
 201  506B               IF (VRAM_CMDS == 1)
 202  506B 4D 45 4D 56      DB "MEMVRM", 0
 202  506F 52 4D 00
 203  5072 C6 53            DW MEMVRM
 204  5074               ENDIF
 205  5074               IF (RAM_CMDS == 1)
 206  5074 4D 45 4D 43  	DB "MEMCPY", 0
 206  5078 50 59 00
 207  507B 85 52        	DW MEMCPY
 208  507D               ENDIF
 209  507D               IF (ANIM_CMDS == 1)
 210  507D 4D 41 58 41  	DB "MAXANIMITEMS",0
 210  5081 4E 49 4D 49
 210  5085 54 45 4D 53
 210  5089 00
 211  508A 56 4F        	DW MAXANIMITEMS
 212  508C               ENDIF
 213  508C               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 214  508C 00           	DB 0
 215  508D               ENDIF
 216  508D              CMDS_F:
 217  508D               IF (VRAM_CMDS == 1)
 218  508D 46 49 4C 56      DB "FILVRM", 0
 218  5091 52 4D 00
 219  5094 C8 52            DW FILVRM
 220  5096               ENDIF
 221  5096               IF (RAM_CMDS == 1)
 222  5096 46 49 4C 52      DB "FILRAM", 0
 222  509A 41 4D 00
 223  509D 0F 53            DW FILRAM
 224  509F               ENDIF
 225  509F               IF (VRAM_CMDS + RAM_CMDS > 0)
 226  509F 00               DB 0
 227  50A0               ENDIF
 228  50A0              CMDS_G:
 229  50A0               IF (GENCAL_CMD == 1)
 230  50A0 47 45 4E 43      DB "GENCAL", 0
 230  50A4 41 4C 00
 231  50A7 6D 53            DW GENCAL
 232  50A9               ENDIF
 233  50A9               IF (GENCAL_CMD > 0)
 234  50A9 00           	DB	0
 235  50AA               ENDIF
 236  50AA              CMDS_V:
 237  50AA               IF (VRAM_CMDS == 1)
 238  50AA 56 52 4D 4D  	DB "VRMMEM", 0
 238  50AE 45 4D 00
 239  50B1 3E 54        	DW VRMMEM
 240  50B3               ENDIF
 241  50B3               IF (VRAM_CMDS > 0)
 242  50B3 00           	DB 0
 243  50B4               ENDIF
 244  50B4              CMDS_S:
 245  50B4               IF (SPRITE_CMDS == 1)
 246  50B4 53 50 52 53  	DB "SPRSET", 0
 246  50B8 45 54 00
 247  50BB 0E 4E        	DW SPRSET
 248  50BD 53 50 52 47  	DB "SPRGRPMOV", 0
 248  50C1 52 50 4D 4F
 248  50C5 56 00
 249  50C7 CC 4E        	DW SPRGRPMOV
 250  50C9               ENDIF
 251  50C9               IF (SOUND_CMDS == 1)
 252  50C9 53 4E 44 53  	DB "SNDSFX", 0
 252  50CD 46 58 00
 253  50D0 7C 55        	DW SNDSFX
 254  50D2 53 4E 44 50  	DB "SNDPLYON", 0
 254  50D6 4C 59 4F 4E
 254  50DA 00
 255  50DB 46 55        	DW SNDPLYON
 256  50DD 53 4E 44 50  	DB "SNDPLYOFF", 0
 256  50E1 4C 59 4F 46
 256  50E5 46 00
 257  50E7 59 55        	DW SNDPLYOFF
 258  50E9 53 4E 44 50  	DB "SNDPLYINI", 0
 258  50ED 4C 59 49 4E
 258  50F1 49 00
 259  50F3 FC 54        	DW SNDPLYINIT
 260  50F5               ENDIF
 261  50F5               IF (SPRITE_CMDS == 1)
 262  50F5 53 50 52 45  	DB "SPRENABLE", 0
 262  50F9 4E 41 42 4C
 262  50FD 45 00
 263  50FF B9 4D        	DW SPRENABLE
 264  5101 53 50 52 44  	DB "SPRDISABLE", 0
 264  5105 49 53 41 42
 264  5109 4C 45 00
 265  510C 09 4E        	DW SPRDISABLE
 266  510E               ENDIF
 267  510E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 268  510E 00           	DB 0
 269  510F               ENDIF
 270  510F              CMDS_B:
 271  510F               IF (BLIT_CMDS == 1)
 272  510F 42 4C 49 54  	DB "BLIT", 0
 272  5113 00
 273  5114 53 57        	DW BLIT
 274  5116               ENDIF
 275  5116               IF (BOX_CMDS == 1)
 276  5116 42 4F 58 4D  	DB "BOXMEMCPY", 0
 276  511A 45 4D 43 50
 276  511E 59 00
 277  5120 8B 5A        	DW BOXMEMCPY
 278  5122 42 4F 58 4D  	DB "BOXMEMVRM", 0
 278  5126 45 4D 56 52
 278  512A 4D 00
 279  512C BF 5A        	DW BOXMEMVRM
 280  512E               ENDIF
 281  512E               IF (BLIT_CMDS + BOX_CMDS > 0)
 282  512E 00           	DB 0
 283  512F               ENDIF
 284  512F              CMDS_T:
 285  512F               IF (TILE_CMDS == 1)
 286  512F 54 49 4C 45  	DB "TILERAM", 0
 286  5133 52 41 4D 00
 287  5137 97 58        	DW TILERAM
 288  5139 54 49 4C 45  	DB "TILEVRM", 0
 288  513D 56 52 4D 00
 289  5141 9A 59        	DW TILEVRM
 290  5143               ENDIF
 291  5143               IF (TILE_CMDS > 0)
 292  5143 00           	DB 0
 293  5144               ENDIF
 294  5144
 295  5144               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 296  5144              ; ****************************************************************************************************
 297  5144              ; function sets VRAM address
 298  5144              ; input HL=address
 299  5144              ; modifies AF
 300  5144              SETWRT_LOCAL:
 301  5144 7D           	LD	A, L
 302  5145 D3 99        	OUT	(099H), A
 303  5147 7C           	LD	A, H
 304  5148 E6 3F        	AND	03FH
 305  514A F6 40        	OR	040H
 306  514C D3 99        	OUT	(099H), A
 307  514E C9           	RET
 308  514F              ; ****************************************************************************************************
 309  514F               ENDIF
 310  514F
 311  514F               IF (VRAM_CMDS + TILE_CMDS > 0)
 312  514F              ; ****************************************************************************************************
 313  514F              ; function copies data from RAM to VRAM
 314  514F              ; input HL=address in RAM
 315  514F              ; input B=count
 316  514F              ; modifies AF
 317  514F              BBYTECOPY:
 318  514F ED A3        	OUTI
 319  5151 C2 4F 51     	JP	NZ, BBYTECOPY
 320  5154 C9           	RET
 321  5155              ; ****************************************************************************************************
 322  5155               ENDIF
 323  5155
 324  5155              ; ****************************************************************************************************
 325  5155              ; function multiplies HL by 8
 326  5155              HLx8:
 327  5155 29          > ADD HL, HL
 327  5156 29          > ADD HL, HL
 327  5157 29          > ADD HL, HL
 328  5158 C9           	RET
 329  5159              ; ****************************************************************************************************
 330  5159
 331  5159              ; ****************************************************************************************************
 332  5159              ; function gets slot and subslot data for specific page
 333  5159              ; input A=page (0, 1 or 2)
 334  5159              ; output B = 0A8H register value
 335  5159              ; output D = 0 is no subslots, 1 if yes
 336  5159              ; output C = 0A8H value when page 3 slot equals to requested page slot
 337  5159              ; output E = subslot value if present
 338  5159              ; modifies AF, BC, DE, HL
 339  5159              GET_PAGE_INFO:
 340  5159 6F               LD L, A
 341  515A C6 C1            ADD A, low (EXPTBL)
 342  515C 32 66 51         LD (GET_PAGE_INFO_L1+1), A
 343  515F DB A8            IN A, (0A8H)
 344  5161 47               LD B, A
 345  5162 E6 3F            AND 03FH
 346  5164 4F               LD C, A
 347  5165              GET_PAGE_INFO_L1:
 348  5165 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 349  5168 E6 80            AND 080H
 350  516A 28 1B            JR Z, GET_PAGE_INFO_L2
 351  516C                  ; expanded
 352  516C 2D               DEC L
 353  516D FA 8C 51         JP M, GET_PAGE_INFO_L3
 354  5170 2D               DEC L
 355  5171 FA 8A 51         JP M, GET_PAGE_INFO_L4
 356  5174                  ; page 2
 357  5174 07               RLCA
 358  5175 07               RLCA
 359  5176              GET_PAGE_INFO_L5:
 360  5176 E6 C0            AND 0C0H
 361  5178 B1               OR C
 362  5179 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 363  517B 4F               LD C, A
 364  517C 3A FF FF         LD A, (0FFFFH)
 365  517F 2F               CPL
 366  5180 5F               LD E, A
 367  5181 16 01            LD D, 1
 368  5183 78               LD A, B ; return stack
 369  5184 D3 A8            OUT (0A8H), A
 370  5186 C9               RET
 371  5187              GET_PAGE_INFO_L2:
 372  5187                  ; not expanded
 373  5187 16 00            LD D, 0
 374  5189 C9               RET
 375  518A              GET_PAGE_INFO_L4:
 376  518A                  ; page 1
 377  518A 0F               RRCA
 378  518B 0F               RRCA
 379  518C              GET_PAGE_INFO_L3:
 380  518C                  ; page 0
 381  518C 0F               RRCA
 382  518D 0F               RRCA
 383  518E 18 E6            JR GET_PAGE_INFO_L5
 384  5190              ; ****************************************************************************************************
 385  5190
 386  5190              ; ****************************************************************************************************
 387  5190              ; function returns original slot and subslot info
 388  5190              ; input B = 0A8H register value
 389  5190              ; input D = 0 is no subslots, 1 if yes
 390  5190              ; input C = 0A8H value when page 3 slot equals to requested page slot
 391  5190              ; input E = subslot value if present
 392  5190              ; modifies AF, disables interrupts
 393  5190              RESTORE_PAGE_INFO:
 394  5190 7A               LD A, D
 395  5191 B7               OR A
 396  5192 28 08            JR Z, RESTORE_PAGE_INFO_L1
 397  5194 79               LD A, C
 398  5195 F3           	DI
 399  5196 D3 A8            OUT (0A8H), A
 400  5198 7B               LD A, E
 401  5199 32 FF FF         LD (0FFFFH), A
 402  519C              RESTORE_PAGE_INFO_L1:
 403  519C 78               LD A, B
 404  519D D3 A8            OUT (0A8H), A
 405  519F C9               RET
 406  51A0              ; ****************************************************************************************************
 407  51A0
 408  51A0              ; *******************************************************************************************************
 409  51A0              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 410  51A0              ; INPUT:  A = SLOT ID: EXXXSSPP
 411  51A0              ; E = EXPANDED FLAG
 412  51A0              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 413  51A0              ; PP = PRIMARY SLOT NUMBER
 414  51A0              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 415  51A0              ; CHANGES: AF, BC, DE
 416  51A0
 417  51A0              LOCAL_ENASLT:
 418  51A0 CD C0 51         CALL L0353
 419  51A3 FA AD 51         JP M, L0340
 420  51A6 DB A8            IN A, (0A8H)
 421  51A8 A1               AND C
 422  51A9 B0               OR B
 423  51AA D3 A8            OUT (0A8H), A
 424  51AC C9               RET
 425  51AD              L0340:
 426  51AD E5               PUSH HL
 427  51AE CD E5 51         CALL L0378
 428  51B1 4F               LD C, A
 429  51B2 06 00            LD B, 0
 430  51B4 7D               LD A, L
 431  51B5 A4               AND H
 432  51B6 B2               OR D
 433  51B7 21 C5 FC         LD HL, 0FCC5H
 434  51BA 09               ADD HL, BC
 435  51BB 77               LD (HL), A
 436  51BC E1               POP HL
 437  51BD 79               LD A, C
 438  51BE 18 E0            JR LOCAL_ENASLT
 439  51C0              L0353:
 440  51C0 F3               DI
 441  51C1 F5               PUSH AF
 442  51C2 7C               LD A, H
 443  51C3 07               RLCA
 444  51C4 07               RLCA
 445  51C5 E6 03            AND 3
 446  51C7 5F               LD E, A
 447  51C8 3E C0            LD A, 0C0H
 448  51CA              L035D:
 449  51CA 07               RLCA
 450  51CB 07               RLCA
 451  51CC 1D               DEC E
 452  51CD F2 CA 51         JP P, L035D
 453  51D0 5F               LD E, A
 454  51D1 2F               CPL
 455  51D2 4F               LD C, A
 456  51D3 F1               POP AF
 457  51D4 F5               PUSH AF
 458  51D5 E6 03            AND 3
 459  51D7 3C               INC A
 460  51D8 47               LD B, A
 461  51D9 3E AB            LD A, 0ABH
 462  51DB              L036E:
 463  51DB C6 55            ADD A, 055H
 464  51DD 10 FC            DJNZ L036E
 465  51DF 57               LD D, A
 466  51E0 A3               AND E
 467  51E1 47               LD B, A
 468  51E2 F1               POP AF
 469  51E3 A7               AND A
 470  51E4 C9               RET
 471  51E5              L0378:
 472  51E5 F5               PUSH AF
 473  51E6 7A               LD A, D
 474  51E7 E6 C0            AND 0C0H
 475  51E9 4F               LD C, A
 476  51EA F1               POP AF
 477  51EB F5               PUSH AF
 478  51EC 57               LD D, A
 479  51ED DB A8            IN A, (0A8H)
 480  51EF 47               LD B, A
 481  51F0 E6 3F            AND 03FH
 482  51F2 B1               OR C
 483  51F3 D3 A8            OUT (0A8H), A
 484  51F5 7A               LD A, D
 485  51F6 0F               RRCA
 486  51F7 0F               RRCA
 487  51F8 E6 03            AND 3
 488  51FA 57               LD D, A
 489  51FB 3E AB            LD A, 0ABH
 490  51FD              L0390:
 491  51FD C6 55            ADD A, 055H
 492  51FF 15               DEC D
 493  5200 F2 FD 51         JP P, L0390
 494  5203 A3               AND E
 495  5204 57               LD D, A
 496  5205 7B               LD A, E
 497  5206 2F               CPL
 498  5207 67               LD H, A
 499  5208 3A FF FF         LD A, (0FFFFH)
 500  520B 2F               CPL
 501  520C 6F               LD L, A
 502  520D A4               AND H
 503  520E B2               OR D
 504  520F 32 FF FF         LD (0FFFFH), A
 505  5212 78               LD A, B
 506  5213 D3 A8            OUT (0A8H), A
 507  5215 F1               POP AF
 508  5216 E6 03            AND 3
 509  5218 C9               RET
 510  5219              ; *******************************************************************************************************
 511  5219
 512  5219              ; *******************************************************************************************************
 513  5219              ; some common code to activate page 0 and place values needed to restore original page on stack
 514  5219              ; input IY=return address
 515  5219              ENABLE_PAGE0:
 516  5219 AF               XOR A
 517  521A CD 59 51         CALL GET_PAGE_INFO
 518  521D C5               PUSH BC
 519  521E D5               PUSH DE
 520  521F 3A 41 F3         LD A, (RAMAD0)
 521  5222 26 00            LD H, 0
 522  5224 CD A0 51         CALL LOCAL_ENASLT
 523  5227 FD E9        	JP (IY)
 524  5229              ; *******************************************************************************************************
 525  5229
 526  5229              ; General BASIC CALL-instruction handler
 527  5229              CALLHAND:
 528  5229 E5           	PUSH HL
 529  522A 21 37 50     	LD	HL, CMDS ; pointer table based on starting letter
 530  522D 3A 89 FD         LD A, (PROCNM)
 531  5230 D6 41            SUB 'A'
 532  5232 87               ADD A, A
 533  5233 16 00            LD D, 0
 534  5235 5F               LD E, A
 535  5236 19               ADD HL, DE
 536  5237 5E               LD E, (HL)
 537  5238 23               INC HL
 538  5239 56               LD D, (HL)
 539  523A 7A               LD A, D
 540  523B B3               OR E
 541  523C 28 23            JR Z, .CMDNOTRECOGNIZED
 542  523E EB               EX DE, HL
 543  523F              .CHKCMD:
 544  523F 11 89 FD     	LD	DE, PROCNM
 545  5242 1A           .LOOP:	LD	A,(DE)
 546  5243 BE           	CP	(HL)
 547  5244 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 548  5246 13           	INC	DE
 549  5247 23           	INC	HL
 550  5248 A7           	AND	A
 551  5249 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 552  524B 5E           	LD	E,(HL)
 553  524C 23           	INC	HL
 554  524D 56           	LD	D,(HL)
 555  524E E1           	POP	HL		; routine address
 556  524F CD 70 52     	CALL	GETPREVCHAR
 557  5252 CD 64 52     	CALL	.CALLDE		; Call routine
 558  5255 A7           	AND	A
 559  5256 C9           	RET
 560  5257
 561  5257              .TONEXTCMD:
 562  5257 0E FF        	LD	C,0FFH
 563  5259 AF           	XOR	A
 564  525A ED B1        	CPIR			; Skip to end of instruction name
 565  525C 23           	INC	HL
 566  525D 23           	INC	HL		; Skip address
 567  525E BE           	CP	(HL)
 568  525F 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 569  5261              .CMDNOTRECOGNIZED:
 570  5261 E1           	POP	HL
 571  5262 37               SCF
 572  5263 C9           	RET
 573  5264
 574  5264              .CALLDE:
 575  5264 D5           	PUSH	DE
 576  5265 C9           	RET
 577  5266
 578  5266              ;---------------------------
 579  5266
 580  5266              ;GETSTRPNT:
 581  5266              ; OUT:
 582  5266              ; HL = String Address
 583  5266              ; B  = Lenght
 584  5266              ;        LD      HL,(USR)
 585  5266              ;        LD      B,(HL)
 586  5266              ;        INC     HL
 587  5266              ;        LD      E,(HL)
 588  5266              ;        INC     HL
 589  5266              ;        LD      D,(HL)
 590  5266              ;        EX      DE,HL
 591  5266              ;        RET
 592  5266
 593  5266              ;EVALTXTPARAM:
 594  5266              ;	CALL	CHKCHAR
 595  5266              ;	DEFB	"("             ; Check for (
 596  5266              ;	LD	IX,FRMEVL
 597  5266              ;	CALL	CALBAS		; Evaluate expression
 598  5266              ;       LD      A,(VALTYP)
 599  5266              ;        CP      3               ; Text type?
 600  5266              ;        JP      NZ,TYPE_MISMATCH
 601  5266              ;        PUSH	HL
 602  5266              ;        LD	IX,FRESTR         ; Free the temporary string
 603  5266              ;        CALL	CALBAS
 604  5266              ;        POP	HL
 605  5266              ;	CALL	CHKCHAR
 606  5266              ;	DEFB	")"             ; Check for )
 607  5266              ;        RET
 608  5266
 609  5266
 610  5266              CHKCHAR:
 611  5266 CD 70 52     	CALL	GETPREVCHAR	; Get previous basic char
 612  5269 E3           	EX	(SP),HL
 613  526A BE           	CP	(HL) 	        ; Check if good char
 614  526B 20 0F        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 615  526D 23           	INC	HL
 616  526E E3           	EX	(SP),HL
 617  526F 23           	INC	HL		; Get next basic char
 618  5270
 619  5270              GETPREVCHAR:
 620  5270 2B           	DEC	HL
 621  5271 DD 21 66 46  	LD	IX,CHRGTR
 622  5275 C3 59 01     	JP      CALBAS
 623  5278
 624  5278
 625  5278              TYPE_MISMATCH:
 626  5278 1E 0D            LD E, 13 ; Type mismatch
 627  527A 18 02            JR THROW_ERROR
 628  527C
 629  527C              SYNTAX_ERROR:
 630  527C 1E 02            LD E, 2 ; Syntax error
 631  527E              THROW_ERROR:
 632  527E DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 633  5282 C3 59 01     	JP	CALBAS
 634  5285
 635  5285              ;---------------------------
 636  5285
 637  5285               IF (RAM_CMDS == 1)
 638  5285              ; *******************************************************************************************************
 639  5285              ; function to handle CALL MEMCPY basic extension
 640  5285              ; _MEMCPY ( INT source,
 641  5285              ;			INT destination,
 642  5285              ;			INT count,
 643  5285              ; will put ram in page 0 also, page 1 is already there
 644  5285              MEMCPY:
 645  5285              	; opening (
 646  5285 CD 66 52     	CALL CHKCHAR
 647  5288 28           	DB '('
 648  5289              	; get source address
 649  5289 DD 21 2F 54  	LD IX, FRMQNT
 650  528D CD 59 01     	CALL CALBAS
 651  5290 D5           	PUSH DE
 652  5291              	; comma
 653  5291 CD 66 52     	CALL CHKCHAR
 654  5294 2C           	DB ','
 655  5295              	; get destination address
 656  5295 DD 21 2F 54  	LD IX, FRMQNT
 657  5299 CD 59 01     	CALL CALBAS
 658  529C D5           	PUSH DE
 659  529D              	; comma
 660  529D CD 66 52     	CALL CHKCHAR
 661  52A0 2C           	DB ','
 662  52A1              	; get length
 663  52A1 DD 21 2F 54  	LD IX, FRMQNT
 664  52A5 CD 59 01     	CALL CALBAS
 665  52A8 D5           	PUSH DE
 666  52A9              	; ending )
 667  52A9 CD 66 52     	CALL CHKCHAR
 668  52AC 29           	DB ')'
 669  52AD
 670  52AD              	; save position
 671  52AD E5           	PUSH HL
 672  52AE DD E1        	POP IX
 673  52B0
 674  52B0 C1           	POP BC ; count
 675  52B1 D1           	POP DE ; destination
 676  52B2 E1           	POP HL ; source
 677  52B3 D9           	EXX
 678  52B4              	; enable page 0
 679  52B4 FD 21 BB 52  	LD IY, .RET
 680  52B8 C3 19 52     	JP ENABLE_PAGE0
 681  52BB              .RET:
 682  52BB FB           	EI
 683  52BC D9           	EXX
 684  52BD ED B0        	LDIR
 685  52BF D1               POP DE
 686  52C0 C1               POP BC
 687  52C1 CD 90 51         CALL RESTORE_PAGE_INFO
 688  52C4 DD E5        	PUSH IX
 689  52C6 E1           	POP HL
 690  52C7 C9           	RET
 691  52C8              ; *******************************************************************************************************
 692  52C8               ENDIF
 693  52C8
 694  52C8               IF (VRAM_CMDS == 1)
 695  52C8              ; *******************************************************************************************************
 696  52C8              ; function to handle CALL FILVRM basic extension
 697  52C8              ; FILVRM ( INT offset,
 698  52C8              ;		   INT count,
 699  52C8              ;		   BYTE value,
 700  52C8              ;		   BYTE wait_vsync) >0 = true
 701  52C8              ; wait_vsync will issue HALT before copying
 702  52C8              FILVRM:
 703  52C8              	; opening (
 704  52C8 CD 66 52     	CALL CHKCHAR
 705  52CB 28           	DB '('
 706  52CC              	; get offset address
 707  52CC DD 21 2F 54  	LD IX, FRMQNT
 708  52D0 CD 59 01     	CALL CALBAS
 709  52D3 D5           	PUSH DE
 710  52D4              	; comma
 711  52D4 CD 66 52     	CALL CHKCHAR
 712  52D7 2C           	DB ','
 713  52D8              	; get count
 714  52D8 DD 21 2F 54  	LD IX, FRMQNT
 715  52DC CD 59 01     	CALL CALBAS
 716  52DF D5           	PUSH DE
 717  52E0              	; comma
 718  52E0 CD 66 52     	CALL CHKCHAR
 719  52E3 2C           	DB ','
 720  52E4              	; get value
 721  52E4 DD 21 1C 52  	LD IX, GETBYT
 722  52E8 CD 59 01     	CALL CALBAS
 723  52EB F5           	PUSH AF
 724  52EC              	; comma
 725  52EC CD 66 52     	CALL CHKCHAR
 726  52EF 2C           	DB ','
 727  52F0              	; get vsync wait
 728  52F0 DD 21 1C 52  	LD IX, GETBYT
 729  52F4 CD 59 01     	CALL CALBAS
 730  52F7 F5           	PUSH AF
 731  52F8              	; ending )
 732  52F8 CD 66 52     	CALL CHKCHAR
 733  52FB 29           	DB ')'
 734  52FC
 735  52FC FB               EI
 736  52FD              	; save position
 737  52FD E5           	PUSH HL
 738  52FE DD E1        	POP IX
 739  5300
 740  5300              	; syntax ok
 741  5300              	; wait for vsync if needed
 742  5300 F1           	POP AF
 743  5301 B7           	OR A
 744  5302 28 01        	JR Z, .L1
 745  5304 76           	HALT
 746  5305
 747  5305              .L1:
 748  5305 F1               POP AF ; value
 749  5306 C1               POP BC ; count
 750  5307 E1               POP HL ; offset
 751  5308 CD 56 00         CALL BIOS_FILVRM
 752  530B
 753  530B              .L3:
 754  530B DD E5        	PUSH IX
 755  530D E1           	POP HL
 756  530E C9           	RET
 757  530F              ; *******************************************************************************************************
 758  530F               ENDIF
 759  530F
 760  530F               IF (RAM_CMDS == 1)
 761  530F              ; *******************************************************************************************************
 762  530F              ; function to handle CALL FILRAM basic extension
 763  530F              ; FILRAM ( INT start address,
 764  530F              ;		   INT count,
 765  530F              ;		   BYTE value,
 766  530F              ; will put ram in page 0 also, page 1 is already there
 767  530F              FILRAM:
 768  530F              	; opening (
 769  530F CD 66 52     	CALL CHKCHAR
 770  5312 28           	DB '('
 771  5313              	; get start address
 772  5313 DD 21 2F 54  	LD IX, FRMQNT
 773  5317 CD 59 01     	CALL CALBAS
 774  531A D5           	PUSH DE
 775  531B              	; comma
 776  531B CD 66 52     	CALL CHKCHAR
 777  531E 2C           	DB ','
 778  531F              	; get count
 779  531F DD 21 2F 54  	LD IX, FRMQNT
 780  5323 CD 59 01     	CALL CALBAS
 781  5326 D5           	PUSH DE
 782  5327              	; comma
 783  5327 CD 66 52     	CALL CHKCHAR
 784  532A 2C           	DB ','
 785  532B              	; get value
 786  532B DD 21 1C 52  	LD IX, GETBYT
 787  532F CD 59 01     	CALL CALBAS
 788  5332 F5           	PUSH AF
 789  5333              	; ending )
 790  5333 CD 66 52     	CALL CHKCHAR
 791  5336 29           	DB ')'
 792  5337
 793  5337              	; save position
 794  5337 E5           	PUSH HL
 795  5338 DD E1        	POP IX
 796  533A
 797  533A D1           	POP DE ; actually AF
 798  533B C1           	POP BC ; count
 799  533C E1           	POP HL ; start address
 800  533D 78           	LD A, B
 801  533E B7           	OR A
 802  533F 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 803  5341 B1           	OR C
 804  5342 28 19        	JR Z, .EXIT ; 0 bytes to fill, skip
 805  5344 79           	LD A, C
 806  5345 3D           	DEC A
 807  5346 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 808  5348              	; one byte to fill
 809  5348 72           	LD (HL), D
 810  5349 18 12        	JR .EXIT
 811  534B              .L1:
 812  534B D9           	EXX
 813  534C              	; enable page 0
 814  534C FD 21 53 53  	LD IY, .RET
 815  5350 C3 19 52     	JP ENABLE_PAGE0
 816  5353              .RET:
 817  5353 FB           	EI
 818  5354 D9           	EXX
 819  5355 CD 61 53     	CALL .FILLVALUE
 820  5358 D1               POP DE
 821  5359 C1               POP BC
 822  535A CD 90 51         CALL RESTORE_PAGE_INFO
 823  535D              .EXIT:
 824  535D DD E5        	PUSH IX
 825  535F E1           	POP HL
 826  5360 C9           	RET
 827  5361
 828  5361              .FILLVALUE:
 829  5361 72               LD (HL), D
 830  5362 54               LD D, H
 831  5363 5D               LD E, L
 832  5364 13               INC DE
 833  5365 0B               DEC BC
 834  5366 ED B0            LDIR
 835  5368 C9               RET
 836  5369              ; *******************************************************************************************************
 837  5369               ENDIF
 838  5369
 839  5369               IF (GENCAL_CMD == 1)
 840  5369              ; *******************************************************************************************************
 841  5369              ; function to handle CALL GENCAL basic extension
 842  5369              ; GENCAL ( INT fn_addr, = address of the function to call
 843  5369              ;		   INT reg_list_ptr, = pointer to array holding register values (AF,BC,DE,HL,IX,IY)
 844  5369              ; output values of reristers will also be stored at reg_list_ptr
 845  5369              GENCAL_VAR_SP:
 846  5369 00 00            DW 0
 847  536B              GENCAL_VAR_SP2:
 848  536B 00 00            DW 0
 849  536D              GENCAL:
 850  536D              	; opening (
 851  536D CD 66 52     	CALL CHKCHAR
 852  5370 28           	DB '('
 853  5371              	; get function address
 854  5371 DD 21 2F 54  	LD IX, FRMQNT
 855  5375 CD 59 01     	CALL CALBAS
 856  5378 D5           	PUSH DE
 857  5379              	; comma
 858  5379 CD 66 52     	CALL CHKCHAR
 859  537C 2C           	DB ','
 860  537D              	; get pointer to register list
 861  537D DD 21 2F 54  	LD IX, FRMQNT
 862  5381 CD 59 01     	CALL CALBAS
 863  5384 D5           	PUSH DE
 864  5385              	; ending )
 865  5385 CD 66 52     	CALL CHKCHAR
 866  5388 29           	DB ')'
 867  5389
 868  5389              	; save BASIC token position
 869  5389 E5           	PUSH HL
 870  538A D9               EXX
 871  538B E1           	POP HL ; HL'=next basic token
 872  538C D9               EXX
 873  538D
 874  538D E1               POP HL ; get pointer to register values
 875  538E F3           	DI
 876  538F ED 73 69 53      LD (GENCAL_VAR_SP), SP
 877  5393 F9               LD SP, HL
 878  5394 F1               POP AF
 879  5395 C1               POP BC
 880  5396 D1               POP DE
 881  5397 E1               POP HL
 882  5398 DD E1            POP IX
 883  539A FD E1            POP IY
 884  539C D9               EXX
 885  539D ED 73 6B 53      LD (GENCAL_VAR_SP2), SP
 886  53A1 ED 7B 69 53      LD SP, (GENCAL_VAR_SP)
 887  53A5 FB               EI
 888  53A6 D1               POP DE ; get function to call
 889  53A7 E5               PUSH HL
 890  53A8 CD C3 53         CALL .EXXDECALL
 891  53AB F3               DI
 892  53AC ED 73 69 53      LD (GENCAL_VAR_SP), SP
 893  53B0 ED 7B 6B 53      LD SP, (GENCAL_VAR_SP2)
 894  53B4 FD E5            PUSH IY
 895  53B6 DD E5            PUSH IX
 896  53B8 E5               PUSH HL
 897  53B9 D5               PUSH DE
 898  53BA C5               PUSH BC
 899  53BB F5               PUSH AF
 900  53BC ED 7B 69 53      LD SP, (GENCAL_VAR_SP)
 901  53C0 FB               EI
 902  53C1 E1               POP HL
 903  53C2 C9           	RET
 904  53C3
 905  53C3              .EXXDECALL:
 906  53C3 D5               PUSH DE
 907  53C4 D9               EXX
 908  53C5 C9               RET
 909  53C6              ; *******************************************************************************************************
 910  53C6               ENDIF
 911  53C6
 912  53C6               IF (VRAM_CMDS == 1)
 913  53C6              ; *******************************************************************************************************
 914  53C6              ; function to handle CALL MEMVRM basic extension
 915  53C6              ; copies from RAM to VRAM
 916  53C6              ; _MEMVRM ( INT source,
 917  53C6              ;			INT destination,
 918  53C6              ;			INT count,
 919  53C6              ;			BYTE wait_vsync) >0 = true
 920  53C6              ; will put ram in page 0 also, page 1 is already there
 921  53C6              ; wait_vsync will issue HALT before copying
 922  53C6              MEMVRM:
 923  53C6              	; opening (
 924  53C6 CD 66 52     	CALL CHKCHAR
 925  53C9 28           	DB '('
 926  53CA              	; get source address
 927  53CA DD 21 2F 54  	LD IX, FRMQNT
 928  53CE CD 59 01     	CALL CALBAS
 929  53D1 D5           	PUSH DE
 930  53D2              	; comma
 931  53D2 CD 66 52     	CALL CHKCHAR
 932  53D5 2C           	DB ','
 933  53D6              	; get destination address
 934  53D6 DD 21 2F 54  	LD IX, FRMQNT
 935  53DA CD 59 01     	CALL CALBAS
 936  53DD D5           	PUSH DE
 937  53DE              	; comma
 938  53DE CD 66 52     	CALL CHKCHAR
 939  53E1 2C           	DB ','
 940  53E2              	; get length
 941  53E2 DD 21 2F 54  	LD IX, FRMQNT
 942  53E6 CD 59 01     	CALL CALBAS
 943  53E9 D5           	PUSH DE
 944  53EA              	; comma
 945  53EA CD 66 52     	CALL CHKCHAR
 946  53ED 2C           	DB ','
 947  53EE              	; get vsync wait
 948  53EE DD 21 1C 52  	LD IX, GETBYT
 949  53F2 CD 59 01     	CALL CALBAS
 950  53F5 F5           	PUSH AF
 951  53F6              	; ending )
 952  53F6 CD 66 52     	CALL CHKCHAR
 953  53F9 29           	DB ')'
 954  53FA
 955  53FA                  ; save position in BASIC text
 956  53FA E5           	PUSH HL
 957  53FB DD E1        	POP IX
 958  53FD
 959  53FD F1           	POP AF ; wait vsync
 960  53FE B7           	OR A
 961  53FF 28 03        	JR Z, .L1
 962  5401 FB               EI
 963  5402 76           	HALT
 964  5403 F3           	DI
 965  5404              .L1:
 966  5404              	; pop LDIR parameters and store away for later
 967  5404 C1           	POP BC ; count
 968  5405 D1           	POP DE ; vram destination
 969  5406 E1           	POP HL ; ram source
 970  5407 D9           	EXX
 971  5408 FD 21 0F 54   	LD IY, .RET
 972  540C C3 19 52     	JP ENABLE_PAGE0
 973  540F              .RET:
 974  540F FB           	EI
 975  5410 D9           	EXX
 976  5411 CD 1D 54     	CALL .LDIRVM
 977  5414 D1               POP DE
 978  5415 C1               POP BC
 979  5416 CD 90 51         CALL RESTORE_PAGE_INFO
 980  5419 DD E5        	PUSH IX
 981  541B E1           	POP HL
 982  541C C9           	RET
 983  541D
 984  541D              .LDIRVM:
 985  541D EB           	EX DE, HL
 986  541E F3           	DI
 987  541F CD 44 51     	CALL SETWRT_LOCAL
 988  5422 FB           	EI
 989  5423 EB           	EX DE, HL
 990  5424 78           	LD A, B
 991  5425 B7           	OR A
 992  5426 28 0D        	JR Z, .L3
 993  5428 C5           	PUSH BC
 994  5429 0E 98        	LD C, #98
 995  542B              .L2:
 996  542B 50           	LD D, B
 997  542C 06 00        	LD B, 0
 998  542E CD 4F 51     	CALL BBYTECOPY
 999  5431 42           	LD B, D
1000  5432 10 F7        	DJNZ .L2
1001  5434 C1           	POP BC
1002  5435              .L3:
1003  5435 79           	LD A, C
1004  5436 B7           	OR A
1005  5437 C8           	RET Z
1006  5438 41           	LD B, C
1007  5439 0E 98        	LD C, #98
1008  543B C3 4F 51     	JP BBYTECOPY
1009  543E              ; *******************************************************************************************************
1010  543E               ENDIF
1011  543E
1012  543E               IF (VRAM_CMDS == 1)
1013  543E              ; *******************************************************************************************************
1014  543E              ; function to handle CALL VRMMEM basic extension
1015  543E              ; copies from RAM to VRAM
1016  543E              ; _VRMMEM ( INT source,
1017  543E              ;			INT destination,
1018  543E              ;			INT count
1019  543E              ; will put ram in page 0 also, page 1 is already there
1020  543E              VRMMEM:
1021  543E              	; opening (
1022  543E CD 66 52     	CALL CHKCHAR
1023  5441 28           	DB '('
1024  5442              	; get source address
1025  5442 DD 21 2F 54  	LD IX, FRMQNT
1026  5446 CD 59 01     	CALL CALBAS
1027  5449 D5           	PUSH DE
1028  544A              	; comma
1029  544A CD 66 52     	CALL CHKCHAR
1030  544D 2C           	DB ','
1031  544E              	; get destination address
1032  544E DD 21 2F 54  	LD IX, FRMQNT
1033  5452 CD 59 01     	CALL CALBAS
1034  5455 D5           	PUSH DE
1035  5456              	; comma
1036  5456 CD 66 52     	CALL CHKCHAR
1037  5459 2C           	DB ','
1038  545A              	; get length
1039  545A DD 21 2F 54  	LD IX, FRMQNT
1040  545E CD 59 01     	CALL CALBAS
1041  5461 D5           	PUSH DE
1042  5462              	; ending )
1043  5462 CD 66 52     	CALL CHKCHAR
1044  5465 29           	DB ')'
1045  5466
1046  5466                  ; save position in BASIC text
1047  5466 E5           	PUSH HL
1048  5467 DD E1        	POP IX
1049  5469
1050  5469 C1           	POP BC ; count
1051  546A D1           	POP DE ; destination
1052  546B E1           	POP HL ; source
1053  546C D9           	EXX
1054  546D FD 21 74 54  	LD IY, .RET
1055  5471 C3 19 52     	JP ENABLE_PAGE0
1056  5474              .RET:
1057  5474 FB           	EI
1058  5475 D9           	EXX
1059  5476 CD 82 54     	CALL .LDIRMV
1060  5479 D1               POP DE
1061  547A C1               POP BC
1062  547B CD 90 51         CALL RESTORE_PAGE_INFO
1063  547E DD E5        	PUSH IX
1064  5480 E1           	POP HL
1065  5481 C9           	RET
1066  5482
1067  5482              .LDIRMV:
1068  5482              	; set VRAM address *exactly* as in ROM, otherwise corruption
1069  5482 7D           	LD	A, L
1070  5483 F3           	DI
1071  5484 D3 99        	OUT	(099H), A
1072  5486 7C           	LD	A, H
1073  5487 E6 3F        	AND	03FH
1074  5489 D3 99        	OUT	(099H), A
1075  548B FB           	EI
1076  548C              	;EX (SP), HL
1077  548C              	;EX (SP), HL
1078  548C              	;NOP
1079  548C              	;NOP
1080  548C              .L4:
1081  548C DB 98            IN A, (#98)
1082  548E 12           	LD (DE), A
1083  548F 13               INC DE
1084  5490 0B               DEC BC
1085  5491 79               LD A, C
1086  5492 B0               OR B
1087  5493 20 F7            JR NZ, .L4
1088  5495 C9               RET
1089  5496              ; *******************************************************************************************************
1090  5496               ENDIF
1091  5496
1092  5496              ; *******************************************************************************************************
1093  5496              ; H.TIMI function
1094  5496              MBGE_HTIMI:
1095  5496               EXPORT MBGE_HTIMI
1096  5496 F5           	PUSH AF
1097  5497
1098  5497               IF (SPRITE_CMDS == 1)
1099  5497 CD 01 4D     	CALL SPRATR_UPDATE
1100  549A               ENDIF
1101  549A
1102  549A               IF (SOUND_CMDS == 1)
1103  549A 3A F7 4C     	LD A, (SOUND_ENABLED)
1104  549D B7           	OR A
1105  549E 28 2A        	JR Z, .EXIT
1106  54A0
1107  54A0              	; enable page 2
1108  54A0 3E 02            LD A, 2
1109  54A2 CD 59 51         CALL GET_PAGE_INFO
1110  54A5 C5               PUSH BC
1111  54A6 D5               PUSH DE
1112  54A7 3A 43 F3         LD A, (RAMAD2)
1113  54AA 26 80            LD H, 080H
1114  54AC CD A0 51         CALL LOCAL_ENASLT
1115  54AF              	; enable page 0
1116  54AF AF               XOR A
1117  54B0 CD 59 51         CALL GET_PAGE_INFO
1118  54B3 C5               PUSH BC
1119  54B4 D5               PUSH DE
1120  54B5 3A 41 F3         LD A, (RAMAD0)
1121  54B8 26 00            LD H, 0
1122  54BA CD A0 51         CALL LOCAL_ENASLT
1123  54BD
1124  54BD CD 33 42     	CALL PLY_AKG_PLAY
1125  54C0
1126  54C0              	; restore page 0
1127  54C0 D1               POP DE
1128  54C1 C1               POP BC
1129  54C2 CD 90 51         CALL RESTORE_PAGE_INFO
1130  54C5              	; restore page 2
1131  54C5 D1               POP DE
1132  54C6 C1               POP BC
1133  54C7 CD 90 51         CALL RESTORE_PAGE_INFO
1134  54CA               ENDIF
1135  54CA
1136  54CA              .EXIT:
1137  54CA F1           	POP AF
1138  54CB C3 F0 4C     	JP ORIG.HTIMI
1139  54CE              ; *******************************************************************************************************
1140  54CE
1141  54CE              ; *******************************************************************************************************
1142  54CE              ; interrupt handler when page 0 enabled
1143  54CE              VBLANK:
1144  54CE              	EXPORT VBLANK
1145  54CE
1146  54CE F5               PUSH AF
1147  54CF              	; is VDP originator ?
1148  54CF DB 99        	IN	A, (099H)
1149  54D1 A7           	AND	A
1150  54D2 F2 F8 54     	JP P, .EXIT
1151  54D5
1152  54D5               IF (SOUND_CMDS == 1)
1153  54D5 3A F7 4C     	LD A, (SOUND_ENABLED)
1154  54D8 B7           	OR A
1155  54D9 28 1D        	JR Z, .EXIT
1156  54DB
1157  54DB C5               PUSH BC
1158  54DC D5               PUSH DE
1159  54DD E5               PUSH HL
1160  54DE 08               EX AF, AF'
1161  54DF D9               EXX
1162  54E0 F5               PUSH AF
1163  54E1 C5               PUSH BC
1164  54E2 D5               PUSH DE
1165  54E3 E5               PUSH HL
1166  54E4 DD E5            PUSH IX
1167  54E6 FD E5            PUSH IY
1168  54E8
1169  54E8 CD 33 42     	CALL PLY_AKG_PLAY
1170  54EB
1171  54EB FD E1            POP IY
1172  54ED DD E1            POP IX
1173  54EF E1               POP HL
1174  54F0 D1               POP DE
1175  54F1 C1               POP BC
1176  54F2 F1               POP AF
1177  54F3 08               EX AF, AF'
1178  54F4 D9               EXX
1179  54F5 E1               POP HL
1180  54F6 D1               POP DE
1181  54F7 C1               POP BC
1182  54F8               ENDIF
1183  54F8
1184  54F8              .EXIT:
1185  54F8 F1           	POP AF
1186  54F9 FB           	EI
1187  54FA ED 4D        	RETI
1188  54FC              ; *******************************************************************************************************
1189  54FC
1190  54FC               IF (SOUND_CMDS == 1)
1191  54FC              ; *******************************************************************************************************
1192  54FC              ; function to handle CALL SNDPLYINIT basic extension
1193  54FC              ; initializes sound player
1194  54FC              ; _SNDPLYINIT ( INT music_offset,
1195  54FC              ;				INT sfx_offset, can be -1 if no SFX
1196  54FC              ; will put ram in page 0 also, page 1 is already there
1197  54FC              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
1198  54FC              SNDPLYINIT:
1199  54FC              	; opening (
1200  54FC CD 66 52     	CALL CHKCHAR
1201  54FF 28           	DB '('
1202  5500              	; get music address
1203  5500 DD 21 2F 54  	LD IX, FRMQNT
1204  5504 CD 59 01     	CALL CALBAS
1205  5507 D5           	PUSH DE
1206  5508              	; comma
1207  5508 CD 66 52     	CALL CHKCHAR
1208  550B 2C           	DB ','
1209  550C              	; get sfx address
1210  550C DD 21 2F 54  	LD IX, FRMQNT
1211  5510 CD 59 01     	CALL CALBAS
1212  5513 D5           	PUSH DE
1213  5514              	; ending )
1214  5514 CD 66 52     	CALL CHKCHAR
1215  5517 29           	DB ')'
1216  5518
1217  5518                  ; save position in BASIC text
1218  5518 44           	LD B, H
1219  5519 4D           	LD C, L
1220  551A
1221  551A              	; pop LDIR parameters and store away for later
1222  551A D1           	POP DE ; sfx address
1223  551B E1           	POP HL ; music address
1224  551C C5           	PUSH BC ; basic text location
1225  551D D9           	EXX
1226  551E FD 21 25 55  	LD IY, .RET
1227  5522 C3 19 52     	JP ENABLE_PAGE0
1228  5525              .RET:
1229  5525 D9           	EXX
1230  5526
1231  5526 D5           	PUSH DE
1232  5527 AF           	XOR A
1233  5528              	; HL = music location
1234  5528 CD 62 41     	CALL PLY_AKG_INIT
1235  552B 3E 01        	LD A, 1
1236  552D 32 F5 4C     	LD (MUSIC_INIT_STATUS), A
1237  5530
1238  5530 E1           	POP HL ; SFX
1239  5531              	; check if SFX address -1
1240  5531 23           	INC HL
1241  5532 7D           	LD A, L
1242  5533 B4           	OR H
1243  5534 28 09        	JR Z,.L1
1244  5536 2B           	DEC HL
1245  5537 CD 1D 40     	CALL PLY_AKG_INITSOUNDEFFECTS
1246  553A 3E 01        	LD A, 1
1247  553C 32 F6 4C     	LD (SFX_INIT_STATUS), A
1248  553F              .L1:
1249  553F D1               POP DE
1250  5540 C1               POP BC
1251  5541 CD 90 51         CALL RESTORE_PAGE_INFO
1252  5544
1253  5544 E1           	POP HL
1254  5545 C9           	RET
1255  5546              ; *******************************************************************************************************
1256  5546
1257  5546              ; *******************************************************************************************************
1258  5546              ; function to handle CALL SNDPLYON basic extension
1259  5546              ; enables sound player
1260  5546              ; _SNDPLYON
1261  5546              ; sets SOUND_ENABLED variable to 1 if init call was done
1262  5546              ; if not throws out of data error
1263  5546              SNDPLYON:
1264  5546 3A F5 4C     	LD A, (MUSIC_INIT_STATUS)
1265  5549 B7           	OR A
1266  554A 20 05        	JR NZ, .L1
1267  554C              	; player not initialized, throw error
1268  554C 1E 04        	LD E, 04 ; Out of DATA
1269  554E C3 7E 52     	JP THROW_ERROR
1270  5551              .L1:
1271  5551 32 F7 4C     	LD (SOUND_ENABLED), A
1272  5554              	; disable key click
1273  5554 AF           	XOR A
1274  5555 32 DB F3     	LD (CLIKSW), A
1275  5558 C9           	RET
1276  5559              ; *******************************************************************************************************
1277  5559
1278  5559              ; *******************************************************************************************************
1279  5559              ; function to handle CALL SNDPLYOFF basic extension
1280  5559              ; disables sound player
1281  5559              ; _SNDPLYOFF
1282  5559              ; sets SOUND_ENABLED variable to 0
1283  5559              ; calls AKG to stop music and SFX on all channels if initialized
1284  5559              SNDPLYOFF:
1285  5559 3A F7 4C     	LD A, (SOUND_ENABLED)
1286  555C B7           	OR A
1287  555D C8           	RET Z ; already stopped
1288  555E AF           	XOR A
1289  555F 32 F7 4C     	LD (SOUND_ENABLED), A
1290  5562 E5           	PUSH HL
1291  5563 CD 21 42     	CALL PLY_AKG_STOP
1292  5566 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1293  5569 B7           	OR A
1294  556A 28 0E        	JR Z, .EXIT ; SFX not in use
1295  556C AF           	XOR A
1296  556D CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1297  5570 3E 01        	LD A, 1
1298  5572 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1299  5575 3E 02        	LD A, 2
1300  5577 CD 49 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
1301  557A              .EXIT:
1302  557A E1           	POP HL
1303  557B C9           	RET
1304  557C              ; *******************************************************************************************************
1305  557C
1306  557C              ; *******************************************************************************************************
1307  557C              ; function to handle CALL SNDSFX basic extension
1308  557C              ; plays a sound effect
1309  557C              ; _SNDSFX ( BYTE sfx_number, >0
1310  557C              ;			BYTE channel, = 0,1 or 2
1311  557C              ;			BYTE inverted_volume = 0-16, 0 being full volume
1312  557C              ; will put ram in page 0 also, page 1 is already there
1313  557C              ; if sound off throws illegal function call
1314  557C              ; if sfx not initialized, throws out of data
1315  557C              SNDSFX:
1316  557C              	; opening (
1317  557C CD 66 52     	CALL CHKCHAR
1318  557F 28           	DB '('
1319  5580              	; get sfx_number
1320  5580 DD 21 1C 52  	LD IX, GETBYT
1321  5584 CD 59 01     	CALL CALBAS
1322  5587 D5           	PUSH DE
1323  5588              	; comma
1324  5588 CD 66 52     	CALL CHKCHAR
1325  558B 2C           	DB ','
1326  558C              	; get sfx address
1327  558C DD 21 1C 52  	LD IX, GETBYT
1328  5590 CD 59 01     	CALL CALBAS
1329  5593 D5           	PUSH DE
1330  5594              	; comma
1331  5594 CD 66 52     	CALL CHKCHAR
1332  5597 2C           	DB ','
1333  5598              	; get inverted volume
1334  5598 DD 21 1C 52  	LD IX, GETBYT
1335  559C CD 59 01     	CALL CALBAS
1336  559F D5           	PUSH DE
1337  55A0              	; ending )
1338  55A0 CD 66 52     	CALL CHKCHAR
1339  55A3 29           	DB ')'
1340  55A4
1341  55A4 3A F7 4C     	LD A, (SOUND_ENABLED)
1342  55A7 B7           	OR A
1343  55A8 20 05        	JR NZ, .L1
1344  55AA              	; sound disabled, throw illegal function call
1345  55AA 1E 05        	LD E, 5
1346  55AC C3 7E 52     	JP THROW_ERROR
1347  55AF              .L1:
1348  55AF 3A F6 4C     	LD A, (SFX_INIT_STATUS)
1349  55B2 B7           	OR A
1350  55B3 20 05        	JR NZ, .L2
1351  55B5              	; sfx data not initialized, throw out of data
1352  55B5 1E 04        	LD E, 4
1353  55B7 C3 7E 52     	JP THROW_ERROR
1354  55BA              .L2:
1355  55BA              	; pop  parameters and store away for later
1356  55BA D1           	POP DE ; inverted volume
1357  55BB 43           	LD B, E
1358  55BC D1           	POP DE ; channel
1359  55BD 4B           	LD C, E
1360  55BE D1           	POP DE
1361  55BF 7B           	LD A, E
1362  55C0 08           	EX AF, AF'
1363  55C1 E5           	PUSH HL ; basic text location
1364  55C2 D9           	EXX
1365  55C3 FD 21 CA 55  	LD IY, .RET
1366  55C7 C3 19 52     	JP ENABLE_PAGE0
1367  55CA              .RET:
1368  55CA D9           	EXX
1369  55CB 08           	EX AF, AF'
1370  55CC CD 21 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
1371  55CF
1372  55CF D1               POP DE
1373  55D0 C1               POP BC
1374  55D1 CD 90 51         CALL RESTORE_PAGE_INFO
1375  55D4
1376  55D4 E1           	POP HL
1377  55D5 C9           	RET
1378  55D6              ; *******************************************************************************************************
1379  55D6               ENDIF
1380  55D6
1381  55D6               IF (BLIT_CMDS == 1)
1382  55D6              ; *******************************************************************************************************
1383  55D6              ; function rotates mask and data of several characters and applies to background data
1384  55D6              ; this handles x-shift from 0 to 4
1385  55D6              ; contains self-modifying code that is set-up from external function
1386  55D6              ; input HL=pointer to mask data
1387  55D6              ; input HL'=pointer to character data
1388  55D6              ; input DE=output buffer containing background data
1389  55D6              ; input BC=DE+8
1390  55D6              ; input A=number of characters to process
1391  55D6              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1392  55D6              SHIFT04:
1393  55D6 08           	EX AF, AF'
1394  55D7 7E           	LD A, (HL) ; get mask
1395  55D8 D9           	EXX
1396  55D9 57           	LD D, A
1397  55DA 1E FF        	LD E, #FF
1398  55DC 37           	SCF
1399  55DD              .M1:
1400  55DD 18 FE        	JR .M1 ; this is self-modifying part
1401  55DF CB 1A        	RR D
1402  55E1 CB 1B        	RR E
1403  55E3 CB 1A        	RR D
1404  55E5 CB 1B        	RR E
1405  55E7 CB 1A        	RR D
1406  55E9 CB 1B        	RR E
1407  55EB CB 1A        	RR D
1408  55ED CB 1B        	RR E
1409  55EF
1410  55EF 46           	LD B, (HL) ; get data
1411  55F0 0E 00        	LD C, 0
1412  55F2              .M2:
1413  55F2 18 FE        	JR .M2 ; also self-modifying part
1414  55F4 CB 38        	SRL B
1415  55F6 CB 19        	RR C
1416  55F8 CB 38        	SRL B
1417  55FA CB 19        	RR C
1418  55FC CB 38        	SRL B
1419  55FE CB 19        	RR C
1420  5600 CB 38        	SRL B
1421  5602 CB 19        	RR C
1422  5604
1423  5604 D9           	EXX
1424  5605 1A           	LD A, (DE) ; background
1425  5606 D9           	EXX
1426  5607 A2           	AND D
1427  5608 B0           	OR B
1428  5609 D9           	EXX
1429  560A 12           	LD (DE), A
1430  560B
1431  560B 0A           	LD A, (BC)
1432  560C D9           	EXX
1433  560D A3           	AND E
1434  560E B1           	OR C
1435  560F 23           	INC HL
1436  5610 D9           	EXX
1437  5611 02           	LD (BC), A
1438  5612
1439  5612 23           	INC HL
1440  5613 13           	INC DE
1441  5614 03           	INC BC
1442  5615
1443  5615 08           	EX AF, AF'
1444  5616 3D           	DEC A
1445  5617 C2 D6 55     	JP NZ, SHIFT04
1446  561A C9           	RET
1447  561B              ; *******************************************************************************************************
1448  561B
1449  561B              ; *******************************************************************************************************
1450  561B              ; function rotates mask and data of several characters and applies to background data
1451  561B              ; this handles x-shift from 5 to 8
1452  561B              ; contains self-modifying code that is set-up from external function
1453  561B              ; input HL=pointer to mask data
1454  561B              ; input HL'=pointer to character data
1455  561B              ; input DE=output buffer containing background data
1456  561B              ; input BC=DE+8
1457  561B              ; input A=number of characters to process
1458  561B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1459  561B              SHIFT58:
1460  561B 08           	EX AF, AF'
1461  561C 7E           	LD A, (HL) ; get mask
1462  561D D9           	EXX
1463  561E 57           	LD D, A
1464  561F 1E FF        	LD E, #FF
1465  5621 37           	SCF
1466  5622              .M1:
1467  5622 18 FE        	JR .M1 ; this is self-modifying part
1468  5624 CB 12        	RL D
1469  5626 CB 13        	RL E
1470  5628 CB 12        	RL D
1471  562A CB 13        	RL E
1472  562C CB 12        	RL D
1473  562E CB 13        	RL E
1474  5630
1475  5630 46           	LD B, (HL)
1476  5631 0E 00        	LD C, 0
1477  5633              .M2:
1478  5633 18 FE        	JR .M2 ; also self-modifying part
1479  5635 CB 20        	SLA B
1480  5637 CB 11        	RL C
1481  5639 CB 20        	SLA B
1482  563B CB 11        	RL C
1483  563D CB 20        	SLA B
1484  563F CB 11        	RL C
1485  5641
1486  5641 D9           	EXX
1487  5642 1A           	LD A, (DE) ; background
1488  5643 D9           	EXX
1489  5644 A3           	AND E
1490  5645 B1           	OR C
1491  5646 D9           	EXX
1492  5647 12           	LD (DE), A
1493  5648
1494  5648 0A           	LD A, (BC)
1495  5649 D9           	EXX
1496  564A A2           	AND D
1497  564B B0           	OR B
1498  564C 23           	INC HL
1499  564D D9           	EXX
1500  564E 02           	LD (BC), A
1501  564F
1502  564F 23           	INC HL
1503  5650 13           	INC DE
1504  5651 03           	INC BC
1505  5652
1506  5652 08           	EX AF, AF'
1507  5653 3D           	DEC A
1508  5654 C2 1B 56     	JP NZ, SHIFT58
1509  5657 C9           	RET
1510  5658              ; *******************************************************************************************************
1511  5658
1512  5658              ; *******************************************************************************************************
1513  5658              ; routine that shifts one row of characters
1514  5658              ; contains self-modifying code that is set-up from external function
1515  5658              ; input HL=pointer to mask data
1516  5658              ; input HL'=pointer to character data
1517  5658              ; input DE=output buffer containing background data
1518  5658              ; input A=number of characters to process
1519  5658              ; input IX=pointer to structure describing input data
1520  5658              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
1521  5658              SHIFT_ROW:
1522  5658 F5           	PUSH AF
1523  5659 ED 53 22 50  		LD (BLIT_TMP1), DE
1524  565D E5           		PUSH HL
1525  565E CD A1 56     			CALL .ADDYSHIFT
1526  5661 E1           		POP HL
1527  5662 ED 53 24 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1528  5666              .L1:
1529  5666 3E 08        		LD A, 8
1530  5668 DD 96 02     		SUB (IX+2) ; y shift
1531  566B              .CALL1:
1532  566B CD 00 00     		CALL 0
1533  566E DD 7E 02     		LD A, (IX+2); y shift
1534  5671 B7           		OR A
1535  5672 28 26        		JR Z, .DONE
1536  5674 ED 5B 22 50  		LD DE, (BLIT_TMP1)
1537  5678 E5           		PUSH HL
1538  5679 CD AF 56     			CALL .DETONEXTROW
1539  567C E1           		POP HL
1540  567D              .CALL2:
1541  567D CD 00 00     		CALL 0
1542  5680 ED 5B 22 50  		LD DE, (BLIT_TMP1)
1543  5684 E5           		PUSH HL
1544  5685 CD A9 56     			CALL .ADD8
1545  5688 E1           		POP HL
1546  5689 ED 53 22 50  		LD (BLIT_TMP1), DE
1547  568D ED 5B 24 50  		LD DE, (BLIT_TMP2)
1548  5691 E5           		PUSH HL
1549  5692 CD A9 56     			CALL .ADD8
1550  5695 E1           		POP HL
1551  5696 ED 53 24 50  		LD (BLIT_TMP2), DE ; DE+vertical shift
1552  569A              .DONE:
1553  569A F1           	POP AF
1554  569B 3D           	DEC A
1555  569C C8           	RET Z
1556  569D F5           	PUSH AF
1557  569E C3 66 56     	JP .L1
1558  56A1              .ADDYSHIFT:
1559  56A1 EB           	EX DE, HL
1560  56A2 16 00        	LD D, 0
1561  56A4 DD 5E 02     	LD E, (IX+2); y shift
1562  56A7 18 0C        	JR .MOVDEBC
1563  56A9              .ADD8:
1564  56A9 21 08 00     	LD HL, 8
1565  56AC C3 B5 56     	JP .MOVDEBC
1566  56AF              .DETONEXTROW:
1567  56AF DD 6E 06     	LD L, (IX+6)
1568  56B2 DD 66 07     	LD H, (IX+7) ; bkg add to value
1569  56B5              .MOVDEBC:
1570  56B5 19           	ADD HL, DE
1571  56B6 54           	LD D, H
1572  56B7 5D           	LD E, L
1573  56B8 01 08 00     	LD BC, 8
1574  56BB 09           	ADD HL, BC
1575  56BC 44           	LD B, H
1576  56BD 4D           	LD C, L
1577  56BE C9           	RET
1578  56BF              ; *******************************************************************************************************
1579  56BF
1580  56BF              ; *******************************************************************************************************
1581  56BF              ; function rotates mask and character data and applies it to background
1582  56BF              ; input IX=pointer to structure describing input data
1583  56BF              ; +0  DW horizontal shift count 0-7 (low byte used)
1584  56BF              ; +2  DW vertical shift count 0-7 (low byte used)
1585  56BF              ; +4  DW background data start;
1586  56BF              ; +6  DW background add to value to next row of background data
1587  56BF              ; +8  DW mask data start;
1588  56BF              ; +10  DW character data start;
1589  56BF              ; +12 DW character&mask add to value to next row of data
1590  56BF              ; +14 DW columns (low byte used)
1591  56BF              ; +16 DW rows (low byte used)
1592  56BF              SHIFT_MERGE_CHARACTER:
1593  56BF DD 7E 00     	LD A, (IX) ; shift
1594  56C2 FE 05        	CP 5
1595  56C4 38 25        	JR C, .RIGHT
1596  56C6              	; shifts 5-7, use rotate towards left 1-3
1597  56C6 21 1B 56     	LD HL, SHIFT58
1598  56C9 22 6C 56     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1599  56CC 22 7E 56     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1600  56CF D6 05        	SUB 5
1601  56D1 28 0D        	JR Z, .L1
1602  56D3 87           	ADD A, A
1603  56D4 87           	ADD A, A
1604  56D5 67           	LD H, A
1605  56D6 2E 18        	LD L, #18 ; JR opcode
1606  56D8 22 22 56     	LD (SHIFT58.M1), HL
1607  56DB 22 33 56     	LD (SHIFT58.M2), HL
1608  56DE 18 32        	JR .DO
1609  56E0              .L1:
1610  56E0 21 00 00     	LD HL, 0 ; 2xNOP opcode
1611  56E3 22 22 56     	LD (SHIFT58.M1), HL
1612  56E6 22 33 56     	LD (SHIFT58.M2), HL
1613  56E9 18 27        	JR .DO
1614  56EB              .RIGHT:
1615  56EB              	; shifts 0-4, rotate towards right
1616  56EB 21 D6 55     	LD HL, SHIFT04
1617  56EE 22 6C 56     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
1618  56F1 22 7E 56     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
1619  56F4 FE 04        	CP 4
1620  56F6 28 11        	JR Z, .R1
1621  56F8 D6 04        	SUB 4
1622  56FA ED 44        	NEG
1623  56FC 87           	ADD A, A
1624  56FD 87           	ADD A, A
1625  56FE 67           	LD H, A
1626  56FF 2E 18        	LD L, #18 ; JR opcode
1627  5701 22 DD 55     	LD (SHIFT04.M1), HL
1628  5704 22 F2 55     	LD (SHIFT04.M2), HL
1629  5707 18 09        	JR .DO
1630  5709              .R1:
1631  5709 21 00 00     	LD HL, 0 ; 2xNOP opcode
1632  570C 22 DD 55     	LD (SHIFT04.M1), HL
1633  570F 22 F2 55     	LD (SHIFT04.M2), HL
1634  5712              .DO:
1635  5712 DD 46 10     	LD B, (IX+16) ; rows
1636  5715 DD 6E 08     	LD L, (IX+8)
1637  5718 DD 66 09     	LD H, (IX+9) ; mask data
1638  571B DD 5E 04     	LD E, (IX+4)
1639  571E DD 56 05     	LD D, (IX+5) ; background data
1640  5721 D9           	EXX
1641  5722 DD 6E 0A     	LD L, (IX+10)
1642  5725 DD 66 0B     	LD H, (IX+11) ; character data
1643  5728 D9           	EXX
1644  5729              .LOOP:
1645  5729 C5           	PUSH BC
1646  572A E5           		PUSH HL
1647  572B D5           			PUSH DE
1648  572C D9           				EXX
1649  572D E5           				PUSH HL
1650  572E D9           					EXX
1651  572F DD 7E 0E     					LD A, (IX+14) ; columns
1652  5732              .CALL:
1653  5732 CD 58 56     					CALL SHIFT_ROW
1654  5735 E1           				POP HL
1655  5736 DD 5E 0C     				LD E, (IX+12)
1656  5739 DD 56 0D     				LD D, (IX+13) ; char data to next row
1657  573C 19           				ADD HL, DE
1658  573D D9           				EXX
1659  573E E1           			POP HL
1660  573F DD 5E 06     			LD E, (IX+6)
1661  5742 DD 56 07     			LD D, (IX+7) ; background to next row
1662  5745 19           			ADD HL, DE
1663  5746 EB           			EX DE, HL
1664  5747 E1           		POP HL
1665  5748 DD 4E 0C     		LD C, (IX+12)
1666  574B DD 46 0D     		LD B, (IX+13) ; char data to next row
1667  574E 09           		ADD HL, BC
1668  574F C1           	POP BC
1669  5750 10 D7        	DJNZ .LOOP
1670  5752 C9           	RET
1671  5753              ; *******************************************************************************************************
1672  5753
1673  5753               IFNDEF CMDS_WITH_PARAMETERS
1674  5753 ~            ; *******************************************************************************************************
1675  5753 ~            ; function to handle CALL BLIT basic extension
1676  5753 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
1677  5753 ~            ; fuses with background data and applies vertical shift too
1678  5753 ~            ; BLIT ( INT request_data_ptr )
1679  5753 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
1680  5753 ~            ; will put ram in page 0 also, page 1 is already there
1681  5753 ~            BLIT:
1682  5753 ~            	; opening (
1683  5753 ~            	CALL CHKCHAR
1684  5753 ~            	DB '('
1685  5753 ~            	; get pointer to request struct
1686  5753 ~            	LD IX, FRMQNT
1687  5753 ~            	CALL CALBAS
1688  5753 ~            	PUSH DE
1689  5753 ~            	; ending )
1690  5753 ~            	CALL CHKCHAR
1691  5753 ~            	DB ')'
1692  5753 ~
1693  5753 ~            	POP IX ; pointer to request struct
1694  5753 ~
1695  5753 ~            	PUSH HL ; save position in BASIC buffer
1696  5753 ~
1697  5753 ~            	LD IY, .RET
1698  5753 ~            	JP ENABLE_PAGE0
1699  5753 ~            .RET:
1700  5753 ~            	EI
1701  5753 ~            	CALL SHIFT_MERGE_CHARACTER
1702  5753 ~
1703  5753 ~                POP DE
1704  5753 ~                POP BC
1705  5753 ~                CALL RESTORE_PAGE_INFO
1706  5753 ~
1707  5753 ~            	POP HL
1708  5753 ~            	RET
1709  5753 ~            ; *******************************************************************************************************
1710  5753               ENDIF
1711  5753
1712  5753               IFDEF CMDS_WITH_PARAMETERS
1713  5753              ; *******************************************************************************************************
1714  5753              ; function to handle CALL BLIT basic extension
1715  5753              ; rotates 1-bit character drawing horizontally with mask and character data and
1716  5753              ; fuses with background data and applies vertical shift too
1717  5753              ; in form without pointers
1718  5753              ; BLIT ( INT x,
1719  5753              ;		 INT y,
1720  5753              ;		 INT char_data_pointer,
1721  5753              ;		 INT mask_data_pointer,
1722  5753              ;		 INT width (in characters),
1723  5753              ;		 INT height (in characters),
1724  5753              ;		 INT background_pointer (top left),
1725  5753              ;		 INT background_width (in characters),
1726  5753              ;		 INT background_height (in characters))
1727  5753              ; will put ram in page 0 also, page 1 is already there
1728  5753              BLIT:
1729  5753              	; opening (
1730  5753 CD 66 52     	CALL CHKCHAR
1731  5756 28           	DB '('
1732  5757              	; get x coordinate
1733  5757 DD 21 2F 54  	LD IX, FRMQNT
1734  575B CD 59 01     	CALL CALBAS
1735  575E 7B           	LD A, E
1736  575F E6 07        	AND 7
1737  5761 32 26 50     	LD (BLIT_STRUCT+0), A
1738  5764 CD 41 58     	CALL .DAdiv8
1739  5767 32 22 50     	LD (BLIT_TMP+0),A
1740  576A              	; comma
1741  576A CD 66 52     	CALL CHKCHAR
1742  576D 2C           	DB ','
1743  576E              	; get y coordinate
1744  576E DD 21 2F 54  	LD IX, FRMQNT
1745  5772 CD 59 01     	CALL CALBAS
1746  5775 7B           	LD A, E
1747  5776 E6 07        	AND 7
1748  5778 32 28 50     	LD (BLIT_STRUCT+2), A
1749  577B CD 41 58     	CALL .DAdiv8
1750  577E 32 23 50     	LD (BLIT_TMP+1),A
1751  5781              	; comma
1752  5781 CD 66 52     	CALL CHKCHAR
1753  5784 2C           	DB ','
1754  5785              	; get char data pointer
1755  5785 DD 21 2F 54  	LD IX, FRMQNT
1756  5789 CD 59 01     	CALL CALBAS
1757  578C ED 53 30 50  	LD (BLIT_STRUCT+10), DE
1758  5790              	; comma
1759  5790 CD 66 52     	CALL CHKCHAR
1760  5793 2C           	DB ','
1761  5794              	; get mask data pointer
1762  5794 DD 21 2F 54  	LD IX, FRMQNT
1763  5798 CD 59 01     	CALL CALBAS
1764  579B ED 53 2E 50  	LD (BLIT_STRUCT+8), DE
1765  579F              	; comma
1766  579F CD 66 52     	CALL CHKCHAR
1767  57A2 2C           	DB ','
1768  57A3              	; get width
1769  57A3 DD 21 2F 54  	LD IX, FRMQNT
1770  57A7 CD 59 01     	CALL CALBAS
1771  57AA 7B           	LD A, E
1772  57AB 32 34 50     	LD (BLIT_STRUCT+14), A
1773  57AE              	; comma
1774  57AE CD 66 52     	CALL CHKCHAR
1775  57B1 2C           	DB ','
1776  57B2              	; get height
1777  57B2 DD 21 2F 54  	LD IX, FRMQNT
1778  57B6 CD 59 01     	CALL CALBAS
1779  57B9 7B           	LD A, E
1780  57BA 32 36 50     	LD (BLIT_STRUCT+16), A
1781  57BD              	; comma
1782  57BD CD 66 52     	CALL CHKCHAR
1783  57C0 2C           	DB ','
1784  57C1              	; get background pointer
1785  57C1 DD 21 2F 54  	LD IX, FRMQNT
1786  57C5 CD 59 01     	CALL CALBAS
1787  57C8 ED 53 2A 50  	LD (BLIT_STRUCT+4), DE
1788  57CC              	; comma
1789  57CC CD 66 52     	CALL CHKCHAR
1790  57CF 2C           	DB ','
1791  57D0              	; get background width
1792  57D0 DD 21 2F 54  	LD IX, FRMQNT
1793  57D4 CD 59 01     	CALL CALBAS
1794  57D7 7B           	LD A, E
1795  57D8 32 24 50     	LD (BLIT_TMP+2), A
1796  57DB              	; comma
1797  57DB CD 66 52     	CALL CHKCHAR
1798  57DE 2C           	DB ','
1799  57DF              	; get background height
1800  57DF DD 21 2F 54  	LD IX, FRMQNT
1801  57E3 CD 59 01     	CALL CALBAS
1802  57E6 7B           	LD A, E
1803  57E7 32 25 50     	LD (BLIT_TMP+3), A
1804  57EA              	; ending )
1805  57EA CD 66 52     	CALL CHKCHAR
1806  57ED 29           	DB ')'
1807  57EE
1808  57EE E5           	PUSH HL ; save position in BASIC buffer
1809  57EF
1810  57EF              	; calculate char&mask add to value
1811  57EF 26 00        	LD H, 0
1812  57F1 3A 34 50     	LD A, (BLIT_STRUCT+14)
1813  57F4 6F           	LD L, A
1814  57F5 CD 55 51     	CALL HLx8
1815  57F8 22 32 50     	LD (BLIT_STRUCT+12), HL
1816  57FB              	; calculate background add to value
1817  57FB 26 00        	LD H, 0
1818  57FD 3A 24 50     	LD A, (BLIT_TMP+2)
1819  5800 6F           	LD L, A
1820  5801 CD 55 51     	CALL HLx8
1821  5804 22 2C 50     	LD (BLIT_STRUCT+6), HL
1822  5807              	; calculate pointer to background location
1823  5807 21 00 00     	LD HL, 0
1824  580A 3A 23 50     	LD A,(BLIT_TMP+1)
1825  580D B7           	OR A
1826  580E 28 08        	JR Z, .L1
1827  5810 47           	LD B,A
1828  5811 ED 5B 2C 50  	LD DE,(BLIT_STRUCT+6)
1829  5815              .L0:
1830  5815 19           	ADD HL, DE
1831  5816 10 FD        	DJNZ .L0
1832  5818              .L1:
1833  5818 EB           	EX DE,HL
1834  5819 26 00        	LD H,0
1835  581B 3A 22 50     	LD A,(BLIT_TMP+0)
1836  581E 6F           	LD L,A
1837  581F CD 55 51     	CALL HLx8
1838  5822 19           	ADD HL,DE
1839  5823 ED 5B 2A 50  	LD DE,(BLIT_STRUCT+4)
1840  5827 19           	ADD HL,DE
1841  5828 22 2A 50     	LD (BLIT_STRUCT+4),HL
1842  582B
1843  582B FD 21 32 58  	LD IY, .RET
1844  582F C3 19 52     	JP ENABLE_PAGE0
1845  5832              .RET:
1846  5832 FB           	EI
1847  5833 DD 21 26 50  	LD IX, BLIT_STRUCT
1848  5837 CD BF 56     	CALL SHIFT_MERGE_CHARACTER
1849  583A
1850  583A D1               POP DE
1851  583B C1               POP BC
1852  583C CD 90 51         CALL RESTORE_PAGE_INFO
1853  583F
1854  583F E1           	POP HL
1855  5840 C9           	RET
1856  5841              .DAdiv8:
1857  5841 7B           	LD A,E
1858  5842 CB 2A        	SRA D
1859  5844 CB 1F            RR  A
1860  5846 CB 2A            SRA D
1861  5848 CB 1F            RR  A
1862  584A CB 2A            SRA D
1863  584C CB 1F            RR  A
1864  584E C9           	RET
1865  584F              ; *******************************************************************************************************
1866  584F               ENDIF
1867  584F               ENDIF
1868  584F
1869  584F               IF (TILE_CMDS == 1)
1870  584F              ; *******************************************************************************************************
1871  584F              ; generic function to implement tiling
1872  584F              ; should be modified to call appropriate function for memory or vram
1873  584F              ; input IX=pointer to following structure
1874  584F              ; +00 tile_data_ptr
1875  584F              ; +02 tile_rows
1876  584F              ; +04 tile_columns
1877  584F              ; +06 destination_address
1878  584F              ; +08 dest_to_next_row_add_to_value
1879  584F              ; +10 num_horizontal_tiles
1880  584F              ; +12 num_vertical_tiles
1881  584F              ; modifies AF, BC, DE, HL
1882  584F              TILE:
1883  584F DD 6E 06     	LD L, (IX+6)
1884  5852 DD 66 07     	LD H, (IX+7) ; destination address
1885  5855 22 22 50     	LD (TILETMP1), HL
1886  5858 DD 46 0C     	LD B, (IX+12) ; vertical tile number
1887  585B              .L1:
1888  585B C5           	PUSH BC
1889  585C DD 6E 00     		LD L, (IX+0)
1890  585F DD 66 01     		LD H, (IX+1) ; tile address
1891  5862 22 24 50     		LD (TILETMP2), HL
1892  5865 DD 46 02     		LD B, (IX+2) ; tile rows
1893  5868              .L2:
1894  5868 C5           		PUSH BC
1895  5869              .CALL1:
1896  5869 CD 00 00     			CALL 0
1897  586C DD 46 0A     			LD B, (IX+10) ; horizontal tile num
1898  586F              .L3:
1899  586F C5           			PUSH BC
1900  5870 2A 24 50     				LD HL, (TILETMP2)
1901  5873 DD 46 04     				LD B, (IX+4) ; tile columns
1902  5876              .L4:
1903  5876 C5           				PUSH BC
1904  5877              .CALL2:
1905  5877 CD 00 00     					CALL 0
1906  587A C1           				POP BC
1907  587B 10 F9        				DJNZ .L4
1908  587D C1           			POP BC
1909  587E 10 EF        			DJNZ .L3
1910  5880 22 24 50     			LD (TILETMP2), HL
1911  5883 2A 22 50     			LD HL, (TILETMP1)
1912  5886 DD 5E 08     			LD E, (IX+8)
1913  5889 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
1914  588C 19           			ADD HL, DE
1915  588D 22 22 50     			LD (TILETMP1), HL
1916  5890 C1           		POP BC
1917  5891 10 D5        		DJNZ .L2
1918  5893 C1           	POP BC
1919  5894 10 C5        	DJNZ .L1
1920  5896 C9           	RET
1921  5897              ; *******************************************************************************************************
1922  5897
1923  5897               IFNDEF CMDS_WITH_PARAMETERS
1924  5897 ~            ; *******************************************************************************************************
1925  5897 ~            ; function to handle CALL TILERAM basic extension
1926  5897 ~            ; fills memory with tiles
1927  5897 ~            ; TILERAM ( INT request_data_ptr )
1928  5897 ~            ; request_data_ptr described in TILE
1929  5897 ~            ; will put ram in page 0 also, page 1 is already there
1930  5897 ~            TILERAM:
1931  5897 ~            	; opening (
1932  5897 ~            	CALL CHKCHAR
1933  5897 ~            	DB '('
1934  5897 ~            	; get pointer to request struct
1935  5897 ~            	LD IX, FRMQNT
1936  5897 ~            	CALL CALBAS
1937  5897 ~            	PUSH DE
1938  5897 ~            	; ending )
1939  5897 ~            	CALL CHKCHAR
1940  5897 ~            	DB ')'
1941  5897 ~
1942  5897 ~            	POP IX ; pointer to request struct
1943  5897 ~
1944  5897 ~            	PUSH HL ; save position in BASIC buffer
1945  5897 ~
1946  5897 ~            	LD IY, .RET
1947  5897 ~            	JP ENABLE_PAGE0
1948  5897 ~            .RET:
1949  5897 ~            	EI
1950  5897 ~            	; set RAM functions to call
1951  5897 ~            	LD HL, .TILECOPY
1952  5897 ~            	LD (TILE.CALL2+1), HL
1953  5897 ~            	LD HL, .SETDESTROW
1954  5897 ~            	LD (TILE.CALL1+1), HL
1955  5897 ~            	CALL TILE
1956  5897 ~
1957  5897 ~                POP DE
1958  5897 ~                POP BC
1959  5897 ~                CALL RESTORE_PAGE_INFO
1960  5897 ~
1961  5897 ~            	POP HL
1962  5897 ~            	RET
1963  5897 ~            .TILECOPY:
1964  5897 ~            	.8 LDI
1965  5897 ~            	RET
1966  5897 ~            .SETDESTROW:
1967  5897 ~            	LD DE, (TILETMP1)
1968  5897 ~            	RET
1969  5897 ~            ; *******************************************************************************************************
1970  5897               ENDIF
1971  5897
1972  5897               IFDEF CMDS_WITH_PARAMETERS
1973  5897              ; *******************************************************************************************************
1974  5897              ; function to handle CALL TILERAM basic extension
1975  5897              ; fills memory with tiles
1976  5897              ; TILERAM ( INT tile_data_pointer,
1977  5897              ;			INT tile_columns,
1978  5897              ;			INT tile_rows,
1979  5897              ;			INT destination_pointer,
1980  5897              ;			INT destination_columns,
1981  5897              ;			INT destination_rows,
1982  5897              ;			INT destination_begin_column,
1983  5897              ;			INT destination_begin_row,
1984  5897              ;			INT number_of_tiles_horizontally,
1985  5897              ;			INT	number_of_tiles_vertically )
1986  5897              ; will put ram in page 0 also, page 1 is already there
1987  5897              TILERAM:
1988  5897              	; opening (
1989  5897 CD 66 52     	CALL CHKCHAR
1990  589A 28           	DB '('
1991  589B              	; get tile data pointer coordinate
1992  589B DD 21 2F 54  	LD IX, FRMQNT
1993  589F CD 59 01     	CALL CALBAS
1994  58A2 ED 53 26 50  	LD (BLIT_STRUCT+0), DE
1995  58A6              	; comma
1996  58A6 CD 66 52     	CALL CHKCHAR
1997  58A9 2C           	DB ','
1998  58AA              	; get tile columns
1999  58AA DD 21 2F 54  	LD IX, FRMQNT
2000  58AE CD 59 01     	CALL CALBAS
2001  58B1 ED 53 2A 50  	LD (BLIT_STRUCT+4), DE
2002  58B5              	; comma
2003  58B5 CD 66 52     	CALL CHKCHAR
2004  58B8 2C           	DB ','
2005  58B9              	; get tile columns
2006  58B9 DD 21 2F 54  	LD IX, FRMQNT
2007  58BD CD 59 01     	CALL CALBAS
2008  58C0 ED 53 28 50  	LD (BLIT_STRUCT+2), DE
2009  58C4              	; comma
2010  58C4 CD 66 52     	CALL CHKCHAR
2011  58C7 2C           	DB ','
2012  58C8              	; get destintion pointer
2013  58C8 DD 21 2F 54  	LD IX, FRMQNT
2014  58CC CD 59 01     	CALL CALBAS
2015  58CF ED 53 2C 50  	LD (BLIT_STRUCT+6), DE
2016  58D3              	; comma
2017  58D3 CD 66 52     	CALL CHKCHAR
2018  58D6 2C           	DB ','
2019  58D7              	; get destination columns
2020  58D7 DD 21 2F 54  	LD IX, FRMQNT
2021  58DB CD 59 01     	CALL CALBAS
2022  58DE 7B           	LD A, E
2023  58DF 32 22 50     	LD (BLIT_TMP+0), A
2024  58E2              	; comma
2025  58E2 CD 66 52     	CALL CHKCHAR
2026  58E5 2C           	DB ','
2027  58E6              	; get destination rows
2028  58E6 DD 21 2F 54  	LD IX, FRMQNT
2029  58EA CD 59 01     	CALL CALBAS
2030  58ED 7B           	LD A, E
2031  58EE 32 23 50     	LD (BLIT_TMP+1), A
2032  58F1              	; comma
2033  58F1 CD 66 52     	CALL CHKCHAR
2034  58F4 2C           	DB ','
2035  58F5              	; get destination begin column
2036  58F5 DD 21 2F 54  	LD IX, FRMQNT
2037  58F9 CD 59 01     	CALL CALBAS
2038  58FC 7B           	LD A, E
2039  58FD 32 24 50     	LD (BLIT_TMP+2), A
2040  5900              	; comma
2041  5900 CD 66 52     	CALL CHKCHAR
2042  5903 2C           	DB ','
2043  5904              	; get destination begin row
2044  5904 DD 21 2F 54  	LD IX, FRMQNT
2045  5908 CD 59 01     	CALL CALBAS
2046  590B 7B           	LD A, E
2047  590C 32 25 50     	LD (BLIT_TMP+3), A
2048  590F              	; comma
2049  590F CD 66 52     	CALL CHKCHAR
2050  5912 2C           	DB ','
2051  5913              	; get number of tiles horizontally
2052  5913 DD 21 2F 54  	LD IX, FRMQNT
2053  5917 CD 59 01     	CALL CALBAS
2054  591A ED 53 30 50  	LD (BLIT_STRUCT+10), DE
2055  591E              	; comma
2056  591E CD 66 52     	CALL CHKCHAR
2057  5921 2C           	DB ','
2058  5922              	; get number of tiles vertically
2059  5922 DD 21 2F 54  	LD IX, FRMQNT
2060  5926 CD 59 01     	CALL CALBAS
2061  5929 ED 53 32 50  	LD (BLIT_STRUCT+12), DE
2062  592D              	; ending )
2063  592D CD 66 52     	CALL CHKCHAR
2064  5930 29           	DB ')'
2065  5931
2066  5931 E5           	PUSH HL ; save position in BASIC buffer
2067  5932
2068  5932              	; calculate destination add to value
2069  5932 26 00        	LD H, 0
2070  5934 3A 22 50     	LD A, (BLIT_TMP+0)
2071  5937 6F           	LD L, A
2072  5938 CD 55 51     	CALL HLx8
2073  593B 22 2E 50     	LD (BLIT_STRUCT+8), HL
2074  593E              	; calculate pointer to background location
2075  593E 21 00 00     	LD HL, 0
2076  5941 3A 25 50     	LD A,(BLIT_TMP+3)
2077  5944 B7           	OR A
2078  5945 28 08        	JR Z, .L1
2079  5947 47           	LD B,A
2080  5948 ED 5B 2E 50  	LD DE,(BLIT_STRUCT+8)
2081  594C              .L0:
2082  594C 19           	ADD HL, DE
2083  594D 10 FD        	DJNZ .L0
2084  594F              .L1:
2085  594F EB           	EX DE,HL
2086  5950 26 00        	LD H,0
2087  5952 3A 24 50     	LD A,(BLIT_TMP+2)
2088  5955 6F           	LD L,A
2089  5956 CD 55 51     	CALL HLx8
2090  5959 19           	ADD HL,DE
2091  595A ED 5B 2C 50  	LD DE,(BLIT_STRUCT+6)
2092  595E 19           	ADD HL,DE
2093  595F 22 2C 50     	LD (BLIT_STRUCT+6),HL
2094  5962
2095  5962 FD 21 69 59  	LD IY, .RET
2096  5966 C3 19 52     	JP ENABLE_PAGE0
2097  5969              .RET:
2098  5969 FB           	EI
2099  596A              	; set RAM functions to call
2100  596A 21 84 59     	LD HL, .TILECOPY
2101  596D 22 78 58     	LD (TILE.CALL2+1), HL
2102  5970 21 95 59     	LD HL, .SETDESTROW
2103  5973 22 6A 58     	LD (TILE.CALL1+1), HL
2104  5976 DD 21 26 50  	LD IX,BLIT_STRUCT
2105  597A CD 4F 58     	CALL TILE
2106  597D
2107  597D D1               POP DE
2108  597E C1               POP BC
2109  597F CD 90 51         CALL RESTORE_PAGE_INFO
2110  5982
2111  5982 E1           	POP HL
2112  5983 C9           	RET
2113  5984              .TILECOPY:
2114  5984 ED A0       > LDI
2114  5986 ED A0       > LDI
2114  5988 ED A0       > LDI
2114  598A ED A0       > LDI
2114  598C ED A0       > LDI
2114  598E ED A0       > LDI
2114  5990 ED A0       > LDI
2114  5992 ED A0       > LDI
2115  5994 C9           	RET
2116  5995              .SETDESTROW:
2117  5995 ED 5B 22 50  	LD DE, (TILETMP1)
2118  5999 C9           	RET
2119  599A              ; *******************************************************************************************************
2120  599A               ENDIF
2121  599A
2122  599A               IFDEF CMDS_WITH_PARAMETERS
2123  599A              ; *******************************************************************************************************
2124  599A              ; function to handle CALL TILEVRM basic extension
2125  599A              ; fills vram with tiles
2126  599A              ; TILEVRM ( INT tile_data_pointer,
2127  599A              ;			INT tile_columns,
2128  599A              ;			INT tile_rows,
2129  599A              ;			INT destination_begin_column,
2130  599A              ;			INT destination_begin_row,
2131  599A              ;			INT number_of_tiles_horizontally,
2132  599A              ;			INT	number_of_tiles_vertically )
2133  599A              ; will put ram in page 0 also, page 1 is already there
2134  599A              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
2135  599A              TILEVRM:
2136  599A              	; opening (
2137  599A CD 66 52     	CALL CHKCHAR
2138  599D 28           	DB '('
2139  599E              	; get tile data pointer coordinate
2140  599E DD 21 2F 54  	LD IX, FRMQNT
2141  59A2 CD 59 01     	CALL CALBAS
2142  59A5 ED 53 26 50  	LD (BLIT_STRUCT+0), DE
2143  59A9              	; comma
2144  59A9 CD 66 52     	CALL CHKCHAR
2145  59AC 2C           	DB ','
2146  59AD              	; get tile columns
2147  59AD DD 21 2F 54  	LD IX, FRMQNT
2148  59B1 CD 59 01     	CALL CALBAS
2149  59B4 ED 53 2A 50  	LD (BLIT_STRUCT+4), DE
2150  59B8              	; comma
2151  59B8 CD 66 52     	CALL CHKCHAR
2152  59BB 2C           	DB ','
2153  59BC              	; get tile columns
2154  59BC DD 21 2F 54  	LD IX, FRMQNT
2155  59C0 CD 59 01     	CALL CALBAS
2156  59C3 ED 53 28 50  	LD (BLIT_STRUCT+2), DE
2157  59C7              	; comma
2158  59C7 CD 66 52     	CALL CHKCHAR
2159  59CA 2C           	DB ','
2160  59CB              	; get destination begin column
2161  59CB DD 21 2F 54  	LD IX, FRMQNT
2162  59CF CD 59 01     	CALL CALBAS
2163  59D2 7B           	LD A, E
2164  59D3 32 24 50     	LD (BLIT_TMP+2), A
2165  59D6              	; comma
2166  59D6 CD 66 52     	CALL CHKCHAR
2167  59D9 2C           	DB ','
2168  59DA              	; get destination begin row
2169  59DA DD 21 2F 54  	LD IX, FRMQNT
2170  59DE CD 59 01     	CALL CALBAS
2171  59E1 7B           	LD A, E
2172  59E2 32 25 50     	LD (BLIT_TMP+3), A
2173  59E5              	; comma
2174  59E5 CD 66 52     	CALL CHKCHAR
2175  59E8 2C           	DB ','
2176  59E9              	; get number of tiles horizontally
2177  59E9 DD 21 2F 54  	LD IX, FRMQNT
2178  59ED CD 59 01     	CALL CALBAS
2179  59F0 ED 53 30 50  	LD (BLIT_STRUCT+10), DE
2180  59F4              	; comma
2181  59F4 CD 66 52     	CALL CHKCHAR
2182  59F7 2C           	DB ','
2183  59F8              	; get number of tiles vertically
2184  59F8 DD 21 2F 54  	LD IX, FRMQNT
2185  59FC CD 59 01     	CALL CALBAS
2186  59FF ED 53 32 50  	LD (BLIT_STRUCT+12), DE
2187  5A03              	; ending )
2188  5A03 CD 66 52     	CALL CHKCHAR
2189  5A06 29           	DB ')'
2190  5A07
2191  5A07 E5           	PUSH HL ; save position in BASIC buffer
2192  5A08
2193  5A08              	; calculate destination add to value
2194  5A08 21 00 01     	LD HL, 256
2195  5A0B 22 2E 50     	LD (BLIT_STRUCT+8), HL
2196  5A0E              	; calculate pointer to background location
2197  5A0E 3A 25 50     	LD A,(BLIT_TMP+3)
2198  5A11 67           	LD H,A
2199  5A12 2E 00        	LD L,0
2200  5A14 EB           	EX DE,HL
2201  5A15 26 00        	LD H,0
2202  5A17 3A 24 50     	LD A,(BLIT_TMP+2)
2203  5A1A 6F           	LD L,A
2204  5A1B CD 55 51     	CALL HLx8
2205  5A1E 19           	ADD HL,DE
2206  5A1F ED 5B CB F3  	LD DE,(GRPCGP)
2207  5A23 19           	ADD HL,DE
2208  5A24 22 2C 50     	LD (BLIT_STRUCT+6),HL
2209  5A27
2210  5A27 FD 21 2E 5A  	LD IY, .RET
2211  5A2B C3 19 52     	JP ENABLE_PAGE0
2212  5A2E              .RET:
2213  5A2E FB           	EI
2214  5A2F              	; set RAM functions to call
2215  5A2F 21 49 5A     	LD HL, .TILECOPY
2216  5A32 22 78 58     	LD (TILE.CALL2+1), HL
2217  5A35 21 4F 5A     	LD HL, .SETDESTROW
2218  5A38 22 6A 58     	LD (TILE.CALL1+1), HL
2219  5A3B DD 21 26 50  	LD IX,BLIT_STRUCT
2220  5A3F CD 4F 58     	CALL TILE
2221  5A42
2222  5A42 D1               POP DE
2223  5A43 C1               POP BC
2224  5A44 CD 90 51         CALL RESTORE_PAGE_INFO
2225  5A47
2226  5A47 E1           	POP HL
2227  5A48 C9           	RET
2228  5A49              .TILECOPY:
2229  5A49 01 98 08     	LD BC, #0898
2230  5A4C C3 4F 51     	JP BBYTECOPY
2231  5A4F              .SETDESTROW:
2232  5A4F 2A 22 50     	LD HL, (TILETMP1)
2233  5A52 F3           	DI
2234  5A53 CD 44 51     	CALL SETWRT_LOCAL
2235  5A56 FB           	EI
2236  5A57 C9           	RET
2237  5A58              ; *******************************************************************************************************
2238  5A58               ENDIF
2239  5A58
2240  5A58               IFNDEF CMDS_WITH_PARAMETERS
2241  5A58 ~            ; *******************************************************************************************************
2242  5A58 ~            ; function to handle CALL TILEVRM basic extension
2243  5A58 ~            ; fills vram with tiles
2244  5A58 ~            ; TILEVRM ( INT request_data_ptr )
2245  5A58 ~            ; request_data_ptr described in TILE
2246  5A58 ~            ; will put ram in page 0 also, page 1 is already there
2247  5A58 ~            TILEVRM:
2248  5A58 ~            	; opening (
2249  5A58 ~            	CALL CHKCHAR
2250  5A58 ~            	DB '('
2251  5A58 ~            	; get pointer to request struct
2252  5A58 ~            	LD IX, FRMQNT
2253  5A58 ~            	CALL CALBAS
2254  5A58 ~            	PUSH DE
2255  5A58 ~            	; ending )
2256  5A58 ~            	CALL CHKCHAR
2257  5A58 ~            	DB ')'
2258  5A58 ~
2259  5A58 ~            	POP IX ; pointer to request struct
2260  5A58 ~
2261  5A58 ~            	PUSH HL ; save position in BASIC buffer
2262  5A58 ~
2263  5A58 ~            	LD IY, .RET
2264  5A58 ~            	JP ENABLE_PAGE0
2265  5A58 ~            .RET:
2266  5A58 ~            	EI
2267  5A58 ~            	; set RAM functions to call
2268  5A58 ~            	LD HL, .TILECOPY
2269  5A58 ~            	LD (TILE.CALL2+1), HL
2270  5A58 ~            	LD HL, .SETDESTROW
2271  5A58 ~            	LD (TILE.CALL1+1), HL
2272  5A58 ~            	CALL TILE
2273  5A58 ~
2274  5A58 ~                POP DE
2275  5A58 ~                POP BC
2276  5A58 ~                CALL RESTORE_PAGE_INFO
2277  5A58 ~
2278  5A58 ~            	POP HL
2279  5A58 ~            	RET
2280  5A58 ~            .TILECOPY:
2281  5A58 ~            	LD BC, #0898
2282  5A58 ~            	JP BBYTECOPY
2283  5A58 ~            .SETDESTROW:
2284  5A58 ~            	LD HL, (TILETMP1)
2285  5A58 ~            	DI
2286  5A58 ~            	CALL SETWRT_LOCAL
2287  5A58 ~            	EI
2288  5A58 ~            	RET
2289  5A58 ~            ; *******************************************************************************************************
2290  5A58               ENDIF
2291  5A58               ENDIF
2292  5A58
2293  5A58               IF (BOX_CMDS == 1)
2294  5A58              ; *******************************************************************************************************
2295  5A58              ; generic function to implement rectangle data copy
2296  5A58              ; should be modified to call appropriate function for memory or vram
2297  5A58              ; input IX=pointer to following structure
2298  5A58              ; +00 source data pointer
2299  5A58              ; +02 num bytes in a row
2300  5A58              ; +04 number of rows
2301  5A58              ; +06 source add-to value till next row
2302  5A58              ; +08 destination address
2303  5A58              ; +10 destination add-to value till next row
2304  5A58              ; modifies AF, BC, DE, HL
2305  5A58              RECTANGLE_COPY:
2306  5A58 DD 6E 00     	LD L, (IX+0)
2307  5A5B DD 66 01     	LD H, (IX+1) ; source address
2308  5A5E DD 5E 08     	LD E, (IX+8)
2309  5A61 DD 56 09     	LD D, (IX+9) ; destination
2310  5A64 DD 46 04     	LD B, (IX+4) ; row number
2311  5A67              .L1:
2312  5A67 C5           	PUSH BC
2313  5A68 E5           		PUSH HL
2314  5A69 D5           			PUSH DE
2315  5A6A DD 4E 02     				LD C, (IX+2)
2316  5A6D DD 46 03     				LD B, (IX+3) ; num bytes in a row
2317  5A70              .CALL1:
2318  5A70 CD 00 00     				CALL 0 ; set destination address from DE
2319  5A73              .CALL2:
2320  5A73 CD 00 00     				CALL 0 ; copy data fn
2321  5A76 E1           			POP HL
2322  5A77 DD 4E 0A     			LD C, (IX+10)
2323  5A7A DD 46 0B     			LD B, (IX+11) ; destination add-to
2324  5A7D 09           			ADD HL, BC
2325  5A7E EB           			EX DE, HL
2326  5A7F E1           		POP HL
2327  5A80 DD 4E 06     		LD C, (IX+6)
2328  5A83 DD 46 07     		LD B, (IX+7) ; src add-to
2329  5A86 09           		ADD HL, BC
2330  5A87 C1           	POP BC
2331  5A88 10 DD        	DJNZ .L1
2332  5A8A C9           	RET
2333  5A8B              ; *******************************************************************************************************
2334  5A8B
2335  5A8B              ; *******************************************************************************************************
2336  5A8B              ; function to handle CALL BOXMEMCPY basic extension
2337  5A8B              ; copies data with window like boundaries to ram
2338  5A8B              ; BOXMEMCPY ( INT request_data_ptr )
2339  5A8B              ; request_data_ptr described in RECTANGLE_COPY
2340  5A8B              ; will put ram in page 0 also, page 1 is already there
2341  5A8B              BOXMEMCPY:
2342  5A8B              	; opening (
2343  5A8B CD 66 52     	CALL CHKCHAR
2344  5A8E 28           	DB '('
2345  5A8F              	; get pointer to request struct
2346  5A8F DD 21 2F 54  	LD IX, FRMQNT
2347  5A93 CD 59 01     	CALL CALBAS
2348  5A96 D5           	PUSH DE
2349  5A97              	; ending )
2350  5A97 CD 66 52     	CALL CHKCHAR
2351  5A9A 29           	DB ')'
2352  5A9B
2353  5A9B DD E1        	POP IX ; pointer to request struct
2354  5A9D
2355  5A9D E5           	PUSH HL ; save position in BASIC buffer
2356  5A9E
2357  5A9E FD 21 A5 5A  	LD IY, .RET
2358  5AA2 C3 19 52     	JP ENABLE_PAGE0
2359  5AA5              .RET:
2360  5AA5 FB           	EI
2361  5AA6              	; set RAM functions to call
2362  5AA6 21 00 00     	LD HL, 0
2363  5AA9 22 70 5A     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
2364  5AAC 22 72 5A     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
2365  5AAF 21 ED B0     	LD HL, #B0ED ; LDIR
2366  5AB2 22 74 5A     	LD (RECTANGLE_COPY.CALL1+4), HL
2367  5AB5 CD 58 5A     	CALL RECTANGLE_COPY
2368  5AB8
2369  5AB8 D1               POP DE
2370  5AB9 C1               POP BC
2371  5ABA CD 90 51         CALL RESTORE_PAGE_INFO
2372  5ABD
2373  5ABD E1           	POP HL
2374  5ABE C9           	RET
2375  5ABF              ; *******************************************************************************************************
2376  5ABF
2377  5ABF              ; *******************************************************************************************************
2378  5ABF              ; function to handle CALL BOXMEMVRM basic extension
2379  5ABF              ; copies data with window like boundaries to ram
2380  5ABF              ; BOXMEMVRM ( INT request_data_ptr )
2381  5ABF              ; request_data_ptr described in RECTANGLE_COPY
2382  5ABF              ; will put ram in page 0 also, page 1 is already there
2383  5ABF              BOXMEMVRM:
2384  5ABF              	; opening (
2385  5ABF CD 66 52     	CALL CHKCHAR
2386  5AC2 28           	DB '('
2387  5AC3              	; get pointer to request struct
2388  5AC3 DD 21 2F 54  	LD IX, FRMQNT
2389  5AC7 CD 59 01     	CALL CALBAS
2390  5ACA D5           	PUSH DE
2391  5ACB              	; ending )
2392  5ACB CD 66 52     	CALL CHKCHAR
2393  5ACE 29           	DB ')'
2394  5ACF
2395  5ACF DD E1        	POP IX ; pointer to request struct
2396  5AD1
2397  5AD1 E5           	PUSH HL ; save position in BASIC buffer
2398  5AD2
2399  5AD2 FD 21 D9 5A  	LD IY, .RET
2400  5AD6 C3 19 52     	JP ENABLE_PAGE0
2401  5AD9              .RET:
2402  5AD9 FB           	EI
2403  5ADA              	; set RAM functions to call
2404  5ADA 21 F8 5A     	LD HL, .SETDEST
2405  5ADD 22 71 5A     	LD (RECTANGLE_COPY.CALL1+1), HL
2406  5AE0 21 00 5B     	LD HL, .COPYDATA
2407  5AE3 22 74 5A     	LD (RECTANGLE_COPY.CALL2+1), HL
2408  5AE6 3E CD        	LD A, #CD ; CALL
2409  5AE8 32 70 5A     	LD (RECTANGLE_COPY.CALL1), A
2410  5AEB 32 73 5A     	LD (RECTANGLE_COPY.CALL2), A
2411  5AEE CD 58 5A     	CALL RECTANGLE_COPY
2412  5AF1
2413  5AF1 D1               POP DE
2414  5AF2 C1               POP BC
2415  5AF3 CD 90 51         CALL RESTORE_PAGE_INFO
2416  5AF6
2417  5AF6 E1           	POP HL
2418  5AF7 C9           	RET
2419  5AF8              .SETDEST:
2420  5AF8 EB           	EX DE, HL
2421  5AF9 F3           	DI
2422  5AFA CD 44 51     	CALL SETWRT_LOCAL
2423  5AFD FB           	EI
2424  5AFE EB           	EX DE, HL
2425  5AFF C9           	RET
2426  5B00              .COPYDATA:
2427  5B00 41           	LD B, C
2428  5B01 0E 98        	LD C, #98
2429  5B03 C3 4F 51     	JP BBYTECOPY
2430  5B06              ; *******************************************************************************************************
2431  5B06               ENDIF
2432  5B06
2433  5B06              EXT_END:
2434  5B06
# file closed: asm\main.asm
